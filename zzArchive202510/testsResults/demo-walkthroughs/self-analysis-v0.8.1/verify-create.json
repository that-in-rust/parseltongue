[
  {
    "isgl1_key": "rust:fn:action:______crates_parseltongue-core_src_temporal_rs:415-418",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "action",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 415,
        "end": 418
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn action(mut self, action: TemporalAction) -> Self {\n        self.action = Some(action);\n        self\n    }",
    "future_code": "    pub fn action(mut self, action: TemporalAction) -> Self {\n        self.action = Some(action);\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435957Z",
      "modified_at": "2025-11-01T15:29:24.435958Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:add_change:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:145-153",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "add_change",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 145,
        "end": 153
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn add_change(&mut self, change: Change) {\n        match change.operation {\n            Operation::Create => self.metadata.create_count += 1,\n            Operation::Edit => self.metadata.edit_count += 1,\n            Operation::Delete => self.metadata.delete_count += 1,\n        }\n        self.metadata.total_changes += 1;\n        self.changes.push(change);\n    }",
    "future_code": "    pub fn add_change(&mut self, change: Change) {\n        match change.operation {\n            Operation::Create => self.metadata.create_count += 1,\n            Operation::Edit => self.metadata.edit_count += 1,\n            Operation::Delete => self.metadata.delete_count += 1,\n        }\n        self.metadata.total_changes += 1;\n        self.changes.push(change);\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435960Z",
      "modified_at": "2025-11-01T15:29:24.435960Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:add_entity:______crates_parseltongue-core_src_temporal_rs:42-53",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "add_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 42,
        "end": 53
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn add_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        // Validate entity\n        entity.validate()?;\n\n        // Check for conflicts with existing entity\n        if let Some(existing) = self.entities.get(&entity.isgl1_key) {\n            self.validate_entity_compatibility(existing, &entity)?;\n        }\n\n        self.entities.insert(entity.isgl1_key.clone(), entity);\n        Ok(())\n    }",
    "future_code": "    pub fn add_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        // Validate entity\n        entity.validate()?;\n\n        // Check for conflicts with existing entity\n        if let Some(existing) = self.entities.get(&entity.isgl1_key) {\n            self.validate_entity_compatibility(existing, &entity)?;\n        }\n\n        self.entities.insert(entity.isgl1_key.clone(), entity);\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435962Z",
      "modified_at": "2025-11-01T15:29:24.435962Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:add_response:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:113-115",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "add_response",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 113,
        "end": 115
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn add_response(&mut self, key: String, response: HoverResponse) {\n        self.responses.insert(key, response);\n    }",
    "future_code": "    pub fn add_response(&mut self, key: String, response: HoverResponse) {\n        self.responses.insert(key, response);\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435963Z",
      "modified_at": "2025-11-01T15:29:24.435963Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:add_result:______crates_pt04-syntax-preflight-validator_src_types_rs:130-135",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "add_result",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 130,
        "end": 135
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn add_result(&mut self, result: ValidationOutput) {\n        self.overall_valid = self.overall_valid && result.is_valid;\n        self.total_execution_time_ms += result.execution_time_ms;\n        self.total_memory_usage_bytes += result.memory_usage_bytes;\n        self.individual_results.push(result);\n    }",
    "future_code": "    pub fn add_result(&mut self, result: ValidationOutput) {\n        self.overall_valid = self.overall_valid && result.is_valid;\n        self.total_execution_time_ms += result.execution_time_ms;\n        self.total_memory_usage_bytes += result.memory_usage_bytes;\n        self.individual_results.push(result);\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435964Z",
      "modified_at": "2025-11-01T15:29:24.435964Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:add_result:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:86-99",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "add_result",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 86,
        "end": 99
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn add_result(&mut self, result: &WriteResult) {\n        if !result.success {\n            self.errors += 1;\n            return;\n        }\n\n        match result.operation {\n            WriteOperation::Create => self.created += 1,\n            WriteOperation::Edit => self.edited += 1,\n            WriteOperation::Delete => self.deleted += 1,\n            WriteOperation::NoOp => {}\n        }\n        self.total += 1;\n    }",
    "future_code": "    pub fn add_result(&mut self, result: &WriteResult) {\n        if !result.success {\n            self.errors += 1;\n            return;\n        }\n\n        match result.operation {\n            WriteOperation::Create => self.created += 1,\n            WriteOperation::Edit => self.edited += 1,\n            WriteOperation::Delete => self.deleted += 1,\n            WriteOperation::NoOp => {}\n        }\n        self.total += 1;\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435965Z",
      "modified_at": "2025-11-01T15:29:24.435965Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:all:______crates_pt04-syntax-preflight-validator_src_types_rs:24-32",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "all",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 24,
        "end": 32
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn all() -> Vec<Self> {\n        vec![\n            Self::Syntax,\n            Self::Type,\n            Self::BorrowChecker,\n            Self::Compilation,\n            Self::Test,\n        ]\n    }",
    "future_code": "    pub fn all() -> Vec<Self> {\n        vec![\n            Self::Syntax,\n            Self::Type,\n            Self::BorrowChecker,\n            Self::Compilation,\n            Self::Test,\n        ]\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435967Z",
      "modified_at": "2025-11-01T15:29:24.435967Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:all_errors:______crates_pt04-syntax-preflight-validator_src_types_rs:138-143",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "all_errors",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 138,
        "end": 143
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn all_errors(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.errors.iter().cloned())\n            .collect()\n    }",
    "future_code": "    pub fn all_errors(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.errors.iter().cloned())\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435968Z",
      "modified_at": "2025-11-01T15:29:24.435968Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:all_warnings:______crates_pt04-syntax-preflight-validator_src_types_rs:146-151",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "all_warnings",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 146,
        "end": 151
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn all_warnings(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.warnings.iter().cloned())\n            .collect()\n    }",
    "future_code": "    pub fn all_warnings(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.warnings.iter().cloned())\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435969Z",
      "modified_at": "2025-11-01T15:29:24.435969Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:apply_changes:______crates_parseltongue-core_src_temporal_rs:56-82",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "apply_changes",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 56,
        "end": 82
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn apply_changes(&mut self, changes: Vec<TemporalChange>) -> Result<Vec<String>> {\n        let mut affected_entities = Vec::new();\n\n        for change in changes {\n            let isgl1_key = &change.isgl1_key;\n\n            // Validate change\n            self.validate_temporal_change(&change)?;\n\n            // Apply change to entity\n            if let Some(entity) = self.entities.get_mut(isgl1_key) {\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                affected_entities.push(isgl1_key.clone());\n            } else {\n                // Entity doesn't exist, create new one\n                let mut entity = self.create_entity_for_change(&change)?;\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                self.entities.insert(isgl1_key.clone(), entity);\n                affected_entities.push(isgl1_key.clone());\n            }\n        }\n\n        // Run validation rules\n        self.run_validation_rules()?;\n\n        Ok(affected_entities)\n    }",
    "future_code": "    pub fn apply_changes(&mut self, changes: Vec<TemporalChange>) -> Result<Vec<String>> {\n        let mut affected_entities = Vec::new();\n\n        for change in changes {\n            let isgl1_key = &change.isgl1_key;\n\n            // Validate change\n            self.validate_temporal_change(&change)?;\n\n            // Apply change to entity\n            if let Some(entity) = self.entities.get_mut(isgl1_key) {\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                affected_entities.push(isgl1_key.clone());\n            } else {\n                // Entity doesn't exist, create new one\n                let mut entity = self.create_entity_for_change(&change)?;\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                self.entities.insert(isgl1_key.clone(), entity);\n                affected_entities.push(isgl1_key.clone());\n            }\n        }\n\n        // Run validation rules\n        self.run_validation_rules()?;\n\n        Ok(affected_entities)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435971Z",
      "modified_at": "2025-11-01T15:29:24.435971Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:apply_temporal_change:______crates_parseltongue-core_src_entities_rs:628-650",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "apply_temporal_change",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 628,
        "end": 650
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn apply_temporal_change(\n        &mut self,\n        action: TemporalAction,\n        future_code: Option<String>,\n    ) -> Result<()> {\n        match action {\n            TemporalAction::Create => {\n                self.temporal_state = TemporalState::create();\n                self.future_code = future_code;\n            }\n            TemporalAction::Edit => {\n                self.temporal_state = TemporalState::edit();\n                self.future_code = future_code;\n            }\n            TemporalAction::Delete => {\n                self.temporal_state = TemporalState::delete();\n                self.future_code = None;\n            }\n        }\n\n        self.temporal_state.validate()?;\n        Ok(())\n    }",
    "future_code": "    pub fn apply_temporal_change(\n        &mut self,\n        action: TemporalAction,\n        future_code: Option<String>,\n    ) -> Result<()> {\n        match action {\n            TemporalAction::Create => {\n                self.temporal_state = TemporalState::create();\n                self.future_code = future_code;\n            }\n            TemporalAction::Edit => {\n                self.temporal_state = TemporalState::edit();\n                self.future_code = future_code;\n            }\n            TemporalAction::Delete => {\n                self.temporal_state = TemporalState::delete();\n                self.future_code = None;\n            }\n        }\n\n        self.temporal_state.validate()?;\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435972Z",
      "modified_at": "2025-11-01T15:29:24.435972Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:as_ref:______crates_parseltongue-core_src_entities_rs:895-897",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "as_ref",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 895,
        "end": 897
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn as_ref(&self) -> &str {\n        &self.0\n    }",
    "future_code": "    fn as_ref(&self) -> &str {\n        &self.0\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435974Z",
      "modified_at": "2025-11-01T15:29:24.435974Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:as_str:______crates_parseltongue-core_src_entities_rs:883-885",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "as_str",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 883,
        "end": 885
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn as_str(&self) -> &str {\n        &self.0\n    }",
    "future_code": "    pub fn as_str(&self) -> &str {\n        &self.0\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435975Z",
      "modified_at": "2025-11-01T15:29:24.435975Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:as_str:______crates_parseltongue-core_src_entities_rs:931-937",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "as_str",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 931,
        "end": 937
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn as_str(self) -> &'static str {\n        match self {\n            Self::Calls => \"Calls\",\n            Self::Uses => \"Uses\",\n            Self::Implements => \"Implements\",\n        }\n    }",
    "future_code": "    pub fn as_str(self) -> &'static str {\n        match self {\n            Self::Calls => \"Calls\",\n            Self::Uses => \"Uses\",\n            Self::Implements => \"Implements\",\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435976Z",
      "modified_at": "2025-11-01T15:29:24.435976Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:attempt_merge:______crates_parseltongue-core_src_temporal_rs:560-566",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "attempt_merge",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 560,
        "end": 566
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn attempt_merge(&self, _changes: Vec<TemporalChange>, _conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        // Simplified merge implementation\n        // In a real implementation, this would be more sophisticated\n        Err(ParseltongError::TemporalError {\n            details: \"Merge conflict resolution not yet implemented\".to_string(),\n        })\n    }",
    "future_code": "    fn attempt_merge(&self, _changes: Vec<TemporalChange>, _conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        // Simplified merge implementation\n        // In a real implementation, this would be more sophisticated\n        Err(ParseltongError::TemporalError {\n            details: \"Merge conflict resolution not yet implemented\".to_string(),\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435977Z",
      "modified_at": "2025-11-01T15:29:24.435977Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build:______crates_parseltongue-core_src_entities_rs:1063-1082",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1063,
        "end": 1082
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build(self) -> Result<DependencyEdge> {\n        DependencyEdge::new(\n            self.from_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"from_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.to_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"to_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.edge_type.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"EdgeType\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.source_location,\n        )\n    }",
    "future_code": "    pub fn build(self) -> Result<DependencyEdge> {\n        DependencyEdge::new(\n            self.from_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"from_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.to_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"to_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.edge_type.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"EdgeType\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.source_location,\n        )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435978Z",
      "modified_at": "2025-11-01T15:29:24.435978Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build:______crates_parseltongue-core_src_temporal_rs:433-444",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 433,
        "end": 444
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build(self) -> Result<TemporalChange> {\n        let action = self.action.ok_or_else(|| ParseltongError::TemporalError {\n            details: \"Temporal action is required\".to_string(),\n        })?;\n\n        Ok(TemporalChange {\n            isgl1_key: self.isgl1_key,\n            action,\n            future_code: self.future_code,\n            updated_signature: self.updated_signature,\n        })\n    }",
    "future_code": "    pub fn build(self) -> Result<TemporalChange> {\n        let action = self.action.ok_or_else(|| ParseltongError::TemporalError {\n            details: \"Temporal action is required\".to_string(),\n        })?;\n\n        Ok(TemporalChange {\n            isgl1_key: self.isgl1_key,\n            action,\n            future_code: self.future_code,\n            updated_signature: self.updated_signature,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435979Z",
      "modified_at": "2025-11-01T15:29:24.435979Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build_cli:______crates_parseltongue_src_main_rs:59-203",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build_cli",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 59,
        "end": 203
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn build_cli() -> Command {\n    Command::new(\"parseltongue\")\n        .version(\"1.0.0\")\n        .author(\"Parseltongue Team\")\n        .about(\"Ultra-minimalist CLI toolkit for code analysis and modification\")\n        .subcommand_required(false)\n        .arg_required_else_help(false)\n        .subcommand(\n            Command::new(\"pt01-folder-to-cozodb-streamer\")\n                .about(\"Tool 1: Stream folder contents to CozoDB with ISGL1 keys\")\n                .long_about(\n                    \"Examples:\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer .            # Index current directory\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer ./src --db rocksdb:analysis.db --verbose\"\n                )\n                .arg(\n                    Arg::new(\"directory\")\n                        .help(\"Directory to index [default: current directory]\")\n                        .default_value(\".\")\n                        .index(1),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Enable verbose output\")\n                        .action(clap::ArgAction::SetTrue),\n                )\n                .arg(\n                    Arg::new(\"quiet\")\n                        .long(\"quiet\")\n                        .short('q')\n                        .help(\"Suppress output\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt02-llm-cozodb-to-context-writer\")\n                .about(\"Tool 2: Generate context JSON from CozoDB for LLM consumption\")\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"filter\")\n                        .long(\"filter\")\n                        .help(\"Filter: all, changed, or current\")\n                        .value_parser([\"all\", \"changed\", \"current\"])\n                        .default_value(\"all\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt03-llm-to-cozodb-writer\")\n                .about(\"Tool 3: Write LLM-proposed changes to temporal state\")\n                .arg(\n                    Arg::new(\"entity\")\n                        .long(\"entity\")\n                        .help(\"ISGL1 key of entity\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"action\")\n                        .long(\"action\")\n                        .help(\"Action type: create, edit, or delete\")\n                        .value_parser([\"create\", \"edit\", \"delete\"])\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"future-code\")\n                        .long(\"future-code\")\n                        .help(\"Future code content (required for create/edit)\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt04-syntax-preflight-validator\")\n                .about(\"Tool 4: Validate syntax of proposed changes\")\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show detailed errors\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt05-llm-cozodb-to-diff-writer\")\n                .about(\"Tool 5: Generate CodeDiff.json from temporal state\")\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt06-cozodb-make-future-code-current\")\n                .about(\"Tool 6: Make future code current and reset temporal state\")\n                .arg(\n                    Arg::new(\"project\")\n                        .long(\"project\")\n                        .help(\"Project root directory\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n}",
    "future_code": "fn build_cli() -> Command {\n    Command::new(\"parseltongue\")\n        .version(\"1.0.0\")\n        .author(\"Parseltongue Team\")\n        .about(\"Ultra-minimalist CLI toolkit for code analysis and modification\")\n        .subcommand_required(false)\n        .arg_required_else_help(false)\n        .subcommand(\n            Command::new(\"pt01-folder-to-cozodb-streamer\")\n                .about(\"Tool 1: Stream folder contents to CozoDB with ISGL1 keys\")\n                .long_about(\n                    \"Examples:\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer .            # Index current directory\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer ./src --db rocksdb:analysis.db --verbose\"\n                )\n                .arg(\n                    Arg::new(\"directory\")\n                        .help(\"Directory to index [default: current directory]\")\n                        .default_value(\".\")\n                        .index(1),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Enable verbose output\")\n                        .action(clap::ArgAction::SetTrue),\n                )\n                .arg(\n                    Arg::new(\"quiet\")\n                        .long(\"quiet\")\n                        .short('q')\n                        .help(\"Suppress output\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt02-llm-cozodb-to-context-writer\")\n                .about(\"Tool 2: Generate context JSON from CozoDB for LLM consumption\")\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"filter\")\n                        .long(\"filter\")\n                        .help(\"Filter: all, changed, or current\")\n                        .value_parser([\"all\", \"changed\", \"current\"])\n                        .default_value(\"all\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt03-llm-to-cozodb-writer\")\n                .about(\"Tool 3: Write LLM-proposed changes to temporal state\")\n                .arg(\n                    Arg::new(\"entity\")\n                        .long(\"entity\")\n                        .help(\"ISGL1 key of entity\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"action\")\n                        .long(\"action\")\n                        .help(\"Action type: create, edit, or delete\")\n                        .value_parser([\"create\", \"edit\", \"delete\"])\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"future-code\")\n                        .long(\"future-code\")\n                        .help(\"Future code content (required for create/edit)\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt04-syntax-preflight-validator\")\n                .about(\"Tool 4: Validate syntax of proposed changes\")\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show detailed errors\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt05-llm-cozodb-to-diff-writer\")\n                .about(\"Tool 5: Generate CodeDiff.json from temporal state\")\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt06-cozodb-make-future-code-current\")\n                .about(\"Tool 6: Make future code current and reset temporal state\")\n                .arg(\n                    Arg::new(\"project\")\n                        .long(\"project\")\n                        .help(\"Project root directory\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435981Z",
      "modified_at": "2025-11-01T15:29:24.435981Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build_cli:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:32-71",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build_cli",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 32,
        "end": 71
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-01\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 01: folder-to-cozoDB-streamer\")\n            .long_about(\n                \"Ultra-minimalist streaming tool that reads code files from a directory,\\n\\\n                generates ISGL1 keys using tree-sitter, and stores them in CozoDB.\\n\\\n                \\n\\\n                Following TDD-first principles with executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"directory\")\n                    .help(\"Directory to index\")\n                    .required(true)\n                    .index(1),\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database connection string (use 'mem' for in-memory)\")\n                    .default_value(\"mem\"),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n    }",
    "future_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-01\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 01: folder-to-cozoDB-streamer\")\n            .long_about(\n                \"Ultra-minimalist streaming tool that reads code files from a directory,\\n\\\n                generates ISGL1 keys using tree-sitter, and stores them in CozoDB.\\n\\\n                \\n\\\n                Following TDD-first principles with executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"directory\")\n                    .help(\"Directory to index\")\n                    .required(true)\n                    .index(1),\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database connection string (use 'mem' for in-memory)\")\n                    .default_value(\"mem\"),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435982Z",
      "modified_at": "2025-11-01T15:29:24.435983Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build_cli:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:12-157",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build_cli",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 12,
        "end": 157
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-03\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 03: LLM-cozoDB-to-context-writer\")\n            .long_about(\n                \"Ultra-minimalist context optimization tool that reads entity graphs from CozoDB,\\\\n\\\\\\n                generates optimized CodeGraphContext.json files using LLM reasoning, and writes\\\\n\\\\\\n                them for consumption by other tools. Following TDD-first principles with\\\\n\\\\\\n                executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .short('b')\n                    .long(\"db\")\n                    .alias(\"database\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            .arg(\n                Arg::new(\"endpoint\")\n                    .short('e')\n                    .long(\"endpoint\")\n                    .value_name(\"URL\")\n                    .help(\"LLM API endpoint\")\n                    .default_value(\"https://api.openai.com/v1/chat/completions\"),\n            )\n            .arg(\n                Arg::new(\"api-key\")\n                    .short('k')\n                    .long(\"api-key\")\n                    .value_name(\"KEY\")\n                    .help(\"LLM API key (or set OPENAI_API_KEY env var)\"),\n            )\n            .arg(\n                Arg::new(\"model\")\n                    .short('m')\n                    .long(\"model\")\n                    .value_name(\"MODEL\")\n                    .help(\"LLM model to use\")\n                    .default_value(\"gpt-4\"),\n            )\n            .arg(\n                Arg::new(\"max-tokens\")\n                    .short('t')\n                    .long(\"max-tokens\")\n                    .value_name(\"TOKENS\")\n                    .help(\"Maximum tokens per request\")\n                    .value_parser(clap::value_parser!(usize))\n                    .default_value(\"8192\"),\n            )\n            .arg(\n                Arg::new(\"temperature\")\n                    .short('T')\n                    .long(\"temperature\")\n                    .value_name(\"TEMP\")\n                    .help(\"Temperature for LLM generation (0.0-1.0)\")\n                    .value_parser(clap::value_parser!(f32))\n                    .default_value(\"0.3\"),\n            )\n            .arg(\n                Arg::new(\"query\")\n                    .short('q')\n                    .long(\"query\")\n                    .value_name(\"QUERY\")\n                    .help(\"CozoDB query for context extraction (PRD: excludes Current_Code/Future_Code)\")\n                    .default_value(\"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\"),\n            )\n            .arg(\n                Arg::new(\"max-context-tokens\")\n                    .short('c')\n                    .long(\"max-context-tokens\")\n                    .value_name(\"TOKENS\")\n                    .help(\"Maximum context size in tokens\")\n                    .value_parser(clap::value_parser!(usize))\n                    .default_value(\"128000\"),\n            )\n            .arg(\n                Arg::new(\"relevance-threshold\")\n                    .short('r')\n                    .long(\"relevance-threshold\")\n                    .value_name(\"THRESHOLD\")\n                    .help(\"Relevance threshold for entity inclusion (0.0-1.0)\")\n                    .value_parser(clap::value_parser!(f32))\n                    .default_value(\"0.7\"),\n            )\n            .arg(\n                Arg::new(\"output\")\n                    .short('o')\n                    .long(\"output\")\n                    .value_name(\"PATH\")\n                    .help(\"Output directory for context files\")\n                    .default_value(\"./contexts\"),\n            )\n            .arg(\n                Arg::new(\"context-id\")\n                    .short('i')\n                    .long(\"context-id\")\n                    .value_name(\"ID\")\n                    .help(\"Custom context ID (auto-generated if not provided)\"),\n            )\n            .arg(\n                Arg::new(\"focus-areas\")\n                    .short('f')\n                    .long(\"focus-areas\")\n                    .value_name(\"AREAS\")\n                    .help(\"Comma-separated focus areas for optimization\")\n                    .default_value(\"core_types,implementations\"),\n            )\n            .arg(\n                Arg::new(\"optimization-goals\")\n                    .short('g')\n                    .long(\"optimization-goals\")\n                    .value_name(\"GOALS\")\n                    .help(\"Comma-separated optimization goals\")\n                    .default_value(\"minimize_size,maximize_relevance,preserve_connectivity\"),\n            )\n            .arg(\n                Arg::new(\"dry-run\")\n                    .short('d')\n                    .long(\"dry-run\")\n                    .help(\"Generate context but don't write to file\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('Q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n            .arg(\n                Arg::new(\"include-current-code\")\n                    .long(\"include-current-code\")\n                    .value_name(\"0|1\")\n                    .help(\"Include Current_Code in context (0=exclude for token optimization, 1=include for debugging)\")\n                    .value_parser([\"0\", \"1\"])\n                    .default_value(\"0\"),\n            )\n    }",
    "future_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-03\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 03: LLM-cozoDB-to-context-writer\")\n            .long_about(\n                \"Ultra-minimalist context optimization tool that reads entity graphs from CozoDB,\\\\n\\\\\\n                generates optimized CodeGraphContext.json files using LLM reasoning, and writes\\\\n\\\\\\n                them for consumption by other tools. Following TDD-first principles with\\\\n\\\\\\n                executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .short('b')\n                    .long(\"db\")\n                    .alias(\"database\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            .arg(\n                Arg::new(\"endpoint\")\n                    .short('e')\n                    .long(\"endpoint\")\n                    .value_name(\"URL\")\n                    .help(\"LLM API endpoint\")\n                    .default_value(\"https://api.openai.com/v1/chat/completions\"),\n            )\n            .arg(\n                Arg::new(\"api-key\")\n                    .short('k')\n                    .long(\"api-key\")\n                    .value_name(\"KEY\")\n                    .help(\"LLM API key (or set OPENAI_API_KEY env var)\"),\n            )\n            .arg(\n                Arg::new(\"model\")\n                    .short('m')\n                    .long(\"model\")\n                    .value_name(\"MODEL\")\n                    .help(\"LLM model to use\")\n                    .default_value(\"gpt-4\"),\n            )\n            .arg(\n                Arg::new(\"max-tokens\")\n                    .short('t')\n                    .long(\"max-tokens\")\n                    .value_name(\"TOKENS\")\n                    .help(\"Maximum tokens per request\")\n                    .value_parser(clap::value_parser!(usize))\n                    .default_value(\"8192\"),\n            )\n            .arg(\n                Arg::new(\"temperature\")\n                    .short('T')\n                    .long(\"temperature\")\n                    .value_name(\"TEMP\")\n                    .help(\"Temperature for LLM generation (0.0-1.0)\")\n                    .value_parser(clap::value_parser!(f32))\n                    .default_value(\"0.3\"),\n            )\n            .arg(\n                Arg::new(\"query\")\n                    .short('q')\n                    .long(\"query\")\n                    .value_name(\"QUERY\")\n                    .help(\"CozoDB query for context extraction (PRD: excludes Current_Code/Future_Code)\")\n                    .default_value(\"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\"),\n            )\n            .arg(\n                Arg::new(\"max-context-tokens\")\n                    .short('c')\n                    .long(\"max-context-tokens\")\n                    .value_name(\"TOKENS\")\n                    .help(\"Maximum context size in tokens\")\n                    .value_parser(clap::value_parser!(usize))\n                    .default_value(\"128000\"),\n            )\n            .arg(\n                Arg::new(\"relevance-threshold\")\n                    .short('r')\n                    .long(\"relevance-threshold\")\n                    .value_name(\"THRESHOLD\")\n                    .help(\"Relevance threshold for entity inclusion (0.0-1.0)\")\n                    .value_parser(clap::value_parser!(f32))\n                    .default_value(\"0.7\"),\n            )\n            .arg(\n                Arg::new(\"output\")\n                    .short('o')\n                    .long(\"output\")\n                    .value_name(\"PATH\")\n                    .help(\"Output directory for context files\")\n                    .default_value(\"./contexts\"),\n            )\n            .arg(\n                Arg::new(\"context-id\")\n                    .short('i')\n                    .long(\"context-id\")\n                    .value_name(\"ID\")\n                    .help(\"Custom context ID (auto-generated if not provided)\"),\n            )\n            .arg(\n                Arg::new(\"focus-areas\")\n                    .short('f')\n                    .long(\"focus-areas\")\n                    .value_name(\"AREAS\")\n                    .help(\"Comma-separated focus areas for optimization\")\n                    .default_value(\"core_types,implementations\"),\n            )\n            .arg(\n                Arg::new(\"optimization-goals\")\n                    .short('g')\n                    .long(\"optimization-goals\")\n                    .value_name(\"GOALS\")\n                    .help(\"Comma-separated optimization goals\")\n                    .default_value(\"minimize_size,maximize_relevance,preserve_connectivity\"),\n            )\n            .arg(\n                Arg::new(\"dry-run\")\n                    .short('d')\n                    .long(\"dry-run\")\n                    .help(\"Generate context but don't write to file\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('Q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n            .arg(\n                Arg::new(\"include-current-code\")\n                    .long(\"include-current-code\")\n                    .value_name(\"0|1\")\n                    .help(\"Include Current_Code in context (0=exclude for token optimization, 1=include for debugging)\")\n                    .value_parser([\"0\", \"1\"])\n                    .default_value(\"0\"),\n            )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435984Z",
      "modified_at": "2025-11-01T15:29:24.435984Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build_cli:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:60-122",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build_cli",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 60,
        "end": 122
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-02\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 02: LLM-to-cozoDB-writer\")\n            .long_about(\n                \"Ultra-minimalist temporal state writer for CozoDB.\\n\\\n                \\n\\\n                Two interfaces:\\n\\\n                \\n\\\n                1. Simple Interface (80% use cases):\\n  \\\n                llm-to-cozodb-writer --entity <KEY> --action <create|edit|delete> --future-code <CODE>\\n\\\n                \\n\\\n                2. Advanced Interface (20% power users):\\n  \\\n                llm-to-cozodb-writer --query \\\"?[...] := [[...]] :put CodeGraph {...}\\\"\\n\\\n                \",\n            )\n            // Simple interface arguments\n            .arg(\n                Arg::new(\"entity\")\n                    .long(\"entity\")\n                    .value_name(\"ISGL1_KEY\")\n                    .help(\"ISGL1 entity key to modify\")\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"action\")\n                    .long(\"action\")\n                    .value_name(\"ACTION\")\n                    .help(\"Action to perform: create, edit, or delete\")\n                    .value_parser([\"create\", \"edit\", \"delete\"])\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"future-code\")\n                    .long(\"future-code\")\n                    .value_name(\"CODE\")\n                    .help(\"Future code content (required for create/edit)\")\n                    .conflicts_with(\"query\"),\n            )\n            // Advanced interface arguments\n            .arg(\n                Arg::new(\"query\")\n                    .long(\"query\")\n                    .value_name(\"DATALOG\")\n                    .help(\"Raw Datalog query to execute\")\n                    .conflicts_with(\"entity\"),\n            )\n            // Common argument\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            // Mutual exclusion groups\n            .group(\n                ArgGroup::new(\"interface\")\n                    .args([\"query\", \"entity\"])\n                    .required(true),\n            )\n    }",
    "future_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-02\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 02: LLM-to-cozoDB-writer\")\n            .long_about(\n                \"Ultra-minimalist temporal state writer for CozoDB.\\n\\\n                \\n\\\n                Two interfaces:\\n\\\n                \\n\\\n                1. Simple Interface (80% use cases):\\n  \\\n                llm-to-cozodb-writer --entity <KEY> --action <create|edit|delete> --future-code <CODE>\\n\\\n                \\n\\\n                2. Advanced Interface (20% power users):\\n  \\\n                llm-to-cozodb-writer --query \\\"?[...] := [[...]] :put CodeGraph {...}\\\"\\n\\\n                \",\n            )\n            // Simple interface arguments\n            .arg(\n                Arg::new(\"entity\")\n                    .long(\"entity\")\n                    .value_name(\"ISGL1_KEY\")\n                    .help(\"ISGL1 entity key to modify\")\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"action\")\n                    .long(\"action\")\n                    .value_name(\"ACTION\")\n                    .help(\"Action to perform: create, edit, or delete\")\n                    .value_parser([\"create\", \"edit\", \"delete\"])\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"future-code\")\n                    .long(\"future-code\")\n                    .value_name(\"CODE\")\n                    .help(\"Future code content (required for create/edit)\")\n                    .conflicts_with(\"query\"),\n            )\n            // Advanced interface arguments\n            .arg(\n                Arg::new(\"query\")\n                    .long(\"query\")\n                    .value_name(\"DATALOG\")\n                    .help(\"Raw Datalog query to execute\")\n                    .conflicts_with(\"entity\"),\n            )\n            // Common argument\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            // Mutual exclusion groups\n            .group(\n                ArgGroup::new(\"interface\")\n                    .args([\"query\", \"entity\"])\n                    .required(true),\n            )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435985Z",
      "modified_at": "2025-11-01T15:29:24.435985Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:build_context_query:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:220-228",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "build_context_query",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 220,
        "end": 228
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn build_context_query(include_current_code: bool) -> String {\n        if include_current_code {\n            // Include Current_Code (debugging mode)\n            \"SELECT * EXCEPT (Future_Code) FROM CodeGraph WHERE current_ind=1\".to_string()\n        } else {\n            // Exclude Current_Code (token optimization - default)\n            \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\".to_string()\n        }\n    }",
    "future_code": "    pub fn build_context_query(include_current_code: bool) -> String {\n        if include_current_code {\n            // Include Current_Code (debugging mode)\n            \"SELECT * EXCEPT (Future_Code) FROM CodeGraph WHERE current_ind=1\".to_string()\n        } else {\n            // Exclude Current_Code (token optimization - default)\n            \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\".to_string()\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435986Z",
      "modified_at": "2025-11-01T15:29:24.435986Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:builder:______crates_parseltongue-core_src_entities_rs:1019-1021",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "builder",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1019,
        "end": 1021
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn builder() -> DependencyEdgeBuilder {\n        DependencyEdgeBuilder::default()\n    }",
    "future_code": "    pub fn builder() -> DependencyEdgeBuilder {\n        DependencyEdgeBuilder::default()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435987Z",
      "modified_at": "2025-11-01T15:29:24.435987Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:calculate_average_degree:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:399-405",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "calculate_average_degree",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 399,
        "end": 405
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn calculate_average_degree(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> f32 {\n        if entities.is_empty() {\n            return 0.0;\n        }\n\n        relationships.len() as f32 * 2.0 / entities.len() as f32\n    }",
    "future_code": "    fn calculate_average_degree(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> f32 {\n        if entities.is_empty() {\n            return 0.0;\n        }\n\n        relationships.len() as f32 * 2.0 / entities.len() as f32\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435988Z",
      "modified_at": "2025-11-01T15:29:24.435988Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:calculate_blast_radius:______crates_parseltongue-core_src_storage_cozo_client_rs:305-372",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "calculate_blast_radius",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 305,
        "end": 372
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn calculate_blast_radius(\n        &self,\n        changed_key: &str,\n        max_hops: usize,\n    ) -> Result<Vec<(String, usize)>> {\n        // Validation\n        if max_hops == 0 {\n            return Ok(Vec::new());\n        }\n\n        // CozoDB recursive query for bounded BFS\n        // Strategy: Iteratively hop through edges, tracking minimum distance\n        let query = r#\"\n            # Recursive blast radius query\n            # Find all nodes reachable from start_node within max_hops\n\n            # Base case: Starting node at distance 0\n            reachable[to_key, distance] := *DependencyEdges{from_key, to_key},\n                                            from_key == $start_key,\n                                            distance = 1\n\n            # Recursive case: Follow edges, incrementing distance\n            reachable[to_key, new_distance] := reachable[from, dist],\n                                                *DependencyEdges{from_key: from, to_key},\n                                                dist < $max_hops,\n                                                new_distance = dist + 1\n\n            # Aggregate to get minimum distance for each node\n            ?[node, min_dist] := reachable[node, dist],\n                                 min_dist = min(dist)\n\n            :order min_dist\n            \"#.to_string();\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(changed_key.into()));\n        params.insert(\"max_hops\".to_string(), DataValue::from(max_hops as i64));\n\n        let result = self\n            .db\n            .run_script(&query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"calculate_blast_radius\".to_string(),\n                reason: format!(\"Failed to execute blast radius query: {}\", e),\n            })?;\n\n        // Parse results into (key, distance) tuples\n        let mut affected = Vec::new();\n        for row in result.rows {\n            if row.len() >= 2 {\n                if let (Some(DataValue::Str(node)), Some(distance_val)) =\n                    (row.first(), row.get(1))\n                {\n                    // Distance is stored as Num enum (Int or Float)\n                    let distance = match distance_val {\n                        DataValue::Num(n) => match n {\n                            cozo::Num::Int(i) => *i as usize,\n                            cozo::Num::Float(f) => *f as usize,\n                        },\n                        _ => continue,\n                    };\n                    affected.push((node.to_string(), distance));\n                }\n            }\n        }\n\n        Ok(affected)\n    }",
    "future_code": "    pub async fn calculate_blast_radius(\n        &self,\n        changed_key: &str,\n        max_hops: usize,\n    ) -> Result<Vec<(String, usize)>> {\n        // Validation\n        if max_hops == 0 {\n            return Ok(Vec::new());\n        }\n\n        // CozoDB recursive query for bounded BFS\n        // Strategy: Iteratively hop through edges, tracking minimum distance\n        let query = r#\"\n            # Recursive blast radius query\n            # Find all nodes reachable from start_node within max_hops\n\n            # Base case: Starting node at distance 0\n            reachable[to_key, distance] := *DependencyEdges{from_key, to_key},\n                                            from_key == $start_key,\n                                            distance = 1\n\n            # Recursive case: Follow edges, incrementing distance\n            reachable[to_key, new_distance] := reachable[from, dist],\n                                                *DependencyEdges{from_key: from, to_key},\n                                                dist < $max_hops,\n                                                new_distance = dist + 1\n\n            # Aggregate to get minimum distance for each node\n            ?[node, min_dist] := reachable[node, dist],\n                                 min_dist = min(dist)\n\n            :order min_dist\n            \"#.to_string();\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(changed_key.into()));\n        params.insert(\"max_hops\".to_string(), DataValue::from(max_hops as i64));\n\n        let result = self\n            .db\n            .run_script(&query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"calculate_blast_radius\".to_string(),\n                reason: format!(\"Failed to execute blast radius query: {}\", e),\n            })?;\n\n        // Parse results into (key, distance) tuples\n        let mut affected = Vec::new();\n        for row in result.rows {\n            if row.len() >= 2 {\n                if let (Some(DataValue::Str(node)), Some(distance_val)) =\n                    (row.first(), row.get(1))\n                {\n                    // Distance is stored as Num enum (Int or Float)\n                    let distance = match distance_val {\n                        DataValue::Num(n) => match n {\n                            cozo::Num::Int(i) => *i as usize,\n                            cozo::Num::Float(f) => *f as usize,\n                        },\n                        _ => continue,\n                    };\n                    affected.push((node.to_string(), distance));\n                }\n            }\n        }\n\n        Ok(affected)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435990Z",
      "modified_at": "2025-11-01T15:29:24.435990Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:calculate_centrality_scores:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:364-376",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "calculate_centrality_scores",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 364,
        "end": 376
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn calculate_centrality_scores(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> HashMap<String, f32> {\n        let mut scores = HashMap::new();\n\n        // Simple degree centrality calculation\n        for entity in entities {\n            let degree = relationships.iter()\n                .filter(|r| r.source_id == entity.isgl1_key || r.target_id == entity.isgl1_key)\n                .count() as f32;\n            scores.insert(entity.isgl1_key.clone(), degree);\n        }\n\n        scores\n    }",
    "future_code": "    fn calculate_centrality_scores(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> HashMap<String, f32> {\n        let mut scores = HashMap::new();\n\n        // Simple degree centrality calculation\n        for entity in entities {\n            let degree = relationships.iter()\n                .filter(|r| r.source_id == entity.isgl1_key || r.target_id == entity.isgl1_key)\n                .count() as f32;\n            scores.insert(entity.isgl1_key.clone(), degree);\n        }\n\n        scores\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435991Z",
      "modified_at": "2025-11-01T15:29:24.435991Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:calculate_graph_density:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:389-396",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "calculate_graph_density",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 389,
        "end": 396
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn calculate_graph_density(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> f32 {\n        if entities.len() < 2 {\n            return 0.0;\n        }\n\n        let possible_edges = entities.len() * (entities.len() - 1) / 2;\n        relationships.len() as f32 / possible_edges as f32\n    }",
    "future_code": "    fn calculate_graph_density(&self, entities: &[CodeEntity], relationships: &[EntityRelationship]) -> f32 {\n        if entities.len() < 2 {\n            return 0.0;\n        }\n\n        let possible_edges = entities.len() * (entities.len() - 1) / 2;\n        relationships.len() as f32 / possible_edges as f32\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435992Z",
      "modified_at": "2025-11-01T15:29:24.435992Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:capabilities:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:357-359",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "capabilities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 357,
        "end": 359
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn capabilities(&self) -> ContextLlmCapabilities {\n        self.capabilities.clone()\n    }",
    "future_code": "    fn capabilities(&self) -> ContextLlmCapabilities {\n        self.capabilities.clone()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435993Z",
      "modified_at": "2025-11-01T15:29:24.435993Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:check_preceding_test_attribute:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:369-396",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "check_preceding_test_attribute",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 369,
        "end": 396
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn check_preceding_test_attribute(&self, node: &tree_sitter::Node<'_>, source: &str) -> bool {\n        // Get parent to access siblings\n        let Some(parent) = node.parent() else {\n            return false;\n        };\n\n        // Find this node and check its immediate preceding sibling\n        let node_id = node.id();\n        let siblings: Vec<_> = parent.children(&mut parent.walk()).collect();\n\n        // Find index of current node\n        let node_index = siblings.iter().position(|s| s.id() == node_id);\n\n        if let Some(idx) = node_index {\n            if idx > 0 {\n                // Check immediate preceding sibling\n                let prev_sibling = &siblings[idx - 1];\n                if prev_sibling.kind() == \"attribute_item\" {\n                    let attr_text = &source[prev_sibling.byte_range()];\n                    if attr_text.contains(\"#[test]\") || attr_text.contains(\"#[tokio::test]\") || attr_text.contains(\"#[async_test]\") {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        false\n    }",
    "future_code": "    fn check_preceding_test_attribute(&self, node: &tree_sitter::Node<'_>, source: &str) -> bool {\n        // Get parent to access siblings\n        let Some(parent) = node.parent() else {\n            return false;\n        };\n\n        // Find this node and check its immediate preceding sibling\n        let node_id = node.id();\n        let siblings: Vec<_> = parent.children(&mut parent.walk()).collect();\n\n        // Find index of current node\n        let node_index = siblings.iter().position(|s| s.id() == node_id);\n\n        if let Some(idx) = node_index {\n            if idx > 0 {\n                // Check immediate preceding sibling\n                let prev_sibling = &siblings[idx - 1];\n                if prev_sibling.kind() == \"attribute_item\" {\n                    let attr_text = &source[prev_sibling.byte_range()];\n                    if attr_text.contains(\"#[test]\") || attr_text.contains(\"#[tokio::test]\") || attr_text.contains(\"#[async_test]\") {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        false\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435994Z",
      "modified_at": "2025-11-01T15:29:24.435994Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:classify_entity:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:177-196",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "classify_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 177,
        "end": 196
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn classify_entity(&self, parsed: &ParsedEntity) -> parseltongue_core::entities::TddClassification {\n        use parseltongue_core::entities::{EntityClass, TddClassification};\n\n        // Pure FP: Check metadata for test indicator\n        let is_test = parsed\n            .metadata\n            .get(\"is_test\")\n            .map(|v| v == \"true\")\n            .unwrap_or(false);\n\n        // Minimal GREEN implementation: Just set entity_class\n        TddClassification {\n            entity_class: if is_test {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            },\n            ..TddClassification::default()\n        }\n    }",
    "future_code": "    fn classify_entity(&self, parsed: &ParsedEntity) -> parseltongue_core::entities::TddClassification {\n        use parseltongue_core::entities::{EntityClass, TddClassification};\n\n        // Pure FP: Check metadata for test indicator\n        let is_test = parsed\n            .metadata\n            .get(\"is_test\")\n            .map(|v| v == \"true\")\n            .unwrap_or(false);\n\n        // Minimal GREEN implementation: Just set entity_class\n        TddClassification {\n            entity_class: if is_test {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            },\n            ..TddClassification::default()\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435995Z",
      "modified_at": "2025-11-01T15:29:24.435995Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:code_entity_validation:______crates_parseltongue-core_src_entities_rs:1138-1182",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "code_entity_validation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1138,
        "end": 1182
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn code_entity_validation() {\n        let mut entity = CodeEntity::new(\n            \"src/main.rs-main-main\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"main\".to_string(),\n                visibility: Visibility::Public,\n                file_path: PathBuf::from(\"src/main.rs\"),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![\"main\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n        entity.future_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        match entity.validate() {\n            Ok(()) => (),\n            Err(e) => {\n                println!(\"Validation error: {:?}\", e);\n                panic!(\"Entity validation failed: {:?}\", e);\n            }\n        }\n\n        // Test temporal change\n        entity.apply_temporal_change(\n            TemporalAction::Edit,\n            Some(\"fn main() { println!(\\\"Hello\\\"); }\".to_string()),\n        ).unwrap();\n\n        assert!(entity.is_modified());\n        assert!(entity.effective_code().is_some());\n    }",
    "future_code": "    fn code_entity_validation() {\n        let mut entity = CodeEntity::new(\n            \"src/main.rs-main-main\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"main\".to_string(),\n                visibility: Visibility::Public,\n                file_path: PathBuf::from(\"src/main.rs\"),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![\"main\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n        entity.future_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        match entity.validate() {\n            Ok(()) => (),\n            Err(e) => {\n                println!(\"Validation error: {:?}\", e);\n                panic!(\"Entity validation failed: {:?}\", e);\n            }\n        }\n\n        // Test temporal change\n        entity.apply_temporal_change(\n            TemporalAction::Edit,\n            Some(\"fn main() { println!(\\\"Hello\\\"); }\".to_string()),\n        ).unwrap();\n\n        assert!(entity.is_modified());\n        assert!(entity.effective_code().is_some());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435996Z",
      "modified_at": "2025-11-01T15:29:24.435996Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:collect_syntax_errors:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:84-116",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "collect_syntax_errors",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 84,
        "end": 116
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn collect_syntax_errors(&self, node: &Node, source: &str) -> Vec<String> {\n        let mut errors = Vec::new();\n\n        // Check if this node is an error node\n        if node.is_error() || node.is_missing() {\n            let line = node.start_position().row + 1;\n            let col = node.start_position().column + 1;\n            let end_line = node.end_position().row + 1;\n            let end_col = node.end_position().column + 1;\n\n            let error_msg = if node.is_missing() {\n                format!(\n                    \"Missing syntax element at line {}, column {}\",\n                    line, col\n                )\n            } else {\n                format!(\n                    \"Syntax error at line {}, column {} (ends at line {}, column {})\",\n                    line, col, end_line, end_col\n                )\n            };\n\n            errors.push(error_msg);\n        }\n\n        // Recursively check children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            errors.extend(self.collect_syntax_errors(&child, source));\n        }\n\n        errors\n    }",
    "future_code": "    fn collect_syntax_errors(&self, node: &Node, source: &str) -> Vec<String> {\n        let mut errors = Vec::new();\n\n        // Check if this node is an error node\n        if node.is_error() || node.is_missing() {\n            let line = node.start_position().row + 1;\n            let col = node.start_position().column + 1;\n            let end_line = node.end_position().row + 1;\n            let end_col = node.end_position().column + 1;\n\n            let error_msg = if node.is_missing() {\n                format!(\n                    \"Missing syntax element at line {}, column {}\",\n                    line, col\n                )\n            } else {\n                format!(\n                    \"Syntax error at line {}, column {} (ends at line {}, column {})\",\n                    line, col, end_line, end_col\n                )\n            };\n\n            errors.push(error_msg);\n        }\n\n        // Recursively check children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            errors.extend(self.collect_syntax_errors(&child, source));\n        }\n\n        errors\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435998Z",
      "modified_at": "2025-11-01T15:29:24.435998Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:conflict_detection:______crates_parseltongue-core_src_temporal_rs:658-681",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "conflict_detection",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 658,
        "end": 681
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn conflict_detection() {\n        let resolver = ConflictResolver::new(ConflictResolutionStrategy::FailFast);\n\n        let changes = vec![\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Edit,\n                future_code: Some(\"fn test() {}\".to_string()),\n                updated_signature: None,\n            },\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Delete,\n                future_code: None,\n                updated_signature: None,\n            },\n        ];\n\n        let conflicts = resolver.detect_conflicts(&changes);\n        assert_eq!(conflicts.len(), 1);\n\n        let result = resolver.resolve_conflicts(changes);\n        assert!(result.is_err());\n    }",
    "future_code": "    fn conflict_detection() {\n        let resolver = ConflictResolver::new(ConflictResolutionStrategy::FailFast);\n\n        let changes = vec![\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Edit,\n                future_code: Some(\"fn test() {}\".to_string()),\n                updated_signature: None,\n            },\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Delete,\n                future_code: None,\n                updated_signature: None,\n            },\n        ];\n\n        let conflicts = resolver.detect_conflicts(&changes);\n        assert_eq!(conflicts.len(), 1);\n\n        let result = resolver.resolve_conflicts(changes);\n        assert!(result.is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.435999Z",
      "modified_at": "2025-11-01T15:29:24.435999Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:contains:______crates_parseltongue-core_src_entities_rs:308-310",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "contains",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 308,
        "end": 310
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn contains(&self, line: u32) -> bool {\n        line >= self.start && line <= self.end\n    }",
    "future_code": "    pub fn contains(&self, line: u32) -> bool {\n        line >= self.start && line <= self.end\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436002Z",
      "modified_at": "2025-11-01T15:29:24.436002Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:convert_entity_type:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:199-212",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "convert_entity_type",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 199,
        "end": 212
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn convert_entity_type(&self, entity_type: &crate::isgl1_generator::EntityType) -> parseltongue_core::entities::EntityType {\n        match entity_type {\n            crate::isgl1_generator::EntityType::Function => parseltongue_core::entities::EntityType::Function,\n            crate::isgl1_generator::EntityType::Struct => parseltongue_core::entities::EntityType::Struct,\n            crate::isgl1_generator::EntityType::Enum => parseltongue_core::entities::EntityType::Enum,\n            crate::isgl1_generator::EntityType::Trait => parseltongue_core::entities::EntityType::Trait,\n            crate::isgl1_generator::EntityType::Impl => parseltongue_core::entities::EntityType::ImplBlock {\n                trait_name: None,\n                struct_name: \"Unknown\".to_string(), // TODO: Extract from parsed entity\n            },\n            crate::isgl1_generator::EntityType::Module => parseltongue_core::entities::EntityType::Module,\n            crate::isgl1_generator::EntityType::Variable => parseltongue_core::entities::EntityType::Variable,\n        }\n    }",
    "future_code": "    fn convert_entity_type(&self, entity_type: &crate::isgl1_generator::EntityType) -> parseltongue_core::entities::EntityType {\n        match entity_type {\n            crate::isgl1_generator::EntityType::Function => parseltongue_core::entities::EntityType::Function,\n            crate::isgl1_generator::EntityType::Struct => parseltongue_core::entities::EntityType::Struct,\n            crate::isgl1_generator::EntityType::Enum => parseltongue_core::entities::EntityType::Enum,\n            crate::isgl1_generator::EntityType::Trait => parseltongue_core::entities::EntityType::Trait,\n            crate::isgl1_generator::EntityType::Impl => parseltongue_core::entities::EntityType::ImplBlock {\n                trait_name: None,\n                struct_name: \"Unknown\".to_string(), // TODO: Extract from parsed entity\n            },\n            crate::isgl1_generator::EntityType::Module => parseltongue_core::entities::EntityType::Module,\n            crate::isgl1_generator::EntityType::Variable => parseltongue_core::entities::EntityType::Variable,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436003Z",
      "modified_at": "2025-11-01T15:29:24.436003Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create:______crates_parseltongue-core_src_entities_rs:184-190",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 184,
        "end": 190
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn create() -> Self {\n        Self {\n            current_ind: false,\n            future_ind: true,\n            future_action: Some(TemporalAction::Create),\n        }\n    }",
    "future_code": "    pub fn create() -> Self {\n        Self {\n            current_ind: false,\n            future_ind: true,\n            future_action: Some(TemporalAction::Create),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436005Z",
      "modified_at": "2025-11-01T15:29:24.436005Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_context_optimizer:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:72-84",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_context_optimizer",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 72,
        "end": 84
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn create_context_optimizer(config: ContextWriterConfig) -> Result<Arc<ContextOptimizerImpl>> {\n        // Create storage instance\n        let storage = parseltongue_core::storage::CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| ContextWriterError::DatabaseError {\n                reason: format!(\"Failed to create storage: {}\", e)\n            })?;\n\n        let storage = Arc::new(storage);\n        let llm_client = Arc::new(ContextLlmClientImpl::new(config.clone()));\n        let optimizer = Arc::new(ContextOptimizerImpl::new(storage, config, llm_client));\n        Ok(optimizer)\n    }",
    "future_code": "    pub async fn create_context_optimizer(config: ContextWriterConfig) -> Result<Arc<ContextOptimizerImpl>> {\n        // Create storage instance\n        let storage = parseltongue_core::storage::CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| ContextWriterError::DatabaseError {\n                reason: format!(\"Failed to create storage: {}\", e)\n            })?;\n\n        let storage = Arc::new(storage);\n        let llm_client = Arc::new(ContextLlmClientImpl::new(config.clone()));\n        let optimizer = Arc::new(ContextOptimizerImpl::new(storage, config, llm_client));\n        Ok(optimizer)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436006Z",
      "modified_at": "2025-11-01T15:29:24.436006Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_dependency_edges_schema:______crates_parseltongue-core_src_storage_cozo_client_rs:115-134",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_dependency_edges_schema",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 115,
        "end": 134
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn create_dependency_edges_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create DependencyEdges {\n                from_key: String,\n                to_key: String,\n                edge_type: String\n                =>\n                source_location: String?\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"create_dependency_edges_schema\".to_string(),\n                reason: format!(\"Failed to create DependencyEdges schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn create_dependency_edges_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create DependencyEdges {\n                from_key: String,\n                to_key: String,\n                edge_type: String\n                =>\n                source_location: String?\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"create_dependency_edges_schema\".to_string(),\n                reason: format!(\"Failed to create DependencyEdges schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436007Z",
      "modified_at": "2025-11-01T15:29:24.436007Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_entity_for_change:______crates_parseltongue-core_src_temporal_rs:211-240",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_entity_for_change",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 211,
        "end": 240
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_entity_for_change(&self, change: &TemporalChange) -> Result<CodeEntity> {\n        let mut entity = CodeEntity::new(\n            change.isgl1_key.clone(),\n            InterfaceSignature {\n                entity_type: EntityType::Function, // Default\n                name: \"unknown\".to_string(),\n                visibility: Visibility::Private,\n                file_path: std::path::PathBuf::new(),\n                line_range: LineRange::new(1, 1)?,\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        )?;\n\n        // Set initial temporal state based on action\n        entity.temporal_state = match change.action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        };\n\n        Ok(entity)\n    }",
    "future_code": "    fn create_entity_for_change(&self, change: &TemporalChange) -> Result<CodeEntity> {\n        let mut entity = CodeEntity::new(\n            change.isgl1_key.clone(),\n            InterfaceSignature {\n                entity_type: EntityType::Function, // Default\n                name: \"unknown\".to_string(),\n                visibility: Visibility::Private,\n                file_path: std::path::PathBuf::new(),\n                line_range: LineRange::new(1, 1)?,\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        )?;\n\n        // Set initial temporal state based on action\n        entity.temporal_state = match change.action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        };\n\n        Ok(entity)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436008Z",
      "modified_at": "2025-11-01T15:29:24.436008Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:41-59",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 41,
        "end": 59
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn create_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ensure parent directory exists\n        if let Some(parent) = file_path.parent() {\n            tokio::fs::create_dir_all(parent).await?;\n        }\n\n        // Get content to write\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Create operation\"))?;\n\n        // Write file directly (ultra-minimalist: no backups)\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Create))\n    }",
    "future_code": "    async fn create_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ensure parent directory exists\n        if let Some(parent) = file_path.parent() {\n            tokio::fs::create_dir_all(parent).await?;\n        }\n\n        // Get content to write\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Create operation\"))?;\n\n        // Write file directly (ultra-minimalist: no backups)\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Create))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436009Z",
      "modified_at": "2025-11-01T15:29:24.436009Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_indexed_entity:______crates_parseltongue-core_tests_end_to_end_workflow_rs:336-372",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_indexed_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "line_range": {
        "start": 336,
        "end": 372
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_indexed_entity(\n    name: &str,\n    file: &str,\n    lines: (u32, u32),\n    entity_class: EntityClass,\n) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\n        \"rust:fn:{}:{}:{}-{}\",\n        name,\n        file.replace('/', \"_\").replace('.', \"_\"),\n        lines.0,\n        lines.1\n    );\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n    entity.tdd_classification.entity_class = entity_class;\n\n    entity\n}",
    "future_code": "fn create_indexed_entity(\n    name: &str,\n    file: &str,\n    lines: (u32, u32),\n    entity_class: EntityClass,\n) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\n        \"rust:fn:{}:{}:{}-{}\",\n        name,\n        file.replace('/', \"_\").replace('.', \"_\"),\n        lines.0,\n        lines.1\n    );\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n    entity.tdd_classification.entity_class = entity_class;\n\n    entity\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436010Z",
      "modified_at": "2025-11-01T15:29:24.436010Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_indexed_entity_from_project:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:253-281",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_indexed_entity_from_project",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 253,
        "end": 281
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_indexed_entity_from_project(project: &TempDir) -> Result<CodeEntity> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project.path().join(\"src/lib.rs\"))?;\n\n    let mut entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), signature)?;\n    entity.current_code = Some(current_code);\n    entity.future_code = Some(\"\".to_string());  // Will be filled by Tool 2\n    entity.temporal_state = TemporalState::unchanged();\n\n    Ok(entity)\n}",
    "future_code": "fn create_indexed_entity_from_project(project: &TempDir) -> Result<CodeEntity> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project.path().join(\"src/lib.rs\"))?;\n\n    let mut entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), signature)?;\n    entity.current_code = Some(current_code);\n    entity.future_code = Some(\"\".to_string());  // Will be filled by Tool 2\n    entity.temporal_state = TemporalState::unchanged();\n\n    Ok(entity)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436011Z",
      "modified_at": "2025-11-01T15:29:24.436011Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_language_signature:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:215-238",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_language_signature",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 215,
        "end": 238
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_language_signature(&self, language: &Language) -> LanguageSpecificSignature {\n        match language {\n            Language::Rust => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n            Language::Python => LanguageSpecificSignature::Python(PythonSignature {\n                parameters: vec![],\n                return_type: None,\n                is_async: false,\n                decorators: vec![],\n            }),\n            _ => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        }\n    }",
    "future_code": "    fn create_language_signature(&self, language: &Language) -> LanguageSpecificSignature {\n        match language {\n            Language::Rust => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n            Language::Python => LanguageSpecificSignature::Python(PythonSignature {\n                parameters: vec![],\n                return_type: None,\n                is_async: false,\n                decorators: vec![],\n            }),\n            _ => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436012Z",
      "modified_at": "2025-11-01T15:29:24.436012Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_llm_client:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:87-89",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_llm_client",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 87,
        "end": 89
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn create_llm_client(config: ContextWriterConfig) -> Arc<ContextLlmClientImpl> {\n        ContextLlmClientFactory::new(config)\n    }",
    "future_code": "    pub fn create_llm_client(config: ContextWriterConfig) -> Arc<ContextLlmClientImpl> {\n        ContextLlmClientFactory::new(config)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436013Z",
      "modified_at": "2025-11-01T15:29:24.436014Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_sample_entities:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:259-287",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_sample_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 259,
        "end": 287
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_sample_entities(&self) -> Result<Vec<CodeEntity>> {\n        let interface_signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"sample_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: \"src/lib.rs\".into(),\n            line_range: LineRange::new(1, 10).unwrap(),\n            module_path: vec![\"sample_module\".to_string()],\n            documentation: None,\n            language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                parseltongue_core::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        let sample_entities = vec![\n            CodeEntity::new(\n                \"rust:fn:sample_function:src/lib.rs:1-10\".to_string(),\n                interface_signature,\n            ).unwrap(),\n        ];\n\n        Ok(sample_entities)\n    }",
    "future_code": "    fn create_sample_entities(&self) -> Result<Vec<CodeEntity>> {\n        let interface_signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"sample_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: \"src/lib.rs\".into(),\n            line_range: LineRange::new(1, 10).unwrap(),\n            module_path: vec![\"sample_module\".to_string()],\n            documentation: None,\n            language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                parseltongue_core::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        let sample_entities = vec![\n            CodeEntity::new(\n                \"rust:fn:sample_function:src/lib.rs:1-10\".to_string(),\n                interface_signature,\n            ).unwrap(),\n        ];\n\n        Ok(sample_entities)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436015Z",
      "modified_at": "2025-11-01T15:29:24.436015Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_sample_relationships:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:290-304",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_sample_relationships",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 290,
        "end": 304
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_sample_relationships(&self, entities: &[CodeEntity]) -> Vec<EntityRelationship> {\n        if entities.is_empty() {\n            return vec![];\n        }\n\n        vec![\n            EntityRelationship {\n                source_id: entities[0].isgl1_key.clone(),\n                target_id: entities[0].isgl1_key.clone(),\n                relationship_type: RelationshipType::RelatedTo,\n                strength: 1.0,\n                context: Some(\"sample relationship\".to_string()),\n            }\n        ]\n    }",
    "future_code": "    fn create_sample_relationships(&self, entities: &[CodeEntity]) -> Vec<EntityRelationship> {\n        if entities.is_empty() {\n            return vec![];\n        }\n\n        vec![\n            EntityRelationship {\n                source_id: entities[0].isgl1_key.clone(),\n                target_id: entities[0].isgl1_key.clone(),\n                relationship_type: RelationshipType::RelatedTo,\n                strength: 1.0,\n                context: Some(\"sample relationship\".to_string()),\n            }\n        ]\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436016Z",
      "modified_at": "2025-11-01T15:29:24.436016Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_schema:______crates_parseltongue-core_src_storage_cozo_client_rs:67-94",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_schema",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 67,
        "end": 94
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn create_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create CodeGraph {\n                ISGL1_key: String =>\n                Current_Code: String?,\n                Future_Code: String?,\n                interface_signature: String,\n                TDD_Classification: String,\n                lsp_meta_data: String?,\n                current_ind: Bool,\n                future_ind: Bool,\n                Future_Action: String?,\n                file_path: String,\n                language: String,\n                last_modified: String,\n                entity_type: String\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"schema_creation\".to_string(),\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn create_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create CodeGraph {\n                ISGL1_key: String =>\n                Current_Code: String?,\n                Future_Code: String?,\n                interface_signature: String,\n                TDD_Classification: String,\n                lsp_meta_data: String?,\n                current_ind: Bool,\n                future_ind: Bool,\n                Future_Action: String?,\n                file_path: String,\n                language: String,\n                last_modified: String,\n                entity_type: String\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"schema_creation\".to_string(),\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436017Z",
      "modified_at": "2025-11-01T15:29:24.436017Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_simple_test_entity:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:339-365",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_simple_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 339,
        "end": 365
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_simple_test_entity(key: &str) -> CodeEntity {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"test\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n    entity.current_code = Some(\"fn test() {}\".to_string());\n    entity.future_code = Some(\"\".to_string());\n    entity.temporal_state = TemporalState::unchanged();\n\n    entity\n}",
    "future_code": "fn create_simple_test_entity(key: &str) -> CodeEntity {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"test\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n    entity.current_code = Some(\"fn test() {}\".to_string());\n    entity.future_code = Some(\"\".to_string());\n    entity.temporal_state = TemporalState::unchanged();\n\n    entity\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436019Z",
      "modified_at": "2025-11-01T15:29:24.436019Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_streamer:______crates_pt01-folder-to-cozodb-streamer_src_lib_rs:78-82",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_streamer",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "line_range": {
        "start": 78,
        "end": 82
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn create_streamer(config: StreamerConfig) -> Result<Arc<FileStreamerImpl>> {\n        let generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new(config, generator).await?;\n        Ok(Arc::new(streamer))\n    }",
    "future_code": "    pub async fn create_streamer(config: StreamerConfig) -> Result<Arc<FileStreamerImpl>> {\n        let generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new(config, generator).await?;\n        Ok(Arc::new(streamer))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436021Z",
      "modified_at": "2025-11-01T15:29:24.436021Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_system_prompt:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:213-231",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_system_prompt",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 213,
        "end": 231
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_system_prompt(&self) -> String {\n        r#\"You are an expert code context optimizer specializing in creating minimal, highly relevant CodeGraphContext.json files for LLM consumption.\n\nYour task is to analyze the provided entity graph and optimize it for context usage following these principles:\n\n1. **Token Efficiency**: Remove redundant entities while preserving connectivity\n2. **Relevance Preservation**: Keep entities with high relevance scores (>0.7)\n3. **Structural Integrity**: Maintain dependency relationships\n4. **Type Safety**: Preserve type information and signatures\n5. **Implementation Clarity**: Keep key implementation details\n\nFor each entity, provide:\n- Relevance score (0.0-1.0)\n- Inclusion reason (why this entity matters)\n- Token estimate (approximate token cost)\n- Dependencies (required related entities)\n\nOutput format: JSON with optimized_entities, pruning_summary, context_metadata, and confidence_score.\"#.to_string()\n    }",
    "future_code": "    fn create_system_prompt(&self) -> String {\n        r#\"You are an expert code context optimizer specializing in creating minimal, highly relevant CodeGraphContext.json files for LLM consumption.\n\nYour task is to analyze the provided entity graph and optimize it for context usage following these principles:\n\n1. **Token Efficiency**: Remove redundant entities while preserving connectivity\n2. **Relevance Preservation**: Keep entities with high relevance scores (>0.7)\n3. **Structural Integrity**: Maintain dependency relationships\n4. **Type Safety**: Preserve type information and signatures\n5. **Implementation Clarity**: Keep key implementation details\n\nFor each entity, provide:\n- Relevance score (0.0-1.0)\n- Inclusion reason (why this entity matters)\n- Token estimate (approximate token cost)\n- Dependencies (required related entities)\n\nOutput format: JSON with optimized_entities, pruning_summary, context_metadata, and confidence_score.\"#.to_string()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436023Z",
      "modified_at": "2025-11-01T15:29:24.436023Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:10-12",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 10,
        "end": 12
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity() -> CodeEntity {\n    create_test_entity_with_key(\"test-file-rs-TestStruct\")\n}",
    "future_code": "fn create_test_entity() -> CodeEntity {\n    create_test_entity_with_key(\"test-file-rs-TestStruct\")\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436024Z",
      "modified_at": "2025-11-01T15:29:24.436024Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:21-45",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 21,
        "end": 45
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
    "future_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436025Z",
      "modified_at": "2025-11-01T15:29:24.436025Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:327-365",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 327,
        "end": 365
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity(\n    isgl1_key: &str,\n    current_code: Option<&str>,\n    temporal_state: TemporalState,\n) -> CodeEntity {\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: current_code.map(|s| s.to_string()),\n        future_code: None,\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state,\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "future_code": "fn create_test_entity(\n    isgl1_key: &str,\n    current_code: Option<&str>,\n    temporal_state: TemporalState,\n) -> CodeEntity {\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: current_code.map(|s| s.to_string()),\n        future_code: None,\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state,\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436026Z",
      "modified_at": "2025-11-01T15:29:24.436027Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:21-45",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 21,
        "end": 45
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
    "future_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436028Z",
      "modified_at": "2025-11-01T15:29:24.436028Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:119-158",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 119,
        "end": 158
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_test_entity(isgl1_key: &str, future_code: Option<String>, temporal_state: TemporalState) -> CodeEntity {\n        CodeEntity {\n            isgl1_key: isgl1_key.to_string(),\n            temporal_state,\n            interface_signature: InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"test_func\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange { start: 1, end: 10 },\n                module_path: vec![\"test\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            current_code: None,\n            future_code,\n            tdd_classification: TddClassification {\n                entity_class: parseltongue_core::EntityClass::CodeImplementation,\n                testability: TestabilityLevel::High,\n                complexity: ComplexityLevel::Simple,\n                dependencies: 0,\n                test_coverage_estimate: 0.0,\n                critical_path: false,\n                change_risk: RiskLevel::Low,\n            },\n            lsp_metadata: None,\n            metadata: EntityMetadata {\n                created_at: Utc::now(),\n                modified_at: Utc::now(),\n                content_hash: \"test_hash\".to_string(),\n                additional: HashMap::new(),\n            },\n        }\n    }",
    "future_code": "    fn create_test_entity(isgl1_key: &str, future_code: Option<String>, temporal_state: TemporalState) -> CodeEntity {\n        CodeEntity {\n            isgl1_key: isgl1_key.to_string(),\n            temporal_state,\n            interface_signature: InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"test_func\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange { start: 1, end: 10 },\n                module_path: vec![\"test\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            current_code: None,\n            future_code,\n            tdd_classification: TddClassification {\n                entity_class: parseltongue_core::EntityClass::CodeImplementation,\n                testability: TestabilityLevel::High,\n                complexity: ComplexityLevel::Simple,\n                dependencies: 0,\n                test_coverage_estimate: 0.0,\n                critical_path: false,\n                change_risk: RiskLevel::Low,\n            },\n            lsp_metadata: None,\n            metadata: EntityMetadata {\n                created_at: Utc::now(),\n                modified_at: Utc::now(),\n                content_hash: \"test_hash\".to_string(),\n                additional: HashMap::new(),\n            },\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436029Z",
      "modified_at": "2025-11-01T15:29:24.436029Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:217-265",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 217,
        "end": 265
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity(isgl1_key: &str, future_code: Option<&str>, action: TemporalAction) -> CodeEntity {\n    use parseltongue_core::entities::{\n        ComplexityLevel, EntityClass, EntityMetadata, EntityType, InterfaceSignature,\n        LanguageSpecificSignature, LineRange, RiskLevel, RustSignature, TddClassification, TestabilityLevel,\n        Visibility,\n    };\n    use std::path::PathBuf;\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: Some(\"old code\".to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: isgl1_key.to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/test.rs\"),\n            line_range: LineRange {\n                start: 1,\n                end: 10,\n            },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: match action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        },\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "future_code": "fn create_test_entity(isgl1_key: &str, future_code: Option<&str>, action: TemporalAction) -> CodeEntity {\n    use parseltongue_core::entities::{\n        ComplexityLevel, EntityClass, EntityMetadata, EntityType, InterfaceSignature,\n        LanguageSpecificSignature, LineRange, RiskLevel, RustSignature, TddClassification, TestabilityLevel,\n        Visibility,\n    };\n    use std::path::PathBuf;\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: Some(\"old code\".to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: isgl1_key.to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/test.rs\"),\n            line_range: LineRange {\n                start: 1,\n                end: 10,\n            },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: match action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        },\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436030Z",
      "modified_at": "2025-11-01T15:29:24.436030Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:368-427",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 368,
        "end": 427
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity(\n    isgl1_key: &str,\n    current_code: Option<&str>,\n    future_code: Option<&str>,\n    temporal_state: TemporalState,\n) -> CodeEntity {\n    // Extract file path from ISGL1 key (matching diff_generator logic)\n    let file_path = if isgl1_key.contains(\":\") {\n        // Line-based key: rust:fn:name:src_lib_rs:10-20\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 4 {\n            let sanitized_path = parts[3];\n            desanitize_path(sanitized_path)\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    } else {\n        // Hash-based key: src_lib_rs-name-type-hash\n        let parts: Vec<&str> = isgl1_key.split('-').collect();\n        if !parts.is_empty() {\n            desanitize_path(parts[0])\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    };\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: current_code.map(|s| s.to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path,\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state,\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "future_code": "fn create_test_entity(\n    isgl1_key: &str,\n    current_code: Option<&str>,\n    future_code: Option<&str>,\n    temporal_state: TemporalState,\n) -> CodeEntity {\n    // Extract file path from ISGL1 key (matching diff_generator logic)\n    let file_path = if isgl1_key.contains(\":\") {\n        // Line-based key: rust:fn:name:src_lib_rs:10-20\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 4 {\n            let sanitized_path = parts[3];\n            desanitize_path(sanitized_path)\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    } else {\n        // Hash-based key: src_lib_rs-name-type-hash\n        let parts: Vec<&str> = isgl1_key.split('-').collect();\n        if !parts.is_empty() {\n            desanitize_path(parts[0])\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    };\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: current_code.map(|s| s.to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path,\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state,\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436031Z",
      "modified_at": "2025-11-01T15:29:24.436031Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:101-120",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 101,
        "end": 120
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_test_entity(key: &str) -> CodeEntity {\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        };\n\n        CodeEntity::new(key.to_string(), signature).unwrap()\n    }",
    "future_code": "    fn create_test_entity(key: &str) -> CodeEntity {\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        };\n\n        CodeEntity::new(key.to_string(), signature).unwrap()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436032Z",
      "modified_at": "2025-11-01T15:29:24.436032Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_entity_with_key:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:15-40",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_entity_with_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 15,
        "end": 40
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_entity_with_key(key: &str) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Struct,\n        name: \"TestStruct\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test/file.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![\"test\".to_string()],\n        documentation: Some(\"Test documentation\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[derive(Debug)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n\n    // Set code to satisfy validation requirements\n    entity.current_code = Some(\"struct TestStruct {}\".to_string());\n    entity.future_code = Some(\"struct TestStruct {}\".to_string());\n\n    entity\n}",
    "future_code": "fn create_test_entity_with_key(key: &str) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Struct,\n        name: \"TestStruct\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test/file.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![\"test\".to_string()],\n        documentation: Some(\"Test documentation\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[derive(Debug)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n\n    // Set code to satisfy validation requirements\n    entity.current_code = Some(\"struct TestStruct {}\".to_string());\n    entity.future_code = Some(\"struct TestStruct {}\".to_string());\n\n    entity\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436033Z",
      "modified_at": "2025-11-01T15:29:24.436033Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_project_with_subtraction_bug:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:215-253",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_project_with_subtraction_bug",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 215,
        "end": 253
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_project_with_subtraction_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with bug\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be + not -\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
    "future_code": "fn create_test_project_with_subtraction_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with bug\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be + not -\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436035Z",
      "modified_at": "2025-11-01T15:29:24.436035Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_test_rust_project_with_bug:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:192-230",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_test_rust_project_with_bug",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 192,
        "end": 230
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn create_test_rust_project_with_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with a bug (subtract instead of add)\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will fail!\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
    "future_code": "fn create_test_rust_project_with_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with a bug (subtract instead of add)\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will fail!\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436036Z",
      "modified_at": "2025-11-01T15:29:24.436036Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:create_user_prompt:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:234-270",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "create_user_prompt",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 234,
        "end": 270
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn create_user_prompt(&self, request: &ContextOptimizationRequest) -> String {\n        let mut prompt = String::new();\n        prompt.push_str(\"Optimize this code entity graph for LLM context consumption:\\n\\n\");\n\n        prompt.push_str(&format!(\"Target context size: {} tokens\\n\", request.target_context_size));\n        prompt.push_str(&format!(\"Entities: {}\\n\", request.entities.len()));\n        prompt.push_str(&format!(\"Relationships: {}\\n\", request.relationships.len()));\n        prompt.push_str(&format!(\"Focus areas: {:?}\\n\", request.focus_areas));\n        prompt.push_str(&format!(\"Optimization goals: {:?}\\n\\n\", request.optimization_goals));\n\n        prompt.push_str(\"Entities:\\n\");\n        for (i, entity) in request.entities.iter().enumerate() {\n            prompt.push_str(&format!(\n                \"{}. {} ({:?}) - {:?}\\n   Code: {}\\n\\n\",\n                i + 1,\n                entity.interface_signature.name,\n                entity.interface_signature.entity_type,\n                entity.interface_signature.language_specific,\n                entity.current_code.as_deref().unwrap_or(\"No code\")\n            ));\n        }\n\n        prompt.push_str(\"Relationships:\\n\");\n        for (i, rel) in request.relationships.iter().enumerate() {\n            prompt.push_str(&format!(\n                \"{}. {} -> {} ({:?}) strength: {}\\n\",\n                i + 1,\n                rel.source_id,\n                rel.target_id,\n                rel.relationship_type,\n                rel.strength\n            ));\n        }\n\n        prompt.push_str(\"\\nGenerate optimized JSON context with relevance scores and pruning summary.\");\n        prompt\n    }",
    "future_code": "    fn create_user_prompt(&self, request: &ContextOptimizationRequest) -> String {\n        let mut prompt = String::new();\n        prompt.push_str(\"Optimize this code entity graph for LLM context consumption:\\n\\n\");\n\n        prompt.push_str(&format!(\"Target context size: {} tokens\\n\", request.target_context_size));\n        prompt.push_str(&format!(\"Entities: {}\\n\", request.entities.len()));\n        prompt.push_str(&format!(\"Relationships: {}\\n\", request.relationships.len()));\n        prompt.push_str(&format!(\"Focus areas: {:?}\\n\", request.focus_areas));\n        prompt.push_str(&format!(\"Optimization goals: {:?}\\n\\n\", request.optimization_goals));\n\n        prompt.push_str(\"Entities:\\n\");\n        for (i, entity) in request.entities.iter().enumerate() {\n            prompt.push_str(&format!(\n                \"{}. {} ({:?}) - {:?}\\n   Code: {}\\n\\n\",\n                i + 1,\n                entity.interface_signature.name,\n                entity.interface_signature.entity_type,\n                entity.interface_signature.language_specific,\n                entity.current_code.as_deref().unwrap_or(\"No code\")\n            ));\n        }\n\n        prompt.push_str(\"Relationships:\\n\");\n        for (i, rel) in request.relationships.iter().enumerate() {\n            prompt.push_str(&format!(\n                \"{}. {} -> {} ({:?}) strength: {}\\n\",\n                i + 1,\n                rel.source_id,\n                rel.target_id,\n                rel.relationship_type,\n                rel.strength\n            ));\n        }\n\n        prompt.push_str(\"\\nGenerate optimized JSON context with relevance scores and pruning summary.\");\n        prompt\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436037Z",
      "modified_at": "2025-11-01T15:29:24.436037Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_entities_rs:806-816",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 806,
        "end": 816
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Medium,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Medium,\n        }\n    }",
    "future_code": "    fn default() -> Self {\n        Self {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Medium,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Medium,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436038Z",
      "modified_at": "2025-11-01T15:29:24.436038Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_error_rs:159-161",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 159,
        "end": 161
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::RetryWithBackoff(std::time::Duration::from_millis(1000))\n    }",
    "future_code": "    fn default() -> Self {\n        Self::RetryWithBackoff(std::time::Duration::from_millis(1000))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436039Z",
      "modified_at": "2025-11-01T15:29:24.436039Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_temporal_rs:251-253",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 251,
        "end": 253
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436040Z",
      "modified_at": "2025-11-01T15:29:24.436040Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_temporal_rs:269-271",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 269,
        "end": 271
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436041Z",
      "modified_at": "2025-11-01T15:29:24.436041Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_temporal_rs:311-313",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 311,
        "end": 313
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436042Z",
      "modified_at": "2025-11-01T15:29:24.436042Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_parseltongue-core_src_temporal_rs:359-361",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 359,
        "end": 361
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436043Z",
      "modified_at": "2025-11-01T15:29:24.436043Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:59-61",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 59,
        "end": 61
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436044Z",
      "modified_at": "2025-11-01T15:29:24.436044Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt01-folder-to-cozodb-streamer_src_lib_rs:60-70",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "line_range": {
        "start": 60,
        "end": 70
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self {\n            root_dir: PathBuf::from(\".\"),\n            db_path: \"mem\".to_string(), // Use in-memory database by default\n            max_file_size: 1024 * 1024, // 1MB\n            include_patterns: vec![\"*.rs\".to_string(), \"*.py\".to_string()], // Simplified patterns that work\n            exclude_patterns: vec![\"target/**\".to_string(), \"node_modules/**\".to_string()],\n            parsing_library: \"tree-sitter\".to_string(), // PRD default\n            chunking: \"ISGL1\".to_string(), // PRD default\n        }\n    }",
    "future_code": "    fn default() -> Self {\n        Self {\n            root_dir: PathBuf::from(\".\"),\n            db_path: \"mem\".to_string(), // Use in-memory database by default\n            max_file_size: 1024 * 1024, // 1MB\n            include_patterns: vec![\"*.rs\".to_string(), \"*.py\".to_string()], // Simplified patterns that work\n            exclude_patterns: vec![\"target/**\".to_string(), \"node_modules/**\".to_string()],\n            parsing_library: \"tree-sitter\".to_string(), // PRD default\n            chunking: \"ISGL1\".to_string(), // PRD default\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436045Z",
      "modified_at": "2025-11-01T15:29:24.436046Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt02-llm-cozodb-to-context-writer_src_errors_rs:97-102",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/errors.rs",
      "line_range": {
        "start": 97,
        "end": 102
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        ErrorRecoveryStrategy::RetryWithBackoff {\n            max_retries: 3,\n            base_delay_ms: 1000,\n        }\n    }",
    "future_code": "    fn default() -> Self {\n        ErrorRecoveryStrategy::RetryWithBackoff {\n            max_retries: 3,\n            base_delay_ms: 1000,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436047Z",
      "modified_at": "2025-11-01T15:29:24.436047Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:51-64",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 51,
        "end": 64
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self {\n            db_path: \"parseltongue.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: std::env::var(\"OPENAI_API_KEY\").unwrap_or_default(),\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity)-[r:RELATED_TO]->(n:Entity) RETURN e, r, n LIMIT 100\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: \"./contexts\".to_string(),\n        }\n    }",
    "future_code": "    fn default() -> Self {\n        Self {\n            db_path: \"parseltongue.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: std::env::var(\"OPENAI_API_KEY\").unwrap_or_default(),\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity)-[r:RELATED_TO]->(n:Entity) RETURN e, r, n LIMIT 100\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: \"./contexts\".to_string(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436048Z",
      "modified_at": "2025-11-01T15:29:24.436048Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:175-180",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 175,
        "end": 180
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self {\n            query: String::new(),\n            db_path: \"parseltongue.db\".to_string(),\n        }\n    }",
    "future_code": "    fn default() -> Self {\n        Self {\n            query: String::new(),\n            db_path: \"parseltongue.db\".to_string(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436049Z",
      "modified_at": "2025-11-01T15:29:24.436049Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt04-syntax-preflight-validator_src_validator_rs:85-87",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 85,
        "end": 87
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436050Z",
      "modified_at": "2025-11-01T15:29:24.436050Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:162-164",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 162,
        "end": 164
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436051Z",
      "modified_at": "2025-11-01T15:29:24.436051Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:default:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:103-105",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "default",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 103,
        "end": 105
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "future_code": "    fn default() -> Self {\n        Self::new()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436052Z",
      "modified_at": "2025-11-01T15:29:24.436052Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:delete:______crates_parseltongue-core_src_entities_rs:202-208",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "delete",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 202,
        "end": 208
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn delete() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,\n            future_action: Some(TemporalAction::Delete),\n        }\n    }",
    "future_code": "    pub fn delete() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,\n            future_action: Some(TemporalAction::Delete),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436053Z",
      "modified_at": "2025-11-01T15:29:24.436053Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:delete_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:1149-1151",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "delete_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1149,
        "end": 1151
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn delete_entity(&mut self, isgl1_key: &str) -> Result<()> {\n        self.delete_entity(isgl1_key).await\n    }",
    "future_code": "    async fn delete_entity(&mut self, isgl1_key: &str) -> Result<()> {\n        self.delete_entity(isgl1_key).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436054Z",
      "modified_at": "2025-11-01T15:29:24.436055Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:delete_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:731-748",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "delete_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 731,
        "end": 748
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn delete_entity(&self, isgl1_key: &str) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key] <- [[$key]]\n            :rm CodeGraph { ISGL1_key }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"delete_entity\".to_string(),\n                details: format!(\"Failed to delete entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn delete_entity(&self, isgl1_key: &str) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key] <- [[$key]]\n            :rm CodeGraph { ISGL1_key }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"delete_entity\".to_string(),\n                details: format!(\"Failed to delete entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436056Z",
      "modified_at": "2025-11-01T15:29:24.436056Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:delete_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:77-85",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "delete_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 77,
        "end": 85
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn delete_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - permanent deletion\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ultra-minimalist: Permanent deletion, NO trash\n        tokio::fs::remove_file(&file_path).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Delete))\n    }",
    "future_code": "    async fn delete_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - permanent deletion\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ultra-minimalist: Permanent deletion, NO trash\n        tokio::fs::remove_file(&file_path).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Delete))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436057Z",
      "modified_at": "2025-11-01T15:29:24.436057Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:delete_table:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:47-57",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "delete_table",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 47,
        "end": 57
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn delete_table(&self) -> Result<()> {\n        // Get all entities (simple, direct)\n        let entities = self.storage.get_all_entities().await?;\n\n        // Delete each one (brute-force, ultra-minimalist)\n        for entity in entities {\n            self.storage.delete_entity(&entity.isgl1_key).await?;\n        }\n\n        Ok(())\n    }",
    "future_code": "    async fn delete_table(&self) -> Result<()> {\n        // Get all entities (simple, direct)\n        let entities = self.storage.get_all_entities().await?;\n\n        // Delete each one (brute-force, ultra-minimalist)\n        for entity in entities {\n            self.storage.delete_entity(&entity.isgl1_key).await?;\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436058Z",
      "modified_at": "2025-11-01T15:29:24.436058Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:demo_5_line_code_change:______crates_pt05-llm-cozodb-to-diff-writer_tests_demo_5_line_change_rs:14-122",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "demo_5_line_code_change",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/demo_5_line_change.rs",
      "line_range": {
        "start": 14,
        "end": 122
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn demo_5_line_code_change() {\n    println!(\"\\n\");\n    println!(\"         Tool 5 Demo: 5-Line Code Change                      \");\n    println!(\"\\n\");\n\n    // Setup: In-memory CozoDB\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    println!(\" Scenario: Editing a simple function in src/lib.rs\");\n    println!();\n\n    // CURRENT CODE (before) - 5 lines\n    let current_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // TODO: Add error handling\n    a + b\n}\"#;\n\n    // FUTURE CODE (after) - 5 lines with improvement\n    let future_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // Added validation for overflow\n    a.checked_add(b).unwrap_or(i32::MAX)\n}\"#;\n\n    println!(\" CURRENT CODE (lines 10-14 in src/lib.rs):\");\n    println!(\"\");\n    println!(\"{}\", current_code);\n    println!();\n\n    println!(\" FUTURE CODE (improved version):\");\n    println!(\"\");\n    println!(\"{}\", future_code);\n    println!();\n\n    // Create entity representing this change\n    let entity = CodeEntity {\n        isgl1_key: \"rust:fn:calculate_sum:src_lib_rs:10-14\".to_string(),\n        current_code: Some(current_code.to_string()),\n        future_code: Some(future_code.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"calculate_sum\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/lib.rs\"),\n            line_range: LineRange { start: 10, end: 14 },\n            module_path: vec![\"crate\".to_string()],\n            documentation: Some(\"Calculates sum with overflow protection\".to_string()),\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::High,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.8,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: TemporalState::edit(),\n        metadata: EntityMetadata::new().unwrap(),\n    };\n\n    // Insert into CozoDB\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate CodeDiff.json using Tool 5\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    println!(\" Tool 5 Output Summary:\");\n    println!(\"\");\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  Edit operations: {}\", diff.metadata.edit_count);\n    println!(\"  Generated at: {}\", diff.metadata.generated_at);\n    println!();\n\n    println!(\" Generated CodeDiff.json:\");\n    println!(\"\\n\");\n    let json = diff.to_json_pretty().unwrap();\n    println!(\"{}\", json);\n    println!();\n    println!(\"\\n\");\n\n    println!(\" Key Features Demonstrated:\");\n    println!(\"   current_code     Shows exactly what to replace\");\n    println!(\"   future_code      Shows the improved version\");\n    println!(\"   line_range       Precise location (lines 10-14)\");\n    println!(\"   operation: EDIT  LLM knows this is a modification\");\n    println!();\n    println!(\" LLM can now make surgical edits without touching the rest of the file!\");\n    println!();\n\n    // Validate the output\n    assert_eq!(diff.changes.len(), 1);\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, pt05_llm_cozodb_to_diff_writer::Operation::Edit);\n    assert!(change.current_code.is_some());\n    assert!(change.future_code.is_some());\n    assert!(change.line_range.is_some());\n    assert_eq!(change.line_range.unwrap().start, 10);\n    assert_eq!(change.line_range.unwrap().end, 14);\n}",
    "future_code": "async fn demo_5_line_code_change() {\n    println!(\"\\n\");\n    println!(\"         Tool 5 Demo: 5-Line Code Change                      \");\n    println!(\"\\n\");\n\n    // Setup: In-memory CozoDB\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    println!(\" Scenario: Editing a simple function in src/lib.rs\");\n    println!();\n\n    // CURRENT CODE (before) - 5 lines\n    let current_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // TODO: Add error handling\n    a + b\n}\"#;\n\n    // FUTURE CODE (after) - 5 lines with improvement\n    let future_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // Added validation for overflow\n    a.checked_add(b).unwrap_or(i32::MAX)\n}\"#;\n\n    println!(\" CURRENT CODE (lines 10-14 in src/lib.rs):\");\n    println!(\"\");\n    println!(\"{}\", current_code);\n    println!();\n\n    println!(\" FUTURE CODE (improved version):\");\n    println!(\"\");\n    println!(\"{}\", future_code);\n    println!();\n\n    // Create entity representing this change\n    let entity = CodeEntity {\n        isgl1_key: \"rust:fn:calculate_sum:src_lib_rs:10-14\".to_string(),\n        current_code: Some(current_code.to_string()),\n        future_code: Some(future_code.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"calculate_sum\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/lib.rs\"),\n            line_range: LineRange { start: 10, end: 14 },\n            module_path: vec![\"crate\".to_string()],\n            documentation: Some(\"Calculates sum with overflow protection\".to_string()),\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::High,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.8,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: TemporalState::edit(),\n        metadata: EntityMetadata::new().unwrap(),\n    };\n\n    // Insert into CozoDB\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate CodeDiff.json using Tool 5\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    println!(\" Tool 5 Output Summary:\");\n    println!(\"\");\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  Edit operations: {}\", diff.metadata.edit_count);\n    println!(\"  Generated at: {}\", diff.metadata.generated_at);\n    println!();\n\n    println!(\" Generated CodeDiff.json:\");\n    println!(\"\\n\");\n    let json = diff.to_json_pretty().unwrap();\n    println!(\"{}\", json);\n    println!();\n    println!(\"\\n\");\n\n    println!(\" Key Features Demonstrated:\");\n    println!(\"   current_code     Shows exactly what to replace\");\n    println!(\"   future_code      Shows the improved version\");\n    println!(\"   line_range       Precise location (lines 10-14)\");\n    println!(\"   operation: EDIT  LLM knows this is a modification\");\n    println!();\n    println!(\" LLM can now make surgical edits without touching the rest of the file!\");\n    println!();\n\n    // Validate the output\n    assert_eq!(diff.changes.len(), 1);\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, pt05_llm_cozodb_to_diff_writer::Operation::Edit);\n    assert!(change.current_code.is_some());\n    assert!(change.future_code.is_some());\n    assert!(change.line_range.is_some());\n    assert_eq!(change.line_range.unwrap().start, 10);\n    assert_eq!(change.line_range.unwrap().end, 14);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436059Z",
      "modified_at": "2025-11-01T15:29:24.436059Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:desanitize_path:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:164-183",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "desanitize_path",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 164,
        "end": 183
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn desanitize_path(&self, sanitized: &str) -> PathBuf {\n        // Common file extensions\n        let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n        // Find and replace extension suffix\n        for ext in extensions {\n            if let Some(idx) = sanitized.rfind(ext) {\n                if idx + ext.len() == sanitized.len() {\n                    // Found extension at end\n                    let path_part = &sanitized[..idx]; // \"src_lib\"\n                    let ext_part = &ext[1..]; // \"rs\"\n                    let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                    return PathBuf::from(file_path);\n                }\n            }\n        }\n\n        // No known extension found, treat as-is\n        PathBuf::from(sanitized.replace('_', \"/\"))\n    }",
    "future_code": "    fn desanitize_path(&self, sanitized: &str) -> PathBuf {\n        // Common file extensions\n        let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n        // Find and replace extension suffix\n        for ext in extensions {\n            if let Some(idx) = sanitized.rfind(ext) {\n                if idx + ext.len() == sanitized.len() {\n                    // Found extension at end\n                    let path_part = &sanitized[..idx]; // \"src_lib\"\n                    let ext_part = &ext[1..]; // \"rs\"\n                    let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                    return PathBuf::from(file_path);\n                }\n            }\n        }\n\n        // No known extension found, treat as-is\n        PathBuf::from(sanitized.replace('_', \"/\"))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436061Z",
      "modified_at": "2025-11-01T15:29:24.436061Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:desanitize_path:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:443-462",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "desanitize_path",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 443,
        "end": 462
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn desanitize_path(sanitized: &str) -> PathBuf {\n    // Common file extensions\n    let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n    // Find and replace extension suffix\n    for ext in extensions {\n        if let Some(idx) = sanitized.rfind(ext) {\n            if idx + ext.len() == sanitized.len() {\n                // Found extension at end\n                let path_part = &sanitized[..idx]; // \"src_lib\"\n                let ext_part = &ext[1..]; // \"rs\"\n                let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                return PathBuf::from(file_path);\n            }\n        }\n    }\n\n    // No known extension found, treat as-is\n    PathBuf::from(sanitized.replace('_', \"/\"))\n}",
    "future_code": "fn desanitize_path(sanitized: &str) -> PathBuf {\n    // Common file extensions\n    let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n    // Find and replace extension suffix\n    for ext in extensions {\n        if let Some(idx) = sanitized.rfind(ext) {\n            if idx + ext.len() == sanitized.len() {\n                // Found extension at end\n                let path_part = &sanitized[..idx]; // \"src_lib\"\n                let ext_part = &ext[1..]; // \"rs\"\n                let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                return PathBuf::from(file_path);\n            }\n        }\n    }\n\n    // No known extension found, treat as-is\n    PathBuf::from(sanitized.replace('_', \"/\"))\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436062Z",
      "modified_at": "2025-11-01T15:29:24.436062Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:detect_conflicts:______crates_parseltongue-core_src_temporal_rs:473-495",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "detect_conflicts",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 473,
        "end": 495
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn detect_conflicts(&self, changes: &[TemporalChange]) -> Vec<Conflict> {\n        let mut conflicts = Vec::new();\n\n        // Check for multiple changes to same entity\n        let mut entity_changes: HashMap<String, Vec<&TemporalChange>> = HashMap::new();\n        for change in changes {\n            entity_changes\n                .entry(change.isgl1_key.clone())\n                .or_default()\n                .push(change);\n        }\n\n        for (entity, entity_changes) in entity_changes {\n            if entity_changes.len() > 1 {\n                conflicts.push(Conflict::MultipleChanges {\n                    entity,\n                    changes: entity_changes.iter().map(|c| (*c).clone()).collect(),\n                });\n            }\n        }\n\n        conflicts\n    }",
    "future_code": "    pub fn detect_conflicts(&self, changes: &[TemporalChange]) -> Vec<Conflict> {\n        let mut conflicts = Vec::new();\n\n        // Check for multiple changes to same entity\n        let mut entity_changes: HashMap<String, Vec<&TemporalChange>> = HashMap::new();\n        for change in changes {\n            entity_changes\n                .entry(change.isgl1_key.clone())\n                .or_default()\n                .push(change);\n        }\n\n        for (entity, entity_changes) in entity_changes {\n            if entity_changes.len() > 1 {\n                conflicts.push(Conflict::MultipleChanges {\n                    entity,\n                    changes: entity_changes.iter().map(|c| (*c).clone()).collect(),\n                });\n            }\n        }\n\n        conflicts\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436063Z",
      "modified_at": "2025-11-01T15:29:24.436063Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:edge_type:______crates_parseltongue-core_src_entities_rs:1047-1050",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "edge_type",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1047,
        "end": 1050
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn edge_type(mut self, edge_type: EdgeType) -> Self {\n        self.edge_type = Some(edge_type);\n        self\n    }",
    "future_code": "    pub fn edge_type(mut self, edge_type: EdgeType) -> Self {\n        self.edge_type = Some(edge_type);\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436064Z",
      "modified_at": "2025-11-01T15:29:24.436064Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:edit:______crates_parseltongue-core_src_entities_rs:193-199",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "edit",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 193,
        "end": 199
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn edit() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,\n            future_action: Some(TemporalAction::Edit),\n        }\n    }",
    "future_code": "    pub fn edit() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,\n            future_action: Some(TemporalAction::Edit),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436065Z",
      "modified_at": "2025-11-01T15:29:24.436065Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:effective_code:______crates_parseltongue-core_src_entities_rs:658-664",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "effective_code",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 658,
        "end": 664
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn effective_code(&self) -> Option<&String> {\n        if self.temporal_state.future_action.is_some() {\n            self.future_code.as_ref()\n        } else {\n            self.current_code.as_ref()\n        }\n    }",
    "future_code": "    pub fn effective_code(&self) -> Option<&String> {\n        if self.temporal_state.future_action.is_some() {\n            self.future_code.as_ref()\n        } else {\n            self.current_code.as_ref()\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436066Z",
      "modified_at": "2025-11-01T15:29:24.436066Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:entity_creation_and_modification:______crates_parseltongue-core_src_temporal_rs:595-642",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "entity_creation_and_modification",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 595,
        "end": 642
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn entity_creation_and_modification() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Create entity\n        let mut entity = CodeEntity::new(\n            \"test.rs-compute_result\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"calculate_value\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange::new(1, 5).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn test() {}\".to_string());\n        entity.future_code = Some(\"fn test() {}\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        manager.add_entity(entity).unwrap();\n\n        // Apply edit change\n        let changes = vec![TemporalChange {\n            isgl1_key: \"test.rs-compute_result\".to_string(),\n            action: TemporalAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            updated_signature: None,\n        }];\n\n        let affected = manager.apply_changes(changes).unwrap();\n        assert_eq!(affected.len(), 1);\n        assert_eq!(affected[0], \"test.rs-compute_result\");\n\n        let changed_entities = manager.get_changed_entities();\n        assert_eq!(changed_entities.len(), 1);\n    }",
    "future_code": "    fn entity_creation_and_modification() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Create entity\n        let mut entity = CodeEntity::new(\n            \"test.rs-compute_result\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"calculate_value\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange::new(1, 5).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn test() {}\".to_string());\n        entity.future_code = Some(\"fn test() {}\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        manager.add_entity(entity).unwrap();\n\n        // Apply edit change\n        let changes = vec![TemporalChange {\n            isgl1_key: \"test.rs-compute_result\".to_string(),\n            action: TemporalAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            updated_signature: None,\n        }];\n\n        let affected = manager.apply_changes(changes).unwrap();\n        assert_eq!(affected.len(), 1);\n        assert_eq!(affected[0], \"test.rs-compute_result\");\n\n        let changed_entities = manager.get_changed_entities();\n        assert_eq!(changed_entities.len(), 1);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436067Z",
      "modified_at": "2025-11-01T15:29:24.436067Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:entity_to_change:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:80-130",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "entity_to_change",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 80,
        "end": 130
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn entity_to_change(&self, entity: &CodeEntity) -> Result<Option<Change>> {\n        // Determine operation from temporal state's future_action\n        let operation = match entity.temporal_state.future_action {\n            Some(TemporalAction::Create) => Operation::Create,\n            Some(TemporalAction::Edit) => Operation::Edit,\n            Some(TemporalAction::Delete) => Operation::Delete,\n            None => return Ok(None), // Skip entities with no future action (unchanged)\n        };\n\n        // Extract file path from ISGL1 key\n        let file_path = self.extract_file_path(&entity.isgl1_key)?;\n\n        // Extract line range from ISGL1 key (if line-based format)\n        let line_range = self.extract_line_range(&entity.isgl1_key);\n\n        // Extract current_code based on operation:\n        // - CREATE: None (entity doesn't exist yet)\n        // - EDIT/DELETE: Some (need to know what to replace/remove)\n        let current_code = match operation {\n            Operation::Create => None,\n            Operation::Edit | Operation::Delete => entity.current_code.clone(),\n        };\n\n        // Extract future_code based on operation:\n        // - CREATE/EDIT: Some (what to write)\n        // - DELETE: None (removing code)\n        let future_code = match operation {\n            Operation::Create | Operation::Edit => entity.future_code.clone(),\n            Operation::Delete => None,\n        };\n\n        // Format interface signature from components\n        let interface_signature = format!(\n            \"{:?} {}\",\n            entity.interface_signature.entity_type,\n            entity.interface_signature.name\n        );\n\n        // Create change with enhanced fields\n        let change = Change {\n            isgl1_key: entity.isgl1_key.clone(),\n            file_path,\n            operation,\n            current_code,\n            future_code,\n            line_range,\n            interface_signature,\n        };\n\n        Ok(Some(change))\n    }",
    "future_code": "    fn entity_to_change(&self, entity: &CodeEntity) -> Result<Option<Change>> {\n        // Determine operation from temporal state's future_action\n        let operation = match entity.temporal_state.future_action {\n            Some(TemporalAction::Create) => Operation::Create,\n            Some(TemporalAction::Edit) => Operation::Edit,\n            Some(TemporalAction::Delete) => Operation::Delete,\n            None => return Ok(None), // Skip entities with no future action (unchanged)\n        };\n\n        // Extract file path from ISGL1 key\n        let file_path = self.extract_file_path(&entity.isgl1_key)?;\n\n        // Extract line range from ISGL1 key (if line-based format)\n        let line_range = self.extract_line_range(&entity.isgl1_key);\n\n        // Extract current_code based on operation:\n        // - CREATE: None (entity doesn't exist yet)\n        // - EDIT/DELETE: Some (need to know what to replace/remove)\n        let current_code = match operation {\n            Operation::Create => None,\n            Operation::Edit | Operation::Delete => entity.current_code.clone(),\n        };\n\n        // Extract future_code based on operation:\n        // - CREATE/EDIT: Some (what to write)\n        // - DELETE: None (removing code)\n        let future_code = match operation {\n            Operation::Create | Operation::Edit => entity.future_code.clone(),\n            Operation::Delete => None,\n        };\n\n        // Format interface signature from components\n        let interface_signature = format!(\n            \"{:?} {}\",\n            entity.interface_signature.entity_type,\n            entity.interface_signature.name\n        );\n\n        // Create change with enhanced fields\n        let change = Change {\n            isgl1_key: entity.isgl1_key.clone(),\n            file_path,\n            operation,\n            current_code,\n            future_code,\n            line_range,\n            interface_signature,\n        };\n\n        Ok(Some(change))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436068Z",
      "modified_at": "2025-11-01T15:29:24.436068Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:entity_to_minimal:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:97-108",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "entity_to_minimal",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 97,
        "end": 108
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn entity_to_minimal(&self, entity: &CodeEntity) -> MinimalEntity {\n        MinimalEntity {\n            isgl1_key: entity.isgl1_key.clone(),\n            interface_signature: format!(\n                \"{:?} {}\",\n                entity.interface_signature.entity_type,\n                entity.interface_signature.name\n            ),\n            tdd_classification: format!(\"{:?}\", entity.tdd_classification.entity_class),\n            lsp_metadata: entity.lsp_metadata.as_ref().map(|m| format!(\"{:?}\", m)),\n        }\n    }",
    "future_code": "    fn entity_to_minimal(&self, entity: &CodeEntity) -> MinimalEntity {\n        MinimalEntity {\n            isgl1_key: entity.isgl1_key.clone(),\n            interface_signature: format!(\n                \"{:?} {}\",\n                entity.interface_signature.entity_type,\n                entity.interface_signature.name\n            ),\n            tdd_classification: format!(\"{:?}\", entity.tdd_classification.entity_class),\n            lsp_metadata: entity.lsp_metadata.as_ref().map(|m| format!(\"{:?}\", m)),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436069Z",
      "modified_at": "2025-11-01T15:29:24.436069Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:entity_to_params:______crates_parseltongue-core_src_storage_cozo_client_rs:836-978",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "entity_to_params",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 836,
        "end": 978
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn entity_to_params(&self, entity: &CodeEntity) -> Result<BTreeMap<String, DataValue>> {\n        let mut params = BTreeMap::new();\n\n        params.insert(\n            \"ISGL1_key\".to_string(),\n            DataValue::Str(entity.isgl1_key.clone().into()),\n        );\n\n        params.insert(\n            \"Current_Code\".to_string(),\n            entity\n                .current_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"Future_Code\".to_string(),\n            entity\n                .future_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        // Serialize complex types as JSON\n        let signature_json = serde_json::to_string(&entity.interface_signature)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize interface_signature: {}\", e),\n            })?;\n        params.insert(\n            \"interface_signature\".to_string(),\n            DataValue::Str(signature_json.into()),\n        );\n\n        let tdd_json = serde_json::to_string(&entity.tdd_classification)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize TDD_Classification: {}\", e),\n            })?;\n        params.insert(\n            \"TDD_Classification\".to_string(),\n            DataValue::Str(tdd_json.into()),\n        );\n\n        params.insert(\n            \"lsp_meta_data\".to_string(),\n            if let Some(ref lsp) = entity.lsp_metadata {\n                let lsp_json = serde_json::to_string(lsp)\n                    .map_err(|e| ParseltongError::SerializationError {\n                        details: format!(\"Failed to serialize lsp_meta_data: {}\", e),\n                    })?;\n                DataValue::Str(lsp_json.into())\n            } else {\n                DataValue::Null\n            },\n        );\n\n        params.insert(\n            \"current_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.current_ind),\n        );\n\n        params.insert(\n            \"future_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.future_ind),\n        );\n\n        params.insert(\n            \"Future_Action\".to_string(),\n            entity\n                .temporal_state\n                .future_action\n                .as_ref()\n                .map(|action| {\n                    DataValue::Str(\n                        match action {\n                            TemporalAction::Create => \"Create\",\n                            TemporalAction::Edit => \"Edit\",\n                            TemporalAction::Delete => \"Delete\",\n                        }\n                        .into(),\n                    )\n                })\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"file_path\".to_string(),\n            DataValue::Str(\n                entity\n                    .interface_signature\n                    .file_path\n                    .to_string_lossy()\n                    .to_string()\n                    .into(),\n            ),\n        );\n\n        params.insert(\n            \"language\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.language_specific {\n                    LanguageSpecificSignature::Rust(_) => \"rust\",\n                    LanguageSpecificSignature::JavaScript(_) => \"javascript\",\n                    LanguageSpecificSignature::TypeScript(_) => \"typescript\",\n                    LanguageSpecificSignature::Python(_) => \"python\",\n                    LanguageSpecificSignature::Java(_) => \"java\",\n                }\n                .into(),\n            ),\n        );\n\n        params.insert(\n            \"last_modified\".to_string(),\n            DataValue::Str(entity.metadata.modified_at.to_rfc3339().into()),\n        );\n\n        params.insert(\n            \"entity_type\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.entity_type {\n                    EntityType::Function => \"function\",\n                    EntityType::Method => \"method\",\n                    EntityType::Struct => \"struct\",\n                    EntityType::Enum => \"enum\",\n                    EntityType::Trait => \"trait\",\n                    EntityType::Interface => \"interface\",\n                    EntityType::Module => \"module\",\n                    EntityType::ImplBlock { .. } => \"impl\",\n                    EntityType::Macro => \"macro\",\n                    EntityType::ProcMacro => \"proc_macro\",\n                    EntityType::TestFunction => \"test\",\n                    EntityType::Class => \"class\",\n                    EntityType::Variable => \"variable\",\n                    EntityType::Constant => \"constant\",\n                }\n                .into(),\n            ),\n        );\n\n        Ok(params)\n    }",
    "future_code": "    fn entity_to_params(&self, entity: &CodeEntity) -> Result<BTreeMap<String, DataValue>> {\n        let mut params = BTreeMap::new();\n\n        params.insert(\n            \"ISGL1_key\".to_string(),\n            DataValue::Str(entity.isgl1_key.clone().into()),\n        );\n\n        params.insert(\n            \"Current_Code\".to_string(),\n            entity\n                .current_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"Future_Code\".to_string(),\n            entity\n                .future_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        // Serialize complex types as JSON\n        let signature_json = serde_json::to_string(&entity.interface_signature)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize interface_signature: {}\", e),\n            })?;\n        params.insert(\n            \"interface_signature\".to_string(),\n            DataValue::Str(signature_json.into()),\n        );\n\n        let tdd_json = serde_json::to_string(&entity.tdd_classification)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize TDD_Classification: {}\", e),\n            })?;\n        params.insert(\n            \"TDD_Classification\".to_string(),\n            DataValue::Str(tdd_json.into()),\n        );\n\n        params.insert(\n            \"lsp_meta_data\".to_string(),\n            if let Some(ref lsp) = entity.lsp_metadata {\n                let lsp_json = serde_json::to_string(lsp)\n                    .map_err(|e| ParseltongError::SerializationError {\n                        details: format!(\"Failed to serialize lsp_meta_data: {}\", e),\n                    })?;\n                DataValue::Str(lsp_json.into())\n            } else {\n                DataValue::Null\n            },\n        );\n\n        params.insert(\n            \"current_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.current_ind),\n        );\n\n        params.insert(\n            \"future_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.future_ind),\n        );\n\n        params.insert(\n            \"Future_Action\".to_string(),\n            entity\n                .temporal_state\n                .future_action\n                .as_ref()\n                .map(|action| {\n                    DataValue::Str(\n                        match action {\n                            TemporalAction::Create => \"Create\",\n                            TemporalAction::Edit => \"Edit\",\n                            TemporalAction::Delete => \"Delete\",\n                        }\n                        .into(),\n                    )\n                })\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"file_path\".to_string(),\n            DataValue::Str(\n                entity\n                    .interface_signature\n                    .file_path\n                    .to_string_lossy()\n                    .to_string()\n                    .into(),\n            ),\n        );\n\n        params.insert(\n            \"language\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.language_specific {\n                    LanguageSpecificSignature::Rust(_) => \"rust\",\n                    LanguageSpecificSignature::JavaScript(_) => \"javascript\",\n                    LanguageSpecificSignature::TypeScript(_) => \"typescript\",\n                    LanguageSpecificSignature::Python(_) => \"python\",\n                    LanguageSpecificSignature::Java(_) => \"java\",\n                }\n                .into(),\n            ),\n        );\n\n        params.insert(\n            \"last_modified\".to_string(),\n            DataValue::Str(entity.metadata.modified_at.to_rfc3339().into()),\n        );\n\n        params.insert(\n            \"entity_type\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.entity_type {\n                    EntityType::Function => \"function\",\n                    EntityType::Method => \"method\",\n                    EntityType::Struct => \"struct\",\n                    EntityType::Enum => \"enum\",\n                    EntityType::Trait => \"trait\",\n                    EntityType::Interface => \"interface\",\n                    EntityType::Module => \"module\",\n                    EntityType::ImplBlock { .. } => \"impl\",\n                    EntityType::Macro => \"macro\",\n                    EntityType::ProcMacro => \"proc_macro\",\n                    EntityType::TestFunction => \"test\",\n                    EntityType::Class => \"class\",\n                    EntityType::Variable => \"variable\",\n                    EntityType::Constant => \"constant\",\n                }\n                .into(),\n            ),\n        );\n\n        Ok(params)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436071Z",
      "modified_at": "2025-11-01T15:29:24.436071Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:error_chain_preserves_context:______crates_parseltongue-core_src_error_rs:182-197",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "error_chain_preserves_context",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 182,
        "end": 197
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn error_chain_preserves_context() {\n        let io_error = std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            \"file not found\"\n        );\n\n        let parseltong_error = ParseltongError::FileSystemError {\n            path: \"test.txt\".to_string(),\n            source: io_error,\n        };\n\n        // The error should contain both the path and the underlying IO error\n        let error_string = parseltong_error.to_string();\n        assert!(error_string.contains(\"test.txt\"));\n        assert!(error_string.contains(\"file not found\"));\n    }",
    "future_code": "    fn error_chain_preserves_context() {\n        let io_error = std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            \"file not found\"\n        );\n\n        let parseltong_error = ParseltongError::FileSystemError {\n            path: \"test.txt\".to_string(),\n            source: io_error,\n        };\n\n        // The error should contain both the path and the underlying IO error\n        let error_string = parseltong_error.to_string();\n        assert!(error_string.contains(\"test.txt\"));\n        assert!(error_string.contains(\"file not found\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436072Z",
      "modified_at": "2025-11-01T15:29:24.436072Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:error_formatting_provides_clear_context:______crates_parseltongue-core_src_error_rs:169-179",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "error_formatting_provides_clear_context",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 169,
        "end": 179
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn error_formatting_provides_clear_context() {\n        let error = ParseltongError::ParseError {\n            reason: \"unexpected token\".to_string(),\n            location: \"src/main.rs:42\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Parsing failed\"));\n        assert!(formatted.contains(\"unexpected token\"));\n        assert!(formatted.contains(\"src/main.rs:42\"));\n    }",
    "future_code": "    fn error_formatting_provides_clear_context() {\n        let error = ParseltongError::ParseError {\n            reason: \"unexpected token\".to_string(),\n            location: \"src/main.rs:42\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Parsing failed\"));\n        assert!(formatted.contains(\"unexpected token\"));\n        assert!(formatted.contains(\"src/main.rs:42\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436073Z",
      "modified_at": "2025-11-01T15:29:24.436073Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:escape_future_code:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:134-145",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "escape_future_code",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 134,
        "end": 145
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn escape_future_code(&self) -> String {\n        match &self.future_code {\n            Some(code) => {\n                // Properly escape quotes and backslashes for Datalog string literals\n                let escaped = code\n                    .replace('\\\\', \"\\\\\\\\\")  // Escape backslashes first\n                    .replace('\"', \"\\\\\\\"\");   // Then escape quotes\n                format!(\"\\\"{}\\\"\", escaped)\n            }\n            None => \"null\".to_string(),\n        }\n    }",
    "future_code": "    fn escape_future_code(&self) -> String {\n        match &self.future_code {\n            Some(code) => {\n                // Properly escape quotes and backslashes for Datalog string literals\n                let escaped = code\n                    .replace('\\\\', \"\\\\\\\\\")  // Escape backslashes first\n                    .replace('\"', \"\\\\\\\"\");   // Then escape quotes\n                format!(\"\\\"{}\\\"\", escaped)\n            }\n            None => \"null\".to_string(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436074Z",
      "modified_at": "2025-11-01T15:29:24.436074Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:estimate_tokens:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:111-115",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "estimate_tokens",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 111,
        "end": 115
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn estimate_tokens(&self, context: &CodeGraphContext) -> usize {\n        // Rough estimate: 1 token  4 characters\n        let json = serde_json::to_string(context).unwrap_or_default();\n        json.len() / 4\n    }",
    "future_code": "    fn estimate_tokens(&self, context: &CodeGraphContext) -> usize {\n        // Rough estimate: 1 token  4 characters\n        let json = serde_json::to_string(context).unwrap_or_default();\n        json.len() / 4\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436075Z",
      "modified_at": "2025-11-01T15:29:24.436075Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:execute:______crates_parseltongue-core_src_interfaces_rs:583-596",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "execute",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 583,
        "end": 596
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        async fn execute(&self, _input: ToolInput) -> Result<ToolOutput> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ConfigurationError {\n                    details: \"Mock tool configured to fail\".to_string(),\n                });\n            }\n\n            self.execute_result\n                .clone()\n                .unwrap_or(Ok(ToolOutput::IndexingComplete {\n                    entities_count: 0,\n                    duration_ms: 0,\n                }))\n        }",
    "future_code": "        async fn execute(&self, _input: ToolInput) -> Result<ToolOutput> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ConfigurationError {\n                    details: \"Mock tool configured to fail\".to_string(),\n                });\n            }\n\n            self.execute_result\n                .clone()\n                .unwrap_or(Ok(ToolOutput::IndexingComplete {\n                    entities_count: 0,\n                    duration_ms: 0,\n                }))\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436077Z",
      "modified_at": "2025-11-01T15:29:24.436077Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:execute_query:______crates_parseltongue-core_src_storage_cozo_client_rs:631-639",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "execute_query",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 631,
        "end": 639
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn execute_query(&self, query: &str) -> Result<()> {\n        self.db\n            .run_script(query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"execute_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(())\n    }",
    "future_code": "    pub async fn execute_query(&self, query: &str) -> Result<()> {\n        self.db\n            .run_script(query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"execute_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436078Z",
      "modified_at": "2025-11-01T15:29:24.436078Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_callee_name:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:306-315",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_callee_name",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 306,
        "end": 315
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_callee_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        // call_expression structure: function_name arguments\n        // We want the identifier node\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"identifier\" || child.kind() == \"field_expression\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "future_code": "    fn extract_callee_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        // call_expression structure: function_name arguments\n        // We want the identifier node\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"identifier\" || child.kind() == \"field_expression\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436079Z",
      "modified_at": "2025-11-01T15:29:24.436079Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_code_snippet:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:241-249",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_code_snippet",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 241,
        "end": 249
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_code_snippet(&self, source: &str, start_line: usize, end_line: usize) -> String {\n        source\n            .lines()\n            .enumerate()\n            .filter(|(idx, _)| *idx + 1 >= start_line && *idx < end_line)\n            .map(|(_, line)| line)\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }",
    "future_code": "    fn extract_code_snippet(&self, source: &str, start_line: usize, end_line: usize) -> String {\n        source\n            .lines()\n            .enumerate()\n            .filter(|(idx, _)| *idx + 1 >= start_line && *idx < end_line)\n            .map(|(_, line)| line)\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436080Z",
      "modified_at": "2025-11-01T15:29:24.436080Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_dependencies_pass2:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:186-202",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_dependencies_pass2",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 186,
        "end": 202
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_dependencies_pass2(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &[ParsedEntity],\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // Extract dependencies from this node\n        self.extract_rust_dependencies(node, source, file_path, entities, dependencies);\n\n        // Recurse through children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.extract_dependencies_pass2(&child, source, file_path, entities, dependencies);\n        }\n    }",
    "future_code": "    fn extract_dependencies_pass2(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &[ParsedEntity],\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // Extract dependencies from this node\n        self.extract_rust_dependencies(node, source, file_path, entities, dependencies);\n\n        // Recurse through children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.extract_dependencies_pass2(&child, source, file_path, entities, dependencies);\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436081Z",
      "modified_at": "2025-11-01T15:29:24.436081Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_entities:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:165-183",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 165,
        "end": 183
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_entities(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        let root_node = tree.root_node();\n\n        // Pass 1: Extract entities (populate entities vec)\n        self.walk_node(&root_node, source, file_path, language, entities, dependencies);\n\n        // Pass 2: Extract dependencies (now entities are complete)\n        if language == Language::Rust {\n            self.extract_dependencies_pass2(&root_node, source, file_path, entities, dependencies);\n        }\n    }",
    "future_code": "    fn extract_entities(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        let root_node = tree.root_node();\n\n        // Pass 1: Extract entities (populate entities vec)\n        self.walk_node(&root_node, source, file_path, language, entities, dependencies);\n\n        // Pass 2: Extract dependencies (now entities are complete)\n        if language == Language::Rust {\n            self.extract_dependencies_pass2(&root_node, source, file_path, entities, dependencies);\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436082Z",
      "modified_at": "2025-11-01T15:29:24.436082Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_file_path:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:133-160",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_file_path",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 133,
        "end": 160
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_file_path(&self, isgl1_key: &str) -> Result<PathBuf> {\n        // ISGL1 key formats:\n        // - Line-based: \"rust:fn:name:src_lib_rs:42-56\"\n        // - Hash-based: \"src_lib_rs-new_feature-fn-abc12345\"\n        //\n        // Sanitized paths encode \"src/lib.rs\" as \"src_lib_rs\"\n        // The \"_rs\" suffix represents the \".rs\" extension\n        // Other underscores represent directory separators\n\n        if isgl1_key.contains(':') {\n            // Line-based format\n            let parts: Vec<&str> = isgl1_key.split(':').collect();\n            if parts.len() >= 4 {\n                let sanitized_path = parts[3]; // \"src_lib_rs\"\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        } else {\n            // Hash-based format\n            let parts: Vec<&str> = isgl1_key.split('-').collect();\n            if !parts.is_empty() {\n                // First part is sanitized file path\n                let sanitized_path = parts[0];\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        }\n\n        anyhow::bail!(\"Invalid ISGL1 key format: {}\", isgl1_key)\n    }",
    "future_code": "    fn extract_file_path(&self, isgl1_key: &str) -> Result<PathBuf> {\n        // ISGL1 key formats:\n        // - Line-based: \"rust:fn:name:src_lib_rs:42-56\"\n        // - Hash-based: \"src_lib_rs-new_feature-fn-abc12345\"\n        //\n        // Sanitized paths encode \"src/lib.rs\" as \"src_lib_rs\"\n        // The \"_rs\" suffix represents the \".rs\" extension\n        // Other underscores represent directory separators\n\n        if isgl1_key.contains(':') {\n            // Line-based format\n            let parts: Vec<&str> = isgl1_key.split(':').collect();\n            if parts.len() >= 4 {\n                let sanitized_path = parts[3]; // \"src_lib_rs\"\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        } else {\n            // Hash-based format\n            let parts: Vec<&str> = isgl1_key.split('-').collect();\n            if !parts.is_empty() {\n                // First part is sanitized file path\n                let sanitized_path = parts[0];\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        }\n\n        anyhow::bail!(\"Invalid ISGL1 key format: {}\", isgl1_key)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436084Z",
      "modified_at": "2025-11-01T15:29:24.436084Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_function_name:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:349-356",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_function_name",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 349,
        "end": 356
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_function_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"identifier\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "future_code": "    fn extract_function_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"identifier\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436085Z",
      "modified_at": "2025-11-01T15:29:24.436085Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_line_range:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:186-210",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_line_range",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 186,
        "end": 210
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_line_range(&self, isgl1_key: &str) -> Option<LineRange> {\n        // Only line-based keys have line ranges: \"rust:fn:name:src_lib_rs:42-56\"\n        // Hash-based keys do not: \"src_lib_rs-new_feature-fn-abc12345\"\n\n        if !isgl1_key.contains(':') {\n            return None; // Hash-based key\n        }\n\n        // Line-based format: last part is \"start-end\"\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() < 5 {\n            return None;\n        }\n\n        let line_part = parts[4]; // \"42-56\"\n        let line_nums: Vec<&str> = line_part.split('-').collect();\n        if line_nums.len() != 2 {\n            return None;\n        }\n\n        let start = line_nums[0].parse::<u32>().ok()?;\n        let end = line_nums[1].parse::<u32>().ok()?;\n\n        Some(LineRange { start, end })\n    }",
    "future_code": "    fn extract_line_range(&self, isgl1_key: &str) -> Option<LineRange> {\n        // Only line-based keys have line ranges: \"rust:fn:name:src_lib_rs:42-56\"\n        // Hash-based keys do not: \"src_lib_rs-new_feature-fn-abc12345\"\n\n        if !isgl1_key.contains(':') {\n            return None; // Hash-based key\n        }\n\n        // Line-based format: last part is \"start-end\"\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() < 5 {\n            return None;\n        }\n\n        let line_part = parts[4]; // \"42-56\"\n        let line_nums: Vec<&str> = line_part.split('-').collect();\n        if line_nums.len() != 2 {\n            return None;\n        }\n\n        let start = line_nums[0].parse::<u32>().ok()?;\n        let end = line_nums[1].parse::<u32>().ok()?;\n\n        Some(LineRange { start, end })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436086Z",
      "modified_at": "2025-11-01T15:29:24.436086Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_rust_dependencies:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:237-280",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_rust_dependencies",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 237,
        "end": 280
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_rust_dependencies(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &[ParsedEntity],\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // Only extract calls from function bodies\n        if node.kind() == \"call_expression\" {\n            // Find the containing function\n            let containing_function = self.find_containing_function(node, entities);\n            if let Some(from_entity) = containing_function {\n                // Extract the function being called\n                if let Some(callee_name) = self.extract_callee_name(node, source) {\n                    // Find the target function entity\n                    let to_entity = entities.iter().find(|e| {\n                        e.entity_type == EntityType::Function && e.name == callee_name\n                    });\n\n                    if let Some(to) = to_entity {\n                        // Generate ISGL1 keys for both\n                        if let (Ok(from_key), Ok(to_key)) = (\n                            self.generate_key(from_entity),\n                            self.generate_key(to),\n                        ) {\n                            // Create dependency edge\n                            if let Ok(edge) = DependencyEdge::builder()\n                                .from_key(from_key)\n                                .to_key(to_key)\n                                .edge_type(EdgeType::Calls)\n                                .source_location(format!(\"{}:{}\",\n                                    file_path.display(),\n                                    node.start_position().row + 1))\n                                .build()\n                            {\n                                dependencies.push(edge);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "future_code": "    fn extract_rust_dependencies(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &[ParsedEntity],\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // Only extract calls from function bodies\n        if node.kind() == \"call_expression\" {\n            // Find the containing function\n            let containing_function = self.find_containing_function(node, entities);\n            if let Some(from_entity) = containing_function {\n                // Extract the function being called\n                if let Some(callee_name) = self.extract_callee_name(node, source) {\n                    // Find the target function entity\n                    let to_entity = entities.iter().find(|e| {\n                        e.entity_type == EntityType::Function && e.name == callee_name\n                    });\n\n                    if let Some(to) = to_entity {\n                        // Generate ISGL1 keys for both\n                        if let (Ok(from_key), Ok(to_key)) = (\n                            self.generate_key(from_entity),\n                            self.generate_key(to),\n                        ) {\n                            // Create dependency edge\n                            if let Ok(edge) = DependencyEdge::builder()\n                                .from_key(from_key)\n                                .to_key(to_key)\n                                .edge_type(EdgeType::Calls)\n                                .source_location(format!(\"{}:{}\",\n                                    file_path.display(),\n                                    node.start_position().row + 1))\n                                .build()\n                            {\n                                dependencies.push(edge);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436088Z",
      "modified_at": "2025-11-01T15:29:24.436088Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_rust_entities:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:318-346",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_rust_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 318,
        "end": 346
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_rust_entities(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &mut Vec<ParsedEntity>,\n    ) {\n        match node.kind() {\n            \"function_item\" => {\n                // Skip - functions are handled separately in walk_node to check attributes\n            }\n            \"struct_item\" => {\n                if let Some(name) = self.extract_struct_name(node, source) {\n                    let start_line = node.start_position().row + 1;\n                    let end_line = node.end_position().row + 1;\n\n                    entities.push(ParsedEntity {\n                        entity_type: EntityType::Struct,\n                        name,\n                        language: Language::Rust,\n                        line_range: (start_line, end_line),\n                        file_path: file_path.to_string_lossy().to_string(),\n                        metadata: HashMap::new(),\n                    });\n                }\n            }\n            _ => {}\n        }\n    }",
    "future_code": "    fn extract_rust_entities(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &mut Vec<ParsedEntity>,\n    ) {\n        match node.kind() {\n            \"function_item\" => {\n                // Skip - functions are handled separately in walk_node to check attributes\n            }\n            \"struct_item\" => {\n                if let Some(name) = self.extract_struct_name(node, source) {\n                    let start_line = node.start_position().row + 1;\n                    let end_line = node.end_position().row + 1;\n\n                    entities.push(ParsedEntity {\n                        entity_type: EntityType::Struct,\n                        name,\n                        language: Language::Rust,\n                        line_range: (start_line, end_line),\n                        file_path: file_path.to_string_lossy().to_string(),\n                        metadata: HashMap::new(),\n                    });\n                }\n            }\n            _ => {}\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436089Z",
      "modified_at": "2025-11-01T15:29:24.436089Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_rust_function_with_test_info:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:399-425",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_rust_function_with_test_info",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 399,
        "end": 425
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_rust_function_with_test_info(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &mut Vec<ParsedEntity>,\n        is_test: bool,\n    ) {\n        if let Some(name) = self.extract_function_name(node, source) {\n            let start_line = node.start_position().row + 1;\n            let end_line = node.end_position().row + 1;\n\n            let mut metadata = HashMap::new();\n            if is_test {\n                metadata.insert(\"is_test\".to_string(), \"true\".to_string());\n            }\n\n            entities.push(ParsedEntity {\n                entity_type: EntityType::Function,\n                name,\n                language: Language::Rust,\n                line_range: (start_line, end_line),\n                file_path: file_path.to_string_lossy().to_string(),\n                metadata,\n            });\n        }\n    }",
    "future_code": "    fn extract_rust_function_with_test_info(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        entities: &mut Vec<ParsedEntity>,\n        is_test: bool,\n    ) {\n        if let Some(name) = self.extract_function_name(node, source) {\n            let start_line = node.start_position().row + 1;\n            let end_line = node.end_position().row + 1;\n\n            let mut metadata = HashMap::new();\n            if is_test {\n                metadata.insert(\"is_test\".to_string(), \"true\".to_string());\n            }\n\n            entities.push(ParsedEntity {\n                entity_type: EntityType::Function,\n                name,\n                language: Language::Rust,\n                line_range: (start_line, end_line),\n                file_path: file_path.to_string_lossy().to_string(),\n                metadata,\n            });\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436090Z",
      "modified_at": "2025-11-01T15:29:24.436090Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:extract_struct_name:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:359-366",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "extract_struct_name",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 359,
        "end": 366
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn extract_struct_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"type_identifier\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "future_code": "    fn extract_struct_name(&self, node: &tree_sitter::Node<'_>, source: &str) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"type_identifier\" {\n                return Some(source[child.byte_range()].to_string());\n            }\n        }\n        None\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436091Z",
      "modified_at": "2025-11-01T15:29:24.436091Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:failure:______crates_pt04-syntax-preflight-validator_src_types_rs:77-86",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "failure",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 77,
        "end": 86
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn failure(validation_type: ValidationType, error: ValidationError) -> Self {\n        Self {\n            is_valid: false,\n            validation_type,\n            errors: vec![error.to_string()],\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
    "future_code": "    pub fn failure(validation_type: ValidationType, error: ValidationError) -> Self {\n        Self {\n            is_valid: false,\n            validation_type,\n            errors: vec![error.to_string()],\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436092Z",
      "modified_at": "2025-11-01T15:29:24.436092Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fetch_lsp_metadata_for_entity:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:490-513",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fetch_lsp_metadata_for_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 490,
        "end": 513
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn fetch_lsp_metadata_for_entity(\n        &self,\n        entity: &ParsedEntity,\n        file_path: &Path,\n    ) -> Option<LspMetadata> {\n        // Only fetch for Rust files\n        if entity.language != Language::Rust {\n            return None;\n        }\n\n        // Calculate hover position at the start of the entity (line is 0-indexed in LSP)\n        let line = entity.line_range.0.saturating_sub(1) as u32;\n        let character = 0u32; // Start of line (tree-sitter gives us the entity name position)\n\n        // Request hover metadata\n        match self.lsp_client.hover(file_path, line, character).await {\n            Ok(Some(hover_response)) => {\n                // Convert hover response to LspMetadata (stub/MVP implementation)\n                Self::hover_response_to_lsp_metadata(&hover_response)\n            }\n            Ok(None) => None, // Graceful degradation\n            Err(_) => None,   // Graceful degradation\n        }\n    }",
    "future_code": "    async fn fetch_lsp_metadata_for_entity(\n        &self,\n        entity: &ParsedEntity,\n        file_path: &Path,\n    ) -> Option<LspMetadata> {\n        // Only fetch for Rust files\n        if entity.language != Language::Rust {\n            return None;\n        }\n\n        // Calculate hover position at the start of the entity (line is 0-indexed in LSP)\n        let line = entity.line_range.0.saturating_sub(1) as u32;\n        let character = 0u32; // Start of line (tree-sitter gives us the entity name position)\n\n        // Request hover metadata\n        match self.lsp_client.hover(file_path, line, character).await {\n            Ok(Some(hover_response)) => {\n                // Convert hover response to LspMetadata (stub/MVP implementation)\n                Self::hover_response_to_lsp_metadata(&hover_response)\n            }\n            Ok(None) => None, // Graceful degradation\n            Err(_) => None,   // Graceful degradation\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436093Z",
      "modified_at": "2025-11-01T15:29:24.436093Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fetch_real_dependencies:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:328-361",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fetch_real_dependencies",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 328,
        "end": 361
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn fetch_real_dependencies(&self, entities: &[CodeEntity]) -> Result<Vec<EntityRelationship>> {\n        \n\n        if entities.is_empty() {\n            return Ok(vec![]);\n        }\n\n        let mut relationships = Vec::new();\n\n        // For each entity, get its forward dependencies\n        for entity in entities {\n            match self.storage.get_forward_dependencies(&entity.isgl1_key).await {\n                Ok(deps) => {\n                    // Create EntityRelationship for each dependency\n                    for dep_key in deps {\n                        // Check if the dependency is in our entity set (optional filtering)\n                        relationships.push(EntityRelationship {\n                            source_id: entity.isgl1_key.clone(),\n                            target_id: dep_key,\n                            relationship_type: RelationshipType::Calls, // Default to Calls for now\n                            strength: 1.0,\n                            context: Some(\"dependency edge\".to_string()),\n                        });\n                    }\n                }\n                Err(e) => {\n                    // Log error but continue processing other entities\n                    eprintln!(\"Warning: Failed to fetch dependencies for {}: {}\", entity.isgl1_key, e);\n                }\n            }\n        }\n\n        Ok(relationships)\n    }",
    "future_code": "    async fn fetch_real_dependencies(&self, entities: &[CodeEntity]) -> Result<Vec<EntityRelationship>> {\n        \n\n        if entities.is_empty() {\n            return Ok(vec![]);\n        }\n\n        let mut relationships = Vec::new();\n\n        // For each entity, get its forward dependencies\n        for entity in entities {\n            match self.storage.get_forward_dependencies(&entity.isgl1_key).await {\n                Ok(deps) => {\n                    // Create EntityRelationship for each dependency\n                    for dep_key in deps {\n                        // Check if the dependency is in our entity set (optional filtering)\n                        relationships.push(EntityRelationship {\n                            source_id: entity.isgl1_key.clone(),\n                            target_id: dep_key,\n                            relationship_type: RelationshipType::Calls, // Default to Calls for now\n                            strength: 1.0,\n                            context: Some(\"dependency edge\".to_string()),\n                        });\n                    }\n                }\n                Err(e) => {\n                    // Log error but continue processing other entities\n                    eprintln!(\"Warning: Failed to fetch dependencies for {}: {}\", entity.isgl1_key, e);\n                }\n            }\n        }\n\n        Ok(relationships)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436095Z",
      "modified_at": "2025-11-01T15:29:24.436095Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:file_already_exists:______crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:31-33",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "file_already_exists",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "line_range": {
        "start": 31,
        "end": 33
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn file_already_exists(path: PathBuf) -> Self {\n        Self::FileAlreadyExists { path }\n    }",
    "future_code": "    pub fn file_already_exists(path: PathBuf) -> Self {\n        Self::FileAlreadyExists { path }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436096Z",
      "modified_at": "2025-11-01T15:29:24.436096Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:file_extensions:______crates_parseltongue-core_src_entities_rs:32-48",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "file_extensions",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 32,
        "end": 48
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn file_extensions(&self) -> Vec<&'static str> {\n        match self {\n            Language::Rust => vec![\"rs\"],\n            Language::JavaScript => vec![\"js\", \"jsx\"],\n            Language::TypeScript => vec![\"ts\", \"tsx\"],\n            Language::Python => vec![\"py\"],\n            Language::Java => vec![\"java\"],\n            Language::Cpp => vec![\"cpp\", \"cc\", \"cxx\", \"c\", \"h\", \"hpp\"],\n            Language::Go => vec![\"go\"],\n            Language::Ruby => vec![\"rb\"],\n            Language::Php => vec![\"php\"],\n            Language::CSharp => vec![\"cs\"],\n            Language::Swift => vec![\"swift\"],\n            Language::Kotlin => vec![\"kt\", \"kts\"],\n            Language::Scala => vec![\"scala\", \"sc\"],\n        }\n    }",
    "future_code": "    pub fn file_extensions(&self) -> Vec<&'static str> {\n        match self {\n            Language::Rust => vec![\"rs\"],\n            Language::JavaScript => vec![\"js\", \"jsx\"],\n            Language::TypeScript => vec![\"ts\", \"tsx\"],\n            Language::Python => vec![\"py\"],\n            Language::Java => vec![\"java\"],\n            Language::Cpp => vec![\"cpp\", \"cc\", \"cxx\", \"c\", \"h\", \"hpp\"],\n            Language::Go => vec![\"go\"],\n            Language::Ruby => vec![\"rb\"],\n            Language::Php => vec![\"php\"],\n            Language::CSharp => vec![\"cs\"],\n            Language::Swift => vec![\"swift\"],\n            Language::Kotlin => vec![\"kt\", \"kts\"],\n            Language::Scala => vec![\"scala\", \"sc\"],\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436097Z",
      "modified_at": "2025-11-01T15:29:24.436097Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:file_not_found:______crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:36-38",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "file_not_found",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "line_range": {
        "start": 36,
        "end": 38
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn file_not_found(path: PathBuf) -> Self {\n        Self::FileNotFound { path }\n    }",
    "future_code": "    pub fn file_not_found(path: PathBuf) -> Self {\n        Self::FileNotFound { path }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436098Z",
      "modified_at": "2025-11-01T15:29:24.436098Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:find_containing_function:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:283-303",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "find_containing_function",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 283,
        "end": 303
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn find_containing_function<'a>(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        entities: &'a [ParsedEntity],\n    ) -> Option<&'a ParsedEntity> {\n        // Walk up the tree to find a function_item\n        let mut current = node.parent()?;\n        while current.kind() != \"function_item\" {\n            current = current.parent()?;\n        }\n\n        // Get the line range of this function_item\n        let start_line = current.start_position().row + 1;\n        let end_line = current.end_position().row + 1;\n\n        // Find matching function entity\n        entities.iter().find(|e| {\n            e.entity_type == EntityType::Function\n            && e.line_range == (start_line, end_line)\n        })\n    }",
    "future_code": "    fn find_containing_function<'a>(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        entities: &'a [ParsedEntity],\n    ) -> Option<&'a ParsedEntity> {\n        // Walk up the tree to find a function_item\n        let mut current = node.parent()?;\n        while current.kind() != \"function_item\" {\n            current = current.parent()?;\n        }\n\n        // Get the line range of this function_item\n        let start_line = current.start_position().row + 1;\n        let end_line = current.end_position().row + 1;\n\n        // Find matching function entity\n        entities.iter().find(|e| {\n            e.entity_type == EntityType::Function\n            && e.line_range == (start_line, end_line)\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436099Z",
      "modified_at": "2025-11-01T15:29:24.436099Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fmt:______crates_parseltongue-core_src_entities_rs:486-491",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fmt",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 486,
        "end": 491
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EntityClass::TestImplementation => write!(f, \"TEST\"),\n            EntityClass::CodeImplementation => write!(f, \"CODE\"),\n        }\n    }",
    "future_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EntityClass::TestImplementation => write!(f, \"TEST\"),\n            EntityClass::CodeImplementation => write!(f, \"CODE\"),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436100Z",
      "modified_at": "2025-11-01T15:29:24.436100Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fmt:______crates_parseltongue-core_src_entities_rs:73-89",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fmt",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 73,
        "end": 89
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Language::Rust => write!(f, \"rust\"),\n            Language::JavaScript => write!(f, \"javascript\"),\n            Language::TypeScript => write!(f, \"typescript\"),\n            Language::Python => write!(f, \"python\"),\n            Language::Java => write!(f, \"java\"),\n            Language::Cpp => write!(f, \"cpp\"),\n            Language::Go => write!(f, \"go\"),\n            Language::Ruby => write!(f, \"ruby\"),\n            Language::Php => write!(f, \"php\"),\n            Language::CSharp => write!(f, \"csharp\"),\n            Language::Swift => write!(f, \"swift\"),\n            Language::Kotlin => write!(f, \"kotlin\"),\n            Language::Scala => write!(f, \"scala\"),\n        }\n    }",
    "future_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Language::Rust => write!(f, \"rust\"),\n            Language::JavaScript => write!(f, \"javascript\"),\n            Language::TypeScript => write!(f, \"typescript\"),\n            Language::Python => write!(f, \"python\"),\n            Language::Java => write!(f, \"java\"),\n            Language::Cpp => write!(f, \"cpp\"),\n            Language::Go => write!(f, \"go\"),\n            Language::Ruby => write!(f, \"ruby\"),\n            Language::Php => write!(f, \"php\"),\n            Language::CSharp => write!(f, \"csharp\"),\n            Language::Swift => write!(f, \"swift\"),\n            Language::Kotlin => write!(f, \"kotlin\"),\n            Language::Scala => write!(f, \"scala\"),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436101Z",
      "modified_at": "2025-11-01T15:29:24.436101Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fmt:______crates_parseltongue-core_src_entities_rs:901-903",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fmt",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 901,
        "end": 903
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }",
    "future_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436102Z",
      "modified_at": "2025-11-01T15:29:24.436102Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:fmt:______crates_parseltongue-core_src_entities_rs:965-967",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "fmt",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 965,
        "end": 967
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }",
    "future_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436103Z",
      "modified_at": "2025-11-01T15:29:24.436103Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:format_key:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:84-104",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "format_key",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 84,
        "end": 104
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn format_key(&self, entity: &ParsedEntity) -> String {\n        let type_str = match entity.entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Impl => \"impl\",\n            EntityType::Module => \"mod\",\n            EntityType::Variable => \"var\",\n        };\n\n        format!(\n            \"{}:{}:{}:{}:{}-{}\",\n            entity.language,\n            type_str,\n            entity.name,\n            self.sanitize_path(&entity.file_path),\n            entity.line_range.0,\n            entity.line_range.1\n        )\n    }",
    "future_code": "    fn format_key(&self, entity: &ParsedEntity) -> String {\n        let type_str = match entity.entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Impl => \"impl\",\n            EntityType::Module => \"mod\",\n            EntityType::Variable => \"var\",\n        };\n\n        format!(\n            \"{}:{}:{}:{}:{}-{}\",\n            entity.language,\n            type_str,\n            entity.name,\n            self.sanitize_path(&entity.file_path),\n            entity.line_range.0,\n            entity.line_range.1\n        )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436105Z",
      "modified_at": "2025-11-01T15:29:24.436105Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from:______crates_parseltongue-core_src_entities_rs:942-944",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 942,
        "end": 944
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn from(edge_type: EdgeType) -> Self {\n        edge_type.as_str().to_owned()\n    }",
    "future_code": "    fn from(edge_type: EdgeType) -> Self {\n        edge_type.as_str().to_owned()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436106Z",
      "modified_at": "2025-11-01T15:29:24.436106Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from:______crates_pt01-folder-to-cozodb-streamer_src_errors_rs:60-81",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/errors.rs",
      "line_range": {
        "start": 60,
        "end": 81
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn from(err: StreamerError) -> Self {\n        match err {\n            StreamerError::FileSystemError { path, source } => {\n                ParseltongError::FileSystemError { path, source }\n            }\n            StreamerError::ParsingError { file, reason } => {\n                ParseltongError::ParseError { reason, location: file }\n            }\n            StreamerError::StorageError { details } => {\n                ParseltongError::DatabaseError {\n                    operation: \"storage\".to_string(),\n                    details,\n                }\n            }\n            StreamerError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError { details: format!(\"{}: {}\", field, reason) }\n            }\n            _ => ParseltongError::ConfigurationError {\n                details: err.to_string(),\n            },\n        }\n    }",
    "future_code": "    fn from(err: StreamerError) -> Self {\n        match err {\n            StreamerError::FileSystemError { path, source } => {\n                ParseltongError::FileSystemError { path, source }\n            }\n            StreamerError::ParsingError { file, reason } => {\n                ParseltongError::ParseError { reason, location: file }\n            }\n            StreamerError::StorageError { details } => {\n                ParseltongError::DatabaseError {\n                    operation: \"storage\".to_string(),\n                    details,\n                }\n            }\n            StreamerError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError { details: format!(\"{}: {}\", field, reason) }\n            }\n            _ => ParseltongError::ConfigurationError {\n                details: err.to_string(),\n            },\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436107Z",
      "modified_at": "2025-11-01T15:29:24.436107Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from:______crates_pt03-llm-to-cozodb-writer_src_errors_rs:63-93",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/errors.rs",
      "line_range": {
        "start": 63,
        "end": 93
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn from(err: LlmWriterError) -> Self {\n        match err {\n            LlmWriterError::DatabaseQueryError { query, reason } => {\n                ParseltongError::DatabaseError {\n                    operation: \"query\".to_string(),\n                    details: format!(\"Query: {} - {}\", query, reason),\n                }\n            }\n            LlmWriterError::ValidationError { field, reason } => {\n                ParseltongError::ValidationError {\n                    field,\n                    expected: \"valid temporal change\".to_string(),\n                    actual: reason,\n                }\n            }\n            LlmWriterError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError {\n                    details: format!(\"{}: {}\", field, reason),\n                }\n            }\n            LlmWriterError::ResponseParseError { reason } => {\n                ParseltongError::ParseError {\n                    reason,\n                    location: \"LLM response\".to_string(),\n                }\n            }\n            _ => ParseltongError::LlmError {\n                reason: err.to_string(),\n            },\n        }\n    }",
    "future_code": "    fn from(err: LlmWriterError) -> Self {\n        match err {\n            LlmWriterError::DatabaseQueryError { query, reason } => {\n                ParseltongError::DatabaseError {\n                    operation: \"query\".to_string(),\n                    details: format!(\"Query: {} - {}\", query, reason),\n                }\n            }\n            LlmWriterError::ValidationError { field, reason } => {\n                ParseltongError::ValidationError {\n                    field,\n                    expected: \"valid temporal change\".to_string(),\n                    actual: reason,\n                }\n            }\n            LlmWriterError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError {\n                    details: format!(\"{}: {}\", field, reason),\n                }\n            }\n            LlmWriterError::ResponseParseError { reason } => {\n                ParseltongError::ParseError {\n                    reason,\n                    location: \"LLM response\".to_string(),\n                }\n            }\n            _ => ParseltongError::LlmError {\n                reason: err.to_string(),\n            },\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436108Z",
      "modified_at": "2025-11-01T15:29:24.436108Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from_file_path:______crates_parseltongue-core_src_entities_rs:51-69",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from_file_path",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 51,
        "end": 69
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn from_file_path(path: &PathBuf) -> Option<Self> {\n        let extension = path.extension()?.to_str()?;\n\n        [\n            Language::Rust,\n            Language::JavaScript,\n            Language::TypeScript,\n            Language::Python,\n            Language::Java,\n            Language::Cpp,\n            Language::Go,\n            Language::Ruby,\n            Language::Php,\n            Language::CSharp,\n            Language::Swift,\n            Language::Kotlin,\n            Language::Scala,\n        ].into_iter().find(|&language| language.file_extensions().contains(&extension))\n    }",
    "future_code": "    pub fn from_file_path(path: &PathBuf) -> Option<Self> {\n        let extension = path.extension()?.to_str()?;\n\n        [\n            Language::Rust,\n            Language::JavaScript,\n            Language::TypeScript,\n            Language::Python,\n            Language::Java,\n            Language::Cpp,\n            Language::Go,\n            Language::Ruby,\n            Language::Php,\n            Language::CSharp,\n            Language::Swift,\n            Language::Kotlin,\n            Language::Scala,\n        ].into_iter().find(|&language| language.file_extensions().contains(&extension))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436109Z",
      "modified_at": "2025-11-01T15:29:24.436109Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from_key:______crates_parseltongue-core_src_entities_rs:1035-1038",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1035,
        "end": 1038
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn from_key(mut self, key: impl Into<String>) -> Self {\n        self.from_key = Some(key.into());\n        self\n    }",
    "future_code": "    pub fn from_key(mut self, key: impl Into<String>) -> Self {\n        self.from_key = Some(key.into());\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436110Z",
      "modified_at": "2025-11-01T15:29:24.436110Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:from_str:______crates_parseltongue-core_src_entities_rs:950-961",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "from_str",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 950,
        "end": 961
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn from_str(s: &str) -> Result<Self> {\n        match s {\n            \"Calls\" => Ok(Self::Calls),\n            \"Uses\" => Ok(Self::Uses),\n            \"Implements\" => Ok(Self::Implements),\n            _ => Err(ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"Calls, Uses, or Implements\".to_string(),\n                actual: s.to_owned(),\n            }),\n        }\n    }",
    "future_code": "    fn from_str(s: &str) -> Result<Self> {\n        match s {\n            \"Calls\" => Ok(Self::Calls),\n            \"Uses\" => Ok(Self::Uses),\n            \"Implements\" => Ok(Self::Implements),\n            _ => Err(ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"Calls, Uses, or Implements\".to_string(),\n                actual: s.to_owned(),\n            }),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436111Z",
      "modified_at": "2025-11-01T15:29:24.436111Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:future_code:______crates_parseltongue-core_src_temporal_rs:421-424",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "future_code",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 421,
        "end": 424
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn future_code(mut self, code: String) -> Self {\n        self.future_code = Some(code);\n        self\n    }",
    "future_code": "    pub fn future_code(mut self, code: String) -> Self {\n        self.future_code = Some(code);\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436112Z",
      "modified_at": "2025-11-01T15:29:24.436112Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_context:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:449-452",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_context",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 449,
        "end": 452
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn generate_context(&self, output_path: &str) -> Result<ContextResult> {\n        // Use simplified, PRD-compliant approach (no LLM calls)\n        self.generate_context_from_db_simple(output_path).await\n    }",
    "future_code": "    async fn generate_context(&self, output_path: &str) -> Result<ContextResult> {\n        // Use simplified, PRD-compliant approach (no LLM calls)\n        self.generate_context_from_db_simple(output_path).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436113Z",
      "modified_at": "2025-11-01T15:29:24.436113Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_context_for_entities:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:454-510",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_context_for_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 454,
        "end": 510
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn generate_context_for_entities(&self, entities: &[CodeEntity], output_path: &str) -> Result<ContextResult> {\n        let start_time = Instant::now();\n        let mut errors = Vec::new();\n\n        // Create simple relationships for provided entities\n        let relationships = entities.iter().map(|entity| {\n            EntityRelationship {\n                source_id: entity.isgl1_key.clone(),\n                target_id: entity.isgl1_key.clone(),\n                relationship_type: RelationshipType::RelatedTo,\n                strength: 1.0,\n                context: None,\n            }\n        }).collect();\n\n        // Create context optimization request\n        let request = ContextOptimizationRequest {\n            entities: entities.to_vec(),\n            relationships,\n            target_context_size: self.config.max_context_tokens,\n            focus_areas: vec![\"user_provided\".to_string()],\n            optimization_goals: vec![OptimizationGoal::MaximizeRelevance],\n        };\n\n        // Generate optimized context\n        let response = self.llm_client.optimize_context(request).await.map_err(|e| {\n            let error_msg = format!(\"Context optimization failed: {}\", e);\n            errors.push(error_msg.clone());\n            e\n        })?;\n\n        // Write optimized context to file\n        self.write_context_file(&response, output_path).await.map_err(|e| {\n            let error_msg = format!(\"Failed to write context file: {}\", e);\n            errors.push(error_msg.clone());\n            e\n        })?;\n\n        let generation_time = start_time.elapsed();\n        let entities_optimized = response.optimized_entities.len();\n        let tokens_generated = response.context_metadata.token_count;\n        let optimization_ratio = response.pruning_summary.pruning_ratio;\n\n        // Update statistics\n        self.update_stats(entities.len(), tokens_generated, optimization_ratio, generation_time);\n\n        Ok(ContextResult {\n            context_id: response.context_metadata.context_id,\n            output_path: output_path.to_string(),\n            entities_processed: entities.len(),\n            entities_optimized,\n            tokens_generated,\n            optimization_ratio,\n            generation_time,\n            errors,\n        })\n    }",
    "future_code": "    async fn generate_context_for_entities(&self, entities: &[CodeEntity], output_path: &str) -> Result<ContextResult> {\n        let start_time = Instant::now();\n        let mut errors = Vec::new();\n\n        // Create simple relationships for provided entities\n        let relationships = entities.iter().map(|entity| {\n            EntityRelationship {\n                source_id: entity.isgl1_key.clone(),\n                target_id: entity.isgl1_key.clone(),\n                relationship_type: RelationshipType::RelatedTo,\n                strength: 1.0,\n                context: None,\n            }\n        }).collect();\n\n        // Create context optimization request\n        let request = ContextOptimizationRequest {\n            entities: entities.to_vec(),\n            relationships,\n            target_context_size: self.config.max_context_tokens,\n            focus_areas: vec![\"user_provided\".to_string()],\n            optimization_goals: vec![OptimizationGoal::MaximizeRelevance],\n        };\n\n        // Generate optimized context\n        let response = self.llm_client.optimize_context(request).await.map_err(|e| {\n            let error_msg = format!(\"Context optimization failed: {}\", e);\n            errors.push(error_msg.clone());\n            e\n        })?;\n\n        // Write optimized context to file\n        self.write_context_file(&response, output_path).await.map_err(|e| {\n            let error_msg = format!(\"Failed to write context file: {}\", e);\n            errors.push(error_msg.clone());\n            e\n        })?;\n\n        let generation_time = start_time.elapsed();\n        let entities_optimized = response.optimized_entities.len();\n        let tokens_generated = response.context_metadata.token_count;\n        let optimization_ratio = response.pruning_summary.pruning_ratio;\n\n        // Update statistics\n        self.update_stats(entities.len(), tokens_generated, optimization_ratio, generation_time);\n\n        Ok(ContextResult {\n            context_id: response.context_metadata.context_id,\n            output_path: output_path.to_string(),\n            entities_processed: entities.len(),\n            entities_optimized,\n            tokens_generated,\n            optimization_ratio,\n            generation_time,\n            errors,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436115Z",
      "modified_at": "2025-11-01T15:29:24.436115Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_context_from_db_simple:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:118-199",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_context_from_db_simple",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 118,
        "end": 199
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn generate_context_from_db_simple(&self, output_path: &str) -> Result<ContextResult> {\n        let start_time = Instant::now();\n        let mut errors = Vec::new();\n\n        println!(\"{}\", style(\"Starting context generation from CozoDB...\").blue().bold());\n\n        // Use injected storage (Dependency Injection pattern)\n        // Get all entities from CozoDB\n        let all_entities = self.storage.get_all_entities()\n            .await\n            .map_err(|e| {\n                let error_msg = format!(\"Failed to query entities: {}\", e);\n                errors.push(error_msg.clone());\n                ContextWriterError::DatabaseError {\n                    reason: error_msg\n                }\n            })?;\n\n        // Filter to current_ind=true only (PRD requirement)\n        let current_entities: Vec<CodeEntity> = all_entities\n            .into_iter()\n            .filter(|e| e.temporal_state.current_ind)\n            .collect();\n\n        println!(\"{} entities with current_ind=true\", current_entities.len());\n\n        // Convert to MinimalEntity (excludes current_code/future_code)\n        let minimal_entities: Vec<MinimalEntity> = current_entities\n            .iter()\n            .map(|e| self.entity_to_minimal(e))\n            .collect();\n\n        // Create CodeGraphContext\n        let context = CodeGraphContext {\n            entities: minimal_entities.clone(),\n            entity_count: minimal_entities.len(),\n            token_count: 0, // Will be updated after estimation\n            generated_at: chrono::Utc::now().to_rfc3339(),\n        };\n\n        // Estimate tokens\n        let token_count = self.estimate_tokens(&context);\n\n        // Check token limit (PRD requirement: <100k tokens)\n        if token_count > self.config.max_context_tokens {\n            return Err(ContextWriterError::ContextTooLarge {\n                actual: token_count,\n                limit: self.config.max_context_tokens,\n            });\n        }\n\n        // Update context with token count\n        let context = CodeGraphContext {\n            token_count,\n            ..context\n        };\n\n        // Write context file\n        self.write_context_file_simple(&context, output_path).await?;\n\n        let generation_time = start_time.elapsed();\n\n        println!(\"\\n{}\", style(\"Context Generation Summary:\").green().bold());\n        println!(\"Entities processed: {}\", current_entities.len());\n        println!(\"Tokens generated: {}\", token_count);\n        println!(\"Output file: {}\", output_path);\n        println!(\"Generation time: {:?}\", generation_time);\n\n        // Update statistics\n        self.update_stats(current_entities.len(), token_count, 0.0, generation_time);\n\n        Ok(ContextResult {\n            context_id: uuid::Uuid::new_v4().to_string(),\n            output_path: output_path.to_string(),\n            entities_processed: current_entities.len(),\n            entities_optimized: minimal_entities.len(),\n            tokens_generated: token_count,\n            optimization_ratio: 0.0,\n            generation_time,\n            errors,\n        })\n    }",
    "future_code": "    async fn generate_context_from_db_simple(&self, output_path: &str) -> Result<ContextResult> {\n        let start_time = Instant::now();\n        let mut errors = Vec::new();\n\n        println!(\"{}\", style(\"Starting context generation from CozoDB...\").blue().bold());\n\n        // Use injected storage (Dependency Injection pattern)\n        // Get all entities from CozoDB\n        let all_entities = self.storage.get_all_entities()\n            .await\n            .map_err(|e| {\n                let error_msg = format!(\"Failed to query entities: {}\", e);\n                errors.push(error_msg.clone());\n                ContextWriterError::DatabaseError {\n                    reason: error_msg\n                }\n            })?;\n\n        // Filter to current_ind=true only (PRD requirement)\n        let current_entities: Vec<CodeEntity> = all_entities\n            .into_iter()\n            .filter(|e| e.temporal_state.current_ind)\n            .collect();\n\n        println!(\"{} entities with current_ind=true\", current_entities.len());\n\n        // Convert to MinimalEntity (excludes current_code/future_code)\n        let minimal_entities: Vec<MinimalEntity> = current_entities\n            .iter()\n            .map(|e| self.entity_to_minimal(e))\n            .collect();\n\n        // Create CodeGraphContext\n        let context = CodeGraphContext {\n            entities: minimal_entities.clone(),\n            entity_count: minimal_entities.len(),\n            token_count: 0, // Will be updated after estimation\n            generated_at: chrono::Utc::now().to_rfc3339(),\n        };\n\n        // Estimate tokens\n        let token_count = self.estimate_tokens(&context);\n\n        // Check token limit (PRD requirement: <100k tokens)\n        if token_count > self.config.max_context_tokens {\n            return Err(ContextWriterError::ContextTooLarge {\n                actual: token_count,\n                limit: self.config.max_context_tokens,\n            });\n        }\n\n        // Update context with token count\n        let context = CodeGraphContext {\n            token_count,\n            ..context\n        };\n\n        // Write context file\n        self.write_context_file_simple(&context, output_path).await?;\n\n        let generation_time = start_time.elapsed();\n\n        println!(\"\\n{}\", style(\"Context Generation Summary:\").green().bold());\n        println!(\"Entities processed: {}\", current_entities.len());\n        println!(\"Tokens generated: {}\", token_count);\n        println!(\"Output file: {}\", output_path);\n        println!(\"Generation time: {:?}\", generation_time);\n\n        // Update statistics\n        self.update_stats(current_entities.len(), token_count, 0.0, generation_time);\n\n        Ok(ContextResult {\n            context_id: uuid::Uuid::new_v4().to_string(),\n            output_path: output_path.to_string(),\n            entities_processed: current_entities.len(),\n            entities_optimized: minimal_entities.len(),\n            tokens_generated: token_count,\n            optimization_ratio: 0.0,\n            generation_time,\n            errors,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436116Z",
      "modified_at": "2025-11-01T15:29:24.436116Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_diff:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:60-77",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_diff",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 60,
        "end": 77
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn generate_diff(&self) -> Result<CodeDiff> {\n        // Get all changed entities from CozoDB\n        let changed_entities = self\n            .storage\n            .get_changed_entities()\n            .await\n            .context(\"Failed to get changed entities from CozoDB\")?;\n\n        let mut diff = CodeDiff::new();\n\n        for entity in changed_entities {\n            if let Some(change) = self.entity_to_change(&entity)? {\n                diff.add_change(change);\n            }\n        }\n\n        Ok(diff)\n    }",
    "future_code": "    pub async fn generate_diff(&self) -> Result<CodeDiff> {\n        // Get all changed entities from CozoDB\n        let changed_entities = self\n            .storage\n            .get_changed_entities()\n            .await\n            .context(\"Failed to get changed entities from CozoDB\")?;\n\n        let mut diff = CodeDiff::new();\n\n        for entity in changed_entities {\n            if let Some(change) = self.entity_to_change(&entity)? {\n                diff.add_change(change);\n            }\n        }\n\n        Ok(diff)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436117Z",
      "modified_at": "2025-11-01T15:29:24.436117Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_fixed_code:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:321-338",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_fixed_code",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 321,
        "end": 338
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn generate_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#\n    .to_string()\n}",
    "future_code": "fn generate_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#\n    .to_string()\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436118Z",
      "modified_at": "2025-11-01T15:29:24.436118Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_key:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:113-115",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_key",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 113,
        "end": 115
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn generate_key(&self, entity: &ParsedEntity) -> Result<String> {\n        Ok(self.format_key(entity))\n    }",
    "future_code": "    fn generate_key(&self, entity: &ParsedEntity) -> Result<String> {\n        Ok(self.format_key(entity))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436119Z",
      "modified_at": "2025-11-01T15:29:24.436119Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_large_graph:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:861-895",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_large_graph",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 861,
        "end": 895
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn generate_large_graph(\n    db: &CozoDbStorage,\n    num_nodes: usize,\n    avg_edges_per_node: usize,\n) -> Vec<String> {\n    let mut nodes = Vec::new();\n    let mut edges = Vec::new();\n\n    // Generate nodes\n    for i in 0..num_nodes {\n        let key = format!(\"rust:fn:node_{}:perf_test_rs:{}-{}\", i, i * 10, i * 10 + 5);\n        nodes.push(key.clone());\n    }\n\n    // Generate edges with realistic graph structure (not fully connected)\n    for i in 0..num_nodes {\n        let num_edges = avg_edges_per_node.min(num_nodes - i - 1);\n        for j in 1..=num_edges {\n            if i + j < num_nodes {\n                let edge = DependencyEdge::builder()\n                    .from_key(&nodes[i])\n                    .to_key(&nodes[i + j])\n                    .edge_type(EdgeType::Calls)\n                    .build()\n                    .unwrap();\n                edges.push(edge);\n            }\n        }\n    }\n\n    // Batch insert all edges\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    nodes\n}",
    "future_code": "async fn generate_large_graph(\n    db: &CozoDbStorage,\n    num_nodes: usize,\n    avg_edges_per_node: usize,\n) -> Vec<String> {\n    let mut nodes = Vec::new();\n    let mut edges = Vec::new();\n\n    // Generate nodes\n    for i in 0..num_nodes {\n        let key = format!(\"rust:fn:node_{}:perf_test_rs:{}-{}\", i, i * 10, i * 10 + 5);\n        nodes.push(key.clone());\n    }\n\n    // Generate edges with realistic graph structure (not fully connected)\n    for i in 0..num_nodes {\n        let num_edges = avg_edges_per_node.min(num_nodes - i - 1);\n        for j in 1..=num_edges {\n            if i + j < num_nodes {\n                let edge = DependencyEdge::builder()\n                    .from_key(&nodes[i])\n                    .to_key(&nodes[i + j])\n                    .edge_type(EdgeType::Calls)\n                    .build()\n                    .unwrap();\n                edges.push(edge);\n            }\n        }\n    }\n\n    // Batch insert all edges\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    nodes\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436120Z",
      "modified_at": "2025-11-01T15:29:24.436120Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_new_entity_key:______crates_parseltongue-core_src_entities_rs:758-802",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_new_entity_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 758,
        "end": 802
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn generate_new_entity_key(\n        file_path: &str,\n        entity_name: &str,\n        entity_type: &EntityType,\n        timestamp: chrono::DateTime<chrono::Utc>,\n    ) -> String {\n        use sha2::{Sha256, Digest};\n\n        // Sanitize file path: replace /, \\, and . with _\n        let sanitized_path = file_path\n            .replace(['/', '\\\\', '.'], \"_\");\n\n        // Get type abbreviation\n        let type_abbrev = match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Module => \"mod\",\n            EntityType::ImplBlock { .. } => \"impl\",\n            EntityType::Macro => \"macro\",\n            EntityType::ProcMacro => \"proc_macro\",\n            EntityType::TestFunction => \"test\",\n            EntityType::Class => \"class\",\n            EntityType::Variable => \"var\",\n            EntityType::Constant => \"const\",\n        };\n\n        // Create hash input: filepath + name + type + timestamp\n        let mut hasher = Sha256::new();\n        hasher.update(file_path.as_bytes());\n        hasher.update(entity_name.as_bytes());\n        hasher.update(format!(\"{:?}\", entity_type).as_bytes());\n        hasher.update(timestamp.to_rfc3339().as_bytes());\n\n        // Get hash result and take first 8 characters\n        let hash_bytes = hasher.finalize();\n        let hash_str = format!(\"{:x}\", hash_bytes);\n        let short_hash = &hash_str[0..8];\n\n        // Format: sanitized_path-entity_name-type_abbrev-hash8\n        format!(\"{}-{}-{}-{}\", sanitized_path, entity_name, type_abbrev, short_hash)\n    }",
    "future_code": "    pub fn generate_new_entity_key(\n        file_path: &str,\n        entity_name: &str,\n        entity_type: &EntityType,\n        timestamp: chrono::DateTime<chrono::Utc>,\n    ) -> String {\n        use sha2::{Sha256, Digest};\n\n        // Sanitize file path: replace /, \\, and . with _\n        let sanitized_path = file_path\n            .replace(['/', '\\\\', '.'], \"_\");\n\n        // Get type abbreviation\n        let type_abbrev = match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Module => \"mod\",\n            EntityType::ImplBlock { .. } => \"impl\",\n            EntityType::Macro => \"macro\",\n            EntityType::ProcMacro => \"proc_macro\",\n            EntityType::TestFunction => \"test\",\n            EntityType::Class => \"class\",\n            EntityType::Variable => \"var\",\n            EntityType::Constant => \"const\",\n        };\n\n        // Create hash input: filepath + name + type + timestamp\n        let mut hasher = Sha256::new();\n        hasher.update(file_path.as_bytes());\n        hasher.update(entity_name.as_bytes());\n        hasher.update(format!(\"{:?}\", entity_type).as_bytes());\n        hasher.update(timestamp.to_rfc3339().as_bytes());\n\n        // Get hash result and take first 8 characters\n        let hash_bytes = hasher.finalize();\n        let hash_str = format!(\"{:x}\", hash_bytes);\n        let short_hash = &hash_str[0..8];\n\n        // Format: sanitized_path-entity_name-type_abbrev-hash8\n        format!(\"{}-{}-{}-{}\", sanitized_path, entity_name, type_abbrev, short_hash)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436121Z",
      "modified_at": "2025-11-01T15:29:24.436121Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:generate_output_path:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:258-261",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "generate_output_path",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 258,
        "end": 261
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn generate_output_path(output_dir: &str, context_id: &str) -> String {\n        let timestamp = chrono::Utc::now().format(\"%Y%m%d_%H%M%S\");\n        format!(\"{}/context_{}_{}.json\", output_dir, context_id, timestamp)\n    }",
    "future_code": "    pub fn generate_output_path(output_dir: &str, context_id: &str) -> String {\n        let timestamp = chrono::Utc::now().format(\"%Y%m%d_%H%M%S\");\n        format!(\"{}/context_{}_{}.json\", output_dir, context_id, timestamp)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436122Z",
      "modified_at": "2025-11-01T15:29:24.436122Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_all_entities:______crates_parseltongue-core_src_storage_cozo_client_rs:805-831",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_all_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 805,
        "end": 831
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_all_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_all_entities\".to_string(),\n                details: format!(\"Failed to query all entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
    "future_code": "    pub async fn get_all_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_all_entities\".to_string(),\n                details: format!(\"Failed to query all entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436123Z",
      "modified_at": "2025-11-01T15:29:24.436124Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_all_entities:______crates_parseltongue-core_src_temporal_rs:137-139",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_all_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 137,
        "end": 139
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn get_all_entities(&self) -> Vec<&CodeEntity> {\n        self.entities.values().collect()\n    }",
    "future_code": "    pub fn get_all_entities(&self) -> Vec<&CodeEntity> {\n        self.entities.values().collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436125Z",
      "modified_at": "2025-11-01T15:29:24.436125Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_changed_entities:______crates_parseltongue-core_src_storage_cozo_client_rs:1159-1161",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_changed_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1159,
        "end": 1161
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        self.get_changed_entities().await\n    }",
    "future_code": "    async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        self.get_changed_entities().await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436126Z",
      "modified_at": "2025-11-01T15:29:24.436126Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_changed_entities:______crates_parseltongue-core_src_storage_cozo_client_rs:772-799",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_changed_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 772,
        "end": 799
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            },\n            Future_Action != null\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_changed_entities\".to_string(),\n                details: format!(\"Failed to query changed entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
    "future_code": "    pub async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            },\n            Future_Action != null\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_changed_entities\".to_string(),\n                details: format!(\"Failed to query changed entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436128Z",
      "modified_at": "2025-11-01T15:29:24.436128Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_changed_entities:______crates_parseltongue-core_src_temporal_rs:124-129",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_changed_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 124,
        "end": 129
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn get_changed_entities(&self) -> Vec<&CodeEntity> {\n        self.entities\n            .values()\n            .filter(|entity| entity.is_modified())\n            .collect()\n    }",
    "future_code": "    pub fn get_changed_entities(&self) -> Vec<&CodeEntity> {\n        self.entities\n            .values()\n            .filter(|entity| entity.is_modified())\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436129Z",
      "modified_at": "2025-11-01T15:29:24.436129Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_dependents:______crates_parseltongue-core_src_temporal_rs:147-159",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_dependents",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 147,
        "end": 159
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn get_dependents(&self, isgl1_key: &str) -> Vec<String> {\n        self.entities\n            .values()\n            .filter(|entity| {\n                // Check if entity depends on the given entity\n                // This is a simplified implementation\n                entity.interface_signature.file_path\n                    .to_string_lossy()\n                    .contains(isgl1_key)\n            })\n            .map(|entity| entity.isgl1_key.clone())\n            .collect()\n    }",
    "future_code": "    pub fn get_dependents(&self, isgl1_key: &str) -> Vec<String> {\n        self.entities\n            .values()\n            .filter(|entity| {\n                // Check if entity depends on the given entity\n                // This is a simplified implementation\n                entity.interface_signature.file_path\n                    .to_string_lossy()\n                    .contains(isgl1_key)\n            })\n            .map(|entity| entity.isgl1_key.clone())\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436130Z",
      "modified_at": "2025-11-01T15:29:24.436130Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:1137-1143",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1137,
        "end": 1143
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn get_entity(&self, isgl1_key: &str) -> Result<Option<CodeEntity>> {\n        match self.get_entity(isgl1_key).await {\n            Ok(entity) => Ok(Some(entity)),\n            Err(ParseltongError::EntityNotFound { .. }) => Ok(None),\n            Err(e) => Err(e),\n        }\n    }",
    "future_code": "    async fn get_entity(&self, isgl1_key: &str) -> Result<Option<CodeEntity>> {\n        match self.get_entity(isgl1_key).await {\n            Ok(entity) => Ok(Some(entity)),\n            Err(ParseltongError::EntityNotFound { .. }) => Ok(None),\n            Err(e) => Err(e),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436132Z",
      "modified_at": "2025-11-01T15:29:24.436132Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:692-722",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 692,
        "end": 722
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_entity(&self, isgl1_key: &str) -> Result<CodeEntity> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            },\n            ISGL1_key == $key\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self.db.run_script(query, params, ScriptMutability::Immutable).map_err(|e| {\n            ParseltongError::DatabaseError {\n                operation: \"get_entity\".to_string(),\n                details: format!(\"Failed to get entity: {}\", e),\n            }\n        })?;\n\n        if result.rows.is_empty() {\n            return Err(ParseltongError::EntityNotFound {\n                isgl1_key: isgl1_key.to_string(),\n            });\n        }\n\n        self.row_to_entity(&result.rows[0])\n    }",
    "future_code": "    pub async fn get_entity(&self, isgl1_key: &str) -> Result<CodeEntity> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            },\n            ISGL1_key == $key\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self.db.run_script(query, params, ScriptMutability::Immutable).map_err(|e| {\n            ParseltongError::DatabaseError {\n                operation: \"get_entity\".to_string(),\n                details: format!(\"Failed to get entity: {}\", e),\n            }\n        })?;\n\n        if result.rows.is_empty() {\n            return Err(ParseltongError::EntityNotFound {\n                isgl1_key: isgl1_key.to_string(),\n            });\n        }\n\n        self.row_to_entity(&result.rows[0])\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436133Z",
      "modified_at": "2025-11-01T15:29:24.436133Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_entity:______crates_parseltongue-core_src_temporal_rs:132-134",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 132,
        "end": 134
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn get_entity(&self, isgl1_key: &str) -> Option<&CodeEntity> {\n        self.entities.get(isgl1_key)\n    }",
    "future_code": "    pub fn get_entity(&self, isgl1_key: &str) -> Option<&CodeEntity> {\n        self.entities.get(isgl1_key)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436134Z",
      "modified_at": "2025-11-01T15:29:24.436134Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_fixed_code:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:233-250",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_fixed_code",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 233,
        "end": 250
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn get_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will pass!\n    }\n}\n\"#\n    .to_string()\n}",
    "future_code": "fn get_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will pass!\n    }\n}\n\"#\n    .to_string()\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436135Z",
      "modified_at": "2025-11-01T15:29:24.436135Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_forward_dependencies:______crates_parseltongue-core_src_storage_cozo_client_rs:420-443",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_forward_dependencies",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 420,
        "end": 443
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_forward_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[to_key] := *DependencyEdges{from_key, to_key}, from_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_forward_dependencies\".to_string(),\n                reason: format!(\"Failed to query forward dependencies: {}\", e),\n            })?;\n\n        // Extract to_key values from results\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependencies.push(key.to_string());\n            }\n        }\n\n        Ok(dependencies)\n    }",
    "future_code": "    pub async fn get_forward_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[to_key] := *DependencyEdges{from_key, to_key}, from_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_forward_dependencies\".to_string(),\n                reason: format!(\"Failed to query forward dependencies: {}\", e),\n            })?;\n\n        // Extract to_key values from results\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependencies.push(key.to_string());\n            }\n        }\n\n        Ok(dependencies)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436136Z",
      "modified_at": "2025-11-01T15:29:24.436136Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_language_type:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:141-157",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_language_type",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 141,
        "end": 157
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn get_language_type(&self, file_path: &Path) -> Result<Language> {\n        match file_path.extension().and_then(|s| s.to_str()) {\n            Some(\"rs\") => Ok(Language::Rust),\n            Some(\"py\") => {\n                if self.python_language.is_some() {\n                    Ok(Language::Python)\n                } else {\n                    Err(StreamerError::UnsupportedFileType {\n                        path: file_path.to_string_lossy().to_string(),\n                    })\n                }\n            }\n            _ => Err(StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            }),\n        }\n    }",
    "future_code": "    fn get_language_type(&self, file_path: &Path) -> Result<Language> {\n        match file_path.extension().and_then(|s| s.to_str()) {\n            Some(\"rs\") => Ok(Language::Rust),\n            Some(\"py\") => {\n                if self.python_language.is_some() {\n                    Ok(Language::Python)\n                } else {\n                    Err(StreamerError::UnsupportedFileType {\n                        path: file_path.to_string_lossy().to_string(),\n                    })\n                }\n            }\n            _ => Err(StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            }),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436137Z",
      "modified_at": "2025-11-01T15:29:24.436137Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_reverse_dependencies:______crates_parseltongue-core_src_storage_cozo_client_rs:491-514",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_reverse_dependencies",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 491,
        "end": 514
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_reverse_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[from_key] := *DependencyEdges{from_key, to_key}, to_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_reverse_dependencies\".to_string(),\n                reason: format!(\"Failed to query reverse dependencies: {}\", e),\n            })?;\n\n        // Extract from_key values from results\n        let mut dependents = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependents.push(key.to_string());\n            }\n        }\n\n        Ok(dependents)\n    }",
    "future_code": "    pub async fn get_reverse_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[from_key] := *DependencyEdges{from_key, to_key}, to_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_reverse_dependencies\".to_string(),\n                reason: format!(\"Failed to query reverse dependencies: {}\", e),\n            })?;\n\n        // Extract from_key values from results\n        let mut dependents = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependents.push(key.to_string());\n            }\n        }\n\n        Ok(dependents)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436138Z",
      "modified_at": "2025-11-01T15:29:24.436138Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_stats:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:482-484",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_stats",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 482,
        "end": 484
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn get_stats(&self) -> StreamStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }",
    "future_code": "    fn get_stats(&self) -> StreamStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436139Z",
      "modified_at": "2025-11-01T15:29:24.436139Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_stats:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:512-514",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_stats",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 512,
        "end": 514
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn get_stats(&self) -> ContextOptimizerStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }",
    "future_code": "    fn get_stats(&self) -> ContextOptimizerStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436140Z",
      "modified_at": "2025-11-01T15:29:24.436140Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:get_transitive_closure:______crates_parseltongue-core_src_storage_cozo_client_rs:588-625",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "get_transitive_closure",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 588,
        "end": 625
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn get_transitive_closure(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        // CozoDB recursive query for unbounded reachability\n        let query = r#\"\n            # Transitive closure: Find all nodes reachable from start node\n\n            # Base case: Direct edges from start node\n            reachable[to_key] := *DependencyEdges{from_key, to_key},\n                                 from_key == $start_key\n\n            # Recursive case: Follow edges transitively (CozoDB handles cycle termination)\n            reachable[to_key] := reachable[from],\n                                 *DependencyEdges{from_key: from, to_key}\n\n            # Return all unique reachable nodes\n            ?[node] := reachable[node]\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_transitive_closure\".to_string(),\n                reason: format!(\"Failed to compute transitive closure: {}\", e),\n            })?;\n\n        // Extract all reachable keys\n        let mut reachable = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                reachable.push(key.to_string());\n            }\n        }\n\n        Ok(reachable)\n    }",
    "future_code": "    pub async fn get_transitive_closure(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        // CozoDB recursive query for unbounded reachability\n        let query = r#\"\n            # Transitive closure: Find all nodes reachable from start node\n\n            # Base case: Direct edges from start node\n            reachable[to_key] := *DependencyEdges{from_key, to_key},\n                                 from_key == $start_key\n\n            # Recursive case: Follow edges transitively (CozoDB handles cycle termination)\n            reachable[to_key] := reachable[from],\n                                 *DependencyEdges{from_key: from, to_key}\n\n            # Return all unique reachable nodes\n            ?[node] := reachable[node]\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_transitive_closure\".to_string(),\n                reason: format!(\"Failed to compute transitive closure: {}\", e),\n            })?;\n\n        // Extract all reachable keys\n        let mut reachable = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                reachable.push(key.to_string());\n            }\n        }\n\n        Ok(reachable)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436141Z",
      "modified_at": "2025-11-01T15:29:24.436141Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:group_changes_by_file:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:430-439",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "group_changes_by_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 430,
        "end": 439
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn group_changes_by_file(changes: &[Change]) -> HashMap<PathBuf, Vec<&Change>> {\n    let mut grouped: HashMap<PathBuf, Vec<&Change>> = HashMap::new();\n    for change in changes {\n        grouped\n            .entry(change.file_path.clone())\n            .or_insert_with(Vec::new)\n            .push(change);\n    }\n    grouped\n}",
    "future_code": "fn group_changes_by_file(changes: &[Change]) -> HashMap<PathBuf, Vec<&Change>> {\n    let mut grouped: HashMap<PathBuf, Vec<&Change>> = HashMap::new();\n    for change in changes {\n        grouped\n            .entry(change.file_path.clone())\n            .or_insert_with(Vec::new)\n            .push(change);\n    }\n    grouped\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436142Z",
      "modified_at": "2025-11-01T15:29:24.436142Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:hover:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:121-129",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "hover",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 121,
        "end": 129
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn hover(\n        &self,\n        file_path: &Path,\n        line: u32,\n        character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        let key = format!(\"{}:{}:{}\", file_path.display(), line, character);\n        Ok(self.responses.get(&key).cloned())\n    }",
    "future_code": "    async fn hover(\n        &self,\n        file_path: &Path,\n        line: u32,\n        character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        let key = format!(\"{}:{}:{}\", file_path.display(), line, character);\n        Ok(self.responses.get(&key).cloned())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436143Z",
      "modified_at": "2025-11-01T15:29:24.436143Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:hover:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:79-92",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "hover",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 79,
        "end": 92
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn hover(\n        &self,\n        _file_path: &Path,\n        _line: u32,\n        _character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        // Graceful degradation: return None if not enabled\n        if !self.enabled {\n            return Ok(None);\n        }\n\n        // TODO: Implement actual LSP hover request\n        Ok(None)\n    }",
    "future_code": "    async fn hover(\n        &self,\n        _file_path: &Path,\n        _line: u32,\n        _character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        // Graceful degradation: return None if not enabled\n        if !self.enabled {\n            return Ok(None);\n        }\n\n        // TODO: Implement actual LSP hover request\n        Ok(None)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436144Z",
      "modified_at": "2025-11-01T15:29:24.436144Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:hover_response_to_lsp_metadata:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:517-532",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "hover_response_to_lsp_metadata",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 517,
        "end": 532
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn hover_response_to_lsp_metadata(hover: &HoverResponse) -> Option<LspMetadata> {\n        Some(LspMetadata {\n            type_information: TypeInformation {\n                resolved_type: hover.contents.clone(),\n                module_path: vec![],\n                generic_parameters: vec![],\n                definition_location: None,\n            },\n            usage_analysis: UsageAnalysis {\n                total_references: 0,\n                usage_locations: vec![],\n                dependents: vec![],\n            },\n            semantic_tokens: vec![],\n        })\n    }",
    "future_code": "    fn hover_response_to_lsp_metadata(hover: &HoverResponse) -> Option<LspMetadata> {\n        Some(LspMetadata {\n            type_information: TypeInformation {\n                resolved_type: hover.contents.clone(),\n                module_path: vec![],\n                generic_parameters: vec![],\n                definition_location: None,\n            },\n            usage_analysis: UsageAnalysis {\n                total_references: 0,\n                usage_locations: vec![],\n                dependents: vec![],\n            },\n            semantic_tokens: vec![],\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436146Z",
      "modified_at": "2025-11-01T15:29:24.436146Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:identify_connectivity_clusters:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:379-386",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "identify_connectivity_clusters",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 379,
        "end": 386
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn identify_connectivity_clusters(&self, entities: &[CodeEntity], _relationships: &[EntityRelationship]) -> Vec<Vec<String>> {\n        if entities.is_empty() {\n            return vec![];\n        }\n\n        // Simple clustering - put all entities in one cluster for now\n        vec![entities.iter().map(|e| e.isgl1_key.clone()).collect()]\n    }",
    "future_code": "    fn identify_connectivity_clusters(&self, entities: &[CodeEntity], _relationships: &[EntityRelationship]) -> Vec<Vec<String>> {\n        if entities.is_empty() {\n            return vec![];\n        }\n\n        // Simple clustering - put all entities in one cluster for now\n        vec![entities.iter().map(|e| e.isgl1_key.clone()).collect()]\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436147Z",
      "modified_at": "2025-11-01T15:29:24.436147Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:initial:______crates_parseltongue-core_src_entities_rs:164-170",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "initial",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 164,
        "end": 170
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn initial() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,  // Future state unknown at index time\n            future_action: None,\n        }\n    }",
    "future_code": "    pub fn initial() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,  // Future state unknown at index time\n            future_action: None,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436148Z",
      "modified_at": "2025-11-01T15:29:24.436148Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:insert_edge:______crates_parseltongue-core_src_storage_cozo_client_rs:153-184",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "insert_edge",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 153,
        "end": 184
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn insert_edge(&self, edge: &DependencyEdge) -> Result<()> {\n        let query = r#\"\n            ?[from_key, to_key, edge_type, source_location] <-\n            [[$from_key, $to_key, $edge_type, $source_location]]\n\n            :put DependencyEdges {\n                from_key, to_key, edge_type =>\n                source_location\n            }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"from_key\".to_string(), DataValue::Str(edge.from_key.as_ref().into()));\n        params.insert(\"to_key\".to_string(), DataValue::Str(edge.to_key.as_ref().into()));\n        params.insert(\"edge_type\".to_string(), DataValue::Str(edge.edge_type.as_str().into()));\n        params.insert(\n            \"source_location\".to_string(),\n            edge.source_location\n                .as_ref()\n                .map(|s| DataValue::Str(s.as_str().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edge\".to_string(),\n                reason: format!(\"Failed to insert dependency edge: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn insert_edge(&self, edge: &DependencyEdge) -> Result<()> {\n        let query = r#\"\n            ?[from_key, to_key, edge_type, source_location] <-\n            [[$from_key, $to_key, $edge_type, $source_location]]\n\n            :put DependencyEdges {\n                from_key, to_key, edge_type =>\n                source_location\n            }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"from_key\".to_string(), DataValue::Str(edge.from_key.as_ref().into()));\n        params.insert(\"to_key\".to_string(), DataValue::Str(edge.to_key.as_ref().into()));\n        params.insert(\"edge_type\".to_string(), DataValue::Str(edge.edge_type.as_str().into()));\n        params.insert(\n            \"source_location\".to_string(),\n            edge.source_location\n                .as_ref()\n                .map(|s| DataValue::Str(s.as_str().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edge\".to_string(),\n                reason: format!(\"Failed to insert dependency edge: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436149Z",
      "modified_at": "2025-11-01T15:29:24.436149Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:insert_edges_batch:______crates_parseltongue-core_src_storage_cozo_client_rs:201-245",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "insert_edges_batch",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 201,
        "end": 245
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn insert_edges_batch(&self, edges: &[DependencyEdge]) -> Result<()> {\n        if edges.is_empty() {\n            return Ok(());\n        }\n\n        // Build query with inline data for batch insert\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type, source_location] <- [{}]\n\n            :put DependencyEdges {{\n                from_key, to_key, edge_type =>\n                source_location\n            }}\n            \"#,\n            edges\n                .iter()\n                .map(|edge| {\n                    let source_loc = edge\n                        .source_location\n                        .as_ref()\n                        .map(|s| format!(\"'{}'\", s.replace('\\'', \"\\\\'\")))\n                        .unwrap_or_else(|| \"null\".to_string());\n\n                    format!(\n                        \"['{}', '{}', '{}', {}]\",\n                        edge.from_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.to_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.edge_type.as_str(),\n                        source_loc\n                    )\n                })\n                .collect::<Vec<_>>()\n                .join(\", \")\n        );\n\n        self.db\n            .run_script(&query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edges_batch\".to_string(),\n                reason: format!(\"Failed to batch insert {} edges: {}\", edges.len(), e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn insert_edges_batch(&self, edges: &[DependencyEdge]) -> Result<()> {\n        if edges.is_empty() {\n            return Ok(());\n        }\n\n        // Build query with inline data for batch insert\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type, source_location] <- [{}]\n\n            :put DependencyEdges {{\n                from_key, to_key, edge_type =>\n                source_location\n            }}\n            \"#,\n            edges\n                .iter()\n                .map(|edge| {\n                    let source_loc = edge\n                        .source_location\n                        .as_ref()\n                        .map(|s| format!(\"'{}'\", s.replace('\\'', \"\\\\'\")))\n                        .unwrap_or_else(|| \"null\".to_string());\n\n                    format!(\n                        \"['{}', '{}', '{}', {}]\",\n                        edge.from_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.to_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.edge_type.as_str(),\n                        source_loc\n                    )\n                })\n                .collect::<Vec<_>>()\n                .join(\", \")\n        );\n\n        self.db\n            .run_script(&query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edges_batch\".to_string(),\n                reason: format!(\"Failed to batch insert {} edges: {}\", edges.len(), e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436150Z",
      "modified_at": "2025-11-01T15:29:24.436150Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:insert_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:662-689",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "insert_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 662,
        "end": 689
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn insert_entity(&self, entity: &CodeEntity) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[$ISGL1_key, $Current_Code, $Future_Code, $interface_signature, $TDD_Classification,\n              $lsp_meta_data, $current_ind, $future_ind, $Future_Action, $file_path, $language,\n              $last_modified, $entity_type]]\n\n            :put CodeGraph {\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }\n        \"#;\n\n        let params = self.entity_to_params(entity)?;\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"insert_entity\".to_string(),\n                details: format!(\"Failed to insert entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "future_code": "    pub async fn insert_entity(&self, entity: &CodeEntity) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[$ISGL1_key, $Current_Code, $Future_Code, $interface_signature, $TDD_Classification,\n              $lsp_meta_data, $current_ind, $future_ind, $Future_Action, $file_path, $language,\n              $last_modified, $entity_type]]\n\n            :put CodeGraph {\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }\n        \"#;\n\n        let params = self.entity_to_params(entity)?;\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"insert_entity\".to_string(),\n                details: format!(\"Failed to insert entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436151Z",
      "modified_at": "2025-11-01T15:29:24.436151Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:into_inner:______crates_parseltongue-core_src_entities_rs:888-890",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "into_inner",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 888,
        "end": 890
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn into_inner(self) -> String {\n        self.0\n    }",
    "future_code": "    pub fn into_inner(self) -> String {\n        self.0\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436152Z",
      "modified_at": "2025-11-01T15:29:24.436152Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:invalid:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:138-143",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "invalid",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 138,
        "end": 143
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn invalid(errors: Vec<String>) -> Self {\n        Self {\n            is_valid: false,\n            errors,\n        }\n    }",
    "future_code": "    pub fn invalid(errors: Vec<String>) -> Self {\n        Self {\n            is_valid: false,\n            errors,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436153Z",
      "modified_at": "2025-11-01T15:29:24.436153Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:invalid_isgl1_key:______crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:41-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "invalid_isgl1_key",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "line_range": {
        "start": 41,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn invalid_isgl1_key(key: String) -> Self {\n        Self::InvalidIsgl1Key { key }\n    }",
    "future_code": "    pub fn invalid_isgl1_key(key: String) -> Self {\n        Self::InvalidIsgl1Key { key }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436154Z",
      "modified_at": "2025-11-01T15:29:24.436154Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:invalid_temporal_state:______crates_parseltongue-core_src_entities_rs:1101-1109",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "invalid_temporal_state",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1101,
        "end": 1109
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn invalid_temporal_state() {\n        let invalid_state = TemporalState {\n            current_ind: false,\n            future_ind: false,\n            future_action: None,\n        };\n\n        assert!(invalid_state.validate().is_err());\n    }",
    "future_code": "    fn invalid_temporal_state() {\n        let invalid_state = TemporalState {\n            current_ind: false,\n            future_ind: false,\n            future_action: None,\n        };\n\n        assert!(invalid_state.validate().is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436155Z",
      "modified_at": "2025-11-01T15:29:24.436155Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:is_available:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:131-133",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "is_available",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 131,
        "end": 133
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn is_available(&self) -> bool {\n        true\n    }",
    "future_code": "    async fn is_available(&self) -> bool {\n        true\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436156Z",
      "modified_at": "2025-11-01T15:29:24.436156Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:is_available:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:94-96",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "is_available",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 94,
        "end": 96
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn is_available(&self) -> bool {\n        self.enabled\n    }",
    "future_code": "    async fn is_available(&self) -> bool {\n        self.enabled\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436158Z",
      "modified_at": "2025-11-01T15:29:24.436158Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:is_changed:______crates_parseltongue-core_src_entities_rs:235-237",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "is_changed",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 235,
        "end": 237
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn is_changed(&self) -> bool {\n        self.future_action.is_some()\n    }",
    "future_code": "    pub fn is_changed(&self) -> bool {\n        self.future_action.is_some()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436159Z",
      "modified_at": "2025-11-01T15:29:24.436159Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:is_connected:______crates_parseltongue-core_src_storage_cozo_client_rs:57-62",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "is_connected",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 57,
        "end": 62
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn is_connected(&self) -> bool {\n        // Test query to verify connection - use ::relations which always works\n        self.db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .is_ok()\n    }",
    "future_code": "    pub async fn is_connected(&self) -> bool {\n        // Test query to verify connection - use ::relations which always works\n        self.db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .is_ok()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436160Z",
      "modified_at": "2025-11-01T15:29:24.436160Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:is_modified:______crates_parseltongue-core_src_entities_rs:653-655",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "is_modified",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 653,
        "end": 655
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn is_modified(&self) -> bool {\n        self.temporal_state.is_changed()\n    }",
    "future_code": "    pub fn is_modified(&self) -> bool {\n        self.temporal_state.is_changed()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436161Z",
      "modified_at": "2025-11-01T15:29:24.436161Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:language_detection:______crates_parseltongue-core_src_entities_rs:1126-1135",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "language_detection",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1126,
        "end": 1135
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn language_detection() {\n        let rust_path = PathBuf::from(\"src/main.rs\");\n        assert_eq!(Language::from_file_path(&rust_path), Some(Language::Rust));\n\n        let js_path = PathBuf::from(\"app.js\");\n        assert_eq!(Language::from_file_path(&js_path), Some(Language::JavaScript));\n\n        let unknown_path = PathBuf::from(\"file.xyz\");\n        assert_eq!(Language::from_file_path(&unknown_path), None);\n    }",
    "future_code": "    fn language_detection() {\n        let rust_path = PathBuf::from(\"src/main.rs\");\n        assert_eq!(Language::from_file_path(&rust_path), Some(Language::Rust));\n\n        let js_path = PathBuf::from(\"app.js\");\n        assert_eq!(Language::from_file_path(&js_path), Some(Language::JavaScript));\n\n        let unknown_path = PathBuf::from(\"file.xyz\");\n        assert_eq!(Language::from_file_path(&unknown_path), None);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436162Z",
      "modified_at": "2025-11-01T15:29:24.436162Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:line:______crates_pt04-syntax-preflight-validator_src_errors_rs:81-88",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "line",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/errors.rs",
      "line_range": {
        "start": 81,
        "end": 88
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn line(&self) -> Option<usize> {\n        match self {\n            Self::SyntaxError { line, .. }\n            | Self::TypeError { line, .. }\n            | Self::BorrowError { line, .. } => Some(*line),\n            _ => None,\n        }\n    }",
    "future_code": "    pub fn line(&self) -> Option<usize> {\n        match self {\n            Self::SyntaxError { line, .. }\n            | Self::TypeError { line, .. }\n            | Self::BorrowError { line, .. } => Some(*line),\n            _ => None,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436163Z",
      "modified_at": "2025-11-01T15:29:24.436163Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:line_range_validation:______crates_parseltongue-core_src_entities_rs:1112-1123",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "line_range_validation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1112,
        "end": 1123
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn line_range_validation() {\n        let valid_range = LineRange::new(1, 5).unwrap();\n        assert_eq!(valid_range.span(), 5);\n        assert!(valid_range.contains(3));\n        assert!(!valid_range.contains(6));\n\n        // Invalid range (start > end)\n        assert!(LineRange::new(10, 5).is_err());\n\n        // Invalid range (zero-based)\n        assert!(LineRange::new(0, 5).is_err());\n    }",
    "future_code": "    fn line_range_validation() {\n        let valid_range = LineRange::new(1, 5).unwrap();\n        assert_eq!(valid_range.span(), 5);\n        assert!(valid_range.contains(3));\n        assert!(!valid_range.contains(6));\n\n        // Invalid range (start > end)\n        assert!(LineRange::new(10, 5).is_err());\n\n        // Invalid range (zero-based)\n        assert!(LineRange::new(0, 5).is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436164Z",
      "modified_at": "2025-11-01T15:29:24.436164Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:list_relations:______crates_parseltongue-core_src_storage_cozo_client_rs:642-659",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "list_relations",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 642,
        "end": 659
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn list_relations(&self) -> Result<Vec<String>> {\n        let result = self\n            .db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"list_relations\".to_string(),\n                details: format!(\"Failed to list relations: {}\", e),\n            })?;\n\n        let mut relations = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(name)) = row.first() {\n                relations.push(name.to_string());\n            }\n        }\n\n        Ok(relations)\n    }",
    "future_code": "    pub async fn list_relations(&self) -> Result<Vec<String>> {\n        let result = self\n            .db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"list_relations\".to_string(),\n                details: format!(\"Failed to list relations: {}\", e),\n            })?;\n\n        let mut relations = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(name)) = row.first() {\n                relations.push(name.to_string());\n            }\n        }\n\n        Ok(relations)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436165Z",
      "modified_at": "2025-11-01T15:29:24.436166Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_parseltongue_src_main_rs:19-57",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 19,
        "end": 57
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    let matches = build_cli().get_matches();\n\n    match matches.subcommand() {\n        Some((\"pt01-folder-to-cozodb-streamer\", sub_matches)) => {\n            run_folder_to_cozodb_streamer(sub_matches).await\n        }\n        Some((\"pt02-llm-cozodb-to-context-writer\", sub_matches)) => {\n            run_llm_cozodb_to_context_writer(sub_matches).await\n        }\n        Some((\"pt03-llm-to-cozodb-writer\", sub_matches)) => {\n            run_llm_to_cozodb_writer(sub_matches).await\n        }\n        Some((\"pt04-syntax-preflight-validator\", sub_matches)) => {\n            run_rust_preflight_code_simulator(sub_matches).await\n        }\n        Some((\"pt05-llm-cozodb-to-diff-writer\", sub_matches)) => {\n            run_llm_cozodb_to_diff_writer(sub_matches).await\n        }\n        Some((\"pt06-cozodb-make-future-code-current\", sub_matches)) => {\n            run_cozodb_make_future_code_current(sub_matches).await\n        }\n        _ => {\n            println!(\"{}\", style(\"Parseltongue CLI Toolkit\").blue().bold());\n            println!(\"{}\", style(\"Ultra-minimalist code analysis and modification toolkit\").blue());\n            println!();\n            println!(\"Use --help for more information\");\n            println!();\n            println!(\"Available commands:\");\n            println!(\"  pt01-folder-to-cozodb-streamer       - Index codebase into CozoDB (Tool 1: Ingest)\");\n            println!(\"  pt02-llm-cozodb-to-context-writer    - Generate context from CozoDB (Tool 2: Read)\");\n            println!(\"  pt03-llm-to-cozodb-writer            - Write LLM changes to temporal state (Tool 3: Edit)\");\n            println!(\"  pt04-syntax-preflight-validator      - Validate syntax of proposed changes (Tool 4: Validate)\");\n            println!(\"  pt05-llm-cozodb-to-diff-writer       - Generate CodeDiff.json (Tool 5: Diff)\");\n            println!(\"  pt06-cozodb-make-future-code-current - Reset database state (Tool 6: Reset)\");\n            Ok(())\n        }\n    }\n}",
    "future_code": "async fn main() -> Result<()> {\n    let matches = build_cli().get_matches();\n\n    match matches.subcommand() {\n        Some((\"pt01-folder-to-cozodb-streamer\", sub_matches)) => {\n            run_folder_to_cozodb_streamer(sub_matches).await\n        }\n        Some((\"pt02-llm-cozodb-to-context-writer\", sub_matches)) => {\n            run_llm_cozodb_to_context_writer(sub_matches).await\n        }\n        Some((\"pt03-llm-to-cozodb-writer\", sub_matches)) => {\n            run_llm_to_cozodb_writer(sub_matches).await\n        }\n        Some((\"pt04-syntax-preflight-validator\", sub_matches)) => {\n            run_rust_preflight_code_simulator(sub_matches).await\n        }\n        Some((\"pt05-llm-cozodb-to-diff-writer\", sub_matches)) => {\n            run_llm_cozodb_to_diff_writer(sub_matches).await\n        }\n        Some((\"pt06-cozodb-make-future-code-current\", sub_matches)) => {\n            run_cozodb_make_future_code_current(sub_matches).await\n        }\n        _ => {\n            println!(\"{}\", style(\"Parseltongue CLI Toolkit\").blue().bold());\n            println!(\"{}\", style(\"Ultra-minimalist code analysis and modification toolkit\").blue());\n            println!();\n            println!(\"Use --help for more information\");\n            println!();\n            println!(\"Available commands:\");\n            println!(\"  pt01-folder-to-cozodb-streamer       - Index codebase into CozoDB (Tool 1: Ingest)\");\n            println!(\"  pt02-llm-cozodb-to-context-writer    - Generate context from CozoDB (Tool 2: Read)\");\n            println!(\"  pt03-llm-to-cozodb-writer            - Write LLM changes to temporal state (Tool 3: Edit)\");\n            println!(\"  pt04-syntax-preflight-validator      - Validate syntax of proposed changes (Tool 4: Validate)\");\n            println!(\"  pt05-llm-cozodb-to-diff-writer       - Generate CodeDiff.json (Tool 5: Diff)\");\n            println!(\"  pt06-cozodb-make-future-code-current - Reset database state (Tool 6: Reset)\");\n            Ok(())\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436167Z",
      "modified_at": "2025-11-01T15:29:24.436167Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt01-folder-to-cozodb-streamer_src_main_rs:15-72",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "line_range": {
        "start": 15,
        "end": 72
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            let config = CliConfig::parse_config(&matches);\n\n            // Handle quiet/verbose flags\n            let quiet = matches.get_flag(\"quiet\");\n            let verbose = matches.get_flag(\"verbose\");\n\n            if !quiet {\n                println!(\n                    \"{}\",\n                    style(\"Parseltongue Tool 01: folder-to-cozoDB-streamer\")\n                        .blue()\n                        .bold()\n                );\n                println!(\"{}\", style(\"Ultra-minimalist code streaming to CozoDB\").blue());\n                println!();\n            }\n\n            // Create and run streamer\n            match run_streamer(&config, verbose, quiet).await {\n                Ok(result) => {\n                    if !quiet {\n                        println!(\n                            \"{}\",\n                            style(\" Streaming completed successfully!\").green().bold()\n                        );\n                        if result.errors.is_empty() {\n                            println!(\"{}\", style(\"No errors encountered.\").green());\n                        } else {\n                            println!(\n                                \"{}\",\n                                style(format!(\" {} warnings encountered\", result.errors.len()))\n                                    .yellow()\n                            );\n                        }\n                    }\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "future_code": "async fn main() -> Result<()> {\n\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            let config = CliConfig::parse_config(&matches);\n\n            // Handle quiet/verbose flags\n            let quiet = matches.get_flag(\"quiet\");\n            let verbose = matches.get_flag(\"verbose\");\n\n            if !quiet {\n                println!(\n                    \"{}\",\n                    style(\"Parseltongue Tool 01: folder-to-cozoDB-streamer\")\n                        .blue()\n                        .bold()\n                );\n                println!(\"{}\", style(\"Ultra-minimalist code streaming to CozoDB\").blue());\n                println!();\n            }\n\n            // Create and run streamer\n            match run_streamer(&config, verbose, quiet).await {\n                Ok(result) => {\n                    if !quiet {\n                        println!(\n                            \"{}\",\n                            style(\" Streaming completed successfully!\").green().bold()\n                        );\n                        if result.errors.is_empty() {\n                            println!(\"{}\", style(\"No errors encountered.\").green());\n                        } else {\n                            println!(\n                                \"{}\",\n                                style(format!(\" {} warnings encountered\", result.errors.len()))\n                                    .yellow()\n                            );\n                        }\n                    }\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436168Z",
      "modified_at": "2025-11-01T15:29:24.436168Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:16-90",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 16,
        "end": 90
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    let _term = Term::stdout();\n\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            let config = CliConfig::parse_config(&matches);\n\n            // Handle quiet/verbose flags\n            let quiet = matches.get_flag(\"quiet\");\n            let verbose = matches.get_flag(\"verbose\");\n            let dry_run = matches.get_flag(\"dry-run\");\n\n            if !quiet {\n                println!(\n                    \"{}\",\n                    style(\"Parseltongue Tool 02: LLM-cozoDB-to-context-writer\")\n                        .blue()\n                        .bold()\n                );\n                println!(\"{}\", style(\"Ultra-minimalist context optimization with CozoDB\").blue());\n                println!();\n            }\n\n            // Validate configuration\n            let llm_client = ToolFactory::create_llm_client(config.clone());\n            if let Err(e) = llm_client.validate_config() {\n                eprintln!(\"{} Configuration error: {}\", style(\"Error:\").red().bold(), e);\n                std::process::exit(1);\n            }\n\n            // Create and run optimizer\n            match run_optimizer(&config, &matches, verbose, quiet, dry_run).await {\n                Ok(result) => {\n                    if !quiet {\n                        println!(\n                            \"{}\",\n                            style(\" Context optimizer completed successfully!\").green().bold()\n                        );\n                        if result.errors.is_empty() {\n                            println!(\"{}\", style(\"No errors encountered.\").green());\n                        } else {\n                            println!(\n                                \"{}\",\n                                style(format!(\" {} warnings encountered\", result.errors.len()))\n                                    .yellow()\n                            );\n                        }\n\n                        if dry_run {\n                            println!(\n                                \"{}\",\n                                style(\" Dry run mode - no context files were written.\")\n                                    .cyan()\n                            );\n                        }\n                    }\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "future_code": "async fn main() -> Result<()> {\n    let _term = Term::stdout();\n\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            let config = CliConfig::parse_config(&matches);\n\n            // Handle quiet/verbose flags\n            let quiet = matches.get_flag(\"quiet\");\n            let verbose = matches.get_flag(\"verbose\");\n            let dry_run = matches.get_flag(\"dry-run\");\n\n            if !quiet {\n                println!(\n                    \"{}\",\n                    style(\"Parseltongue Tool 02: LLM-cozoDB-to-context-writer\")\n                        .blue()\n                        .bold()\n                );\n                println!(\"{}\", style(\"Ultra-minimalist context optimization with CozoDB\").blue());\n                println!();\n            }\n\n            // Validate configuration\n            let llm_client = ToolFactory::create_llm_client(config.clone());\n            if let Err(e) = llm_client.validate_config() {\n                eprintln!(\"{} Configuration error: {}\", style(\"Error:\").red().bold(), e);\n                std::process::exit(1);\n            }\n\n            // Create and run optimizer\n            match run_optimizer(&config, &matches, verbose, quiet, dry_run).await {\n                Ok(result) => {\n                    if !quiet {\n                        println!(\n                            \"{}\",\n                            style(\" Context optimizer completed successfully!\").green().bold()\n                        );\n                        if result.errors.is_empty() {\n                            println!(\"{}\", style(\"No errors encountered.\").green());\n                        } else {\n                            println!(\n                                \"{}\",\n                                style(format!(\" {} warnings encountered\", result.errors.len()))\n                                    .yellow()\n                            );\n                        }\n\n                        if dry_run {\n                            println!(\n                                \"{}\",\n                                style(\" Dry run mode - no context files were written.\")\n                                    .cyan()\n                            );\n                        }\n                    }\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436169Z",
      "modified_at": "2025-11-01T15:29:24.436169Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt03-llm-to-cozodb-writer_src_main_rs:17-53",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "line_range": {
        "start": 17,
        "end": 53
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            // Parse interface mode (Simple or Advanced)\n            let mode = CliConfig::parse_interface_mode(&matches);\n\n            println!(\n                \"{}\",\n                style(\"Running Tool 2: llm-to-cozodb-writer\").cyan()\n            );\n\n            // Execute based on interface mode\n            match run_writer(mode).await {\n                Ok(()) => {\n                    println!(\n                        \"{}\",\n                        style(\" Entity updated successfully\").green().bold()\n                    );\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "future_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            // Parse interface mode (Simple or Advanced)\n            let mode = CliConfig::parse_interface_mode(&matches);\n\n            println!(\n                \"{}\",\n                style(\"Running Tool 2: llm-to-cozodb-writer\").cyan()\n            );\n\n            // Execute based on interface mode\n            match run_writer(mode).await {\n                Ok(()) => {\n                    println!(\n                        \"{}\",\n                        style(\" Entity updated successfully\").green().bold()\n                    );\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436171Z",
      "modified_at": "2025-11-01T15:29:24.436171Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt04-syntax-preflight-validator_src_main_rs:25-124",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/main.rs",
      "line_range": {
        "start": 25,
        "end": 124
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 04: Simplified Syntax Validator\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    // Get entities with future_code (Create or Edit operations)\n    let changed_entities = storage\n        .get_changed_entities()\n        .await\n        .context(\"Failed to get changed entities from CozoDB\")?;\n\n    if changed_entities.is_empty() {\n        println!(\n            \"{}\",\n            style(\"No entities with future_code found. Nothing to validate.\")\n                .yellow()\n        );\n        return Ok(());\n    }\n\n    println!(\n        \"\\n{} entities with future_code found\",\n        style(changed_entities.len()).bold()\n    );\n\n    // Create validator\n    let mut validator =\n        SimpleSyntaxValidator::new().context(\"Failed to create syntax validator\")?;\n\n    // Validate each entity\n    let mut valid_count = 0;\n    let mut invalid_count = 0;\n    let mut error_details = Vec::new();\n\n    for entity in &changed_entities {\n        if let Some(future_code) = &entity.future_code {\n            match validator.validate_syntax(future_code) {\n                Ok(result) => {\n                    if result.is_valid {\n                        valid_count += 1;\n                        if cli.verbose {\n                            println!(\"  {} {}\", style(\"\").green(), entity.isgl1_key);\n                        }\n                    } else {\n                        invalid_count += 1;\n                        println!(\"  {} {}\", style(\"\").red(), entity.isgl1_key);\n                        for error in &result.errors {\n                            println!(\"    {}\", style(error).red().dim());\n                            error_details.push((entity.isgl1_key.clone(), error.clone()));\n                        }\n                    }\n                }\n                Err(e) => {\n                    invalid_count += 1;\n                    println!(\n                        \"  {} {} - Validation error: {}\",\n                        style(\"\").red(),\n                        entity.isgl1_key,\n                        style(e).red()\n                    );\n                }\n            }\n        }\n    }\n\n    // Print summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total entities: {}\", changed_entities.len());\n    println!(\"  {} Valid syntax: {}\", style(\"\").green(), valid_count);\n    println!(\"  {} Invalid syntax: {}\", style(\"\").red(), invalid_count);\n\n    if invalid_count > 0 {\n        println!(\n            \"\\n{}\",\n            style(\"Syntax validation failed. Fix errors and retry.\")\n                .red()\n                .bold()\n        );\n        std::process::exit(1);\n    } else {\n        println!(\n            \"\\n{}\",\n            style(\" All syntax checks passed! Ready for file writes (Tool 5).\")\n                .green()\n                .bold()\n        );\n        Ok(())\n    }\n}",
    "future_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 04: Simplified Syntax Validator\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    // Get entities with future_code (Create or Edit operations)\n    let changed_entities = storage\n        .get_changed_entities()\n        .await\n        .context(\"Failed to get changed entities from CozoDB\")?;\n\n    if changed_entities.is_empty() {\n        println!(\n            \"{}\",\n            style(\"No entities with future_code found. Nothing to validate.\")\n                .yellow()\n        );\n        return Ok(());\n    }\n\n    println!(\n        \"\\n{} entities with future_code found\",\n        style(changed_entities.len()).bold()\n    );\n\n    // Create validator\n    let mut validator =\n        SimpleSyntaxValidator::new().context(\"Failed to create syntax validator\")?;\n\n    // Validate each entity\n    let mut valid_count = 0;\n    let mut invalid_count = 0;\n    let mut error_details = Vec::new();\n\n    for entity in &changed_entities {\n        if let Some(future_code) = &entity.future_code {\n            match validator.validate_syntax(future_code) {\n                Ok(result) => {\n                    if result.is_valid {\n                        valid_count += 1;\n                        if cli.verbose {\n                            println!(\"  {} {}\", style(\"\").green(), entity.isgl1_key);\n                        }\n                    } else {\n                        invalid_count += 1;\n                        println!(\"  {} {}\", style(\"\").red(), entity.isgl1_key);\n                        for error in &result.errors {\n                            println!(\"    {}\", style(error).red().dim());\n                            error_details.push((entity.isgl1_key.clone(), error.clone()));\n                        }\n                    }\n                }\n                Err(e) => {\n                    invalid_count += 1;\n                    println!(\n                        \"  {} {} - Validation error: {}\",\n                        style(\"\").red(),\n                        entity.isgl1_key,\n                        style(e).red()\n                    );\n                }\n            }\n        }\n    }\n\n    // Print summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total entities: {}\", changed_entities.len());\n    println!(\"  {} Valid syntax: {}\", style(\"\").green(), valid_count);\n    println!(\"  {} Invalid syntax: {}\", style(\"\").red(), invalid_count);\n\n    if invalid_count > 0 {\n        println!(\n            \"\\n{}\",\n            style(\"Syntax validation failed. Fix errors and retry.\")\n                .red()\n                .bold()\n        );\n        std::process::exit(1);\n    } else {\n        println!(\n            \"\\n{}\",\n            style(\" All syntax checks passed! Ready for file writes (Tool 5).\")\n                .green()\n                .bold()\n        );\n        Ok(())\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436172Z",
      "modified_at": "2025-11-01T15:29:24.436172Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt05-llm-cozodb-to-diff-writer_src_main_rs:31-104",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/main.rs",
      "line_range": {
        "start": 31,
        "end": 104
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 05: LLM-cozoDB-to-diff-writer\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"CodeDiff.json Generator\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    if cli.verbose {\n        println!(\"\\n{}\", style(\"Configuration:\").bold());\n        println!(\"  Database: {}\", cli.database);\n        println!(\"  Output: {}\", cli.output.display());\n    }\n\n    // Generate diff (with dependency injection)\n    let storage = Arc::new(storage);\n    let generator = DiffGenerator::new(storage);\n    let diff = generator\n        .generate_diff()\n        .await\n        .context(\"Failed to generate CodeDiff\")?;\n\n    // Display summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  {} Create: {}\", style(\"\").green(), diff.metadata.create_count);\n    println!(\"  {} Edit: {}\", style(\" \").yellow(), diff.metadata.edit_count);\n    println!(\"  {} Delete: {}\", style(\" \").red(), diff.metadata.delete_count);\n\n    if cli.verbose && !diff.changes.is_empty() {\n        println!(\"\\n{}\", style(\"Changes:\").bold());\n        for change in &diff.changes {\n            let icon = match change.operation {\n                pt05_llm_cozodb_to_diff_writer::Operation::Create => style(\"\").green(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Edit => style(\" \").yellow(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Delete => style(\" \").red(),\n            };\n            println!(\"  {} {}\", icon, change.file_path.display());\n            if cli.verbose {\n                println!(\"     ISGL1: {}\", change.isgl1_key);\n            }\n        }\n    }\n\n    // Write JSON to file\n    let json = diff\n        .to_json_pretty()\n        .context(\"Failed to serialize CodeDiff\")?;\n    std::fs::write(&cli.output, json).context(\"Failed to write CodeDiff.json\")?;\n\n    println!(\n        \"\\n{}\",\n        style(format!(\" CodeDiff.json written to: {}\", cli.output.display()))\n            .green()\n            .bold()\n    );\n\n    println!(\"\\n{}\", style(\"Next Steps:\").bold().cyan());\n    println!(\"  1. LLM reads CodeDiff.json\");\n    println!(\"  2. LLM applies changes to codebase files\");\n    println!(\"  3. Run cargo build to verify compilation\");\n    println!(\"  4. Run cargo test to verify functionality\");\n\n    Ok(())\n}",
    "future_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 05: LLM-cozoDB-to-diff-writer\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"CodeDiff.json Generator\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    if cli.verbose {\n        println!(\"\\n{}\", style(\"Configuration:\").bold());\n        println!(\"  Database: {}\", cli.database);\n        println!(\"  Output: {}\", cli.output.display());\n    }\n\n    // Generate diff (with dependency injection)\n    let storage = Arc::new(storage);\n    let generator = DiffGenerator::new(storage);\n    let diff = generator\n        .generate_diff()\n        .await\n        .context(\"Failed to generate CodeDiff\")?;\n\n    // Display summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  {} Create: {}\", style(\"\").green(), diff.metadata.create_count);\n    println!(\"  {} Edit: {}\", style(\" \").yellow(), diff.metadata.edit_count);\n    println!(\"  {} Delete: {}\", style(\" \").red(), diff.metadata.delete_count);\n\n    if cli.verbose && !diff.changes.is_empty() {\n        println!(\"\\n{}\", style(\"Changes:\").bold());\n        for change in &diff.changes {\n            let icon = match change.operation {\n                pt05_llm_cozodb_to_diff_writer::Operation::Create => style(\"\").green(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Edit => style(\" \").yellow(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Delete => style(\" \").red(),\n            };\n            println!(\"  {} {}\", icon, change.file_path.display());\n            if cli.verbose {\n                println!(\"     ISGL1: {}\", change.isgl1_key);\n            }\n        }\n    }\n\n    // Write JSON to file\n    let json = diff\n        .to_json_pretty()\n        .context(\"Failed to serialize CodeDiff\")?;\n    std::fs::write(&cli.output, json).context(\"Failed to write CodeDiff.json\")?;\n\n    println!(\n        \"\\n{}\",\n        style(format!(\" CodeDiff.json written to: {}\", cli.output.display()))\n            .green()\n            .bold()\n    );\n\n    println!(\"\\n{}\", style(\"Next Steps:\").bold().cyan());\n    println!(\"  1. LLM reads CodeDiff.json\");\n    println!(\"  2. LLM applies changes to codebase files\");\n    println!(\"  3. Run cargo build to verify compilation\");\n    println!(\"  4. Run cargo test to verify functionality\");\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436173Z",
      "modified_at": "2025-11-01T15:29:24.436173Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:main:______crates_pt06-cozodb-make-future-code-current_src_main_rs:10-82",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "main",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/main.rs",
      "line_range": {
        "start": 10,
        "end": 82
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn main() -> Result<()> {\n    let cli = cli::Cli::parse_args();\n\n    println!(\"\\n{}\", style(\"Parseltongue Tool 06: cozoDB-make-future-code-current\").bold().cyan());\n    println!(\"{}\", style(\"Ultra-Minimalist State Reset Manager\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    println!(\"\\n{}\", style(\"Configuration:\").bold());\n    println!(\"  Database: {}\", cli.database);\n    println!(\"  Project: {}\", cli.project_path.display());\n\n    println!(\"\\n{}\", style(\"Ultra-Minimalist Principles:\").bold().yellow());\n    println!(\"  {} NO BACKUP METADATA - Direct table deletion\", style(\"\").green());\n    println!(\"  {} NO CONFIGURATION - Single deterministic operation\", style(\"\").green());\n    println!(\"  {} NO ROLLBACK - Permanent state reset\", style(\"\").green());\n    println!(\"  {} NO COMPLEXITY - Delete  Recreate  Re-index\", style(\"\").green());\n\n    // Initialize CozoDB storage\n    println!(\"\\n{}\", style(\"Initializing storage...\").bold());\n    // Accept database backend prefix from CLI (rocksdb: or sqlite:)\n    let storage = CozoDbStorage::new(&cli.database).await?;\n    if cli.verbose {\n        println!(\"  {} Storage initialized\", style(\"\").green());\n    }\n\n    // Create state reset manager\n    let manager = StateResetManager::new(storage);\n\n    // Perform state reset\n    println!(\"\\n{}\", style(\"Performing state reset...\").bold().yellow());\n    println!(\"  {} Deleting CodeGraph table\", style(\"\").cyan());\n    println!(\"  {} Recreating schema\", style(\"\").cyan());\n\n    let result = manager.reset(&cli.project_path).await?;\n\n    // Display results\n    println!(\"\\n{}\", style(\"Reset Complete!\").bold().green());\n    println!(\"  Success: {}\", if result.success { style(\"\").green() } else { style(\"\").red() });\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { style(\"\").green() } else { style(\"\").red() });\n\n    // PRD-compliant re-indexing (call Tool 1 directly - NO config duplication)\n    if cli.reindex {\n        println!(\"\\n{}\", style(\"Re-indexing project (Tool 1)...\").bold().yellow());\n\n        // S01 Ultra-minimalist: Just call pt01 binary with same DB\n        // NO config duplication - Tool 1 owns its own configuration\n        let pt01_status = std::process::Command::new(\"parseltongue\")\n            .arg(\"pt01-folder-to-cozodb-streamer\")\n            .arg(&cli.project_path)\n            .arg(\"--db\")\n            .arg(&cli.database)\n            .arg(if cli.verbose { \"--verbose\" } else { \"--quiet\" })\n            .status()?;\n\n        if !pt01_status.success() {\n            eprintln!(\"{}\", style(\" Re-indexing failed\").red().bold());\n            std::process::exit(1);\n        }\n\n        println!(\"\\n{}\", style(\"Complete Cycle Finished!\").bold().green());\n        println!(\"  {} Reset complete\", style(\"\").green());\n        println!(\"  {} Re-indexing complete\", style(\"\").green());\n        println!(\"  {} Ready for next iteration\", style(\"\").green());\n    } else {\n        println!(\"\\n{}\", style(\"Next Steps (Manual):\").bold().yellow());\n        println!(\"  1. Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\",\n                 cli.project_path.display(), cli.database);\n        println!(\"  2. Continue with workflow...\");\n    }\n\n    Ok(())\n}",
    "future_code": "async fn main() -> Result<()> {\n    let cli = cli::Cli::parse_args();\n\n    println!(\"\\n{}\", style(\"Parseltongue Tool 06: cozoDB-make-future-code-current\").bold().cyan());\n    println!(\"{}\", style(\"Ultra-Minimalist State Reset Manager\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    println!(\"\\n{}\", style(\"Configuration:\").bold());\n    println!(\"  Database: {}\", cli.database);\n    println!(\"  Project: {}\", cli.project_path.display());\n\n    println!(\"\\n{}\", style(\"Ultra-Minimalist Principles:\").bold().yellow());\n    println!(\"  {} NO BACKUP METADATA - Direct table deletion\", style(\"\").green());\n    println!(\"  {} NO CONFIGURATION - Single deterministic operation\", style(\"\").green());\n    println!(\"  {} NO ROLLBACK - Permanent state reset\", style(\"\").green());\n    println!(\"  {} NO COMPLEXITY - Delete  Recreate  Re-index\", style(\"\").green());\n\n    // Initialize CozoDB storage\n    println!(\"\\n{}\", style(\"Initializing storage...\").bold());\n    // Accept database backend prefix from CLI (rocksdb: or sqlite:)\n    let storage = CozoDbStorage::new(&cli.database).await?;\n    if cli.verbose {\n        println!(\"  {} Storage initialized\", style(\"\").green());\n    }\n\n    // Create state reset manager\n    let manager = StateResetManager::new(storage);\n\n    // Perform state reset\n    println!(\"\\n{}\", style(\"Performing state reset...\").bold().yellow());\n    println!(\"  {} Deleting CodeGraph table\", style(\"\").cyan());\n    println!(\"  {} Recreating schema\", style(\"\").cyan());\n\n    let result = manager.reset(&cli.project_path).await?;\n\n    // Display results\n    println!(\"\\n{}\", style(\"Reset Complete!\").bold().green());\n    println!(\"  Success: {}\", if result.success { style(\"\").green() } else { style(\"\").red() });\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { style(\"\").green() } else { style(\"\").red() });\n\n    // PRD-compliant re-indexing (call Tool 1 directly - NO config duplication)\n    if cli.reindex {\n        println!(\"\\n{}\", style(\"Re-indexing project (Tool 1)...\").bold().yellow());\n\n        // S01 Ultra-minimalist: Just call pt01 binary with same DB\n        // NO config duplication - Tool 1 owns its own configuration\n        let pt01_status = std::process::Command::new(\"parseltongue\")\n            .arg(\"pt01-folder-to-cozodb-streamer\")\n            .arg(&cli.project_path)\n            .arg(\"--db\")\n            .arg(&cli.database)\n            .arg(if cli.verbose { \"--verbose\" } else { \"--quiet\" })\n            .status()?;\n\n        if !pt01_status.success() {\n            eprintln!(\"{}\", style(\" Re-indexing failed\").red().bold());\n            std::process::exit(1);\n        }\n\n        println!(\"\\n{}\", style(\"Complete Cycle Finished!\").bold().green());\n        println!(\"  {} Reset complete\", style(\"\").green());\n        println!(\"  {} Re-indexing complete\", style(\"\").green());\n        println!(\"  {} Ready for next iteration\", style(\"\").green());\n    } else {\n        println!(\"\\n{}\", style(\"Next Steps (Manual):\").bold().yellow());\n        println!(\"  1. Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\",\n                 cli.project_path.display(), cli.database);\n        println!(\"  2. Continue with workflow...\");\n    }\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436174Z",
      "modified_at": "2025-11-01T15:29:24.436174Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:matches_pattern:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:273-281",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "matches_pattern",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 273,
        "end": 281
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn matches_pattern(&self, path: &str, pattern: &str) -> bool {\n        if pattern.contains('*') {\n            // Simple pattern matching: check if path ends with extension\n            // TODO: Implement proper glob matching for complex patterns\n            path.contains(&pattern.replace('*', \"\")) || path == pattern\n        } else {\n            path.contains(pattern)\n        }\n    }",
    "future_code": "    fn matches_pattern(&self, path: &str, pattern: &str) -> bool {\n        if pattern.contains('*') {\n            // Simple pattern matching: check if path ends with extension\n            // TODO: Implement proper glob matching for complex patterns\n            path.contains(&pattern.replace('*', \"\")) || path == pattern\n        } else {\n            path.contains(pattern)\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436175Z",
      "modified_at": "2025-11-01T15:29:24.436175Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:metadata:______crates_parseltongue-core_src_interfaces_rs:609-611",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "metadata",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 609,
        "end": 611
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        fn metadata(&self) -> ToolMetadata {\n            self.metadata.clone()\n        }",
    "future_code": "        fn metadata(&self) -> ToolMetadata {\n            self.metadata.clone()\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436176Z",
      "modified_at": "2025-11-01T15:29:24.436176Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:mock_tool_implementation:______crates_parseltongue-core_src_interfaces_rs:658-680",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "mock_tool_implementation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 658,
        "end": 680
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn mock_tool_implementation() {\n        let mock_tool = MockTool::new(\"test\")\n            .with_execute_result(Ok(ToolOutput::IndexingComplete {\n                entities_count: 42,\n                duration_ms: 1000,\n            }));\n\n        let input = ToolInput::IndexFolder {\n            path: PathBuf::from(\"test\"),\n            language_filter: None,\n        };\n\n        let result = mock_tool.execute(input).await.unwrap();\n        match result {\n            ToolOutput::IndexingComplete { entities_count, .. } => {\n                assert_eq!(entities_count, 42);\n            }\n            _ => panic!(\"Unexpected output type\"),\n        }\n\n        assert!(mock_tool.validate_input(&input).is_ok());\n        assert_eq!(mock_tool.metadata().name, \"test\");\n    }",
    "future_code": "    async fn mock_tool_implementation() {\n        let mock_tool = MockTool::new(\"test\")\n            .with_execute_result(Ok(ToolOutput::IndexingComplete {\n                entities_count: 42,\n                duration_ms: 1000,\n            }));\n\n        let input = ToolInput::IndexFolder {\n            path: PathBuf::from(\"test\"),\n            language_filter: None,\n        };\n\n        let result = mock_tool.execute(input).await.unwrap();\n        match result {\n            ToolOutput::IndexingComplete { entities_count, .. } => {\n                assert_eq!(entities_count, 42);\n            }\n            _ => panic!(\"Unexpected output type\"),\n        }\n\n        assert!(mock_tool.validate_input(&input).is_ok());\n        assert_eq!(mock_tool.metadata().name, \"test\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436177Z",
      "modified_at": "2025-11-01T15:29:24.436177Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:modify_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:62-74",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "modify_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 62,
        "end": 74
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn modify_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - direct overwrite\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Edit operation\"))?;\n\n        // Ultra-minimalist: Direct overwrite, NO backup\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Edit))\n    }",
    "future_code": "    async fn modify_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - direct overwrite\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Edit operation\"))?;\n\n        // Ultra-minimalist: Direct overwrite, NO backup\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Edit))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436178Z",
      "modified_at": "2025-11-01T15:29:24.436179Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_entities_rs:1004-1016",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1004,
        "end": 1016
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(\n        from_key: impl Into<String>,\n        to_key: impl Into<String>,\n        edge_type: EdgeType,\n        source_location: Option<String>,\n    ) -> Result<Self> {\n        Ok(Self {\n            from_key: Isgl1Key::new(from_key)?,\n            to_key: Isgl1Key::new(to_key)?,\n            edge_type,\n            source_location,\n        })\n    }",
    "future_code": "    pub fn new(\n        from_key: impl Into<String>,\n        to_key: impl Into<String>,\n        edge_type: EdgeType,\n        source_location: Option<String>,\n    ) -> Result<Self> {\n        Ok(Self {\n            from_key: Isgl1Key::new(from_key)?,\n            to_key: Isgl1Key::new(to_key)?,\n            edge_type,\n            source_location,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436180Z",
      "modified_at": "2025-11-01T15:29:24.436180Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_entities_rs:282-300",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 282,
        "end": 300
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(start: u32, end: u32) -> Result<Self> {\n        if start == 0 || end == 0 {\n            return Err(ParseltongError::ValidationError {\n                field: \"line numbers\".to_string(),\n                expected: \"1-based line numbers\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        if start > end {\n            return Err(ParseltongError::ValidationError {\n                field: \"line range\".to_string(),\n                expected: \"start <= end\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        Ok(Self { start, end })\n    }",
    "future_code": "    pub fn new(start: u32, end: u32) -> Result<Self> {\n        if start == 0 || end == 0 {\n            return Err(ParseltongError::ValidationError {\n                field: \"line numbers\".to_string(),\n                expected: \"1-based line numbers\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        if start > end {\n            return Err(ParseltongError::ValidationError {\n                field: \"line range\".to_string(),\n                expected: \"start <= end\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        Ok(Self { start, end })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436181Z",
      "modified_at": "2025-11-01T15:29:24.436181Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_entities_rs:609-625",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 609,
        "end": 625
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(\n        isgl1_key: String,\n        interface_signature: InterfaceSignature,\n    ) -> Result<Self> {\n        let entity = Self {\n            temporal_state: TemporalState::initial(),  // Tool 1 initial state: (1,0,None)\n            interface_signature,\n            current_code: None,\n            future_code: None,\n            tdd_classification: TddClassification::default(),\n            lsp_metadata: None,\n            metadata: EntityMetadata::new()?,\n            isgl1_key,\n        };\n\n        Ok(entity)\n    }",
    "future_code": "    pub fn new(\n        isgl1_key: String,\n        interface_signature: InterfaceSignature,\n    ) -> Result<Self> {\n        let entity = Self {\n            temporal_state: TemporalState::initial(),  // Tool 1 initial state: (1,0,None)\n            interface_signature,\n            current_code: None,\n            future_code: None,\n            tdd_classification: TddClassification::default(),\n            lsp_metadata: None,\n            metadata: EntityMetadata::new()?,\n            isgl1_key,\n        };\n\n        Ok(entity)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436182Z",
      "modified_at": "2025-11-01T15:29:24.436182Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_entities_rs:820-827",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 820,
        "end": 827
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Result<Self> {\n        Ok(Self {\n            created_at: chrono::Utc::now(),\n            modified_at: chrono::Utc::now(),\n            content_hash: String::new(), // Will be set when content is available\n            additional: HashMap::new(),\n        })\n    }",
    "future_code": "    pub fn new() -> Result<Self> {\n        Ok(Self {\n            created_at: chrono::Utc::now(),\n            modified_at: chrono::Utc::now(),\n            content_hash: String::new(), // Will be set when content is available\n            additional: HashMap::new(),\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436183Z",
      "modified_at": "2025-11-01T15:29:24.436183Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_entities_rs:861-871",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 861,
        "end": 871
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(key: impl Into<String>) -> Result<Self> {\n        let key = key.into();\n        if key.is_empty() {\n            Err(ParseltongError::InvalidIsgl1Key {\n                key,\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            })\n        } else {\n            Ok(Self(key))\n        }\n    }",
    "future_code": "    pub fn new(key: impl Into<String>) -> Result<Self> {\n        let key = key.into();\n        if key.is_empty() {\n            Err(ParseltongError::InvalidIsgl1Key {\n                key,\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            })\n        } else {\n            Ok(Self(key))\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436184Z",
      "modified_at": "2025-11-01T15:29:24.436184Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_interfaces_rs:549-568",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 549,
        "end": 568
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        pub fn new(name: &str) -> Self {\n            Self {\n                metadata: ToolMetadata {\n                    id: format!(\"mock-{}\", name),\n                    name: name.to_string(),\n                    version: \"1.0.0\".to_string(),\n                    description: format!(\"Mock implementation of {}\", name),\n                    supported_inputs: vec![],\n                    capabilities: ToolCapabilities {\n                        async_execution: true,\n                        parallel_processing: false,\n                        incremental_processing: false,\n                        requires_network: false,\n                        max_input_size: None,\n                    },\n                },\n                execute_result: None,\n                should_fail: false,\n            }\n        }",
    "future_code": "        pub fn new(name: &str) -> Self {\n            Self {\n                metadata: ToolMetadata {\n                    id: format!(\"mock-{}\", name),\n                    name: name.to_string(),\n                    version: \"1.0.0\".to_string(),\n                    description: format!(\"Mock implementation of {}\", name),\n                    supported_inputs: vec![],\n                    capabilities: ToolCapabilities {\n                        async_execution: true,\n                        parallel_processing: false,\n                        incremental_processing: false,\n                        requires_network: false,\n                        max_input_size: None,\n                    },\n                },\n                execute_result: None,\n                should_fail: false,\n            }\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436186Z",
      "modified_at": "2025-11-01T15:29:24.436186Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_storage_cozo_client_rs:38-54",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 38,
        "end": 54
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn new(engine_spec: &str) -> Result<Self> {\n        // Parse engine specification: \"engine:path\" or just \"engine\" (for mem)\n        let (engine, path) = if engine_spec.contains(':') {\n            let parts: Vec<&str> = engine_spec.splitn(2, ':').collect();\n            (parts[0], parts[1])\n        } else {\n            (engine_spec, \"\")\n        };\n\n        let db = DbInstance::new(engine, path, Default::default())\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"connection\".to_string(),\n                details: format!(\"Failed to create CozoDB instance with engine '{}' and path '{}': {}\", engine, path, e),\n            })?;\n\n        Ok(Self { db })\n    }",
    "future_code": "    pub async fn new(engine_spec: &str) -> Result<Self> {\n        // Parse engine specification: \"engine:path\" or just \"engine\" (for mem)\n        let (engine, path) = if engine_spec.contains(':') {\n            let parts: Vec<&str> = engine_spec.splitn(2, ':').collect();\n            (parts[0], parts[1])\n        } else {\n            (engine_spec, \"\")\n        };\n\n        let db = DbInstance::new(engine, path, Default::default())\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"connection\".to_string(),\n                details: format!(\"Failed to create CozoDB instance with engine '{}' and path '{}': {}\", engine, path, e),\n            })?;\n\n        Ok(Self { db })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436187Z",
      "modified_at": "2025-11-01T15:29:24.436187Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:275-277",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 275,
        "end": 277
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436188Z",
      "modified_at": "2025-11-01T15:29:24.436188Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:29-39",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 29,
        "end": 39
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self {\n            entities: HashMap::new(),\n            pending_changes: Vec::new(),\n            validation_rules: vec![\n                Box::new(NoCircularDependenciesRule::new()),\n                Box::new(ConsistentStateRule::new()),\n                Box::new(ValidTransitionsRule::new()),\n            ],\n        }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self {\n            entities: HashMap::new(),\n            pending_changes: Vec::new(),\n            validation_rules: vec![\n                Box::new(NoCircularDependenciesRule::new()),\n                Box::new(ConsistentStateRule::new()),\n                Box::new(ValidTransitionsRule::new()),\n            ],\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436189Z",
      "modified_at": "2025-11-01T15:29:24.436189Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:317-319",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 317,
        "end": 319
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436190Z",
      "modified_at": "2025-11-01T15:29:24.436190Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:365-367",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 365,
        "end": 367
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436191Z",
      "modified_at": "2025-11-01T15:29:24.436191Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:405-412",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 405,
        "end": 412
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(isgl1_key: String) -> Self {\n        Self {\n            isgl1_key,\n            action: None,\n            future_code: None,\n            updated_signature: None,\n        }\n    }",
    "future_code": "    pub fn new(isgl1_key: String) -> Self {\n        Self {\n            isgl1_key,\n            action: None,\n            future_code: None,\n            updated_signature: None,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436192Z",
      "modified_at": "2025-11-01T15:29:24.436192Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_parseltongue-core_src_temporal_rs:468-470",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 468,
        "end": 470
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(strategy: ConflictResolutionStrategy) -> Self {\n        Self { strategy }\n    }",
    "future_code": "    pub fn new(strategy: ConflictResolutionStrategy) -> Self {\n        Self { strategy }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436193Z",
      "modified_at": "2025-11-01T15:29:24.436193Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:433-435",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 433,
        "end": 435
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Arc<dyn Isgl1KeyGenerator> {\n        Arc::new(Isgl1KeyGeneratorImpl::new())\n    }",
    "future_code": "    pub fn new() -> Arc<dyn Isgl1KeyGenerator> {\n        Arc::new(Isgl1KeyGeneratorImpl::new())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436194Z",
      "modified_at": "2025-11-01T15:29:24.436194Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:66-81",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 66,
        "end": 81
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        let mut generators = HashMap::new();\n\n        // Initialize Rust parser\n        let mut rust_parser = Parser::new();\n        rust_parser\n            .set_language(tree_sitter_rust::language())\n            .expect(\"Error loading Rust grammar\");\n        generators.insert(Language::Rust, Arc::new(Mutex::new(rust_parser)));\n\n        Self {\n            rust_language: tree_sitter_rust::language(),\n            python_language: None, // TODO: Add Python support\n            parsers: generators,\n        }\n    }",
    "future_code": "    pub fn new() -> Self {\n        let mut generators = HashMap::new();\n\n        // Initialize Rust parser\n        let mut rust_parser = Parser::new();\n        rust_parser\n            .set_language(tree_sitter_rust::language())\n            .expect(\"Error loading Rust grammar\");\n        generators.insert(Language::Rust, Arc::new(Mutex::new(rust_parser)));\n\n        Self {\n            rust_language: tree_sitter_rust::language(),\n            python_language: None, // TODO: Add Python support\n            parsers: generators,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436195Z",
      "modified_at": "2025-11-01T15:29:24.436195Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:107-111",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 107,
        "end": 111
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self {\n            responses: std::collections::HashMap::new(),\n        }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self {\n            responses: std::collections::HashMap::new(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436196Z",
      "modified_at": "2025-11-01T15:29:24.436196Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:70-74",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 70,
        "end": 74
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn new() -> Self {\n        // TODO: Implement actual LSP process spawning\n        // For now, stub implementation\n        Self { enabled: false }\n    }",
    "future_code": "    pub async fn new() -> Self {\n        // TODO: Implement actual LSP process spawning\n        // For now, stub implementation\n        Self { enabled: false }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436197Z",
      "modified_at": "2025-11-01T15:29:24.436197Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:73-101",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 73,
        "end": 101
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn new(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        // Initialize LSP client (graceful degradation if unavailable)\n        let lsp_client = RustAnalyzerClientImpl::new().await;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client: Arc::new(lsp_client),\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
    "future_code": "    pub async fn new(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        // Initialize LSP client (graceful degradation if unavailable)\n        let lsp_client = RustAnalyzerClientImpl::new().await;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client: Arc::new(lsp_client),\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436198Z",
      "modified_at": "2025-11-01T15:29:24.436198Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:522-535",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 522,
        "end": 535
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn new(\n        config: crate::ContextWriterConfig,\n        llm_client: Arc<ContextLlmClientImpl>,\n    ) -> Result<Arc<ContextOptimizerImpl>> {\n        // Create storage instance for dependency injection\n        let storage = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| ContextWriterError::DatabaseError {\n                reason: format!(\"Failed to create storage: {}\", e)\n            })?;\n        let storage = Arc::new(storage);\n\n        Ok(Arc::new(ContextOptimizerImpl::new(storage, config, llm_client)))\n    }",
    "future_code": "    pub async fn new(\n        config: crate::ContextWriterConfig,\n        llm_client: Arc<ContextLlmClientImpl>,\n    ) -> Result<Arc<ContextOptimizerImpl>> {\n        // Create storage instance for dependency injection\n        let storage = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| ContextWriterError::DatabaseError {\n                reason: format!(\"Failed to create storage: {}\", e)\n            })?;\n        let storage = Arc::new(storage);\n\n        Ok(Arc::new(ContextOptimizerImpl::new(storage, config, llm_client)))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436199Z",
      "modified_at": "2025-11-01T15:29:24.436199Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:83-94",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 83,
        "end": 94
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(\n        storage: Arc<CozoDbStorage>,\n        config: crate::ContextWriterConfig,\n        llm_client: Arc<ContextLlmClientImpl>,\n    ) -> Self {\n        Self {\n            storage,\n            config,\n            llm_client,\n            stats: std::sync::Mutex::new(ContextOptimizerStats::default()),\n        }\n    }",
    "future_code": "    pub fn new(\n        storage: Arc<CozoDbStorage>,\n        config: crate::ContextWriterConfig,\n        llm_client: Arc<ContextLlmClientImpl>,\n    ) -> Self {\n        Self {\n            storage,\n            config,\n            llm_client,\n            stats: std::sync::Mutex::new(ContextOptimizerStats::default()),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436200Z",
      "modified_at": "2025-11-01T15:29:24.436200Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:190-210",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 190,
        "end": 210
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(config: crate::ContextWriterConfig) -> Self {\n        let http_client = reqwest::Client::builder()\n            .timeout(Duration::from_secs(120))\n            .build()\n            .expect(\"Failed to create HTTP client\");\n\n        let capabilities = ContextLlmCapabilities {\n            max_input_tokens: 128000,\n            max_output_tokens: config.max_tokens,\n            supported_models: vec![\"gpt-4\".to_string(), \"gpt-3.5-turbo\".to_string()],\n            rate_limit_rpm: 60,\n            supports_context_optimization: true,\n            supports_relationship_analysis: true,\n        };\n\n        Self {\n            config,\n            http_client,\n            capabilities,\n        }\n    }",
    "future_code": "    pub fn new(config: crate::ContextWriterConfig) -> Self {\n        let http_client = reqwest::Client::builder()\n            .timeout(Duration::from_secs(120))\n            .build()\n            .expect(\"Failed to create HTTP client\");\n\n        let capabilities = ContextLlmCapabilities {\n            max_input_tokens: 128000,\n            max_output_tokens: config.max_tokens,\n            supported_models: vec![\"gpt-4\".to_string(), \"gpt-3.5-turbo\".to_string()],\n            rate_limit_rpm: 60,\n            supports_context_optimization: true,\n            supports_relationship_analysis: true,\n        };\n\n        Self {\n            config,\n            http_client,\n            capabilities,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436201Z",
      "modified_at": "2025-11-01T15:29:24.436201Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:392-394",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 392,
        "end": 394
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(config: crate::ContextWriterConfig) -> Arc<ContextLlmClientImpl> {\n        Arc::new(ContextLlmClientImpl::new(config))\n    }",
    "future_code": "    pub fn new(config: crate::ContextWriterConfig) -> Arc<ContextLlmClientImpl> {\n        Arc::new(ContextLlmClientImpl::new(config))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436202Z",
      "modified_at": "2025-11-01T15:29:24.436202Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:46-54",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 46,
        "end": 54
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Result<Self> {\n        let mut parser = Parser::new();\n        let language = tree_sitter_rust::language();\n        parser\n            .set_language(language)\n            .context(\"Failed to set tree-sitter language\")?;\n\n        Ok(Self { parser })\n    }",
    "future_code": "    pub fn new() -> Result<Self> {\n        let mut parser = Parser::new();\n        let language = tree_sitter_rust::language();\n        parser\n            .set_language(language)\n            .context(\"Failed to set tree-sitter language\")?;\n\n        Ok(Self { parser })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436203Z",
      "modified_at": "2025-11-01T15:29:24.436203Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt04-syntax-preflight-validator_src_types_rs:117-127",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 117,
        "end": 127
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(file_path: Option<PathBuf>, code_snippet: String) -> Self {\n        Self {\n            file_path,\n            code_snippet,\n            individual_results: Vec::new(),\n            overall_valid: true,\n            total_execution_time_ms: 0,\n            total_memory_usage_bytes: 0,\n            generated_at: Utc::now(),\n        }\n    }",
    "future_code": "    pub fn new(file_path: Option<PathBuf>, code_snippet: String) -> Self {\n        Self {\n            file_path,\n            code_snippet,\n            individual_results: Vec::new(),\n            overall_valid: true,\n            total_execution_time_ms: 0,\n            total_memory_usage_bytes: 0,\n            generated_at: Utc::now(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436205Z",
      "modified_at": "2025-11-01T15:29:24.436205Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt04-syntax-preflight-validator_src_validator_rs:79-81",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 79,
        "end": 81
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436206Z",
      "modified_at": "2025-11-01T15:29:24.436206Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:55-57",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 55,
        "end": 57
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(storage: Arc<CozoDbStorage>) -> Self {\n        Self { storage }\n    }",
    "future_code": "    pub fn new(storage: Arc<CozoDbStorage>) -> Self {\n        Self { storage }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436207Z",
      "modified_at": "2025-11-01T15:29:24.436207Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:131-142",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 131,
        "end": 142
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self {\n            changes: Vec::new(),\n            metadata: DiffMetadata {\n                total_changes: 0,\n                create_count: 0,\n                edit_count: 0,\n                delete_count: 0,\n                generated_at: chrono::Utc::now().to_rfc3339(),\n            },\n        }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self {\n            changes: Vec::new(),\n            metadata: DiffMetadata {\n                total_changes: 0,\n                create_count: 0,\n                edit_count: 0,\n                delete_count: 0,\n                generated_at: chrono::Utc::now().to_rfc3339(),\n            },\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436208Z",
      "modified_at": "2025-11-01T15:29:24.436208Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:75-83",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 75,
        "end": 83
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new() -> Self {\n        Self {\n            created: 0,\n            edited: 0,\n            deleted: 0,\n            total: 0,\n            errors: 0,\n        }\n    }",
    "future_code": "    pub fn new() -> Self {\n        Self {\n            created: 0,\n            edited: 0,\n            deleted: 0,\n            total: 0,\n            errors: 0,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436209Z",
      "modified_at": "2025-11-01T15:29:24.436209Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:21-23",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 21,
        "end": 23
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(root_path: PathBuf) -> Self {\n        Self { root_path }\n    }",
    "future_code": "    pub fn new(root_path: PathBuf) -> Self {\n        Self { root_path }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436210Z",
      "modified_at": "2025-11-01T15:29:24.436210Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:16-18",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 16,
        "end": 18
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }",
    "future_code": "    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436211Z",
      "modified_at": "2025-11-01T15:29:24.436211Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new_unchecked:______crates_parseltongue-core_src_entities_rs:878-880",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new_unchecked",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 878,
        "end": 880
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn new_unchecked(key: impl Into<String>) -> Self {\n        Self(key.into())\n    }",
    "future_code": "    pub fn new_unchecked(key: impl Into<String>) -> Self {\n        Self(key.into())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436212Z",
      "modified_at": "2025-11-01T15:29:24.436212Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:new_with_lsp:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:105-131",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new_with_lsp",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 105,
        "end": 131
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn new_with_lsp(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        lsp_client: Arc<dyn RustAnalyzerClient>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
    "future_code": "    pub async fn new_with_lsp(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        lsp_client: Arc<dyn RustAnalyzerClient>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436213Z",
      "modified_at": "2025-11-01T15:29:24.436214Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:no_op:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:29-36",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "no_op",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 29,
        "end": 36
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn no_op() -> Self {\n        Self {\n            success: true,\n            file_path: PathBuf::new(),\n            operation: WriteOperation::NoOp,\n            message: Some(\"No operation required\".to_string()),\n        }\n    }",
    "future_code": "    pub fn no_op() -> Self {\n        Self {\n            success: true,\n            file_path: PathBuf::new(),\n            operation: WriteOperation::NoOp,\n            message: Some(\"No operation required\".to_string()),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436215Z",
      "modified_at": "2025-11-01T15:29:24.436215Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:optimize_context:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:299-355",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "optimize_context",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 299,
        "end": 355
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn optimize_context(&self, request: ContextOptimizationRequest) -> Result<ContextOptimizationResponse> {\n        let llm_request = ContextLlmRequest {\n            model: self.config.model.clone(),\n            messages: vec![\n                ContextLlmMessage {\n                    role: MessageRole::System,\n                    content: self.create_system_prompt(),\n                },\n                ContextLlmMessage {\n                    role: MessageRole::User,\n                    content: self.create_user_prompt(&request),\n                },\n            ],\n            max_tokens: Some(self.config.max_tokens),\n            temperature: self.config.temperature,\n            stream: false,\n            user: Some(Uuid::new_v4().to_string()),\n        };\n\n        let response = self.http_client\n            .post(&self.config.llm_endpoint)\n            .header(\"Authorization\", format!(\"Bearer {}\", self.config.llm_api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(&llm_request)\n            .send()\n            .await\n            .map_err(|e| ContextWriterError::LlmApiError {\n                status: 0,\n                message: format!(\"Request failed: {}\", e),\n            })?;\n\n        let status = response.status();\n        if status.is_client_error() || status.is_server_error() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ContextWriterError::LlmApiError {\n                status: status.as_u16(),\n                message: error_text,\n            });\n        }\n\n        let llm_response: ContextLlmResponse = response.json().await.map_err(|e| {\n            ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: format!(\"Failed to parse JSON response: {}\", e),\n            }\n        })?;\n\n        if llm_response.choices.is_empty() {\n            return Err(ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: \"No choices in LLM response\".to_string(),\n            });\n        }\n\n        let content = &llm_response.choices[0].message.content;\n        self.parse_response(content)\n    }",
    "future_code": "    async fn optimize_context(&self, request: ContextOptimizationRequest) -> Result<ContextOptimizationResponse> {\n        let llm_request = ContextLlmRequest {\n            model: self.config.model.clone(),\n            messages: vec![\n                ContextLlmMessage {\n                    role: MessageRole::System,\n                    content: self.create_system_prompt(),\n                },\n                ContextLlmMessage {\n                    role: MessageRole::User,\n                    content: self.create_user_prompt(&request),\n                },\n            ],\n            max_tokens: Some(self.config.max_tokens),\n            temperature: self.config.temperature,\n            stream: false,\n            user: Some(Uuid::new_v4().to_string()),\n        };\n\n        let response = self.http_client\n            .post(&self.config.llm_endpoint)\n            .header(\"Authorization\", format!(\"Bearer {}\", self.config.llm_api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(&llm_request)\n            .send()\n            .await\n            .map_err(|e| ContextWriterError::LlmApiError {\n                status: 0,\n                message: format!(\"Request failed: {}\", e),\n            })?;\n\n        let status = response.status();\n        if status.is_client_error() || status.is_server_error() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ContextWriterError::LlmApiError {\n                status: status.as_u16(),\n                message: error_text,\n            });\n        }\n\n        let llm_response: ContextLlmResponse = response.json().await.map_err(|e| {\n            ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: format!(\"Failed to parse JSON response: {}\", e),\n            }\n        })?;\n\n        if llm_response.choices.is_empty() {\n            return Err(ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: \"No choices in LLM response\".to_string(),\n            });\n        }\n\n        let content = &llm_response.choices[0].message.content;\n        self.parse_response(content)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436216Z",
      "modified_at": "2025-11-01T15:29:24.436216Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_args:______crates_pt04-syntax-preflight-validator_src_cli_rs:55-57",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_args",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/cli.rs",
      "line_range": {
        "start": 55,
        "end": 57
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "future_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436217Z",
      "modified_at": "2025-11-01T15:29:24.436217Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_args:______crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:27-29",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_args",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "line_range": {
        "start": 27,
        "end": 29
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "future_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436218Z",
      "modified_at": "2025-11-01T15:29:24.436218Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_args:______crates_pt06-cozodb-make-future-code-current_src_cli_rs:27-29",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_args",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/cli.rs",
      "line_range": {
        "start": 27,
        "end": 29
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "future_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436219Z",
      "modified_at": "2025-11-01T15:29:24.436219Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_config:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:81-101",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_config",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 81,
        "end": 101
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> StreamerConfig {\n        StreamerConfig {\n            root_dir: PathBuf::from(matches.get_one::<String>(\"directory\").unwrap()),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            // Hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n            max_file_size: 100 * 1024 * 1024,  // 100MB - let tree-sitter decide\n            include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n            exclude_patterns: vec![\n                \"target\".to_string(),      // Rust build\n                \"node_modules\".to_string(), // Node.js dependencies\n                \".git\".to_string(),        // Git metadata\n                \"build\".to_string(),       // Generic build dir\n                \"dist\".to_string(),        // Distribution files\n                \"__pycache__\".to_string(), // Python cache\n                \".venv\".to_string(),       // Python virtual env\n                \"venv\".to_string(),        // Python virtual env\n            ],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        }\n    }",
    "future_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> StreamerConfig {\n        StreamerConfig {\n            root_dir: PathBuf::from(matches.get_one::<String>(\"directory\").unwrap()),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            // Hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n            max_file_size: 100 * 1024 * 1024,  // 100MB - let tree-sitter decide\n            include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n            exclude_patterns: vec![\n                \"target\".to_string(),      // Rust build\n                \"node_modules\".to_string(), // Node.js dependencies\n                \".git\".to_string(),        // Git metadata\n                \"build\".to_string(),       // Generic build dir\n                \"dist\".to_string(),        // Distribution files\n                \"__pycache__\".to_string(), // Python cache\n                \".venv\".to_string(),       // Python virtual env\n                \"venv\".to_string(),        // Python virtual env\n            ],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436220Z",
      "modified_at": "2025-11-01T15:29:24.436220Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_config:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:160-177",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_config",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 160,
        "end": 177
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> ContextWriterConfig {\n        ContextWriterConfig {\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            llm_endpoint: matches.get_one::<String>(\"endpoint\").unwrap().clone(),\n            llm_api_key: matches\n                .get_one::<String>(\"api-key\")\n                .cloned()\n                .or_else(|| std::env::var(\"OPENAI_API_KEY\").ok())\n                .unwrap_or_default(),\n            model: matches.get_one::<String>(\"model\").unwrap().clone(),\n            max_tokens: *matches.get_one::<usize>(\"max-tokens\").unwrap(),\n            temperature: *matches.get_one::<f32>(\"temperature\").unwrap(),\n            entity_query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            max_context_tokens: *matches.get_one::<usize>(\"max-context-tokens\").unwrap(),\n            relevance_threshold: *matches.get_one::<f32>(\"relevance-threshold\").unwrap(),\n            output_dir: matches.get_one::<String>(\"output\").unwrap().clone(),\n        }\n    }",
    "future_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> ContextWriterConfig {\n        ContextWriterConfig {\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            llm_endpoint: matches.get_one::<String>(\"endpoint\").unwrap().clone(),\n            llm_api_key: matches\n                .get_one::<String>(\"api-key\")\n                .cloned()\n                .or_else(|| std::env::var(\"OPENAI_API_KEY\").ok())\n                .unwrap_or_default(),\n            model: matches.get_one::<String>(\"model\").unwrap().clone(),\n            max_tokens: *matches.get_one::<usize>(\"max-tokens\").unwrap(),\n            temperature: *matches.get_one::<f32>(\"temperature\").unwrap(),\n            entity_query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            max_context_tokens: *matches.get_one::<usize>(\"max-context-tokens\").unwrap(),\n            relevance_threshold: *matches.get_one::<f32>(\"relevance-threshold\").unwrap(),\n            output_dir: matches.get_one::<String>(\"output\").unwrap().clone(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436221Z",
      "modified_at": "2025-11-01T15:29:24.436221Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_config:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:127-132",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_config",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 127,
        "end": 132
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> LlmWriterConfig {\n        LlmWriterConfig {\n            query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n        }\n    }",
    "future_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> LlmWriterConfig {\n        LlmWriterConfig {\n            query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436222Z",
      "modified_at": "2025-11-01T15:29:24.436222Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_focus_areas:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:231-237",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_focus_areas",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 231,
        "end": 237
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_focus_areas(areas_str: &str) -> Vec<String> {\n        areas_str\n            .split(',')\n            .map(|s| s.trim().to_string())\n            .filter(|s| !s.is_empty())\n            .collect()\n    }",
    "future_code": "    pub fn parse_focus_areas(areas_str: &str) -> Vec<String> {\n        areas_str\n            .split(',')\n            .map(|s| s.trim().to_string())\n            .filter(|s| !s.is_empty())\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436223Z",
      "modified_at": "2025-11-01T15:29:24.436223Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_include_current_code:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:194-199",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_include_current_code",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 194,
        "end": 199
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_include_current_code(matches: &clap::ArgMatches) -> bool {\n        matches\n            .get_one::<String>(\"include-current-code\")\n            .map(|s| s == \"1\")\n            .unwrap_or(false)\n    }",
    "future_code": "    pub fn parse_include_current_code(matches: &clap::ArgMatches) -> bool {\n        matches\n            .get_one::<String>(\"include-current-code\")\n            .map(|s| s == \"1\")\n            .unwrap_or(false)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436224Z",
      "modified_at": "2025-11-01T15:29:24.436224Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_interface_mode:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:137-167",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_interface_mode",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 137,
        "end": 167
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_interface_mode(matches: &clap::ArgMatches) -> InterfaceMode {\n        let db_path = matches\n            .get_one::<String>(\"database\")\n            .unwrap()\n            .clone();\n\n        // Check which interface mode\n        if let Some(entity_key) = matches.get_one::<String>(\"entity\") {\n            // Simple Interface\n            let action_str = matches.get_one::<String>(\"action\").unwrap();\n            let action = match action_str.as_str() {\n                \"create\" => EntityAction::Create,\n                \"edit\" => EntityAction::Edit,\n                \"delete\" => EntityAction::Delete,\n                _ => unreachable!(\"clap validates this\"),\n            };\n\n            let future_code = matches.get_one::<String>(\"future-code\").cloned();\n\n            InterfaceMode::Simple(SimpleUpdateConfig {\n                entity_key: entity_key.clone(),\n                action,\n                future_code,\n                db_path,\n            })\n        } else {\n            // Advanced Interface\n            let query = matches.get_one::<String>(\"query\").unwrap().clone();\n            InterfaceMode::Advanced(AdvancedQueryConfig { query, db_path })\n        }\n    }",
    "future_code": "    pub fn parse_interface_mode(matches: &clap::ArgMatches) -> InterfaceMode {\n        let db_path = matches\n            .get_one::<String>(\"database\")\n            .unwrap()\n            .clone();\n\n        // Check which interface mode\n        if let Some(entity_key) = matches.get_one::<String>(\"entity\") {\n            // Simple Interface\n            let action_str = matches.get_one::<String>(\"action\").unwrap();\n            let action = match action_str.as_str() {\n                \"create\" => EntityAction::Create,\n                \"edit\" => EntityAction::Edit,\n                \"delete\" => EntityAction::Delete,\n                _ => unreachable!(\"clap validates this\"),\n            };\n\n            let future_code = matches.get_one::<String>(\"future-code\").cloned();\n\n            InterfaceMode::Simple(SimpleUpdateConfig {\n                entity_key: entity_key.clone(),\n                action,\n                future_code,\n                db_path,\n            })\n        } else {\n            // Advanced Interface\n            let query = matches.get_one::<String>(\"query\").unwrap().clone();\n            InterfaceMode::Advanced(AdvancedQueryConfig { query, db_path })\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436225Z",
      "modified_at": "2025-11-01T15:29:24.436225Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_optimization_goals:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:240-255",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_optimization_goals",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 240,
        "end": 255
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn parse_optimization_goals(goals_str: &str) -> Vec<crate::llm_client::OptimizationGoal> {\n        goals_str\n            .split(',')\n            .map(|s| s.trim().to_lowercase())\n            .filter(|s| !s.is_empty())\n            .map(|goal| match goal.as_str() {\n                \"minimize_size\" => crate::llm_client::OptimizationGoal::MinimizeSize,\n                \"maximize_relevance\" => crate::llm_client::OptimizationGoal::MaximizeRelevance,\n                \"preserve_connectivity\" => crate::llm_client::OptimizationGoal::PreserveConnectivity,\n                \"focus_on_types\" => crate::llm_client::OptimizationGoal::FocusOnTypes,\n                \"focus_on_functions\" => crate::llm_client::OptimizationGoal::FocusOnFunctions,\n                \"balance_complexity\" => crate::llm_client::OptimizationGoal::BalanceComplexity,\n                _ => crate::llm_client::OptimizationGoal::MaximizeRelevance, // default fallback\n            })\n            .collect()\n    }",
    "future_code": "    pub fn parse_optimization_goals(goals_str: &str) -> Vec<crate::llm_client::OptimizationGoal> {\n        goals_str\n            .split(',')\n            .map(|s| s.trim().to_lowercase())\n            .filter(|s| !s.is_empty())\n            .map(|goal| match goal.as_str() {\n                \"minimize_size\" => crate::llm_client::OptimizationGoal::MinimizeSize,\n                \"maximize_relevance\" => crate::llm_client::OptimizationGoal::MaximizeRelevance,\n                \"preserve_connectivity\" => crate::llm_client::OptimizationGoal::PreserveConnectivity,\n                \"focus_on_types\" => crate::llm_client::OptimizationGoal::FocusOnTypes,\n                \"focus_on_functions\" => crate::llm_client::OptimizationGoal::FocusOnFunctions,\n                \"balance_complexity\" => crate::llm_client::OptimizationGoal::BalanceComplexity,\n                _ => crate::llm_client::OptimizationGoal::MaximizeRelevance, // default fallback\n            })\n            .collect()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436226Z",
      "modified_at": "2025-11-01T15:29:24.436226Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_response:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:273-294",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_response",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 273,
        "end": 294
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn parse_response(&self, response: &str) -> Result<ContextOptimizationResponse> {\n        // Try to extract JSON from response\n        let json_start = response.find('{').ok_or_else(|| ContextWriterError::ContextGenerationError {\n            entity: \"response\".to_string(),\n            reason: \"No JSON object found in response\".to_string(),\n        })?;\n\n        let json_end = response.rfind('}').ok_or_else(|| ContextWriterError::ContextGenerationError {\n            entity: \"response\".to_string(),\n            reason: \"Unclosed JSON object in response\".to_string(),\n        })?;\n\n        let json_str = &response[json_start..=json_end];\n\n        let optimized_response: ContextOptimizationResponse = serde_json::from_str(json_str)\n            .map_err(|e| ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: format!(\"Invalid JSON: {}\", e),\n            })?;\n\n        Ok(optimized_response)\n    }",
    "future_code": "    fn parse_response(&self, response: &str) -> Result<ContextOptimizationResponse> {\n        // Try to extract JSON from response\n        let json_start = response.find('{').ok_or_else(|| ContextWriterError::ContextGenerationError {\n            entity: \"response\".to_string(),\n            reason: \"No JSON object found in response\".to_string(),\n        })?;\n\n        let json_end = response.rfind('}').ok_or_else(|| ContextWriterError::ContextGenerationError {\n            entity: \"response\".to_string(),\n            reason: \"Unclosed JSON object in response\".to_string(),\n        })?;\n\n        let json_str = &response[json_start..=json_end];\n\n        let optimized_response: ContextOptimizationResponse = serde_json::from_str(json_str)\n            .map_err(|e| ContextWriterError::ContextGenerationError {\n                entity: \"response\".to_string(),\n                reason: format!(\"Invalid JSON: {}\", e),\n            })?;\n\n        Ok(optimized_response)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436228Z",
      "modified_at": "2025-11-01T15:29:24.436228Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parse_source:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:117-139",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parse_source",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 117,
        "end": 139
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn parse_source(&self, source: &str, file_path: &Path) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        let language_type = self.get_language_type(file_path)?;\n\n        let parser_mutex = self.parsers.get(&language_type)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: format!(\"No parser available for language: {:?}\", language_type),\n            })?;\n\n        let mut parser = parser_mutex.lock().unwrap();\n        let tree = parser\n            .parse(source, None)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: \"Failed to parse source code\".to_string(),\n            })?;\n\n        let mut entities = Vec::new();\n        let mut dependencies = Vec::new();\n        self.extract_entities(&tree, source, file_path, language_type, &mut entities, &mut dependencies);\n\n        Ok((entities, dependencies))\n    }",
    "future_code": "    fn parse_source(&self, source: &str, file_path: &Path) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        let language_type = self.get_language_type(file_path)?;\n\n        let parser_mutex = self.parsers.get(&language_type)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: format!(\"No parser available for language: {:?}\", language_type),\n            })?;\n\n        let mut parser = parser_mutex.lock().unwrap();\n        let tree = parser\n            .parse(source, None)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: \"Failed to parse source code\".to_string(),\n            })?;\n\n        let mut entities = Vec::new();\n        let mut dependencies = Vec::new();\n        self.extract_entities(&tree, source, file_path, language_type, &mut entities, &mut dependencies);\n\n        Ok((entities, dependencies))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436229Z",
      "modified_at": "2025-11-01T15:29:24.436229Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:parsed_entity_to_code_entity:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:134-166",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "parsed_entity_to_code_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 134,
        "end": 166
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn parsed_entity_to_code_entity(\n        &self,\n        parsed: &ParsedEntity,\n        isgl1_key: &str,\n        source_code: &str,\n    ) -> std::result::Result<CodeEntity, parseltongue_core::error::ParseltongError> {\n        // Create InterfaceSignature\n        let interface_signature = InterfaceSignature {\n            entity_type: self.convert_entity_type(&parsed.entity_type),\n            name: parsed.name.clone(),\n            visibility: Visibility::Public, // Default to public for now\n            file_path: PathBuf::from(&parsed.file_path),\n            line_range: LineRange::new(parsed.line_range.0 as u32, parsed.line_range.1 as u32)?,\n            module_path: vec![], // TODO: Extract from file path\n            documentation: None,\n            language_specific: self.create_language_signature(&parsed.language),\n        };\n\n        // Create CodeEntity with temporal state initialized to \"unchanged\" (current=true, future=true, action=none)\n        let mut entity = CodeEntity::new(isgl1_key.to_string(), interface_signature)?;\n\n        // Extract the code snippet from the source\n        let code_snippet = self.extract_code_snippet(source_code, parsed.line_range.0, parsed.line_range.1);\n\n        // Set current_code and future_code to the same value (unchanged state)\n        entity.current_code = Some(code_snippet.clone());\n        entity.future_code = Some(code_snippet);\n\n        // GREEN Phase: Apply TDD classification based on parsed metadata\n        entity.tdd_classification = self.classify_entity(parsed);\n\n        Ok(entity)\n    }",
    "future_code": "    fn parsed_entity_to_code_entity(\n        &self,\n        parsed: &ParsedEntity,\n        isgl1_key: &str,\n        source_code: &str,\n    ) -> std::result::Result<CodeEntity, parseltongue_core::error::ParseltongError> {\n        // Create InterfaceSignature\n        let interface_signature = InterfaceSignature {\n            entity_type: self.convert_entity_type(&parsed.entity_type),\n            name: parsed.name.clone(),\n            visibility: Visibility::Public, // Default to public for now\n            file_path: PathBuf::from(&parsed.file_path),\n            line_range: LineRange::new(parsed.line_range.0 as u32, parsed.line_range.1 as u32)?,\n            module_path: vec![], // TODO: Extract from file path\n            documentation: None,\n            language_specific: self.create_language_signature(&parsed.language),\n        };\n\n        // Create CodeEntity with temporal state initialized to \"unchanged\" (current=true, future=true, action=none)\n        let mut entity = CodeEntity::new(isgl1_key.to_string(), interface_signature)?;\n\n        // Extract the code snippet from the source\n        let code_snippet = self.extract_code_snippet(source_code, parsed.line_range.0, parsed.line_range.1);\n\n        // Set current_code and future_code to the same value (unchanged state)\n        entity.current_code = Some(code_snippet.clone());\n        entity.future_code = Some(code_snippet);\n\n        // GREEN Phase: Apply TDD classification based on parsed metadata\n        entity.tdd_classification = self.classify_entity(parsed);\n\n        Ok(entity)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436230Z",
      "modified_at": "2025-11-01T15:29:24.436230Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_usage:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:104-108",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_usage",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 104,
        "end": 108
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "future_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436231Z",
      "modified_at": "2025-11-01T15:29:24.436231Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_usage:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:264-268",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_usage",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 264,
        "end": 268
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "future_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436232Z",
      "modified_at": "2025-11-01T15:29:24.436232Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_usage:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:170-174",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_usage",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 170,
        "end": 174
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "future_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436233Z",
      "modified_at": "2025-11-01T15:29:24.436233Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_version:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:111-113",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_version",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 111,
        "end": 113
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_version() {\n        println!(\"parseltongue-01 version 0.7.1\");\n    }",
    "future_code": "    pub fn print_version() {\n        println!(\"parseltongue-01 version 0.7.1\");\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436234Z",
      "modified_at": "2025-11-01T15:29:24.436234Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_version:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:271-273",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_version",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 271,
        "end": 273
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_version() {\n        println!(\"parseltongue-03 version 0.7.1\");\n    }",
    "future_code": "    pub fn print_version() {\n        println!(\"parseltongue-03 version 0.7.1\");\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436235Z",
      "modified_at": "2025-11-01T15:29:24.436235Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:print_version:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:177-179",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "print_version",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 177,
        "end": 179
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn print_version() {\n        println!(\"parseltongue-02 version 0.7.1\");\n    }",
    "future_code": "    pub fn print_version() {\n        println!(\"parseltongue-02 version 0.7.1\");\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436236Z",
      "modified_at": "2025-11-01T15:29:24.436236Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:query_entities:______crates_parseltongue-core_src_storage_cozo_client_rs:1153-1157",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "query_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1153,
        "end": 1157
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn query_entities(&self, _query: &TemporalQuery) -> Result<Vec<CodeEntity>> {\n        // Simplified implementation for MVP\n        // Full query support to be added later\n        Ok(Vec::new())\n    }",
    "future_code": "    async fn query_entities(&self, _query: &TemporalQuery) -> Result<Vec<CodeEntity>> {\n        // Simplified implementation for MVP\n        // Full query support to be added later\n        Ok(Vec::new())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436238Z",
      "modified_at": "2025-11-01T15:29:24.436238Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:query_entity_graph:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:231-256",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "query_entity_graph",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 231,
        "end": 256
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn query_entity_graph(&self) -> Result<ContextGraph> {\n        // TODO: Implement actual database query\n        // For now, return sample graph for testing\n        let sample_entities = self.create_sample_entities()?;\n        let sample_relationships = self.create_sample_relationships(&sample_entities);\n\n        let centrality_scores = self.calculate_centrality_scores(&sample_entities, &sample_relationships);\n        let connectivity_clusters = self.identify_connectivity_clusters(&sample_entities, &sample_relationships);\n\n        let metadata = GraphMetadata {\n            total_entities: sample_entities.len(),\n            total_relationships: sample_relationships.len(),\n            graph_density: self.calculate_graph_density(&sample_entities, &sample_relationships),\n            average_degree: self.calculate_average_degree(&sample_entities, &sample_relationships),\n            max_centrality: centrality_scores.values().cloned().fold(0.0, f32::max),\n            analysis_timestamp: std::time::SystemTime::now(),\n        };\n\n        Ok(ContextGraph {\n            entities: sample_entities,\n            relationships: sample_relationships,\n            centrality_scores,\n            connectivity_clusters,\n            metadata,\n        })\n    }",
    "future_code": "    async fn query_entity_graph(&self) -> Result<ContextGraph> {\n        // TODO: Implement actual database query\n        // For now, return sample graph for testing\n        let sample_entities = self.create_sample_entities()?;\n        let sample_relationships = self.create_sample_relationships(&sample_entities);\n\n        let centrality_scores = self.calculate_centrality_scores(&sample_entities, &sample_relationships);\n        let connectivity_clusters = self.identify_connectivity_clusters(&sample_entities, &sample_relationships);\n\n        let metadata = GraphMetadata {\n            total_entities: sample_entities.len(),\n            total_relationships: sample_relationships.len(),\n            graph_density: self.calculate_graph_density(&sample_entities, &sample_relationships),\n            average_degree: self.calculate_average_degree(&sample_entities, &sample_relationships),\n            max_centrality: centrality_scores.values().cloned().fold(0.0, f32::max),\n            analysis_timestamp: std::time::SystemTime::now(),\n        };\n\n        Ok(ContextGraph {\n            entities: sample_entities,\n            relationships: sample_relationships,\n            centrality_scores,\n            connectivity_clusters,\n            metadata,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436239Z",
      "modified_at": "2025-11-01T15:29:24.436239Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:read_file_content:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:284-316",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "read_file_content",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 284,
        "end": 316
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn read_file_content(&self, file_path: &Path) -> Result<String> {\n        let metadata = fs::metadata(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        if metadata.len() as usize > self.config.max_file_size {\n            return Err(StreamerError::FileTooLarge {\n                path: file_path.to_string_lossy().to_string(),\n                size: metadata.len() as usize,\n                limit: self.config.max_file_size,\n            });\n        }\n\n        let mut content = String::new();\n        let mut file = fs::File::open(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        file.read_to_string(&mut content).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        Ok(content)\n    }",
    "future_code": "    async fn read_file_content(&self, file_path: &Path) -> Result<String> {\n        let metadata = fs::metadata(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        if metadata.len() as usize > self.config.max_file_size {\n            return Err(StreamerError::FileTooLarge {\n                path: file_path.to_string_lossy().to_string(),\n                size: metadata.len() as usize,\n                limit: self.config.max_file_size,\n            });\n        }\n\n        let mut content = String::new();\n        let mut file = fs::File::open(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        file.read_to_string(&mut content).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        Ok(content)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436240Z",
      "modified_at": "2025-11-01T15:29:24.436240Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:recovery_action_default_is_sensible:______crates_parseltongue-core_src_error_rs:200-203",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "recovery_action_default_is_sensible",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 200,
        "end": 203
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn recovery_action_default_is_sensible() {\n        let default_action = RecoveryAction::default();\n        assert!(matches!(default_action, RecoveryAction::RetryWithBackoff(_)));\n    }",
    "future_code": "    fn recovery_action_default_is_sensible() {\n        let default_action = RecoveryAction::default();\n        assert!(matches!(default_action, RecoveryAction::RetryWithBackoff(_)));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436241Z",
      "modified_at": "2025-11-01T15:29:24.436241Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:recreate_schema:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:63-68",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "recreate_schema",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 63,
        "end": 68
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn recreate_schema(&self) -> Result<()> {\n        // GREEN phase: Schema already exists, no need to recreate\n        // CozoDB doesn't support DROP TABLE, we just deleted all entities\n        // Schema structure remains valid\n        Ok(())\n    }",
    "future_code": "    async fn recreate_schema(&self) -> Result<()> {\n        // GREEN phase: Schema already exists, no need to recreate\n        // CozoDB doesn't support DROP TABLE, we just deleted all entities\n        // Schema structure remains valid\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436242Z",
      "modified_at": "2025-11-01T15:29:24.436242Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:reset:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:26-41",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "reset",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 26,
        "end": 41
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn reset(&self, _project_path: &Path) -> Result<ResetResult> {\n        // Count entities before deletion (for reporting)\n        let entities_before = self.storage.get_all_entities().await?;\n        let entities_deleted = entities_before.len();\n\n        // Delete all entities (NO backups - ultra-minimalist)\n        self.delete_table().await?;\n\n        // Recreate schema\n        self.recreate_schema().await?;\n\n        // Note: Re-indexing (Tool 1 integration) would happen externally\n        // Tool 6 just resets the state, doesn't trigger indexing itself\n\n        Ok(ResetResult::success(entities_deleted))\n    }",
    "future_code": "    pub async fn reset(&self, _project_path: &Path) -> Result<ResetResult> {\n        // Count entities before deletion (for reporting)\n        let entities_before = self.storage.get_all_entities().await?;\n        let entities_deleted = entities_before.len();\n\n        // Delete all entities (NO backups - ultra-minimalist)\n        self.delete_table().await?;\n\n        // Recreate schema\n        self.recreate_schema().await?;\n\n        // Note: Re-indexing (Tool 1 integration) would happen externally\n        // Tool 6 just resets the state, doesn't trigger indexing itself\n\n        Ok(ResetResult::success(entities_deleted))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436243Z",
      "modified_at": "2025-11-01T15:29:24.436243Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:reset_temporal_state:______crates_parseltongue-core_src_storage_cozo_client_rs:1163-1198",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "reset_temporal_state",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1163,
        "end": 1198
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn reset_temporal_state(&mut self) -> Result<()> {\n        // Get all changed entities\n        let changed = self.get_changed_entities().await?;\n\n        for entity in changed {\n            let mut updated_entity = entity.clone();\n\n            // Apply temporal changes to current state\n            match updated_entity.temporal_state.future_action {\n                Some(TemporalAction::Create) => {\n                    // New entity becomes current\n                    updated_entity.temporal_state.current_ind = true;\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Edit) => {\n                    // Apply edit\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Delete) => {\n                    // Delete entity\n                    self.delete_entity(&entity.isgl1_key).await?;\n                    continue;\n                }\n                None => {}\n            }\n\n            // Reset temporal indicators\n            updated_entity.temporal_state.future_ind = updated_entity.temporal_state.current_ind;\n            updated_entity.temporal_state.future_action = None;\n            updated_entity.future_code = None;\n\n            self.update_entity_internal(&updated_entity).await?;\n        }\n\n        Ok(())\n    }",
    "future_code": "    async fn reset_temporal_state(&mut self) -> Result<()> {\n        // Get all changed entities\n        let changed = self.get_changed_entities().await?;\n\n        for entity in changed {\n            let mut updated_entity = entity.clone();\n\n            // Apply temporal changes to current state\n            match updated_entity.temporal_state.future_action {\n                Some(TemporalAction::Create) => {\n                    // New entity becomes current\n                    updated_entity.temporal_state.current_ind = true;\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Edit) => {\n                    // Apply edit\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Delete) => {\n                    // Delete entity\n                    self.delete_entity(&entity.isgl1_key).await?;\n                    continue;\n                }\n                None => {}\n            }\n\n            // Reset temporal indicators\n            updated_entity.temporal_state.future_ind = updated_entity.temporal_state.current_ind;\n            updated_entity.temporal_state.future_action = None;\n            updated_entity.future_code = None;\n\n            self.update_entity_internal(&updated_entity).await?;\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436244Z",
      "modified_at": "2025-11-01T15:29:24.436244Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:reset_temporal_state:______crates_parseltongue-core_src_temporal_rs:85-121",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "reset_temporal_state",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 85,
        "end": 121
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn reset_temporal_state(&mut self) -> Result<usize> {\n        let mut reset_count = 0;\n\n        for entity in self.entities.values_mut() {\n            if entity.is_modified() {\n                // Apply temporal state changes\n                match &entity.temporal_state.future_action {\n                    Some(TemporalAction::Create) => {\n                        // New entity becomes current\n                        entity.temporal_state.current_ind = true;\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Edit) => {\n                        // Apply edit\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Delete) => {\n                        // Mark for deletion (will be removed by caller)\n                        entity.temporal_state.current_ind = false;\n                    }\n                    None => {}\n                }\n\n                // Reset temporal indicators\n                entity.temporal_state.future_ind = entity.temporal_state.current_ind;\n                entity.temporal_state.future_action = None;\n                entity.future_code = None;\n\n                reset_count += 1;\n            }\n        }\n\n        // Remove deleted entities\n        self.entities.retain(|_, entity| entity.temporal_state.current_ind);\n\n        Ok(reset_count)\n    }",
    "future_code": "    pub fn reset_temporal_state(&mut self) -> Result<usize> {\n        let mut reset_count = 0;\n\n        for entity in self.entities.values_mut() {\n            if entity.is_modified() {\n                // Apply temporal state changes\n                match &entity.temporal_state.future_action {\n                    Some(TemporalAction::Create) => {\n                        // New entity becomes current\n                        entity.temporal_state.current_ind = true;\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Edit) => {\n                        // Apply edit\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Delete) => {\n                        // Mark for deletion (will be removed by caller)\n                        entity.temporal_state.current_ind = false;\n                    }\n                    None => {}\n                }\n\n                // Reset temporal indicators\n                entity.temporal_state.future_ind = entity.temporal_state.current_ind;\n                entity.temporal_state.future_action = None;\n                entity.future_code = None;\n\n                reset_count += 1;\n            }\n        }\n\n        // Remove deleted entities\n        self.entities.retain(|_, entity| entity.temporal_state.current_ind);\n\n        Ok(reset_count)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436245Z",
      "modified_at": "2025-11-01T15:29:24.436245Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:resolve_conflicts:______crates_parseltongue-core_src_temporal_rs:498-524",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "resolve_conflicts",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 498,
        "end": 524
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn resolve_conflicts(&self, changes: Vec<TemporalChange>) -> Result<Vec<TemporalChange>> {\n        let conflicts = self.detect_conflicts(&changes);\n\n        if conflicts.is_empty() {\n            return Ok(changes);\n        }\n\n        match self.strategy {\n            ConflictResolutionStrategy::FailFast => {\n                Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Conflicts detected: {:?}\",\n                        conflicts\n                    ),\n                })\n            }\n            ConflictResolutionStrategy::UseLatest => {\n                self.resolve_with_latest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::UseEarliest => {\n                self.resolve_with_earliest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::AttemptMerge => {\n                self.attempt_merge(changes, conflicts)\n            }\n        }\n    }",
    "future_code": "    pub fn resolve_conflicts(&self, changes: Vec<TemporalChange>) -> Result<Vec<TemporalChange>> {\n        let conflicts = self.detect_conflicts(&changes);\n\n        if conflicts.is_empty() {\n            return Ok(changes);\n        }\n\n        match self.strategy {\n            ConflictResolutionStrategy::FailFast => {\n                Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Conflicts detected: {:?}\",\n                        conflicts\n                    ),\n                })\n            }\n            ConflictResolutionStrategy::UseLatest => {\n                self.resolve_with_latest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::UseEarliest => {\n                self.resolve_with_earliest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::AttemptMerge => {\n                self.attempt_merge(changes, conflicts)\n            }\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436246Z",
      "modified_at": "2025-11-01T15:29:24.436246Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:resolve_file_path:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:90-107",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "resolve_file_path",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 90,
        "end": 107
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn resolve_file_path(&self, isgl1_key: &str) -> Result<PathBuf, FileWriterError> {\n        // GREEN phase: Simple string parsing\n        // Format: filepath-filename-rs-EntityName\n        // Example: \"src-models-rs-User\"  \"src/models.rs\"\n\n        // Find last occurrence of \"-rs-\" to separate path from entity name\n        let rs_marker = \"-rs-\";\n        let pos = isgl1_key.rfind(rs_marker)\n            .ok_or_else(|| FileWriterError::invalid_isgl1_key(isgl1_key.to_string()))?;\n\n        // Extract path part (everything before \"-rs-\")\n        let path_part = &isgl1_key[..pos];\n\n        // Convert hyphens to path separators and add .rs extension\n        let file_path = path_part.replace('-', \"/\") + \".rs\";\n\n        Ok(self.root_path.join(file_path))\n    }",
    "future_code": "    fn resolve_file_path(&self, isgl1_key: &str) -> Result<PathBuf, FileWriterError> {\n        // GREEN phase: Simple string parsing\n        // Format: filepath-filename-rs-EntityName\n        // Example: \"src-models-rs-User\"  \"src/models.rs\"\n\n        // Find last occurrence of \"-rs-\" to separate path from entity name\n        let rs_marker = \"-rs-\";\n        let pos = isgl1_key.rfind(rs_marker)\n            .ok_or_else(|| FileWriterError::invalid_isgl1_key(isgl1_key.to_string()))?;\n\n        // Extract path part (everything before \"-rs-\")\n        let path_part = &isgl1_key[..pos];\n\n        // Convert hyphens to path separators and add .rs extension\n        let file_path = path_part.replace('-', \"/\") + \".rs\";\n\n        Ok(self.root_path.join(file_path))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436247Z",
      "modified_at": "2025-11-01T15:29:24.436247Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:resolve_with_earliest:______crates_parseltongue-core_src_temporal_rs:543-558",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "resolve_with_earliest",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 543,
        "end": 558
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn resolve_with_earliest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the first change\n                for i in 1..conflicting_changes.len() {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
    "future_code": "    fn resolve_with_earliest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the first change\n                for i in 1..conflicting_changes.len() {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436248Z",
      "modified_at": "2025-11-01T15:29:24.436248Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:resolve_with_latest:______crates_parseltongue-core_src_temporal_rs:526-541",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "resolve_with_latest",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 526,
        "end": 541
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn resolve_with_latest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the last change\n                for i in 0..conflicting_changes.len() - 1 {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
    "future_code": "    fn resolve_with_latest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the last change\n                for i in 0..conflicting_changes.len() - 1 {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436249Z",
      "modified_at": "2025-11-01T15:29:24.436249Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:row_to_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:981-1127",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "row_to_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 981,
        "end": 1127
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn row_to_entity(&self, row: &[DataValue]) -> Result<CodeEntity> {\n        if row.len() < 13 {\n            return Err(ParseltongError::DatabaseError {\n                operation: \"row_to_entity\".to_string(),\n                details: format!(\"Invalid row length: expected 13, got {}\", row.len()),\n            });\n        }\n\n        // Extract ISGL1 key\n        let isgl1_key = match &row[0] {\n            DataValue::Str(s) => s.to_string(),\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"ISGL1_key is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Extract current_code\n        let current_code = match &row[1] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Current_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract future_code\n        let future_code = match &row[2] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize interface_signature\n        let interface_signature: InterfaceSignature = match &row[3] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize interface_signature: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"interface_signature is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize TDD_Classification\n        let tdd_classification: TddClassification = match &row[4] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize TDD_Classification: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"TDD_Classification is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize lsp_meta_data\n        let lsp_metadata: Option<LspMetadata> = match &row[5] {\n            DataValue::Str(s) => Some(serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize lsp_meta_data: {}\", e),\n                }\n            })?),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"lsp_meta_data has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract temporal state\n        let current_ind = match &row[6] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"current_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_ind = match &row[7] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"future_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_action = match &row[8] {\n            DataValue::Str(s) => Some(match s.as_ref() {\n                \"Create\" => TemporalAction::Create,\n                \"Edit\" => TemporalAction::Edit,\n                \"Delete\" => TemporalAction::Delete,\n                _ => {\n                    return Err(ParseltongError::DatabaseError {\n                        operation: \"row_to_entity\".to_string(),\n                        details: format!(\"Invalid Future_Action value: {}\", s),\n                    })\n                }\n            }),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Action has invalid type\".to_string(),\n                })\n            }\n        };\n\n        let temporal_state = TemporalState {\n            current_ind,\n            future_ind,\n            future_action,\n        };\n\n        // Build CodeEntity\n        let mut entity = CodeEntity::new(isgl1_key, interface_signature)?;\n        entity.current_code = current_code;\n        entity.future_code = future_code;\n        entity.temporal_state = temporal_state;\n        entity.tdd_classification = tdd_classification;\n        entity.lsp_metadata = lsp_metadata;\n\n        Ok(entity)\n    }",
    "future_code": "    fn row_to_entity(&self, row: &[DataValue]) -> Result<CodeEntity> {\n        if row.len() < 13 {\n            return Err(ParseltongError::DatabaseError {\n                operation: \"row_to_entity\".to_string(),\n                details: format!(\"Invalid row length: expected 13, got {}\", row.len()),\n            });\n        }\n\n        // Extract ISGL1 key\n        let isgl1_key = match &row[0] {\n            DataValue::Str(s) => s.to_string(),\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"ISGL1_key is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Extract current_code\n        let current_code = match &row[1] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Current_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract future_code\n        let future_code = match &row[2] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize interface_signature\n        let interface_signature: InterfaceSignature = match &row[3] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize interface_signature: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"interface_signature is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize TDD_Classification\n        let tdd_classification: TddClassification = match &row[4] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize TDD_Classification: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"TDD_Classification is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize lsp_meta_data\n        let lsp_metadata: Option<LspMetadata> = match &row[5] {\n            DataValue::Str(s) => Some(serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize lsp_meta_data: {}\", e),\n                }\n            })?),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"lsp_meta_data has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract temporal state\n        let current_ind = match &row[6] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"current_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_ind = match &row[7] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"future_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_action = match &row[8] {\n            DataValue::Str(s) => Some(match s.as_ref() {\n                \"Create\" => TemporalAction::Create,\n                \"Edit\" => TemporalAction::Edit,\n                \"Delete\" => TemporalAction::Delete,\n                _ => {\n                    return Err(ParseltongError::DatabaseError {\n                        operation: \"row_to_entity\".to_string(),\n                        details: format!(\"Invalid Future_Action value: {}\", s),\n                    })\n                }\n            }),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Action has invalid type\".to_string(),\n                })\n            }\n        };\n\n        let temporal_state = TemporalState {\n            current_ind,\n            future_ind,\n            future_action,\n        };\n\n        // Build CodeEntity\n        let mut entity = CodeEntity::new(isgl1_key, interface_signature)?;\n        entity.current_code = current_code;\n        entity.future_code = future_code;\n        entity.temporal_state = temporal_state;\n        entity.tdd_classification = tdd_classification;\n        entity.lsp_metadata = lsp_metadata;\n\n        Ok(entity)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436251Z",
      "modified_at": "2025-11-01T15:29:24.436251Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_cozodb_make_future_code_current:______crates_parseltongue_src_main_rs:529-562",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_cozodb_make_future_code_current",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 529,
        "end": 562
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_cozodb_make_future_code_current(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt06_cozodb_make_future_code_current::StateResetManager;\n    use std::path::Path;\n\n    let project = matches.get_one::<String>(\"project\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 6: pt06-cozodb-make-future-code-current\").cyan());\n    println!(\"  Project: {}\", project);\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create state reset manager\n    let reset_manager = StateResetManager::new(storage);\n\n    // Reset database state (delete all entities, recreate schema)\n    let result = reset_manager.reset(Path::new(project))\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to reset database state: {}\", e))?;\n\n    println!(\"{}\", style(\" Database reset completed\").green().bold());\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { \"yes\" } else { \"no\" });\n    println!();\n    println!(\"{}\", style(\"Next step: Re-index the codebase\").cyan());\n    println!(\"  Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\", project, db);\n\n    Ok(())\n}",
    "future_code": "async fn run_cozodb_make_future_code_current(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt06_cozodb_make_future_code_current::StateResetManager;\n    use std::path::Path;\n\n    let project = matches.get_one::<String>(\"project\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 6: pt06-cozodb-make-future-code-current\").cyan());\n    println!(\"  Project: {}\", project);\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create state reset manager\n    let reset_manager = StateResetManager::new(storage);\n\n    // Reset database state (delete all entities, recreate schema)\n    let result = reset_manager.reset(Path::new(project))\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to reset database state: {}\", e))?;\n\n    println!(\"{}\", style(\" Database reset completed\").green().bold());\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { \"yes\" } else { \"no\" });\n    println!();\n    println!(\"{}\", style(\"Next step: Re-index the codebase\").cyan());\n    println!(\"  Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\", project, db);\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436252Z",
      "modified_at": "2025-11-01T15:29:24.436252Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_folder_to_cozodb_streamer:______crates_parseltongue_src_main_rs:205-247",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_folder_to_cozodb_streamer",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 205,
        "end": 247
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_folder_to_cozodb_streamer(matches: &ArgMatches) -> Result<()> {\n    let directory = matches.get_one::<String>(\"directory\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n    let quiet = matches.get_flag(\"quiet\");\n\n    println!(\"{}\", style(\"Running Tool 1: folder-to-cozodb-streamer\").cyan());\n\n    // Create config (S01 ultra-minimalist: let tree-sitter decide what to parse)\n    let config = pt01_folder_to_cozodb_streamer::StreamerConfig {\n        root_dir: std::path::PathBuf::from(directory),\n        db_path: db.clone(),\n        max_file_size: 100 * 1024 * 1024,  // 100MB - no artificial limits\n        include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n        exclude_patterns: vec![\n            \"target\".to_string(),\n            \"node_modules\".to_string(),\n            \".git\".to_string(),\n            \"build\".to_string(),\n            \"dist\".to_string(),\n            \"__pycache__\".to_string(),\n            \".venv\".to_string(),\n            \"venv\".to_string(),\n        ],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Create and run streamer\n    let streamer = pt01_folder_to_cozodb_streamer::ToolFactory::create_streamer(config.clone()).await?;\n    let result = streamer.stream_directory().await?;\n\n    if !quiet {\n        println!(\"{}\", style(\" Indexing completed\").green().bold());\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        if verbose {\n            println!(\"  Duration: {:?}\", result.duration);\n        }\n    }\n\n    Ok(())\n}",
    "future_code": "async fn run_folder_to_cozodb_streamer(matches: &ArgMatches) -> Result<()> {\n    let directory = matches.get_one::<String>(\"directory\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n    let quiet = matches.get_flag(\"quiet\");\n\n    println!(\"{}\", style(\"Running Tool 1: folder-to-cozodb-streamer\").cyan());\n\n    // Create config (S01 ultra-minimalist: let tree-sitter decide what to parse)\n    let config = pt01_folder_to_cozodb_streamer::StreamerConfig {\n        root_dir: std::path::PathBuf::from(directory),\n        db_path: db.clone(),\n        max_file_size: 100 * 1024 * 1024,  // 100MB - no artificial limits\n        include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n        exclude_patterns: vec![\n            \"target\".to_string(),\n            \"node_modules\".to_string(),\n            \".git\".to_string(),\n            \"build\".to_string(),\n            \"dist\".to_string(),\n            \"__pycache__\".to_string(),\n            \".venv\".to_string(),\n            \"venv\".to_string(),\n        ],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Create and run streamer\n    let streamer = pt01_folder_to_cozodb_streamer::ToolFactory::create_streamer(config.clone()).await?;\n    let result = streamer.stream_directory().await?;\n\n    if !quiet {\n        println!(\"{}\", style(\" Indexing completed\").green().bold());\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        if verbose {\n            println!(\"  Duration: {:?}\", result.duration);\n        }\n    }\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436253Z",
      "modified_at": "2025-11-01T15:29:24.436253Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_llm_cozodb_to_context_writer:______crates_parseltongue_src_main_rs:331-380",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_llm_cozodb_to_context_writer",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 331,
        "end": 380
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_llm_cozodb_to_context_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use std::io::Write;\n\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let filter = matches.get_one::<String>(\"filter\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 2: pt02-llm-cozodb-to-context-writer\").cyan());\n    println!(\"  Database: {}\", db);\n    println!(\"  Filter: {}\", filter);\n    println!(\"  Output: {}\", output);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Fetch entities based on filter\n    let entities = match filter.as_str() {\n        \"all\" => storage.get_all_entities().await?,\n        \"changed\" => storage.get_changed_entities().await?,\n        \"current\" => {\n            // For MVP: \"current\" means entities where current_ind=true\n            storage.get_all_entities().await?\n                .into_iter()\n                .filter(|e| e.temporal_state.current_ind)\n                .collect()\n        }\n        _ => unreachable!(\"clap validation should prevent this\"),\n    };\n\n    println!(\"  Found {} entities\", entities.len());\n\n    // Write to JSON file\n    let json = serde_json::to_string_pretty(&entities)\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize entities: {}\", e))?;\n\n    let mut file = std::fs::File::create(output)\n        .map_err(|e| anyhow::anyhow!(\"Failed to create output file: {}\", e))?;\n\n    file.write_all(json.as_bytes())\n        .map_err(|e| anyhow::anyhow!(\"Failed to write to file: {}\", e))?;\n\n    println!(\"{}\", style(\" Context JSON written\").green());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Entities exported: {}\", entities.len());\n\n    Ok(())\n}",
    "future_code": "async fn run_llm_cozodb_to_context_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use std::io::Write;\n\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let filter = matches.get_one::<String>(\"filter\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 2: pt02-llm-cozodb-to-context-writer\").cyan());\n    println!(\"  Database: {}\", db);\n    println!(\"  Filter: {}\", filter);\n    println!(\"  Output: {}\", output);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Fetch entities based on filter\n    let entities = match filter.as_str() {\n        \"all\" => storage.get_all_entities().await?,\n        \"changed\" => storage.get_changed_entities().await?,\n        \"current\" => {\n            // For MVP: \"current\" means entities where current_ind=true\n            storage.get_all_entities().await?\n                .into_iter()\n                .filter(|e| e.temporal_state.current_ind)\n                .collect()\n        }\n        _ => unreachable!(\"clap validation should prevent this\"),\n    };\n\n    println!(\"  Found {} entities\", entities.len());\n\n    // Write to JSON file\n    let json = serde_json::to_string_pretty(&entities)\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize entities: {}\", e))?;\n\n    let mut file = std::fs::File::create(output)\n        .map_err(|e| anyhow::anyhow!(\"Failed to create output file: {}\", e))?;\n\n    file.write_all(json.as_bytes())\n        .map_err(|e| anyhow::anyhow!(\"Failed to write to file: {}\", e))?;\n\n    println!(\"{}\", style(\" Context JSON written\").green());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Entities exported: {}\", entities.len());\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436254Z",
      "modified_at": "2025-11-01T15:29:24.436254Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_llm_cozodb_to_diff_writer:______crates_parseltongue_src_main_rs:467-527",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_llm_cozodb_to_diff_writer",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 467,
        "end": 527
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_llm_cozodb_to_diff_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt05_llm_cozodb_to_diff_writer::DiffGenerator;\n    use std::sync::Arc;\n\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 5: pt05-llm-cozodb-to-diff-writer\").cyan());\n    println!(\"  Database: {}\", db);\n    println!(\"  Output: {}\", output);\n\n    // Connect to database\n    let storage = Arc::new(\n        CozoDbStorage::new(db)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?\n    );\n\n    // Create diff generator with dependency injection\n    let generator = DiffGenerator::new(storage);\n\n    // Generate CodeDiff from changed entities\n    let diff = generator.generate_diff()\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to generate diff: {}\", e))?;\n\n    if diff.changes.is_empty() {\n        println!(\"{}\", style(\" No changes found in database\").yellow());\n        return Ok(());\n    }\n\n    // Serialize to JSON\n    let json = diff.to_json_pretty()\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize diff to JSON: {}\", e))?;\n\n    // Write to file\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write to file: {}\", e))?;\n\n    println!(\"{}\", style(\" CodeDiff.json generated\").green());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Changes included: {}\", diff.changes.len());\n\n    // Print summary by operation\n    let mut creates = 0;\n    let mut edits = 0;\n    let mut deletes = 0;\n    for change in &diff.changes {\n        match change.operation {\n            pt05_llm_cozodb_to_diff_writer::Operation::Create => creates += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Edit => edits += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Delete => deletes += 1,\n        }\n    }\n    println!(\"    Creates: {}\", creates);\n    println!(\"    Edits: {}\", edits);\n    println!(\"    Deletes: {}\", deletes);\n\n    Ok(())\n}",
    "future_code": "async fn run_llm_cozodb_to_diff_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt05_llm_cozodb_to_diff_writer::DiffGenerator;\n    use std::sync::Arc;\n\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 5: pt05-llm-cozodb-to-diff-writer\").cyan());\n    println!(\"  Database: {}\", db);\n    println!(\"  Output: {}\", output);\n\n    // Connect to database\n    let storage = Arc::new(\n        CozoDbStorage::new(db)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?\n    );\n\n    // Create diff generator with dependency injection\n    let generator = DiffGenerator::new(storage);\n\n    // Generate CodeDiff from changed entities\n    let diff = generator.generate_diff()\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to generate diff: {}\", e))?;\n\n    if diff.changes.is_empty() {\n        println!(\"{}\", style(\" No changes found in database\").yellow());\n        return Ok(());\n    }\n\n    // Serialize to JSON\n    let json = diff.to_json_pretty()\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize diff to JSON: {}\", e))?;\n\n    // Write to file\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write to file: {}\", e))?;\n\n    println!(\"{}\", style(\" CodeDiff.json generated\").green());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Changes included: {}\", diff.changes.len());\n\n    // Print summary by operation\n    let mut creates = 0;\n    let mut edits = 0;\n    let mut deletes = 0;\n    for change in &diff.changes {\n        match change.operation {\n            pt05_llm_cozodb_to_diff_writer::Operation::Create => creates += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Edit => edits += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Delete => deletes += 1,\n        }\n    }\n    println!(\"    Creates: {}\", creates);\n    println!(\"    Edits: {}\", edits);\n    println!(\"    Deletes: {}\", deletes);\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436256Z",
      "modified_at": "2025-11-01T15:29:24.436256Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_llm_to_cozodb_writer:______crates_parseltongue_src_main_rs:249-329",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_llm_to_cozodb_writer",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 249,
        "end": 329
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_llm_to_cozodb_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use parseltongue_core::entities::TemporalAction;\n\n    let entity_key = matches.get_one::<String>(\"entity\").unwrap();\n    let action = matches.get_one::<String>(\"action\").unwrap();\n    let future_code = matches.get_one::<String>(\"future-code\");\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 3: pt03-llm-to-cozodb-writer\").cyan());\n\n    // Validate future-code requirement\n    if (action == \"create\" || action == \"edit\") && future_code.is_none() {\n        eprintln!(\"{}\", style(\"Error: --future-code required for create/edit actions\").red());\n        std::process::exit(1);\n    }\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Process action\n    match action.as_str() {\n        \"create\" => {\n            println!(\"  Creating entity: {}\", entity_key);\n            println!(\"  Future code: {} bytes\", future_code.unwrap().len());\n            // For MVP: creating new entity requires full entity data structure\n            // This is a simplified implementation - in practice, you'd parse the ISGL1 key\n            // and construct a proper CodeEntity\n            eprintln!(\"{}\", style(\"  CREATE action requires full entity construction - not yet implemented\").yellow());\n            eprintln!(\"    Hint: First index the codebase, then use EDIT to modify entities\");\n        }\n        \"edit\" => {\n            println!(\"  Editing entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Update future_code\n            entity.future_code = Some(future_code.unwrap().clone());\n\n            // Set temporal action\n            entity.temporal_state.future_action = Some(TemporalAction::Edit);\n            entity.temporal_state.future_ind = true;\n\n            // Persist updated entity back to database\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to persist entity changes: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity updated with future code\").green());\n            println!(\"  Temporal state: Edit pending (future_ind=true)\");\n        }\n        \"delete\" => {\n            println!(\"  Deleting entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Mark for deletion via temporal state\n            entity.temporal_state.future_ind = false;\n            entity.temporal_state.future_action = Some(TemporalAction::Delete);\n\n            // Persist updated entity\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to mark for deletion: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity marked for deletion\").green());\n            println!(\"  Temporal state: Delete pending (future_ind=false)\");\n        }\n        _ => unreachable!(\"clap validation should prevent this\"),\n    }\n\n    Ok(())\n}",
    "future_code": "async fn run_llm_to_cozodb_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use parseltongue_core::entities::TemporalAction;\n\n    let entity_key = matches.get_one::<String>(\"entity\").unwrap();\n    let action = matches.get_one::<String>(\"action\").unwrap();\n    let future_code = matches.get_one::<String>(\"future-code\");\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 3: pt03-llm-to-cozodb-writer\").cyan());\n\n    // Validate future-code requirement\n    if (action == \"create\" || action == \"edit\") && future_code.is_none() {\n        eprintln!(\"{}\", style(\"Error: --future-code required for create/edit actions\").red());\n        std::process::exit(1);\n    }\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Process action\n    match action.as_str() {\n        \"create\" => {\n            println!(\"  Creating entity: {}\", entity_key);\n            println!(\"  Future code: {} bytes\", future_code.unwrap().len());\n            // For MVP: creating new entity requires full entity data structure\n            // This is a simplified implementation - in practice, you'd parse the ISGL1 key\n            // and construct a proper CodeEntity\n            eprintln!(\"{}\", style(\"  CREATE action requires full entity construction - not yet implemented\").yellow());\n            eprintln!(\"    Hint: First index the codebase, then use EDIT to modify entities\");\n        }\n        \"edit\" => {\n            println!(\"  Editing entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Update future_code\n            entity.future_code = Some(future_code.unwrap().clone());\n\n            // Set temporal action\n            entity.temporal_state.future_action = Some(TemporalAction::Edit);\n            entity.temporal_state.future_ind = true;\n\n            // Persist updated entity back to database\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to persist entity changes: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity updated with future code\").green());\n            println!(\"  Temporal state: Edit pending (future_ind=true)\");\n        }\n        \"delete\" => {\n            println!(\"  Deleting entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Mark for deletion via temporal state\n            entity.temporal_state.future_ind = false;\n            entity.temporal_state.future_action = Some(TemporalAction::Delete);\n\n            // Persist updated entity\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to mark for deletion: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity marked for deletion\").green());\n            println!(\"  Temporal state: Delete pending (future_ind=false)\");\n        }\n        _ => unreachable!(\"clap validation should prevent this\"),\n    }\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436257Z",
      "modified_at": "2025-11-01T15:29:24.436257Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_optimizer:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:93-180",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_optimizer",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 93,
        "end": 180
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_optimizer(\n    config: &ContextWriterConfig,\n    matches: &clap::ArgMatches,\n    verbose: bool,\n    quiet: bool,\n    dry_run: bool,\n) -> Result<ContextResult, ContextWriterError> {\n    // Create optimizer instance using async factory (with dependency injection)\n    let optimizer = ToolFactory::create_context_optimizer(config.clone()).await?;\n\n    if verbose && !quiet {\n        println!(\"Configuration:\");\n        println!(\"  Database path: {}\", config.db_path);\n        println!(\"  LLM endpoint: {}\", config.llm_endpoint);\n        println!(\"  Model: {}\", config.model);\n        println!(\"  Max tokens: {}\", config.max_tokens);\n        println!(\"  Temperature: {}\", config.temperature);\n        println!(\"  Max context tokens: {}\", config.max_context_tokens);\n        println!(\"  Relevance threshold: {}\", config.relevance_threshold);\n        println!(\"  Output directory: {}\", config.output_dir);\n        println!(\"  Entity query: {}\", config.entity_query);\n\n        if dry_run {\n            println!(\"  Mode: Dry run (no files will be written)\");\n        }\n        println!();\n    }\n\n    // Generate context ID\n    let context_id = matches\n        .get_one::<String>(\"context-id\")\n        .cloned()\n        .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());\n\n    // Generate output path\n    let output_path = if dry_run {\n        // For dry run, use a temporary path\n        format!(\"/tmp/dry_run_context_{}.json\", context_id)\n    } else {\n        CliConfig::generate_output_path(&config.output_dir, &context_id)\n    };\n\n    if verbose && !quiet {\n        println!(\"Context ID: {}\", context_id);\n        println!(\"Output path: {}\", output_path);\n        println!();\n    }\n\n    // Run optimizer\n    let result = optimizer.generate_context(&output_path).await?;\n\n    // Print detailed results if verbose\n    if verbose && !quiet {\n        println!(\"\\nDetailed Results:\");\n        println!(\"  Context ID: {}\", result.context_id);\n        println!(\"  Output file: {}\", result.output_path);\n        println!(\"  Entities processed: {}\", result.entities_processed);\n        println!(\"  Entities optimized: {}\", result.entities_optimized);\n        println!(\"  Tokens generated: {}\", result.tokens_generated);\n        println!(\"  Optimization ratio: {:.2}%\", result.optimization_ratio * 100.0);\n        println!(\"  Processing time: {:?}\", result.generation_time);\n\n        // Get and display statistics\n        let stats = optimizer.get_stats();\n        println!(\"  Contexts generated: {}\", stats.contexts_generated);\n        println!(\"  Total entities processed: {}\", stats.entities_processed);\n        println!(\"  Total tokens generated: {}\", stats.tokens_generated);\n        println!(\"  Optimization savings: {} tokens\", stats.optimization_savings);\n        println!(\"  LLM requests made: {}\", stats.llm_requests_made);\n        println!(\"  Total generation time: {:?}\", stats.total_generation_time);\n\n        if !result.errors.is_empty() {\n            println!(\"\\nErrors:\");\n            for error in &result.errors {\n                println!(\"  {}\", style(error).yellow());\n            }\n        }\n    }\n\n    // Clean up dry run file if it exists\n    if dry_run {\n        if let Err(_) = tokio::fs::remove_file(&output_path).await {\n            // Ignore cleanup errors\n        }\n    }\n\n    Ok(result)\n}",
    "future_code": "async fn run_optimizer(\n    config: &ContextWriterConfig,\n    matches: &clap::ArgMatches,\n    verbose: bool,\n    quiet: bool,\n    dry_run: bool,\n) -> Result<ContextResult, ContextWriterError> {\n    // Create optimizer instance using async factory (with dependency injection)\n    let optimizer = ToolFactory::create_context_optimizer(config.clone()).await?;\n\n    if verbose && !quiet {\n        println!(\"Configuration:\");\n        println!(\"  Database path: {}\", config.db_path);\n        println!(\"  LLM endpoint: {}\", config.llm_endpoint);\n        println!(\"  Model: {}\", config.model);\n        println!(\"  Max tokens: {}\", config.max_tokens);\n        println!(\"  Temperature: {}\", config.temperature);\n        println!(\"  Max context tokens: {}\", config.max_context_tokens);\n        println!(\"  Relevance threshold: {}\", config.relevance_threshold);\n        println!(\"  Output directory: {}\", config.output_dir);\n        println!(\"  Entity query: {}\", config.entity_query);\n\n        if dry_run {\n            println!(\"  Mode: Dry run (no files will be written)\");\n        }\n        println!();\n    }\n\n    // Generate context ID\n    let context_id = matches\n        .get_one::<String>(\"context-id\")\n        .cloned()\n        .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());\n\n    // Generate output path\n    let output_path = if dry_run {\n        // For dry run, use a temporary path\n        format!(\"/tmp/dry_run_context_{}.json\", context_id)\n    } else {\n        CliConfig::generate_output_path(&config.output_dir, &context_id)\n    };\n\n    if verbose && !quiet {\n        println!(\"Context ID: {}\", context_id);\n        println!(\"Output path: {}\", output_path);\n        println!();\n    }\n\n    // Run optimizer\n    let result = optimizer.generate_context(&output_path).await?;\n\n    // Print detailed results if verbose\n    if verbose && !quiet {\n        println!(\"\\nDetailed Results:\");\n        println!(\"  Context ID: {}\", result.context_id);\n        println!(\"  Output file: {}\", result.output_path);\n        println!(\"  Entities processed: {}\", result.entities_processed);\n        println!(\"  Entities optimized: {}\", result.entities_optimized);\n        println!(\"  Tokens generated: {}\", result.tokens_generated);\n        println!(\"  Optimization ratio: {:.2}%\", result.optimization_ratio * 100.0);\n        println!(\"  Processing time: {:?}\", result.generation_time);\n\n        // Get and display statistics\n        let stats = optimizer.get_stats();\n        println!(\"  Contexts generated: {}\", stats.contexts_generated);\n        println!(\"  Total entities processed: {}\", stats.entities_processed);\n        println!(\"  Total tokens generated: {}\", stats.tokens_generated);\n        println!(\"  Optimization savings: {} tokens\", stats.optimization_savings);\n        println!(\"  LLM requests made: {}\", stats.llm_requests_made);\n        println!(\"  Total generation time: {:?}\", stats.total_generation_time);\n\n        if !result.errors.is_empty() {\n            println!(\"\\nErrors:\");\n            for error in &result.errors {\n                println!(\"  {}\", style(error).yellow());\n            }\n        }\n    }\n\n    // Clean up dry run file if it exists\n    if dry_run {\n        if let Err(_) = tokio::fs::remove_file(&output_path).await {\n            // Ignore cleanup errors\n        }\n    }\n\n    Ok(result)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436258Z",
      "modified_at": "2025-11-01T15:29:24.436258Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_rust_preflight_code_simulator:______crates_parseltongue_src_main_rs:382-465",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_rust_preflight_code_simulator",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 382,
        "end": 465
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_rust_preflight_code_simulator(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt04_syntax_preflight_validator::SimpleSyntaxValidator;\n\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running Tool 4: pt04-syntax-preflight-validator\").cyan());\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Fetch changed entities (those with future_action set)\n    let entities = storage.get_changed_entities().await?;\n\n    if entities.is_empty() {\n        println!(\"{}\", style(\" No entities with pending changes found\").yellow());\n        return Ok(());\n    }\n\n    println!(\"  Validating {} changed entities...\", entities.len());\n\n    // Create syntax validator\n    let mut validator = SimpleSyntaxValidator::new()\n        .map_err(|e| anyhow::anyhow!(\"Failed to create validator: {}\", e))?;\n\n    let mut total_validated = 0;\n    let mut total_errors = 0;\n    let mut validation_details = Vec::new();\n\n    // Validate each entity's future_code\n    for entity in &entities {\n        if let Some(future_code) = &entity.future_code {\n            total_validated += 1;\n\n            let result = validator.validate_syntax(future_code)\n                .map_err(|e| anyhow::anyhow!(\"Validation failed for {}: {}\", entity.isgl1_key, e))?;\n\n            if !result.is_valid {\n                total_errors += 1;\n\n                if verbose {\n                    eprintln!(\"{} {}\", style(\"\").red(), entity.isgl1_key);\n                    for error in &result.errors {\n                        eprintln!(\"  {}\", style(error).red());\n                    }\n                }\n\n                validation_details.push((entity.isgl1_key.clone(), result.errors));\n            } else if verbose {\n                println!(\"{} {}\", style(\"\").green(), entity.isgl1_key);\n            }\n        }\n    }\n\n    // Print summary\n    println!();\n    if total_errors == 0 {\n        println!(\"{}\", style(\" All syntax validations passed\").green().bold());\n        println!(\"  Entities validated: {}\", total_validated);\n    } else {\n        eprintln!(\"{}\", style(\" Syntax validation failed\").red().bold());\n        eprintln!(\"  Entities validated: {}\", total_validated);\n        eprintln!(\"  Entities with errors: {}\", total_errors);\n\n        if !verbose {\n            eprintln!();\n            eprintln!(\"Failed entities:\");\n            for (key, errors) in &validation_details {\n                eprintln!(\"  {} {}\", style(\"\").red(), key);\n                for error in errors {\n                    eprintln!(\"    {}\", error);\n                }\n            }\n        }\n\n        return Err(anyhow::anyhow!(\"Syntax validation failed for {} entities\", total_errors));\n    }\n\n    Ok(())\n}",
    "future_code": "async fn run_rust_preflight_code_simulator(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt04_syntax_preflight_validator::SimpleSyntaxValidator;\n\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running Tool 4: pt04-syntax-preflight-validator\").cyan());\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Fetch changed entities (those with future_action set)\n    let entities = storage.get_changed_entities().await?;\n\n    if entities.is_empty() {\n        println!(\"{}\", style(\" No entities with pending changes found\").yellow());\n        return Ok(());\n    }\n\n    println!(\"  Validating {} changed entities...\", entities.len());\n\n    // Create syntax validator\n    let mut validator = SimpleSyntaxValidator::new()\n        .map_err(|e| anyhow::anyhow!(\"Failed to create validator: {}\", e))?;\n\n    let mut total_validated = 0;\n    let mut total_errors = 0;\n    let mut validation_details = Vec::new();\n\n    // Validate each entity's future_code\n    for entity in &entities {\n        if let Some(future_code) = &entity.future_code {\n            total_validated += 1;\n\n            let result = validator.validate_syntax(future_code)\n                .map_err(|e| anyhow::anyhow!(\"Validation failed for {}: {}\", entity.isgl1_key, e))?;\n\n            if !result.is_valid {\n                total_errors += 1;\n\n                if verbose {\n                    eprintln!(\"{} {}\", style(\"\").red(), entity.isgl1_key);\n                    for error in &result.errors {\n                        eprintln!(\"  {}\", style(error).red());\n                    }\n                }\n\n                validation_details.push((entity.isgl1_key.clone(), result.errors));\n            } else if verbose {\n                println!(\"{} {}\", style(\"\").green(), entity.isgl1_key);\n            }\n        }\n    }\n\n    // Print summary\n    println!();\n    if total_errors == 0 {\n        println!(\"{}\", style(\" All syntax validations passed\").green().bold());\n        println!(\"  Entities validated: {}\", total_validated);\n    } else {\n        eprintln!(\"{}\", style(\" Syntax validation failed\").red().bold());\n        eprintln!(\"  Entities validated: {}\", total_validated);\n        eprintln!(\"  Entities with errors: {}\", total_errors);\n\n        if !verbose {\n            eprintln!();\n            eprintln!(\"Failed entities:\");\n            for (key, errors) in &validation_details {\n                eprintln!(\"  {} {}\", style(\"\").red(), key);\n                for error in errors {\n                    eprintln!(\"    {}\", error);\n                }\n            }\n        }\n\n        return Err(anyhow::anyhow!(\"Syntax validation failed for {} entities\", total_errors));\n    }\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436260Z",
      "modified_at": "2025-11-01T15:29:24.436260Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_streamer:______crates_pt01-folder-to-cozodb-streamer_src_main_rs:75-113",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_streamer",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "line_range": {
        "start": 75,
        "end": 113
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_streamer(\n    config: &StreamerConfig,\n    verbose: bool,\n    quiet: bool,\n) -> Result<pt01_folder_to_cozodb_streamer::StreamResult, StreamerError> {\n    // Create streamer instance using factory (now async)\n    let streamer = ToolFactory::create_streamer(config.clone()).await?;\n\n    if verbose && !quiet {\n        println!(\"Configuration:\");\n        println!(\"  Root directory: {}\", config.root_dir.display());\n        println!(\"  Database path: {}\", config.db_path);\n        println!(\"  Max file size: {} bytes\", config.max_file_size);\n        println!(\"  Include patterns: {:?}\", config.include_patterns);\n        println!(\"  Exclude patterns: {:?}\", config.exclude_patterns);\n        println!();\n    }\n\n    // Run streaming\n    let result = streamer.stream_directory().await?;\n\n    // Print detailed results if verbose\n    if verbose && !quiet {\n        println!(\"\\nDetailed Results:\");\n        println!(\"  Files scanned: {}\", result.total_files);\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        println!(\"  Processing time: {:?}\", result.duration);\n\n        if !result.errors.is_empty() {\n            println!(\"\\nErrors:\");\n            for error in &result.errors {\n                println!(\"  {}\", style(error).yellow());\n            }\n        }\n    }\n\n    Ok(result)\n}",
    "future_code": "async fn run_streamer(\n    config: &StreamerConfig,\n    verbose: bool,\n    quiet: bool,\n) -> Result<pt01_folder_to_cozodb_streamer::StreamResult, StreamerError> {\n    // Create streamer instance using factory (now async)\n    let streamer = ToolFactory::create_streamer(config.clone()).await?;\n\n    if verbose && !quiet {\n        println!(\"Configuration:\");\n        println!(\"  Root directory: {}\", config.root_dir.display());\n        println!(\"  Database path: {}\", config.db_path);\n        println!(\"  Max file size: {} bytes\", config.max_file_size);\n        println!(\"  Include patterns: {:?}\", config.include_patterns);\n        println!(\"  Exclude patterns: {:?}\", config.exclude_patterns);\n        println!();\n    }\n\n    // Run streaming\n    let result = streamer.stream_directory().await?;\n\n    // Print detailed results if verbose\n    if verbose && !quiet {\n        println!(\"\\nDetailed Results:\");\n        println!(\"  Files scanned: {}\", result.total_files);\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        println!(\"  Processing time: {:?}\", result.duration);\n\n        if !result.errors.is_empty() {\n            println!(\"\\nErrors:\");\n            for error in &result.errors {\n                println!(\"  {}\", style(error).yellow());\n            }\n        }\n    }\n\n    Ok(result)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436261Z",
      "modified_at": "2025-11-01T15:29:24.436261Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_validation_rules:______crates_parseltongue-core_src_temporal_rs:242-247",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_validation_rules",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 242,
        "end": 247
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn run_validation_rules(&self) -> Result<()> {\n        for rule in &self.validation_rules {\n            rule.validate(&self.entities)?;\n        }\n        Ok(())\n    }",
    "future_code": "    fn run_validation_rules(&self) -> Result<()> {\n        for rule in &self.validation_rules {\n            rule.validate(&self.entities)?;\n        }\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436262Z",
      "modified_at": "2025-11-01T15:29:24.436262Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:run_writer:______crates_pt03-llm-to-cozodb-writer_src_main_rs:62-96",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "run_writer",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "line_range": {
        "start": 62,
        "end": 96
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn run_writer(mode: InterfaceMode) -> Result<()> {\n    // Extract database path and query based on interface mode\n    let (db_path, query) = match &mode {\n        InterfaceMode::Simple(config) => {\n            println!(\"  Using Simple Interface (Create/Edit/Delete)\");\n            println!(\"  Entity: {}\", config.entity_key);\n            println!(\"  Action: {:?}\", config.action);\n            let query = config.to_datalog();\n            (&config.db_path, query)\n        }\n        InterfaceMode::Advanced(config) => {\n            println!(\"  Using Advanced Interface (Raw Datalog)\");\n            (&config.db_path, config.query.clone())\n        }\n    };\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    println!(\"  Executing Datalog query...\");\n\n    // Execute Datalog query via CozoDB (S01: trust the user)\n    storage\n        .execute_query(&query)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Query execution failed: {}\", e))?;\n\n    println!(\n        \"{}\",\n        style(\" Datalog query executed successfully\").green()\n    );\n    Ok(())\n}",
    "future_code": "async fn run_writer(mode: InterfaceMode) -> Result<()> {\n    // Extract database path and query based on interface mode\n    let (db_path, query) = match &mode {\n        InterfaceMode::Simple(config) => {\n            println!(\"  Using Simple Interface (Create/Edit/Delete)\");\n            println!(\"  Entity: {}\", config.entity_key);\n            println!(\"  Action: {:?}\", config.action);\n            let query = config.to_datalog();\n            (&config.db_path, query)\n        }\n        InterfaceMode::Advanced(config) => {\n            println!(\"  Using Advanced Interface (Raw Datalog)\");\n            (&config.db_path, config.query.clone())\n        }\n    };\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    println!(\"  Executing Datalog query...\");\n\n    // Execute Datalog query via CozoDB (S01: trust the user)\n    storage\n        .execute_query(&query)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Query execution failed: {}\", e))?;\n\n    println!(\n        \"{}\",\n        style(\" Datalog query executed successfully\").green()\n    );\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436263Z",
      "modified_at": "2025-11-01T15:29:24.436263Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:sanitize_path:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:107-109",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "sanitize_path",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 107,
        "end": 109
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn sanitize_path(&self, path: &str) -> String {\n        path.replace(['/', '\\\\', '.'], \"_\")\n    }",
    "future_code": "    fn sanitize_path(&self, path: &str) -> String {\n        path.replace(['/', '\\\\', '.'], \"_\")\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436265Z",
      "modified_at": "2025-11-01T15:29:24.436265Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:severity:______crates_pt04-syntax-preflight-validator_src_errors_rs:67-78",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "severity",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/errors.rs",
      "line_range": {
        "start": 67,
        "end": 78
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn severity(&self) -> Severity {\n        match self {\n            Self::SyntaxError { .. }\n            | Self::TypeError { .. }\n            | Self::BorrowError { .. }\n            | Self::CompilationError { .. }\n            | Self::TestError { .. } => Severity::Error,\n            Self::Timeout { .. } => Severity::Error,\n            Self::Io(_) => Severity::Error,\n            Self::Parse(_) => Severity::Error,\n        }\n    }",
    "future_code": "    pub fn severity(&self) -> Severity {\n        match self {\n            Self::SyntaxError { .. }\n            | Self::TypeError { .. }\n            | Self::BorrowError { .. }\n            | Self::CompilationError { .. }\n            | Self::TestError { .. } => Severity::Error,\n            Self::Timeout { .. } => Severity::Error,\n            Self::Io(_) => Severity::Error,\n            Self::Parse(_) => Severity::Error,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436266Z",
      "modified_at": "2025-11-01T15:29:24.436266Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:should_process_file:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:252-270",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "should_process_file",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 252,
        "end": 270
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn should_process_file(&self, file_path: &Path) -> bool {\n        let path_str = file_path.to_string_lossy();\n\n        // Check exclude patterns\n        for pattern in &self.config.exclude_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return false;\n            }\n        }\n\n        // Check include patterns\n        for pattern in &self.config.include_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return true;\n            }\n        }\n\n        false\n    }",
    "future_code": "    fn should_process_file(&self, file_path: &Path) -> bool {\n        let path_str = file_path.to_string_lossy();\n\n        // Check exclude patterns\n        for pattern in &self.config.exclude_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return false;\n            }\n        }\n\n        // Check include patterns\n        for pattern in &self.config.include_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return true;\n            }\n        }\n\n        false\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436267Z",
      "modified_at": "2025-11-01T15:29:24.436267Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:simulate_test_execution:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:359-363",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "simulate_test_execution",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 359,
        "end": 363
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn simulate_test_execution(code: &str) -> Result<bool> {\n    // Simulate: add(2, 3) should equal 5\n    // Check if code contains 'a + b' which would make this pass\n    Ok(code.contains(\"a + b\"))\n}",
    "future_code": "fn simulate_test_execution(code: &str) -> Result<bool> {\n    // Simulate: add(2, 3) should equal 5\n    // Check if code contains 'a + b' which would make this pass\n    Ok(code.contains(\"a + b\"))\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436268Z",
      "modified_at": "2025-11-01T15:29:24.436268Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:simulate_tool1_indexing:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:256-318",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "simulate_tool1_indexing",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 256,
        "end": 318
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn simulate_tool1_indexing(\n    project_path: &PathBuf,\n    storage: &CozoDbStorage,\n) -> Result<Vec<CodeEntity>> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let mut entities = Vec::new();\n\n    // Index the 'add' function\n    let add_signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project_path.join(\"src/lib.rs\"))?;\n    let mut add_entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), add_signature)?;\n    add_entity.current_code = Some(current_code.clone());\n    add_entity.future_code = Some(\"\".to_string());\n    add_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&add_entity).await?;\n    entities.push(add_entity);\n\n    // Index the test module\n    let test_signature = InterfaceSignature {\n        entity_type: EntityType::Module,\n        name: \"tests\".to_string(),\n        visibility: Visibility::Private,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(6, 13).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[cfg(test)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut test_entity = CodeEntity::new(\"src-lib-rs-tests\".to_string(), test_signature)?;\n    test_entity.current_code = Some(current_code);\n    test_entity.future_code = Some(\"\".to_string());\n    test_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&test_entity).await?;\n    entities.push(test_entity);\n\n    Ok(entities)\n}",
    "future_code": "async fn simulate_tool1_indexing(\n    project_path: &PathBuf,\n    storage: &CozoDbStorage,\n) -> Result<Vec<CodeEntity>> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let mut entities = Vec::new();\n\n    // Index the 'add' function\n    let add_signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project_path.join(\"src/lib.rs\"))?;\n    let mut add_entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), add_signature)?;\n    add_entity.current_code = Some(current_code.clone());\n    add_entity.future_code = Some(\"\".to_string());\n    add_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&add_entity).await?;\n    entities.push(add_entity);\n\n    // Index the test module\n    let test_signature = InterfaceSignature {\n        entity_type: EntityType::Module,\n        name: \"tests\".to_string(),\n        visibility: Visibility::Private,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(6, 13).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[cfg(test)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut test_entity = CodeEntity::new(\"src-lib-rs-tests\".to_string(), test_signature)?;\n    test_entity.current_code = Some(current_code);\n    test_entity.future_code = Some(\"\".to_string());\n    test_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&test_entity).await?;\n    entities.push(test_entity);\n\n    Ok(entities)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436269Z",
      "modified_at": "2025-11-01T15:29:24.436269Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:source_location:______crates_parseltongue-core_src_entities_rs:1053-1056",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "source_location",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1053,
        "end": 1056
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn source_location(mut self, location: impl Into<String>) -> Self {\n        self.source_location = Some(location.into());\n        self\n    }",
    "future_code": "    pub fn source_location(mut self, location: impl Into<String>) -> Self {\n        self.source_location = Some(location.into());\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436270Z",
      "modified_at": "2025-11-01T15:29:24.436270Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:span:______crates_parseltongue-core_src_entities_rs:303-305",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "span",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 303,
        "end": 305
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn span(&self) -> u32 {\n        self.end - self.start + 1\n    }",
    "future_code": "    pub fn span(&self) -> u32 {\n        self.end - self.start + 1\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436271Z",
      "modified_at": "2025-11-01T15:29:24.436271Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:store_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:1133-1135",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "store_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1133,
        "end": 1135
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn store_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.insert_entity(&entity).await\n    }",
    "future_code": "    async fn store_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.insert_entity(&entity).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436272Z",
      "modified_at": "2025-11-01T15:29:24.436272Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:stream_directory:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:332-399",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "stream_directory",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 332,
        "end": 399
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn stream_directory(&self) -> Result<StreamResult> {\n        let start_time = Instant::now();\n        let mut total_files = 0;\n        let mut processed_files = 0;\n        let mut entities_created = 0;\n        let mut errors = Vec::new();\n\n        println!(\n            \"{}\",\n            style(\"Starting directory streaming...\").blue().bold()\n        );\n\n        // Setup progress bar\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} [{elapsed_precise}] {msg}\")\n                .unwrap()\n        );\n        pb.set_message(\"Scanning files...\");\n\n        // Walk through directory\n        for entry in WalkDir::new(&self.config.root_dir)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let path = entry.path();\n\n            if path.is_file() && self.should_process_file(path) {\n                total_files += 1;\n                pb.set_message(format!(\"Processing: {}\", path.display()));\n\n                match self.stream_file(path).await {\n                    Ok(result) => {\n                        processed_files += 1;\n                        entities_created += result.entities_created;\n                    }\n                    Err(e) => {\n                        let error_msg = format!(\"{}: {}\", path.display(), e);\n                        errors.push(error_msg.clone());\n                        pb.println(format!(\"{} {}\", style(\"\").yellow().for_stderr(), error_msg));\n                        self.update_stats(0, true);\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(\"Directory streaming completed\");\n\n        let duration = start_time.elapsed();\n\n        // Print summary\n        println!(\"\\n{}\", style(\"Streaming Summary:\").green().bold());\n        println!(\"Total files found: {}\", total_files);\n        println!(\"Files processed: {}\", processed_files);\n        println!(\"Entities created: {}\", entities_created);\n        println!(\"Errors encountered: {}\", errors.len());\n        println!(\"Duration: {:?}\", duration);\n\n        Ok(StreamResult {\n            total_files,\n            processed_files,\n            entities_created,\n            errors,\n            duration,\n        })\n    }",
    "future_code": "    async fn stream_directory(&self) -> Result<StreamResult> {\n        let start_time = Instant::now();\n        let mut total_files = 0;\n        let mut processed_files = 0;\n        let mut entities_created = 0;\n        let mut errors = Vec::new();\n\n        println!(\n            \"{}\",\n            style(\"Starting directory streaming...\").blue().bold()\n        );\n\n        // Setup progress bar\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} [{elapsed_precise}] {msg}\")\n                .unwrap()\n        );\n        pb.set_message(\"Scanning files...\");\n\n        // Walk through directory\n        for entry in WalkDir::new(&self.config.root_dir)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let path = entry.path();\n\n            if path.is_file() && self.should_process_file(path) {\n                total_files += 1;\n                pb.set_message(format!(\"Processing: {}\", path.display()));\n\n                match self.stream_file(path).await {\n                    Ok(result) => {\n                        processed_files += 1;\n                        entities_created += result.entities_created;\n                    }\n                    Err(e) => {\n                        let error_msg = format!(\"{}: {}\", path.display(), e);\n                        errors.push(error_msg.clone());\n                        pb.println(format!(\"{} {}\", style(\"\").yellow().for_stderr(), error_msg));\n                        self.update_stats(0, true);\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(\"Directory streaming completed\");\n\n        let duration = start_time.elapsed();\n\n        // Print summary\n        println!(\"\\n{}\", style(\"Streaming Summary:\").green().bold());\n        println!(\"Total files found: {}\", total_files);\n        println!(\"Files processed: {}\", processed_files);\n        println!(\"Entities created: {}\", entities_created);\n        println!(\"Errors encountered: {}\", errors.len());\n        println!(\"Duration: {:?}\", duration);\n\n        Ok(StreamResult {\n            total_files,\n            processed_files,\n            entities_created,\n            errors,\n            duration,\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436273Z",
      "modified_at": "2025-11-01T15:29:24.436274Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:stream_file:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:401-480",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "stream_file",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 401,
        "end": 480
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn stream_file(&self, file_path: &Path) -> Result<FileResult> {\n        let file_path_str = file_path.to_string_lossy().to_string();\n\n        // Read file content\n        let content = self.read_file_content(file_path).await?;\n\n        // Parse code entities AND dependencies (two-pass extraction)\n        let (parsed_entities, dependencies) = self.key_generator.parse_source(&content, file_path)?;\n\n        let mut entities_created = 0;\n        let mut errors: Vec<String> = Vec::new();\n\n        // Process each parsed entity\n        for parsed_entity in parsed_entities {\n            // Generate ISGL1 key\n            let isgl1_key = self.key_generator.generate_key(&parsed_entity)?;\n\n            // Enrich with LSP metadata for Rust files (sequential hover requests)\n            let lsp_metadata = self.fetch_lsp_metadata_for_entity(&parsed_entity, file_path).await;\n\n            // Convert ParsedEntity to CodeEntity\n            match self.parsed_entity_to_code_entity(&parsed_entity, &isgl1_key, &content) {\n                Ok(mut code_entity) => {\n                    // Store LSP metadata as JSON string if available\n                    if let Some(metadata) = lsp_metadata {\n                        code_entity.lsp_metadata = Some(metadata);\n                    }\n\n                    // Store in real database\n                    match self.db.insert_entity(&code_entity).await {\n                        Ok(_) => {\n                            entities_created += 1;\n                        }\n                        Err(e) => {\n                            let error_msg = format!(\"Failed to insert entity {}: {}\", isgl1_key, e);\n                            errors.push(error_msg);\n                        }\n                    }\n                }\n                Err(e) => {\n                    let error_msg = format!(\"Failed to convert entity {}: {}\", isgl1_key, e);\n                    errors.push(error_msg);\n                }\n            }\n        }\n\n        // Batch insert dependencies after all entities are stored\n        if !dependencies.is_empty() {\n            // First need to create schema for dependencies if not exists\n            if let Err(e) = self.db.create_dependency_edges_schema().await {\n                // Schema might already exist - that's ok\n                if !e.to_string().contains(\"already exists\") && !e.to_string().contains(\"conflicts with an existing\") {\n                    errors.push(format!(\"Failed to create dependency schema: {}\", e));\n                }\n            }\n\n            // Insert dependency edges\n            match self.db.insert_edges_batch(&dependencies).await {\n                Ok(_) => {\n                    // Successfully inserted dependencies\n                }\n                Err(e) => {\n                    errors.push(format!(\"Failed to insert {} dependencies: {}\", dependencies.len(), e));\n                }\n            }\n        }\n\n        self.update_stats(entities_created, !errors.is_empty());\n\n        Ok(FileResult {\n            file_path: file_path_str,\n            entities_created,\n            success: errors.is_empty(),\n            error: if errors.is_empty() {\n                None\n            } else {\n                Some(errors.join(\"; \"))\n            },\n        })\n    }",
    "future_code": "    async fn stream_file(&self, file_path: &Path) -> Result<FileResult> {\n        let file_path_str = file_path.to_string_lossy().to_string();\n\n        // Read file content\n        let content = self.read_file_content(file_path).await?;\n\n        // Parse code entities AND dependencies (two-pass extraction)\n        let (parsed_entities, dependencies) = self.key_generator.parse_source(&content, file_path)?;\n\n        let mut entities_created = 0;\n        let mut errors: Vec<String> = Vec::new();\n\n        // Process each parsed entity\n        for parsed_entity in parsed_entities {\n            // Generate ISGL1 key\n            let isgl1_key = self.key_generator.generate_key(&parsed_entity)?;\n\n            // Enrich with LSP metadata for Rust files (sequential hover requests)\n            let lsp_metadata = self.fetch_lsp_metadata_for_entity(&parsed_entity, file_path).await;\n\n            // Convert ParsedEntity to CodeEntity\n            match self.parsed_entity_to_code_entity(&parsed_entity, &isgl1_key, &content) {\n                Ok(mut code_entity) => {\n                    // Store LSP metadata as JSON string if available\n                    if let Some(metadata) = lsp_metadata {\n                        code_entity.lsp_metadata = Some(metadata);\n                    }\n\n                    // Store in real database\n                    match self.db.insert_entity(&code_entity).await {\n                        Ok(_) => {\n                            entities_created += 1;\n                        }\n                        Err(e) => {\n                            let error_msg = format!(\"Failed to insert entity {}: {}\", isgl1_key, e);\n                            errors.push(error_msg);\n                        }\n                    }\n                }\n                Err(e) => {\n                    let error_msg = format!(\"Failed to convert entity {}: {}\", isgl1_key, e);\n                    errors.push(error_msg);\n                }\n            }\n        }\n\n        // Batch insert dependencies after all entities are stored\n        if !dependencies.is_empty() {\n            // First need to create schema for dependencies if not exists\n            if let Err(e) = self.db.create_dependency_edges_schema().await {\n                // Schema might already exist - that's ok\n                if !e.to_string().contains(\"already exists\") && !e.to_string().contains(\"conflicts with an existing\") {\n                    errors.push(format!(\"Failed to create dependency schema: {}\", e));\n                }\n            }\n\n            // Insert dependency edges\n            match self.db.insert_edges_batch(&dependencies).await {\n                Ok(_) => {\n                    // Successfully inserted dependencies\n                }\n                Err(e) => {\n                    errors.push(format!(\"Failed to insert {} dependencies: {}\", dependencies.len(), e));\n                }\n            }\n        }\n\n        self.update_stats(entities_created, !errors.is_empty());\n\n        Ok(FileResult {\n            file_path: file_path_str,\n            entities_created,\n            success: errors.is_empty(),\n            error: if errors.is_empty() {\n                None\n            } else {\n                Some(errors.join(\"; \"))\n            },\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436275Z",
      "modified_at": "2025-11-01T15:29:24.436275Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:success:______crates_pt04-syntax-preflight-validator_src_types_rs:65-74",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "success",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 65,
        "end": 74
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn success(validation_type: ValidationType) -> Self {\n        Self {\n            is_valid: true,\n            validation_type,\n            errors: Vec::new(),\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
    "future_code": "    pub fn success(validation_type: ValidationType) -> Self {\n        Self {\n            is_valid: true,\n            validation_type,\n            errors: Vec::new(),\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436277Z",
      "modified_at": "2025-11-01T15:29:24.436277Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:success:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:19-26",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "success",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 19,
        "end": 26
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn success(file_path: PathBuf, operation: WriteOperation) -> Self {\n        Self {\n            success: true,\n            file_path,\n            operation,\n            message: None,\n        }\n    }",
    "future_code": "    pub fn success(file_path: PathBuf, operation: WriteOperation) -> Self {\n        Self {\n            success: true,\n            file_path,\n            operation,\n            message: None,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436278Z",
      "modified_at": "2025-11-01T15:29:24.436278Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:success:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:84-90",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "success",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 84,
        "end": 90
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn success(entities_deleted: usize) -> Self {\n        Self {\n            success: true,\n            entities_deleted,\n            schema_recreated: true,\n        }\n    }",
    "future_code": "    pub fn success(entities_deleted: usize) -> Self {\n        Self {\n            success: true,\n            entities_deleted,\n            schema_recreated: true,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436279Z",
      "modified_at": "2025-11-01T15:29:24.436279Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:temporal_query_creation:______crates_parseltongue-core_src_interfaces_rs:642-654",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "temporal_query_creation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 642,
        "end": 654
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn temporal_query_creation() {\n        let query = TemporalQuery {\n            base_entities: vec![\"test.rs-test-function\".to_string()],\n            hop_depth: 2,\n            future_only: true,\n            entity_type_filter: Some(EntityType::Function),\n            language_filter: Some(Language::Rust),\n        };\n\n        assert_eq!(query.base_entities.len(), 1);\n        assert_eq!(query.hop_depth, 2);\n        assert!(query.future_only);\n    }",
    "future_code": "    fn temporal_query_creation() {\n        let query = TemporalQuery {\n            base_entities: vec![\"test.rs-test-function\".to_string()],\n            hop_depth: 2,\n            future_only: true,\n            entity_type_filter: Some(EntityType::Function),\n            language_filter: Some(Language::Rust),\n        };\n\n        assert_eq!(query.base_entities.len(), 1);\n        assert_eq!(query.hop_depth, 2);\n        assert!(query.future_only);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436280Z",
      "modified_at": "2025-11-01T15:29:24.436280Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:temporal_state_validation:______crates_parseltongue-core_src_entities_rs:1090-1098",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "temporal_state_validation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1090,
        "end": 1098
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn temporal_state_validation() {\n        let state = TemporalState::unchanged();\n        assert!(state.validate().is_ok());\n        assert!(!state.is_changed());\n\n        let edit_state = TemporalState::edit();\n        assert!(edit_state.validate().is_ok());\n        assert!(edit_state.is_changed());\n    }",
    "future_code": "    fn temporal_state_validation() {\n        let state = TemporalState::unchanged();\n        assert!(state.validate().is_ok());\n        assert!(!state.is_changed());\n\n        let edit_state = TemporalState::edit();\n        assert!(edit_state.validate().is_ok());\n        assert!(edit_state.is_changed());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436281Z",
      "modified_at": "2025-11-01T15:29:24.436281Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:temporal_state_validation:______crates_parseltongue-core_src_temporal_rs:589-592",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "temporal_state_validation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 589,
        "end": 592
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn temporal_state_validation() {\n        let manager = TemporalVersioningManager::new();\n        assert!(manager.validate_state().is_ok());\n    }",
    "future_code": "    fn temporal_state_validation() {\n        let manager = TemporalVersioningManager::new();\n        assert!(manager.validate_state().is_ok());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436282Z",
      "modified_at": "2025-11-01T15:29:24.436282Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:temporal_transition_builder:______crates_parseltongue-core_src_temporal_rs:645-655",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "temporal_transition_builder",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 645,
        "end": 655
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn temporal_transition_builder() {\n        let transition = TemporalTransitionBuilder::new(\"test.rs-test\".to_string())\n            .action(TemporalAction::Create)\n            .future_code(\"fn test() {}\".to_string())\n            .build()\n            .unwrap();\n\n        assert_eq!(transition.isgl1_key, \"test.rs-test\");\n        assert_eq!(transition.action, TemporalAction::Create);\n        assert_eq!(transition.future_code, Some(\"fn test() {}\".to_string()));\n    }",
    "future_code": "    fn temporal_transition_builder() {\n        let transition = TemporalTransitionBuilder::new(\"test.rs-test\".to_string())\n            .action(TemporalAction::Create)\n            .future_code(\"fn test() {}\".to_string())\n            .build()\n            .unwrap();\n\n        assert_eq!(transition.isgl1_key, \"test.rs-test\");\n        assert_eq!(transition.action, TemporalAction::Create);\n        assert_eq!(transition.future_code, Some(\"fn test() {}\".to_string()));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436283Z",
      "modified_at": "2025-11-01T15:29:24.436283Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_add_change_updates_metadata:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:179-199",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_add_change_updates_metadata",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 179,
        "end": 199
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_add_change_updates_metadata() {\n        let mut diff = CodeDiff::new();\n\n        let change = Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None, // Create operations have no current code\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None, // Hash-based keys have no line range\n            interface_signature: \"fn test()\".to_string(),\n        };\n\n        diff.add_change(change);\n\n        assert_eq!(diff.changes.len(), 1);\n        assert_eq!(diff.metadata.total_changes, 1);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 0);\n        assert_eq!(diff.metadata.delete_count, 0);\n    }",
    "future_code": "    fn test_add_change_updates_metadata() {\n        let mut diff = CodeDiff::new();\n\n        let change = Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None, // Create operations have no current code\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None, // Hash-based keys have no line range\n            interface_signature: \"fn test()\".to_string(),\n        };\n\n        diff.add_change(change);\n\n        assert_eq!(diff.changes.len(), 1);\n        assert_eq!(diff.metadata.total_changes, 1);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 0);\n        assert_eq!(diff.metadata.delete_count, 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436284Z",
      "modified_at": "2025-11-01T15:29:24.436284Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_advanced_interface_mode:______crates_pt03-llm-to-cozodb-writer_src_main_rs:124-139",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_advanced_interface_mode",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "line_range": {
        "start": 124,
        "end": 139
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_advanced_interface_mode() {\n        let config = AdvancedQueryConfig {\n            query: \"?[a] := [[1]]\".to_string(),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Advanced(config);\n\n        match mode {\n            InterfaceMode::Advanced(c) => {\n                assert_eq!(c.query, \"?[a] := [[1]]\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Advanced mode\"),\n        }\n    }",
    "future_code": "    fn test_advanced_interface_mode() {\n        let config = AdvancedQueryConfig {\n            query: \"?[a] := [[1]]\".to_string(),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Advanced(config);\n\n        match mode {\n            InterfaceMode::Advanced(c) => {\n                assert_eq!(c.query, \"?[a] := [[1]]\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Advanced mode\"),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436285Z",
      "modified_at": "2025-11-01T15:29:24.436285Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_batch_insert_edges:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:321-348",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_batch_insert_edges",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 321,
        "end": 348
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_batch_insert_edges() {\n    // RED: Batch insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .to_key(\"rust:fn:util:src_util_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:struct:Config:src_config_rs:1-20\")\n            .edge_type(EdgeType::Uses)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
    "future_code": "async fn test_batch_insert_edges() {\n    // RED: Batch insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .to_key(\"rust:fn:util:src_util_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:struct:Config:src_config_rs:1-20\")\n            .edge_type(EdgeType::Uses)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436286Z",
      "modified_at": "2025-11-01T15:29:24.436286Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_batch_insert_empty_slice:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:351-358",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_batch_insert_empty_slice",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 351,
        "end": 358
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_batch_insert_empty_slice() {\n    // Test: Batch insert with empty slice should succeed (no-op)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges: Vec<DependencyEdge> = vec![];\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
    "future_code": "async fn test_batch_insert_empty_slice() {\n    // Test: Batch insert with empty slice should succeed (no-op)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges: Vec<DependencyEdge> = vec![];\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436287Z",
      "modified_at": "2025-11-01T15:29:24.436287Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_batch_insert_performance_contract:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:391-420",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_batch_insert_performance_contract",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 391,
        "end": 420
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_batch_insert_performance_contract() {\n    // Performance Contract: Batch insert (100 edges) <50ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 100 edges\n    let edges: Vec<DependencyEdge> = (0..100)\n        .map(|i| {\n            DependencyEdge::builder()\n                .from_key(format!(\"entity_{}\", i))\n                .to_key(format!(\"entity_{}\", i + 1))\n                .edge_type(EdgeType::Calls)\n                .build()\n                .unwrap()\n        })\n        .collect();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edges_batch(&edges).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 50,\n        \"Batch insert (100 edges) took {:?}, expected <50ms\",\n        elapsed\n    );\n}",
    "future_code": "async fn test_batch_insert_performance_contract() {\n    // Performance Contract: Batch insert (100 edges) <50ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 100 edges\n    let edges: Vec<DependencyEdge> = (0..100)\n        .map(|i| {\n            DependencyEdge::builder()\n                .from_key(format!(\"entity_{}\", i))\n                .to_key(format!(\"entity_{}\", i + 1))\n                .edge_type(EdgeType::Calls)\n                .build()\n                .unwrap()\n        })\n        .collect();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edges_batch(&edges).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 50,\n        \"Batch insert (100 edges) took {:?}, expected <50ms\",\n        elapsed\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436288Z",
      "modified_at": "2025-11-01T15:29:24.436288Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_blast_radius_branching:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:503-546",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_blast_radius_branching",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 503,
        "end": 546
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_blast_radius_branching() {\n    // Test diamond pattern: A -> B, A -> C, B -> D, C -> D\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B, C at distance 1, and D at distance 2 (min distance)\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 3, \"Should find 3 entities (B, C, D)\");\n\n    // D should have minimum distance of 2 (even though reachable via two paths)\n    let d = affected.iter().find(|(k, _)| k.contains(\"fn:D:\"));\n    assert!(d.is_some(), \"Should find D\");\n    assert_eq!(d.unwrap().1, 2, \"D should be at minimum distance 2\");\n}",
    "future_code": "async fn test_blast_radius_branching() {\n    // Test diamond pattern: A -> B, A -> C, B -> D, C -> D\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B, C at distance 1, and D at distance 2 (min distance)\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 3, \"Should find 3 entities (B, C, D)\");\n\n    // D should have minimum distance of 2 (even though reachable via two paths)\n    let d = affected.iter().find(|(k, _)| k.contains(\"fn:D:\"));\n    assert!(d.is_some(), \"Should find D\");\n    assert_eq!(d.unwrap().1, 2, \"D should be at minimum distance 2\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436290Z",
      "modified_at": "2025-11-01T15:29:24.436290Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_blast_radius_multi_hop:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:457-500",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_blast_radius_multi_hop",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 457,
        "end": 500
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_blast_radius_multi_hop() {\n    // RED: Multi-hop blast radius\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B and C\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 2, \"Should find 2 entities within 2 hops\");\n\n    // Check we have B at distance 1 and C at distance 2\n    let b = affected.iter().find(|(k, _)| k.contains(\"fn:B:\"));\n    let c = affected.iter().find(|(k, _)| k.contains(\"fn:C:\"));\n\n    assert!(b.is_some(), \"Should find B\");\n    assert_eq!(b.unwrap().1, 1, \"B should be at distance 1\");\n\n    assert!(c.is_some(), \"Should find C\");\n    assert_eq!(c.unwrap().1, 2, \"C should be at distance 2\");\n}",
    "future_code": "async fn test_blast_radius_multi_hop() {\n    // RED: Multi-hop blast radius\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B and C\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 2, \"Should find 2 entities within 2 hops\");\n\n    // Check we have B at distance 1 and C at distance 2\n    let b = affected.iter().find(|(k, _)| k.contains(\"fn:B:\"));\n    let c = affected.iter().find(|(k, _)| k.contains(\"fn:C:\"));\n\n    assert!(b.is_some(), \"Should find B\");\n    assert_eq!(b.unwrap().1, 1, \"B should be at distance 1\");\n\n    assert!(c.is_some(), \"Should find C\");\n    assert_eq!(c.unwrap().1, 2, \"C should be at distance 2\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436291Z",
      "modified_at": "2025-11-01T15:29:24.436291Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_blast_radius_performance_10k_nodes:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:899-939",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_blast_radius_performance_10k_nodes",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 899,
        "end": 939
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_blast_radius_performance_10k_nodes() {\n    // RED: Validate performance contract - <50ms for 5-hop on 10k nodes (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 3 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let graph_start = Instant::now();\n    let nodes = generate_large_graph(&db, 10_000, 3).await;\n    let graph_time = graph_start.elapsed();\n    println!(\"Graph generation took: {:?}\", graph_time);\n\n    // Warm up query (first query may be slower due to CozoDB internal setup)\n    let _ = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n\n    // Performance test: 5-hop blast radius from first node\n    println!(\"Running blast radius query (5 hops on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Blast radius query returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance contract: <50ms for 5-hop on 10k nodes (D10 PRD requirement)\n    // Note: Run with --release for production performance (debug builds ~5-10x slower)\n    assert!(\n        elapsed < Duration::from_millis(50),\n        \"Performance contract violated: 5-hop blast radius took {:?}, expected <50ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness: Should find nodes within 5 hops\n    assert!(\n        result.len() >= 5,\n        \"Should find at least direct dependencies in graph\"\n    );\n}",
    "future_code": "async fn test_blast_radius_performance_10k_nodes() {\n    // RED: Validate performance contract - <50ms for 5-hop on 10k nodes (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 3 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let graph_start = Instant::now();\n    let nodes = generate_large_graph(&db, 10_000, 3).await;\n    let graph_time = graph_start.elapsed();\n    println!(\"Graph generation took: {:?}\", graph_time);\n\n    // Warm up query (first query may be slower due to CozoDB internal setup)\n    let _ = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n\n    // Performance test: 5-hop blast radius from first node\n    println!(\"Running blast radius query (5 hops on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Blast radius query returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance contract: <50ms for 5-hop on 10k nodes (D10 PRD requirement)\n    // Note: Run with --release for production performance (debug builds ~5-10x slower)\n    assert!(\n        elapsed < Duration::from_millis(50),\n        \"Performance contract violated: 5-hop blast radius took {:?}, expected <50ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness: Should find nodes within 5 hops\n    assert!(\n        result.len() >= 5,\n        \"Should find at least direct dependencies in graph\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436293Z",
      "modified_at": "2025-11-01T15:29:24.436293Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_blast_radius_single_hop:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:425-454",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_blast_radius_single_hop",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 425,
        "end": 454
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_blast_radius_single_hop() {\n    // RED: Blast radius query not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 1-hop from A should return only B\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 1).await.unwrap();\n\n    assert_eq!(affected.len(), 1, \"Should find 1 entity within 1 hop\");\n    assert_eq!(affected[0].0, \"rust:fn:B:test_rs:10-15\");\n    assert_eq!(affected[0].1, 1, \"Distance should be 1\");\n}",
    "future_code": "async fn test_blast_radius_single_hop() {\n    // RED: Blast radius query not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 1-hop from A should return only B\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 1).await.unwrap();\n\n    assert_eq!(affected.len(), 1, \"Should find 1 entity within 1 hop\");\n    assert_eq!(affected[0].0, \"rust:fn:B:test_rs:10-15\");\n    assert_eq!(affected[0].1, 1, \"Distance should be 1\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436294Z",
      "modified_at": "2025-11-01T15:29:24.436294Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_blast_radius_zero_hops:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:549-557",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_blast_radius_zero_hops",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 549,
        "end": 557
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_blast_radius_zero_hops() {\n    // Edge case: 0 hops should return empty\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 0).await.unwrap();\n\n    assert_eq!(affected.len(), 0, \"0 hops should return empty\");\n}",
    "future_code": "async fn test_blast_radius_zero_hops() {\n    // Edge case: 0 hops should return empty\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 0).await.unwrap();\n\n    assert_eq!(affected.len(), 0, \"0 hops should return empty\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436295Z",
      "modified_at": "2025-11-01T15:29:24.436295Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_both_schemas_can_coexist:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:237-261",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_both_schemas_can_coexist",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 237,
        "end": 261
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_both_schemas_can_coexist() {\n    // Test: CodeGraph and DependencyEdges tables can both exist\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create both schemas\n    db.create_schema().await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify both relations exist\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n    assert!(relations.contains(&\"DependencyEdges\".to_string()));\n\n    // Verify we have exactly 2 relations (plus any system relations)\n    let user_relations: Vec<_> = relations\n        .iter()\n        .filter(|r| !r.starts_with(':'))\n        .collect();\n    assert_eq!(\n        user_relations.len(),\n        2,\n        \"Should have exactly 2 user relations. Found: {:?}\",\n        user_relations\n    );\n}",
    "future_code": "async fn test_both_schemas_can_coexist() {\n    // Test: CodeGraph and DependencyEdges tables can both exist\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create both schemas\n    db.create_schema().await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify both relations exist\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n    assert!(relations.contains(&\"DependencyEdges\".to_string()));\n\n    // Verify we have exactly 2 relations (plus any system relations)\n    let user_relations: Vec<_> = relations\n        .iter()\n        .filter(|r| !r.starts_with(':'))\n        .collect();\n    assert_eq!(\n        user_relations.len(),\n        2,\n        \"Should have exactly 2 user relations. Found: {:?}\",\n        user_relations\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436296Z",
      "modified_at": "2025-11-01T15:29:24.436296Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_chained_function_calls:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:639-681",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_chained_function_calls",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 639,
        "end": 681
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_chained_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    a();\n}\n\nfn a() {\n    b();\n}\n\nfn b() {\n    c();\n}\n\nfn c() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->a, a->b, b->c\n        assert_eq!(dependencies.len(), 3);\n\n        // Verify the chain\n        let main_to_a = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"main\") && e.to_key.as_ref().contains(\"a\")\n        );\n        assert!(main_to_a.is_some(), \"Should have main -> a edge\");\n\n        let a_to_b = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:a:\") && e.to_key.as_ref().contains(\"fn:b:\")\n        );\n        assert!(a_to_b.is_some(), \"Should have a -> b edge\");\n\n        let b_to_c = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:b:\") && e.to_key.as_ref().contains(\"fn:c:\")\n        );\n        assert!(b_to_c.is_some(), \"Should have b -> c edge\");\n    }",
    "future_code": "    fn test_chained_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    a();\n}\n\nfn a() {\n    b();\n}\n\nfn b() {\n    c();\n}\n\nfn c() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->a, a->b, b->c\n        assert_eq!(dependencies.len(), 3);\n\n        // Verify the chain\n        let main_to_a = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"main\") && e.to_key.as_ref().contains(\"a\")\n        );\n        assert!(main_to_a.is_some(), \"Should have main -> a edge\");\n\n        let a_to_b = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:a:\") && e.to_key.as_ref().contains(\"fn:b:\")\n        );\n        assert!(a_to_b.is_some(), \"Should have a -> b edge\");\n\n        let b_to_c = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:b:\") && e.to_key.as_ref().contains(\"fn:c:\")\n        );\n        assert!(b_to_c.is_some(), \"Should have b -> c edge\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436297Z",
      "modified_at": "2025-11-01T15:29:24.436297Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_changes_grouped_by_file:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:178-239",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_changes_grouped_by_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 178,
        "end": 239
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_changes_grouped_by_file() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert multiple entities from same file\n    let entity1 = create_test_entity(\n        \"rust:fn:func_a:src_lib_rs:10-20\",\n        Some(\"fn func_a() {}\"),\n        Some(\"fn func_a_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    let entity2 = create_test_entity(\n        \"rust:fn:func_b:src_lib_rs:30-40\",\n        Some(\"fn func_b() {}\"),\n        Some(\"fn func_b_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    // Entity from different file\n    let entity3 = create_test_entity(\n        \"rust:fn:other:src_models_user_rs:50-60\",\n        Some(\"fn other() {}\"),\n        Some(\"fn other_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Changes should be grouped by file path\n    // Convert to file-grouped structure for validation\n    let grouped = group_changes_by_file(&diff.changes);\n\n    assert_eq!(grouped.len(), 2, \"Should have changes from 2 files\");\n\n    let lib_changes = grouped.get(&PathBuf::from(\"src/lib.rs\"));\n    assert!(lib_changes.is_some(), \"Should have changes for src/lib.rs\");\n    assert_eq!(\n        lib_changes.unwrap().len(),\n        2,\n        \"Should have 2 changes for src/lib.rs\"\n    );\n\n    let user_changes = grouped.get(&PathBuf::from(\"src/models/user.rs\"));\n    assert!(\n        user_changes.is_some(),\n        \"Should have changes for src/models/user.rs\"\n    );\n    assert_eq!(\n        user_changes.unwrap().len(),\n        1,\n        \"Should have 1 change for src/models/user.rs\"\n    );\n}",
    "future_code": "async fn test_changes_grouped_by_file() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert multiple entities from same file\n    let entity1 = create_test_entity(\n        \"rust:fn:func_a:src_lib_rs:10-20\",\n        Some(\"fn func_a() {}\"),\n        Some(\"fn func_a_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    let entity2 = create_test_entity(\n        \"rust:fn:func_b:src_lib_rs:30-40\",\n        Some(\"fn func_b() {}\"),\n        Some(\"fn func_b_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    // Entity from different file\n    let entity3 = create_test_entity(\n        \"rust:fn:other:src_models_user_rs:50-60\",\n        Some(\"fn other() {}\"),\n        Some(\"fn other_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Changes should be grouped by file path\n    // Convert to file-grouped structure for validation\n    let grouped = group_changes_by_file(&diff.changes);\n\n    assert_eq!(grouped.len(), 2, \"Should have changes from 2 files\");\n\n    let lib_changes = grouped.get(&PathBuf::from(\"src/lib.rs\"));\n    assert!(lib_changes.is_some(), \"Should have changes for src/lib.rs\");\n    assert_eq!(\n        lib_changes.unwrap().len(),\n        2,\n        \"Should have 2 changes for src/lib.rs\"\n    );\n\n    let user_changes = grouped.get(&PathBuf::from(\"src/models/user.rs\"));\n    assert!(\n        user_changes.is_some(),\n        \"Should have changes for src/models/user.rs\"\n    );\n    assert_eq!(\n        user_changes.unwrap().len(),\n        1,\n        \"Should have 1 change for src/models/user.rs\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436298Z",
      "modified_at": "2025-11-01T15:29:24.436299Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_circular_dependency_error:______crates_parseltongue-core_src_error_rs:221-229",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_circular_dependency_error",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 221,
        "end": 229
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_circular_dependency_error() {\n        let error = ParseltongError::CircularDependency {\n            path: \"A -> B -> C -> A\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Circular dependency detected\"));\n        assert!(formatted.contains(\"A -> B -> C -> A\"));\n    }",
    "future_code": "    fn test_circular_dependency_error() {\n        let error = ParseltongError::CircularDependency {\n            path: \"A -> B -> C -> A\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Circular dependency detected\"));\n        assert!(formatted.contains(\"A -> B -> C -> A\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436300Z",
      "modified_at": "2025-11-01T15:29:24.436300Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_claude_orchestrates_bug_fix_workflow:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:47-208",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_claude_orchestrates_bug_fix_workflow",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 47,
        "end": 208
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_claude_orchestrates_bug_fix_workflow() -> Result<()> {\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" CLAUDE CODE AS AGENT ORCHESTRATOR\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    // ========================================\n    // PHASE 0: SETUP - Create project with bug\n    // ========================================\n    println!(\"\\n PHASE 0: Setting up test project...\");\n    let test_project = create_test_project_with_subtraction_bug()?;\n    let project_path = test_project.path().to_path_buf();\n\n    println!(\" Created test project at: {:?}\", project_path);\n    println!(\"   Bug: 'add' function uses subtraction instead of addition\");\n\n    // ========================================\n    // PHASE 1: INDEX (Tool 1) - Scan codebase\n    // ========================================\n    println!(\"\\n PHASE 1: Indexing codebase (Tool 1)...\");\n    println!(\"    Claude Decision: Scan src/ directory to build code graph\");\n\n    let start_index = Instant::now();\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Simulate Tool 1 output\n    let indexed_entities = simulate_tool1_indexing(&project_path, &storage).await?;\n\n    println!(\" Indexed {} entities in {:?}\", indexed_entities.len(), start_index.elapsed());\n    for entity in &indexed_entities {\n        println!(\"   - {} ({:?})\", entity.isgl1_key, entity.interface_signature.entity_type);\n    }\n\n    // ========================================\n    // PHASE 2: REASONING (Tool 2) - Identify bug and propose fix\n    // ========================================\n    println!(\"\\n PHASE 2: LLM Reasoning and Change Proposal (Tool 2)...\");\n    println!(\"    Claude Analysis:\");\n    println!(\"      - Function 'add' has doc comment 'Calculate the sum'\");\n    println!(\"      - Implementation uses subtraction: a - b\");\n    println!(\"      - Test expects: add(2, 3) == 5\");\n    println!(\"      - Current output would be: -1\");\n    println!(\"    Claude Decision: Propose fix - change 'a - b' to 'a + b'\");\n\n    let mut storage_mut = storage;\n\n    // Find the add function entity\n    let add_entity = indexed_entities.iter()\n        .find(|e| e.isgl1_key.contains(\"add\"))\n        .expect(\"Should have indexed 'add' function\");\n\n    // Claude reasons about the fix\n    let fixed_code = generate_fixed_code();\n\n    // Apply temporal change (Tool 2 operation)\n    let mut modified_entity = add_entity.clone();\n    modified_entity.future_code = Some(fixed_code.clone());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n    modified_entity.temporal_state.future_ind = true;\n\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    println!(\" Temporal change recorded in CozoDB\");\n    println!(\"   - future_action: Edit\");\n    println!(\"   - future_code: Changed 'a - b' to 'a + b'\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: CONTEXT EXTRACTION (Tool 3) - Get context for validation\n    // ========================================\n    println!(\"\\n PHASE 3: Extracting context for validation (Tool 3)...\");\n    println!(\"    Claude Decision: Query changed entities for next reasoning cycle\");\n\n    let changed_entities = storage.get_changed_entities().await?;\n\n    println!(\" Extracted {} changed entities\", changed_entities.len());\n    println!(\"   Context includes:\");\n    println!(\"   - Current code (buggy version)\");\n    println!(\"   - Proposed code (fixed version)\");\n    println!(\"   - Interface signature\");\n    println!(\"   - Temporal state\");\n\n    // ========================================\n    // PHASE 4: VALIDATION (Tool 4) - Verify proposed changes\n    // ========================================\n    println!(\"\\n PHASE 4: Validating proposed changes (Tool 4)...\");\n    println!(\"    Claude Decision: Run preflight checks on proposed code\");\n\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n\n    // Syntax validation\n    print!(\"   - Syntax check: \");\n    let syntax_valid = validate_rust_syntax(future_code)?;\n    println!(\"{}\", if syntax_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Semantic validation\n    print!(\"   - Semantic check: \");\n    let semantic_valid = validate_semantics(future_code)?;\n    println!(\"{}\", if semantic_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Test simulation\n    print!(\"   - Test simulation: \");\n    let test_would_pass = simulate_test_execution(future_code)?;\n    println!(\"{}\", if test_would_pass { \" PASS\" } else { \" FAIL\" });\n\n    println!(\" All validation checks passed\");\n    println!(\"    Claude Decision: Proceed to write phase (confidence: 95%)\");\n\n    // ========================================\n    // PHASE 5: WRITING (Tool 5) - Apply validated changes\n    // ========================================\n    println!(\"\\n PHASE 5: Writing validated changes to files (Tool 5)...\");\n    println!(\"    Claude Decision: Write future_code to filesystem\");\n\n    let target_file = project_path.join(\"src/lib.rs\");\n    tokio::fs::write(&target_file, future_code).await?;\n\n    println!(\" Wrote changes to: {}\", target_file.display());\n    println!(\"   - Replaced 'a - b' with 'a + b'\");\n\n    // Verify the fix by running actual tests\n    println!(\"   Running actual cargo test...\");\n    let test_output = std::process::Command::new(\"cargo\")\n        .args(&[\"test\", \"--manifest-path\"])\n        .arg(project_path.join(\"Cargo.toml\"))\n        .output()?;\n\n    let test_passed = test_output.status.success();\n    println!(\"   Test result: {}\", if test_passed { \" PASS\" } else { \" FAIL\" });\n\n    assert!(test_passed, \"Tests should pass after bug fix\");\n\n    // ========================================\n    // PHASE 6: RESET (Tool 6) - Clean database state\n    // ========================================\n    println!(\"\\n PHASE 6: Resetting database state (Tool 6)...\");\n    println!(\"    Claude Decision: Drop CodeGraph table, ready for next cycle\");\n\n    // Simulate Tool 6 state reset\n    drop(storage); // Release database handle\n    println!(\" Database state reset complete\");\n\n    // ========================================\n    // FINAL SUMMARY\n    // ========================================\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" ORCHESTRATION COMPLETE - BUG FIXED!\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"\\n Orchestration Summary:\");\n    println!(\"    Phase 0: Test project setup\");\n    println!(\"    Phase 1: Codebase indexed (2 entities)\");\n    println!(\"    Phase 2: Bug identified and fix proposed\");\n    println!(\"    Phase 3: Context extracted for validation\");\n    println!(\"    Phase 4: All validation checks passed\");\n    println!(\"    Phase 5: Fix applied to filesystem\");\n    println!(\"    Phase 6: Database state reset\");\n    println!(\"\\n Claude Code successfully orchestrated the complete workflow!\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    Ok(())\n}",
    "future_code": "async fn test_claude_orchestrates_bug_fix_workflow() -> Result<()> {\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" CLAUDE CODE AS AGENT ORCHESTRATOR\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    // ========================================\n    // PHASE 0: SETUP - Create project with bug\n    // ========================================\n    println!(\"\\n PHASE 0: Setting up test project...\");\n    let test_project = create_test_project_with_subtraction_bug()?;\n    let project_path = test_project.path().to_path_buf();\n\n    println!(\" Created test project at: {:?}\", project_path);\n    println!(\"   Bug: 'add' function uses subtraction instead of addition\");\n\n    // ========================================\n    // PHASE 1: INDEX (Tool 1) - Scan codebase\n    // ========================================\n    println!(\"\\n PHASE 1: Indexing codebase (Tool 1)...\");\n    println!(\"    Claude Decision: Scan src/ directory to build code graph\");\n\n    let start_index = Instant::now();\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Simulate Tool 1 output\n    let indexed_entities = simulate_tool1_indexing(&project_path, &storage).await?;\n\n    println!(\" Indexed {} entities in {:?}\", indexed_entities.len(), start_index.elapsed());\n    for entity in &indexed_entities {\n        println!(\"   - {} ({:?})\", entity.isgl1_key, entity.interface_signature.entity_type);\n    }\n\n    // ========================================\n    // PHASE 2: REASONING (Tool 2) - Identify bug and propose fix\n    // ========================================\n    println!(\"\\n PHASE 2: LLM Reasoning and Change Proposal (Tool 2)...\");\n    println!(\"    Claude Analysis:\");\n    println!(\"      - Function 'add' has doc comment 'Calculate the sum'\");\n    println!(\"      - Implementation uses subtraction: a - b\");\n    println!(\"      - Test expects: add(2, 3) == 5\");\n    println!(\"      - Current output would be: -1\");\n    println!(\"    Claude Decision: Propose fix - change 'a - b' to 'a + b'\");\n\n    let mut storage_mut = storage;\n\n    // Find the add function entity\n    let add_entity = indexed_entities.iter()\n        .find(|e| e.isgl1_key.contains(\"add\"))\n        .expect(\"Should have indexed 'add' function\");\n\n    // Claude reasons about the fix\n    let fixed_code = generate_fixed_code();\n\n    // Apply temporal change (Tool 2 operation)\n    let mut modified_entity = add_entity.clone();\n    modified_entity.future_code = Some(fixed_code.clone());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n    modified_entity.temporal_state.future_ind = true;\n\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    println!(\" Temporal change recorded in CozoDB\");\n    println!(\"   - future_action: Edit\");\n    println!(\"   - future_code: Changed 'a - b' to 'a + b'\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: CONTEXT EXTRACTION (Tool 3) - Get context for validation\n    // ========================================\n    println!(\"\\n PHASE 3: Extracting context for validation (Tool 3)...\");\n    println!(\"    Claude Decision: Query changed entities for next reasoning cycle\");\n\n    let changed_entities = storage.get_changed_entities().await?;\n\n    println!(\" Extracted {} changed entities\", changed_entities.len());\n    println!(\"   Context includes:\");\n    println!(\"   - Current code (buggy version)\");\n    println!(\"   - Proposed code (fixed version)\");\n    println!(\"   - Interface signature\");\n    println!(\"   - Temporal state\");\n\n    // ========================================\n    // PHASE 4: VALIDATION (Tool 4) - Verify proposed changes\n    // ========================================\n    println!(\"\\n PHASE 4: Validating proposed changes (Tool 4)...\");\n    println!(\"    Claude Decision: Run preflight checks on proposed code\");\n\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n\n    // Syntax validation\n    print!(\"   - Syntax check: \");\n    let syntax_valid = validate_rust_syntax(future_code)?;\n    println!(\"{}\", if syntax_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Semantic validation\n    print!(\"   - Semantic check: \");\n    let semantic_valid = validate_semantics(future_code)?;\n    println!(\"{}\", if semantic_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Test simulation\n    print!(\"   - Test simulation: \");\n    let test_would_pass = simulate_test_execution(future_code)?;\n    println!(\"{}\", if test_would_pass { \" PASS\" } else { \" FAIL\" });\n\n    println!(\" All validation checks passed\");\n    println!(\"    Claude Decision: Proceed to write phase (confidence: 95%)\");\n\n    // ========================================\n    // PHASE 5: WRITING (Tool 5) - Apply validated changes\n    // ========================================\n    println!(\"\\n PHASE 5: Writing validated changes to files (Tool 5)...\");\n    println!(\"    Claude Decision: Write future_code to filesystem\");\n\n    let target_file = project_path.join(\"src/lib.rs\");\n    tokio::fs::write(&target_file, future_code).await?;\n\n    println!(\" Wrote changes to: {}\", target_file.display());\n    println!(\"   - Replaced 'a - b' with 'a + b'\");\n\n    // Verify the fix by running actual tests\n    println!(\"   Running actual cargo test...\");\n    let test_output = std::process::Command::new(\"cargo\")\n        .args(&[\"test\", \"--manifest-path\"])\n        .arg(project_path.join(\"Cargo.toml\"))\n        .output()?;\n\n    let test_passed = test_output.status.success();\n    println!(\"   Test result: {}\", if test_passed { \" PASS\" } else { \" FAIL\" });\n\n    assert!(test_passed, \"Tests should pass after bug fix\");\n\n    // ========================================\n    // PHASE 6: RESET (Tool 6) - Clean database state\n    // ========================================\n    println!(\"\\n PHASE 6: Resetting database state (Tool 6)...\");\n    println!(\"    Claude Decision: Drop CodeGraph table, ready for next cycle\");\n\n    // Simulate Tool 6 state reset\n    drop(storage); // Release database handle\n    println!(\" Database state reset complete\");\n\n    // ========================================\n    // FINAL SUMMARY\n    // ========================================\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" ORCHESTRATION COMPLETE - BUG FIXED!\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"\\n Orchestration Summary:\");\n    println!(\"    Phase 0: Test project setup\");\n    println!(\"    Phase 1: Codebase indexed (2 entities)\");\n    println!(\"    Phase 2: Bug identified and fix proposed\");\n    println!(\"    Phase 3: Context extracted for validation\");\n    println!(\"    Phase 4: All validation checks passed\");\n    println!(\"    Phase 5: Fix applied to filesystem\");\n    println!(\"    Phase 6: Database state reset\");\n    println!(\"\\n Claude Code successfully orchestrated the complete workflow!\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436301Z",
      "modified_at": "2025-11-01T15:29:24.436301Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_builds:______crates_parseltongue_src_main_rs:569-579",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_builds",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue/src/main.rs",
      "line_range": {
        "start": 569,
        "end": 579
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_builds() {\n        let cli = build_cli();\n        // Verify all subcommands are present with pt01-pt06 prefixes (PRDv2)\n        let subcommands: Vec<&str> = cli.get_subcommands().map(|cmd| cmd.get_name()).collect();\n        assert!(subcommands.contains(&\"pt01-folder-to-cozodb-streamer\"));\n        assert!(subcommands.contains(&\"pt02-llm-cozodb-to-context-writer\"));\n        assert!(subcommands.contains(&\"pt03-llm-to-cozodb-writer\"));\n        assert!(subcommands.contains(&\"pt04-syntax-preflight-validator\"));\n        assert!(subcommands.contains(&\"pt05-llm-cozodb-to-diff-writer\"));\n        assert!(subcommands.contains(&\"pt06-cozodb-make-future-code-current\"));\n    }",
    "future_code": "    fn test_cli_builds() {\n        let cli = build_cli();\n        // Verify all subcommands are present with pt01-pt06 prefixes (PRDv2)\n        let subcommands: Vec<&str> = cli.get_subcommands().map(|cmd| cmd.get_name()).collect();\n        assert!(subcommands.contains(&\"pt01-folder-to-cozodb-streamer\"));\n        assert!(subcommands.contains(&\"pt02-llm-cozodb-to-context-writer\"));\n        assert!(subcommands.contains(&\"pt03-llm-to-cozodb-writer\"));\n        assert!(subcommands.contains(&\"pt04-syntax-preflight-validator\"));\n        assert!(subcommands.contains(&\"pt05-llm-cozodb-to-diff-writer\"));\n        assert!(subcommands.contains(&\"pt06-cozodb-make-future-code-current\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436302Z",
      "modified_at": "2025-11-01T15:29:24.436302Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_config_parsing:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:122-146",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_config_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 122,
        "end": 146
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"/test/dir\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"/test/dir\"));\n        assert_eq!(config.db_path, \"test.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "future_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"/test/dir\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"/test/dir\"));\n        assert_eq!(config.db_path, \"test.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436303Z",
      "modified_at": "2025-11-01T15:29:24.436303Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_config_parsing:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:281-318",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_config_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 281,
        "end": 318
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--db\",\n            \"test.db\",\n            \"--endpoint\",\n            \"https://api.example.com/v1/chat\",\n            \"--api-key\",\n            \"test-key-123\",\n            \"--model\",\n            \"gpt-3.5-turbo\",\n            \"--max-tokens\",\n            \"4096\",\n            \"--temperature\",\n            \"0.2\",\n            \"--max-context-tokens\",\n            \"64000\",\n            \"--relevance-threshold\",\n            \"0.8\",\n            \"--output\",\n            \"./test_contexts\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.db_path, \"test.db\");\n        assert_eq!(config.llm_endpoint, \"https://api.example.com/v1/chat\");\n        assert_eq!(config.llm_api_key, \"test-key-123\");\n        assert_eq!(config.model, \"gpt-3.5-turbo\");\n        assert_eq!(config.max_tokens, 4096);\n        assert_eq!(config.temperature, 0.2);\n        assert_eq!(config.max_context_tokens, 64000);\n        assert_eq!(config.relevance_threshold, 0.8);\n        assert_eq!(config.output_dir, \"./test_contexts\");\n    }",
    "future_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--db\",\n            \"test.db\",\n            \"--endpoint\",\n            \"https://api.example.com/v1/chat\",\n            \"--api-key\",\n            \"test-key-123\",\n            \"--model\",\n            \"gpt-3.5-turbo\",\n            \"--max-tokens\",\n            \"4096\",\n            \"--temperature\",\n            \"0.2\",\n            \"--max-context-tokens\",\n            \"64000\",\n            \"--relevance-threshold\",\n            \"0.8\",\n            \"--output\",\n            \"./test_contexts\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.db_path, \"test.db\");\n        assert_eq!(config.llm_endpoint, \"https://api.example.com/v1/chat\");\n        assert_eq!(config.llm_api_key, \"test-key-123\");\n        assert_eq!(config.model, \"gpt-3.5-turbo\");\n        assert_eq!(config.max_tokens, 4096);\n        assert_eq!(config.temperature, 0.2);\n        assert_eq!(config.max_context_tokens, 64000);\n        assert_eq!(config.relevance_threshold, 0.8);\n        assert_eq!(config.output_dir, \"./test_contexts\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436305Z",
      "modified_at": "2025-11-01T15:29:24.436305Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_config_parsing:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:187-203",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_config_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 187,
        "end": 203
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[a] := [[1]]\",\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[a] := [[1]]\");\n        assert_eq!(config.db_path, \"test.db\");\n    }",
    "future_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[a] := [[1]]\",\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[a] := [[1]]\");\n        assert_eq!(config.db_path, \"test.db\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436306Z",
      "modified_at": "2025-11-01T15:29:24.436306Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_default_excludes_current_code:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:12-24",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_default_excludes_current_code",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 12,
        "end": 24
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_default_excludes_current_code() {\n    let cli = CliConfig::build_cli();\n\n    // Test default behavior (no flag provided)\n    let matches = cli.try_get_matches_from(&[\"parseltongue-03\"]);\n    assert!(matches.is_ok());\n\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Default is false (exclude Current_Code)\n    assert_eq!(include_current_code, false, \"Default should exclude Current_Code\");\n}",
    "future_code": "fn test_cli_default_excludes_current_code() {\n    let cli = CliConfig::build_cli();\n\n    // Test default behavior (no flag provided)\n    let matches = cli.try_get_matches_from(&[\"parseltongue-03\"]);\n    assert!(matches.is_ok());\n\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Default is false (exclude Current_Code)\n    assert_eq!(include_current_code, false, \"Default should exclude Current_Code\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436307Z",
      "modified_at": "2025-11-01T15:29:24.436307Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_include_current_code_disabled_explicit:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:47-62",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_include_current_code_disabled_explicit",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 47,
        "end": 62
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_include_current_code_disabled_explicit() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"0\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Flag=0 means exclude Current_Code\n    assert_eq!(include_current_code, false, \"Flag=0 should exclude Current_Code\");\n}",
    "future_code": "fn test_cli_include_current_code_disabled_explicit() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"0\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Flag=0 means exclude Current_Code\n    assert_eq!(include_current_code, false, \"Flag=0 should exclude Current_Code\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436308Z",
      "modified_at": "2025-11-01T15:29:24.436308Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_include_current_code_enabled:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:28-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_include_current_code_enabled",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 28,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_include_current_code_enabled() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"1\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Flag=1 means include Current_Code\n    assert_eq!(include_current_code, true, \"Flag=1 should include Current_Code\");\n}",
    "future_code": "fn test_cli_include_current_code_enabled() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"1\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n    let include_current_code = CliConfig::parse_include_current_code(&matches);\n\n    // Postcondition: Flag=1 means include Current_Code\n    assert_eq!(include_current_code, true, \"Flag=1 should include Current_Code\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436309Z",
      "modified_at": "2025-11-01T15:29:24.436309Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_mutual_exclusion:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:99-115",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_mutual_exclusion",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 99,
        "end": 115
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_mutual_exclusion() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    // Attempt to use both interfaces simultaneously\n    let result = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\", \"?[x] := [[1]]\",\n        \"--entity\", \"rust:fn:test:lib_rs:1-5\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"fn test() {}\",\n    ]);\n\n    // Error condition: Mutual exclusion violated\n    assert!(result.is_err(), \"Should reject both --query and --entity\");\n}",
    "future_code": "fn test_cli_mutual_exclusion() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    // Attempt to use both interfaces simultaneously\n    let result = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\", \"?[x] := [[1]]\",\n        \"--entity\", \"rust:fn:test:lib_rs:1-5\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"fn test() {}\",\n    ]);\n\n    // Error condition: Mutual exclusion violated\n    assert!(result.is_err(), \"Should reject both --query and --entity\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436310Z",
      "modified_at": "2025-11-01T15:29:24.436310Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_parsing:______crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:37-47",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "line_range": {
        "start": 37,
        "end": 47
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_parsing() {\n        let cli = Cli {\n            database: PathBuf::from(\"./parseltongue.db\"),\n            root: PathBuf::from(\"./project\"),\n            dry_run: false,\n            verbose: false,\n        };\n\n        assert_eq!(cli.database, PathBuf::from(\"./parseltongue.db\"));\n        assert_eq!(cli.root, PathBuf::from(\"./project\"));\n    }",
    "future_code": "    fn test_cli_parsing() {\n        let cli = Cli {\n            database: PathBuf::from(\"./parseltongue.db\"),\n            root: PathBuf::from(\"./project\"),\n            dry_run: false,\n            verbose: false,\n        };\n\n        assert_eq!(cli.database, PathBuf::from(\"./parseltongue.db\"));\n        assert_eq!(cli.root, PathBuf::from(\"./project\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436311Z",
      "modified_at": "2025-11-01T15:29:24.436311Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_parsing_default_db:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:72-86",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_parsing_default_db",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 72,
        "end": 86
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_parsing_default_db() {\n    let cli = CliConfig::build_cli();\n\n    // Test with only --query (should use default db)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[x] := [[42]]\",\n    ]);\n\n    assert!(matches.is_ok());\n\n    let config = CliConfig::parse_config(&matches.unwrap());\n    assert_eq!(config.db_path, \"parseltongue.db\", \"Should use default database path\");\n}",
    "future_code": "fn test_cli_parsing_default_db() {\n    let cli = CliConfig::build_cli();\n\n    // Test with only --query (should use default db)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[x] := [[42]]\",\n    ]);\n\n    assert!(matches.is_ok());\n\n    let config = CliConfig::parse_config(&matches.unwrap());\n    assert_eq!(config.db_path, \"parseltongue.db\", \"Should use default database path\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436312Z",
      "modified_at": "2025-11-01T15:29:24.436312Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_parsing_missing_query:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:90-101",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_parsing_missing_query",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 90,
        "end": 101
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_parsing_missing_query() {\n    let cli = CliConfig::build_cli();\n\n    // Test with missing --query (should fail)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--db\",\n        \"test.db\",\n    ]);\n\n    assert!(matches.is_err(), \"CLI should require --query argument\");\n}",
    "future_code": "fn test_cli_parsing_missing_query() {\n    let cli = CliConfig::build_cli();\n\n    // Test with missing --query (should fail)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--db\",\n        \"test.db\",\n    ]);\n\n    assert!(matches.is_err(), \"CLI should require --query argument\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436313Z",
      "modified_at": "2025-11-01T15:29:24.436313Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_parsing_query_interface:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:49-68",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_parsing_query_interface",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 49,
        "end": 68
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_parsing_query_interface() {\n    let cli = CliConfig::build_cli();\n\n    // Test with both arguments\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[a, b, c] := [[1, 2, 3]]\",\n        \"--db\",\n        \"rocksdb:test.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse valid arguments\");\n\n    let matches = matches.unwrap();\n    let config = CliConfig::parse_config(&matches);\n\n    assert_eq!(config.query, \"?[a, b, c] := [[1, 2, 3]]\");\n    assert_eq!(config.db_path, \"rocksdb:test.db\");\n}",
    "future_code": "fn test_cli_parsing_query_interface() {\n    let cli = CliConfig::build_cli();\n\n    // Test with both arguments\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[a, b, c] := [[1, 2, 3]]\",\n        \"--db\",\n        \"rocksdb:test.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse valid arguments\");\n\n    let matches = matches.unwrap();\n    let config = CliConfig::parse_config(&matches);\n\n    assert_eq!(config.query, \"?[a, b, c] := [[1, 2, 3]]\");\n    assert_eq!(config.db_path, \"rocksdb:test.db\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436314Z",
      "modified_at": "2025-11-01T15:29:24.436314Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_query_flag_support:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:178-201",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_query_flag_support",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 178,
        "end": 201
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_query_flag_support() {\n    use pt02_llm_cozodb_to_context_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches_from(&[\n        \"llm-cozodb-to-context-writer\",\n        \"--query\",\n        \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\",\n        \"--database\",\n        \"test.db\",\n        \"--output\",\n        \"context.json\",\n    ]);\n\n    // EXPECTATION: CLI should accept --query flag\n    // CURRENT: Will FAIL because --query flag doesn't exist in cli.rs\n    assert!(matches.is_ok(), \"CLI should accept --query flag\");\n\n    let matches = matches.unwrap();\n    assert_eq!(\n        matches.get_one::<String>(\"query\").unwrap(),\n        \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\"\n    );\n}",
    "future_code": "fn test_cli_query_flag_support() {\n    use pt02_llm_cozodb_to_context_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches_from(&[\n        \"llm-cozodb-to-context-writer\",\n        \"--query\",\n        \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\",\n        \"--database\",\n        \"test.db\",\n        \"--output\",\n        \"context.json\",\n    ]);\n\n    // EXPECTATION: CLI should accept --query flag\n    // CURRENT: Will FAIL because --query flag doesn't exist in cli.rs\n    assert!(matches.is_ok(), \"CLI should accept --query flag\");\n\n    let matches = matches.unwrap();\n    assert_eq!(\n        matches.get_one::<String>(\"query\").unwrap(),\n        \"SELECT * EXCEPT (Current_Code, Future_Code) FROM CodeGraph WHERE current_ind=1\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436316Z",
      "modified_at": "2025-11-01T15:29:24.436316Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_simple_interface_parsing:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:119-145",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_simple_interface_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 119,
        "end": 145
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_cli_simple_interface_parsing() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--entity\", \"rust:fn:hello:greeter_src_lib_rs:4-6\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"pub fn hello() -> &'static str { \\\"Hello!\\\" }\",\n        \"--db\", \"rocksdb:demo.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse simple interface\");\n\n    let matches = matches.unwrap();\n    let mode = CliConfig::parse_interface_mode(&matches);\n\n    match mode {\n        InterfaceMode::Simple(config) => {\n            assert_eq!(config.entity_key, \"rust:fn:hello:greeter_src_lib_rs:4-6\");\n            assert!(matches!(config.action, EntityAction::Edit));\n            assert_eq!(config.db_path, \"rocksdb:demo.db\");\n        }\n        _ => panic!(\"Expected Simple interface mode\"),\n    }\n}",
    "future_code": "fn test_cli_simple_interface_parsing() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--entity\", \"rust:fn:hello:greeter_src_lib_rs:4-6\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"pub fn hello() -> &'static str { \\\"Hello!\\\" }\",\n        \"--db\", \"rocksdb:demo.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse simple interface\");\n\n    let matches = matches.unwrap();\n    let mode = CliConfig::parse_interface_mode(&matches);\n\n    match mode {\n        InterfaceMode::Simple(config) => {\n            assert_eq!(config.entity_key, \"rust:fn:hello:greeter_src_lib_rs:4-6\");\n            assert!(matches!(config.action, EntityAction::Edit));\n            assert_eq!(config.db_path, \"rocksdb:demo.db\");\n        }\n        _ => panic!(\"Expected Simple interface mode\"),\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436317Z",
      "modified_at": "2025-11-01T15:29:24.436317Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_validation_requires_input:______crates_pt04-syntax-preflight-validator_src_cli_rs:73-84",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_validation_requires_input",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/cli.rs",
      "line_range": {
        "start": 73,
        "end": 84
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_validation_requires_input() {\n        // Create CLI without code snippet or file\n        let cli = Cli {\n            code_snippet: None,\n            file: None,\n            validation_type: ValidationTypeArg::All,\n            verbose: false,\n            output_format: OutputFormat::Text,\n        };\n\n        assert!(cli.validate().is_err());\n    }",
    "future_code": "    fn test_cli_validation_requires_input() {\n        // Create CLI without code snippet or file\n        let cli = Cli {\n            code_snippet: None,\n            file: None,\n            validation_type: ValidationTypeArg::All,\n            verbose: false,\n            output_format: OutputFormat::Text,\n        };\n\n        assert!(cli.validate().is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436318Z",
      "modified_at": "2025-11-01T15:29:24.436318Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cli_validation_with_code_snippet:______crates_pt04-syntax-preflight-validator_src_cli_rs:87-97",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cli_validation_with_code_snippet",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/cli.rs",
      "line_range": {
        "start": 87,
        "end": 97
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_cli_validation_with_code_snippet() {\n        let cli = Cli {\n            code_snippet: Some(\"fn main() {}\".to_string()),\n            file: None,\n            validation_type: ValidationTypeArg::Syntax,\n            verbose: false,\n            output_format: OutputFormat::Json,\n        };\n\n        assert!(cli.validate().is_ok());\n    }",
    "future_code": "    fn test_cli_validation_with_code_snippet() {\n        let cli = Cli {\n            code_snippet: Some(\"fn main() {}\".to_string()),\n            file: None,\n            validation_type: ValidationTypeArg::Syntax,\n            verbose: false,\n            output_format: OutputFormat::Json,\n        };\n\n        assert!(cli.validate().is_ok());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436319Z",
      "modified_at": "2025-11-01T15:29:24.436319Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_code_diff_json_output:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:190-214",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_code_diff_json_output",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 190,
        "end": 214
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_code_diff_json_output() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    let entity = create_test_entity(\n        \"src_lib_rs-test-fn-abc\",\n        Some(\"fn test() {}\"),\n        TemporalAction::Create,\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n\n    // Verify JSON structure\n    assert!(json.contains(\"\\\"changes\\\"\"));\n    assert!(json.contains(\"\\\"metadata\\\"\"));\n    assert!(json.contains(\"\\\"CREATE\\\"\"));\n    assert!(json.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json.contains(\"\\\"file_path\\\"\"));\n    assert!(json.contains(\"\\\"future_code\\\"\"));\n}",
    "future_code": "async fn test_code_diff_json_output() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    let entity = create_test_entity(\n        \"src_lib_rs-test-fn-abc\",\n        Some(\"fn test() {}\"),\n        TemporalAction::Create,\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n\n    // Verify JSON structure\n    assert!(json.contains(\"\\\"changes\\\"\"));\n    assert!(json.contains(\"\\\"metadata\\\"\"));\n    assert!(json.contains(\"\\\"CREATE\\\"\"));\n    assert!(json.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json.contains(\"\\\"file_path\\\"\"));\n    assert!(json.contains(\"\\\"future_code\\\"\"));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436321Z",
      "modified_at": "2025-11-01T15:29:24.436321Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_codegraph_repository_trait:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:172-186",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_codegraph_repository_trait",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 172,
        "end": 186
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_codegraph_repository_trait() {\n    // Test: CodeGraphRepository trait implementation\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n    let mut db: Box<dyn CodeGraphRepository> = Box::new(storage);\n\n    let entity = create_test_entity();\n\n    // Test trait methods\n    db.store_entity(entity.clone()).await.unwrap();\n\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().isgl1_key, \"test-file-rs-TestStruct\");\n}",
    "future_code": "async fn test_codegraph_repository_trait() {\n    // Test: CodeGraphRepository trait implementation\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n    let mut db: Box<dyn CodeGraphRepository> = Box::new(storage);\n\n    let entity = create_test_entity();\n\n    // Test trait methods\n    db.store_entity(entity.clone()).await.unwrap();\n\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().isgl1_key, \"test-file-rs-TestStruct\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436322Z",
      "modified_at": "2025-11-01T15:29:24.436322Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_complete_6_tool_workflow:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:41-185",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_complete_6_tool_workflow",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 41,
        "end": 185
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_complete_6_tool_workflow() -> Result<()> {\n    // ========================================\n    // SETUP: Create test project with bug\n    // ========================================\n    let test_project = create_test_rust_project_with_bug()?;\n\n    // ========================================\n    // PHASE 1: Tool 1 - Index codebase\n    // ========================================\n    println!(\"\\n Phase 1: Indexing codebase...\");\n    let start_indexing = Instant::now();\n\n    // Initialize database (use in-memory for tests)\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Index test project (simulating Tool 1 output)\n    let test_entity = create_indexed_entity_from_project(&test_project)?;\n    storage.insert_entity(&test_entity).await?;\n\n    let indexing_duration = start_indexing.elapsed();\n    println!(\" Indexed 1 entity in {:?}\", indexing_duration);\n\n    // **Contract**: Indexing should be fast (<1s for small project)\n    assert!(\n        indexing_duration.as_secs() < 1,\n        \"Indexing took {:?}, expected <1s for small project\",\n        indexing_duration\n    );\n\n    // **Contract**: Entity should exist with correct temporal state\n    let retrieved = storage.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // ========================================\n    // PHASE 2: Tool 2 - Apply temporal changes\n    // ========================================\n    println!(\"\\n  Phase 2: Applying temporal changes...\");\n\n    // Simulate LLM reasoning: Mark entity for modification\n    let mut modified_entity = retrieved.clone();\n    modified_entity.future_code = Some(get_fixed_code());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n\n    let mut storage_mut = storage;\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    // **Contract**: Temporal flags should be set correctly\n    let after_tool2 = storage_mut.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(after_tool2.temporal_state.current_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert!(after_tool2.future_code.is_some());\n    println!(\" Temporal state updated correctly\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: Tool 3 - Generate context\n    // ========================================\n    println!(\"\\n Phase 3: Generating context...\");\n    let start_context = Instant::now();\n\n    // Query entities with changes (simulating Tool 3)\n    let changed_entities = storage.get_changed_entities().await?;\n\n    let context_duration = start_context.elapsed();\n    println!(\" Generated context for {} entities in {:?}\",\n             changed_entities.len(), context_duration);\n\n    // **Contract**: Context generation should be fast (<100ms)\n    assert!(\n        context_duration.as_millis() < 100,\n        \"Context generation took {:?}, expected <100ms\",\n        context_duration\n    );\n\n    // **Contract**: Should only return changed entities\n    assert_eq!(changed_entities.len(), 1);\n    assert_eq!(changed_entities[0].temporal_state.future_action, Some(TemporalAction::Edit));\n\n    // ========================================\n    // PHASE 4: Tool 4 - Validate changes\n    // ========================================\n    println!(\"\\n Phase 4: Validating changes...\");\n\n    // Simulate validation (Tool 4 would run syntax/build/test checks)\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n    let validation_result = validate_rust_syntax(future_code)?;\n\n    println!(\" Validation passed: {:?}\", validation_result);\n\n    // **Contract**: Validation should pass for fixed code\n    assert!(validation_result.is_valid);\n    assert!(validation_result.errors.is_empty());\n\n    // ========================================\n    // PHASE 5: Tool 5 - Write files\n    // ========================================\n    println!(\"\\n Phase 5: Writing changes to files...\");\n\n    // Simulate file writing (Tool 5)\n    let file_path = test_project.path().join(\"src/lib.rs\");\n    tokio::fs::write(&file_path, future_code).await?;\n\n    println!(\" Written changes to {}\", file_path.display());\n\n    // **Contract**: File should exist and contain new code\n    let written_content = tokio::fs::read_to_string(&file_path).await?;\n    assert_eq!(written_content, *future_code);\n\n    // ========================================\n    // PHASE 6: Tool 6 - Reset state\n    // ========================================\n    println!(\"\\n Phase 6: Resetting database state...\");\n\n    // Simulate state reset (Tool 6 would delete table and re-index)\n    // In a real implementation, Tool 6 would:\n    // 1. Drop/delete the CodeGraph table\n    // 2. Recreate schema\n    // 3. Trigger Tool 1 to re-index\n    //\n    // For this test, we verify the workflow completes successfully\n    // The schema already exists from Phase 1, which is fine for this test\n\n    println!(\" Database state reset completed\");\n\n    // **Contract**: Workflow completed successfully through all 6 phases\n    // (In production, Tool 6 would reset the database and trigger Tool 1 re-indexing)\n\n    // ========================================\n    // FINAL VALIDATION\n    // ========================================\n    println!(\"\\n Complete 6-tool workflow PASSED!\");\n    println!(\"    Phase 1: Indexing\");\n    println!(\"    Phase 2: Temporal updates\");\n    println!(\"    Phase 3: Context generation\");\n    println!(\"    Phase 4: Validation\");\n    println!(\"    Phase 5: File writing\");\n    println!(\"    Phase 6: State reset\");\n\n    Ok(())\n}",
    "future_code": "async fn test_complete_6_tool_workflow() -> Result<()> {\n    // ========================================\n    // SETUP: Create test project with bug\n    // ========================================\n    let test_project = create_test_rust_project_with_bug()?;\n\n    // ========================================\n    // PHASE 1: Tool 1 - Index codebase\n    // ========================================\n    println!(\"\\n Phase 1: Indexing codebase...\");\n    let start_indexing = Instant::now();\n\n    // Initialize database (use in-memory for tests)\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Index test project (simulating Tool 1 output)\n    let test_entity = create_indexed_entity_from_project(&test_project)?;\n    storage.insert_entity(&test_entity).await?;\n\n    let indexing_duration = start_indexing.elapsed();\n    println!(\" Indexed 1 entity in {:?}\", indexing_duration);\n\n    // **Contract**: Indexing should be fast (<1s for small project)\n    assert!(\n        indexing_duration.as_secs() < 1,\n        \"Indexing took {:?}, expected <1s for small project\",\n        indexing_duration\n    );\n\n    // **Contract**: Entity should exist with correct temporal state\n    let retrieved = storage.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // ========================================\n    // PHASE 2: Tool 2 - Apply temporal changes\n    // ========================================\n    println!(\"\\n  Phase 2: Applying temporal changes...\");\n\n    // Simulate LLM reasoning: Mark entity for modification\n    let mut modified_entity = retrieved.clone();\n    modified_entity.future_code = Some(get_fixed_code());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n\n    let mut storage_mut = storage;\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    // **Contract**: Temporal flags should be set correctly\n    let after_tool2 = storage_mut.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(after_tool2.temporal_state.current_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert!(after_tool2.future_code.is_some());\n    println!(\" Temporal state updated correctly\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: Tool 3 - Generate context\n    // ========================================\n    println!(\"\\n Phase 3: Generating context...\");\n    let start_context = Instant::now();\n\n    // Query entities with changes (simulating Tool 3)\n    let changed_entities = storage.get_changed_entities().await?;\n\n    let context_duration = start_context.elapsed();\n    println!(\" Generated context for {} entities in {:?}\",\n             changed_entities.len(), context_duration);\n\n    // **Contract**: Context generation should be fast (<100ms)\n    assert!(\n        context_duration.as_millis() < 100,\n        \"Context generation took {:?}, expected <100ms\",\n        context_duration\n    );\n\n    // **Contract**: Should only return changed entities\n    assert_eq!(changed_entities.len(), 1);\n    assert_eq!(changed_entities[0].temporal_state.future_action, Some(TemporalAction::Edit));\n\n    // ========================================\n    // PHASE 4: Tool 4 - Validate changes\n    // ========================================\n    println!(\"\\n Phase 4: Validating changes...\");\n\n    // Simulate validation (Tool 4 would run syntax/build/test checks)\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n    let validation_result = validate_rust_syntax(future_code)?;\n\n    println!(\" Validation passed: {:?}\", validation_result);\n\n    // **Contract**: Validation should pass for fixed code\n    assert!(validation_result.is_valid);\n    assert!(validation_result.errors.is_empty());\n\n    // ========================================\n    // PHASE 5: Tool 5 - Write files\n    // ========================================\n    println!(\"\\n Phase 5: Writing changes to files...\");\n\n    // Simulate file writing (Tool 5)\n    let file_path = test_project.path().join(\"src/lib.rs\");\n    tokio::fs::write(&file_path, future_code).await?;\n\n    println!(\" Written changes to {}\", file_path.display());\n\n    // **Contract**: File should exist and contain new code\n    let written_content = tokio::fs::read_to_string(&file_path).await?;\n    assert_eq!(written_content, *future_code);\n\n    // ========================================\n    // PHASE 6: Tool 6 - Reset state\n    // ========================================\n    println!(\"\\n Phase 6: Resetting database state...\");\n\n    // Simulate state reset (Tool 6 would delete table and re-index)\n    // In a real implementation, Tool 6 would:\n    // 1. Drop/delete the CodeGraph table\n    // 2. Recreate schema\n    // 3. Trigger Tool 1 to re-index\n    //\n    // For this test, we verify the workflow completes successfully\n    // The schema already exists from Phase 1, which is fine for this test\n\n    println!(\" Database state reset completed\");\n\n    // **Contract**: Workflow completed successfully through all 6 phases\n    // (In production, Tool 6 would reset the database and trigger Tool 1 re-indexing)\n\n    // ========================================\n    // FINAL VALIDATION\n    // ========================================\n    println!(\"\\n Complete 6-tool workflow PASSED!\");\n    println!(\"    Phase 1: Indexing\");\n    println!(\"    Phase 2: Temporal updates\");\n    println!(\"    Phase 3: Context generation\");\n    println!(\"    Phase 4: Validation\");\n    println!(\"    Phase 5: File writing\");\n    println!(\"    Phase 6: State reset\");\n\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436323Z",
      "modified_at": "2025-11-01T15:29:24.436323Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_complete_reset_cycle:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:283-306",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_complete_reset_cycle",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 283,
        "end": 306
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_complete_reset_cycle() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Add entities\n        storage.insert_entity(&create_test_entity(\"entity-1\")).await.unwrap();\n        storage.insert_entity(&create_test_entity(\"entity-2\")).await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        // Execute reset\n        let result = manager.reset(&project_path).await.unwrap();\n\n        // Postconditions\n        assert!(result.success, \"Reset should succeed\");\n        assert!(result.schema_recreated, \"Schema should be recreated\");\n\n        // Verify entities deleted\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 0, \"All entities should be deleted\");\n    }",
    "future_code": "    async fn test_complete_reset_cycle() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Add entities\n        storage.insert_entity(&create_test_entity(\"entity-1\")).await.unwrap();\n        storage.insert_entity(&create_test_entity(\"entity-2\")).await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        // Execute reset\n        let result = manager.reset(&project_path).await.unwrap();\n\n        // Postconditions\n        assert!(result.success, \"Reset should succeed\");\n        assert!(result.schema_recreated, \"Schema should be recreated\");\n\n        // Verify entities deleted\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 0, \"All entities should be deleted\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436324Z",
      "modified_at": "2025-11-01T15:29:24.436324Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_config_integration_with_include_current_code:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:98-117",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_config_integration_with_include_current_code",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 98,
        "end": 117
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_config_integration_with_include_current_code() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--db\",\n        \"test.db\",\n        \"--include-current-code\",\n        \"1\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n\n    let config = CliConfig::parse_config(&matches);\n    let include_flag = CliConfig::parse_include_current_code(&matches);\n\n    assert_eq!(config.db_path, \"test.db\");\n    assert_eq!(include_flag, true);\n}",
    "future_code": "fn test_config_integration_with_include_current_code() {\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--db\",\n        \"test.db\",\n        \"--include-current-code\",\n        \"1\",\n    ]);\n\n    assert!(matches.is_ok());\n    let matches = matches.unwrap();\n\n    let config = CliConfig::parse_config(&matches);\n    let include_flag = CliConfig::parse_include_current_code(&matches);\n\n    assert_eq!(config.db_path, \"test.db\");\n    assert_eq!(include_flag, true);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436325Z",
      "modified_at": "2025-11-01T15:29:24.436325Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_config_validation:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:413-423",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_config_validation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 413,
        "end": 423
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_config_validation() {\n        let mut config = crate::ContextWriterConfig::default();\n        config.llm_api_key = \"test-key\".to_string();\n\n        let client = ContextLlmClientImpl::new(config);\n        assert!(client.validate_config().is_ok());\n\n        let invalid_config = crate::ContextWriterConfig::default();\n        let invalid_client = ContextLlmClientImpl::new(invalid_config);\n        assert!(invalid_client.validate_config().is_err());\n    }",
    "future_code": "    fn test_config_validation() {\n        let mut config = crate::ContextWriterConfig::default();\n        config.llm_api_key = \"test-key\".to_string();\n\n        let client = ContextLlmClientImpl::new(config);\n        assert!(client.validate_config().is_ok());\n\n        let invalid_config = crate::ContextWriterConfig::default();\n        let invalid_client = ContextLlmClientImpl::new(invalid_config);\n        assert!(invalid_client.validate_config().is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436326Z",
      "modified_at": "2025-11-01T15:29:24.436327Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_configuration_validation:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:256-282",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_configuration_validation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 256,
        "end": 282
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_configuration_validation() {\n        // Test with valid configuration\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"valid-api-key\".to_string(),\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 10\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: \"./contexts\".to_string(),\n        };\n\n        let client = ToolFactory::create_llm_client(config);\n        assert!(client.validate_config().is_ok());\n\n        // Test with invalid configuration\n        let invalid_config = ContextWriterConfig {\n            llm_api_key: \"\".to_string(), // Invalid: empty\n            ..ContextWriterConfig::default()\n        };\n\n        let invalid_client = ToolFactory::create_llm_client(invalid_config);\n        assert!(invalid_client.validate_config().is_err());\n    }",
    "future_code": "    fn test_configuration_validation() {\n        // Test with valid configuration\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"valid-api-key\".to_string(),\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 10\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: \"./contexts\".to_string(),\n        };\n\n        let client = ToolFactory::create_llm_client(config);\n        assert!(client.validate_config().is_ok());\n\n        // Test with invalid configuration\n        let invalid_config = ContextWriterConfig {\n            llm_api_key: \"\".to_string(), // Invalid: empty\n            ..ContextWriterConfig::default()\n        };\n\n        let invalid_client = ToolFactory::create_llm_client(invalid_config);\n        assert!(invalid_client.validate_config().is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436328Z",
      "modified_at": "2025-11-01T15:29:24.436328Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_context_excludes_code_fields:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:74-129",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_context_excludes_code_fields",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 74,
        "end": 129
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_context_excludes_code_fields() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:sample:src_lib_rs:1-10\",\n        Some(\"fn sample() { println!(\\\"This should NOT appear in context\\\"); }\"),\n        TemporalState::unchanged(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let _result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // Read generated JSON file\n    let json_content = std::fs::read_to_string(&output_path).expect(\"Failed to read output file\");\n\n    // EXPECTATION: JSON should NOT contain current_code or future_code fields\n    // CURRENT: Will FAIL because implementation includes current_code in llm_client.rs:253\n    assert!(\n        !json_content.contains(\"\\\"current_code\\\"\"),\n        \"Output JSON must NOT contain current_code field\"\n    );\n    assert!(\n        !json_content.contains(\"\\\"future_code\\\"\"),\n        \"Output JSON must NOT contain future_code field\"\n    );\n\n    // Should contain required fields\n    assert!(\n        json_content.contains(\"\\\"isgl1_key\\\"\"),\n        \"Output must contain isgl1_key\"\n    );\n    assert!(\n        json_content.contains(\"\\\"interface_signature\\\"\"),\n        \"Output must contain interface_signature\"\n    );\n}",
    "future_code": "async fn test_context_excludes_code_fields() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:sample:src_lib_rs:1-10\",\n        Some(\"fn sample() { println!(\\\"This should NOT appear in context\\\"); }\"),\n        TemporalState::unchanged(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let _result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // Read generated JSON file\n    let json_content = std::fs::read_to_string(&output_path).expect(\"Failed to read output file\");\n\n    // EXPECTATION: JSON should NOT contain current_code or future_code fields\n    // CURRENT: Will FAIL because implementation includes current_code in llm_client.rs:253\n    assert!(\n        !json_content.contains(\"\\\"current_code\\\"\"),\n        \"Output JSON must NOT contain current_code field\"\n    );\n    assert!(\n        !json_content.contains(\"\\\"future_code\\\"\"),\n        \"Output JSON must NOT contain future_code field\"\n    );\n\n    // Should contain required fields\n    assert!(\n        json_content.contains(\"\\\"isgl1_key\\\"\"),\n        \"Output must contain isgl1_key\"\n    );\n    assert!(\n        json_content.contains(\"\\\"interface_signature\\\"\"),\n        \"Output must contain interface_signature\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436329Z",
      "modified_at": "2025-11-01T15:29:24.436329Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_context_generation:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:543-560",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_context_generation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 543,
        "end": 560
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_context_generation() {\n        // Create in-memory storage for testing\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        let storage = Arc::new(storage);\n\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        let temp_dir = tempfile::tempdir().unwrap();\n        let output_path = temp_dir.path().join(\"test_context.json\").to_string_lossy().to_string();\n\n        // Test with real CozoDB (empty database)\n        let result = optimizer.generate_context(&output_path).await;\n        // Should succeed with 0 entities\n        assert!(result.is_ok());\n    }",
    "future_code": "    async fn test_context_generation() {\n        // Create in-memory storage for testing\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        let storage = Arc::new(storage);\n\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        let temp_dir = tempfile::tempdir().unwrap();\n        let output_path = temp_dir.path().join(\"test_context.json\").to_string_lossy().to_string();\n\n        // Test with real CozoDB (empty database)\n        let result = optimizer.generate_context(&output_path).await;\n        // Should succeed with 0 entities\n        assert!(result.is_ok());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436330Z",
      "modified_at": "2025-11-01T15:29:24.436330Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_context_request_creation:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:426-437",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_context_request_creation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 426,
        "end": 437
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_context_request_creation() {\n        let request = ContextOptimizationRequest {\n            entities: vec![],\n            relationships: vec![],\n            target_context_size: 1000,\n            focus_areas: vec![\"types\".to_string()],\n            optimization_goals: vec![OptimizationGoal::MinimizeSize],\n        };\n\n        assert_eq!(request.target_context_size, 1000);\n        assert_eq!(request.focus_areas.len(), 1);\n    }",
    "future_code": "    fn test_context_request_creation() {\n        let request = ContextOptimizationRequest {\n            entities: vec![],\n            relationships: vec![],\n            target_context_size: 1000,\n            focus_areas: vec![\"types\".to_string()],\n            optimization_goals: vec![OptimizationGoal::MinimizeSize],\n        };\n\n        assert_eq!(request.target_context_size, 1000);\n        assert_eq!(request.focus_areas.len(), 1);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436332Z",
      "modified_at": "2025-11-01T15:29:24.436332Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_cozo_connection:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:43-49",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_cozo_connection",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 43,
        "end": 49
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_cozo_connection() {\n    // Test: Real CozoDB connection works\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    // Create schema first to ensure database is properly initialized\n    db.create_schema().await.unwrap();\n    assert!(db.is_connected().await);\n}",
    "future_code": "async fn test_cozo_connection() {\n    // Test: Real CozoDB connection works\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    // Create schema first to ensure database is properly initialized\n    db.create_schema().await.unwrap();\n    assert!(db.is_connected().await);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436333Z",
      "modified_at": "2025-11-01T15:29:24.436333Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_create_action_generates_datalog:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:12-30",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_create_action_generates_datalog",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 12,
        "end": 30
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_create_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog:\\n{}\", datalog);\n\n    // Postcondition: current_ind=0, future_ind=1, Future_Action=\"Create\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"current_ind: false\") || datalog.contains(\"false\"), \"Missing current_ind=false\");\n    assert!(datalog.contains(\"future_ind: true\") || datalog.contains(\"true\"), \"Missing future_ind=true\");\n    assert!(datalog.contains(\"Future_Action: \\\"Create\\\"\") || datalog.contains(\"\\\"Create\\\"\"), \"Missing Future_Action\");\n    assert!(datalog.contains(\"rust:fn:new_func:src_lib_rs:10-15\"));\n    assert!(datalog.contains(\"pub fn new_func() {}\"));\n}",
    "future_code": "fn test_create_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog:\\n{}\", datalog);\n\n    // Postcondition: current_ind=0, future_ind=1, Future_Action=\"Create\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"current_ind: false\") || datalog.contains(\"false\"), \"Missing current_ind=false\");\n    assert!(datalog.contains(\"future_ind: true\") || datalog.contains(\"true\"), \"Missing future_ind=true\");\n    assert!(datalog.contains(\"Future_Action: \\\"Create\\\"\") || datalog.contains(\"\\\"Create\\\"\"), \"Missing Future_Action\");\n    assert!(datalog.contains(\"rust:fn:new_func:src_lib_rs:10-15\"));\n    assert!(datalog.contains(\"pub fn new_func() {}\"));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436334Z",
      "modified_at": "2025-11-01T15:29:24.436334Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_create_code_graph_schema:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:52-60",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_create_code_graph_schema",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 52,
        "end": 60
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_create_code_graph_schema() {\n    // RED: Schema creation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Verify CodeGraph relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n}",
    "future_code": "async fn test_create_code_graph_schema() {\n    // RED: Schema creation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Verify CodeGraph relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436335Z",
      "modified_at": "2025-11-01T15:29:24.436335Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_create_dependency_edges_schema:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:191-205",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_create_dependency_edges_schema",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 191,
        "end": 205
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_create_dependency_edges_schema() {\n    // RED: DependencyEdges schema creation not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify DependencyEdges relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(\n        relations.contains(&\"DependencyEdges\".to_string()),\n        \"DependencyEdges table should exist after schema creation. Found: {:?}\",\n        relations\n    );\n}",
    "future_code": "async fn test_create_dependency_edges_schema() {\n    // RED: DependencyEdges schema creation not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify DependencyEdges relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(\n        relations.contains(&\"DependencyEdges\".to_string()),\n        \"DependencyEdges table should exist after schema creation. Found: {:?}\",\n        relations\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436336Z",
      "modified_at": "2025-11-01T15:29:24.436336Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_create_new_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:163-182",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_create_new_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 163,
        "end": 182
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_create_new_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n\n        let entity = create_test_entity(\n            \"src-utils-rs-helper_function\",\n            Some(\"fn helper() {}\".to_string()),\n            TemporalState::create(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n\n        let file_path = temp_dir.path().join(\"src/utils.rs\");\n        assert!(file_path.exists());\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn helper() {}\");\n    }",
    "future_code": "    async fn test_create_new_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n\n        let entity = create_test_entity(\n            \"src-utils-rs-helper_function\",\n            Some(\"fn helper() {}\".to_string()),\n            TemporalState::create(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n\n        let file_path = temp_dir.path().join(\"src/utils.rs\");\n        assert!(file_path.exists());\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn helper() {}\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436337Z",
      "modified_at": "2025-11-01T15:29:24.436337Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_create_requires_future_code:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:72-81",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_create_requires_future_code",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 72,
        "end": 81
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_create_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: None, // ERROR: Create requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
    "future_code": "fn test_create_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: None, // ERROR: Create requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436338Z",
      "modified_at": "2025-11-01T15:29:24.436338Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_default_config:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:149-171",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_default_config",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 149,
        "end": 171
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \".\",  // Directory is now required (positional argument)\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI defaults\n        assert_eq!(config.root_dir, PathBuf::from(\".\"));\n        assert_eq!(config.db_path, \"mem\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "future_code": "    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \".\",  // Directory is now required (positional argument)\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI defaults\n        assert_eq!(config.root_dir, PathBuf::from(\".\"));\n        assert_eq!(config.db_path, \"mem\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436339Z",
      "modified_at": "2025-11-01T15:29:24.436339Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_default_config:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:355-371",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_default_config",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 355,
        "end": 371
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\"parseltongue-03\"]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.db_path, \"parseltongue.db\");\n        assert_eq!(config.llm_endpoint, \"https://api.openai.com/v1/chat/completions\");\n        assert_eq!(config.model, \"gpt-4\");\n        assert_eq!(config.max_tokens, 8192);\n        assert_eq!(config.temperature, 0.3);\n        assert_eq!(config.max_context_tokens, 128000);\n        assert_eq!(config.relevance_threshold, 0.7);\n        assert_eq!(config.output_dir, \"./contexts\");\n    }",
    "future_code": "    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\"parseltongue-03\"]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.db_path, \"parseltongue.db\");\n        assert_eq!(config.llm_endpoint, \"https://api.openai.com/v1/chat/completions\");\n        assert_eq!(config.model, \"gpt-4\");\n        assert_eq!(config.max_tokens, 8192);\n        assert_eq!(config.temperature, 0.3);\n        assert_eq!(config.max_context_tokens, 128000);\n        assert_eq!(config.relevance_threshold, 0.7);\n        assert_eq!(config.output_dir, \"./contexts\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436340Z",
      "modified_at": "2025-11-01T15:29:24.436340Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_default_db_path:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:206-220",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_default_db_path",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 206,
        "end": 220
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_default_db_path() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[b] := [[2]]\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[b] := [[2]]\");\n        assert_eq!(config.db_path, \"parseltongue.db\"); // Default value\n    }",
    "future_code": "    fn test_default_db_path() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[b] := [[2]]\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[b] := [[2]]\");\n        assert_eq!(config.db_path, \"parseltongue.db\"); // Default value\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436341Z",
      "modified_at": "2025-11-01T15:29:24.436341Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_delete_action_generates_datalog:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:52-67",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_delete_action_generates_datalog",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 52,
        "end": 67
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_delete_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:old_func:src_lib_rs:20-25\".to_string(),\n        action: EntityAction::Delete,\n        future_code: None, // Optional for Delete\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=0, Future_Action=\"Delete\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing current_ind=true\");\n    assert!(datalog.contains(\"false\"), \"Missing future_ind=false\");\n    assert!(datalog.contains(\"\\\"Delete\\\"\"), \"Missing Delete action\");\n}",
    "future_code": "fn test_delete_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:old_func:src_lib_rs:20-25\".to_string(),\n        action: EntityAction::Delete,\n        future_code: None, // Optional for Delete\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=0, Future_Action=\"Delete\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing current_ind=true\");\n    assert!(datalog.contains(\"false\"), \"Missing future_ind=false\");\n    assert!(datalog.contains(\"\\\"Delete\\\"\"), \"Missing Delete action\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436343Z",
      "modified_at": "2025-11-01T15:29:24.436343Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_delete_codegraph_table_removes_all_entities:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:135-165",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_delete_codegraph_table_removes_all_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 135,
        "end": 165
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_delete_codegraph_table_removes_all_entities() {\n        // Setup: Create database with test entities\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Insert 3 test entities\n        let entities = vec![\n            create_test_entity(\"test-1\"),\n            create_test_entity(\"test-2\"),\n            create_test_entity(\"test-3\"),\n        ];\n        for entity in &entities {\n            storage.insert_entity(entity).await.unwrap();\n        }\n\n        let before_count = storage.get_all_entities().await.unwrap().len();\n        assert_eq!(before_count, 3, \"Precondition: Should have 3 entities\");\n\n        // Execute: Delete table\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n        assert!(result.is_ok(), \"Delete operation should succeed\");\n\n        // Postcondition: Verify ALL entities deleted\n        let after_count = manager.storage.get_all_entities().await.unwrap().len();\n        assert_eq!(\n            after_count, 0,\n            \"Postcondition: Should have 0 entities after deletion, found {}\",\n            after_count\n        );\n    }",
    "future_code": "    async fn test_delete_codegraph_table_removes_all_entities() {\n        // Setup: Create database with test entities\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Insert 3 test entities\n        let entities = vec![\n            create_test_entity(\"test-1\"),\n            create_test_entity(\"test-2\"),\n            create_test_entity(\"test-3\"),\n        ];\n        for entity in &entities {\n            storage.insert_entity(entity).await.unwrap();\n        }\n\n        let before_count = storage.get_all_entities().await.unwrap().len();\n        assert_eq!(before_count, 3, \"Precondition: Should have 3 entities\");\n\n        // Execute: Delete table\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n        assert!(result.is_ok(), \"Delete operation should succeed\");\n\n        // Postcondition: Verify ALL entities deleted\n        let after_count = manager.storage.get_all_entities().await.unwrap().len();\n        assert_eq!(\n            after_count, 0,\n            \"Postcondition: Should have 0 entities after deletion, found {}\",\n            after_count\n        );\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436344Z",
      "modified_at": "2025-11-01T15:29:24.436344Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_delete_empty_table_succeeds:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:176-190",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_delete_empty_table_succeeds",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 176,
        "end": 190
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_delete_empty_table_succeeds() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Verify empty\n        let before = storage.get_all_entities().await.unwrap();\n        assert_eq!(before.len(), 0, \"Precondition: Database should be empty\");\n\n        // Execute\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n\n        // Postcondition: Should succeed\n        assert!(result.is_ok(), \"Delete on empty table should succeed\");\n    }",
    "future_code": "    async fn test_delete_empty_table_succeeds() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Verify empty\n        let before = storage.get_all_entities().await.unwrap();\n        assert_eq!(before.len(), 0, \"Precondition: Database should be empty\");\n\n        // Execute\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n\n        // Postcondition: Should succeed\n        assert!(result.is_ok(), \"Delete on empty table should succeed\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436345Z",
      "modified_at": "2025-11-01T15:29:24.436345Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_delete_entity:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:154-169",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_delete_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 154,
        "end": 169
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_delete_entity() {\n    // RED: Delete operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Delete entity\n    db.delete_entity(\"test-file-rs-TestStruct\").await.unwrap();\n\n    // Verify deletion - should return None\n    let result = db.get_entity(\"test-file-rs-TestStruct\").await;\n    assert!(result.is_err() || result.unwrap().isgl1_key.is_empty());\n}",
    "future_code": "async fn test_delete_entity() {\n    // RED: Delete operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Delete entity\n    db.delete_entity(\"test-file-rs-TestStruct\").await.unwrap();\n\n    // Verify deletion - should return None\n    let result = db.get_entity(\"test-file-rs-TestStruct\").await;\n    assert!(result.is_err() || result.unwrap().isgl1_key.is_empty());\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436346Z",
      "modified_at": "2025-11-01T15:29:24.436346Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_delete_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:213-236",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_delete_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 213,
        "end": 236
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_delete_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/delete_me.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn to_delete() {}\")\n            .await\n            .unwrap();\n        assert!(file_path.exists());\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-delete_me-rs-ToDelete\",\n            None,\n            TemporalState::delete(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Delete);\n        assert!(!file_path.exists());\n    }",
    "future_code": "    async fn test_delete_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/delete_me.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn to_delete() {}\")\n            .await\n            .unwrap();\n        assert!(file_path.exists());\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-delete_me-rs-ToDelete\",\n            None,\n            TemporalState::delete(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Delete);\n        assert!(!file_path.exists());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436347Z",
      "modified_at": "2025-11-01T15:29:24.436347Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_builder:______crates_parseltongue-core_src_entities_rs:1453-1465",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_builder",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1453,
        "end": 1465
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_builder() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n        assert_eq!(edge.source_location, None);\n    }",
    "future_code": "    fn test_dependency_edge_builder() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n        assert_eq!(edge.source_location, None);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436349Z",
      "modified_at": "2025-11-01T15:29:24.436349Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_builder_missing_field:______crates_parseltongue-core_src_entities_rs:1481-1505",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_builder_missing_field",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1481,
        "end": 1505
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_builder_missing_field() {\n        // Missing to_key\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when to_key is missing\");\n\n        // Missing from_key\n        let result = DependencyEdge::builder()\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when from_key is missing\");\n\n        // Missing edge_type\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .build();\n\n        assert!(result.is_err(), \"Should fail when edge_type is missing\");\n    }",
    "future_code": "    fn test_dependency_edge_builder_missing_field() {\n        // Missing to_key\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when to_key is missing\");\n\n        // Missing from_key\n        let result = DependencyEdge::builder()\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when from_key is missing\");\n\n        // Missing edge_type\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .build();\n\n        assert!(result.is_err(), \"Should fail when edge_type is missing\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436350Z",
      "modified_at": "2025-11-01T15:29:24.436350Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_builder_with_location:______crates_parseltongue-core_src_entities_rs:1468-1478",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_builder_with_location",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1468,
        "end": 1478
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_builder_with_location() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_main_rs:20-30\")\n            .edge_type(EdgeType::Calls)\n            .source_location(\"src/main.rs:5\")\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.source_location, Some(\"src/main.rs:5\".to_string()));\n    }",
    "future_code": "    fn test_dependency_edge_builder_with_location() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_main_rs:20-30\")\n            .edge_type(EdgeType::Calls)\n            .source_location(\"src/main.rs:5\")\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.source_location, Some(\"src/main.rs:5\".to_string()));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436351Z",
      "modified_at": "2025-11-01T15:29:24.436351Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_new:______crates_parseltongue-core_src_entities_rs:1508-1520",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_new",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1508,
        "end": 1520
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_new() {\n        let edge = DependencyEdge::new(\n            \"from\",\n            \"to\",\n            EdgeType::Uses,\n            Some(\"location\".to_string()),\n        ).unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Uses);\n        assert_eq!(edge.source_location, Some(\"location\".to_string()));\n    }",
    "future_code": "    fn test_dependency_edge_new() {\n        let edge = DependencyEdge::new(\n            \"from\",\n            \"to\",\n            EdgeType::Uses,\n            Some(\"location\".to_string()),\n        ).unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Uses);\n        assert_eq!(edge.source_location, Some(\"location\".to_string()));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436352Z",
      "modified_at": "2025-11-01T15:29:24.436352Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_rejects_empty_keys:______crates_parseltongue-core_src_entities_rs:1523-1541",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_rejects_empty_keys",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1523,
        "end": 1541
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_rejects_empty_keys() {\n        // Empty from_key\n        let result = DependencyEdge::new(\n            \"\",\n            \"to\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty from_key\");\n\n        // Empty to_key\n        let result = DependencyEdge::new(\n            \"from\",\n            \"\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty to_key\");\n    }",
    "future_code": "    fn test_dependency_edge_rejects_empty_keys() {\n        // Empty from_key\n        let result = DependencyEdge::new(\n            \"\",\n            \"to\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty from_key\");\n\n        // Empty to_key\n        let result = DependencyEdge::new(\n            \"from\",\n            \"\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty to_key\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436353Z",
      "modified_at": "2025-11-01T15:29:24.436353Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edge_serialization:______crates_parseltongue-core_src_entities_rs:1544-1557",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edge_serialization",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1544,
        "end": 1557
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_edge_serialization() {\n        // Test that DependencyEdge can be serialized/deserialized\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        let json = serde_json::to_string(&edge).unwrap();\n        let deserialized: DependencyEdge = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, edge);\n    }",
    "future_code": "    fn test_dependency_edge_serialization() {\n        // Test that DependencyEdge can be serialized/deserialized\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        let json = serde_json::to_string(&edge).unwrap();\n        let deserialized: DependencyEdge = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, edge);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436354Z",
      "modified_at": "2025-11-01T15:29:24.436354Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_edges_schema_is_idempotent:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:208-234",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_edges_schema_is_idempotent",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 208,
        "end": 234
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_dependency_edges_schema_is_idempotent() {\n    // Test: Schema creation should be idempotent (can call multiple times)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema twice\n    db.create_dependency_edges_schema().await.unwrap();\n    let result = db.create_dependency_edges_schema().await;\n\n    // CozoDB may error on duplicate :create - this is expected behavior\n    // The important thing is the schema exists after first call\n    match result {\n        Ok(_) => {\n            // Some CozoDB versions allow duplicate creates\n            println!(\"CozoDB allows duplicate schema creation\");\n        }\n        Err(e) => {\n            // Most CozoDB versions error on duplicate creates - this is expected\n            println!(\"CozoDB errored on duplicate create (expected): {}\", e);\n            // Verify schema still exists despite error\n            let relations = db.list_relations().await.unwrap();\n            assert!(\n                relations.contains(&\"DependencyEdges\".to_string()),\n                \"Schema should still exist even if second create errors\"\n            );\n        }\n    }\n}",
    "future_code": "async fn test_dependency_edges_schema_is_idempotent() {\n    // Test: Schema creation should be idempotent (can call multiple times)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema twice\n    db.create_dependency_edges_schema().await.unwrap();\n    let result = db.create_dependency_edges_schema().await;\n\n    // CozoDB may error on duplicate :create - this is expected behavior\n    // The important thing is the schema exists after first call\n    match result {\n        Ok(_) => {\n            // Some CozoDB versions allow duplicate creates\n            println!(\"CozoDB allows duplicate schema creation\");\n        }\n        Err(e) => {\n            // Most CozoDB versions error on duplicate creates - this is expected\n            println!(\"CozoDB errored on duplicate create (expected): {}\", e);\n            // Verify schema still exists despite error\n            let relations = db.list_relations().await.unwrap();\n            assert!(\n                relations.contains(&\"DependencyEdges\".to_string()),\n                \"Schema should still exist even if second create errors\"\n            );\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436355Z",
      "modified_at": "2025-11-01T15:29:24.436355Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_error_formatting:______crates_parseltongue-core_src_error_rs:208-218",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_error_formatting",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 208,
        "end": 218
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_error_formatting() {\n        let error = ParseltongError::DependencyError {\n            operation: \"insert_edge\".to_string(),\n            reason: \"source entity does not exist\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency error\"));\n        assert!(formatted.contains(\"insert_edge\"));\n        assert!(formatted.contains(\"source entity does not exist\"));\n    }",
    "future_code": "    fn test_dependency_error_formatting() {\n        let error = ParseltongError::DependencyError {\n            operation: \"insert_edge\".to_string(),\n            reason: \"source entity does not exist\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency error\"));\n        assert!(formatted.contains(\"insert_edge\"));\n        assert!(formatted.contains(\"source entity does not exist\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436356Z",
      "modified_at": "2025-11-01T15:29:24.436356Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_dependency_error_is_error_trait:______crates_parseltongue-core_src_error_rs:261-269",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_dependency_error_is_error_trait",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 261,
        "end": 269
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_dependency_error_is_error_trait() {\n        let error = ParseltongError::DependencyError {\n            operation: \"query_dependencies\".to_string(),\n            reason: \"invalid hop count\".to_string(),\n        };\n\n        // Verify it implements std::error::Error\n        let _: &dyn std::error::Error = &error;\n    }",
    "future_code": "    fn test_dependency_error_is_error_trait() {\n        let error = ParseltongError::DependencyError {\n            operation: \"query_dependencies\".to_string(),\n            reason: \"invalid hop count\".to_string(),\n        };\n\n        // Verify it implements std::error::Error\n        let _: &dyn std::error::Error = &error;\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436357Z",
      "modified_at": "2025-11-01T15:29:24.436357Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_diff_format_matches_spec:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:329-363",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_diff_format_matches_spec",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 329,
        "end": 363
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_diff_format_matches_spec() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:test:src_lib_rs:10-20\",\n        Some(\"fn test() {}\"),\n        Some(\"fn test_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff and serialize to JSON\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n    let json = diff.to_json_pretty().unwrap();\n\n    // EXPECTATION: JSON should have enhanced structure\n    assert!(json.contains(\"\\\"current_code\\\"\"), \"Must have current_code field\");\n    assert!(json.contains(\"\\\"future_code\\\"\"), \"Must have future_code field\");\n    assert!(json.contains(\"\\\"line_range\\\"\"), \"Must have line_range field\");\n    assert!(json.contains(\"\\\"start\\\"\"), \"line_range must have start\");\n    assert!(json.contains(\"\\\"end\\\"\"), \"line_range must have end\");\n\n    // Should have operation type\n    assert!(json.contains(\"\\\"EDIT\\\"\"), \"Must have operation type\");\n\n    // Should have metadata\n    assert!(json.contains(\"\\\"metadata\\\"\"), \"Must have metadata\");\n    assert!(json.contains(\"\\\"total_changes\\\"\"), \"Must have total_changes\");\n    assert!(json.contains(\"\\\"generated_at\\\"\"), \"Must have timestamp\");\n}",
    "future_code": "async fn test_diff_format_matches_spec() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:test:src_lib_rs:10-20\",\n        Some(\"fn test() {}\"),\n        Some(\"fn test_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff and serialize to JSON\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n    let json = diff.to_json_pretty().unwrap();\n\n    // EXPECTATION: JSON should have enhanced structure\n    assert!(json.contains(\"\\\"current_code\\\"\"), \"Must have current_code field\");\n    assert!(json.contains(\"\\\"future_code\\\"\"), \"Must have future_code field\");\n    assert!(json.contains(\"\\\"line_range\\\"\"), \"Must have line_range field\");\n    assert!(json.contains(\"\\\"start\\\"\"), \"line_range must have start\");\n    assert!(json.contains(\"\\\"end\\\"\"), \"line_range must have end\");\n\n    // Should have operation type\n    assert!(json.contains(\"\\\"EDIT\\\"\"), \"Must have operation type\");\n\n    // Should have metadata\n    assert!(json.contains(\"\\\"metadata\\\"\"), \"Must have metadata\");\n    assert!(json.contains(\"\\\"total_changes\\\"\"), \"Must have total_changes\");\n    assert!(json.contains(\"\\\"generated_at\\\"\"), \"Must have timestamp\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436358Z",
      "modified_at": "2025-11-01T15:29:24.436358Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_diff_includes_current_and_future_code:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:98-140",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_diff_includes_current_and_future_code",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 98,
        "end": 140
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_diff_includes_current_and_future_code() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:calculate:src_lib_rs:42-56\",\n        Some(\"fn calculate(a: i32) -> i32 { a + 1 }\"),\n        Some(\"fn calculate(a: i32, b: i32) -> i32 { a + b }\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Diff should INCLUDE current_code for Edit operations\n    // (Opposite of Tool 3 which EXCLUDES code!)\n    let change = &diff.changes[0];\n    assert!(\n        change.current_code.is_some(),\n        \"Edit operation must include current_code\"\n    );\n    assert!(\n        change.future_code.is_some(),\n        \"Edit operation must include future_code\"\n    );\n\n    // Verify content\n    let current = change.current_code.as_ref().unwrap();\n    let future = change.future_code.as_ref().unwrap();\n    assert!(\n        current.contains(\"a + 1\"),\n        \"current_code should contain old implementation\"\n    );\n    assert!(\n        future.contains(\"a + b\"),\n        \"future_code should contain new implementation\"\n    );\n}",
    "future_code": "async fn test_diff_includes_current_and_future_code() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:calculate:src_lib_rs:42-56\",\n        Some(\"fn calculate(a: i32) -> i32 { a + 1 }\"),\n        Some(\"fn calculate(a: i32, b: i32) -> i32 { a + b }\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Diff should INCLUDE current_code for Edit operations\n    // (Opposite of Tool 3 which EXCLUDES code!)\n    let change = &diff.changes[0];\n    assert!(\n        change.current_code.is_some(),\n        \"Edit operation must include current_code\"\n    );\n    assert!(\n        change.future_code.is_some(),\n        \"Edit operation must include future_code\"\n    );\n\n    // Verify content\n    let current = change.current_code.as_ref().unwrap();\n    let future = change.future_code.as_ref().unwrap();\n    assert!(\n        current.contains(\"a + 1\"),\n        \"current_code should contain old implementation\"\n    );\n    assert!(\n        future.contains(\"a + b\"),\n        \"future_code should contain new implementation\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436359Z",
      "modified_at": "2025-11-01T15:29:24.436359Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_diff_includes_line_ranges:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:144-174",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_diff_includes_line_ranges",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 144,
        "end": 174
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_diff_includes_line_ranges() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Entity with line-based ISGL1 key\n    let entity = create_test_entity(\n        \"rust:fn:example:src_lib_rs:100-150\",\n        Some(\"fn example() {}\"),\n        Some(\"fn example_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: line_range should be extracted from ISGL1 key\n    let change = &diff.changes[0];\n    assert!(\n        change.line_range.is_some(),\n        \"Edit operation must include line_range\"\n    );\n\n    let line_range = change.line_range.as_ref().unwrap();\n    assert_eq!(line_range.start, 100, \"Line start should match ISGL1 key\");\n    assert_eq!(line_range.end, 150, \"Line end should match ISGL1 key\");\n}",
    "future_code": "async fn test_diff_includes_line_ranges() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Entity with line-based ISGL1 key\n    let entity = create_test_entity(\n        \"rust:fn:example:src_lib_rs:100-150\",\n        Some(\"fn example() {}\"),\n        Some(\"fn example_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: line_range should be extracted from ISGL1 key\n    let change = &diff.changes[0];\n    assert!(\n        change.line_range.is_some(),\n        \"Edit operation must include line_range\"\n    );\n\n    let line_range = change.line_range.as_ref().unwrap();\n    assert_eq!(line_range.start, 100, \"Line start should match ISGL1 key\");\n    assert_eq!(line_range.end, 150, \"Line end should match ISGL1 key\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436360Z",
      "modified_at": "2025-11-01T15:29:24.436360Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_duplicate_edge_error:______crates_parseltongue-core_src_error_rs:232-244",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_duplicate_edge_error",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 232,
        "end": 244
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_duplicate_edge_error() {\n        let error = ParseltongError::DuplicateEdge {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:helper:src_helper_rs:5-20\".to_string(),\n            edge_type: \"Calls\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Duplicate dependency edge\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n        assert!(formatted.contains(\"rust:fn:helper:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"Calls\"));\n    }",
    "future_code": "    fn test_duplicate_edge_error() {\n        let error = ParseltongError::DuplicateEdge {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:helper:src_helper_rs:5-20\".to_string(),\n            edge_type: \"Calls\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Duplicate dependency edge\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n        assert!(formatted.contains(\"rust:fn:helper:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"Calls\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436360Z",
      "modified_at": "2025-11-01T15:29:24.436361Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_error_propagation:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:160-185",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_error_propagation",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 160,
        "end": 185
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_e2e_error_propagation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User provides invalid query\n    let config = LlmWriterConfig {\n        query: \"INVALID DATALOG GARBAGE !!!\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute should fail and propagate error\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_err(), \"Invalid query should fail\");\n\n    let err = result.unwrap_err();\n    let err_msg = format!(\"{:?}\", err);\n    assert!(\n        err_msg.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog failure\"\n    );\n}",
    "future_code": "async fn test_e2e_error_propagation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User provides invalid query\n    let config = LlmWriterConfig {\n        query: \"INVALID DATALOG GARBAGE !!!\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute should fail and propagate error\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_err(), \"Invalid query should fail\");\n\n    let err = result.unwrap_err();\n    let err_msg = format!(\"{:?}\", err);\n    assert!(\n        err_msg.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog failure\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436361Z",
      "modified_at": "2025-11-01T15:29:24.436361Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_multiple_sequential_queries:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:189-226",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_multiple_sequential_queries",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 189,
        "end": 226
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_e2e_multiple_sequential_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // User runs multiple sequential queries:\n    // 1. List relations\n    let query1 = \"::relations\";\n    let result1 = storage.execute_query(query1).await;\n    assert!(result1.is_ok(), \"First query should succeed\");\n\n    // 2. Query all entities\n    let query2 = r#\"\n        ?[ISGL1_key] :=\n        *CodeGraph{ ISGL1_key }\n    \"#;\n    let result2 = storage.execute_query(query2).await;\n    assert!(result2.is_ok(), \"Second query should succeed\");\n\n    // 3. Query with filter\n    let query3 = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{ ISGL1_key, current_ind },\n        current_ind == true\n    \"#;\n    let result3 = storage.execute_query(query3).await;\n    assert!(result3.is_ok(), \"Third query should succeed\");\n}",
    "future_code": "async fn test_e2e_multiple_sequential_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // User runs multiple sequential queries:\n    // 1. List relations\n    let query1 = \"::relations\";\n    let result1 = storage.execute_query(query1).await;\n    assert!(result1.is_ok(), \"First query should succeed\");\n\n    // 2. Query all entities\n    let query2 = r#\"\n        ?[ISGL1_key] :=\n        *CodeGraph{ ISGL1_key }\n    \"#;\n    let result2 = storage.execute_query(query2).await;\n    assert!(result2.is_ok(), \"Second query should succeed\");\n\n    // 3. Query with filter\n    let query3 = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{ ISGL1_key, current_ind },\n        current_ind == true\n    \"#;\n    let result3 = storage.execute_query(query3).await;\n    assert!(result3.is_ok(), \"Third query should succeed\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436363Z",
      "modified_at": "2025-11-01T15:29:24.436363Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_query_building_with_flag:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:121-138",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_query_building_with_flag",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 121,
        "end": 138
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_e2e_query_building_with_flag() {\n    // Scenario 1: Default behavior (exclude)\n    let query_exclude = CliConfig::build_context_query(false);\n    assert!(\n        query_exclude.contains(\"EXCEPT\") || !query_exclude.contains(\"Current_Code\"),\n        \"Default query should exclude Current_Code\"\n    );\n\n    // Scenario 2: Include Current_Code\n    let query_include = CliConfig::build_context_query(true);\n    // When including, either no EXCEPT or EXCEPT doesn't mention Current_Code\n    if query_include.contains(\"EXCEPT\") {\n        assert!(\n            !query_include.contains(\"EXCEPT (Current_Code\"),\n            \"Include mode should not have Current_Code in EXCEPT clause\"\n        );\n    }\n}",
    "future_code": "fn test_e2e_query_building_with_flag() {\n    // Scenario 1: Default behavior (exclude)\n    let query_exclude = CliConfig::build_context_query(false);\n    assert!(\n        query_exclude.contains(\"EXCEPT\") || !query_exclude.contains(\"Current_Code\"),\n        \"Default query should exclude Current_Code\"\n    );\n\n    // Scenario 2: Include Current_Code\n    let query_include = CliConfig::build_context_query(true);\n    // When including, either no EXCEPT or EXCEPT doesn't mention Current_Code\n    if query_include.contains(\"EXCEPT\") {\n        assert!(\n            !query_include.contains(\"EXCEPT (Current_Code\"),\n            \"Include mode should not have Current_Code in EXCEPT clause\"\n        );\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436363Z",
      "modified_at": "2025-11-01T15:29:24.436364Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_simple_create_workflow:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:149-193",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_simple_create_workflow",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 149,
        "end": 193
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_e2e_simple_create_workflow() {\n    use parseltongue_core::storage::CozoDbStorage;\n    use tempfile::TempDir;\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Create action via simple interface\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Generate and execute Datalog\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog for E2E test:\\n{}\", datalog);\n\n    let result = storage.execute_query(&datalog).await;\n\n    if let Err(e) = &result {\n        eprintln!(\"Error executing query: {:?}\", e);\n    }\n    assert!(result.is_ok(), \"Simple interface Create should succeed: {:?}\", result);\n\n    // Verify postcondition: Entity exists with correct temporal state\n    let verify_query = r#\"\n        ?[ISGL1_key, current_ind, future_ind, Future_Action] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind, Future_Action\n        },\n        ISGL1_key == \"rust:fn:new_func:src_lib_rs:10-15\"\n    \"#;\n\n    let result = storage.execute_query(verify_query).await;\n    assert!(result.is_ok(), \"Verification query should succeed\");\n    // Note: Full verification would parse result and check values\n}",
    "future_code": "async fn test_e2e_simple_create_workflow() {\n    use parseltongue_core::storage::CozoDbStorage;\n    use tempfile::TempDir;\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Create action via simple interface\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Generate and execute Datalog\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog for E2E test:\\n{}\", datalog);\n\n    let result = storage.execute_query(&datalog).await;\n\n    if let Err(e) = &result {\n        eprintln!(\"Error executing query: {:?}\", e);\n    }\n    assert!(result.is_ok(), \"Simple interface Create should succeed: {:?}\", result);\n\n    // Verify postcondition: Entity exists with correct temporal state\n    let verify_query = r#\"\n        ?[ISGL1_key, current_ind, future_ind, Future_Action] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind, Future_Action\n        },\n        ISGL1_key == \"rust:fn:new_func:src_lib_rs:10-15\"\n    \"#;\n\n    let result = storage.execute_query(verify_query).await;\n    assert!(result.is_ok(), \"Verification query should succeed\");\n    // Note: Full verification would parse result and check values\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436365Z",
      "modified_at": "2025-11-01T15:29:24.436365Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_simple_query_via_config:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:105-135",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_simple_query_via_config",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 105,
        "end": 135
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_e2e_simple_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup: Create database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Simulate user running: llm-to-cozodb-writer --query \"...\" --db <path>\n    let config = LlmWriterConfig {\n        query: r#\"\n            ?[ISGL1_key, current_ind] :=\n            *CodeGraph{\n                ISGL1_key, current_ind\n            }\n        \"#.to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute query (this is what main.rs does)\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"E2E query execution should succeed\");\n}",
    "future_code": "async fn test_e2e_simple_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup: Create database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Simulate user running: llm-to-cozodb-writer --query \"...\" --db <path>\n    let config = LlmWriterConfig {\n        query: r#\"\n            ?[ISGL1_key, current_ind] :=\n            *CodeGraph{\n                ISGL1_key, current_ind\n            }\n        \"#.to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute query (this is what main.rs does)\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"E2E query execution should succeed\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436366Z",
      "modified_at": "2025-11-01T15:29:24.436366Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_e2e_system_query_via_config:______crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:139-156",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_e2e_system_query_via_config",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "line_range": {
        "start": 139,
        "end": 156
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_e2e_system_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User runs: llm-to-cozodb-writer --query \"::relations\" --db <path>\n    let config = LlmWriterConfig {\n        query: \"::relations\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
    "future_code": "async fn test_e2e_system_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User runs: llm-to-cozodb-writer --query \"::relations\" --db <path>\n    let config = LlmWriterConfig {\n        query: \"::relations\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436366Z",
      "modified_at": "2025-11-01T15:29:24.436367Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_edge_type_display:______crates_parseltongue-core_src_entities_rs:1446-1450",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_edge_type_display",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1446,
        "end": 1450
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_edge_type_display() {\n        assert_eq!(format!(\"{}\", EdgeType::Calls), \"Calls\");\n        assert_eq!(format!(\"{}\", EdgeType::Uses), \"Uses\");\n        assert_eq!(format!(\"{}\", EdgeType::Implements), \"Implements\");\n    }",
    "future_code": "    fn test_edge_type_display() {\n        assert_eq!(format!(\"{}\", EdgeType::Calls), \"Calls\");\n        assert_eq!(format!(\"{}\", EdgeType::Uses), \"Uses\");\n        assert_eq!(format!(\"{}\", EdgeType::Implements), \"Implements\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436367Z",
      "modified_at": "2025-11-01T15:29:24.436367Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_edge_type_roundtrip:______crates_parseltongue-core_src_entities_rs:1427-1443",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_edge_type_roundtrip",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1427,
        "end": 1443
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_edge_type_roundtrip() {\n        use std::str::FromStr;\n\n        // Test all variants\n        for edge_type in [EdgeType::Calls, EdgeType::Uses, EdgeType::Implements] {\n            let s = edge_type.as_str();\n            let parsed = EdgeType::from_str(s).unwrap();\n            assert_eq!(parsed, edge_type);\n\n            // Test String conversion\n            let string: String = edge_type.into();\n            assert_eq!(string, s);\n        }\n\n        // Invalid edge type\n        assert!(EdgeType::from_str(\"Invalid\").is_err());\n    }",
    "future_code": "    fn test_edge_type_roundtrip() {\n        use std::str::FromStr;\n\n        // Test all variants\n        for edge_type in [EdgeType::Calls, EdgeType::Uses, EdgeType::Implements] {\n            let s = edge_type.as_str();\n            let parsed = EdgeType::from_str(s).unwrap();\n            assert_eq!(parsed, edge_type);\n\n            // Test String conversion\n            let string: String = edge_type.into();\n            assert_eq!(string, s);\n        }\n\n        // Invalid edge type\n        assert!(EdgeType::from_str(\"Invalid\").is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436368Z",
      "modified_at": "2025-11-01T15:29:24.436368Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_edit_action_generates_datalog:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:34-48",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_edit_action_generates_datalog",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 34,
        "end": 48
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_edit_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: Some(\"pub fn existing() { /* modified */ }\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=1, Future_Action=\"Edit\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing temporal indicators\");\n    assert!(datalog.contains(\"\\\"Edit\\\"\"), \"Missing Edit action\");\n}",
    "future_code": "fn test_edit_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: Some(\"pub fn existing() { /* modified */ }\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=1, Future_Action=\"Edit\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing temporal indicators\");\n    assert!(datalog.contains(\"\\\"Edit\\\"\"), \"Missing Edit action\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436369Z",
      "modified_at": "2025-11-01T15:29:24.436369Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_edit_existing_file:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:185-210",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_edit_existing_file",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 185,
        "end": 210
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_edit_existing_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/existing.rs\");\n\n        // Create directory and file\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn old() {}\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-existing-rs-NewFunc\",\n            Some(\"fn new() {}\".to_string()),\n            TemporalState::edit(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Edit);\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn new() {}\");\n    }",
    "future_code": "    async fn test_edit_existing_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/existing.rs\");\n\n        // Create directory and file\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn old() {}\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-existing-rs-NewFunc\",\n            Some(\"fn new() {}\".to_string()),\n            TemporalState::edit(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Edit);\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn new() {}\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436370Z",
      "modified_at": "2025-11-01T15:29:24.436370Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_edit_requires_future_code:______crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:86-95",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_edit_requires_future_code",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "line_range": {
        "start": 86,
        "end": 95
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_edit_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: None, // ERROR: Edit requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
    "future_code": "fn test_edit_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: None, // ERROR: Edit requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436371Z",
      "modified_at": "2025-11-01T15:29:24.436371Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_empty_code_diff:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:172-176",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_empty_code_diff",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 172,
        "end": 176
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_empty_code_diff() {\n        let diff = CodeDiff::new();\n        assert_eq!(diff.changes.len(), 0);\n        assert_eq!(diff.metadata.total_changes, 0);\n    }",
    "future_code": "    fn test_empty_code_diff() {\n        let diff = CodeDiff::new();\n        assert_eq!(diff.changes.len(), 0);\n        assert_eq!(diff.metadata.total_changes, 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436373Z",
      "modified_at": "2025-11-01T15:29:24.436373Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_end_to_end_tool1_tool2_tool3_pipeline:______crates_parseltongue-core_tests_end_to_end_workflow_rs:49-333",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_end_to_end_tool1_tool2_tool3_pipeline",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "line_range": {
        "start": 49,
        "end": 333
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_end_to_end_tool1_tool2_tool3_pipeline() {\n    println!(\"\\n\");\n    println!(\"   END-TO-END WORKFLOW TEST: Tool 1  Tool 2  Tool 3    \");\n    println!(\"   Testing on: Parseltongue Repository (Self-Hosting)    \");\n    println!(\"\\n\");\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"e2e_test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .expect(\"Failed to create test database\");\n\n    // Create schema\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // \n    // PHASE 1: Tool 1 - Index Parseltongue Codebase\n    // \n    println!(\"\");\n    println!(\" PHASE 1: Tool 1 - Index Codebase                       \");\n    println!(\"\");\n\n    // Simulate Tool 1 indexing by creating sample entities\n    // (In real scenario, folder-to-cozodb-streamer would parse files)\n    let entity1 = create_indexed_entity(\n        \"calculate_sum\",\n        \"src/lib.rs\",\n        (10, 20),\n        EntityClass::CodeImplementation,\n    );\n    let entity2 = create_indexed_entity(\n        \"test_calculate_sum\",\n        \"src/lib.rs\",\n        (30, 40),\n        EntityClass::TestImplementation,\n    );\n    let entity3 = create_indexed_entity(\n        \"process_data\",\n        \"src/processor.rs\",\n        (50, 70),\n        EntityClass::CodeImplementation,\n    );\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    let indexed_count = storage.get_all_entities().await.unwrap().len();\n    println!(\" Tool 1 indexed {} entities\", indexed_count);\n    println!(\"  - Entity 1: {} (Code)\", key1);\n    println!(\"  - Entity 2: {} (Test)\", key2);\n    println!(\"  - Entity 3: {} (Code)\", key3);\n\n    // Verify initial state: All entities (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true, \"Should exist in current\");\n        assert_eq!(e.temporal_state.future_ind, false, \"Future unknown initially\");\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n    println!(\" All entities start with state (current_ind=1, future_ind=0, future_action=None)\");\n\n    // \n    // PHASE 2: Tool 2 - Apply Temporal Changes (Simulate LLM Reasoning)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 2: Tool 2 - Temporal Operations                  \");\n    println!(\"\");\n\n    // Operation 1: Edit existing function (1,1,Edit)\n    println!(\"\\n Edit Operation: {}\", key1);\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    let mut edited = storage.get_entity(&key1).await.unwrap();\n    edited.future_code = Some(\"fn calculate_sum() {\\n    // LLM-improved implementation\\n}\".to_string());\n    storage.update_entity(edited).await.unwrap();\n\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true);\n    assert_eq!(e1.temporal_state.future_ind, true);\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit));\n    println!(\" State: (current_ind=1, future_ind=1, future_action=Edit)\");\n    println!(\" future_code populated\");\n\n    // Operation 2: Delete existing function (1,0,Delete)\n    println!(\"\\n  Delete Operation: {}\", key3);\n    storage\n        .update_temporal_state(&key3, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, Some(TemporalAction::Delete));\n    println!(\" State: (current_ind=1, future_ind=0, future_action=Delete)\");\n\n    // Operation 3: Create new function with hash-based ISGL1 key (0,1,Create)\n    println!(\"\\n Create Operation: new_awesome_function\");\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    let e_new = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e_new.temporal_state.current_ind, false);\n    assert_eq!(e_new.temporal_state.future_ind, true);\n    assert_eq!(e_new.temporal_state.future_action, Some(TemporalAction::Create));\n    println!(\" Hash-based ISGL1 key: {}\", new_key);\n    println!(\" State: (current_ind=0, future_ind=1, future_action=Create)\");\n    println!(\" future_code populated\");\n\n    // Verify changed entities count\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 changed entities\");\n    println!(\"\\n Tool 2 created {} temporal changes (1 Edit, 1 Delete, 1 Create)\", changed.len());\n\n    // \n    // PHASE 3: Tool 3 - Extract Context (Ultra-Minimalist per PRD)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 3: Tool 3 - Context Extraction                   \");\n    println!(\"\");\n\n    // Extract base context: Only current_ind=1 entities (per PRD P01:122)\n    let all_entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"\\n Context Statistics:\");\n    println!(\"  - Total entities in database: {}\", all_entities.len());\n    println!(\"  - Entities with current_ind=1: {}\", current_entities.len());\n    println!(\"  - Entities with future_action!=None: {}\", changed.len());\n\n    // Create ultra-minimalist context per PRD P01:128\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class),\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        })\n        .collect();\n\n    // Estimate token count\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"\\n Context Output:\");\n    println!(\"  - JSON size: {} bytes\", json_output.len());\n    println!(\"  - Estimated tokens: {}\", estimated_tokens);\n    println!(\"  - Tokens per entity: {}\", estimated_tokens / context_entities.len());\n\n    // Verify PRD compliance\n    println!(\"\\n PRD Compliance Verification:\");\n\n    // 1. Token limit\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens\",\n        estimated_tokens\n    );\n    println!(\"   Token count < 100k limit ({})\", estimated_tokens);\n\n    // 2. No code fields\n    assert!(!json_output.contains(\"\\\"current_code\\\":\"));\n    assert!(!json_output.contains(\"\\\"future_code\\\":\"));\n    println!(\"   current_code excluded\");\n    println!(\"   future_code excluded\");\n\n    // 3. Required fields present\n    assert!(json_output.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json_output.contains(\"\\\"interface_signature\\\"\"));\n    assert!(json_output.contains(\"\\\"entity_class\\\"\"));\n    println!(\"   isgl1_key present\");\n    println!(\"   interface_signature present\");\n    println!(\"   entity_class present\");\n\n    // 4. Only current_ind=1 in base context\n    assert_eq!(\n        current_entities.len(),\n        3,\n        \"Base context should have 3 current entities (new entity not in current)\"\n    );\n    println!(\"   Only current_ind=1 entities in base context ({})\", current_entities.len());\n\n    // \n    // PHASE 4: Verify Temporal State Transitions\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 4: Temporal State Validation                     \");\n    println!(\"\");\n\n    println!(\"\\n Entity States After Tool 2 Operations:\");\n\n    let e1_final = storage.get_entity(&key1).await.unwrap();\n    println!(\"\\n  Entity 1 ({}): EDITED\", e1_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e1_final.temporal_state.current_ind,\n             e1_final.temporal_state.future_ind,\n             e1_final.temporal_state.future_action);\n    assert_eq!(e1_final.temporal_state.current_ind, true);\n    assert_eq!(e1_final.temporal_state.future_ind, true);\n    assert_eq!(e1_final.temporal_state.future_action, Some(TemporalAction::Edit));\n\n    let e2_final = storage.get_entity(&key2).await.unwrap();\n    println!(\"\\n  Entity 2 ({}): UNCHANGED\", e2_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e2_final.temporal_state.current_ind,\n             e2_final.temporal_state.future_ind,\n             e2_final.temporal_state.future_action);\n    assert_eq!(e2_final.temporal_state.current_ind, true);\n    assert_eq!(e2_final.temporal_state.future_ind, false);\n    assert_eq!(e2_final.temporal_state.future_action, None);\n\n    let e3_final = storage.get_entity(&key3).await.unwrap();\n    println!(\"\\n  Entity 3 ({}): DELETED\", e3_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e3_final.temporal_state.current_ind,\n             e3_final.temporal_state.future_ind,\n             e3_final.temporal_state.future_action);\n    assert_eq!(e3_final.temporal_state.current_ind, true);\n    assert_eq!(e3_final.temporal_state.future_ind, false);\n    assert_eq!(e3_final.temporal_state.future_action, Some(TemporalAction::Delete));\n\n    let e_new_final = storage.get_entity(&new_key).await.unwrap();\n    println!(\"\\n  Entity 4 ({}): CREATED\", e_new_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e_new_final.temporal_state.current_ind,\n             e_new_final.temporal_state.future_ind,\n             e_new_final.temporal_state.future_action);\n    assert_eq!(e_new_final.temporal_state.current_ind, false);\n    assert_eq!(e_new_final.temporal_state.future_ind, true);\n    assert_eq!(e_new_final.temporal_state.future_action, Some(TemporalAction::Create));\n\n    // \n    // FINAL SUMMARY\n    // \n    println!(\"\\n\");\n    println!(\"             END-TO-END TEST:  PASSED                   \");\n    println!(\"\");\n\n    println!(\"\\n Tool 1: Indexed {} entities with ISGL1 keys\", indexed_count);\n    println!(\" Tool 2: Applied {} temporal changes (Edit/Delete/Create)\", changed.len());\n    println!(\" Tool 3: Generated context with {} tokens (<100k limit)\", estimated_tokens);\n    println!(\" PRD Compliance: All requirements validated\");\n    println!(\" Temporal States: All transitions correct\\n\");\n}",
    "future_code": "async fn test_end_to_end_tool1_tool2_tool3_pipeline() {\n    println!(\"\\n\");\n    println!(\"   END-TO-END WORKFLOW TEST: Tool 1  Tool 2  Tool 3    \");\n    println!(\"   Testing on: Parseltongue Repository (Self-Hosting)    \");\n    println!(\"\\n\");\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"e2e_test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .expect(\"Failed to create test database\");\n\n    // Create schema\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // \n    // PHASE 1: Tool 1 - Index Parseltongue Codebase\n    // \n    println!(\"\");\n    println!(\" PHASE 1: Tool 1 - Index Codebase                       \");\n    println!(\"\");\n\n    // Simulate Tool 1 indexing by creating sample entities\n    // (In real scenario, folder-to-cozodb-streamer would parse files)\n    let entity1 = create_indexed_entity(\n        \"calculate_sum\",\n        \"src/lib.rs\",\n        (10, 20),\n        EntityClass::CodeImplementation,\n    );\n    let entity2 = create_indexed_entity(\n        \"test_calculate_sum\",\n        \"src/lib.rs\",\n        (30, 40),\n        EntityClass::TestImplementation,\n    );\n    let entity3 = create_indexed_entity(\n        \"process_data\",\n        \"src/processor.rs\",\n        (50, 70),\n        EntityClass::CodeImplementation,\n    );\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    let indexed_count = storage.get_all_entities().await.unwrap().len();\n    println!(\" Tool 1 indexed {} entities\", indexed_count);\n    println!(\"  - Entity 1: {} (Code)\", key1);\n    println!(\"  - Entity 2: {} (Test)\", key2);\n    println!(\"  - Entity 3: {} (Code)\", key3);\n\n    // Verify initial state: All entities (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true, \"Should exist in current\");\n        assert_eq!(e.temporal_state.future_ind, false, \"Future unknown initially\");\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n    println!(\" All entities start with state (current_ind=1, future_ind=0, future_action=None)\");\n\n    // \n    // PHASE 2: Tool 2 - Apply Temporal Changes (Simulate LLM Reasoning)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 2: Tool 2 - Temporal Operations                  \");\n    println!(\"\");\n\n    // Operation 1: Edit existing function (1,1,Edit)\n    println!(\"\\n Edit Operation: {}\", key1);\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    let mut edited = storage.get_entity(&key1).await.unwrap();\n    edited.future_code = Some(\"fn calculate_sum() {\\n    // LLM-improved implementation\\n}\".to_string());\n    storage.update_entity(edited).await.unwrap();\n\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true);\n    assert_eq!(e1.temporal_state.future_ind, true);\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit));\n    println!(\" State: (current_ind=1, future_ind=1, future_action=Edit)\");\n    println!(\" future_code populated\");\n\n    // Operation 2: Delete existing function (1,0,Delete)\n    println!(\"\\n  Delete Operation: {}\", key3);\n    storage\n        .update_temporal_state(&key3, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, Some(TemporalAction::Delete));\n    println!(\" State: (current_ind=1, future_ind=0, future_action=Delete)\");\n\n    // Operation 3: Create new function with hash-based ISGL1 key (0,1,Create)\n    println!(\"\\n Create Operation: new_awesome_function\");\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    let e_new = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e_new.temporal_state.current_ind, false);\n    assert_eq!(e_new.temporal_state.future_ind, true);\n    assert_eq!(e_new.temporal_state.future_action, Some(TemporalAction::Create));\n    println!(\" Hash-based ISGL1 key: {}\", new_key);\n    println!(\" State: (current_ind=0, future_ind=1, future_action=Create)\");\n    println!(\" future_code populated\");\n\n    // Verify changed entities count\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 changed entities\");\n    println!(\"\\n Tool 2 created {} temporal changes (1 Edit, 1 Delete, 1 Create)\", changed.len());\n\n    // \n    // PHASE 3: Tool 3 - Extract Context (Ultra-Minimalist per PRD)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 3: Tool 3 - Context Extraction                   \");\n    println!(\"\");\n\n    // Extract base context: Only current_ind=1 entities (per PRD P01:122)\n    let all_entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"\\n Context Statistics:\");\n    println!(\"  - Total entities in database: {}\", all_entities.len());\n    println!(\"  - Entities with current_ind=1: {}\", current_entities.len());\n    println!(\"  - Entities with future_action!=None: {}\", changed.len());\n\n    // Create ultra-minimalist context per PRD P01:128\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class),\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        })\n        .collect();\n\n    // Estimate token count\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"\\n Context Output:\");\n    println!(\"  - JSON size: {} bytes\", json_output.len());\n    println!(\"  - Estimated tokens: {}\", estimated_tokens);\n    println!(\"  - Tokens per entity: {}\", estimated_tokens / context_entities.len());\n\n    // Verify PRD compliance\n    println!(\"\\n PRD Compliance Verification:\");\n\n    // 1. Token limit\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens\",\n        estimated_tokens\n    );\n    println!(\"   Token count < 100k limit ({})\", estimated_tokens);\n\n    // 2. No code fields\n    assert!(!json_output.contains(\"\\\"current_code\\\":\"));\n    assert!(!json_output.contains(\"\\\"future_code\\\":\"));\n    println!(\"   current_code excluded\");\n    println!(\"   future_code excluded\");\n\n    // 3. Required fields present\n    assert!(json_output.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json_output.contains(\"\\\"interface_signature\\\"\"));\n    assert!(json_output.contains(\"\\\"entity_class\\\"\"));\n    println!(\"   isgl1_key present\");\n    println!(\"   interface_signature present\");\n    println!(\"   entity_class present\");\n\n    // 4. Only current_ind=1 in base context\n    assert_eq!(\n        current_entities.len(),\n        3,\n        \"Base context should have 3 current entities (new entity not in current)\"\n    );\n    println!(\"   Only current_ind=1 entities in base context ({})\", current_entities.len());\n\n    // \n    // PHASE 4: Verify Temporal State Transitions\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 4: Temporal State Validation                     \");\n    println!(\"\");\n\n    println!(\"\\n Entity States After Tool 2 Operations:\");\n\n    let e1_final = storage.get_entity(&key1).await.unwrap();\n    println!(\"\\n  Entity 1 ({}): EDITED\", e1_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e1_final.temporal_state.current_ind,\n             e1_final.temporal_state.future_ind,\n             e1_final.temporal_state.future_action);\n    assert_eq!(e1_final.temporal_state.current_ind, true);\n    assert_eq!(e1_final.temporal_state.future_ind, true);\n    assert_eq!(e1_final.temporal_state.future_action, Some(TemporalAction::Edit));\n\n    let e2_final = storage.get_entity(&key2).await.unwrap();\n    println!(\"\\n  Entity 2 ({}): UNCHANGED\", e2_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e2_final.temporal_state.current_ind,\n             e2_final.temporal_state.future_ind,\n             e2_final.temporal_state.future_action);\n    assert_eq!(e2_final.temporal_state.current_ind, true);\n    assert_eq!(e2_final.temporal_state.future_ind, false);\n    assert_eq!(e2_final.temporal_state.future_action, None);\n\n    let e3_final = storage.get_entity(&key3).await.unwrap();\n    println!(\"\\n  Entity 3 ({}): DELETED\", e3_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e3_final.temporal_state.current_ind,\n             e3_final.temporal_state.future_ind,\n             e3_final.temporal_state.future_action);\n    assert_eq!(e3_final.temporal_state.current_ind, true);\n    assert_eq!(e3_final.temporal_state.future_ind, false);\n    assert_eq!(e3_final.temporal_state.future_action, Some(TemporalAction::Delete));\n\n    let e_new_final = storage.get_entity(&new_key).await.unwrap();\n    println!(\"\\n  Entity 4 ({}): CREATED\", e_new_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e_new_final.temporal_state.current_ind,\n             e_new_final.temporal_state.future_ind,\n             e_new_final.temporal_state.future_action);\n    assert_eq!(e_new_final.temporal_state.current_ind, false);\n    assert_eq!(e_new_final.temporal_state.future_ind, true);\n    assert_eq!(e_new_final.temporal_state.future_action, Some(TemporalAction::Create));\n\n    // \n    // FINAL SUMMARY\n    // \n    println!(\"\\n\");\n    println!(\"             END-TO-END TEST:  PASSED                   \");\n    println!(\"\");\n\n    println!(\"\\n Tool 1: Indexed {} entities with ISGL1 keys\", indexed_count);\n    println!(\" Tool 2: Applied {} temporal changes (Edit/Delete/Create)\", changed.len());\n    println!(\" Tool 3: Generated context with {} tokens (<100k limit)\", estimated_tokens);\n    println!(\" PRD Compliance: All requirements validated\");\n    println!(\" Temporal States: All transitions correct\\n\");\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436375Z",
      "modified_at": "2025-11-01T15:29:24.436375Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_entity_class_enum:______crates_parseltongue-core_src_entities_rs:1369-1376",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_entity_class_enum",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1369,
        "end": 1376
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_entity_class_enum() {\n        // Test that EntityClass enum exists with correct variants\n        let test_class = EntityClass::TestImplementation;\n        let code_class = EntityClass::CodeImplementation;\n\n        assert_eq!(test_class, EntityClass::TestImplementation);\n        assert_eq!(code_class, EntityClass::CodeImplementation);\n    }",
    "future_code": "    fn test_entity_class_enum() {\n        // Test that EntityClass enum exists with correct variants\n        let test_class = EntityClass::TestImplementation;\n        let code_class = EntityClass::CodeImplementation;\n\n        assert_eq!(test_class, EntityClass::TestImplementation);\n        assert_eq!(code_class, EntityClass::CodeImplementation);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436376Z",
      "modified_at": "2025-11-01T15:29:24.436376Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_entity_class_serialization:______crates_parseltongue-core_src_entities_rs:1388-1395",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_entity_class_serialization",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1388,
        "end": 1395
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_entity_class_serialization() {\n        // Test that EntityClass can be serialized/deserialized\n        let test_impl = EntityClass::TestImplementation;\n        let json = serde_json::to_string(&test_impl).unwrap();\n        let deserialized: EntityClass = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, EntityClass::TestImplementation);\n    }",
    "future_code": "    fn test_entity_class_serialization() {\n        // Test that EntityClass can be serialized/deserialized\n        let test_impl = EntityClass::TestImplementation;\n        let json = serde_json::to_string(&test_impl).unwrap();\n        let deserialized: EntityClass = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, EntityClass::TestImplementation);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436377Z",
      "modified_at": "2025-11-01T15:29:24.436377Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_environment_variable_api_key:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:374-387",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_environment_variable_api_key",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 374,
        "end": 387
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_environment_variable_api_key() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--api-key\",\n            \"env-key-456\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.llm_api_key, \"env-key-456\");\n    }",
    "future_code": "    fn test_environment_variable_api_key() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--api-key\",\n            \"env-key-456\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.llm_api_key, \"env-key-456\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436378Z",
      "modified_at": "2025-11-01T15:29:24.436378Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_error_display:______crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:51-54",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_error_display",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "line_range": {
        "start": 51,
        "end": 54
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_error_display() {\n        let err = FileWriterError::file_already_exists(PathBuf::from(\"test.rs\"));\n        assert!(err.to_string().contains(\"test.rs\"));\n    }",
    "future_code": "    fn test_error_display() {\n        let err = FileWriterError::file_already_exists(PathBuf::from(\"test.rs\"));\n        assert!(err.to_string().contains(\"test.rs\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436379Z",
      "modified_at": "2025-11-01T15:29:24.436379Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_error_display:______crates_pt06-cozodb-make-future-code-current_src_errors_rs:21-24",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_error_display",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/errors.rs",
      "line_range": {
        "start": 21,
        "end": 24
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_error_display() {\n        let err = StateResetError::Database(\"connection failed\".to_string());\n        assert!(err.to_string().contains(\"Database error\"));\n    }",
    "future_code": "    fn test_error_display() {\n        let err = StateResetError::Database(\"connection failed\".to_string());\n        assert!(err.to_string().contains(\"Database error\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436379Z",
      "modified_at": "2025-11-01T15:29:24.436380Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_error_line_extraction:______crates_pt04-syntax-preflight-validator_src_errors_rs:107-116",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_error_line_extraction",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/errors.rs",
      "line_range": {
        "start": 107,
        "end": 116
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_error_line_extraction() {\n        let type_err = ValidationError::TypeError {\n            line: 42,\n            column: 10,\n            expected: \"i32\".to_string(),\n            found: \"String\".to_string(),\n            message: \"type mismatch\".to_string(),\n        };\n        assert_eq!(type_err.line(), Some(42));\n    }",
    "future_code": "    fn test_error_line_extraction() {\n        let type_err = ValidationError::TypeError {\n            line: 42,\n            column: 10,\n            expected: \"i32\".to_string(),\n            found: \"String\".to_string(),\n            message: \"type mismatch\".to_string(),\n        };\n        assert_eq!(type_err.line(), Some(42));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436380Z",
      "modified_at": "2025-11-01T15:29:24.436380Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_error_severity:______crates_pt04-syntax-preflight-validator_src_errors_rs:96-104",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_error_severity",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/errors.rs",
      "line_range": {
        "start": 96,
        "end": 104
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_error_severity() {\n        let syntax_err = ValidationError::SyntaxError {\n            line: 1,\n            column: 5,\n            message: \"unexpected token\".to_string(),\n            code_snippet: None,\n        };\n        assert_eq!(syntax_err.severity(), Severity::Error);\n    }",
    "future_code": "    fn test_error_severity() {\n        let syntax_err = ValidationError::SyntaxError {\n            line: 1,\n            column: 5,\n            message: \"unexpected token\".to_string(),\n            code_snippet: None,\n        };\n        assert_eq!(syntax_err.severity(), Severity::Error);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436381Z",
      "modified_at": "2025-11-01T15:29:24.436381Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_execute_query_invalid_syntax:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:374-401",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_execute_query_invalid_syntax",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 374,
        "end": 401
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_execute_query_invalid_syntax() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: Invalid Datalog query\n    let invalid_query = \"THIS IS NOT VALID DATALOG SYNTAX !!!\";\n\n    let result = storage.execute_query(invalid_query).await;\n\n    // Verify: Returns DatabaseError with details\n    assert!(result.is_err(), \"Invalid Datalog should return error\");\n\n    let err = result.unwrap_err();\n    let err_string = format!(\"{:?}\", err);\n    assert!(\n        err_string.contains(\"DatabaseError\") || err_string.contains(\"execute_query\"),\n        \"Error should be DatabaseError from execute_query operation\"\n    );\n    assert!(\n        err_string.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog query failure\"\n    );\n}",
    "future_code": "async fn test_execute_query_invalid_syntax() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: Invalid Datalog query\n    let invalid_query = \"THIS IS NOT VALID DATALOG SYNTAX !!!\";\n\n    let result = storage.execute_query(invalid_query).await;\n\n    // Verify: Returns DatabaseError with details\n    assert!(result.is_err(), \"Invalid Datalog should return error\");\n\n    let err = result.unwrap_err();\n    let err_string = format!(\"{:?}\", err);\n    assert!(\n        err_string.contains(\"DatabaseError\") || err_string.contains(\"execute_query\"),\n        \"Error should be DatabaseError from execute_query operation\"\n    );\n    assert!(\n        err_string.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog query failure\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436382Z",
      "modified_at": "2025-11-01T15:29:24.436382Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_execute_query_list_relations:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:354-368",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_execute_query_list_relations",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 354,
        "end": 368
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_execute_query_list_relations() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: CozoDB system query to list all relations\n    let query = \"::relations\";\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
    "future_code": "async fn test_execute_query_list_relations() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: CozoDB system query to list all relations\n    let query = \"::relations\";\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436383Z",
      "modified_at": "2025-11-01T15:29:24.436383Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_execute_query_simple_query:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:328-348",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_execute_query_simple_query",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 328,
        "end": 348
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_execute_query_simple_query() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Simple read query to verify execute_query works\n    let query = r#\"\n        ?[ISGL1_key, current_ind, future_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind\n        }\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Valid Datalog read query should execute successfully\");\n}",
    "future_code": "async fn test_execute_query_simple_query() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Simple read query to verify execute_query works\n    let query = r#\"\n        ?[ISGL1_key, current_ind, future_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind\n        }\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Valid Datalog read query should execute successfully\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436384Z",
      "modified_at": "2025-11-01T15:29:24.436384Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_execute_query_with_filter:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:407-433",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_execute_query_with_filter",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 407,
        "end": 433
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_execute_query_with_filter() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Execute: Query with filter (find entities where current_ind is true)\n    let query = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind\n        },\n        current_ind == true\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Filtered query should execute successfully\");\n}",
    "future_code": "async fn test_execute_query_with_filter() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Execute: Query with filter (find entities where current_ind is true)\n    let query = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind\n        },\n        current_ind == true\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Filtered query should execute successfully\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436385Z",
      "modified_at": "2025-11-01T15:29:24.436385Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_extracts_function_call_dependencies:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:540-576",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_extracts_function_call_dependencies",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 540,
        "end": 576
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_extracts_function_call_dependencies() {\n        // RED PHASE: This test will FAIL until we implement call_expression extraction\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    helper();\n}\n\nfn helper() {\n    println!(\"Helper called\");\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities (main, helper)\n        assert_eq!(entities.len(), 2);\n\n        // Should extract 1 dependency: main -> helper (Calls)\n        assert_eq!(dependencies.len(), 1, \"Expected 1 dependency edge (main calls helper)\");\n\n        let edge = &dependencies[0];\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n\n        // The keys should reference main and helper\n        assert!(\n            edge.from_key.as_ref().contains(\"main\"),\n            \"from_key should contain 'main', got: {:?}\",\n            edge.from_key\n        );\n        assert!(\n            edge.to_key.as_ref().contains(\"helper\"),\n            \"to_key should contain 'helper', got: {:?}\",\n            edge.to_key\n        );\n    }",
    "future_code": "    fn test_extracts_function_call_dependencies() {\n        // RED PHASE: This test will FAIL until we implement call_expression extraction\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    helper();\n}\n\nfn helper() {\n    println!(\"Helper called\");\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities (main, helper)\n        assert_eq!(entities.len(), 2);\n\n        // Should extract 1 dependency: main -> helper (Calls)\n        assert_eq!(dependencies.len(), 1, \"Expected 1 dependency edge (main calls helper)\");\n\n        let edge = &dependencies[0];\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n\n        // The keys should reference main and helper\n        assert!(\n            edge.from_key.as_ref().contains(\"main\"),\n            \"from_key should contain 'main', got: {:?}\",\n            edge.from_key\n        );\n        assert!(\n            edge.to_key.as_ref().contains(\"helper\"),\n            \"to_key should contain 'helper', got: {:?}\",\n            edge.to_key\n        );\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436386Z",
      "modified_at": "2025-11-01T15:29:24.436386Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_extracts_multiple_function_calls:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:579-612",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_extracts_multiple_function_calls",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 579,
        "end": 612
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_extracts_multiple_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    foo();\n    bar();\n    baz();\n}\n\nfn foo() {}\nfn bar() {}\nfn baz() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities (main, foo, bar, baz)\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->foo, main->bar, main->baz\n        assert_eq!(dependencies.len(), 3, \"Expected 3 call edges from main\");\n\n        // Verify all are Calls edges from main\n        for edge in &dependencies {\n            assert_eq!(edge.edge_type, EdgeType::Calls);\n            assert!(edge.from_key.as_ref().contains(\"main\"));\n        }\n\n        // Check we have edges to each function\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"foo\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"bar\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"baz\")));\n    }",
    "future_code": "    fn test_extracts_multiple_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    foo();\n    bar();\n    baz();\n}\n\nfn foo() {}\nfn bar() {}\nfn baz() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities (main, foo, bar, baz)\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->foo, main->bar, main->baz\n        assert_eq!(dependencies.len(), 3, \"Expected 3 call edges from main\");\n\n        // Verify all are Calls edges from main\n        for edge in &dependencies {\n            assert_eq!(edge.edge_type, EdgeType::Calls);\n            assert!(edge.from_key.as_ref().contains(\"main\"));\n        }\n\n        // Check we have edges to each function\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"foo\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"bar\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"baz\")));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436387Z",
      "modified_at": "2025-11-01T15:29:24.436387Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_fetch_dependencies_multiple_edges:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:711-771",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_fetch_dependencies_multiple_edges",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 711,
        "end": 771
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_fetch_dependencies_multiple_edges() {\n        // RED: Test with multiple dependencies per entity\n        use parseltongue_core::entities::DependencyEdge;\n\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        storage.create_dependency_edges_schema().await.unwrap();\n\n        // Create entity A that calls both B and C\n        let entity_a = CodeEntity::new(\n            \"rust:fn:a:test_rs:1-10\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"a\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        storage.insert_entity(&entity_a).await.unwrap();\n\n        // Insert multiple dependencies: A -> B, A -> C\n        let edges = vec![\n            DependencyEdge::builder()\n                .from_key(\"rust:fn:a:test_rs:1-10\")\n                .to_key(\"rust:fn:b:test_rs:20-30\")\n                .edge_type(parseltongue_core::entities::EdgeType::Calls)\n                .build().unwrap(),\n            DependencyEdge::builder()\n                .from_key(\"rust:fn:a:test_rs:1-10\")\n                .to_key(\"rust:fn:c:test_rs:40-50\")\n                .edge_type(parseltongue_core::entities::EdgeType::Calls)\n                .build().unwrap(),\n        ];\n        storage.insert_edges_batch(&edges).await.unwrap();\n\n        // Create optimizer and fetch dependencies\n        let storage = Arc::new(storage);\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        let relationships = optimizer.fetch_real_dependencies(&[entity_a]).await.unwrap();\n\n        // Verify: Should find 2 relationships\n        assert_eq!(relationships.len(), 2, \"Should find 2 dependencies\");\n        assert!(relationships.iter().any(|r| r.target_id == \"rust:fn:b:test_rs:20-30\"));\n        assert!(relationships.iter().any(|r| r.target_id == \"rust:fn:c:test_rs:40-50\"));\n    }",
    "future_code": "    async fn test_fetch_dependencies_multiple_edges() {\n        // RED: Test with multiple dependencies per entity\n        use parseltongue_core::entities::DependencyEdge;\n\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        storage.create_dependency_edges_schema().await.unwrap();\n\n        // Create entity A that calls both B and C\n        let entity_a = CodeEntity::new(\n            \"rust:fn:a:test_rs:1-10\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"a\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        storage.insert_entity(&entity_a).await.unwrap();\n\n        // Insert multiple dependencies: A -> B, A -> C\n        let edges = vec![\n            DependencyEdge::builder()\n                .from_key(\"rust:fn:a:test_rs:1-10\")\n                .to_key(\"rust:fn:b:test_rs:20-30\")\n                .edge_type(parseltongue_core::entities::EdgeType::Calls)\n                .build().unwrap(),\n            DependencyEdge::builder()\n                .from_key(\"rust:fn:a:test_rs:1-10\")\n                .to_key(\"rust:fn:c:test_rs:40-50\")\n                .edge_type(parseltongue_core::entities::EdgeType::Calls)\n                .build().unwrap(),\n        ];\n        storage.insert_edges_batch(&edges).await.unwrap();\n\n        // Create optimizer and fetch dependencies\n        let storage = Arc::new(storage);\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        let relationships = optimizer.fetch_real_dependencies(&[entity_a]).await.unwrap();\n\n        // Verify: Should find 2 relationships\n        assert_eq!(relationships.len(), 2, \"Should find 2 dependencies\");\n        assert!(relationships.iter().any(|r| r.target_id == \"rust:fn:b:test_rs:20-30\"));\n        assert!(relationships.iter().any(|r| r.target_id == \"rust:fn:c:test_rs:40-50\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436388Z",
      "modified_at": "2025-11-01T15:29:24.436388Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_fetch_dependencies_with_empty_entities:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:695-708",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_fetch_dependencies_with_empty_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 695,
        "end": 708
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_fetch_dependencies_with_empty_entities() {\n        // RED: Test edge case with empty entity list\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        let storage = Arc::new(storage);\n\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        // Test with empty entities\n        let relationships = optimizer.fetch_real_dependencies(&[]).await.unwrap();\n\n        assert_eq!(relationships.len(), 0, \"Empty entities should return empty relationships\");\n    }",
    "future_code": "    async fn test_fetch_dependencies_with_empty_entities() {\n        // RED: Test edge case with empty entity list\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        let storage = Arc::new(storage);\n\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        // Test with empty entities\n        let relationships = optimizer.fetch_real_dependencies(&[]).await.unwrap();\n\n        assert_eq!(relationships.len(), 0, \"Empty entities should return empty relationships\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436389Z",
      "modified_at": "2025-11-01T15:29:24.436389Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_fetch_real_dependencies_from_cozodb:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:611-692",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_fetch_real_dependencies_from_cozodb",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 611,
        "end": 692
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_fetch_real_dependencies_from_cozodb() {\n        // RED: Test real dependency fetching from CozoDB\n        use parseltongue_core::entities::DependencyEdge;\n\n        // Create in-memory storage and set up dependency schema\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        storage.create_dependency_edges_schema().await.unwrap();\n\n        // Insert test entities and dependencies\n        let entity_a = CodeEntity::new(\n            \"rust:fn:function_a:test_rs:1-10\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"function_a\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        let entity_b = CodeEntity::new(\n            \"rust:fn:function_b:test_rs:20-30\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"function_b\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(20, 30).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        storage.insert_entity(&entity_a).await.unwrap();\n        storage.insert_entity(&entity_b).await.unwrap();\n\n        // Insert dependency: A calls B\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:function_a:test_rs:1-10\")\n            .to_key(\"rust:fn:function_b:test_rs:20-30\")\n            .edge_type(parseltongue_core::entities::EdgeType::Calls)\n            .build()\n            .unwrap();\n        storage.insert_edge(&edge).await.unwrap();\n\n        // Create optimizer with populated storage\n        let storage = Arc::new(storage);\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        // Test: Fetch real dependencies\n        let entities = vec![entity_a, entity_b];\n        let relationships = optimizer.fetch_real_dependencies(&entities).await.unwrap();\n\n        // Verify: Should find 1 relationship (A -> B)\n        assert_eq!(relationships.len(), 1, \"Should find 1 dependency relationship\");\n        assert_eq!(relationships[0].source_id, \"rust:fn:function_a:test_rs:1-10\");\n        assert_eq!(relationships[0].target_id, \"rust:fn:function_b:test_rs:20-30\");\n        assert!(matches!(relationships[0].relationship_type, RelationshipType::Calls));\n    }",
    "future_code": "    async fn test_fetch_real_dependencies_from_cozodb() {\n        // RED: Test real dependency fetching from CozoDB\n        use parseltongue_core::entities::DependencyEdge;\n\n        // Create in-memory storage and set up dependency schema\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n        storage.create_dependency_edges_schema().await.unwrap();\n\n        // Insert test entities and dependencies\n        let entity_a = CodeEntity::new(\n            \"rust:fn:function_a:test_rs:1-10\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"function_a\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        let entity_b = CodeEntity::new(\n            \"rust:fn:function_b:test_rs:20-30\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"function_b\".to_string(),\n                visibility: Visibility::Public,\n                file_path: \"test.rs\".into(),\n                line_range: LineRange::new(20, 30).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: parseltongue_core::entities::LanguageSpecificSignature::Rust(\n                    parseltongue_core::entities::RustSignature {\n                        generics: vec![],\n                        lifetimes: vec![],\n                        where_clauses: vec![],\n                        attributes: vec![],\n                        trait_impl: None,\n                    }\n                ),\n            },\n        ).unwrap();\n\n        storage.insert_entity(&entity_a).await.unwrap();\n        storage.insert_entity(&entity_b).await.unwrap();\n\n        // Insert dependency: A calls B\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:function_a:test_rs:1-10\")\n            .to_key(\"rust:fn:function_b:test_rs:20-30\")\n            .edge_type(parseltongue_core::entities::EdgeType::Calls)\n            .build()\n            .unwrap();\n        storage.insert_edge(&edge).await.unwrap();\n\n        // Create optimizer with populated storage\n        let storage = Arc::new(storage);\n        let config = crate::ContextWriterConfig::default();\n        let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n        let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n        // Test: Fetch real dependencies\n        let entities = vec![entity_a, entity_b];\n        let relationships = optimizer.fetch_real_dependencies(&entities).await.unwrap();\n\n        // Verify: Should find 1 relationship (A -> B)\n        assert_eq!(relationships.len(), 1, \"Should find 1 dependency relationship\");\n        assert_eq!(relationships[0].source_id, \"rust:fn:function_a:test_rs:1-10\");\n        assert_eq!(relationships[0].target_id, \"rust:fn:function_b:test_rs:20-30\");\n        assert!(matches!(relationships[0].relationship_type, RelationshipType::Calls));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436390Z",
      "modified_at": "2025-11-01T15:29:24.436390Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_filter_current_ind_entities:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:272-324",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_filter_current_ind_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 272,
        "end": 324
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_filter_current_ind_entities() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Entity 1: current_ind=true (should be included)\n    let entity1 = create_test_entity(\n        \"rust:fn:current:src_lib_rs:1-10\",\n        Some(\"fn current() {}\"),\n        TemporalState::unchanged(), // current_ind=true\n    );\n\n    // Entity 2: current_ind=false (should be EXCLUDED)\n    let entity2 = create_test_entity(\n        \"rust:fn:future:src_lib_rs:20-30\",\n        Some(\"fn future() {}\"),\n        TemporalState::create(), // current_ind=false, future_ind=true\n    );\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // EXPECTATION: Only 1 entity (current_ind=true) should be processed\n    // CURRENT: Will FAIL because implementation doesn't filter by current_ind\n    assert_eq!(\n        result.entities_processed, 1,\n        \"Should only process entities with current_ind=true\"\n    );\n\n    // Verify JSON contains only the current entity\n    let json_content = std::fs::read_to_string(&output_path).unwrap();\n    assert!(json_content.contains(\"current\"));\n    assert!(!json_content.contains(\"future\"));\n}",
    "future_code": "async fn test_filter_current_ind_entities() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Entity 1: current_ind=true (should be included)\n    let entity1 = create_test_entity(\n        \"rust:fn:current:src_lib_rs:1-10\",\n        Some(\"fn current() {}\"),\n        TemporalState::unchanged(), // current_ind=true\n    );\n\n    // Entity 2: current_ind=false (should be EXCLUDED)\n    let entity2 = create_test_entity(\n        \"rust:fn:future:src_lib_rs:20-30\",\n        Some(\"fn future() {}\"),\n        TemporalState::create(), // current_ind=false, future_ind=true\n    );\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // EXPECTATION: Only 1 entity (current_ind=true) should be processed\n    // CURRENT: Will FAIL because implementation doesn't filter by current_ind\n    assert_eq!(\n        result.entities_processed, 1,\n        \"Should only process entities with current_ind=true\"\n    );\n\n    // Verify JSON contains only the current entity\n    let json_content = std::fs::read_to_string(&output_path).unwrap();\n    assert!(json_content.contains(\"current\"));\n    assert!(!json_content.contains(\"future\"));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436391Z",
      "modified_at": "2025-11-01T15:29:24.436391Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_focus_areas_parsing:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:321-330",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_focus_areas_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 321,
        "end": 330
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_focus_areas_parsing() {\n        let areas = CliConfig::parse_focus_areas(\"core_types, implementations, tests\");\n        assert_eq!(areas.len(), 3);\n        assert_eq!(areas[0], \"core_types\");\n        assert_eq!(areas[1], \"implementations\");\n        assert_eq!(areas[2], \"tests\");\n\n        let empty_areas = CliConfig::parse_focus_areas(\"\");\n        assert_eq!(empty_areas.len(), 0);\n    }",
    "future_code": "    fn test_focus_areas_parsing() {\n        let areas = CliConfig::parse_focus_areas(\"core_types, implementations, tests\");\n        assert_eq!(areas.len(), 3);\n        assert_eq!(areas[0], \"core_types\");\n        assert_eq!(areas[1], \"implementations\");\n        assert_eq!(areas[2], \"tests\");\n\n        let empty_areas = CliConfig::parse_focus_areas(\"\");\n        assert_eq!(empty_areas.len(), 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436392Z",
      "modified_at": "2025-11-01T15:29:24.436392Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_forward_dependencies_empty:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:682-691",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_forward_dependencies_empty",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 682,
        "end": 691
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_forward_dependencies_empty() {\n    // RED: Test entity with no forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no outgoing edges\n    let deps = db.get_forward_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no outgoing edges should return empty\");\n}",
    "future_code": "async fn test_forward_dependencies_empty() {\n    // RED: Test entity with no forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no outgoing edges\n    let deps = db.get_forward_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no outgoing edges should return empty\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436393Z",
      "modified_at": "2025-11-01T15:29:24.436394Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_forward_dependencies_multiple:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:606-641",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_forward_dependencies_multiple",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 606,
        "end": 641
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_forward_dependencies_multiple() {\n    // RED: Test multiple forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B, A -> C, A -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: A should depend on B, C, D\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"A should depend on 3 entities\");\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(deps.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "future_code": "async fn test_forward_dependencies_multiple() {\n    // RED: Test multiple forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B, A -> C, A -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: A should depend on B, C, D\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"A should depend on 3 entities\");\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(deps.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436394Z",
      "modified_at": "2025-11-01T15:29:24.436395Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_forward_dependencies_performance_10k_nodes:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:982-1019",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_forward_dependencies_performance_10k_nodes",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 982,
        "end": 1019
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_forward_dependencies_performance_10k_nodes() {\n    // RED: Validate 1-hop query performance at scale (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 5 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let nodes = generate_large_graph(&db, 10_000, 5).await;\n\n    // Warm up\n    let _ = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n\n    // Performance test: Simple 1-hop query should be very fast\n    println!(\"Running forward dependencies query (1-hop on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Forward dependencies returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <20ms for simple 1-hop query on 10k nodes (release mode)\n    // Note: Debug builds may be 5-10x slower - performance contracts are for release builds\n    assert!(\n        elapsed < Duration::from_millis(20),\n        \"1-hop query took {:?}, expected <20ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find forward dependencies for first node\"\n    );\n}",
    "future_code": "async fn test_forward_dependencies_performance_10k_nodes() {\n    // RED: Validate 1-hop query performance at scale (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 5 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let nodes = generate_large_graph(&db, 10_000, 5).await;\n\n    // Warm up\n    let _ = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n\n    // Performance test: Simple 1-hop query should be very fast\n    println!(\"Running forward dependencies query (1-hop on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Forward dependencies returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <20ms for simple 1-hop query on 10k nodes (release mode)\n    // Note: Debug builds may be 5-10x slower - performance contracts are for release builds\n    assert!(\n        elapsed < Duration::from_millis(20),\n        \"1-hop query took {:?}, expected <20ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find forward dependencies for first node\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436395Z",
      "modified_at": "2025-11-01T15:29:24.436396Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_forward_dependencies_single:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:562-581",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_forward_dependencies_single",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 562,
        "end": 581
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_forward_dependencies_single() {\n    // RED: Test forward dependencies (outgoing edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: A's forward dependencies should return [B]\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"A should depend on 1 entity\");\n    assert_eq!(deps[0], \"rust:fn:B:test_rs:10-15\");\n}",
    "future_code": "async fn test_forward_dependencies_single() {\n    // RED: Test forward dependencies (outgoing edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: A's forward dependencies should return [B]\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"A should depend on 1 entity\");\n    assert_eq!(deps[0], \"rust:fn:B:test_rs:10-15\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436396Z",
      "modified_at": "2025-11-01T15:29:24.436396Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_function_detection:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:488-535",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_function_detection",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 488,
        "end": 535
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_function_detection() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\n#[test]\nfn test_something() {\n    assert_eq!(1, 1);\n}\n\nfn regular_function() {\n    println!(\"Hello\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn another_test() {\n        assert!(true);\n    }\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, _dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Debug: print all entities\n        println!(\"\\nExtracted {} entities:\", entities.len());\n        for (i, entity) in entities.iter().enumerate() {\n            println!(\"  {}. {} (type: {:?}, is_test: {:?})\",\n                i, entity.name, entity.entity_type, entity.metadata.get(\"is_test\"));\n        }\n\n        // Find the test function and regular function\n        let test_fn = entities.iter().find(|e| e.name == \"test_something\");\n        let regular_fn = entities.iter().find(|e| e.name == \"regular_function\");\n\n        assert!(test_fn.is_some(), \"Should find test function\");\n        assert!(regular_fn.is_some(), \"Should find regular function\");\n\n        // Verify test function has is_test metadata\n        let test_fn = test_fn.unwrap();\n        println!(\"\\ntest_something metadata: {:?}\", test_fn.metadata);\n        assert_eq!(test_fn.metadata.get(\"is_test\"), Some(&\"true\".to_string()));\n\n        // Verify regular function does NOT have is_test metadata\n        let regular_fn = regular_fn.unwrap();\n        println!(\"regular_function metadata: {:?}\", regular_fn.metadata);\n        assert_eq!(regular_fn.metadata.get(\"is_test\"), None);\n    }",
    "future_code": "    fn test_function_detection() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\n#[test]\nfn test_something() {\n    assert_eq!(1, 1);\n}\n\nfn regular_function() {\n    println!(\"Hello\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn another_test() {\n        assert!(true);\n    }\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, _dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Debug: print all entities\n        println!(\"\\nExtracted {} entities:\", entities.len());\n        for (i, entity) in entities.iter().enumerate() {\n            println!(\"  {}. {} (type: {:?}, is_test: {:?})\",\n                i, entity.name, entity.entity_type, entity.metadata.get(\"is_test\"));\n        }\n\n        // Find the test function and regular function\n        let test_fn = entities.iter().find(|e| e.name == \"test_something\");\n        let regular_fn = entities.iter().find(|e| e.name == \"regular_function\");\n\n        assert!(test_fn.is_some(), \"Should find test function\");\n        assert!(regular_fn.is_some(), \"Should find regular function\");\n\n        // Verify test function has is_test metadata\n        let test_fn = test_fn.unwrap();\n        println!(\"\\ntest_something metadata: {:?}\", test_fn.metadata);\n        assert_eq!(test_fn.metadata.get(\"is_test\"), Some(&\"true\".to_string()));\n\n        // Verify regular function does NOT have is_test metadata\n        let regular_fn = regular_fn.unwrap();\n        println!(\"regular_function metadata: {:?}\", regular_fn.metadata);\n        assert_eq!(regular_fn.metadata.get(\"is_test\"), None);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436398Z",
      "modified_at": "2025-11-01T15:29:24.436398Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_function_with_test_attribute_classified_correctly:______crates_pt01-folder-to-cozodb-streamer_tests_tdd_classification_test_rs:22-91",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_function_with_test_attribute_classified_correctly",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs",
      "line_range": {
        "start": 22,
        "end": 91
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_function_with_test_attribute_classified_correctly() {\n    // Setup: Create temp directory with Rust test file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[test]\nfn test_example() {\n    assert_eq!(1 + 1, 2);\n}\n\nfn regular_function() {\n    println!(\"Not a test\");\n}\n\"#,\n    )\n    .unwrap();\n\n    // Setup database\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Execute: Index with Tool 1\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    // Verify: Check classifications\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    // Should have 2 entities: 1 test, 1 code\n    assert_eq!(entities.len(), 2, \"Should have exactly 2 entities\");\n\n    // Find test function\n    let test_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"test_example\")\n        .expect(\"Should find test_example function\");\n\n    // RED: This will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"Test function should be classified as TEST_IMPLEMENTATION\"\n    );\n\n    // Find regular function\n    let code_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"regular_function\")\n        .expect(\"Should find regular_function\");\n\n    assert_eq!(\n        code_entity.tdd_classification.entity_class,\n        EntityClass::CodeImplementation,\n        \"Regular function should be classified as CODE_IMPLEMENTATION\"\n    );\n}",
    "future_code": "async fn test_function_with_test_attribute_classified_correctly() {\n    // Setup: Create temp directory with Rust test file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[test]\nfn test_example() {\n    assert_eq!(1 + 1, 2);\n}\n\nfn regular_function() {\n    println!(\"Not a test\");\n}\n\"#,\n    )\n    .unwrap();\n\n    // Setup database\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Execute: Index with Tool 1\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    // Verify: Check classifications\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    // Should have 2 entities: 1 test, 1 code\n    assert_eq!(entities.len(), 2, \"Should have exactly 2 entities\");\n\n    // Find test function\n    let test_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"test_example\")\n        .expect(\"Should find test_example function\");\n\n    // RED: This will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"Test function should be classified as TEST_IMPLEMENTATION\"\n    );\n\n    // Find regular function\n    let code_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"regular_function\")\n        .expect(\"Should find regular_function\");\n\n    assert_eq!(\n        code_entity.tdd_classification.entity_class,\n        EntityClass::CodeImplementation,\n        \"Regular function should be classified as CODE_IMPLEMENTATION\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436399Z",
      "modified_at": "2025-11-01T15:29:24.436399Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_context_from_real_cozodb:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:21-70",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_context_from_real_cozodb",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 21,
        "end": 70
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_generate_context_from_real_cozodb() {\n    // Setup: Use in-memory database for shared access\n    let storage = CozoDbStorage::new(\"mem\")\n        .await\n        .expect(\"Failed to create storage\");\n    storage\n        .create_schema()\n        .await\n        .expect(\"Failed to create schema\");\n\n    // Insert test entity with current_ind=1\n    let entity = create_test_entity(\n        \"rust:fn:test_function:src_lib_rs:10-20\",\n        Some(\"fn test_function() {}\"),\n        TemporalState::unchanged(), // current_ind=1, future_ind=1, future_action=None\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Create config pointing to same database\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    // Generate context (with dependency injection)\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await;\n\n    // EXPECTATION: Should successfully read from CozoDB\n    assert!(\n        result.is_ok(),\n        \"Should successfully generate context from real CozoDB: {:?}\",\n        result.err()\n    );\n    assert_eq!(result.unwrap().entities_processed, 1);\n}",
    "future_code": "async fn test_generate_context_from_real_cozodb() {\n    // Setup: Use in-memory database for shared access\n    let storage = CozoDbStorage::new(\"mem\")\n        .await\n        .expect(\"Failed to create storage\");\n    storage\n        .create_schema()\n        .await\n        .expect(\"Failed to create schema\");\n\n    // Insert test entity with current_ind=1\n    let entity = create_test_entity(\n        \"rust:fn:test_function:src_lib_rs:10-20\",\n        Some(\"fn test_function() {}\"),\n        TemporalState::unchanged(), // current_ind=1, future_ind=1, future_action=None\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Create config pointing to same database\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    // Generate context (with dependency injection)\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await;\n\n    // EXPECTATION: Should successfully read from CozoDB\n    assert!(\n        result.is_ok(),\n        \"Should successfully generate context from real CozoDB: {:?}\",\n        result.err()\n    );\n    assert_eq!(result.unwrap().entities_processed, 1);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436400Z",
      "modified_at": "2025-11-01T15:29:24.436400Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_diff_for_create_operations:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:12-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_diff_for_create_operations",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 12,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_generate_diff_for_create_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Create action\n    let entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc123\",\n        Some(\"fn new_feature() { println!(\\\"New!\\\"); }\"),\n        TemporalAction::Create,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 0);\n    assert_eq!(diff.metadata.delete_count, 0);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Create);\n    assert!(change.future_code.is_some());\n}",
    "future_code": "async fn test_generate_diff_for_create_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Create action\n    let entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc123\",\n        Some(\"fn new_feature() { println!(\\\"New!\\\"); }\"),\n        TemporalAction::Create,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 0);\n    assert_eq!(diff.metadata.delete_count, 0);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Create);\n    assert!(change.future_code.is_some());\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436401Z",
      "modified_at": "2025-11-01T15:29:24.436402Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_diff_for_delete_operations:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:80-110",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_diff_for_delete_operations",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 80,
        "end": 110
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_generate_diff_for_delete_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Delete action\n    let mut entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:100-110\",\n        None, // No future_code for delete\n        TemporalAction::Delete,\n    );\n    entity.future_code = None; // Delete doesn't need future code\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Delete);\n    assert!(change.future_code.is_none());\n}",
    "future_code": "async fn test_generate_diff_for_delete_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Delete action\n    let mut entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:100-110\",\n        None, // No future_code for delete\n        TemporalAction::Delete,\n    );\n    entity.future_code = None; // Delete doesn't need future code\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Delete);\n    assert!(change.future_code.is_none());\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436402Z",
      "modified_at": "2025-11-01T15:29:24.436403Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_diff_for_edit_operations:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:47-76",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_diff_for_edit_operations",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 47,
        "end": 76
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_generate_diff_for_edit_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Edit action\n    let entity = create_test_entity(\n        \"rust:fn:calculate_sum:src_lib_rs:42-56\",\n        Some(\"fn calculate_sum(a: i32, b: i32) -> i32 { a + b /* fixed */ }\"),\n        TemporalAction::Edit,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Edit);\n    assert!(change.future_code.is_some());\n}",
    "future_code": "async fn test_generate_diff_for_edit_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Edit action\n    let entity = create_test_entity(\n        \"rust:fn:calculate_sum:src_lib_rs:42-56\",\n        Some(\"fn calculate_sum(a: i32, b: i32) -> i32 { a + b /* fixed */ }\"),\n        TemporalAction::Edit,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Edit);\n    assert!(change.future_code.is_some());\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436403Z",
      "modified_at": "2025-11-01T15:29:24.436403Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_diff_from_real_cozodb:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:52-94",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_diff_from_real_cozodb",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 52,
        "end": 94
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_generate_diff_from_real_cozodb() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\")\n        .await\n        .expect(\"Failed to create storage\");\n    storage\n        .create_schema()\n        .await\n        .expect(\"Failed to create schema\");\n\n    // Insert test entity with Future_Action = Edit\n    let entity = create_test_entity(\n        \"rust:fn:test_function:src_lib_rs:10-20\",\n        Some(\"fn test_function() { /* old */ }\"),\n        Some(\"fn test_function() { /* new */ }\"),\n        TemporalState::edit(),\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Create diff generator with dependency injection\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n\n    // Generate diff\n    let result = generator.generate_diff().await;\n\n    // EXPECTATION: Should successfully read from CozoDB\n    assert!(\n        result.is_ok(),\n        \"Should successfully generate diff from real CozoDB: {:?}\",\n        result.err()\n    );\n\n    let diff = result.unwrap();\n    assert_eq!(\n        diff.metadata.total_changes, 1,\n        \"Should have 1 change (entity with Future_Action)\"\n    );\n}",
    "future_code": "async fn test_generate_diff_from_real_cozodb() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\")\n        .await\n        .expect(\"Failed to create storage\");\n    storage\n        .create_schema()\n        .await\n        .expect(\"Failed to create schema\");\n\n    // Insert test entity with Future_Action = Edit\n    let entity = create_test_entity(\n        \"rust:fn:test_function:src_lib_rs:10-20\",\n        Some(\"fn test_function() { /* old */ }\"),\n        Some(\"fn test_function() { /* new */ }\"),\n        TemporalState::edit(),\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Create diff generator with dependency injection\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n\n    // Generate diff\n    let result = generator.generate_diff().await;\n\n    // EXPECTATION: Should successfully read from CozoDB\n    assert!(\n        result.is_ok(),\n        \"Should successfully generate diff from real CozoDB: {:?}\",\n        result.err()\n    );\n\n    let diff = result.unwrap();\n    assert_eq!(\n        diff.metadata.total_changes, 1,\n        \"Should have 1 change (entity with Future_Action)\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436404Z",
      "modified_at": "2025-11-01T15:29:24.436404Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_basic:______crates_parseltongue-core_src_entities_rs:1185-1206",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_basic",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1185,
        "end": 1206
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_basic() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp\n        );\n\n        // Should follow format: filepath-name-type-hash8\n        assert!(key.contains(\"src_lib_rs\"));\n        assert!(key.contains(\"new_feature\"));\n        assert!(key.contains(\"-fn-\"));\n\n        // Hash should be 8 characters\n        let parts: Vec<&str> = key.split('-').collect();\n        assert!(parts.len() >= 4, \"Key should have at least 4 parts separated by hyphens\");\n        let hash_part = parts.last().unwrap();\n        assert_eq!(hash_part.len(), 8, \"Hash should be exactly 8 characters\");\n    }",
    "future_code": "    fn test_generate_new_entity_key_basic() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp\n        );\n\n        // Should follow format: filepath-name-type-hash8\n        assert!(key.contains(\"src_lib_rs\"));\n        assert!(key.contains(\"new_feature\"));\n        assert!(key.contains(\"-fn-\"));\n\n        // Hash should be 8 characters\n        let parts: Vec<&str> = key.split('-').collect();\n        assert!(parts.len() >= 4, \"Key should have at least 4 parts separated by hyphens\");\n        let hash_part = parts.last().unwrap();\n        assert_eq!(hash_part.len(), 8, \"Hash should be exactly 8 characters\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436405Z",
      "modified_at": "2025-11-01T15:29:24.436405Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_different_types:______crates_parseltongue-core_src_entities_rs:1209-1258",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_different_types",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1209,
        "end": 1258
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_different_types() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test Function type\n        let fn_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_fn\",\n            &EntityType::Function,\n            timestamp\n        );\n        assert!(fn_key.contains(\"-fn-\"));\n\n        // Test Struct type\n        let struct_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestStruct\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(struct_key.contains(\"-struct-\"));\n\n        // Test Enum type\n        let enum_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestEnum\",\n            &EntityType::Enum,\n            timestamp\n        );\n        assert!(enum_key.contains(\"-enum-\"));\n\n        // Test Trait type\n        let trait_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestTrait\",\n            &EntityType::Trait,\n            timestamp\n        );\n        assert!(trait_key.contains(\"-trait-\"));\n\n        // Test Module type\n        let mod_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_module\",\n            &EntityType::Module,\n            timestamp\n        );\n        assert!(mod_key.contains(\"-mod-\"));\n    }",
    "future_code": "    fn test_generate_new_entity_key_different_types() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test Function type\n        let fn_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_fn\",\n            &EntityType::Function,\n            timestamp\n        );\n        assert!(fn_key.contains(\"-fn-\"));\n\n        // Test Struct type\n        let struct_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestStruct\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(struct_key.contains(\"-struct-\"));\n\n        // Test Enum type\n        let enum_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestEnum\",\n            &EntityType::Enum,\n            timestamp\n        );\n        assert!(enum_key.contains(\"-enum-\"));\n\n        // Test Trait type\n        let trait_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestTrait\",\n            &EntityType::Trait,\n            timestamp\n        );\n        assert!(trait_key.contains(\"-trait-\"));\n\n        // Test Module type\n        let mod_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_module\",\n            &EntityType::Module,\n            timestamp\n        );\n        assert!(mod_key.contains(\"-mod-\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436406Z",
      "modified_at": "2025-11-01T15:29:24.436406Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_format:______crates_parseltongue-core_src_entities_rs:1322-1347",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_format",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1322,
        "end": 1347
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_format() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n\n        // Expected format: src_models_user_rs-UserProfile-struct-abc12345\n        let parts: Vec<&str> = key.split('-').collect();\n\n        // Should have exactly 4 parts: path, name, type, hash\n        assert_eq!(parts.len(), 4, \"Key should have exactly 4 hyphen-separated parts\");\n\n        // Verify each part\n        assert_eq!(parts[0], \"src_models_user_rs\");\n        assert_eq!(parts[1], \"UserProfile\");\n        assert_eq!(parts[2], \"struct\");\n        assert_eq!(parts[3].len(), 8, \"Hash should be 8 characters\");\n\n        // Hash should be lowercase hexadecimal\n        assert!(parts[3].chars().all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase()));\n    }",
    "future_code": "    fn test_generate_new_entity_key_format() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n\n        // Expected format: src_models_user_rs-UserProfile-struct-abc12345\n        let parts: Vec<&str> = key.split('-').collect();\n\n        // Should have exactly 4 parts: path, name, type, hash\n        assert_eq!(parts.len(), 4, \"Key should have exactly 4 hyphen-separated parts\");\n\n        // Verify each part\n        assert_eq!(parts[0], \"src_models_user_rs\");\n        assert_eq!(parts[1], \"UserProfile\");\n        assert_eq!(parts[2], \"struct\");\n        assert_eq!(parts[3].len(), 8, \"Hash should be 8 characters\");\n\n        // Hash should be lowercase hexadecimal\n        assert!(parts[3].chars().all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase()));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436407Z",
      "modified_at": "2025-11-01T15:29:24.436407Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_impl_block:______crates_parseltongue-core_src_entities_rs:1350-1366",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_impl_block",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1350,
        "end": 1366
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_impl_block() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test ImplBlock type (should default to \"impl\")\n        let impl_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"MyStruct\",\n            &EntityType::ImplBlock {\n                trait_name: Some(\"Display\".to_string()),\n                struct_name: \"MyStruct\".to_string(),\n            },\n            timestamp\n        );\n        assert!(impl_key.contains(\"-impl-\"));\n    }",
    "future_code": "    fn test_generate_new_entity_key_impl_block() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test ImplBlock type (should default to \"impl\")\n        let impl_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"MyStruct\",\n            &EntityType::ImplBlock {\n                trait_name: Some(\"Display\".to_string()),\n                struct_name: \"MyStruct\".to_string(),\n            },\n            timestamp\n        );\n        assert!(impl_key.contains(\"-impl-\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436408Z",
      "modified_at": "2025-11-01T15:29:24.436408Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_path_sanitization:______crates_parseltongue-core_src_entities_rs:1261-1289",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_path_sanitization",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1261,
        "end": 1289
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_path_sanitization() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test forward slashes\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key1.contains(\"src_models_user_rs\"));\n        assert!(!key1.contains('/'));\n\n        // Test dots in filename\n        assert!(key1.contains(\"_rs\"));\n        assert!(!key1.contains(\".rs\"));\n\n        // Test backslashes (Windows paths)\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src\\\\models\\\\user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key2.contains(\"src_models_user_rs\"));\n        assert!(!key2.contains('\\\\'));\n    }",
    "future_code": "    fn test_generate_new_entity_key_path_sanitization() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test forward slashes\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key1.contains(\"src_models_user_rs\"));\n        assert!(!key1.contains('/'));\n\n        // Test dots in filename\n        assert!(key1.contains(\"_rs\"));\n        assert!(!key1.contains(\".rs\"));\n\n        // Test backslashes (Windows paths)\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src\\\\models\\\\user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key2.contains(\"src_models_user_rs\"));\n        assert!(!key2.contains('\\\\'));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436409Z",
      "modified_at": "2025-11-01T15:29:24.436409Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_generate_new_entity_key_uniqueness:______crates_parseltongue-core_src_entities_rs:1292-1319",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_generate_new_entity_key_uniqueness",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1292,
        "end": 1319
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_generate_new_entity_key_uniqueness() {\n        use chrono::TimeZone;\n\n        // Same inputs but different timestamps should produce different keys\n        let timestamp1 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let timestamp2 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 1, 0).unwrap();\n\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp1\n        );\n\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp2\n        );\n\n        assert_ne!(key1, key2, \"Different timestamps should produce different keys\");\n\n        // Extract hash parts to verify they're different\n        let hash1 = key1.split('-').last().unwrap();\n        let hash2 = key2.split('-').last().unwrap();\n        assert_ne!(hash1, hash2, \"Hash parts should be different\");\n    }",
    "future_code": "    fn test_generate_new_entity_key_uniqueness() {\n        use chrono::TimeZone;\n\n        // Same inputs but different timestamps should produce different keys\n        let timestamp1 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let timestamp2 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 1, 0).unwrap();\n\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp1\n        );\n\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp2\n        );\n\n        assert_ne!(key1, key2, \"Different timestamps should produce different keys\");\n\n        // Extract hash parts to verify they're different\n        let hash1 = key1.split('-').last().unwrap();\n        let hash2 = key2.split('-').last().unwrap();\n        assert_ne!(hash1, hash2, \"Hash parts should be different\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436410Z",
      "modified_at": "2025-11-01T15:29:24.436410Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_graph_analysis:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:563-583",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_graph_analysis",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 563,
        "end": 583
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_graph_analysis() {\n        // Create runtime for async test\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n            let storage = Arc::new(storage);\n\n            let config = crate::ContextWriterConfig::default();\n            let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n            let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n            let entities = optimizer.create_sample_entities().unwrap();\n            let relationships = optimizer.create_sample_relationships(&entities);\n\n            let density = optimizer.calculate_graph_density(&entities, &relationships);\n            assert!(density >= 0.0 && density <= 1.0);\n\n            let avg_degree = optimizer.calculate_average_degree(&entities, &relationships);\n            assert!(avg_degree >= 0.0);\n        });\n    }",
    "future_code": "    fn test_graph_analysis() {\n        // Create runtime for async test\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n            let storage = Arc::new(storage);\n\n            let config = crate::ContextWriterConfig::default();\n            let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n            let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n            let entities = optimizer.create_sample_entities().unwrap();\n            let relationships = optimizer.create_sample_relationships(&entities);\n\n            let density = optimizer.calculate_graph_density(&entities, &relationships);\n            assert!(density >= 0.0 && density <= 1.0);\n\n            let avg_degree = optimizer.calculate_average_degree(&entities, &relationships);\n            assert!(avg_degree >= 0.0);\n        });\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436411Z",
      "modified_at": "2025-11-01T15:29:24.436411Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_handles_all_operation_types:______crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:243-325",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_handles_all_operation_types",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 243,
        "end": 325
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_handles_all_operation_types() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // CREATE: Hash-based ISGL1 key, no current_code\n    let create_entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc12345\",\n        None, // No current code (doesn't exist yet)\n        Some(\"fn new_feature() { /* brand new */ }\"),\n        TemporalState::create(),\n    );\n\n    // EDIT: Line-based ISGL1 key, has both current and future code\n    let edit_entity = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:100-120\",\n        Some(\"fn existing() { /* old */ }\"),\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalState::edit(),\n    );\n\n    // DELETE: Line-based ISGL1 key, no future code\n    let delete_entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:200-220\",\n        Some(\"fn obsolete() { /* to be removed */ }\"),\n        None, // No future code (being deleted)\n        TemporalState::delete(),\n    );\n\n    storage.insert_entity(&create_entity).await.unwrap();\n    storage.insert_entity(&edit_entity).await.unwrap();\n    storage.insert_entity(&delete_entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Should have 3 changes with correct operations\n    assert_eq!(diff.metadata.total_changes, 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    // Verify CREATE operation\n    let create_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Create)\n        .expect(\"Should have CREATE operation\");\n    assert!(create_change.current_code.is_none(), \"CREATE has no current_code\");\n    assert!(create_change.future_code.is_some(), \"CREATE has future_code\");\n    assert!(\n        create_change.line_range.is_none(),\n        \"CREATE (hash-based key) has no line_range\"\n    );\n\n    // Verify EDIT operation\n    let edit_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Edit)\n        .expect(\"Should have EDIT operation\");\n    assert!(edit_change.current_code.is_some(), \"EDIT has current_code\");\n    assert!(edit_change.future_code.is_some(), \"EDIT has future_code\");\n    assert!(\n        edit_change.line_range.is_some(),\n        \"EDIT (line-based key) has line_range\"\n    );\n\n    // Verify DELETE operation\n    let delete_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Delete)\n        .expect(\"Should have DELETE operation\");\n    assert!(delete_change.current_code.is_some(), \"DELETE has current_code\");\n    assert!(delete_change.future_code.is_none(), \"DELETE has no future_code\");\n    assert!(\n        delete_change.line_range.is_some(),\n        \"DELETE (line-based key) has line_range\"\n    );\n}",
    "future_code": "async fn test_handles_all_operation_types() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // CREATE: Hash-based ISGL1 key, no current_code\n    let create_entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc12345\",\n        None, // No current code (doesn't exist yet)\n        Some(\"fn new_feature() { /* brand new */ }\"),\n        TemporalState::create(),\n    );\n\n    // EDIT: Line-based ISGL1 key, has both current and future code\n    let edit_entity = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:100-120\",\n        Some(\"fn existing() { /* old */ }\"),\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalState::edit(),\n    );\n\n    // DELETE: Line-based ISGL1 key, no future code\n    let delete_entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:200-220\",\n        Some(\"fn obsolete() { /* to be removed */ }\"),\n        None, // No future code (being deleted)\n        TemporalState::delete(),\n    );\n\n    storage.insert_entity(&create_entity).await.unwrap();\n    storage.insert_entity(&edit_entity).await.unwrap();\n    storage.insert_entity(&delete_entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Should have 3 changes with correct operations\n    assert_eq!(diff.metadata.total_changes, 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    // Verify CREATE operation\n    let create_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Create)\n        .expect(\"Should have CREATE operation\");\n    assert!(create_change.current_code.is_none(), \"CREATE has no current_code\");\n    assert!(create_change.future_code.is_some(), \"CREATE has future_code\");\n    assert!(\n        create_change.line_range.is_none(),\n        \"CREATE (hash-based key) has no line_range\"\n    );\n\n    // Verify EDIT operation\n    let edit_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Edit)\n        .expect(\"Should have EDIT operation\");\n    assert!(edit_change.current_code.is_some(), \"EDIT has current_code\");\n    assert!(edit_change.future_code.is_some(), \"EDIT has future_code\");\n    assert!(\n        edit_change.line_range.is_some(),\n        \"EDIT (line-based key) has line_range\"\n    );\n\n    // Verify DELETE operation\n    let delete_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Delete)\n        .expect(\"Should have DELETE operation\");\n    assert!(delete_change.current_code.is_some(), \"DELETE has current_code\");\n    assert!(delete_change.future_code.is_none(), \"DELETE has no future_code\");\n    assert!(\n        delete_change.line_range.is_some(),\n        \"DELETE (line-based key) has line_range\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436412Z",
      "modified_at": "2025-11-01T15:29:24.436412Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_import_error_passes_syntax_check:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:138-153",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_import_error_passes_syntax_check",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 138,
        "end": 153
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_import_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has an import error (module doesn't exist) but is syntactically valid\n    let import_error_code = r#\"\n        use nonexistent::Module;\n\n        fn test() {}\n    \"#;\n\n    let result = validator.validate_syntax(import_error_code).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Import errors should pass syntax validation (cargo catches these)\"\n    );\n}",
    "future_code": "fn test_import_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has an import error (module doesn't exist) but is syntactically valid\n    let import_error_code = r#\"\n        use nonexistent::Module;\n\n        fn test() {}\n    \"#;\n\n    let result = validator.validate_syntax(import_error_code).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Import errors should pass syntax validation (cargo catches these)\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436413Z",
      "modified_at": "2025-11-01T15:29:24.436413Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_insert_code_entity:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:63-76",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_insert_code_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 63,
        "end": 76
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_insert_code_entity() {\n    // RED: Entity insertion not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    let entity = create_test_entity();\n\n    db.insert_entity(&entity).await.unwrap();\n\n    // Verify entity can be retrieved\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.isgl1_key, entity.isgl1_key);\n    assert_eq!(retrieved.current_code, entity.current_code);\n}",
    "future_code": "async fn test_insert_code_entity() {\n    // RED: Entity insertion not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    let entity = create_test_entity();\n\n    db.insert_entity(&entity).await.unwrap();\n\n    // Verify entity can be retrieved\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.isgl1_key, entity.isgl1_key);\n    assert_eq!(retrieved.current_code, entity.current_code);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436414Z",
      "modified_at": "2025-11-01T15:29:24.436414Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_insert_duplicate_edge_is_idempotent:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:303-318",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_insert_duplicate_edge_is_idempotent",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 303,
        "end": 318
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_insert_duplicate_edge_is_idempotent() {\n    // Test: Inserting same edge twice should succeed (upsert semantics)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Uses)\n        .build()\n        .unwrap();\n\n    // Insert twice - should succeed both times\n    db.insert_edge(&edge).await.unwrap();\n    db.insert_edge(&edge).await.unwrap();\n}",
    "future_code": "async fn test_insert_duplicate_edge_is_idempotent() {\n    // Test: Inserting same edge twice should succeed (upsert semantics)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Uses)\n        .build()\n        .unwrap();\n\n    // Insert twice - should succeed both times\n    db.insert_edge(&edge).await.unwrap();\n    db.insert_edge(&edge).await.unwrap();\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436415Z",
      "modified_at": "2025-11-01T15:29:24.436415Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_insert_edge_without_source_location:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:287-300",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_insert_edge_without_source_location",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 287,
        "end": 300
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_insert_edge_without_source_location() {\n    // Test: Edge insertion works with optional source_location = None\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:struct:MyStruct:src_lib_rs:10-20\")\n        .to_key(\"rust:trait:MyTrait:src_lib_rs:5-8\")\n        .edge_type(EdgeType::Implements)\n        .build()\n        .unwrap();\n\n    db.insert_edge(&edge).await.unwrap();\n}",
    "future_code": "async fn test_insert_edge_without_source_location() {\n    // Test: Edge insertion works with optional source_location = None\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:struct:MyStruct:src_lib_rs:10-20\")\n        .to_key(\"rust:trait:MyTrait:src_lib_rs:5-8\")\n        .edge_type(EdgeType::Implements)\n        .build()\n        .unwrap();\n\n    db.insert_edge(&edge).await.unwrap();\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436416Z",
      "modified_at": "2025-11-01T15:29:24.436416Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_insert_single_dependency_edge:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:266-284",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_insert_single_dependency_edge",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 266,
        "end": 284
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_insert_single_dependency_edge() {\n    // RED: Edge insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:main:src_main_rs:1-10\")\n        .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n        .edge_type(EdgeType::Calls)\n        .source_location(\"src/main.rs:3:15\")\n        .build()\n        .unwrap();\n\n    // Insert edge\n    db.insert_edge(&edge).await.unwrap();\n\n    // Verify insertion by querying (will implement query methods later)\n    // For now, just verify no error occurred\n}",
    "future_code": "async fn test_insert_single_dependency_edge() {\n    // RED: Edge insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:main:src_main_rs:1-10\")\n        .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n        .edge_type(EdgeType::Calls)\n        .source_location(\"src/main.rs:3:15\")\n        .build()\n        .unwrap();\n\n    // Insert edge\n    db.insert_edge(&edge).await.unwrap();\n\n    // Verify insertion by querying (will implement query methods later)\n    // For now, just verify no error occurred\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436417Z",
      "modified_at": "2025-11-01T15:29:24.436417Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_invalid_flag_value_defaults_to_false:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:142-163",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_invalid_flag_value_defaults_to_false",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 142,
        "end": 163
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_invalid_flag_value_defaults_to_false() {\n    let cli = CliConfig::build_cli();\n\n    // clap should handle validation, but test fallback behavior\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"2\",  // Invalid value\n    ]);\n\n    // Should either fail or default to false\n    // This tests the contract enforcement\n    match matches {\n        Ok(m) => {\n            let include_flag = CliConfig::parse_include_current_code(&m);\n            assert_eq!(include_flag, false, \"Invalid values should default to false\");\n        }\n        Err(_) => {\n            // Also acceptable - clap rejects invalid values\n        }\n    }\n}",
    "future_code": "fn test_invalid_flag_value_defaults_to_false() {\n    let cli = CliConfig::build_cli();\n\n    // clap should handle validation, but test fallback behavior\n    let matches = cli.try_get_matches_from(&[\n        \"parseltongue-03\",\n        \"--include-current-code\",\n        \"2\",  // Invalid value\n    ]);\n\n    // Should either fail or default to false\n    // This tests the contract enforcement\n    match matches {\n        Ok(m) => {\n            let include_flag = CliConfig::parse_include_current_code(&m);\n            assert_eq!(include_flag, false, \"Invalid values should default to false\");\n        }\n        Err(_) => {\n            // Also acceptable - clap rejects invalid values\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436418Z",
      "modified_at": "2025-11-01T15:29:24.436418Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_invalid_function_syntax_missing_paren:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:25-37",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_invalid_function_syntax_missing_paren",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 25,
        "end": 37
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_invalid_function_syntax_missing_paren() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        fn broken_function( {\n            println!(\"broken\");\n        }\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Invalid syntax should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
    "future_code": "fn test_invalid_function_syntax_missing_paren() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        fn broken_function( {\n            println!(\"broken\");\n        }\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Invalid syntax should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436419Z",
      "modified_at": "2025-11-01T15:29:24.436419Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_invalid_isgl1_key_error:______crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:57-60",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_invalid_isgl1_key_error",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "line_range": {
        "start": 57,
        "end": 60
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_invalid_isgl1_key_error() {\n        let err = FileWriterError::invalid_isgl1_key(\"invalid-key\".to_string());\n        assert!(err.to_string().contains(\"invalid-key\"));\n    }",
    "future_code": "    fn test_invalid_isgl1_key_error() {\n        let err = FileWriterError::invalid_isgl1_key(\"invalid-key\".to_string());\n        assert!(err.to_string().contains(\"invalid-key\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436420Z",
      "modified_at": "2025-11-01T15:29:24.436420Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_invalid_struct_missing_brace:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:58-71",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_invalid_struct_missing_brace",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 58,
        "end": 71
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_invalid_struct_missing_brace() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        // Missing closing brace\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Missing brace should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
    "future_code": "fn test_invalid_struct_missing_brace() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        // Missing closing brace\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Missing brace should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436422Z",
      "modified_at": "2025-11-01T15:29:24.436422Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_isgl1_key_as_ref:______crates_parseltongue-core_src_entities_rs:1413-1418",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_isgl1_key_as_ref",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1413,
        "end": 1418
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_isgl1_key_as_ref() {\n        // S77 Pattern A.2: Accept AsRef<str> in APIs\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        let s: &str = key.as_ref();\n        assert_eq!(s, \"test_key\");\n    }",
    "future_code": "    fn test_isgl1_key_as_ref() {\n        // S77 Pattern A.2: Accept AsRef<str> in APIs\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        let s: &str = key.as_ref();\n        assert_eq!(s, \"test_key\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436423Z",
      "modified_at": "2025-11-01T15:29:24.436423Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_isgl1_key_display:______crates_parseltongue-core_src_entities_rs:1421-1424",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_isgl1_key_display",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1421,
        "end": 1424
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_isgl1_key_display() {\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        assert_eq!(format!(\"{}\", key), \"test_key\");\n    }",
    "future_code": "    fn test_isgl1_key_display() {\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        assert_eq!(format!(\"{}\", key), \"test_key\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436424Z",
      "modified_at": "2025-11-01T15:29:24.436424Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_isgl1_key_format:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:444-458",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_isgl1_key_format",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 444,
        "end": 458
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_isgl1_key_format() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let entity = ParsedEntity {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            language: Language::Rust,\n            line_range: (10, 15),\n            file_path: \"src/main.rs\".to_string(),\n            metadata: HashMap::new(),\n        };\n\n        let key = generator.generate_key(&entity).unwrap();\n        assert!(key.contains(\"rust:fn:test_function\"));\n        assert!(key.contains(\"10-15\"));\n    }",
    "future_code": "    fn test_isgl1_key_format() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let entity = ParsedEntity {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            language: Language::Rust,\n            line_range: (10, 15),\n            file_path: \"src/main.rs\".to_string(),\n            metadata: HashMap::new(),\n        };\n\n        let key = generator.generate_key(&entity).unwrap();\n        assert!(key.contains(\"rust:fn:test_function\"));\n        assert!(key.contains(\"10-15\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436425Z",
      "modified_at": "2025-11-01T15:29:24.436425Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_isgl1_key_validates_non_empty:______crates_parseltongue-core_src_entities_rs:1402-1410",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_isgl1_key_validates_non_empty",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1402,
        "end": 1410
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_isgl1_key_validates_non_empty() {\n        // RED: This validates the non-empty invariant\n        let result = Isgl1Key::new(\"\");\n        assert!(result.is_err(), \"Empty key should be rejected\");\n\n        // Valid key\n        let key = Isgl1Key::new(\"rust:fn:main:src_main_rs:1-10\").unwrap();\n        assert_eq!(key.as_str(), \"rust:fn:main:src_main_rs:1-10\");\n    }",
    "future_code": "    fn test_isgl1_key_validates_non_empty() {\n        // RED: This validates the non-empty invariant\n        let result = Isgl1Key::new(\"\");\n        assert!(result.is_err(), \"Empty key should be rejected\");\n\n        // Valid key\n        let key = Isgl1Key::new(\"rust:fn:main:src_main_rs:1-10\").unwrap();\n        assert_eq!(key.as_str(), \"rust:fn:main:src_main_rs:1-10\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436426Z",
      "modified_at": "2025-11-01T15:29:24.436426Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_json_serialization:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:245-266",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_json_serialization",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 245,
        "end": 266
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_json_serialization() {\n        let mut diff = CodeDiff::new();\n\n        diff.add_change(Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn test()\".to_string(),\n        });\n\n        let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n        assert!(json.contains(\"\\\"changes\\\"\"));\n        assert!(json.contains(\"\\\"metadata\\\"\"));\n        assert!(json.contains(\"\\\"CREATE\\\"\"));\n        // Enhanced schema includes these fields\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"\\\"future_code\\\"\"));\n        assert!(json.contains(\"\\\"line_range\\\"\"));\n    }",
    "future_code": "    fn test_json_serialization() {\n        let mut diff = CodeDiff::new();\n\n        diff.add_change(Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn test()\".to_string(),\n        });\n\n        let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n        assert!(json.contains(\"\\\"changes\\\"\"));\n        assert!(json.contains(\"\\\"metadata\\\"\"));\n        assert!(json.contains(\"\\\"CREATE\\\"\"));\n        // Enhanced schema includes these fields\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"\\\"future_code\\\"\"));\n        assert!(json.contains(\"\\\"line_range\\\"\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436427Z",
      "modified_at": "2025-11-01T15:29:24.436427Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_main_with_empty_directory:______crates_pt01-folder-to-cozodb-streamer_src_main_rs:157-177",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_main_with_empty_directory",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "line_range": {
        "start": 157,
        "end": 177
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_main_with_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"**/*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        let stream_result = result.unwrap();\n        assert_eq!(stream_result.total_files, 0);\n        assert_eq!(stream_result.processed_files, 0);\n        assert_eq!(stream_result.entities_created, 0);\n    }",
    "future_code": "    async fn test_main_with_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"**/*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        let stream_result = result.unwrap();\n        assert_eq!(stream_result.total_files, 0);\n        assert_eq!(stream_result.processed_files, 0);\n        assert_eq!(stream_result.entities_created, 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436428Z",
      "modified_at": "2025-11-01T15:29:24.436428Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_main_with_invalid_api_key:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:226-253",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_main_with_invalid_api_key",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 226,
        "end": 253
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_main_with_invalid_api_key() {\n        let temp_dir = TempDir::new().unwrap();\n        let output_dir = temp_dir.path().to_string_lossy().to_string();\n\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"\".to_string(), // Empty API key\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 10\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: output_dir.clone(),\n        };\n\n        // Build CLI matches properly instead of using default()\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--output\", &output_dir,\n            \"--context-id\", \"test-invalid-key\",\n        ]).unwrap();\n\n        let result = run_optimizer(&config, &matches, false, true, true).await;\n        assert!(result.is_err());\n    }",
    "future_code": "    async fn test_main_with_invalid_api_key() {\n        let temp_dir = TempDir::new().unwrap();\n        let output_dir = temp_dir.path().to_string_lossy().to_string();\n\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"\".to_string(), // Empty API key\n            model: \"gpt-4\".to_string(),\n            max_tokens: 8192,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 10\".to_string(),\n            max_context_tokens: 128000,\n            relevance_threshold: 0.7,\n            output_dir: output_dir.clone(),\n        };\n\n        // Build CLI matches properly instead of using default()\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--output\", &output_dir,\n            \"--context-id\", \"test-invalid-key\",\n        ]).unwrap();\n\n        let result = run_optimizer(&config, &matches, false, true, true).await;\n        assert!(result.is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436429Z",
      "modified_at": "2025-11-01T15:29:24.436429Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_main_with_valid_config:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:189-223",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_main_with_valid_config",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 189,
        "end": 223
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_main_with_valid_config() {\n        // Set up environment variable for API key\n        env::set_var(\"OPENAI_API_KEY\", \"test-key-for-testing\");\n\n        let temp_dir = TempDir::new().unwrap();\n        let output_dir = temp_dir.path().to_string_lossy().to_string();\n\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"test-key-for-testing\".to_string(),\n            model: \"gpt-3.5-turbo\".to_string(),\n            max_tokens: 1000,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 1\".to_string(),\n            max_context_tokens: 8000,\n            relevance_threshold: 0.7,\n            output_dir: output_dir.clone(),\n        };\n\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--output\", &output_dir,\n            \"--context-id\", \"test-context\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        // Note: This would fail without a proper LLM mock, but demonstrates the interface\n        let result = run_optimizer(&config, &matches, false, true, true).await;\n        // In a real test environment, we would mock the LLM client\n        assert!(result.is_ok() || result.is_err());\n    }",
    "future_code": "    async fn test_main_with_valid_config() {\n        // Set up environment variable for API key\n        env::set_var(\"OPENAI_API_KEY\", \"test-key-for-testing\");\n\n        let temp_dir = TempDir::new().unwrap();\n        let output_dir = temp_dir.path().to_string_lossy().to_string();\n\n        let config = ContextWriterConfig {\n            db_path: \"test.db\".to_string(),\n            llm_endpoint: \"https://api.openai.com/v1/chat/completions\".to_string(),\n            llm_api_key: \"test-key-for-testing\".to_string(),\n            model: \"gpt-3.5-turbo\".to_string(),\n            max_tokens: 1000,\n            temperature: 0.3,\n            entity_query: \"MATCH (e:Entity) RETURN e LIMIT 1\".to_string(),\n            max_context_tokens: 8000,\n            relevance_threshold: 0.7,\n            output_dir: output_dir.clone(),\n        };\n\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-03\",\n            \"--output\", &output_dir,\n            \"--context-id\", \"test-context\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        // Note: This would fail without a proper LLM mock, but demonstrates the interface\n        let result = run_optimizer(&config, &matches, false, true, true).await;\n        // In a real test environment, we would mock the LLM client\n        assert!(result.is_ok() || result.is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436430Z",
      "modified_at": "2025-11-01T15:29:24.436430Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_main_with_valid_directory:______crates_pt01-folder-to-cozodb-streamer_src_main_rs:121-154",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_main_with_valid_directory",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "line_range": {
        "start": 121,
        "end": 154
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_main_with_valid_directory() {\n        // Create temporary directory with test files\n        let temp_dir = TempDir::new().unwrap();\n        let test_file_path = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file_path,\n            r#\"fn test_function() {\n    println!(\"Hello, world!\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Verify file was created\n        assert!(test_file_path.exists(), \"Test file should exist\");\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()], // Simplified pattern\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        // Verify entities were actually created\n        let stream_result = result.unwrap();\n        assert!(stream_result.total_files > 0, \"Should have found at least one file\");\n        assert!(stream_result.entities_created > 0, \"Should have created at least one entity\");\n    }",
    "future_code": "    async fn test_main_with_valid_directory() {\n        // Create temporary directory with test files\n        let temp_dir = TempDir::new().unwrap();\n        let test_file_path = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file_path,\n            r#\"fn test_function() {\n    println!(\"Hello, world!\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Verify file was created\n        assert!(test_file_path.exists(), \"Test file should exist\");\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()], // Simplified pattern\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        // Verify entities were actually created\n        let stream_result = result.unwrap();\n        assert!(stream_result.total_files > 0, \"Should have found at least one file\");\n        assert!(stream_result.entities_created > 0, \"Should have created at least one entity\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436431Z",
      "modified_at": "2025-11-01T15:29:24.436431Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_missing_dependency_target_error:______crates_parseltongue-core_src_error_rs:247-258",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_missing_dependency_target_error",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/error.rs",
      "line_range": {
        "start": 247,
        "end": 258
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_missing_dependency_target_error() {\n        let error = ParseltongError::MissingDependencyTarget {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:nonexistent:src_helper_rs:5-20\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency target not found\"));\n        assert!(formatted.contains(\"rust:fn:nonexistent:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"referenced from\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n    }",
    "future_code": "    fn test_missing_dependency_target_error() {\n        let error = ParseltongError::MissingDependencyTarget {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:nonexistent:src_helper_rs:5-20\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency target not found\"));\n        assert!(formatted.contains(\"rust:fn:nonexistent:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"referenced from\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436432Z",
      "modified_at": "2025-11-01T15:29:24.436432Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_mixed_operations_diff:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:145-186",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_mixed_operations_diff",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 145,
        "end": 186
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_mixed_operations_diff() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Create\n    let create = create_test_entity(\n        \"src_lib_rs-new_func-fn-xyz789\",\n        Some(\"fn new_func() {}\"),\n        TemporalAction::Create,\n    );\n\n    // Edit\n    let edit = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:50-60\",\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalAction::Edit,\n    );\n\n    // Delete\n    let mut delete = create_test_entity(\n        \"rust:fn:old:src_lib_rs:70-80\",\n        None,\n        TemporalAction::Delete,\n    );\n    delete.future_code = None;\n\n    storage.insert_entity(&create).await.unwrap();\n    storage.insert_entity(&edit).await.unwrap();\n    storage.insert_entity(&delete).await.unwrap();\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n}",
    "future_code": "async fn test_mixed_operations_diff() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Create\n    let create = create_test_entity(\n        \"src_lib_rs-new_func-fn-xyz789\",\n        Some(\"fn new_func() {}\"),\n        TemporalAction::Create,\n    );\n\n    // Edit\n    let edit = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:50-60\",\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalAction::Edit,\n    );\n\n    // Delete\n    let mut delete = create_test_entity(\n        \"rust:fn:old:src_lib_rs:70-80\",\n        None,\n        TemporalAction::Delete,\n    );\n    delete.future_code = None;\n\n    storage.insert_entity(&create).await.unwrap();\n    storage.insert_entity(&edit).await.unwrap();\n    storage.insert_entity(&delete).await.unwrap();\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436433Z",
      "modified_at": "2025-11-01T15:29:24.436433Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_mock_client_returns_configured_response:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:142-166",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_mock_client_returns_configured_response",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 142,
        "end": 166
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_mock_client_returns_configured_response() {\n        let mut mock_client = MockRustAnalyzerClient::new();\n        let test_response = HoverResponse {\n            contents: \"fn test() -> i32\".to_string(),\n            raw_metadata: serde_json::json!({\n                \"type_info\": {\n                    \"resolved_type\": \"i32\"\n                }\n            }),\n        };\n\n        mock_client.add_response(\n            \"test.rs:10:5\".to_string(),\n            test_response.clone(),\n        );\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_some());\n        let response = result.unwrap();\n        assert_eq!(response.contents, \"fn test() -> i32\");\n    }",
    "future_code": "    async fn test_mock_client_returns_configured_response() {\n        let mut mock_client = MockRustAnalyzerClient::new();\n        let test_response = HoverResponse {\n            contents: \"fn test() -> i32\".to_string(),\n            raw_metadata: serde_json::json!({\n                \"type_info\": {\n                    \"resolved_type\": \"i32\"\n                }\n            }),\n        };\n\n        mock_client.add_response(\n            \"test.rs:10:5\".to_string(),\n            test_response.clone(),\n        );\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_some());\n        let response = result.unwrap();\n        assert_eq!(response.contents, \"fn test() -> i32\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436434Z",
      "modified_at": "2025-11-01T15:29:24.436434Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_mock_client_returns_none_for_unconfigured_position:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:169-178",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_mock_client_returns_none_for_unconfigured_position",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 169,
        "end": 178
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_mock_client_returns_none_for_unconfigured_position() {\n        let mock_client = MockRustAnalyzerClient::new();\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 99, 99)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
    "future_code": "    async fn test_mock_client_returns_none_for_unconfigured_position() {\n        let mock_client = MockRustAnalyzerClient::new();\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 99, 99)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436435Z",
      "modified_at": "2025-11-01T15:29:24.436435Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_multiple_valid_entities:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:92-115",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_multiple_valid_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 92,
        "end": 115
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_multiple_valid_entities() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct User {\n            pub name: String,\n            pub age: u32,\n        }\n\n        impl User {\n            pub fn new(name: String, age: u32) -> Self {\n                Self { name, age }\n            }\n\n            pub fn greet(&self) -> String {\n                format!(\"Hello, I'm {}\", self.name)\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Multiple valid entities should pass\");\n    assert!(result.errors.is_empty());\n}",
    "future_code": "fn test_multiple_valid_entities() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct User {\n            pub name: String,\n            pub age: u32,\n        }\n\n        impl User {\n            pub fn new(name: String, age: u32) -> Self {\n                Self { name, age }\n            }\n\n            pub fn greet(&self) -> String {\n                format!(\"Hello, I'm {}\", self.name)\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Multiple valid entities should pass\");\n    assert!(result.errors.is_empty());\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436436Z",
      "modified_at": "2025-11-01T15:29:24.436436Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_no_backup_files_created:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:239-273",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_no_backup_files_created",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 239,
        "end": 273
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/file.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"old content\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-file-rs-Func\",\n            Some(\"new content\".to_string()),\n            TemporalState::edit(),\n        );\n\n        writer.write_entity(&entity).await.unwrap();\n\n        // Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path().join(\"src\"))\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(!name_str.ends_with(\".bak\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".backup\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\"~\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".old\"), \"Found backup file: {}\", name_str);\n        }\n    }",
    "future_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/file.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"old content\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-file-rs-Func\",\n            Some(\"new content\".to_string()),\n            TemporalState::edit(),\n        );\n\n        writer.write_entity(&entity).await.unwrap();\n\n        // Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path().join(\"src\"))\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(!name_str.ends_with(\".bak\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".backup\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\"~\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".old\"), \"Found backup file: {}\", name_str);\n        }\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436437Z",
      "modified_at": "2025-11-01T15:29:24.436437Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_no_backup_files_created:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:202-233",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_no_backup_files_created",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 202,
        "end": 233
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        let _result = manager.reset(&project_path).await;\n\n        // Postcondition: Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path())\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(\n                !name_str.contains(\".backup\"),\n                \"Found backup file: {}\",\n                name_str\n            );\n            assert!(\n                !name_str.contains(\".snapshot\"),\n                \"Found snapshot file: {}\",\n                name_str\n            );\n            assert!(!name_str.contains(\".meta\"), \"Found metadata file: {}\", name_str);\n        }\n    }",
    "future_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        let _result = manager.reset(&project_path).await;\n\n        // Postcondition: Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path())\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(\n                !name_str.contains(\".backup\"),\n                \"Found backup file: {}\",\n                name_str\n            );\n            assert!(\n                !name_str.contains(\".snapshot\"),\n                \"Found snapshot file: {}\",\n                name_str\n            );\n            assert!(!name_str.contains(\".meta\"), \"Found metadata file: {}\", name_str);\n        }\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436438Z",
      "modified_at": "2025-11-01T15:29:24.436438Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_no_dependencies_when_no_calls:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:615-636",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_no_dependencies_when_no_calls",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 615,
        "end": 636
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_no_dependencies_when_no_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    let x = 42;\n    println!(\"{}\", x);\n}\n\nfn helper() {\n    // No calls to other local functions\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities\n        assert_eq!(entities.len(), 2);\n\n        // No dependencies to LOCAL functions (println! is external macro, ignored for MVP)\n        assert_eq!(dependencies.len(), 0, \"Expected no dependencies to local functions\");\n    }",
    "future_code": "    fn test_no_dependencies_when_no_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    let x = 42;\n    println!(\"{}\", x);\n}\n\nfn helper() {\n    // No calls to other local functions\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities\n        assert_eq!(entities.len(), 2);\n\n        // No dependencies to LOCAL functions (println! is external macro, ignored for MVP)\n        assert_eq!(dependencies.len(), 0, \"Expected no dependencies to local functions\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436439Z",
      "modified_at": "2025-11-01T15:29:24.436439Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_operation_counts:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:202-242",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_operation_counts",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 202,
        "end": 242
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_operation_counts() {\n        let mut diff = CodeDiff::new();\n\n        // Add create\n        diff.add_change(Change {\n            isgl1_key: \"create-key\".to_string(),\n            file_path: PathBuf::from(\"src/new.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn new() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn new()\".to_string(),\n        });\n\n        // Add edit\n        diff.add_change(Change {\n            isgl1_key: \"edit-key\".to_string(),\n            file_path: PathBuf::from(\"src/old.rs\"),\n            operation: Operation::Edit,\n            current_code: Some(\"fn old() {}\".to_string()),\n            future_code: Some(\"fn updated() {}\".to_string()),\n            line_range: Some(LineRange { start: 10, end: 20 }),\n            interface_signature: \"fn updated()\".to_string(),\n        });\n\n        // Add delete\n        diff.add_change(Change {\n            isgl1_key: \"delete-key\".to_string(),\n            file_path: PathBuf::from(\"src/gone.rs\"),\n            operation: Operation::Delete,\n            current_code: Some(\"fn gone() {}\".to_string()),\n            future_code: None,\n            line_range: Some(LineRange { start: 30, end: 40 }),\n            interface_signature: \"fn gone()\".to_string(),\n        });\n\n        assert_eq!(diff.metadata.total_changes, 3);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 1);\n        assert_eq!(diff.metadata.delete_count, 1);\n    }",
    "future_code": "    fn test_operation_counts() {\n        let mut diff = CodeDiff::new();\n\n        // Add create\n        diff.add_change(Change {\n            isgl1_key: \"create-key\".to_string(),\n            file_path: PathBuf::from(\"src/new.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn new() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn new()\".to_string(),\n        });\n\n        // Add edit\n        diff.add_change(Change {\n            isgl1_key: \"edit-key\".to_string(),\n            file_path: PathBuf::from(\"src/old.rs\"),\n            operation: Operation::Edit,\n            current_code: Some(\"fn old() {}\".to_string()),\n            future_code: Some(\"fn updated() {}\".to_string()),\n            line_range: Some(LineRange { start: 10, end: 20 }),\n            interface_signature: \"fn updated()\".to_string(),\n        });\n\n        // Add delete\n        diff.add_change(Change {\n            isgl1_key: \"delete-key\".to_string(),\n            file_path: PathBuf::from(\"src/gone.rs\"),\n            operation: Operation::Delete,\n            current_code: Some(\"fn gone() {}\".to_string()),\n            future_code: None,\n            line_range: Some(LineRange { start: 30, end: 40 }),\n            interface_signature: \"fn gone()\".to_string(),\n        });\n\n        assert_eq!(diff.metadata.total_changes, 3);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 1);\n        assert_eq!(diff.metadata.delete_count, 1);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436440Z",
      "modified_at": "2025-11-01T15:29:24.436440Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_optimization_goals_parsing:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:333-343",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_optimization_goals_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 333,
        "end": 343
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_optimization_goals_parsing() {\n        let goals = CliConfig::parse_optimization_goals(\"minimize_size,maximize_relevance,preserve_connectivity\");\n        assert_eq!(goals.len(), 3);\n        assert!(matches!(goals[0], crate::llm_client::OptimizationGoal::MinimizeSize));\n        assert!(matches!(goals[1], crate::llm_client::OptimizationGoal::MaximizeRelevance));\n        assert!(matches!(goals[2], crate::llm_client::OptimizationGoal::PreserveConnectivity));\n\n        let invalid_goals = CliConfig::parse_optimization_goals(\"invalid_goal,another_invalid\");\n        assert_eq!(invalid_goals.len(), 2);\n        // Should fall back to MaximizeRelevance for invalid goals\n    }",
    "future_code": "    fn test_optimization_goals_parsing() {\n        let goals = CliConfig::parse_optimization_goals(\"minimize_size,maximize_relevance,preserve_connectivity\");\n        assert_eq!(goals.len(), 3);\n        assert!(matches!(goals[0], crate::llm_client::OptimizationGoal::MinimizeSize));\n        assert!(matches!(goals[1], crate::llm_client::OptimizationGoal::MaximizeRelevance));\n        assert!(matches!(goals[2], crate::llm_client::OptimizationGoal::PreserveConnectivity));\n\n        let invalid_goals = CliConfig::parse_optimization_goals(\"invalid_goal,another_invalid\");\n        assert_eq!(invalid_goals.len(), 2);\n        // Should fall back to MaximizeRelevance for invalid goals\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436441Z",
      "modified_at": "2025-11-01T15:29:24.436441Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_output_format_matches_spec:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:205-268",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_output_format_matches_spec",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 205,
        "end": 268
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_output_format_matches_spec() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:example:src_lib_rs:1-10\",\n        Some(\"fn example() {}\"),\n        TemporalState::unchanged(),\n    );\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let _result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // Parse JSON output\n    let json_content = std::fs::read_to_string(&output_path).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(&json_content).unwrap();\n\n    // EXPECTATION: Output should have CodeGraphContext structure\n    // CURRENT: Will FAIL because output is ContextOptimizationResponse, not CodeGraphContext\n    assert!(\n        parsed.get(\"entities\").is_some(),\n        \"Output must have 'entities' array\"\n    );\n    assert!(\n        parsed.get(\"entity_count\").is_some(),\n        \"Output must have 'entity_count' field\"\n    );\n    assert!(\n        parsed.get(\"token_count\").is_some(),\n        \"Output must have 'token_count' field\"\n    );\n    assert!(\n        parsed.get(\"generated_at\").is_some(),\n        \"Output must have 'generated_at' timestamp\"\n    );\n\n    // Should NOT have optimization-specific fields\n    assert!(\n        parsed.get(\"pruning_summary\").is_none(),\n        \"Output should NOT have 'pruning_summary' (wrong format)\"\n    );\n    assert!(\n        parsed.get(\"confidence_score\").is_none(),\n        \"Output should NOT have 'confidence_score' (wrong format)\"\n    );\n}",
    "future_code": "async fn test_output_format_matches_spec() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:example:src_lib_rs:1-10\",\n        Some(\"fn example() {}\"),\n        TemporalState::unchanged(),\n    );\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate context\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let _result = optimizer.generate_context(&output_path).await.unwrap();\n\n    // Parse JSON output\n    let json_content = std::fs::read_to_string(&output_path).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(&json_content).unwrap();\n\n    // EXPECTATION: Output should have CodeGraphContext structure\n    // CURRENT: Will FAIL because output is ContextOptimizationResponse, not CodeGraphContext\n    assert!(\n        parsed.get(\"entities\").is_some(),\n        \"Output must have 'entities' array\"\n    );\n    assert!(\n        parsed.get(\"entity_count\").is_some(),\n        \"Output must have 'entity_count' field\"\n    );\n    assert!(\n        parsed.get(\"token_count\").is_some(),\n        \"Output must have 'token_count' field\"\n    );\n    assert!(\n        parsed.get(\"generated_at\").is_some(),\n        \"Output must have 'generated_at' timestamp\"\n    );\n\n    // Should NOT have optimization-specific fields\n    assert!(\n        parsed.get(\"pruning_summary\").is_none(),\n        \"Output should NOT have 'pruning_summary' (wrong format)\"\n    );\n    assert!(\n        parsed.get(\"confidence_score\").is_none(),\n        \"Output should NOT have 'confidence_score' (wrong format)\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436442Z",
      "modified_at": "2025-11-01T15:29:24.436442Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_output_path_generation:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:346-352",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_output_path_generation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 346,
        "end": 352
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_output_path_generation() {\n        let context_id = \"test_context_123\";\n        let output_path = CliConfig::generate_output_path(\"./contexts\", context_id);\n\n        assert!(output_path.starts_with(\"./contexts/context_test_context_123_\"));\n        assert!(output_path.ends_with(\".json\"));\n    }",
    "future_code": "    fn test_output_path_generation() {\n        let context_id = \"test_context_123\";\n        let output_path = CliConfig::generate_output_path(\"./contexts\", context_id);\n\n        assert!(output_path.starts_with(\"./contexts/context_test_context_123_\"));\n        assert!(output_path.ends_with(\".json\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436443Z",
      "modified_at": "2025-11-01T15:29:24.436443Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_output_path_generation:______crates_pt02-llm-cozodb-to-context-writer_src_main_rs:285-293",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_output_path_generation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "line_range": {
        "start": 285,
        "end": 293
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_output_path_generation() {\n        let context_id = \"test-context-123\";\n        let output_dir = \"./test_output\";\n\n        let output_path = CliConfig::generate_output_path(output_dir, context_id);\n\n        assert!(output_path.starts_with(&format!(\"{}/context_test-context-123_\", output_dir)));\n        assert!(output_path.ends_with(\".json\"));\n    }",
    "future_code": "    fn test_output_path_generation() {\n        let context_id = \"test-context-123\";\n        let output_dir = \"./test_output\";\n\n        let output_path = CliConfig::generate_output_path(output_dir, context_id);\n\n        assert!(output_path.starts_with(&format!(\"{}/context_test-context-123_\", output_dir)));\n        assert!(output_path.ends_with(\".json\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436444Z",
      "modified_at": "2025-11-01T15:29:24.436445Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_prd_command_format:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:174-195",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_prd_command_format",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 174,
        "end": 195
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_prd_command_format() {\n        // Test ultra-minimalist CLI (S01 principle)\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"folder-to-cozoDB-streamer\",\n            \"./src\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"./parseltongue.db\",\n        ]);\n\n        assert!(matches.is_ok(), \"Ultra-minimalist command should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"./src\"));\n        assert_eq!(config.db_path, \"./parseltongue.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist)\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "future_code": "    fn test_prd_command_format() {\n        // Test ultra-minimalist CLI (S01 principle)\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"folder-to-cozoDB-streamer\",\n            \"./src\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"./parseltongue.db\",\n        ]);\n\n        assert!(matches.is_ok(), \"Ultra-minimalist command should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"./src\"));\n        assert_eq!(config.db_path, \"./parseltongue.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist)\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436446Z",
      "modified_at": "2025-11-01T15:29:24.436446Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_query_changed_entities:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:103-126",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_query_changed_entities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 103,
        "end": 126
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_query_changed_entities() {\n    // RED: Query for changed entities not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert 3 entities: 1 unchanged, 1 edit, 1 delete\n    let unchanged = create_test_entity_with_key(\"entity1\");\n    let to_edit = create_test_entity_with_key(\"entity2\");\n    let to_delete = create_test_entity_with_key(\"entity3\");\n\n    db.insert_entity(&unchanged).await.unwrap();\n    db.insert_entity(&to_edit).await.unwrap();\n    db.insert_entity(&to_delete).await.unwrap();\n\n    // Mark changes\n    db.update_temporal_state(\"entity2\", true, Some(TemporalAction::Edit)).await.unwrap();\n    db.update_temporal_state(\"entity3\", false, Some(TemporalAction::Delete)).await.unwrap();\n\n    // Query changed entities\n    let changed = db.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 2);\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity2\"));\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity3\"));\n}",
    "future_code": "async fn test_query_changed_entities() {\n    // RED: Query for changed entities not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert 3 entities: 1 unchanged, 1 edit, 1 delete\n    let unchanged = create_test_entity_with_key(\"entity1\");\n    let to_edit = create_test_entity_with_key(\"entity2\");\n    let to_delete = create_test_entity_with_key(\"entity3\");\n\n    db.insert_entity(&unchanged).await.unwrap();\n    db.insert_entity(&to_edit).await.unwrap();\n    db.insert_entity(&to_delete).await.unwrap();\n\n    // Mark changes\n    db.update_temporal_state(\"entity2\", true, Some(TemporalAction::Edit)).await.unwrap();\n    db.update_temporal_state(\"entity3\", false, Some(TemporalAction::Delete)).await.unwrap();\n\n    // Query changed entities\n    let changed = db.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 2);\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity2\"));\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity3\"));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436447Z",
      "modified_at": "2025-11-01T15:29:24.436447Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_query_excludes_current_code_when_flag_false:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:66-76",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_query_excludes_current_code_when_flag_false",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 66,
        "end": 76
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_query_excludes_current_code_when_flag_false() {\n    let include_current_code = false;\n    let query = CliConfig::build_context_query(include_current_code);\n\n    // Postcondition: Query should exclude Current_Code\n    assert!(\n        !query.contains(\"Current_Code\") || query.contains(\"EXCEPT\") && query.contains(\"Current_Code\"),\n        \"Query should exclude Current_Code when flag is false\"\n    );\n    assert!(query.contains(\"CodeGraph\"), \"Query should reference CodeGraph table\");\n}",
    "future_code": "fn test_query_excludes_current_code_when_flag_false() {\n    let include_current_code = false;\n    let query = CliConfig::build_context_query(include_current_code);\n\n    // Postcondition: Query should exclude Current_Code\n    assert!(\n        !query.contains(\"Current_Code\") || query.contains(\"EXCEPT\") && query.contains(\"Current_Code\"),\n        \"Query should exclude Current_Code when flag is false\"\n    );\n    assert!(query.contains(\"CodeGraph\"), \"Query should reference CodeGraph table\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436449Z",
      "modified_at": "2025-11-01T15:29:24.436449Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_query_includes_current_code_when_flag_true:______crates_pt02-llm-cozodb-to-context-writer_tests_include_current_code_tests_rs:80-94",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_query_includes_current_code_when_flag_true",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/include_current_code_tests.rs",
      "line_range": {
        "start": 80,
        "end": 94
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_query_includes_current_code_when_flag_true() {\n    let include_current_code = true;\n    let query = CliConfig::build_context_query(include_current_code);\n\n    // Postcondition: Query should include Current_Code (not in EXCEPT clause)\n    if query.contains(\"EXCEPT\") {\n        assert!(\n            !query.contains(\"EXCEPT (Current_Code\"),\n            \"Query should not exclude Current_Code when flag is true\"\n        );\n    } else {\n        // If no EXCEPT clause, it includes everything implicitly\n        assert!(query.contains(\"CodeGraph\"), \"Query should reference CodeGraph table\");\n    }\n}",
    "future_code": "fn test_query_includes_current_code_when_flag_true() {\n    let include_current_code = true;\n    let query = CliConfig::build_context_query(include_current_code);\n\n    // Postcondition: Query should include Current_Code (not in EXCEPT clause)\n    if query.contains(\"EXCEPT\") {\n        assert!(\n            !query.contains(\"EXCEPT (Current_Code\"),\n            \"Query should not exclude Current_Code when flag is true\"\n        );\n    } else {\n        // If no EXCEPT clause, it includes everything implicitly\n        assert!(query.contains(\"CodeGraph\"), \"Query should reference CodeGraph table\");\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436450Z",
      "modified_at": "2025-11-01T15:29:24.436450Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_query_stored_entity_and_verify_in_codebase:______crates_pt01-folder-to-cozodb-streamer_tests_verify_lsp_storage_rs:8-105",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_query_stored_entity_and_verify_in_codebase",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/tests/verify_lsp_storage.rs",
      "line_range": {
        "start": 8,
        "end": 105
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_query_stored_entity_and_verify_in_codebase() {\n    // Create a test Rust file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"example.rs\");\n    std::fs::write(\n        &test_file,\n        r#\"\npub fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\npub struct Calculator {\n    name: String,\n    version: u32,\n}\n\nimpl Calculator {\n    pub fn new(name: String) -> Self {\n        Self { name, version: 1 }\n    }\n}\n\"#,\n    )\n    .unwrap();\n\n    // Index the file\n    let db_dir = TempDir::new().unwrap();\n    let db_path = format!(\"rocksdb:{}\", db_dir.path().display());\n\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: db_path.clone(),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    let streamer = ToolFactory::create_streamer(config).await.unwrap();\n    let result = streamer.stream_directory().await.unwrap();\n\n    println!(\"\\n Indexing Results:\");\n    println!(\"  Files processed: {}\", result.processed_files);\n    println!(\"  Entities created: {}\", result.entities_created);\n    assert!(result.entities_created >= 3, \"Should have at least 3 entities (function, struct, impl)\");\n\n    // Drop the streamer to release the RocksDB lock before opening a new connection\n    drop(streamer);\n\n    // Now query the database to get one entity\n    let db = CozoDbStorage::new(&db_path).await.unwrap();\n\n    // Query using get_all_entities\n    let entities = db.get_all_entities().await.unwrap();\n    println!(\"\\n Total entities in database: {}\", entities.len());\n\n    // Pick first entity and verify\n    if let Some(first_entity) = entities.first() {\n        let isgl1_key = &first_entity.isgl1_key;\n        println!(\"\\n Found entity: {}\", isgl1_key);\n        println!(\"  LSP metadata present: {}\", first_entity.lsp_metadata.is_some());\n\n        if let Some(lsp_meta) = &first_entity.lsp_metadata {\n            println!(\"\\n LSP Metadata:\");\n            println!(\"  Type: {}\", lsp_meta.type_information.resolved_type);\n            println!(\"  Module path: {:?}\", lsp_meta.type_information.module_path);\n            println!(\"  Generic params: {:?}\", lsp_meta.type_information.generic_parameters);\n            println!(\"  Usage references: {}\", lsp_meta.usage_analysis.total_references);\n        }\n\n        // Verify the entity exists in the source file\n        let source_content = std::fs::read_to_string(&test_file).unwrap();\n\n        // Parse ISGL1 key to extract entity name\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 3 {\n            let entity_name = parts[2];\n            println!(\"\\n Searching for entity '{}' in source...\", entity_name);\n\n            // Search for entity in source\n            assert!(\n                source_content.contains(entity_name),\n                \"Entity '{}' should exist in source file\",\n                entity_name\n            );\n            println!(\"   Verified in source code!\");\n\n            // Show context from source\n            for (i, line) in source_content.lines().enumerate() {\n                if line.contains(entity_name) {\n                    println!(\"\\n Source code context (line {}):\", i + 1);\n                    println!(\"  {}\", line.trim());\n                }\n            }\n        }\n    }\n}",
    "future_code": "async fn test_query_stored_entity_and_verify_in_codebase() {\n    // Create a test Rust file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"example.rs\");\n    std::fs::write(\n        &test_file,\n        r#\"\npub fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\npub struct Calculator {\n    name: String,\n    version: u32,\n}\n\nimpl Calculator {\n    pub fn new(name: String) -> Self {\n        Self { name, version: 1 }\n    }\n}\n\"#,\n    )\n    .unwrap();\n\n    // Index the file\n    let db_dir = TempDir::new().unwrap();\n    let db_path = format!(\"rocksdb:{}\", db_dir.path().display());\n\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: db_path.clone(),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    let streamer = ToolFactory::create_streamer(config).await.unwrap();\n    let result = streamer.stream_directory().await.unwrap();\n\n    println!(\"\\n Indexing Results:\");\n    println!(\"  Files processed: {}\", result.processed_files);\n    println!(\"  Entities created: {}\", result.entities_created);\n    assert!(result.entities_created >= 3, \"Should have at least 3 entities (function, struct, impl)\");\n\n    // Drop the streamer to release the RocksDB lock before opening a new connection\n    drop(streamer);\n\n    // Now query the database to get one entity\n    let db = CozoDbStorage::new(&db_path).await.unwrap();\n\n    // Query using get_all_entities\n    let entities = db.get_all_entities().await.unwrap();\n    println!(\"\\n Total entities in database: {}\", entities.len());\n\n    // Pick first entity and verify\n    if let Some(first_entity) = entities.first() {\n        let isgl1_key = &first_entity.isgl1_key;\n        println!(\"\\n Found entity: {}\", isgl1_key);\n        println!(\"  LSP metadata present: {}\", first_entity.lsp_metadata.is_some());\n\n        if let Some(lsp_meta) = &first_entity.lsp_metadata {\n            println!(\"\\n LSP Metadata:\");\n            println!(\"  Type: {}\", lsp_meta.type_information.resolved_type);\n            println!(\"  Module path: {:?}\", lsp_meta.type_information.module_path);\n            println!(\"  Generic params: {:?}\", lsp_meta.type_information.generic_parameters);\n            println!(\"  Usage references: {}\", lsp_meta.usage_analysis.total_references);\n        }\n\n        // Verify the entity exists in the source file\n        let source_content = std::fs::read_to_string(&test_file).unwrap();\n\n        // Parse ISGL1 key to extract entity name\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 3 {\n            let entity_name = parts[2];\n            println!(\"\\n Searching for entity '{}' in source...\", entity_name);\n\n            // Search for entity in source\n            assert!(\n                source_content.contains(entity_name),\n                \"Entity '{}' should exist in source file\",\n                entity_name\n            );\n            println!(\"   Verified in source code!\");\n\n            // Show context from source\n            for (i, line) in source_content.lines().enumerate() {\n                if line.contains(entity_name) {\n                    println!(\"\\n Source code context (line {}):\", i + 1);\n                    println!(\"  {}\", line.trim());\n                }\n            }\n        }\n    }\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436451Z",
      "modified_at": "2025-11-01T15:29:24.436451Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_real_client_gracefully_degrades_when_unavailable:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:181-191",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_real_client_gracefully_degrades_when_unavailable",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 181,
        "end": 191
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_real_client_gracefully_degrades_when_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n\n        // Should not panic, should return None\n        let result = client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
    "future_code": "    async fn test_real_client_gracefully_degrades_when_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n\n        // Should not panic, should return None\n        let result = client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436452Z",
      "modified_at": "2025-11-01T15:29:24.436452Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_real_client_reports_unavailable:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:194-197",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_real_client_reports_unavailable",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 194,
        "end": 197
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_real_client_reports_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n        assert!(!client.is_available().await);\n    }",
    "future_code": "    async fn test_real_client_reports_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n        assert!(!client.is_available().await);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436453Z",
      "modified_at": "2025-11-01T15:29:24.436453Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_resolve_file_path:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:276-281",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_resolve_file_path",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 276,
        "end": 281
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_resolve_file_path() {\n        let writer = FileWriter::new(PathBuf::from(\"/tmp\"));\n\n        let path = writer.resolve_file_path(\"src-models-rs-User\").unwrap();\n        assert_eq!(path, PathBuf::from(\"/tmp/src/models.rs\"));\n    }",
    "future_code": "    async fn test_resolve_file_path() {\n        let writer = FileWriter::new(PathBuf::from(\"/tmp\"));\n\n        let path = writer.resolve_file_path(\"src-models-rs-User\").unwrap();\n        assert_eq!(path, PathBuf::from(\"/tmp/src/models.rs\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436454Z",
      "modified_at": "2025-11-01T15:29:24.436454Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_reverse_dependencies_empty:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:694-703",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_reverse_dependencies_empty",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 694,
        "end": 703
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_reverse_dependencies_empty() {\n    // RED: Test entity with no reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no incoming edges\n    let deps = db.get_reverse_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no incoming edges should return empty\");\n}",
    "future_code": "async fn test_reverse_dependencies_empty() {\n    // RED: Test entity with no reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no incoming edges\n    let deps = db.get_reverse_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no incoming edges should return empty\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436455Z",
      "modified_at": "2025-11-01T15:29:24.436455Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_reverse_dependencies_multiple:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:644-679",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_reverse_dependencies_multiple",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 644,
        "end": 679
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_reverse_dependencies_multiple() {\n    // RED: Test multiple reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> D, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: D should have A, B, C as dependents\n    let deps = db.get_reverse_dependencies(\"rust:fn:D:test_rs:30-35\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"D should have 3 dependents\");\n    assert!(deps.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
    "future_code": "async fn test_reverse_dependencies_multiple() {\n    // RED: Test multiple reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> D, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: D should have A, B, C as dependents\n    let deps = db.get_reverse_dependencies(\"rust:fn:D:test_rs:30-35\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"D should have 3 dependents\");\n    assert!(deps.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436456Z",
      "modified_at": "2025-11-01T15:29:24.436456Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_reverse_dependencies_single:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:584-603",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_reverse_dependencies_single",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 584,
        "end": 603
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_reverse_dependencies_single() {\n    // RED: Test reverse dependencies (incoming edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: B's reverse dependencies should return [A]\n    let deps = db.get_reverse_dependencies(\"rust:fn:B:test_rs:10-15\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"B should have 1 dependent\");\n    assert_eq!(deps[0], \"rust:fn:A:test_rs:1-5\");\n}",
    "future_code": "async fn test_reverse_dependencies_single() {\n    // RED: Test reverse dependencies (incoming edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: B's reverse dependencies should return [A]\n    let deps = db.get_reverse_dependencies(\"rust:fn:B:test_rs:10-15\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"B should have 1 dependent\");\n    assert_eq!(deps[0], \"rust:fn:A:test_rs:1-5\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436457Z",
      "modified_at": "2025-11-01T15:29:24.436457Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_rust_parsing:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:461-485",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_rust_parsing",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 461,
        "end": 485
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_rust_parsing() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn test_function() {\n    println!(\"Hello, world!\");\n}\n\nstruct TestStruct {\n    field: i32,\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        assert!(!entities.is_empty());\n        assert_eq!(entities.len(), 2); // One function, one struct\n\n        let function = &entities[0];\n        assert_eq!(function.entity_type, EntityType::Function);\n        assert_eq!(function.name, \"test_function\");\n\n        // For now, dependencies should be empty (will implement extraction next)\n        assert_eq!(dependencies.len(), 0);\n    }",
    "future_code": "    fn test_rust_parsing() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn test_function() {\n    println!(\"Hello, world!\");\n}\n\nstruct TestStruct {\n    field: i32,\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        assert!(!entities.is_empty());\n        assert_eq!(entities.len(), 2); // One function, one struct\n\n        let function = &entities[0];\n        assert_eq!(function.entity_type, EntityType::Function);\n        assert_eq!(function.name, \"test_function\");\n\n        // For now, dependencies should be empty (will implement extraction next)\n        assert_eq!(dependencies.len(), 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436458Z",
      "modified_at": "2025-11-01T15:29:24.436458Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_schema_recreation_after_deletion:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:244-270",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_schema_recreation_after_deletion",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 244,
        "end": 270
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_schema_recreation_after_deletion() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Insert test entity\n        storage.insert_entity(&create_test_entity(\"before\")).await.unwrap();\n\n        // Reset\n        let manager = StateResetManager::new(storage);\n        manager.delete_table().await.unwrap();\n        manager.recreate_schema().await.unwrap();\n\n        // Postcondition: Can insert new entity (schema is valid)\n        let result = manager.storage.insert_entity(&create_test_entity(\"after\")).await;\n        assert!(\n            result.is_ok(),\n            \"Should be able to insert after schema recreation\"\n        );\n\n        // Verify only new entity exists\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 1, \"Should have exactly 1 entity\");\n        assert_eq!(\n            entities[0].isgl1_key, \"after\",\n            \"Should be the new entity, not old one\"\n        );\n    }",
    "future_code": "    async fn test_schema_recreation_after_deletion() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Insert test entity\n        storage.insert_entity(&create_test_entity(\"before\")).await.unwrap();\n\n        // Reset\n        let manager = StateResetManager::new(storage);\n        manager.delete_table().await.unwrap();\n        manager.recreate_schema().await.unwrap();\n\n        // Postcondition: Can insert new entity (schema is valid)\n        let result = manager.storage.insert_entity(&create_test_entity(\"after\")).await;\n        assert!(\n            result.is_ok(),\n            \"Should be able to insert after schema recreation\"\n        );\n\n        // Verify only new entity exists\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 1, \"Should have exactly 1 entity\");\n        assert_eq!(\n            entities[0].isgl1_key, \"after\",\n            \"Should be the new entity, not old one\"\n        );\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436459Z",
      "modified_at": "2025-11-01T15:29:24.436460Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_simple_interface_mode:______crates_pt03-llm-to-cozodb-writer_src_main_rs:104-121",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_simple_interface_mode",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "line_range": {
        "start": 104,
        "end": 121
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_simple_interface_mode() {\n        let config = SimpleUpdateConfig {\n            entity_key: \"rust:fn:test:lib_rs:1-5\".to_string(),\n            action: EntityAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Simple(config.clone());\n\n        match mode {\n            InterfaceMode::Simple(c) => {\n                assert_eq!(c.entity_key, \"rust:fn:test:lib_rs:1-5\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Simple mode\"),\n        }\n    }",
    "future_code": "    fn test_simple_interface_mode() {\n        let config = SimpleUpdateConfig {\n            entity_key: \"rust:fn:test:lib_rs:1-5\".to_string(),\n            action: EntityAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Simple(config.clone());\n\n        match mode {\n            InterfaceMode::Simple(c) => {\n                assert_eq!(c.entity_key, \"rust:fn:test:lib_rs:1-5\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Simple mode\"),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436461Z",
      "modified_at": "2025-11-01T15:29:24.436461Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_simple_invalid_code:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:165-171",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_simple_invalid_code",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 165,
        "end": 171
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_simple_invalid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main( {\"; // Missing closing paren\n        let result = validator.validate_syntax(code).unwrap();\n        assert!(!result.is_valid);\n        assert!(!result.errors.is_empty());\n    }",
    "future_code": "    fn test_simple_invalid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main( {\"; // Missing closing paren\n        let result = validator.validate_syntax(code).unwrap();\n        assert!(!result.is_valid);\n        assert!(!result.errors.is_empty());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436462Z",
      "modified_at": "2025-11-01T15:29:24.436462Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_simple_valid_code:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:157-162",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_simple_valid_code",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 157,
        "end": 162
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_simple_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main() {}\";\n        let result = validator.validate_syntax(code).unwrap();\n        assert!(result.is_valid);\n    }",
    "future_code": "    fn test_simple_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main() {}\";\n        let result = validator.validate_syntax(code).unwrap();\n        assert!(result.is_valid);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436463Z",
      "modified_at": "2025-11-01T15:29:24.436463Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_single_edge_insert_performance_contract:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:361-388",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_single_edge_insert_performance_contract",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 361,
        "end": 388
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_single_edge_insert_performance_contract() {\n    // Performance Contract: Single insert <5ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n\n    // Warm up\n    db.insert_edge(&edge).await.unwrap();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edge(&edge).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 5,\n        \"Single edge insert took {:?}, expected <5ms\",\n        elapsed\n    );\n}",
    "future_code": "async fn test_single_edge_insert_performance_contract() {\n    // Performance Contract: Single insert <5ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n\n    // Warm up\n    db.insert_edge(&edge).await.unwrap();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edge(&edge).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 5,\n        \"Single edge insert took {:?}, expected <5ms\",\n        elapsed\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436464Z",
      "modified_at": "2025-11-01T15:29:24.436464Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_skip_unchanged_entities:______crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:114-141",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_skip_unchanged_entities",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "line_range": {
        "start": 114,
        "end": 141
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_skip_unchanged_entities() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert unchanged entity (no FutureAction)\n    let mut entity = create_test_entity(\n        \"rust:fn:unchanged:src_lib_rs:10-20\",\n        Some(\"fn unchanged() {}\"),\n        TemporalAction::Create, // Will be overridden\n    );\n    entity.temporal_state = TemporalState::unchanged();\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    // Should be empty - unchanged entities should be skipped\n    assert_eq!(diff.changes.len(), 0);\n    assert_eq!(diff.metadata.total_changes, 0);\n}",
    "future_code": "async fn test_skip_unchanged_entities() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert unchanged entity (no FutureAction)\n    let mut entity = create_test_entity(\n        \"rust:fn:unchanged:src_lib_rs:10-20\",\n        Some(\"fn unchanged() {}\"),\n        TemporalAction::Create, // Will be overridden\n    );\n    entity.temporal_state = TemporalState::unchanged();\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    // Should be empty - unchanged entities should be skipped\n    assert_eq!(diff.changes.len(), 0);\n    assert_eq!(diff.metadata.total_changes, 0);\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436465Z",
      "modified_at": "2025-11-01T15:29:24.436465Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_statistics_tracking:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:586-606",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_statistics_tracking",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 586,
        "end": 606
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_statistics_tracking() {\n        // Create runtime for async test\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n            let storage = Arc::new(storage);\n\n            let config = crate::ContextWriterConfig::default();\n            let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n            let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n            let initial_stats = optimizer.get_stats();\n            assert_eq!(initial_stats.contexts_generated, 0);\n\n            optimizer.update_stats(10, 1000, 0.3, Duration::from_secs(5));\n            let updated_stats = optimizer.get_stats();\n            assert_eq!(updated_stats.contexts_generated, 1);\n            assert_eq!(updated_stats.entities_processed, 10);\n            assert_eq!(updated_stats.tokens_generated, 1000);\n        });\n    }",
    "future_code": "    fn test_statistics_tracking() {\n        // Create runtime for async test\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n            let storage = Arc::new(storage);\n\n            let config = crate::ContextWriterConfig::default();\n            let llm_client = crate::ToolFactory::create_llm_client(config.clone());\n            let optimizer = ContextOptimizerImpl::new(storage, config, llm_client);\n\n            let initial_stats = optimizer.get_stats();\n            assert_eq!(initial_stats.contexts_generated, 0);\n\n            optimizer.update_stats(10, 1000, 0.3, Duration::from_secs(5));\n            let updated_stats = optimizer.get_stats();\n            assert_eq!(updated_stats.contexts_generated, 1);\n            assert_eq!(updated_stats.entities_processed, 10);\n            assert_eq!(updated_stats.tokens_generated, 1000);\n        });\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436466Z",
      "modified_at": "2025-11-01T15:29:24.436466Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_streamer_enriches_entities_with_lsp_metadata:______crates_pt01-folder-to-cozodb-streamer_src_streamer_lsp_tests_rs:12-86",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_streamer_enriches_entities_with_lsp_metadata",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs",
      "line_range": {
        "start": 12,
        "end": 86
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_streamer_enriches_entities_with_lsp_metadata() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nstruct Calculator {\n    name: String,\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client with hover responses\n        let mut mock_lsp = MockRustAnalyzerClient::new();\n\n        // Add hover response for function (line 1)\n        mock_lsp.add_response(\n            format!(\"{}:0:0\", test_file.display()),\n            HoverResponse {\n                contents: \"fn calculate_sum(a: i32, b: i32) -> i32\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"function\",\n                    \"signature\": \"fn(i32, i32) -> i32\"\n                }),\n            },\n        );\n\n        // Add hover response for struct (line 5)\n        mock_lsp.add_response(\n            format!(\"{}:4:0\", test_file.display()),\n            HoverResponse {\n                contents: \"struct Calculator\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"struct\",\n                    \"fields\": [\"name: String\"]\n                }),\n            },\n        );\n\n        // Setup: Create streamer with mock LSP client\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entities were created\n        assert_eq!(result.entities_created, 2, \"Should create 2 entities (function + struct)\");\n        assert!(result.success, \"Streaming should succeed\");\n\n        // Verify: LSP metadata was stored (we can't easily query DB in this test,\n        // but the fact that no errors occurred means LSP integration works)\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
    "future_code": "    async fn test_streamer_enriches_entities_with_lsp_metadata() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nstruct Calculator {\n    name: String,\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client with hover responses\n        let mut mock_lsp = MockRustAnalyzerClient::new();\n\n        // Add hover response for function (line 1)\n        mock_lsp.add_response(\n            format!(\"{}:0:0\", test_file.display()),\n            HoverResponse {\n                contents: \"fn calculate_sum(a: i32, b: i32) -> i32\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"function\",\n                    \"signature\": \"fn(i32, i32) -> i32\"\n                }),\n            },\n        );\n\n        // Add hover response for struct (line 5)\n        mock_lsp.add_response(\n            format!(\"{}:4:0\", test_file.display()),\n            HoverResponse {\n                contents: \"struct Calculator\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"struct\",\n                    \"fields\": [\"name: String\"]\n                }),\n            },\n        );\n\n        // Setup: Create streamer with mock LSP client\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entities were created\n        assert_eq!(result.entities_created, 2, \"Should create 2 entities (function + struct)\");\n        assert!(result.success, \"Streaming should succeed\");\n\n        // Verify: LSP metadata was stored (we can't easily query DB in this test,\n        // but the fact that no errors occurred means LSP integration works)\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436467Z",
      "modified_at": "2025-11-01T15:29:24.436467Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_streamer_gracefully_degrades_without_lsp:______crates_pt01-folder-to-cozodb-streamer_src_streamer_lsp_tests_rs:89-132",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_streamer_gracefully_degrades_without_lsp",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs",
      "line_range": {
        "start": 89,
        "end": 132
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_streamer_gracefully_degrades_without_lsp() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn test_fn() {\n    println!(\"test\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client that returns None (simulating unavailable LSP)\n        let mock_lsp = MockRustAnalyzerClient::new(); // No responses configured\n\n        // Setup: Create streamer\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entity still created despite LSP unavailable (graceful degradation)\n        assert_eq!(result.entities_created, 1, \"Should still create entity without LSP\");\n        assert!(result.success, \"Streaming should succeed without LSP\");\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
    "future_code": "    async fn test_streamer_gracefully_degrades_without_lsp() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn test_fn() {\n    println!(\"test\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client that returns None (simulating unavailable LSP)\n        let mock_lsp = MockRustAnalyzerClient::new(); // No responses configured\n\n        // Setup: Create streamer\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entity still created despite LSP unavailable (graceful degradation)\n        assert_eq!(result.entities_created, 1, \"Should still create entity without LSP\");\n        assert!(result.success, \"Streaming should succeed without LSP\");\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436468Z",
      "modified_at": "2025-11-01T15:29:24.436468Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_system_prompt_creation:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:402-410",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_system_prompt_creation",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 402,
        "end": 410
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_system_prompt_creation() {\n        let config = crate::ContextWriterConfig::default();\n        let client = ContextLlmClientImpl::new(config);\n        let prompt = client.create_system_prompt();\n\n        assert!(prompt.contains(\"code context optimizer\"));\n        assert!(prompt.contains(\"Token Efficiency\"));\n        assert!(prompt.contains(\"Relevance Preservation\"));\n    }",
    "future_code": "    fn test_system_prompt_creation() {\n        let config = crate::ContextWriterConfig::default();\n        let client = ContextLlmClientImpl::new(config);\n        let prompt = client.create_system_prompt();\n\n        assert!(prompt.contains(\"code context optimizer\"));\n        assert!(prompt.contains(\"Token Efficiency\"));\n        assert!(prompt.contains(\"Relevance Preservation\"));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436469Z",
      "modified_at": "2025-11-01T15:29:24.436469Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tdd_classification_has_entity_class_field:______crates_parseltongue-core_src_entities_rs:1379-1385",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tdd_classification_has_entity_class_field",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1379,
        "end": 1385
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_tdd_classification_has_entity_class_field() {\n        // Test that TddClassification has entity_class field\n        let tdd = TddClassification::default();\n\n        // Default should be CodeImplementation\n        assert_eq!(tdd.entity_class, EntityClass::CodeImplementation);\n    }",
    "future_code": "    fn test_tdd_classification_has_entity_class_field() {\n        // Test that TddClassification has entity_class field\n        let tdd = TddClassification::default();\n\n        // Default should be CodeImplementation\n        assert_eq!(tdd.entity_class, EntityClass::CodeImplementation);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436470Z",
      "modified_at": "2025-11-01T15:29:24.436470Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_temporal_state_transitions:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:311-336",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_temporal_state_transitions",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 311,
        "end": 336
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_temporal_state_transitions() -> Result<()> {\n    let mut storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Create test entity in (1,1) state - unchanged\n    let entity = create_simple_test_entity(\"test-unchanged\");\n    storage.insert_entity(&entity).await?;\n\n    let retrieved = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // Transition to (1,1) with Edit - modified\n    let mut modified = retrieved.clone();\n    modified.future_code = Some(\"new code\".to_string());\n    modified.temporal_state.future_action = Some(TemporalAction::Edit);\n    storage.update_entity(modified).await?;\n\n    let after_edit = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(after_edit.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(after_edit.future_code, Some(\"new code\".to_string()));\n\n    println!(\" Temporal state transitions validated\");\n    Ok(())\n}",
    "future_code": "async fn test_temporal_state_transitions() -> Result<()> {\n    let mut storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Create test entity in (1,1) state - unchanged\n    let entity = create_simple_test_entity(\"test-unchanged\");\n    storage.insert_entity(&entity).await?;\n\n    let retrieved = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // Transition to (1,1) with Edit - modified\n    let mut modified = retrieved.clone();\n    modified.future_code = Some(\"new code\".to_string());\n    modified.temporal_state.future_action = Some(TemporalAction::Edit);\n    storage.update_entity(modified).await?;\n\n    let after_edit = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(after_edit.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(after_edit.future_code, Some(\"new code\".to_string()));\n\n    println!(\" Temporal state transitions validated\");\n    Ok(())\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436472Z",
      "modified_at": "2025-11-01T15:29:24.436472Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_temporal_state_update:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:79-100",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_temporal_state_update",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 79,
        "end": 100
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_temporal_state_update() {\n    // RED: Temporal update not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity with unchanged state\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Update temporal state: (1,1)  (1,0) for delete\n    db.update_temporal_state(\n        \"test-file-rs-TestStruct\",\n        false, // future_ind\n        Some(TemporalAction::Delete),\n    ).await.unwrap();\n\n    // Verify update\n    let updated = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(updated.temporal_state.current_ind, true);\n    assert_eq!(updated.temporal_state.future_ind, false);\n    assert_eq!(updated.temporal_state.future_action, Some(TemporalAction::Delete));\n}",
    "future_code": "async fn test_temporal_state_update() {\n    // RED: Temporal update not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity with unchanged state\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Update temporal state: (1,1)  (1,0) for delete\n    db.update_temporal_state(\n        \"test-file-rs-TestStruct\",\n        false, // future_ind\n        Some(TemporalAction::Delete),\n    ).await.unwrap();\n\n    // Verify update\n    let updated = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(updated.temporal_state.current_ind, true);\n    assert_eq!(updated.temporal_state.future_ind, false);\n    assert_eq!(updated.temporal_state.future_action, Some(TemporalAction::Delete));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436473Z",
      "modified_at": "2025-11-01T15:29:24.436473Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_token_limit_enforcement:______crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:133-174",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_token_limit_enforcement",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "line_range": {
        "start": 133,
        "end": 174
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_token_limit_enforcement() {\n    // Setup: Create many entities that would exceed token limit\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert 10 entities (in real scenario, this could be thousands)\n    for i in 0..10 {\n        let entity = create_test_entity(\n            &format!(\"rust:fn:func_{}:src_lib_rs:{}0-{}9\", i, i, i),\n            Some(&format!(\"fn func_{}() {{}}\", i)),\n            TemporalState::unchanged(),\n        );\n        storage.insert_entity(&entity).await.unwrap();\n    }\n\n    // Generate context with VERY LOW token limit to trigger error\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        max_context_tokens: 10, // Intentionally too low\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await;\n\n    // EXPECTATION: Should return error when context exceeds token limit\n    // CURRENT: Will FAIL because no token counting is implemented\n    assert!(\n        result.is_err(),\n        \"Should error when context exceeds token limit\"\n    );\n}",
    "future_code": "async fn test_token_limit_enforcement() {\n    // Setup: Create many entities that would exceed token limit\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert 10 entities (in real scenario, this could be thousands)\n    for i in 0..10 {\n        let entity = create_test_entity(\n            &format!(\"rust:fn:func_{}:src_lib_rs:{}0-{}9\", i, i, i),\n            Some(&format!(\"fn func_{}() {{}}\", i)),\n            TemporalState::unchanged(),\n        );\n        storage.insert_entity(&entity).await.unwrap();\n    }\n\n    // Generate context with VERY LOW token limit to trigger error\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir\n        .path()\n        .join(\"context.json\")\n        .to_string_lossy()\n        .to_string();\n\n    let config = ContextWriterConfig {\n        db_path: \"mem\".to_string(),\n        max_context_tokens: 10, // Intentionally too low\n        ..ContextWriterConfig::default()\n    };\n\n    let llm_client = ToolFactory::create_llm_client(config.clone());\n    let storage_arc = Arc::new(storage);\n    let optimizer = ContextOptimizerImpl::new(storage_arc, config, llm_client);\n\n    let result = optimizer.generate_context(&output_path).await;\n\n    // EXPECTATION: Should return error when context exceeds token limit\n    // CURRENT: Will FAIL because no token counting is implemented\n    assert!(\n        result.is_err(),\n        \"Should error when context exceeds token limit\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436475Z",
      "modified_at": "2025-11-01T15:29:24.436475Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool1_tool2_integration:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:221-321",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool1_tool2_integration",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 221,
        "end": 321
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool1_tool2_integration() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Step 1: Tool 1 indexes 3 entities\n    let entity1 = create_test_entity(\"function_to_edit\", \"src/main.rs\", (10, 20));\n    let entity2 = create_test_entity(\"function_to_delete\", \"src/main.rs\", (30, 40));\n    let entity3 = create_test_entity(\"function_unchanged\", \"src/main.rs\", (50, 60));\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Verify all start with initial state (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true);\n        assert_eq!(e.temporal_state.future_ind, false);\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n\n    // Step 2: Tool 2 edits entity1\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Step 3: Tool 2 deletes entity2\n    storage\n        .update_temporal_state(&key2, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Step 4: Tool 2 creates new entity\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new.rs\",\n        \"newly_created\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"newly_created\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn newly_created() {}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Step 5: Verify final states\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true, \"Entity1 should exist in current\");\n    assert_eq!(e1.temporal_state.future_ind, true, \"Entity1 should exist in future\");\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit), \"Entity1 should be marked for Edit\");\n\n    let e2 = storage.get_entity(&key2).await.unwrap();\n    assert_eq!(e2.temporal_state.current_ind, true, \"Entity2 should exist in current\");\n    assert_eq!(e2.temporal_state.future_ind, false, \"Entity2 should NOT exist in future\");\n    assert_eq!(e2.temporal_state.future_action, Some(TemporalAction::Delete), \"Entity2 should be marked for Delete\");\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, None, \"Entity3 should remain unchanged\");\n\n    let e4 = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e4.temporal_state.current_ind, false, \"New entity should NOT exist in current\");\n    assert_eq!(e4.temporal_state.future_ind, true, \"New entity should exist in future\");\n    assert_eq!(e4.temporal_state.future_action, Some(TemporalAction::Create), \"New entity should be marked for Create\");\n\n    // Verify get_changed_entities returns 3 entities (Edit, Delete, Create)\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 entities with pending changes\");\n}",
    "future_code": "async fn test_tool1_tool2_integration() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Step 1: Tool 1 indexes 3 entities\n    let entity1 = create_test_entity(\"function_to_edit\", \"src/main.rs\", (10, 20));\n    let entity2 = create_test_entity(\"function_to_delete\", \"src/main.rs\", (30, 40));\n    let entity3 = create_test_entity(\"function_unchanged\", \"src/main.rs\", (50, 60));\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Verify all start with initial state (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true);\n        assert_eq!(e.temporal_state.future_ind, false);\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n\n    // Step 2: Tool 2 edits entity1\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Step 3: Tool 2 deletes entity2\n    storage\n        .update_temporal_state(&key2, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Step 4: Tool 2 creates new entity\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new.rs\",\n        \"newly_created\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"newly_created\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn newly_created() {}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Step 5: Verify final states\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true, \"Entity1 should exist in current\");\n    assert_eq!(e1.temporal_state.future_ind, true, \"Entity1 should exist in future\");\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit), \"Entity1 should be marked for Edit\");\n\n    let e2 = storage.get_entity(&key2).await.unwrap();\n    assert_eq!(e2.temporal_state.current_ind, true, \"Entity2 should exist in current\");\n    assert_eq!(e2.temporal_state.future_ind, false, \"Entity2 should NOT exist in future\");\n    assert_eq!(e2.temporal_state.future_action, Some(TemporalAction::Delete), \"Entity2 should be marked for Delete\");\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, None, \"Entity3 should remain unchanged\");\n\n    let e4 = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e4.temporal_state.current_ind, false, \"New entity should NOT exist in current\");\n    assert_eq!(e4.temporal_state.future_ind, true, \"New entity should exist in future\");\n    assert_eq!(e4.temporal_state.future_action, Some(TemporalAction::Create), \"New entity should be marked for Create\");\n\n    // Verify get_changed_entities returns 3 entities (Edit, Delete, Create)\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 entities with pending changes\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436476Z",
      "modified_at": "2025-11-01T15:29:24.436476Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool2_create_operation_with_hash_key:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:149-210",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool2_create_operation_with_hash_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 149,
        "end": 210
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool2_create_operation_with_hash_key() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Tool 2 Create operation with hash-based key\n    let hash_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(), // Temporary lines\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(hash_key.clone(), signature).unwrap();\n\n    // Set Create state manually (simulating Tool 2 logic)\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Verify: Create state (0,1,Create)\n    let created = storage.get_entity(&hash_key).await.unwrap();\n    assert_eq!(created.temporal_state.current_ind, false, \"Should NOT exist in current\");\n    assert_eq!(created.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        created.temporal_state.future_action,\n        Some(TemporalAction::Create),\n        \"Should be marked for Create\"\n    );\n    assert!(created.future_code.is_some(), \"Should have future_code\");\n\n    // Verify hash key format\n    assert!(hash_key.contains(\"src_new_feature_rs\"), \"Should have sanitized filepath\");\n    assert!(hash_key.contains(\"new_awesome_function\"), \"Should have entity name\");\n    assert!(hash_key.contains(\"-fn-\"), \"Should have entity type\");\n    assert!(hash_key.matches('-').count() >= 3, \"Should have at least 3 dashes (path-name-type-hash)\");\n}",
    "future_code": "async fn test_tool2_create_operation_with_hash_key() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Tool 2 Create operation with hash-based key\n    let hash_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(), // Temporary lines\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(hash_key.clone(), signature).unwrap();\n\n    // Set Create state manually (simulating Tool 2 logic)\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Verify: Create state (0,1,Create)\n    let created = storage.get_entity(&hash_key).await.unwrap();\n    assert_eq!(created.temporal_state.current_ind, false, \"Should NOT exist in current\");\n    assert_eq!(created.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        created.temporal_state.future_action,\n        Some(TemporalAction::Create),\n        \"Should be marked for Create\"\n    );\n    assert!(created.future_code.is_some(), \"Should have future_code\");\n\n    // Verify hash key format\n    assert!(hash_key.contains(\"src_new_feature_rs\"), \"Should have sanitized filepath\");\n    assert!(hash_key.contains(\"new_awesome_function\"), \"Should have entity name\");\n    assert!(hash_key.contains(\"-fn-\"), \"Should have entity type\");\n    assert!(hash_key.matches('-').count() >= 3, \"Should have at least 3 dashes (path-name-type-hash)\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436477Z",
      "modified_at": "2025-11-01T15:29:24.436477Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool2_delete_operation:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:108-138",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool2_delete_operation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 108,
        "end": 138
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool2_delete_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1\n    let entity = create_test_entity(\"deprecated_function\", \"src/old.rs\", (20, 25));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Execute: Tool 2 Delete operation\n    storage\n        .update_temporal_state(&key, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Verify: Delete state (1,0,Delete)\n    let deleted = storage.get_entity(&key).await.unwrap();\n    assert_eq!(deleted.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(deleted.temporal_state.future_ind, false, \"Should NOT exist in future\");\n    assert_eq!(\n        deleted.temporal_state.future_action,\n        Some(TemporalAction::Delete),\n        \"Should be marked for Delete\"\n    );\n}",
    "future_code": "async fn test_tool2_delete_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1\n    let entity = create_test_entity(\"deprecated_function\", \"src/old.rs\", (20, 25));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Execute: Tool 2 Delete operation\n    storage\n        .update_temporal_state(&key, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Verify: Delete state (1,0,Delete)\n    let deleted = storage.get_entity(&key).await.unwrap();\n    assert_eq!(deleted.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(deleted.temporal_state.future_ind, false, \"Should NOT exist in future\");\n    assert_eq!(\n        deleted.temporal_state.future_action,\n        Some(TemporalAction::Delete),\n        \"Should be marked for Delete\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436478Z",
      "modified_at": "2025-11-01T15:29:24.436478Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool2_edit_operation:______crates_parseltongue-core_tests_tool2_temporal_operations_rs:55-98",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool2_edit_operation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "line_range": {
        "start": 55,
        "end": 98
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool2_edit_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1 (initial state: 1,0,None)\n    let entity = create_test_entity(\"calculate_sum\", \"src/lib.rs\", (10, 15));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Verify initial state from Tool 1\n    let initial = storage.get_entity(&key).await.unwrap();\n    assert_eq!(initial.temporal_state.current_ind, true, \"Should exist in current\");\n    assert_eq!(initial.temporal_state.future_ind, false, \"Future unknown initially\");\n    assert_eq!(initial.temporal_state.future_action, None);\n\n    // Execute: Tool 2 Edit operation\n    storage\n        .update_temporal_state(&key, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Set future_code (simulating LLM generation)\n    let mut updated = storage.get_entity(&key).await.unwrap();\n    updated.future_code = Some(format!(\"fn calculate_sum() {{\\n    // LLM-improved code\\n}}\"));\n    storage.update_entity(updated).await.unwrap();\n\n    // Verify: Edit state (1,1,Edit)\n    let edited = storage.get_entity(&key).await.unwrap();\n    assert_eq!(edited.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(edited.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        edited.temporal_state.future_action,\n        Some(TemporalAction::Edit),\n        \"Should be marked for Edit\"\n    );\n    assert!(edited.future_code.is_some(), \"Should have future_code\");\n    assert_ne!(edited.future_code, edited.current_code, \"Future should differ from current\");\n}",
    "future_code": "async fn test_tool2_edit_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1 (initial state: 1,0,None)\n    let entity = create_test_entity(\"calculate_sum\", \"src/lib.rs\", (10, 15));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Verify initial state from Tool 1\n    let initial = storage.get_entity(&key).await.unwrap();\n    assert_eq!(initial.temporal_state.current_ind, true, \"Should exist in current\");\n    assert_eq!(initial.temporal_state.future_ind, false, \"Future unknown initially\");\n    assert_eq!(initial.temporal_state.future_action, None);\n\n    // Execute: Tool 2 Edit operation\n    storage\n        .update_temporal_state(&key, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Set future_code (simulating LLM generation)\n    let mut updated = storage.get_entity(&key).await.unwrap();\n    updated.future_code = Some(format!(\"fn calculate_sum() {{\\n    // LLM-improved code\\n}}\"));\n    storage.update_entity(updated).await.unwrap();\n\n    // Verify: Edit state (1,1,Edit)\n    let edited = storage.get_entity(&key).await.unwrap();\n    assert_eq!(edited.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(edited.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        edited.temporal_state.future_action,\n        Some(TemporalAction::Edit),\n        \"Should be marked for Edit\"\n    );\n    assert!(edited.future_code.is_some(), \"Should have future_code\");\n    assert_ne!(edited.future_code, edited.current_code, \"Future should differ from current\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436479Z",
      "modified_at": "2025-11-01T15:29:24.436479Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool3_filters_by_current_ind:______crates_parseltongue-core_tests_tool3_prd_compliance_rs:254-296",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool3_filters_by_current_ind",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "line_range": {
        "start": 254,
        "end": 296
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool3_filters_by_current_ind() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let all_entities = storage.get_all_entities().await.unwrap();\n\n    println!(\"\\n=== TEMPORAL STATE FILTERING TEST ===\");\n    println!(\"Total entities in database: {}\", all_entities.len());\n\n    // Count by temporal state\n    let current_only = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .count();\n\n    let future_only = all_entities\n        .iter()\n        .filter(|e| !e.temporal_state.current_ind && e.temporal_state.future_ind)\n        .count();\n\n    println!(\"current_ind=1: {}\", current_only);\n    println!(\"future_only (current_ind=0, future_ind=1): {}\", future_only);\n\n    // After Tool 1 indexing, all entities should be current_ind=1, future_ind=0\n    // (Tool 2 hasn't created any future-only entities yet)\n    assert_eq!(\n        current_only,\n        all_entities.len(),\n        \"All entities from Tool 1 should have current_ind=1\"\n    );\n\n    // Tool 3 context should include ALL these entities\n    let context_entities: Vec<_> = all_entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    assert_eq!(\n        context_entities.len(),\n        current_only,\n        \"Tool 3 should include all current_ind=1 entities\"\n    );\n}",
    "future_code": "async fn test_tool3_filters_by_current_ind() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let all_entities = storage.get_all_entities().await.unwrap();\n\n    println!(\"\\n=== TEMPORAL STATE FILTERING TEST ===\");\n    println!(\"Total entities in database: {}\", all_entities.len());\n\n    // Count by temporal state\n    let current_only = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .count();\n\n    let future_only = all_entities\n        .iter()\n        .filter(|e| !e.temporal_state.current_ind && e.temporal_state.future_ind)\n        .count();\n\n    println!(\"current_ind=1: {}\", current_only);\n    println!(\"future_only (current_ind=0, future_ind=1): {}\", future_only);\n\n    // After Tool 1 indexing, all entities should be current_ind=1, future_ind=0\n    // (Tool 2 hasn't created any future-only entities yet)\n    assert_eq!(\n        current_only,\n        all_entities.len(),\n        \"All entities from Tool 1 should have current_ind=1\"\n    );\n\n    // Tool 3 context should include ALL these entities\n    let context_entities: Vec<_> = all_entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    assert_eq!(\n        context_entities.len(),\n        current_only,\n        \"Tool 3 should include all current_ind=1 entities\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436480Z",
      "modified_at": "2025-11-01T15:29:24.436480Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool3_includes_tdd_classification:______crates_parseltongue-core_tests_tool3_prd_compliance_rs:183-247",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool3_includes_tdd_classification",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "line_range": {
        "start": 183,
        "end": 247
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool3_includes_tdd_classification() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    // Count TDD classifications\n    let test_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::TestImplementation\n            )\n        })\n        .count();\n\n    let code_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::CodeImplementation\n            )\n        })\n        .count();\n\n    println!(\"\\n=== TDD CLASSIFICATION IN TOOL 3 CONTEXT ===\");\n    println!(\"Test entities: {}\", test_count);\n    println!(\"Code entities: {}\", code_count);\n    println!(\"Total: {}\", current_entities.len());\n\n    // Verify: Should have test entities (Tool 1 fix validation)\n    assert!(\n        test_count > 100,\n        \"Should have >100 test entities, got {}\",\n        test_count\n    );\n    assert!(\n        code_count > 300,\n        \"Should have >300 code entities, got {}\",\n        code_count\n    );\n\n    // Create sample context entity to verify serialization\n    let sample_entity = &current_entities[0];\n    let context_entity = ContextEntity {\n        isgl1_key: sample_entity.isgl1_key.clone(),\n        interface_signature: serde_json::to_value(&sample_entity.interface_signature).unwrap(),\n        entity_class: format!(\"{:?}\", sample_entity.tdd_classification.entity_class),\n        lsp_metadata: sample_entity.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        // temporal_state excluded per PRD\n        // Full tdd_classification excluded - only entity_class needed\n    };\n\n    let json = serde_json::to_string_pretty(&context_entity).unwrap();\n    println!(\"\\nSample entity JSON:\\n{}\", json);\n\n    // Verify entity_class is serialized (simplified TDD classification)\n    assert!(json.contains(\"entity_class\"));\n}",
    "future_code": "async fn test_tool3_includes_tdd_classification() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    // Count TDD classifications\n    let test_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::TestImplementation\n            )\n        })\n        .count();\n\n    let code_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::CodeImplementation\n            )\n        })\n        .count();\n\n    println!(\"\\n=== TDD CLASSIFICATION IN TOOL 3 CONTEXT ===\");\n    println!(\"Test entities: {}\", test_count);\n    println!(\"Code entities: {}\", code_count);\n    println!(\"Total: {}\", current_entities.len());\n\n    // Verify: Should have test entities (Tool 1 fix validation)\n    assert!(\n        test_count > 100,\n        \"Should have >100 test entities, got {}\",\n        test_count\n    );\n    assert!(\n        code_count > 300,\n        \"Should have >300 code entities, got {}\",\n        code_count\n    );\n\n    // Create sample context entity to verify serialization\n    let sample_entity = &current_entities[0];\n    let context_entity = ContextEntity {\n        isgl1_key: sample_entity.isgl1_key.clone(),\n        interface_signature: serde_json::to_value(&sample_entity.interface_signature).unwrap(),\n        entity_class: format!(\"{:?}\", sample_entity.tdd_classification.entity_class),\n        lsp_metadata: sample_entity.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        // temporal_state excluded per PRD\n        // Full tdd_classification excluded - only entity_class needed\n    };\n\n    let json = serde_json::to_string_pretty(&context_entity).unwrap();\n    println!(\"\\nSample entity JSON:\\n{}\", json);\n\n    // Verify entity_class is serialized (simplified TDD classification)\n    assert!(json.contains(\"entity_class\"));\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436481Z",
      "modified_at": "2025-11-01T15:29:24.436481Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_tool3_pure_data_extraction_no_llm:______crates_parseltongue-core_tests_tool3_prd_compliance_rs:64-176",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_tool3_pure_data_extraction_no_llm",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "line_range": {
        "start": 64,
        "end": 176
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_tool3_pure_data_extraction_no_llm() {\n    // Setup: Connect to real parseltongue database from Tool 1\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .expect(\"Failed to connect to parseltongue database\");\n\n    // Execute: Pure data extraction (no LLM)\n    let entities = storage\n        .get_all_entities()\n        .await\n        .expect(\"Failed to query entities\");\n\n    println!(\"\\n=== TOOL 3 PRD COMPLIANCE TEST ===\\n\");\n    println!(\"Total entities in database: {}\", entities.len());\n\n    // Filter: Only current_ind=1 per PRD (line 122)\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"Entities with current_ind=1: {}\", current_entities.len());\n\n    // Verify: Should have 542 entities from Tool 1 indexing\n    assert!(\n        current_entities.len() > 500,\n        \"Expected >500 current entities from parseltongue codebase, got {}\",\n        current_entities.len()\n    );\n\n    // Transform: Strip code fields per PRD (line 123-128)\n    // Include ONLY: ISGL1 + interface_signature + TDD_Classification (simplified) + lsp_meta_data\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class), // Test vs CodeImplementation\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n            // temporal_state excluded - not in PRD (P01:128)\n            // Full tdd_classification excluded - only entity_class needed (ultra-minimalist)\n        })\n        .collect();\n\n    // Estimate tokens (rough approximation: 1 token  4 characters)\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"JSON output size: {} bytes\", json_output.len());\n    println!(\"Estimated tokens: {} tokens\", estimated_tokens);\n\n    // Verify: No current_code or future_code as TOP-LEVEL entity fields (before moving context_entities)\n    // Note: Interface signatures may contain function names \"current_code\"/\"future_code\" (which is fine)\n    // We need to check the entity structure doesn't have these as code content fields\n    let sample_json = serde_json::to_value(&context_entities[0]).unwrap();\n    let entity_keys: Vec<String> = sample_json.as_object()\n        .unwrap()\n        .keys()\n        .map(|k| k.to_string())\n        .collect();\n\n    assert!(\n        !entity_keys.contains(&\"current_code\".to_string()),\n        \"Entity MUST NOT have current_code field (PRD violation at P01:123-126)\"\n    );\n    assert!(\n        !entity_keys.contains(&\"future_code\".to_string()),\n        \"Entity MUST NOT have future_code field (PRD violation at P01:123-126)\"\n    );\n\n    // Create CodeGraphContext per PRD specification\n    let context = CodeGraphContext {\n        entities: context_entities,\n        entity_count: current_entities.len(),\n        token_count: estimated_tokens,\n        generated_at: chrono::Utc::now().to_rfc3339(),\n    };\n\n    // Write output for analysis\n    let output_path = PathBuf::from(\"/tmp/CodeGraphContext.json\");\n    let context_json = serde_json::to_string_pretty(&context).unwrap();\n    std::fs::write(&output_path, &context_json).expect(\"Failed to write output\");\n    println!(\"Output written to: {} for analysis\", output_path.display());\n\n    // Verify: Contains required fields per PRD (P01:128)\n    assert!(\n        json_output.contains(\"\\\"isgl1_key\\\"\"),\n        \"Output must contain isgl1_key\"\n    );\n    assert!(\n        json_output.contains(\"\\\"interface_signature\\\"\"),\n        \"Output must contain interface_signature\"\n    );\n    assert!(\n        json_output.contains(\"\\\"entity_class\\\"\"),\n        \"Output must contain entity_class (simplified TDD_Classification)\"\n    );\n\n    // Verify: Token limit per PRD (line 115: <100k tokens)\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens (PRD violation at P01:115)\",\n        estimated_tokens\n    );\n\n    println!(\"\\n Tool 3 PRD Compliance Validated:\");\n    println!(\"   - Pure data extraction (no LLM required)\");\n    println!(\"   - Only current_ind=1 entities included\");\n    println!(\"   - current_code/future_code excluded\");\n    println!(\"   - Token count: {} < 100k limit\", estimated_tokens);\n    println!(\"   - Output written to: {}\", output_path.display());\n}",
    "future_code": "async fn test_tool3_pure_data_extraction_no_llm() {\n    // Setup: Connect to real parseltongue database from Tool 1\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .expect(\"Failed to connect to parseltongue database\");\n\n    // Execute: Pure data extraction (no LLM)\n    let entities = storage\n        .get_all_entities()\n        .await\n        .expect(\"Failed to query entities\");\n\n    println!(\"\\n=== TOOL 3 PRD COMPLIANCE TEST ===\\n\");\n    println!(\"Total entities in database: {}\", entities.len());\n\n    // Filter: Only current_ind=1 per PRD (line 122)\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"Entities with current_ind=1: {}\", current_entities.len());\n\n    // Verify: Should have 542 entities from Tool 1 indexing\n    assert!(\n        current_entities.len() > 500,\n        \"Expected >500 current entities from parseltongue codebase, got {}\",\n        current_entities.len()\n    );\n\n    // Transform: Strip code fields per PRD (line 123-128)\n    // Include ONLY: ISGL1 + interface_signature + TDD_Classification (simplified) + lsp_meta_data\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class), // Test vs CodeImplementation\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n            // temporal_state excluded - not in PRD (P01:128)\n            // Full tdd_classification excluded - only entity_class needed (ultra-minimalist)\n        })\n        .collect();\n\n    // Estimate tokens (rough approximation: 1 token  4 characters)\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"JSON output size: {} bytes\", json_output.len());\n    println!(\"Estimated tokens: {} tokens\", estimated_tokens);\n\n    // Verify: No current_code or future_code as TOP-LEVEL entity fields (before moving context_entities)\n    // Note: Interface signatures may contain function names \"current_code\"/\"future_code\" (which is fine)\n    // We need to check the entity structure doesn't have these as code content fields\n    let sample_json = serde_json::to_value(&context_entities[0]).unwrap();\n    let entity_keys: Vec<String> = sample_json.as_object()\n        .unwrap()\n        .keys()\n        .map(|k| k.to_string())\n        .collect();\n\n    assert!(\n        !entity_keys.contains(&\"current_code\".to_string()),\n        \"Entity MUST NOT have current_code field (PRD violation at P01:123-126)\"\n    );\n    assert!(\n        !entity_keys.contains(&\"future_code\".to_string()),\n        \"Entity MUST NOT have future_code field (PRD violation at P01:123-126)\"\n    );\n\n    // Create CodeGraphContext per PRD specification\n    let context = CodeGraphContext {\n        entities: context_entities,\n        entity_count: current_entities.len(),\n        token_count: estimated_tokens,\n        generated_at: chrono::Utc::now().to_rfc3339(),\n    };\n\n    // Write output for analysis\n    let output_path = PathBuf::from(\"/tmp/CodeGraphContext.json\");\n    let context_json = serde_json::to_string_pretty(&context).unwrap();\n    std::fs::write(&output_path, &context_json).expect(\"Failed to write output\");\n    println!(\"Output written to: {} for analysis\", output_path.display());\n\n    // Verify: Contains required fields per PRD (P01:128)\n    assert!(\n        json_output.contains(\"\\\"isgl1_key\\\"\"),\n        \"Output must contain isgl1_key\"\n    );\n    assert!(\n        json_output.contains(\"\\\"interface_signature\\\"\"),\n        \"Output must contain interface_signature\"\n    );\n    assert!(\n        json_output.contains(\"\\\"entity_class\\\"\"),\n        \"Output must contain entity_class (simplified TDD_Classification)\"\n    );\n\n    // Verify: Token limit per PRD (line 115: <100k tokens)\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens (PRD violation at P01:115)\",\n        estimated_tokens\n    );\n\n    println!(\"\\n Tool 3 PRD Compliance Validated:\");\n    println!(\"   - Pure data extraction (no LLM required)\");\n    println!(\"   - Only current_ind=1 entities included\");\n    println!(\"   - current_code/future_code excluded\");\n    println!(\"   - Token count: {} < 100k limit\", estimated_tokens);\n    println!(\"   - Output written to: {}\", output_path.display());\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436483Z",
      "modified_at": "2025-11-01T15:29:24.436483Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_transitive_closure_branching:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:746-787",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_transitive_closure_branching",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 746,
        "end": 787
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_transitive_closure_branching() {\n    // RED: Transitive closure with diamond pattern\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create diamond: A -> B, A -> C, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D] (D counted once despite two paths)\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "future_code": "async fn test_transitive_closure_branching() {\n    // RED: Transitive closure with diamond pattern\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create diamond: A -> B, A -> C, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D] (D counted once despite two paths)\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436484Z",
      "modified_at": "2025-11-01T15:29:24.436484Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_transitive_closure_chain:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:708-743",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_transitive_closure_chain",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 708,
        "end": 743
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_transitive_closure_chain() {\n    // RED: Transitive closure for simple chain\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D]\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "future_code": "async fn test_transitive_closure_chain() {\n    // RED: Transitive closure for simple chain\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D]\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436485Z",
      "modified_at": "2025-11-01T15:29:24.436485Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_transitive_closure_cycle:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:790-826",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_transitive_closure_cycle",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 790,
        "end": 826
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_transitive_closure_cycle() {\n    // RED: Transitive closure must handle cycles correctly\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create cycle: A -> B -> C -> A (should not infinite loop)\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:A:test_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: Should return B, C, A (the cycle) without hanging\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    // In a cycle, all nodes are reachable from any node (including starting node via cycle)\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, and A (cycle)\");\n    assert!(reachable.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
    "future_code": "async fn test_transitive_closure_cycle() {\n    // RED: Transitive closure must handle cycles correctly\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create cycle: A -> B -> C -> A (should not infinite loop)\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:A:test_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: Should return B, C, A (the cycle) without hanging\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    // In a cycle, all nodes are reachable from any node (including starting node via cycle)\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, and A (cycle)\");\n    assert!(reachable.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436486Z",
      "modified_at": "2025-11-01T15:29:24.436486Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_transitive_closure_empty:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:829-838",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_transitive_closure_empty",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 829,
        "end": 838
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_transitive_closure_empty() {\n    // RED: Entity with no outgoing edges\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no dependencies\n    let reachable = db.get_transitive_closure(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 0, \"No outgoing edges means empty closure\");\n}",
    "future_code": "async fn test_transitive_closure_empty() {\n    // RED: Entity with no outgoing edges\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no dependencies\n    let reachable = db.get_transitive_closure(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 0, \"No outgoing edges means empty closure\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436487Z",
      "modified_at": "2025-11-01T15:29:24.436487Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_transitive_closure_performance_1k_nodes:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:942-978",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_transitive_closure_performance_1k_nodes",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 942,
        "end": 978
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_transitive_closure_performance_1k_nodes() {\n    // RED: Validate transitive closure performance on medium graph\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 1k node graph (smaller for unbounded query)\n    println!(\"Generating 1k node test graph...\");\n    let nodes = generate_large_graph(&db, 1_000, 3).await;\n\n    // Warm up\n    let _ = db.get_transitive_closure(&nodes[0]).await.unwrap();\n\n    // Performance test: Unbounded transitive closure\n    println!(\"Running transitive closure query (unbounded on 1k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_transitive_closure(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Transitive closure returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <100ms for 1k nodes unbounded\n    assert!(\n        elapsed < Duration::from_millis(100),\n        \"Transitive closure took {:?}, expected <100ms for 1k nodes\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find reachable nodes in connected graph\"\n    );\n}",
    "future_code": "async fn test_transitive_closure_performance_1k_nodes() {\n    // RED: Validate transitive closure performance on medium graph\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 1k node graph (smaller for unbounded query)\n    println!(\"Generating 1k node test graph...\");\n    let nodes = generate_large_graph(&db, 1_000, 3).await;\n\n    // Warm up\n    let _ = db.get_transitive_closure(&nodes[0]).await.unwrap();\n\n    // Performance test: Unbounded transitive closure\n    println!(\"Running transitive closure query (unbounded on 1k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_transitive_closure(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Transitive closure returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <100ms for 1k nodes unbounded\n    assert!(\n        elapsed < Duration::from_millis(100),\n        \"Transitive closure took {:?}, expected <100ms for 1k nodes\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find reachable nodes in connected graph\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436488Z",
      "modified_at": "2025-11-01T15:29:24.436488Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_type_error_passes_syntax_check:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:119-134",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_type_error_passes_syntax_check",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 119,
        "end": 134
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_type_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has a type error (returns i32, not String) but is syntactically valid\n    let type_error_code = r#\"\n        fn broken() -> String {\n            42  // Type error, but syntax is valid\n        }\n    \"#;\n\n    let result = validator.validate_syntax(type_error_code).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Type errors should pass syntax validation (cargo catches these)\"\n    );\n}",
    "future_code": "fn test_type_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has a type error (returns i32, not String) but is syntactically valid\n    let type_error_code = r#\"\n        fn broken() -> String {\n            42  // Type error, but syntax is valid\n        }\n    \"#;\n\n    let result = validator.validate_syntax(type_error_code).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Type errors should pass syntax validation (cargo catches these)\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436489Z",
      "modified_at": "2025-11-01T15:29:24.436489Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_update_entity:______crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:129-151",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_update_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "line_range": {
        "start": 129,
        "end": 151
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn test_update_entity() {\n    // RED: Update operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let mut entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Modify entity\n    entity.apply_temporal_change(\n        TemporalAction::Edit,\n        Some(\"struct TestStruct { field: i32 }\".to_string())\n    ).unwrap();\n\n    // Update in database\n    db.update_entity_internal(&entity).await.unwrap();\n\n    // Verify update\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(retrieved.future_code, Some(\"struct TestStruct { field: i32 }\".to_string()));\n}",
    "future_code": "async fn test_update_entity() {\n    // RED: Update operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let mut entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Modify entity\n    entity.apply_temporal_change(\n        TemporalAction::Edit,\n        Some(\"struct TestStruct { field: i32 }\".to_string())\n    ).unwrap();\n\n    // Update in database\n    db.update_entity_internal(&entity).await.unwrap();\n\n    // Verify update\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(retrieved.future_code, Some(\"struct TestStruct { field: i32 }\".to_string()));\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436490Z",
      "modified_at": "2025-11-01T15:29:24.436490Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_valid_function_syntax:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:9-21",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_valid_function_syntax",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 9,
        "end": 21
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_valid_function_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        fn calculate_sum(a: i32, b: i32) -> i32 {\n            a + b\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid function should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
    "future_code": "fn test_valid_function_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        fn calculate_sum(a: i32, b: i32) -> i32 {\n            a + b\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid function should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436491Z",
      "modified_at": "2025-11-01T15:29:24.436491Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_valid_impl_syntax:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:75-88",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_valid_impl_syntax",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 75,
        "end": 88
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_valid_impl_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        impl MyStruct {\n            pub fn new() -> Self {\n                Self {}\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid impl should pass syntax check\");\n}",
    "future_code": "fn test_valid_impl_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        impl MyStruct {\n            pub fn new() -> Self {\n                Self {}\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid impl should pass syntax check\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436492Z",
      "modified_at": "2025-11-01T15:29:24.436492Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_valid_struct_syntax:______crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:41-54",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_valid_struct_syntax",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "line_range": {
        "start": 41,
        "end": 54
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn test_valid_struct_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid struct should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
    "future_code": "fn test_valid_struct_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid struct should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436494Z",
      "modified_at": "2025-11-01T15:29:24.436494Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validate_all_stops_on_first_failure:______crates_pt04-syntax-preflight-validator_src_validator_rs:184-198",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validate_all_stops_on_first_failure",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 184,
        "end": 198
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_validate_all_stops_on_first_failure() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn broken_function( {\n                // Syntax error - should stop early\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(!report.overall_valid);\n        // Should only have syntax validation result (fail-fast)\n        assert_eq!(report.individual_results.len(), 1);\n    }",
    "future_code": "    async fn test_validate_all_stops_on_first_failure() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn broken_function( {\n                // Syntax error - should stop early\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(!report.overall_valid);\n        // Should only have syntax validation result (fail-fast)\n        assert_eq!(report.individual_results.len(), 1);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436495Z",
      "modified_at": "2025-11-01T15:29:24.436495Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validate_all_success:______crates_pt04-syntax-preflight-validator_src_validator_rs:201-215",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validate_all_success",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 201,
        "end": 215
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_validate_all_success() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn add(a: i32, b: i32) -> i32 {\n                a + b\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(report.overall_valid);\n        // Should have all 5 validation results\n        assert_eq!(report.individual_results.len(), 5);\n    }",
    "future_code": "    async fn test_validate_all_success() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn add(a: i32, b: i32) -> i32 {\n                a + b\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(report.overall_valid);\n        // Should have all 5 validation results\n        assert_eq!(report.individual_results.len(), 5);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436496Z",
      "modified_at": "2025-11-01T15:29:24.436496Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validate_syntax_invalid_code:______crates_pt04-syntax-preflight-validator_src_validator_rs:168-181",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validate_syntax_invalid_code",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 168,
        "end": 181
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_validate_syntax_invalid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main( {\n                // Missing closing parenthesis\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(!output.is_valid);\n        assert!(output.errors.len() > 0);\n    }",
    "future_code": "    async fn test_validate_syntax_invalid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main( {\n                // Missing closing parenthesis\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(!output.is_valid);\n        assert!(output.errors.len() > 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436497Z",
      "modified_at": "2025-11-01T15:29:24.436497Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validate_syntax_valid_code:______crates_pt04-syntax-preflight-validator_src_validator_rs:151-165",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validate_syntax_valid_code",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 151,
        "end": 165
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_validate_syntax_valid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main() {\n                println!(\"Hello, world!\");\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(output.is_valid);\n        assert_eq!(output.validation_type, ValidationType::Syntax);\n        assert_eq!(output.errors.len(), 0);\n    }",
    "future_code": "    async fn test_validate_syntax_valid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main() {\n                println!(\"Hello, world!\");\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(output.is_valid);\n        assert_eq!(output.validation_type, ValidationType::Syntax);\n        assert_eq!(output.errors.len(), 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436498Z",
      "modified_at": "2025-11-01T15:29:24.436498Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_output_success:______crates_pt04-syntax-preflight-validator_src_types_rs:174-178",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_output_success",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 174,
        "end": 178
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validation_output_success() {\n        let output = ValidationOutput::success(ValidationType::Syntax);\n        assert!(output.is_valid);\n        assert_eq!(output.errors.len(), 0);\n    }",
    "future_code": "    fn test_validation_output_success() {\n        let output = ValidationOutput::success(ValidationType::Syntax);\n        assert!(output.is_valid);\n        assert_eq!(output.errors.len(), 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436499Z",
      "modified_at": "2025-11-01T15:29:24.436499Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_report_aggregates_errors:______crates_pt04-syntax-preflight-validator_src_types_rs:195-206",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_report_aggregates_errors",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 195,
        "end": 206
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validation_report_aggregates_errors() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        let error1 = crate::errors::ValidationError::Parse(\"error 1\".to_string());\n        let error2 = crate::errors::ValidationError::Parse(\"error 2\".to_string());\n\n        report.add_result(ValidationOutput::failure(ValidationType::Syntax, error1));\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error2));\n\n        let all_errors = report.all_errors();\n        assert_eq!(all_errors.len(), 2);\n    }",
    "future_code": "    fn test_validation_report_aggregates_errors() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        let error1 = crate::errors::ValidationError::Parse(\"error 1\".to_string());\n        let error2 = crate::errors::ValidationError::Parse(\"error 2\".to_string());\n\n        report.add_result(ValidationOutput::failure(ValidationType::Syntax, error1));\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error2));\n\n        let all_errors = report.all_errors();\n        assert_eq!(all_errors.len(), 2);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436500Z",
      "modified_at": "2025-11-01T15:29:24.436500Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_report_overall_status:______crates_pt04-syntax-preflight-validator_src_types_rs:181-192",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_report_overall_status",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 181,
        "end": 192
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validation_report_overall_status() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        // Add successful result\n        report.add_result(ValidationOutput::success(ValidationType::Syntax));\n        assert!(report.overall_valid);\n\n        // Add failed result\n        let error = crate::errors::ValidationError::Parse(\"test error\".to_string());\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error));\n        assert!(!report.overall_valid);\n    }",
    "future_code": "    fn test_validation_report_overall_status() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        // Add successful result\n        report.add_result(ValidationOutput::success(ValidationType::Syntax));\n        assert!(report.overall_valid);\n\n        // Add failed result\n        let error = crate::errors::ValidationError::Parse(\"test error\".to_string());\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error));\n        assert!(!report.overall_valid);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436502Z",
      "modified_at": "2025-11-01T15:29:24.436502Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_report_tracks_timing:______crates_pt04-syntax-preflight-validator_src_validator_rs:218-228",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_report_tracks_timing",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 218,
        "end": 228
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn test_validation_report_tracks_timing() {\n        let validator = DefaultRustValidator::new();\n        let code = \"fn main() {}\";\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n\n        // Timing should be tracked (even if zero for now)\n        assert!(report.total_execution_time_ms >= 0);\n    }",
    "future_code": "    async fn test_validation_report_tracks_timing() {\n        let validator = DefaultRustValidator::new();\n        let code = \"fn main() {}\";\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n\n        // Timing should be tracked (even if zero for now)\n        assert!(report.total_execution_time_ms >= 0);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436503Z",
      "modified_at": "2025-11-01T15:29:24.436503Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_type_all:______crates_pt04-syntax-preflight-validator_src_types_rs:159-164",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_type_all",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 159,
        "end": 164
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validation_type_all() {\n        let types = ValidationType::all();\n        assert_eq!(types.len(), 5);\n        assert_eq!(types[0], ValidationType::Syntax);\n        assert_eq!(types[4], ValidationType::Test);\n    }",
    "future_code": "    fn test_validation_type_all() {\n        let types = ValidationType::all();\n        assert_eq!(types.len(), 5);\n        assert_eq!(types[0], ValidationType::Syntax);\n        assert_eq!(types[4], ValidationType::Test);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436504Z",
      "modified_at": "2025-11-01T15:29:24.436504Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validation_type_up_to:______crates_pt04-syntax-preflight-validator_src_types_rs:167-171",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validation_type_up_to",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 167,
        "end": 171
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validation_type_up_to() {\n        let up_to_compilation = ValidationType::Compilation.up_to();\n        assert_eq!(up_to_compilation.len(), 4);\n        assert!(!up_to_compilation.contains(&ValidationType::Test));\n    }",
    "future_code": "    fn test_validation_type_up_to() {\n        let up_to_compilation = ValidationType::Compilation.up_to();\n        assert_eq!(up_to_compilation.len(), 4);\n        assert!(!up_to_compilation.contains(&ValidationType::Test));\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436505Z",
      "modified_at": "2025-11-01T15:29:24.436505Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_validator_creation:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:151-154",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_validator_creation",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 151,
        "end": 154
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_validator_creation() {\n        let validator = SimpleSyntaxValidator::new();\n        assert!(validator.is_ok(), \"Should create validator successfully\");\n    }",
    "future_code": "    fn test_validator_creation() {\n        let validator = SimpleSyntaxValidator::new();\n        assert!(validator.is_ok(), \"Should create validator successfully\");\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436506Z",
      "modified_at": "2025-11-01T15:29:24.436506Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_write_result_success:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:113-120",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_write_result_success",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 113,
        "end": 120
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_write_result_success() {\n        let result = WriteResult::success(\n            PathBuf::from(\"test.rs\"),\n            WriteOperation::Create,\n        );\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n    }",
    "future_code": "    fn test_write_result_success() {\n        let result = WriteResult::success(\n            PathBuf::from(\"test.rs\"),\n            WriteOperation::Create,\n        );\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436507Z",
      "modified_at": "2025-11-01T15:29:24.436507Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:test_write_summary:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:123-138",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "test_write_summary",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 123,
        "end": 138
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn test_write_summary() {\n        let mut summary = WriteSummary::new();\n\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file1.rs\"),\n            WriteOperation::Create,\n        ));\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file2.rs\"),\n            WriteOperation::Edit,\n        ));\n\n        assert_eq!(summary.created, 1);\n        assert_eq!(summary.edited, 1);\n        assert_eq!(summary.total, 2);\n    }",
    "future_code": "    fn test_write_summary() {\n        let mut summary = WriteSummary::new();\n\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file1.rs\"),\n            WriteOperation::Create,\n        ));\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file2.rs\"),\n            WriteOperation::Edit,\n        ));\n\n        assert_eq!(summary.created, 1);\n        assert_eq!(summary.edited, 1);\n        assert_eq!(summary.total, 2);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436508Z",
      "modified_at": "2025-11-01T15:29:24.436508Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:to_datalog:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:95-121",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "to_datalog",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 95,
        "end": 121
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn to_datalog(&self) -> String {\n        // Precondition validation (contract-based programming)\n        // Using panic! is intentional - this is a programming error, not a runtime error\n        self.validate_preconditions();\n\n        let (current_ind, future_ind, action_str) = self.action.to_temporal_state();\n        let future_code_value = self.escape_future_code();\n\n        // Generate Datalog matching actual CodeGraph schema (13 fields)\n        // Note: ISGL1_key => indicates primary key in :put syntax\n        format!(\n            r#\"?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[\"{}\", null, {}, \"\", \"\",\n              null, {}, {}, \"{}\", \"\",\n              \"\", \"\", \"\"]]\n\n            :put CodeGraph {{\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }}\"#,\n            self.entity_key, future_code_value, current_ind, future_ind, action_str\n        )\n    }",
    "future_code": "    pub fn to_datalog(&self) -> String {\n        // Precondition validation (contract-based programming)\n        // Using panic! is intentional - this is a programming error, not a runtime error\n        self.validate_preconditions();\n\n        let (current_ind, future_ind, action_str) = self.action.to_temporal_state();\n        let future_code_value = self.escape_future_code();\n\n        // Generate Datalog matching actual CodeGraph schema (13 fields)\n        // Note: ISGL1_key => indicates primary key in :put syntax\n        format!(\n            r#\"?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[\"{}\", null, {}, \"\", \"\",\n              null, {}, {}, \"{}\", \"\",\n              \"\", \"\", \"\"]]\n\n            :put CodeGraph {{\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }}\"#,\n            self.entity_key, future_code_value, current_ind, future_ind, action_str\n        )\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436509Z",
      "modified_at": "2025-11-01T15:29:24.436509Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:to_json_pretty:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:156-158",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "to_json_pretty",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 156,
        "end": 158
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn to_json_pretty(&self) -> serde_json::Result<String> {\n        serde_json::to_string_pretty(self)\n    }",
    "future_code": "    pub fn to_json_pretty(&self) -> serde_json::Result<String> {\n        serde_json::to_string_pretty(self)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436510Z",
      "modified_at": "2025-11-01T15:29:24.436510Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:to_key:______crates_parseltongue-core_src_entities_rs:1041-1044",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "to_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1041,
        "end": 1044
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn to_key(mut self, key: impl Into<String>) -> Self {\n        self.to_key = Some(key.into());\n        self\n    }",
    "future_code": "    pub fn to_key(mut self, key: impl Into<String>) -> Self {\n        self.to_key = Some(key.into());\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436511Z",
      "modified_at": "2025-11-01T15:29:24.436511Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:to_temporal_state:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:48-54",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "to_temporal_state",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 48,
        "end": 54
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub const fn to_temporal_state(self) -> (&'static str, &'static str, &'static str) {\n        match self {\n            EntityAction::Create => (\"false\", \"true\", \"Create\"),\n            EntityAction::Edit => (\"true\", \"true\", \"Edit\"),\n            EntityAction::Delete => (\"true\", \"false\", \"Delete\"),\n        }\n    }",
    "future_code": "    pub const fn to_temporal_state(self) -> (&'static str, &'static str, &'static str) {\n        match self {\n            EntityAction::Create => (\"false\", \"true\", \"Create\"),\n            EntityAction::Edit => (\"true\", \"true\", \"Edit\"),\n            EntityAction::Delete => (\"true\", \"false\", \"Delete\"),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436512Z",
      "modified_at": "2025-11-01T15:29:24.436512Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:tokio_test_function_classified_correctly:______crates_pt01-folder-to-cozodb-streamer_tests_tdd_classification_test_rs:95-138",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "tokio_test_function_classified_correctly",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs",
      "line_range": {
        "start": 95,
        "end": 138
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn tokio_test_function_classified_correctly() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"async_test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[tokio::test]\nasync fn test_async_function() {\n    assert_eq!(1 + 1, 2);\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    assert_eq!(entities.len(), 1);\n    let test_entity = &entities[0];\n\n    // RED: Will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"#[tokio::test] function should be classified as TEST_IMPLEMENTATION\"\n    );\n}",
    "future_code": "async fn tokio_test_function_classified_correctly() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"async_test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[tokio::test]\nasync fn test_async_function() {\n    assert_eq!(1 + 1, 2);\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    assert_eq!(entities.len(), 1);\n    let test_entity = &entities[0];\n\n    // RED: Will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"#[tokio::test] function should be classified as TEST_IMPLEMENTATION\"\n    );\n}",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436514Z",
      "modified_at": "2025-11-01T15:29:24.436514Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:tool_metadata_creation:______crates_parseltongue-core_src_interfaces_rs:620-639",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "tool_metadata_creation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 620,
        "end": 639
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn tool_metadata_creation() {\n        let metadata = ToolMetadata {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"A test tool\".to_string(),\n            supported_inputs: vec![\"test\".to_string()],\n            capabilities: ToolCapabilities {\n                async_execution: true,\n                parallel_processing: false,\n                incremental_processing: true,\n                requires_network: false,\n                max_input_size: Some(1024),\n            },\n        };\n\n        assert_eq!(metadata.id, \"test-tool\");\n        assert!(metadata.capabilities.async_execution);\n        assert!(!metadata.capabilities.parallel_processing);\n    }",
    "future_code": "    fn tool_metadata_creation() {\n        let metadata = ToolMetadata {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"A test tool\".to_string(),\n            supported_inputs: vec![\"test\".to_string()],\n            capabilities: ToolCapabilities {\n                async_execution: true,\n                parallel_processing: false,\n                incremental_processing: true,\n                requires_network: false,\n                max_input_size: Some(1024),\n            },\n        };\n\n        assert_eq!(metadata.id, \"test-tool\");\n        assert!(metadata.capabilities.async_execution);\n        assert!(!metadata.capabilities.parallel_processing);\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436515Z",
      "modified_at": "2025-11-01T15:29:24.436515Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:unchanged:______crates_parseltongue-core_src_entities_rs:175-181",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "unchanged",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 175,
        "end": 181
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn unchanged() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,  // Unchanged state exists in both present and future\n            future_action: None,\n        }\n    }",
    "future_code": "    pub fn unchanged() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,  // Unchanged state exists in both present and future\n            future_action: None,\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436516Z",
      "modified_at": "2025-11-01T15:29:24.436516Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:up_to:______crates_pt04-syntax-preflight-validator_src_types_rs:35-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "up_to",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 35,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn up_to(self) -> Vec<Self> {\n        match self {\n            Self::Syntax => vec![Self::Syntax],\n            Self::Type => vec![Self::Syntax, Self::Type],\n            Self::BorrowChecker => vec![Self::Syntax, Self::Type, Self::BorrowChecker],\n            Self::Compilation => vec![Self::Syntax, Self::Type, Self::BorrowChecker, Self::Compilation],\n            Self::Test => Self::all(),\n        }\n    }",
    "future_code": "    pub fn up_to(self) -> Vec<Self> {\n        match self {\n            Self::Syntax => vec![Self::Syntax],\n            Self::Type => vec![Self::Syntax, Self::Type],\n            Self::BorrowChecker => vec![Self::Syntax, Self::Type, Self::BorrowChecker],\n            Self::Compilation => vec![Self::Syntax, Self::Type, Self::BorrowChecker, Self::Compilation],\n            Self::Test => Self::all(),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436517Z",
      "modified_at": "2025-11-01T15:29:24.436517Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:update_entity:______crates_parseltongue-core_src_storage_cozo_client_rs:1145-1147",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "update_entity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 1145,
        "end": 1147
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn update_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.update_entity_internal(&entity).await\n    }",
    "future_code": "    async fn update_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.update_entity_internal(&entity).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436518Z",
      "modified_at": "2025-11-01T15:29:24.436518Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:update_entity_internal:______crates_parseltongue-core_src_storage_cozo_client_rs:725-728",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "update_entity_internal",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 725,
        "end": 728
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn update_entity_internal(&self, entity: &CodeEntity) -> Result<()> {\n        // Update is same as insert with :put which replaces existing\n        self.insert_entity(entity).await\n    }",
    "future_code": "    pub async fn update_entity_internal(&self, entity: &CodeEntity) -> Result<()> {\n        // Update is same as insert with :put which replaces existing\n        self.insert_entity(entity).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436519Z",
      "modified_at": "2025-11-01T15:29:24.436519Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:update_stats:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:319-327",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "update_stats",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 319,
        "end": 327
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn update_stats(&self, entities_created: usize, had_error: bool) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.files_processed += 1;\n            stats.entities_created += entities_created;\n            if had_error {\n                stats.errors_encountered += 1;\n            }\n        }\n    }",
    "future_code": "    fn update_stats(&self, entities_created: usize, had_error: bool) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.files_processed += 1;\n            stats.entities_created += entities_created;\n            if had_error {\n                stats.errors_encountered += 1;\n            }\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436520Z",
      "modified_at": "2025-11-01T15:29:24.436520Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:update_stats:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:435-444",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "update_stats",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 435,
        "end": 444
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn update_stats(&self, entities_count: usize, tokens_generated: usize, optimization_ratio: f32, generation_time: Duration) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.contexts_generated += 1;\n            stats.entities_processed += entities_count;\n            stats.tokens_generated += tokens_generated;\n            stats.optimization_savings += (entities_count as f32 * optimization_ratio) as usize;\n            stats.llm_requests_made += 1;\n            stats.total_generation_time += generation_time;\n        }\n    }",
    "future_code": "    fn update_stats(&self, entities_count: usize, tokens_generated: usize, optimization_ratio: f32, generation_time: Duration) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.contexts_generated += 1;\n            stats.entities_processed += entities_count;\n            stats.tokens_generated += tokens_generated;\n            stats.optimization_savings += (entities_count as f32 * optimization_ratio) as usize;\n            stats.llm_requests_made += 1;\n            stats.total_generation_time += generation_time;\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436521Z",
      "modified_at": "2025-11-01T15:29:24.436521Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:update_temporal_state:______crates_parseltongue-core_src_storage_cozo_client_rs:751-769",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "update_temporal_state",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 751,
        "end": 769
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn update_temporal_state(\n        &self,\n        isgl1_key: &str,\n        future_ind: bool,\n        future_action: Option<TemporalAction>,\n    ) -> Result<()> {\n        // Get current entity\n        let mut entity = self.get_entity(isgl1_key).await?;\n\n        // Update temporal state\n        entity.temporal_state.future_ind = future_ind;\n        entity.temporal_state.future_action = future_action.clone();\n\n        // Validate temporal state\n        entity.temporal_state.validate()?;\n\n        // Update in database\n        self.update_entity_internal(&entity).await\n    }",
    "future_code": "    pub async fn update_temporal_state(\n        &self,\n        isgl1_key: &str,\n        future_ind: bool,\n        future_action: Option<TemporalAction>,\n    ) -> Result<()> {\n        // Get current entity\n        let mut entity = self.get_entity(isgl1_key).await?;\n\n        // Update temporal state\n        entity.temporal_state.future_ind = future_ind;\n        entity.temporal_state.future_action = future_action.clone();\n\n        // Validate temporal state\n        entity.temporal_state.validate()?;\n\n        // Update in database\n        self.update_entity_internal(&entity).await\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436522Z",
      "modified_at": "2025-11-01T15:29:24.436522Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:updated_signature:______crates_parseltongue-core_src_temporal_rs:427-430",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "updated_signature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 427,
        "end": 430
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn updated_signature(mut self, signature: InterfaceSignature) -> Self {\n        self.updated_signature = Some(signature);\n        self\n    }",
    "future_code": "    pub fn updated_signature(mut self, signature: InterfaceSignature) -> Self {\n        self.updated_signature = Some(signature);\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436523Z",
      "modified_at": "2025-11-01T15:29:24.436524Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:valid:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:130-135",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "valid",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 130,
        "end": 135
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn valid() -> Self {\n        Self {\n            is_valid: true,\n            errors: vec![],\n        }\n    }",
    "future_code": "    pub fn valid() -> Self {\n        Self {\n            is_valid: true,\n            errors: vec![],\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436524Z",
      "modified_at": "2025-11-01T15:29:24.436524Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_parseltongue-core_src_entities_rs:211-232",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 211,
        "end": 232
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate(&self) -> Result<()> {\n        // Cannot have both indicators false\n        if !self.current_ind && !self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Both current_ind and future_ind cannot be false\".to_string(),\n            });\n        }\n\n        // Validate action compatibility\n        if let Some(ref action) = self.future_action {\n            action.validate_with_indicators(self.current_ind, self.future_ind)?;\n        }\n\n        // If no action, indicators should be the same\n        if self.future_action.is_none() && self.current_ind != self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Temporal indicators differ but no action specified\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "future_code": "    pub fn validate(&self) -> Result<()> {\n        // Cannot have both indicators false\n        if !self.current_ind && !self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Both current_ind and future_ind cannot be false\".to_string(),\n            });\n        }\n\n        // Validate action compatibility\n        if let Some(ref action) = self.future_action {\n            action.validate_with_indicators(self.current_ind, self.future_ind)?;\n        }\n\n        // If no action, indicators should be the same\n        if self.future_action.is_none() && self.current_ind != self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Temporal indicators differ but no action specified\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436526Z",
      "modified_at": "2025-11-01T15:29:24.436526Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_parseltongue-core_src_entities_rs:667-686",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 667,
        "end": 686
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate(&self) -> Result<()> {\n        // Validate ISGL1 key format\n        self.validate_isgl1_key()?;\n\n        // Validate temporal state\n        self.temporal_state.validate()?;\n\n        // Validate line range\n        LineRange::new(self.interface_signature.line_range.start, self.interface_signature.line_range.end)\n            .map_err(|e| ParseltongError::ValidationError {\n                field: \"line_range\".to_string(),\n                expected: \"valid line range\".to_string(),\n                actual: e.to_string(),\n            })?;\n\n        // Validate code consistency\n        self.validate_code_consistency()?;\n\n        Ok(())\n    }",
    "future_code": "    pub fn validate(&self) -> Result<()> {\n        // Validate ISGL1 key format\n        self.validate_isgl1_key()?;\n\n        // Validate temporal state\n        self.temporal_state.validate()?;\n\n        // Validate line range\n        LineRange::new(self.interface_signature.line_range.start, self.interface_signature.line_range.end)\n            .map_err(|e| ParseltongError::ValidationError {\n                field: \"line_range\".to_string(),\n                expected: \"valid line range\".to_string(),\n                actual: e.to_string(),\n            })?;\n\n        // Validate code consistency\n        self.validate_code_consistency()?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436527Z",
      "modified_at": "2025-11-01T15:29:24.436527Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_parseltongue-core_src_temporal_rs:281-301",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 281,
        "end": 301
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        // Simplified circular dependency detection\n        // In a real implementation, this would build a dependency graph\n        // and check for cycles\n\n        for entity in entities.values() {\n            if entity.is_modified() {\n                // Check if entity depends on itself (simplified)\n                if entity.isgl1_key.contains(&entity.interface_signature.name) {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Potential circular dependency detected for entity {}\",\n                            entity.isgl1_key\n                        ),\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        // Simplified circular dependency detection\n        // In a real implementation, this would build a dependency graph\n        // and check for cycles\n\n        for entity in entities.values() {\n            if entity.is_modified() {\n                // Check if entity depends on itself (simplified)\n                if entity.isgl1_key.contains(&entity.interface_signature.name) {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Potential circular dependency detected for entity {}\",\n                            entity.isgl1_key\n                        ),\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436528Z",
      "modified_at": "2025-11-01T15:29:24.436528Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_parseltongue-core_src_temporal_rs:323-349",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 323,
        "end": 349
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            // Validate temporal state consistency\n            entity.validate()?;\n\n            // Ensure code consistency\n            if entity.temporal_state.current_ind && entity.current_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has current_ind=true but no current_code\",\n                        key\n                    ),\n                });\n            }\n\n            if entity.temporal_state.future_ind && entity.future_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has future_ind=true but no future_code\",\n                        key\n                    ),\n                });\n            }\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            // Validate temporal state consistency\n            entity.validate()?;\n\n            // Ensure code consistency\n            if entity.temporal_state.current_ind && entity.current_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has current_ind=true but no current_code\",\n                        key\n                    ),\n                });\n            }\n\n            if entity.temporal_state.future_ind && entity.future_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has future_ind=true but no future_code\",\n                        key\n                    ),\n                });\n            }\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436529Z",
      "modified_at": "2025-11-01T15:29:24.436529Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_parseltongue-core_src_temporal_rs:371-389",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 371,
        "end": 389
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            if let Some(ref action) = entity.temporal_state.future_action {\n                // Validate action is compatible with temporal indicators\n                action.validate_with_indicators(\n                    entity.temporal_state.current_ind,\n                    entity.temporal_state.future_ind,\n                ).map_err(|e| ParseltongError::TemporalError {\n                    details: format!(\n                        \"Invalid transition for entity {}: {}\",\n                        key,\n                        e\n                    ),\n                })?;\n            }\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            if let Some(ref action) = entity.temporal_state.future_action {\n                // Validate action is compatible with temporal indicators\n                action.validate_with_indicators(\n                    entity.temporal_state.current_ind,\n                    entity.temporal_state.future_ind,\n                ).map_err(|e| ParseltongError::TemporalError {\n                    details: format!(\n                        \"Invalid transition for entity {}: {}\",\n                        key,\n                        e\n                    ),\n                })?;\n            }\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436531Z",
      "modified_at": "2025-11-01T15:29:24.436531Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate:______crates_pt04-syntax-preflight-validator_src_cli_rs:60-65",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/cli.rs",
      "line_range": {
        "start": 60,
        "end": 65
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.code_snippet.is_none() && self.file.is_none() {\n            anyhow::bail!(\"Either --code-snippet or --file must be provided\");\n        }\n        Ok(())\n    }",
    "future_code": "    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.code_snippet.is_none() && self.file.is_none() {\n            anyhow::bail!(\"Either --code-snippet or --file must be provided\");\n        }\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436532Z",
      "modified_at": "2025-11-01T15:29:24.436532Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_all:______crates_pt04-syntax-preflight-validator_src_validator_rs:25-48",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_all",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 25,
        "end": 48
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_all(&self, code: &str) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        // Run validations in order, stop on first failure\n        for validation_type in ValidationType::all() {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            // Stop on first failure (fail-fast for efficiency)\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
    "future_code": "    async fn validate_all(&self, code: &str) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        // Run validations in order, stop on first failure\n        for validation_type in ValidationType::all() {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            // Stop on first failure (fail-fast for efficiency)\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436533Z",
      "modified_at": "2025-11-01T15:29:24.436533Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_borrow_checker:______crates_pt04-syntax-preflight-validator_src_validator_rs:128-131",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_borrow_checker",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 128,
        "end": 131
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_borrow_checker(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::BorrowChecker))\n    }",
    "future_code": "    async fn validate_borrow_checker(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::BorrowChecker))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436534Z",
      "modified_at": "2025-11-01T15:29:24.436534Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_code_consistency:______crates_parseltongue-core_src_entities_rs:706-726",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_code_consistency",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 706,
        "end": 726
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_code_consistency(&self) -> Result<()> {\n        // If entity exists in current state, it should have current code\n        if self.temporal_state.current_ind && self.current_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"current_code\".to_string(),\n                expected: \"present when current_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        // If entity will exist in future state, it should have future code\n        if self.temporal_state.future_ind && self.future_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"future_code\".to_string(),\n                expected: \"present when future_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate_code_consistency(&self) -> Result<()> {\n        // If entity exists in current state, it should have current code\n        if self.temporal_state.current_ind && self.current_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"current_code\".to_string(),\n                expected: \"present when current_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        // If entity will exist in future state, it should have future code\n        if self.temporal_state.future_ind && self.future_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"future_code\".to_string(),\n                expected: \"present when future_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436535Z",
      "modified_at": "2025-11-01T15:29:24.436535Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_compilation:______crates_pt04-syntax-preflight-validator_src_validator_rs:133-136",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_compilation",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 133,
        "end": 136
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_compilation(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Compilation))\n    }",
    "future_code": "    async fn validate_compilation(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Compilation))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436536Z",
      "modified_at": "2025-11-01T15:29:24.436536Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_config:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:361-384",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_config",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 361,
        "end": 384
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_config(&self) -> Result<()> {\n        if self.config.llm_api_key.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"llm_api_key\".to_string(),\n                reason: \"API key cannot be empty\".to_string(),\n            });\n        }\n\n        if self.config.llm_endpoint.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"llm_endpoint\".to_string(),\n                reason: \"Endpoint cannot be empty\".to_string(),\n            });\n        }\n\n        if self.config.model.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"model\".to_string(),\n                reason: \"Model cannot be empty\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate_config(&self) -> Result<()> {\n        if self.config.llm_api_key.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"llm_api_key\".to_string(),\n                reason: \"API key cannot be empty\".to_string(),\n            });\n        }\n\n        if self.config.llm_endpoint.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"llm_endpoint\".to_string(),\n                reason: \"Endpoint cannot be empty\".to_string(),\n            });\n        }\n\n        if self.config.model.is_empty() {\n            return Err(ContextWriterError::ConfigurationError {\n                field: \"model\".to_string(),\n                reason: \"Model cannot be empty\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436537Z",
      "modified_at": "2025-11-01T15:29:24.436537Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_entity_compatibility:______crates_parseltongue-core_src_temporal_rs:163-175",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_entity_compatibility",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 163,
        "end": 175
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_entity_compatibility(&self, existing: &CodeEntity, new: &CodeEntity) -> Result<()> {\n        // Check if both entities have conflicting temporal states\n        if existing.is_modified() && new.is_modified() {\n            return Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Concurrent modifications detected for entity {}\",\n                    existing.isgl1_key\n                ),\n            });\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate_entity_compatibility(&self, existing: &CodeEntity, new: &CodeEntity) -> Result<()> {\n        // Check if both entities have conflicting temporal states\n        if existing.is_modified() && new.is_modified() {\n            return Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Concurrent modifications detected for entity {}\",\n                    existing.isgl1_key\n                ),\n            });\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436538Z",
      "modified_at": "2025-11-01T15:29:24.436538Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_input:______crates_parseltongue-core_src_interfaces_rs:598-607",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_input",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 598,
        "end": 607
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        fn validate_input(&self, _input: &ToolInput) -> Result<()> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ValidationError {\n                    field: \"input\".to_string(),\n                    expected: \"valid input\".to_string(),\n                    actual: \"mock failure\".to_string(),\n                });\n            }\n            Ok(())\n        }",
    "future_code": "        fn validate_input(&self, _input: &ToolInput) -> Result<()> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ValidationError {\n                    field: \"input\".to_string(),\n                    expected: \"valid input\".to_string(),\n                    actual: \"mock failure\".to_string(),\n                });\n            }\n            Ok(())\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436539Z",
      "modified_at": "2025-11-01T15:29:24.436539Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_isgl1_key:______crates_parseltongue-core_src_entities_rs:688-704",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_isgl1_key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 688,
        "end": 704
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_isgl1_key(&self) -> Result<()> {\n        if self.isgl1_key.is_empty() {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            });\n        }\n\n        if !self.isgl1_key.contains('-') {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key must contain hyphens\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate_isgl1_key(&self) -> Result<()> {\n        if self.isgl1_key.is_empty() {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            });\n        }\n\n        if !self.isgl1_key.contains('-') {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key must contain hyphens\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436541Z",
      "modified_at": "2025-11-01T15:29:24.436541Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_preconditions:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:124-131",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_preconditions",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 124,
        "end": 131
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_preconditions(&self) {\n        match self.action {\n            EntityAction::Create | EntityAction::Edit if self.future_code.is_none() => {\n                panic!(\"{:?} action requires future_code\", self.action);\n            }\n            _ => {}\n        }\n    }",
    "future_code": "    fn validate_preconditions(&self) {\n        match self.action {\n            EntityAction::Create | EntityAction::Edit if self.future_code.is_none() => {\n                panic!(\"{:?} action requires future_code\", self.action);\n            }\n            _ => {}\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436562Z",
      "modified_at": "2025-11-01T15:29:24.436562Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_rust_syntax:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:291-303",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_rust_syntax",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 291,
        "end": 303
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn validate_rust_syntax(code: &str) -> Result<ValidationResult> {\n    // Use syn crate for syntax validation\n    match syn::parse_file(code) {\n        Ok(_) => Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        }),\n        Err(e) => Ok(ValidationResult {\n            is_valid: false,\n            errors: vec![format!(\"Syntax error: {}\", e)],\n        }),\n    }\n}",
    "future_code": "fn validate_rust_syntax(code: &str) -> Result<ValidationResult> {\n    // Use syn crate for syntax validation\n    match syn::parse_file(code) {\n        Ok(_) => Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        }),\n        Err(e) => Ok(ValidationResult {\n            is_valid: false,\n            errors: vec![format!(\"Syntax error: {}\", e)],\n        }),\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436563Z",
      "modified_at": "2025-11-01T15:29:24.436563Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_rust_syntax:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:341-346",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_rust_syntax",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 341,
        "end": 346
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn validate_rust_syntax(code: &str) -> Result<bool> {\n    match syn::parse_file(code) {\n        Ok(_) => Ok(true),\n        Err(_) => Ok(false),\n    }\n}",
    "future_code": "fn validate_rust_syntax(code: &str) -> Result<bool> {\n    match syn::parse_file(code) {\n        Ok(_) => Ok(true),\n        Err(_) => Ok(false),\n    }\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436564Z",
      "modified_at": "2025-11-01T15:29:24.436564Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_semantics:______crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:349-356",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_semantics",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "line_range": {
        "start": 349,
        "end": 356
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "fn validate_semantics(code: &str) -> Result<bool> {\n    // Check that the fix actually addresses the bug\n    let has_addition = code.contains(\"a + b\");\n    let no_subtraction_in_add = !code.contains(\"fn add\")\n        || !code[code.find(\"fn add\").unwrap()..].contains(\"a - b\");\n\n    Ok(has_addition && no_subtraction_in_add)\n}",
    "future_code": "fn validate_semantics(code: &str) -> Result<bool> {\n    // Check that the fix actually addresses the bug\n    let has_addition = code.contains(\"a + b\");\n    let no_subtraction_in_add = !code.contains(\"fn add\")\n        || !code[code.find(\"fn add\").unwrap()..].contains(\"a - b\");\n\n    Ok(has_addition && no_subtraction_in_add)\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436565Z",
      "modified_at": "2025-11-01T15:29:24.436565Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_specific:______crates_pt04-syntax-preflight-validator_src_validator_rs:51-72",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_specific",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 51,
        "end": 72
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_specific(&self, code: &str, types: Vec<ValidationType>) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        for validation_type in types {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
    "future_code": "    async fn validate_specific(&self, code: &str, types: Vec<ValidationType>) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        for validation_type in types {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436566Z",
      "modified_at": "2025-11-01T15:29:24.436566Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_state:______crates_parseltongue-core_src_temporal_rs:142-144",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_state",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 142,
        "end": 144
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate_state(&self) -> Result<()> {\n        self.run_validation_rules()\n    }",
    "future_code": "    pub fn validate_state(&self) -> Result<()> {\n        self.run_validation_rules()\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436567Z",
      "modified_at": "2025-11-01T15:29:24.436567Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_syntax:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:59-81",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_syntax",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 59,
        "end": 81
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate_syntax(&mut self, code: &str) -> Result<ValidationResult> {\n        // Parse code with tree-sitter\n        let tree = self\n            .parser\n            .parse(code, None)\n            .context(\"Failed to parse code with tree-sitter\")?;\n\n        let root = tree.root_node();\n\n        // Check for syntax errors in parse tree\n        if root.has_error() {\n            let errors = self.collect_syntax_errors(&root, code);\n            return Ok(ValidationResult {\n                is_valid: false,\n                errors,\n            });\n        }\n\n        Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        })\n    }",
    "future_code": "    pub fn validate_syntax(&mut self, code: &str) -> Result<ValidationResult> {\n        // Parse code with tree-sitter\n        let tree = self\n            .parser\n            .parse(code, None)\n            .context(\"Failed to parse code with tree-sitter\")?;\n\n        let root = tree.root_node();\n\n        // Check for syntax errors in parse tree\n        if root.has_error() {\n            let errors = self.collect_syntax_errors(&root, code);\n            return Ok(ValidationResult {\n                is_valid: false,\n                errors,\n            });\n        }\n\n        Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        })\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436579Z",
      "modified_at": "2025-11-01T15:29:24.436579Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_syntax:______crates_pt04-syntax-preflight-validator_src_validator_rs:92-121",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_syntax",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 92,
        "end": 121
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_syntax(&self, code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Minimal implementation using syn\n        let start = std::time::Instant::now();\n\n        let result = syn::parse_file(code);\n\n        let execution_time_ms = start.elapsed().as_millis() as u64;\n\n        match result {\n            Ok(_) => Ok(ValidationOutput {\n                is_valid: true,\n                validation_type: ValidationType::Syntax,\n                errors: Vec::new(),\n                warnings: Vec::new(),\n                execution_time_ms,\n                memory_usage_bytes: 0, // Simplified for GREEN phase\n            }),\n            Err(e) => {\n                let error_msg = format!(\"Syntax error: {}\", e);\n                Ok(ValidationOutput {\n                    is_valid: false,\n                    validation_type: ValidationType::Syntax,\n                    errors: vec![error_msg],\n                    warnings: Vec::new(),\n                    execution_time_ms,\n                    memory_usage_bytes: 0,\n                })\n            }\n        }\n    }",
    "future_code": "    async fn validate_syntax(&self, code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Minimal implementation using syn\n        let start = std::time::Instant::now();\n\n        let result = syn::parse_file(code);\n\n        let execution_time_ms = start.elapsed().as_millis() as u64;\n\n        match result {\n            Ok(_) => Ok(ValidationOutput {\n                is_valid: true,\n                validation_type: ValidationType::Syntax,\n                errors: Vec::new(),\n                warnings: Vec::new(),\n                execution_time_ms,\n                memory_usage_bytes: 0, // Simplified for GREEN phase\n            }),\n            Err(e) => {\n                let error_msg = format!(\"Syntax error: {}\", e);\n                Ok(ValidationOutput {\n                    is_valid: false,\n                    validation_type: ValidationType::Syntax,\n                    errors: vec![error_msg],\n                    warnings: Vec::new(),\n                    execution_time_ms,\n                    memory_usage_bytes: 0,\n                })\n            }\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436581Z",
      "modified_at": "2025-11-01T15:29:24.436581Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_temporal_change:______crates_parseltongue-core_src_temporal_rs:177-209",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_temporal_change",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 177,
        "end": 209
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validate_temporal_change(&self, change: &TemporalChange) -> Result<()> {\n        // Validate temporal action compatibility\n        let entity = self.entities.get(&change.isgl1_key);\n\n        match (&entity, &change.action) {\n            (None, TemporalAction::Edit | TemporalAction::Delete) => {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Cannot {} non-existent entity {}\",\n                        match change.action {\n                            TemporalAction::Edit => \"edit\",\n                            TemporalAction::Delete => \"delete\",\n                            _ => unreachable!(),\n                        },\n                        change.isgl1_key\n                    ),\n                });\n            }\n            (Some(entity), TemporalAction::Create) => {\n                if entity.temporal_state.current_ind {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Cannot create entity {} that already exists\",\n                            change.isgl1_key\n                        ),\n                    });\n                }\n            }\n            _ => {}\n        }\n\n        Ok(())\n    }",
    "future_code": "    fn validate_temporal_change(&self, change: &TemporalChange) -> Result<()> {\n        // Validate temporal action compatibility\n        let entity = self.entities.get(&change.isgl1_key);\n\n        match (&entity, &change.action) {\n            (None, TemporalAction::Edit | TemporalAction::Delete) => {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Cannot {} non-existent entity {}\",\n                        match change.action {\n                            TemporalAction::Edit => \"edit\",\n                            TemporalAction::Delete => \"delete\",\n                            _ => unreachable!(),\n                        },\n                        change.isgl1_key\n                    ),\n                });\n            }\n            (Some(entity), TemporalAction::Create) => {\n                if entity.temporal_state.current_ind {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Cannot create entity {} that already exists\",\n                            change.isgl1_key\n                        ),\n                    });\n                }\n            }\n            _ => {}\n        }\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436582Z",
      "modified_at": "2025-11-01T15:29:24.436582Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_tests:______crates_pt04-syntax-preflight-validator_src_validator_rs:138-141",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_tests",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 138,
        "end": 141
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_tests(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Test))\n    }",
    "future_code": "    async fn validate_tests(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Test))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436583Z",
      "modified_at": "2025-11-01T15:29:24.436583Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_types:______crates_pt04-syntax-preflight-validator_src_validator_rs:123-126",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_types",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 123,
        "end": 126
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn validate_types(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Type))\n    }",
    "future_code": "    async fn validate_types(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Type))\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436584Z",
      "modified_at": "2025-11-01T15:29:24.436584Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validate_with_indicators:______crates_parseltongue-core_src_entities_rs:127-143",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validate_with_indicators",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 127,
        "end": 143
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn validate_with_indicators(\n        &self,\n        current_ind: bool,\n        future_ind: bool,\n    ) -> Result<()> {\n        match (current_ind, future_ind, self) {\n            (true, false, TemporalAction::Delete) => Ok(()),\n            (true, true, TemporalAction::Edit) => Ok(()),\n            (false, true, TemporalAction::Create) => Ok(()),\n            _ => Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Invalid temporal combination: current={}, future={}, action={:?}\",\n                    current_ind, future_ind, self\n                ),\n            }),\n        }\n    }",
    "future_code": "    pub fn validate_with_indicators(\n        &self,\n        current_ind: bool,\n        future_ind: bool,\n    ) -> Result<()> {\n        match (current_ind, future_ind, self) {\n            (true, false, TemporalAction::Delete) => Ok(()),\n            (true, true, TemporalAction::Edit) => Ok(()),\n            (false, true, TemporalAction::Create) => Ok(()),\n            _ => Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Invalid temporal combination: current={}, future={}, action={:?}\",\n                    current_ind, future_ind, self\n                ),\n            }),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436586Z",
      "modified_at": "2025-11-01T15:29:24.436586Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:validation_rules:______crates_parseltongue-core_src_temporal_rs:684-713",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "validation_rules",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 684,
        "end": 713
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn validation_rules() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Test with invalid entity (missing code when current_ind=true)\n        let mut invalid_entity = CodeEntity::new(\n            \"invalid.rs-invalid\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"invalid\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"invalid.rs\"),\n                line_range: LineRange::new(1, 1).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        invalid_entity.temporal_state.current_ind = true;\n        // current_code is None, which should cause validation to fail\n\n        let result = manager.add_entity(invalid_entity);\n        assert!(result.is_err());\n    }",
    "future_code": "    fn validation_rules() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Test with invalid entity (missing code when current_ind=true)\n        let mut invalid_entity = CodeEntity::new(\n            \"invalid.rs-invalid\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"invalid\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"invalid.rs\"),\n                line_range: LineRange::new(1, 1).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n        ).unwrap();\n\n        invalid_entity.temporal_state.current_ind = true;\n        // current_code is None, which should cause validation to fail\n\n        let result = manager.add_entity(invalid_entity);\n        assert!(result.is_err());\n    }",
    "tdd_classification": {
      "entity_class": "TestImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436587Z",
      "modified_at": "2025-11-01T15:29:24.436587Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:verify_tool1_parseltongue_indexing:______crates_parseltongue-core_tests_tool1_verification_rs:10-164",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "verify_tool1_parseltongue_indexing",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool1_verification.rs",
      "line_range": {
        "start": 10,
        "end": 164
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "async fn verify_tool1_parseltongue_indexing() {\n    let storage = CozoDbStorage::new(\"rocksdb:/tmp/parseltongue-rigorous-test.db\")\n        .await\n        .expect(\"Failed to connect to test database\");\n\n    // Get all entities\n    let entities = storage.get_all_entities().await.expect(\"Failed to get entities\");\n\n    println!(\"\\n=== TOOL 1 DATA VERIFICATION ===\\n\");\n    println!(\"Total Entities: {}\", entities.len());\n    assert!(entities.len() > 500, \"Expected >500 entities from parseltongue codebase, got {}\", entities.len());\n\n    // Sample ISGL1 keys\n    println!(\"\\n--- Sample ISGL1 Keys (Line-Based Format Check) ---\");\n    for (i, entity) in entities.iter().take(10).enumerate() {\n        println!(\"{}. {}\", i+1, entity.isgl1_key);\n        println!(\"   Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"   Name: {}\", entity.interface_signature.name);\n        println!(\"   File: {}\", entity.interface_signature.file_path.display());\n        println!(\"   Lines: {}-{}\",\n            entity.interface_signature.line_range.start,\n            entity.interface_signature.line_range.end\n        );\n    }\n\n    // TDD Classification breakdown\n    println!(\"\\n--- TDD Classification Breakdown ---\");\n    let mut test_count = 0;\n    let mut code_count = 0;\n\n    for entity in &entities {\n        match entity.tdd_classification.entity_class {\n            parseltongue_core::entities::EntityClass::TestImplementation => test_count += 1,\n            parseltongue_core::entities::EntityClass::CodeImplementation => code_count += 1,\n            _ => {}\n        }\n    }\n\n    println!(\"TEST_IMPLEMENTATION: {}\", test_count);\n    println!(\"CODE_IMPLEMENTATION: {}\", code_count);\n    println!(\"Classification Rate: {:.1}%\", (test_count + code_count) as f64 / entities.len() as f64 * 100.0);\n\n    assert!(test_count > 0, \"Should have some test entities\");\n    assert!(code_count > 0, \"Should have some code entities\");\n\n    // Temporal state verification (should all be initial state after Tool 1)\n    println!(\"\\n--- Temporal State (should all be current_ind=1, future_ind=0) ---\");\n    let mut correct_state = 0;\n    for entity in &entities {\n        if entity.temporal_state.current_ind\n            && !entity.temporal_state.future_ind\n            && entity.temporal_state.future_action.is_none()\n        {\n            correct_state += 1;\n        }\n    }\n    println!(\"Correct Initial State: {}/{} ({:.1}%)\",\n        correct_state, entities.len(),\n        correct_state as f64 / entities.len() as f64 * 100.0\n    );\n\n    assert_eq!(correct_state, entities.len(),\n        \"All entities should have initial temporal state (1,0,None), but {}/{} were correct\",\n        correct_state, entities.len()\n    );\n\n    // Key format validation\n    println!(\"\\n--- ISGL1 Key Format Validation ---\");\n    let mut line_based_count = 0;\n    let mut potential_hash_based = 0;\n\n    for entity in &entities {\n        let key = &entity.isgl1_key;\n        // Line-based format check (very basic heuristic)\n        if key.contains(':') && key.contains('-') {\n            // Count colons - line-based should have multiple\n            let colon_count = key.matches(':').count();\n            if colon_count >= 2 {\n                line_based_count += 1;\n            } else {\n                potential_hash_based += 1;\n            }\n        }\n    }\n\n    println!(\"Likely line-based keys: {} ({:.1}%)\",\n        line_based_count,\n        line_based_count as f64 / entities.len() as f64 * 100.0\n    );\n\n    if potential_hash_based > 0 {\n        println!(\"Potential hash-based keys: {} ({:.1}%)\",\n            potential_hash_based,\n            potential_hash_based as f64 / entities.len() as f64 * 100.0\n        );\n    }\n\n    // Tool 1 should only create line-based keys (hash-based is for Tool 2 Create operations)\n    println!(\"\\nExpected: 100% line-based keys (Tool 1 indexes existing code only)\");\n\n    // Sample entity detail inspection\n    println!(\"\\n--- Detailed Entity Inspection ---\");\n    if let Some(entity) = entities.first() {\n        println!(\"First Entity:\");\n        println!(\"  ISGL1: {}\", entity.isgl1_key);\n        println!(\"  Name: {}\", entity.interface_signature.name);\n        println!(\"  Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"  Visibility: {:?}\", entity.interface_signature.visibility);\n        println!(\"  File: {}\", entity.interface_signature.file_path.display());\n        println!(\"  Lines: {:?}\", entity.interface_signature.line_range);\n        println!(\"  TDD Class: {:?}\", entity.tdd_classification.entity_class);\n        println!(\"  Temporal: (current={}, future={}, action={:?})\",\n            entity.temporal_state.current_ind,\n            entity.temporal_state.future_ind,\n            entity.temporal_state.future_action\n        );\n        println!(\"  Has Current Code: {}\", entity.current_code.is_some());\n        println!(\"  Has Future Code: {}\", entity.future_code.is_some());\n    }\n\n    // Find test entities\n    println!(\"\\n--- Sample Test Entities ---\");\n    let test_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::TestImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in test_entities.iter().enumerate() {\n        println!(\"{}. {} [{}]\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    // Find code entities\n    println!(\"\\n--- Sample Code Entities ---\");\n    let code_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::CodeImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in code_entities.iter().enumerate() {\n        println!(\"{}. {} [{:?}] in {}\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.entity_type,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    println!(\"\\n Tool 1 verification complete!\\n\");\n}",
    "future_code": "async fn verify_tool1_parseltongue_indexing() {\n    let storage = CozoDbStorage::new(\"rocksdb:/tmp/parseltongue-rigorous-test.db\")\n        .await\n        .expect(\"Failed to connect to test database\");\n\n    // Get all entities\n    let entities = storage.get_all_entities().await.expect(\"Failed to get entities\");\n\n    println!(\"\\n=== TOOL 1 DATA VERIFICATION ===\\n\");\n    println!(\"Total Entities: {}\", entities.len());\n    assert!(entities.len() > 500, \"Expected >500 entities from parseltongue codebase, got {}\", entities.len());\n\n    // Sample ISGL1 keys\n    println!(\"\\n--- Sample ISGL1 Keys (Line-Based Format Check) ---\");\n    for (i, entity) in entities.iter().take(10).enumerate() {\n        println!(\"{}. {}\", i+1, entity.isgl1_key);\n        println!(\"   Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"   Name: {}\", entity.interface_signature.name);\n        println!(\"   File: {}\", entity.interface_signature.file_path.display());\n        println!(\"   Lines: {}-{}\",\n            entity.interface_signature.line_range.start,\n            entity.interface_signature.line_range.end\n        );\n    }\n\n    // TDD Classification breakdown\n    println!(\"\\n--- TDD Classification Breakdown ---\");\n    let mut test_count = 0;\n    let mut code_count = 0;\n\n    for entity in &entities {\n        match entity.tdd_classification.entity_class {\n            parseltongue_core::entities::EntityClass::TestImplementation => test_count += 1,\n            parseltongue_core::entities::EntityClass::CodeImplementation => code_count += 1,\n            _ => {}\n        }\n    }\n\n    println!(\"TEST_IMPLEMENTATION: {}\", test_count);\n    println!(\"CODE_IMPLEMENTATION: {}\", code_count);\n    println!(\"Classification Rate: {:.1}%\", (test_count + code_count) as f64 / entities.len() as f64 * 100.0);\n\n    assert!(test_count > 0, \"Should have some test entities\");\n    assert!(code_count > 0, \"Should have some code entities\");\n\n    // Temporal state verification (should all be initial state after Tool 1)\n    println!(\"\\n--- Temporal State (should all be current_ind=1, future_ind=0) ---\");\n    let mut correct_state = 0;\n    for entity in &entities {\n        if entity.temporal_state.current_ind\n            && !entity.temporal_state.future_ind\n            && entity.temporal_state.future_action.is_none()\n        {\n            correct_state += 1;\n        }\n    }\n    println!(\"Correct Initial State: {}/{} ({:.1}%)\",\n        correct_state, entities.len(),\n        correct_state as f64 / entities.len() as f64 * 100.0\n    );\n\n    assert_eq!(correct_state, entities.len(),\n        \"All entities should have initial temporal state (1,0,None), but {}/{} were correct\",\n        correct_state, entities.len()\n    );\n\n    // Key format validation\n    println!(\"\\n--- ISGL1 Key Format Validation ---\");\n    let mut line_based_count = 0;\n    let mut potential_hash_based = 0;\n\n    for entity in &entities {\n        let key = &entity.isgl1_key;\n        // Line-based format check (very basic heuristic)\n        if key.contains(':') && key.contains('-') {\n            // Count colons - line-based should have multiple\n            let colon_count = key.matches(':').count();\n            if colon_count >= 2 {\n                line_based_count += 1;\n            } else {\n                potential_hash_based += 1;\n            }\n        }\n    }\n\n    println!(\"Likely line-based keys: {} ({:.1}%)\",\n        line_based_count,\n        line_based_count as f64 / entities.len() as f64 * 100.0\n    );\n\n    if potential_hash_based > 0 {\n        println!(\"Potential hash-based keys: {} ({:.1}%)\",\n            potential_hash_based,\n            potential_hash_based as f64 / entities.len() as f64 * 100.0\n        );\n    }\n\n    // Tool 1 should only create line-based keys (hash-based is for Tool 2 Create operations)\n    println!(\"\\nExpected: 100% line-based keys (Tool 1 indexes existing code only)\");\n\n    // Sample entity detail inspection\n    println!(\"\\n--- Detailed Entity Inspection ---\");\n    if let Some(entity) = entities.first() {\n        println!(\"First Entity:\");\n        println!(\"  ISGL1: {}\", entity.isgl1_key);\n        println!(\"  Name: {}\", entity.interface_signature.name);\n        println!(\"  Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"  Visibility: {:?}\", entity.interface_signature.visibility);\n        println!(\"  File: {}\", entity.interface_signature.file_path.display());\n        println!(\"  Lines: {:?}\", entity.interface_signature.line_range);\n        println!(\"  TDD Class: {:?}\", entity.tdd_classification.entity_class);\n        println!(\"  Temporal: (current={}, future={}, action={:?})\",\n            entity.temporal_state.current_ind,\n            entity.temporal_state.future_ind,\n            entity.temporal_state.future_action\n        );\n        println!(\"  Has Current Code: {}\", entity.current_code.is_some());\n        println!(\"  Has Future Code: {}\", entity.future_code.is_some());\n    }\n\n    // Find test entities\n    println!(\"\\n--- Sample Test Entities ---\");\n    let test_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::TestImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in test_entities.iter().enumerate() {\n        println!(\"{}. {} [{}]\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    // Find code entities\n    println!(\"\\n--- Sample Code Entities ---\");\n    let code_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::CodeImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in code_entities.iter().enumerate() {\n        println!(\"{}. {} [{:?}] in {}\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.entity_type,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    println!(\"\\n Tool 1 verification complete!\\n\");\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436589Z",
      "modified_at": "2025-11-01T15:29:24.436589Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:walk_node:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:205-234",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "walk_node",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 205,
        "end": 234
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    fn walk_node(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // For Rust, check if this node or its siblings have attributes\n        if language == Language::Rust && node.kind() == \"function_item\" {\n            // Check preceding siblings for attributes\n            let has_test_attr = self.check_preceding_test_attribute(node, source);\n            self.extract_rust_function_with_test_info(node, source, file_path, entities, has_test_attr);\n        } else {\n            match language {\n                Language::Rust => self.extract_rust_entities(node, source, file_path, entities),\n                Language::Python => {\n                    // TODO: Implement Python entity extraction\n                }\n                _ => {}\n            }\n        }\n\n        // Recursively process child nodes (Pass 1: entities only)\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.walk_node(&child, source, file_path, language, entities, dependencies);\n        }\n    }",
    "future_code": "    fn walk_node(\n        &self,\n        node: &tree_sitter::Node<'_>,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // For Rust, check if this node or its siblings have attributes\n        if language == Language::Rust && node.kind() == \"function_item\" {\n            // Check preceding siblings for attributes\n            let has_test_attr = self.check_preceding_test_attribute(node, source);\n            self.extract_rust_function_with_test_info(node, source, file_path, entities, has_test_attr);\n        } else {\n            match language {\n                Language::Rust => self.extract_rust_entities(node, source, file_path, entities),\n                Language::Python => {\n                    // TODO: Implement Python entity extraction\n                }\n                _ => {}\n            }\n        }\n\n        // Recursively process child nodes (Pass 1: entities only)\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.walk_node(&child, source, file_path, language, entities, dependencies);\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436590Z",
      "modified_at": "2025-11-01T15:29:24.436590Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:with_execute_result:______crates_parseltongue-core_src_interfaces_rs:570-573",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "with_execute_result",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 570,
        "end": 573
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        pub fn with_execute_result(mut self, result: Result<ToolOutput>) -> Self {\n            self.execute_result = Some(result);\n            self\n        }",
    "future_code": "        pub fn with_execute_result(mut self, result: Result<ToolOutput>) -> Self {\n            self.execute_result = Some(result);\n            self\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436591Z",
      "modified_at": "2025-11-01T15:29:24.436591Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:with_failure:______crates_parseltongue-core_src_interfaces_rs:575-578",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "with_failure",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 575,
        "end": 578
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "        pub fn with_failure(mut self) -> Self {\n            self.should_fail = true;\n            self\n        }",
    "future_code": "        pub fn with_failure(mut self) -> Self {\n            self.should_fail = true;\n            self\n        }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436592Z",
      "modified_at": "2025-11-01T15:29:24.436592Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:with_message:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:39-42",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "with_message",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 39,
        "end": 42
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn with_message(mut self, message: String) -> Self {\n        self.message = Some(message);\n        self\n    }",
    "future_code": "    pub fn with_message(mut self, message: String) -> Self {\n        self.message = Some(message);\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436593Z",
      "modified_at": "2025-11-01T15:29:24.436593Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:with_timing:______crates_pt04-syntax-preflight-validator_src_types_rs:89-93",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "with_timing",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 89,
        "end": 93
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub fn with_timing(mut self, execution_time_ms: u64, memory_usage_bytes: usize) -> Self {\n        self.execution_time_ms = execution_time_ms;\n        self.memory_usage_bytes = memory_usage_bytes;\n        self\n    }",
    "future_code": "    pub fn with_timing(mut self, execution_time_ms: u64, memory_usage_bytes: usize) -> Self {\n        self.execution_time_ms = execution_time_ms;\n        self.memory_usage_bytes = memory_usage_bytes;\n        self\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436594Z",
      "modified_at": "2025-11-01T15:29:24.436594Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:write_context_file:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:408-432",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "write_context_file",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 408,
        "end": 432
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn write_context_file(&self, response: &ContextOptimizationResponse, output_path: &str) -> Result<()> {\n        // Create output directory if it doesn't exist\n        if let Some(parent) = Path::new(output_path).parent() {\n            tokio::fs::create_dir_all(parent).await.map_err(|e| ContextWriterError::FileError {\n                path: parent.to_string_lossy().to_string(),\n                reason: format!(\"Failed to create directory: {}\", e),\n            })?;\n        }\n\n        let context_json = serde_json::to_string_pretty(response).map_err(|e| {\n            ContextWriterError::SerializationError {\n                data: \"optimized context\".to_string(),\n                reason: format!(\"Failed to serialize context: {}\", e),\n            }\n        })?;\n\n        tokio::fs::write(output_path, context_json).await.map_err(|e| {\n            ContextWriterError::FileError {\n                path: output_path.to_string(),\n                reason: format!(\"Failed to write context file: {}\", e),\n            }\n        })?;\n\n        Ok(())\n    }",
    "future_code": "    async fn write_context_file(&self, response: &ContextOptimizationResponse, output_path: &str) -> Result<()> {\n        // Create output directory if it doesn't exist\n        if let Some(parent) = Path::new(output_path).parent() {\n            tokio::fs::create_dir_all(parent).await.map_err(|e| ContextWriterError::FileError {\n                path: parent.to_string_lossy().to_string(),\n                reason: format!(\"Failed to create directory: {}\", e),\n            })?;\n        }\n\n        let context_json = serde_json::to_string_pretty(response).map_err(|e| {\n            ContextWriterError::SerializationError {\n                data: \"optimized context\".to_string(),\n                reason: format!(\"Failed to serialize context: {}\", e),\n            }\n        })?;\n\n        tokio::fs::write(output_path, context_json).await.map_err(|e| {\n            ContextWriterError::FileError {\n                path: output_path.to_string(),\n                reason: format!(\"Failed to write context file: {}\", e),\n            }\n        })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436596Z",
      "modified_at": "2025-11-01T15:29:24.436596Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:write_context_file_simple:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:202-228",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "write_context_file_simple",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 202,
        "end": 228
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    async fn write_context_file_simple(&self, context: &CodeGraphContext, output_path: &str) -> Result<()> {\n        // Create output directory if needed\n        if let Some(parent) = Path::new(output_path).parent() {\n            tokio::fs::create_dir_all(parent).await.map_err(|e| {\n                ContextWriterError::FileError {\n                    path: parent.to_string_lossy().to_string(),\n                    reason: format!(\"Failed to create directory: {}\", e),\n                }\n            })?;\n        }\n\n        let json = serde_json::to_string_pretty(context).map_err(|e| {\n            ContextWriterError::SerializationError {\n                data: \"CodeGraphContext\".to_string(),\n                reason: format!(\"Failed to serialize: {}\", e),\n            }\n        })?;\n\n        tokio::fs::write(output_path, json).await.map_err(|e| {\n            ContextWriterError::FileError {\n                path: output_path.to_string(),\n                reason: format!(\"Failed to write file: {}\", e),\n            }\n        })?;\n\n        Ok(())\n    }",
    "future_code": "    async fn write_context_file_simple(&self, context: &CodeGraphContext, output_path: &str) -> Result<()> {\n        // Create output directory if needed\n        if let Some(parent) = Path::new(output_path).parent() {\n            tokio::fs::create_dir_all(parent).await.map_err(|e| {\n                ContextWriterError::FileError {\n                    path: parent.to_string_lossy().to_string(),\n                    reason: format!(\"Failed to create directory: {}\", e),\n                }\n            })?;\n        }\n\n        let json = serde_json::to_string_pretty(context).map_err(|e| {\n            ContextWriterError::SerializationError {\n                data: \"CodeGraphContext\".to_string(),\n                reason: format!(\"Failed to serialize: {}\", e),\n            }\n        })?;\n\n        tokio::fs::write(output_path, json).await.map_err(|e| {\n            ContextWriterError::FileError {\n                path: output_path.to_string(),\n                reason: format!(\"Failed to write file: {}\", e),\n            }\n        })?;\n\n        Ok(())\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436597Z",
      "modified_at": "2025-11-01T15:29:24.436597Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:fn:write_entity:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:31-38",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "write_entity",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 31,
        "end": 38
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub async fn write_entity(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        match &entity.temporal_state.future_action {\n            Some(FutureAction::Create) => self.create_file(entity).await,\n            Some(FutureAction::Edit) => self.modify_file(entity).await,\n            Some(FutureAction::Delete) => self.delete_file(entity).await,\n            None => Ok(WriteResult::no_op()),\n        }\n    }",
    "future_code": "    pub async fn write_entity(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        match &entity.temporal_state.future_action {\n            Some(FutureAction::Create) => self.create_file(entity).await,\n            Some(FutureAction::Edit) => self.modify_file(entity).await,\n            Some(FutureAction::Delete) => self.delete_file(entity).await,\n            None => Ok(WriteResult::no_op()),\n        }\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436598Z",
      "modified_at": "2025-11-01T15:29:24.436598Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:AdvancedQueryConfig:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:157-160",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "AdvancedQueryConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 157,
        "end": 160
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct AdvancedQueryConfig {\n    pub query: String,\n    pub db_path: String,\n}",
    "future_code": "pub struct AdvancedQueryConfig {\n    pub query: String,\n    pub db_path: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436599Z",
      "modified_at": "2025-11-01T15:29:24.436599Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Change:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:68-91",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Change",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 68,
        "end": 91
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Change {\n    /// ISGL1 key of the entity\n    pub isgl1_key: String,\n\n    /// File path relative to project root\n    pub file_path: PathBuf,\n\n    /// Operation to perform\n    pub operation: Operation,\n\n    /// Current code content (Some for Edit/Delete, None for Create)\n    /// Enables LLM to know exactly what code to replace\n    pub current_code: Option<String>,\n\n    /// Future code content (Some for Create/Edit, None for Delete)\n    pub future_code: Option<String>,\n\n    /// Line range for entity-level operations (extracted from ISGL1 key)\n    /// None for hash-based keys (Create operations)\n    pub line_range: Option<LineRange>,\n\n    /// Interface signature for reference\n    pub interface_signature: String,\n}",
    "future_code": "pub struct Change {\n    /// ISGL1 key of the entity\n    pub isgl1_key: String,\n\n    /// File path relative to project root\n    pub file_path: PathBuf,\n\n    /// Operation to perform\n    pub operation: Operation,\n\n    /// Current code content (Some for Edit/Delete, None for Create)\n    /// Enables LLM to know exactly what code to replace\n    pub current_code: Option<String>,\n\n    /// Future code content (Some for Create/Edit, None for Delete)\n    pub future_code: Option<String>,\n\n    /// Line range for entity-level operations (extracted from ISGL1 key)\n    /// None for hash-based keys (Create operations)\n    pub line_range: Option<LineRange>,\n\n    /// Interface signature for reference\n    pub interface_signature: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436600Z",
      "modified_at": "2025-11-01T15:29:24.436600Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Cli:______crates_pt04-syntax-preflight-validator_src_cli_rs:7-27",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Cli",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/cli.rs",
      "line_range": {
        "start": 7,
        "end": 27
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Cli {\n    /// Code snippet to validate (alternative to --file)\n    #[arg(long, conflicts_with = \"file\")]\n    pub code_snippet: Option<String>,\n\n    /// File containing code to validate (alternative to --code-snippet)\n    #[arg(long, conflicts_with = \"code_snippet\")]\n    pub file: Option<PathBuf>,\n\n    /// Type of validation to perform\n    #[arg(long, default_value = \"all\")]\n    pub validation_type: ValidationTypeArg,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Output format (json or text)\n    #[arg(long, default_value = \"text\")]\n    pub output_format: OutputFormat,\n}",
    "future_code": "pub struct Cli {\n    /// Code snippet to validate (alternative to --file)\n    #[arg(long, conflicts_with = \"file\")]\n    pub code_snippet: Option<String>,\n\n    /// File containing code to validate (alternative to --code-snippet)\n    #[arg(long, conflicts_with = \"code_snippet\")]\n    pub file: Option<PathBuf>,\n\n    /// Type of validation to perform\n    #[arg(long, default_value = \"all\")]\n    pub validation_type: ValidationTypeArg,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Output format (json or text)\n    #[arg(long, default_value = \"text\")]\n    pub output_format: OutputFormat,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436601Z",
      "modified_at": "2025-11-01T15:29:24.436601Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Cli:______crates_pt04-syntax-preflight-validator_src_main_rs:14-22",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Cli",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/main.rs",
      "line_range": {
        "start": 14,
        "end": 22
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"mem\")]\n    database: String,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
    "future_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"mem\")]\n    database: String,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436602Z",
      "modified_at": "2025-11-01T15:29:24.436602Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Cli:______crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:7-23",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Cli",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "line_range": {
        "start": 7,
        "end": 23
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Cli {\n    /// Path to CozoDB database\n    #[arg(long)]\n    pub database: PathBuf,\n\n    /// Root directory for file operations\n    #[arg(long)]\n    pub root: PathBuf,\n\n    /// Dry-run mode (show what would be written without actually writing)\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n}",
    "future_code": "pub struct Cli {\n    /// Path to CozoDB database\n    #[arg(long)]\n    pub database: PathBuf,\n\n    /// Root directory for file operations\n    #[arg(long)]\n    pub root: PathBuf,\n\n    /// Dry-run mode (show what would be written without actually writing)\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436603Z",
      "modified_at": "2025-11-01T15:29:24.436603Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Cli:______crates_pt05-llm-cozodb-to-diff-writer_src_main_rs:16-28",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Cli",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/main.rs",
      "line_range": {
        "start": 16,
        "end": 28
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"./parseltongue.db\")]\n    database: String,\n\n    /// Output path for CodeDiff.json\n    #[arg(long, default_value = \"./CodeDiff.json\")]\n    output: PathBuf,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
    "future_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"./parseltongue.db\")]\n    database: String,\n\n    /// Output path for CodeDiff.json\n    #[arg(long, default_value = \"./CodeDiff.json\")]\n    output: PathBuf,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436604Z",
      "modified_at": "2025-11-01T15:29:24.436604Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Cli:______crates_pt06-cozodb-make-future-code-current_src_cli_rs:7-23",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Cli",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/cli.rs",
      "line_range": {
        "start": 7,
        "end": 23
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Cli {\n    /// CozoDB connection string (e.g., \"rocksdb:parseltongue.db\" or \"sqlite:db.sqlite\")\n    #[arg(long)]\n    pub database: String,\n\n    /// Project root directory for re-indexing\n    #[arg(long)]\n    pub project_path: PathBuf,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Automatically re-index after reset (PRD-compliant)\n    #[arg(long, default_value_t = true)]\n    pub reindex: bool,\n}",
    "future_code": "pub struct Cli {\n    /// CozoDB connection string (e.g., \"rocksdb:parseltongue.db\" or \"sqlite:db.sqlite\")\n    #[arg(long)]\n    pub database: String,\n\n    /// Project root directory for re-indexing\n    #[arg(long)]\n    pub project_path: PathBuf,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Automatically re-index after reset (PRD-compliant)\n    #[arg(long, default_value_t = true)]\n    pub reindex: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436606Z",
      "modified_at": "2025-11-01T15:29:24.436606Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CliConfig:______crates_pt01-folder-to-cozodb-streamer_src_cli_rs:28-28",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CliConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "line_range": {
        "start": 28,
        "end": 28
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CliConfig;",
    "future_code": "pub struct CliConfig;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436607Z",
      "modified_at": "2025-11-01T15:29:24.436607Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CliConfig:______crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:8-8",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CliConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "line_range": {
        "start": 8,
        "end": 8
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CliConfig;",
    "future_code": "pub struct CliConfig;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436608Z",
      "modified_at": "2025-11-01T15:29:24.436608Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CliConfig:______crates_pt03-llm-to-cozodb-writer_src_cli_rs:52-52",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CliConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "line_range": {
        "start": 52,
        "end": 52
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CliConfig;",
    "future_code": "pub struct CliConfig;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436609Z",
      "modified_at": "2025-11-01T15:29:24.436609Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeChange:______crates_parseltongue-core_src_interfaces_rs:483-490",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeChange",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 483,
        "end": 490
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CodeChange {\n    pub file_path: PathBuf,\n    pub entity_name: String,\n    pub change_type: TemporalAction,\n    pub old_content: Option<String>,\n    pub new_content: String,\n    pub line_range: LineRange,\n}",
    "future_code": "pub struct CodeChange {\n    pub file_path: PathBuf,\n    pub entity_name: String,\n    pub change_type: TemporalAction,\n    pub old_content: Option<String>,\n    pub new_content: String,\n    pub line_range: LineRange,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436610Z",
      "modified_at": "2025-11-01T15:29:24.436610Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeDiff:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:58-64",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeDiff",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 58,
        "end": 64
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CodeDiff {\n    /// List of changes to apply\n    pub changes: Vec<Change>,\n\n    /// Metadata about the diff generation\n    pub metadata: DiffMetadata,\n}",
    "future_code": "pub struct CodeDiff {\n    /// List of changes to apply\n    pub changes: Vec<Change>,\n\n    /// Metadata about the diff generation\n    pub metadata: DiffMetadata,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436611Z",
      "modified_at": "2025-11-01T15:29:24.436611Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeEntity:______crates_parseltongue-core_src_entities_rs:450-474",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeEntity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 450,
        "end": 474
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CodeEntity {\n    /// Unique ISGL1 key\n    pub isgl1_key: String,\n\n    /// Temporal state\n    pub temporal_state: TemporalState,\n\n    /// Interface signature\n    pub interface_signature: InterfaceSignature,\n\n    /// Current code content\n    pub current_code: Option<String>,\n\n    /// Future code content\n    pub future_code: Option<String>,\n\n    /// TDD classification\n    pub tdd_classification: TddClassification,\n\n    /// LSP metadata (Rust-enhanced)\n    pub lsp_metadata: Option<LspMetadata>,\n\n    /// Entity metadata\n    pub metadata: EntityMetadata,\n}",
    "future_code": "pub struct CodeEntity {\n    /// Unique ISGL1 key\n    pub isgl1_key: String,\n\n    /// Temporal state\n    pub temporal_state: TemporalState,\n\n    /// Interface signature\n    pub interface_signature: InterfaceSignature,\n\n    /// Current code content\n    pub current_code: Option<String>,\n\n    /// Future code content\n    pub future_code: Option<String>,\n\n    /// TDD classification\n    pub tdd_classification: TddClassification,\n\n    /// LSP metadata (Rust-enhanced)\n    pub lsp_metadata: Option<LspMetadata>,\n\n    /// Entity metadata\n    pub metadata: EntityMetadata,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436612Z",
      "modified_at": "2025-11-01T15:29:24.436612Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeGraphContext:______crates_parseltongue-core_src_interfaces_rs:416-423",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeGraphContext",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 416,
        "end": 423
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CodeGraphContext {\n    pub version: String,\n    pub generated_at: chrono::DateTime<chrono::Utc>,\n    pub token_count: usize,\n    pub entities: Vec<ContextEntity>,\n    pub relationships: Vec<ContextRelationship>,\n    pub optimization_info: OptimizationInfo,\n}",
    "future_code": "pub struct CodeGraphContext {\n    pub version: String,\n    pub generated_at: chrono::DateTime<chrono::Utc>,\n    pub token_count: usize,\n    pub entities: Vec<ContextEntity>,\n    pub relationships: Vec<ContextRelationship>,\n    pub optimization_info: OptimizationInfo,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436614Z",
      "modified_at": "2025-11-01T15:29:24.436614Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeGraphContext:______crates_parseltongue-core_tests_tool3_prd_compliance_rs:22-31",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeGraphContext",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "line_range": {
        "start": 22,
        "end": 31
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct CodeGraphContext {\n    /// Entities from CozoDB (current_ind=1 only)\n    entities: Vec<ContextEntity>,\n    /// Count of entities\n    entity_count: usize,\n    /// Estimated token count\n    token_count: usize,\n    /// Generation timestamp\n    generated_at: String,\n}",
    "future_code": "struct CodeGraphContext {\n    /// Entities from CozoDB (current_ind=1 only)\n    entities: Vec<ContextEntity>,\n    /// Count of entities\n    entity_count: usize,\n    /// Estimated token count\n    token_count: usize,\n    /// Generation timestamp\n    generated_at: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436615Z",
      "modified_at": "2025-11-01T15:29:24.436615Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CodeGraphContext:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:108-117",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CodeGraphContext",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 108,
        "end": 117
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CodeGraphContext {\n    /// Minimal entities (ONLY: ISGL1, interface, TDD, LSP - NO code fields)\n    pub entities: Vec<MinimalEntity>,\n    /// Total number of entities\n    pub entity_count: usize,\n    /// Estimated token count\n    pub token_count: usize,\n    /// Generation timestamp\n    pub generated_at: String,\n}",
    "future_code": "pub struct CodeGraphContext {\n    /// Minimal entities (ONLY: ISGL1, interface, TDD, LSP - NO code fields)\n    pub entities: Vec<MinimalEntity>,\n    /// Total number of entities\n    pub entity_count: usize,\n    /// Estimated token count\n    pub token_count: usize,\n    /// Generation timestamp\n    pub generated_at: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436616Z",
      "modified_at": "2025-11-01T15:29:24.436616Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ConflictResolver:______crates_parseltongue-core_src_temporal_rs:462-464",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ConflictResolver",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 462,
        "end": 464
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ConflictResolver {\n    strategy: ConflictResolutionStrategy,\n}",
    "future_code": "pub struct ConflictResolver {\n    strategy: ConflictResolutionStrategy,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436618Z",
      "modified_at": "2025-11-01T15:29:24.436618Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ConsistentStateRule:______crates_parseltongue-core_src_temporal_rs:306-308",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ConsistentStateRule",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 306,
        "end": 308
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ConsistentStateRule {\n    _private: (),\n}",
    "future_code": "pub struct ConsistentStateRule {\n    _private: (),\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436619Z",
      "modified_at": "2025-11-01T15:29:24.436619Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextChoice:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:168-172",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextChoice",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 168,
        "end": 172
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextChoice {\n    index: usize,\n    message: ContextLlmMessage,\n    finish_reason: String,\n}",
    "future_code": "struct ContextChoice {\n    index: usize,\n    message: ContextLlmMessage,\n    finish_reason: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436620Z",
      "modified_at": "2025-11-01T15:29:24.436620Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextEntity:______crates_parseltongue-core_src_interfaces_rs:427-434",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextEntity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 427,
        "end": 434
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextEntity {\n    pub isgl1_key: String,\n    pub interface_signature: InterfaceSignature,\n    pub tdd_classification: TddClassification,\n    pub lsp_metadata: Option<LspMetadata>,\n    pub relevance_score: f64,\n    pub dependency_level: u32,\n}",
    "future_code": "pub struct ContextEntity {\n    pub isgl1_key: String,\n    pub interface_signature: InterfaceSignature,\n    pub tdd_classification: TddClassification,\n    pub lsp_metadata: Option<LspMetadata>,\n    pub relevance_score: f64,\n    pub dependency_level: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436621Z",
      "modified_at": "2025-11-01T15:29:24.436621Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextEntity:______crates_parseltongue-core_tests_end_to_end_workflow_rs:26-31",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextEntity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "line_range": {
        "start": 26,
        "end": 31
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value,\n    entity_class: String, // \"Test\" or \"CodeImplementation\"\n    lsp_metadata: Option<serde_json::Value>,\n}",
    "future_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value,\n    entity_class: String, // \"Test\" or \"CodeImplementation\"\n    lsp_metadata: Option<serde_json::Value>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436622Z",
      "modified_at": "2025-11-01T15:29:24.436622Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextEntity:______crates_parseltongue-core_tests_tool3_prd_compliance_rs:38-45",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextEntity",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "line_range": {
        "start": 38,
        "end": 45
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value, // Serialized InterfaceSignature\n    entity_class: String,  // Simplified TDD Classification: \"Test\" or \"Code\"\n    lsp_metadata: Option<serde_json::Value>, // Serialized LspMetadata\n    // temporal_state removed - not in PRD requirements (P01:128)\n    // Full tdd_classification removed - only entity_class needed for Test vs Code distinction\n}",
    "future_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value, // Serialized InterfaceSignature\n    entity_class: String,  // Simplified TDD Classification: \"Test\" or \"Code\"\n    lsp_metadata: Option<serde_json::Value>, // Serialized LspMetadata\n    // temporal_state removed - not in PRD requirements (P01:128)\n    // Full tdd_classification removed - only entity_class needed for Test vs Code distinction\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436623Z",
      "modified_at": "2025-11-01T15:29:24.436623Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextGraph:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:54-60",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextGraph",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 54,
        "end": 60
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextGraph {\n    pub entities: Vec<CodeEntity>,\n    pub relationships: Vec<EntityRelationship>,\n    pub centrality_scores: HashMap<String, f32>,\n    pub connectivity_clusters: Vec<Vec<String>>,\n    pub metadata: GraphMetadata,\n}",
    "future_code": "pub struct ContextGraph {\n    pub entities: Vec<CodeEntity>,\n    pub relationships: Vec<EntityRelationship>,\n    pub centrality_scores: HashMap<String, f32>,\n    pub connectivity_clusters: Vec<Vec<String>>,\n    pub metadata: GraphMetadata,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436624Z",
      "modified_at": "2025-11-01T15:29:24.436624Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmCapabilities:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:122-129",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmCapabilities",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 122,
        "end": 129
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextLlmCapabilities {\n    pub max_input_tokens: usize,\n    pub max_output_tokens: usize,\n    pub supported_models: Vec<String>,\n    pub rate_limit_rpm: u32,\n    pub supports_context_optimization: bool,\n    pub supports_relationship_analysis: bool,\n}",
    "future_code": "pub struct ContextLlmCapabilities {\n    pub max_input_tokens: usize,\n    pub max_output_tokens: usize,\n    pub supported_models: Vec<String>,\n    pub rate_limit_rpm: u32,\n    pub supports_context_optimization: bool,\n    pub supports_relationship_analysis: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436625Z",
      "modified_at": "2025-11-01T15:29:24.436625Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmClientFactory:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:388-388",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmClientFactory",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 388,
        "end": 388
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextLlmClientFactory;",
    "future_code": "pub struct ContextLlmClientFactory;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436626Z",
      "modified_at": "2025-11-01T15:29:24.436626Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmClientImpl:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:182-186",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmClientImpl",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 182,
        "end": 186
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextLlmClientImpl {\n    config: crate::ContextWriterConfig,\n    http_client: reqwest::Client,\n    capabilities: ContextLlmCapabilities,\n}",
    "future_code": "pub struct ContextLlmClientImpl {\n    config: crate::ContextWriterConfig,\n    http_client: reqwest::Client,\n    capabilities: ContextLlmCapabilities,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436627Z",
      "modified_at": "2025-11-01T15:29:24.436627Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmMessage:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:144-147",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmMessage",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 144,
        "end": 147
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextLlmMessage {\n    role: MessageRole,\n    content: String,\n}",
    "future_code": "struct ContextLlmMessage {\n    role: MessageRole,\n    content: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436628Z",
      "modified_at": "2025-11-01T15:29:24.436628Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmRequest:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:133-140",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmRequest",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 133,
        "end": 140
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextLlmRequest {\n    model: String,\n    messages: Vec<ContextLlmMessage>,\n    max_tokens: Option<usize>,\n    temperature: f32,\n    stream: bool,\n    user: Option<String>,\n}",
    "future_code": "struct ContextLlmRequest {\n    model: String,\n    messages: Vec<ContextLlmMessage>,\n    max_tokens: Option<usize>,\n    temperature: f32,\n    stream: bool,\n    user: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436629Z",
      "modified_at": "2025-11-01T15:29:24.436629Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextLlmResponse:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:158-165",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextLlmResponse",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 158,
        "end": 165
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextLlmResponse {\n    id: String,\n    object: String,\n    created: u64,\n    model: String,\n    choices: Vec<ContextChoice>,\n    usage: ContextUsage,\n}",
    "future_code": "struct ContextLlmResponse {\n    id: String,\n    object: String,\n    created: u64,\n    model: String,\n    choices: Vec<ContextChoice>,\n    usage: ContextUsage,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436630Z",
      "modified_at": "2025-11-01T15:29:24.436630Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextMetadata:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:97-105",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextMetadata",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 97,
        "end": 105
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextMetadata {\n    pub context_id: String,\n    pub generated_at: String,\n    pub model_used: String,\n    pub optimization_applied: bool,\n    pub token_count: usize,\n    pub entity_count: usize,\n    pub relationship_count: usize,\n}",
    "future_code": "pub struct ContextMetadata {\n    pub context_id: String,\n    pub generated_at: String,\n    pub model_used: String,\n    pub optimization_applied: bool,\n    pub token_count: usize,\n    pub entity_count: usize,\n    pub relationship_count: usize,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436631Z",
      "modified_at": "2025-11-01T15:29:24.436631Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextOptimizationRequest:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:13-19",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextOptimizationRequest",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 13,
        "end": 19
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextOptimizationRequest {\n    pub entities: Vec<CodeEntity>,\n    pub relationships: Vec<EntityRelationship>,\n    pub target_context_size: usize,\n    pub focus_areas: Vec<String>,\n    pub optimization_goals: Vec<OptimizationGoal>,\n}",
    "future_code": "pub struct ContextOptimizationRequest {\n    pub entities: Vec<CodeEntity>,\n    pub relationships: Vec<EntityRelationship>,\n    pub target_context_size: usize,\n    pub focus_areas: Vec<String>,\n    pub optimization_goals: Vec<OptimizationGoal>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436632Z",
      "modified_at": "2025-11-01T15:29:24.436632Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextOptimizationResponse:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:57-62",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextOptimizationResponse",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 57,
        "end": 62
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextOptimizationResponse {\n    pub optimized_entities: Vec<OptimizedEntity>,\n    pub pruning_summary: PruningSummary,\n    pub context_metadata: ContextMetadata,\n    pub confidence_score: f32,\n}",
    "future_code": "pub struct ContextOptimizationResponse {\n    pub optimized_entities: Vec<OptimizedEntity>,\n    pub pruning_summary: PruningSummary,\n    pub context_metadata: ContextMetadata,\n    pub confidence_score: f32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436633Z",
      "modified_at": "2025-11-01T15:29:24.436633Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextOptimizerFactory:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:518-518",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextOptimizerFactory",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 518,
        "end": 518
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextOptimizerFactory;",
    "future_code": "pub struct ContextOptimizerFactory;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436634Z",
      "modified_at": "2025-11-01T15:29:24.436634Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextOptimizerImpl:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:74-79",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextOptimizerImpl",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 74,
        "end": 79
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextOptimizerImpl {\n    storage: Arc<CozoDbStorage>,\n    config: crate::ContextWriterConfig,\n    llm_client: Arc<ContextLlmClientImpl>,\n    stats: std::sync::Mutex<ContextOptimizerStats>,\n}",
    "future_code": "pub struct ContextOptimizerImpl {\n    storage: Arc<CozoDbStorage>,\n    config: crate::ContextWriterConfig,\n    llm_client: Arc<ContextLlmClientImpl>,\n    stats: std::sync::Mutex<ContextOptimizerStats>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436635Z",
      "modified_at": "2025-11-01T15:29:24.436635Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextOptimizerStats:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:43-50",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextOptimizerStats",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 43,
        "end": 50
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextOptimizerStats {\n    pub contexts_generated: usize,\n    pub entities_processed: usize,\n    pub tokens_generated: usize,\n    pub optimization_savings: usize,\n    pub llm_requests_made: usize,\n    pub total_generation_time: Duration,\n}",
    "future_code": "pub struct ContextOptimizerStats {\n    pub contexts_generated: usize,\n    pub entities_processed: usize,\n    pub tokens_generated: usize,\n    pub optimization_savings: usize,\n    pub llm_requests_made: usize,\n    pub total_generation_time: Duration,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436636Z",
      "modified_at": "2025-11-01T15:29:24.436636Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextQuery:______crates_parseltongue-core_src_interfaces_rs:388-394",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextQuery",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 388,
        "end": 394
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextQuery {\n    pub base_entities: Vec<String>,\n    pub hop_depth: u32,\n    pub change_type: ChangeType,\n    pub size_limit: usize,\n    pub optimization_strategy: OptimizationStrategy,\n}",
    "future_code": "pub struct ContextQuery {\n    pub base_entities: Vec<String>,\n    pub hop_depth: u32,\n    pub change_type: ChangeType,\n    pub size_limit: usize,\n    pub optimization_strategy: OptimizationStrategy,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436637Z",
      "modified_at": "2025-11-01T15:29:24.436637Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextRelationship:______crates_parseltongue-core_src_interfaces_rs:438-443",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextRelationship",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 438,
        "end": 443
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextRelationship {\n    pub dependent: String,\n    pub dependency: String,\n    pub relationship_type: String,\n    pub strength: f64,\n}",
    "future_code": "pub struct ContextRelationship {\n    pub dependent: String,\n    pub dependency: String,\n    pub relationship_type: String,\n    pub strength: f64,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436638Z",
      "modified_at": "2025-11-01T15:29:24.436638Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextResult:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:30-39",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextResult",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 30,
        "end": 39
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextResult {\n    pub context_id: String,\n    pub output_path: String,\n    pub entities_processed: usize,\n    pub entities_optimized: usize,\n    pub tokens_generated: usize,\n    pub optimization_ratio: f32,\n    pub generation_time: Duration,\n    pub errors: Vec<String>,\n}",
    "future_code": "pub struct ContextResult {\n    pub context_id: String,\n    pub output_path: String,\n    pub entities_processed: usize,\n    pub entities_optimized: usize,\n    pub tokens_generated: usize,\n    pub optimization_ratio: f32,\n    pub generation_time: Duration,\n    pub errors: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436639Z",
      "modified_at": "2025-11-01T15:29:24.436639Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextUsage:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:175-179",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextUsage",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 175,
        "end": 179
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ContextUsage {\n    prompt_tokens: usize,\n    completion_tokens: usize,\n    total_tokens: usize,\n}",
    "future_code": "struct ContextUsage {\n    prompt_tokens: usize,\n    completion_tokens: usize,\n    total_tokens: usize,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436640Z",
      "modified_at": "2025-11-01T15:29:24.436640Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ContextWriterConfig:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:27-48",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ContextWriterConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 27,
        "end": 48
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ContextWriterConfig {\n    /// Database connection string\n    pub db_path: String,\n    /// LLM API endpoint\n    pub llm_endpoint: String,\n    /// LLM API key\n    pub llm_api_key: String,\n    /// Model to use for LLM\n    pub model: String,\n    /// Maximum tokens per request\n    pub max_tokens: usize,\n    /// Temperature for LLM generation\n    pub temperature: f32,\n    /// Query to select entity graph for context generation\n    pub entity_query: String,\n    /// Maximum context size in tokens\n    pub max_context_tokens: usize,\n    /// Relevance threshold for entity inclusion\n    pub relevance_threshold: f32,\n    /// Output directory for context files\n    pub output_dir: String,\n}",
    "future_code": "pub struct ContextWriterConfig {\n    /// Database connection string\n    pub db_path: String,\n    /// LLM API endpoint\n    pub llm_endpoint: String,\n    /// LLM API key\n    pub llm_api_key: String,\n    /// Model to use for LLM\n    pub model: String,\n    /// Maximum tokens per request\n    pub max_tokens: usize,\n    /// Temperature for LLM generation\n    pub temperature: f32,\n    /// Query to select entity graph for context generation\n    pub entity_query: String,\n    /// Maximum context size in tokens\n    pub max_context_tokens: usize,\n    /// Relevance threshold for entity inclusion\n    pub relevance_threshold: f32,\n    /// Output directory for context files\n    pub output_dir: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436641Z",
      "modified_at": "2025-11-01T15:29:24.436641Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:CozoDbStorage:______crates_parseltongue-core_src_storage_cozo_client_rs:19-21",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "CozoDbStorage",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/storage/cozo_client.rs",
      "line_range": {
        "start": 19,
        "end": 21
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct CozoDbStorage {\n    db: DbInstance,\n}",
    "future_code": "pub struct CozoDbStorage {\n    db: DbInstance,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436643Z",
      "modified_at": "2025-11-01T15:29:24.436643Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:DefaultRustValidator:______crates_pt04-syntax-preflight-validator_src_validator_rs:76-76",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "DefaultRustValidator",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/validator.rs",
      "line_range": {
        "start": 76,
        "end": 76
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct DefaultRustValidator;",
    "future_code": "pub struct DefaultRustValidator;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436644Z",
      "modified_at": "2025-11-01T15:29:24.436644Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:DependencyEdge:______crates_parseltongue-core_src_entities_rs:991-1000",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "DependencyEdge",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 991,
        "end": 1000
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct DependencyEdge {\n    /// Source entity ISGL1 key\n    pub from_key: Isgl1Key,\n    /// Target entity ISGL1 key\n    pub to_key: Isgl1Key,\n    /// Type of dependency relationship\n    pub edge_type: EdgeType,\n    /// Source code location where relationship occurs (optional)\n    pub source_location: Option<String>,\n}",
    "future_code": "pub struct DependencyEdge {\n    /// Source entity ISGL1 key\n    pub from_key: Isgl1Key,\n    /// Target entity ISGL1 key\n    pub to_key: Isgl1Key,\n    /// Type of dependency relationship\n    pub edge_type: EdgeType,\n    /// Source code location where relationship occurs (optional)\n    pub source_location: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436644Z",
      "modified_at": "2025-11-01T15:29:24.436645Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:DependencyEdgeBuilder:______crates_parseltongue-core_src_entities_rs:1026-1031",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "DependencyEdgeBuilder",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 1026,
        "end": 1031
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct DependencyEdgeBuilder {\n    from_key: Option<String>,\n    to_key: Option<String>,\n    edge_type: Option<EdgeType>,\n    source_location: Option<String>,\n}",
    "future_code": "pub struct DependencyEdgeBuilder {\n    from_key: Option<String>,\n    to_key: Option<String>,\n    edge_type: Option<EdgeType>,\n    source_location: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436645Z",
      "modified_at": "2025-11-01T15:29:24.436645Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:DiffGenerator:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:49-51",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "DiffGenerator",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "line_range": {
        "start": 49,
        "end": 51
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct DiffGenerator {\n    storage: Arc<CozoDbStorage>,\n}",
    "future_code": "pub struct DiffGenerator {\n    storage: Arc<CozoDbStorage>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436646Z",
      "modified_at": "2025-11-01T15:29:24.436646Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:DiffMetadata:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:116-127",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "DiffMetadata",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 116,
        "end": 127
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct DiffMetadata {\n    /// Number of changes\n    pub total_changes: usize,\n\n    /// Breakdown by operation\n    pub create_count: usize,\n    pub edit_count: usize,\n    pub delete_count: usize,\n\n    /// Generation timestamp (ISO 8601)\n    pub generated_at: String,\n}",
    "future_code": "pub struct DiffMetadata {\n    /// Number of changes\n    pub total_changes: usize,\n\n    /// Breakdown by operation\n    pub create_count: usize,\n    pub edit_count: usize,\n    pub delete_count: usize,\n\n    /// Generation timestamp (ISO 8601)\n    pub generated_at: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436647Z",
      "modified_at": "2025-11-01T15:29:24.436647Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:EntityMetadata:______crates_parseltongue-core_src_entities_rs:591-600",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "EntityMetadata",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 591,
        "end": 600
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct EntityMetadata {\n    /// Creation timestamp\n    pub created_at: chrono::DateTime<chrono::Utc>,\n    /// Last modification timestamp\n    pub modified_at: chrono::DateTime<chrono::Utc>,\n    /// Hash of entity content\n    pub content_hash: String,\n    /// Additional key-value metadata\n    pub additional: HashMap<String, String>,\n}",
    "future_code": "pub struct EntityMetadata {\n    /// Creation timestamp\n    pub created_at: chrono::DateTime<chrono::Utc>,\n    /// Last modification timestamp\n    pub modified_at: chrono::DateTime<chrono::Utc>,\n    /// Hash of entity content\n    pub content_hash: String,\n    /// Additional key-value metadata\n    pub additional: HashMap<String, String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436648Z",
      "modified_at": "2025-11-01T15:29:24.436648Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:EntityRelationship:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:23-29",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "EntityRelationship",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 23,
        "end": 29
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct EntityRelationship {\n    pub source_id: String,\n    pub target_id: String,\n    pub relationship_type: RelationshipType,\n    pub strength: f32,\n    pub context: Option<String>,\n}",
    "future_code": "pub struct EntityRelationship {\n    pub source_id: String,\n    pub target_id: String,\n    pub relationship_type: RelationshipType,\n    pub strength: f32,\n    pub context: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436650Z",
      "modified_at": "2025-11-01T15:29:24.436650Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ErrorContext:______crates_pt02-llm-cozodb-to-context-writer_src_errors_rs:88-94",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ErrorContext",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/errors.rs",
      "line_range": {
        "start": 88,
        "end": 94
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ErrorContext {\n    pub operation: String,\n    pub entity_id: Option<String>,\n    pub attempt_count: u32,\n    pub timestamp: std::time::SystemTime,\n    pub additional_info: HashMap<String, String>,\n}",
    "future_code": "pub struct ErrorContext {\n    pub operation: String,\n    pub entity_id: Option<String>,\n    pub attempt_count: u32,\n    pub timestamp: std::time::SystemTime,\n    pub additional_info: HashMap<String, String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436651Z",
      "modified_at": "2025-11-01T15:29:24.436651Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:FileResult:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:47-52",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "FileResult",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 47,
        "end": 52
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct FileResult {\n    pub file_path: String,\n    pub entities_created: usize,\n    pub success: bool,\n    pub error: Option<String>,\n}",
    "future_code": "pub struct FileResult {\n    pub file_path: String,\n    pub entities_created: usize,\n    pub success: bool,\n    pub error: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436652Z",
      "modified_at": "2025-11-01T15:29:24.436652Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:FileStreamerImpl:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:63-69",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "FileStreamerImpl",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 63,
        "end": 69
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct FileStreamerImpl {\n    config: StreamerConfig,\n    key_generator: Arc<dyn Isgl1KeyGenerator>,\n    lsp_client: Arc<dyn RustAnalyzerClient>,\n    db: Arc<CozoDbStorage>,\n    stats: std::sync::Mutex<StreamStats>,\n}",
    "future_code": "pub struct FileStreamerImpl {\n    config: StreamerConfig,\n    key_generator: Arc<dyn Isgl1KeyGenerator>,\n    lsp_client: Arc<dyn RustAnalyzerClient>,\n    db: Arc<CozoDbStorage>,\n    stats: std::sync::Mutex<StreamStats>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436653Z",
      "modified_at": "2025-11-01T15:29:24.436653Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:FileWriter:______crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:14-17",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "FileWriter",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "line_range": {
        "start": 14,
        "end": 17
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct FileWriter {\n    /// Root directory for file operations\n    root_path: PathBuf,\n}",
    "future_code": "pub struct FileWriter {\n    /// Root directory for file operations\n    root_path: PathBuf,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436654Z",
      "modified_at": "2025-11-01T15:29:24.436654Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:GraphMetadata:______crates_pt02-llm-cozodb-to-context-writer_src_context_optimizer_rs:64-71",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "GraphMetadata",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/context_optimizer.rs",
      "line_range": {
        "start": 64,
        "end": 71
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct GraphMetadata {\n    pub total_entities: usize,\n    pub total_relationships: usize,\n    pub graph_density: f32,\n    pub average_degree: f32,\n    pub max_centrality: f32,\n    pub analysis_timestamp: std::time::SystemTime,\n}",
    "future_code": "pub struct GraphMetadata {\n    pub total_entities: usize,\n    pub total_relationships: usize,\n    pub graph_density: f32,\n    pub average_degree: f32,\n    pub max_centrality: f32,\n    pub analysis_timestamp: std::time::SystemTime,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436655Z",
      "modified_at": "2025-11-01T15:29:24.436655Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:HoverParams:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:29-34",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "HoverParams",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 29,
        "end": 34
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct HoverParams {\n    /// The document to query\n    pub text_document: TextDocumentIdentifier,\n    /// Position within the document\n    pub position: Position,\n}",
    "future_code": "pub struct HoverParams {\n    /// The document to query\n    pub text_document: TextDocumentIdentifier,\n    /// Position within the document\n    pub position: Position,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436656Z",
      "modified_at": "2025-11-01T15:29:24.436656Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:HoverResponse:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:38-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "HoverResponse",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 38,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct HoverResponse {\n    /// Markdown content from hover\n    pub contents: String,\n    /// Raw JSON metadata for storage\n    pub raw_metadata: serde_json::Value,\n}",
    "future_code": "pub struct HoverResponse {\n    /// Markdown content from hover\n    pub contents: String,\n    /// Raw JSON metadata for storage\n    pub raw_metadata: serde_json::Value,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436657Z",
      "modified_at": "2025-11-01T15:29:24.436657Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:InterfaceChunk:______crates_parseltongue-core_src_interfaces_rs:201-214",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "InterfaceChunk",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 201,
        "end": 214
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct InterfaceChunk {\n    /// ISGL1 key\n    pub isgl1_key: String,\n    /// Entity type\n    pub entity_type: EntityType,\n    /// Entity name\n    pub name: String,\n    /// Interface signature\n    pub signature: InterfaceSignature,\n    /// Source code\n    pub source_code: String,\n    /// Dependencies\n    pub dependencies: Vec<String>,\n}",
    "future_code": "pub struct InterfaceChunk {\n    /// ISGL1 key\n    pub isgl1_key: String,\n    /// Entity type\n    pub entity_type: EntityType,\n    /// Entity name\n    pub name: String,\n    /// Interface signature\n    pub signature: InterfaceSignature,\n    /// Source code\n    pub source_code: String,\n    /// Dependencies\n    pub dependencies: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436658Z",
      "modified_at": "2025-11-01T15:29:24.436658Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:InterfaceSignature:______crates_parseltongue-core_src_entities_rs:242-259",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "InterfaceSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 242,
        "end": 259
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct InterfaceSignature {\n    /// Type of entity\n    pub entity_type: EntityType,\n    /// Name of the entity\n    pub name: String,\n    /// Visibility level\n    pub visibility: Visibility,\n    /// File path containing this entity\n    pub file_path: PathBuf,\n    /// Line range where entity is defined\n    pub line_range: LineRange,\n    /// Module path for this entity\n    pub module_path: Vec<String>,\n    /// Documentation comment if available\n    pub documentation: Option<String>,\n    /// Language-specific signature data\n    pub language_specific: LanguageSpecificSignature,\n}",
    "future_code": "pub struct InterfaceSignature {\n    /// Type of entity\n    pub entity_type: EntityType,\n    /// Name of the entity\n    pub name: String,\n    /// Visibility level\n    pub visibility: Visibility,\n    /// File path containing this entity\n    pub file_path: PathBuf,\n    /// Line range where entity is defined\n    pub line_range: LineRange,\n    /// Module path for this entity\n    pub module_path: Vec<String>,\n    /// Documentation comment if available\n    pub documentation: Option<String>,\n    /// Language-specific signature data\n    pub language_specific: LanguageSpecificSignature,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436659Z",
      "modified_at": "2025-11-01T15:29:24.436659Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Isgl1Key:______crates_parseltongue-core_src_entities_rs:853-853",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Isgl1Key",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 853,
        "end": 853
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Isgl1Key(String);",
    "future_code": "pub struct Isgl1Key(String);",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436660Z",
      "modified_at": "2025-11-01T15:29:24.436660Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Isgl1KeyGeneratorFactory:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:429-429",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Isgl1KeyGeneratorFactory",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 429,
        "end": 429
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Isgl1KeyGeneratorFactory;",
    "future_code": "pub struct Isgl1KeyGeneratorFactory;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436661Z",
      "modified_at": "2025-11-01T15:29:24.436661Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Isgl1KeyGeneratorImpl:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:52-56",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Isgl1KeyGeneratorImpl",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 52,
        "end": 56
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Isgl1KeyGeneratorImpl {\n    rust_language: TreeSitterLanguage,\n    python_language: Option<TreeSitterLanguage>,\n    parsers: HashMap<Language, Arc<Mutex<Parser>>>,\n}",
    "future_code": "pub struct Isgl1KeyGeneratorImpl {\n    rust_language: TreeSitterLanguage,\n    python_language: Option<TreeSitterLanguage>,\n    parsers: HashMap<Language, Arc<Mutex<Parser>>>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436662Z",
      "modified_at": "2025-11-01T15:29:24.436662Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:JavaParameter:______crates_parseltongue-core_src_entities_rs:433-437",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "JavaParameter",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 433,
        "end": 437
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct JavaParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub is_varargs: bool,\n}",
    "future_code": "pub struct JavaParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub is_varargs: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436662Z",
      "modified_at": "2025-11-01T15:29:24.436662Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:JavaSignature:______crates_parseltongue-core_src_entities_rs:394-407",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "JavaSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 394,
        "end": 407
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct JavaSignature {\n    /// Access modifier\n    pub access_modifier: AccessModifier,\n    /// Method parameters with types\n    pub parameters: Vec<JavaParameter>,\n    /// Return type\n    pub return_type: String,\n    /// Exception types thrown\n    pub throws: Vec<String>,\n    /// Static method\n    pub is_static: bool,\n    /// Generic parameters\n    pub generics: Vec<String>,\n}",
    "future_code": "pub struct JavaSignature {\n    /// Access modifier\n    pub access_modifier: AccessModifier,\n    /// Method parameters with types\n    pub parameters: Vec<JavaParameter>,\n    /// Return type\n    pub return_type: String,\n    /// Exception types thrown\n    pub throws: Vec<String>,\n    /// Static method\n    pub is_static: bool,\n    /// Generic parameters\n    pub generics: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436664Z",
      "modified_at": "2025-11-01T15:29:24.436664Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:JavascriptSignature:______crates_parseltongue-core_src_entities_rs:355-364",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "JavascriptSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 355,
        "end": 364
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct JavascriptSignature {\n    /// Function parameters\n    pub parameters: Vec<Parameter>,\n    /// Return type annotation (if available)\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Arrow function\n    pub is_arrow: bool,\n}",
    "future_code": "pub struct JavascriptSignature {\n    /// Function parameters\n    pub parameters: Vec<Parameter>,\n    /// Return type annotation (if available)\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Arrow function\n    pub is_arrow: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436666Z",
      "modified_at": "2025-11-01T15:29:24.436666Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LineRange:______crates_parseltongue-core_src_entities_rs:273-278",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LineRange",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 273,
        "end": 278
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LineRange {\n    /// Start line (1-based, inclusive)\n    pub start: u32,\n    /// End line (1-based, inclusive)\n    pub end: u32,\n}",
    "future_code": "pub struct LineRange {\n    /// Start line (1-based, inclusive)\n    pub start: u32,\n    /// End line (1-based, inclusive)\n    pub end: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436666Z",
      "modified_at": "2025-11-01T15:29:24.436666Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LineRange:______crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:95-100",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LineRange",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "line_range": {
        "start": 95,
        "end": 100
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LineRange {\n    /// Start line number (inclusive)\n    pub start: u32,\n    /// End line number (inclusive)\n    pub end: u32,\n}",
    "future_code": "pub struct LineRange {\n    /// Start line number (inclusive)\n    pub start: u32,\n    /// End line number (inclusive)\n    pub end: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436667Z",
      "modified_at": "2025-11-01T15:29:24.436667Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LlmRequest:______crates_parseltongue-core_src_interfaces_rs:279-284",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LlmRequest",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 279,
        "end": 284
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LlmRequest {\n    pub request_id: Uuid,\n    pub context: CodeGraphContext,\n    pub task: TaskSpecification,\n    pub constraints: RequestConstraints,\n}",
    "future_code": "pub struct LlmRequest {\n    pub request_id: Uuid,\n    pub context: CodeGraphContext,\n    pub task: TaskSpecification,\n    pub constraints: RequestConstraints,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436668Z",
      "modified_at": "2025-11-01T15:29:24.436668Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LlmResponse:______crates_parseltongue-core_src_interfaces_rs:288-294",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LlmResponse",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 288,
        "end": 294
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LlmResponse {\n    pub request_id: Uuid,\n    pub reasoning: String,\n    pub proposed_changes: Vec<ProposedChange>,\n    pub confidence_score: f64,\n    pub validation_status: ValidationStatus,\n}",
    "future_code": "pub struct LlmResponse {\n    pub request_id: Uuid,\n    pub reasoning: String,\n    pub proposed_changes: Vec<ProposedChange>,\n    pub confidence_score: f64,\n    pub validation_status: ValidationStatus,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436669Z",
      "modified_at": "2025-11-01T15:29:24.436669Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LlmWriterConfig:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:167-172",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LlmWriterConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 167,
        "end": 172
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LlmWriterConfig {\n    /// Datalog query to execute\n    pub query: String,\n    /// Database connection string\n    pub db_path: String,\n}",
    "future_code": "pub struct LlmWriterConfig {\n    /// Datalog query to execute\n    pub query: String,\n    /// Database connection string\n    pub db_path: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436670Z",
      "modified_at": "2025-11-01T15:29:24.436670Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Location:______crates_parseltongue-core_src_entities_rs:574-578",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Location",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 574,
        "end": 578
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Location {\n    pub file_path: PathBuf,\n    pub line: u32,\n    pub character: u32,\n}",
    "future_code": "pub struct Location {\n    pub file_path: PathBuf,\n    pub line: u32,\n    pub character: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436671Z",
      "modified_at": "2025-11-01T15:29:24.436671Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:LspMetadata:______crates_parseltongue-core_src_entities_rs:539-546",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "LspMetadata",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 539,
        "end": 546
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct LspMetadata {\n    /// Type information\n    pub type_information: TypeInformation,\n    /// Usage analysis\n    pub usage_analysis: UsageAnalysis,\n    /// Semantic tokens\n    pub semantic_tokens: Vec<SemanticToken>,\n}",
    "future_code": "pub struct LspMetadata {\n    /// Type information\n    pub type_information: TypeInformation,\n    /// Usage analysis\n    pub usage_analysis: UsageAnalysis,\n    /// Semantic tokens\n    pub semantic_tokens: Vec<SemanticToken>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436672Z",
      "modified_at": "2025-11-01T15:29:24.436672Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:MinimalEntity:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:94-104",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "MinimalEntity",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 94,
        "end": 104
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct MinimalEntity {\n    /// ISGL1 primary key\n    pub isgl1_key: String,\n    /// Interface signature (formatted string)\n    pub interface_signature: String,\n    /// TDD classification (formatted string)\n    pub tdd_classification: String,\n    /// Optional LSP metadata\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub lsp_metadata: Option<String>,\n}",
    "future_code": "pub struct MinimalEntity {\n    /// ISGL1 primary key\n    pub isgl1_key: String,\n    /// Interface signature (formatted string)\n    pub interface_signature: String,\n    /// TDD classification (formatted string)\n    pub tdd_classification: String,\n    /// Optional LSP metadata\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub lsp_metadata: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436673Z",
      "modified_at": "2025-11-01T15:29:24.436673Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:MockRustAnalyzerClient:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:101-103",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "MockRustAnalyzerClient",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 101,
        "end": 103
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct MockRustAnalyzerClient {\n    responses: std::collections::HashMap<String, HoverResponse>,\n}",
    "future_code": "pub struct MockRustAnalyzerClient {\n    responses: std::collections::HashMap<String, HoverResponse>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436674Z",
      "modified_at": "2025-11-01T15:29:24.436674Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:MockTool:______crates_parseltongue-core_src_interfaces_rs:542-546",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "MockTool",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 542,
        "end": 546
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "    pub struct MockTool {\n        pub metadata: ToolMetadata,\n        pub execute_result: Option<Result<ToolOutput>>,\n        pub should_fail: bool,\n    }",
    "future_code": "    pub struct MockTool {\n        pub metadata: ToolMetadata,\n        pub execute_result: Option<Result<ToolOutput>>,\n        pub should_fail: bool,\n    }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436675Z",
      "modified_at": "2025-11-01T15:29:24.436675Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:NoCircularDependenciesRule:______crates_parseltongue-core_src_temporal_rs:264-266",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "NoCircularDependenciesRule",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 264,
        "end": 266
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct NoCircularDependenciesRule {\n    _private: (),\n}",
    "future_code": "pub struct NoCircularDependenciesRule {\n    _private: (),\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436675Z",
      "modified_at": "2025-11-01T15:29:24.436675Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:OptimizationInfo:______crates_parseltongue-core_src_interfaces_rs:447-451",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "OptimizationInfo",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 447,
        "end": 451
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct OptimizationInfo {\n    pub excluded_entities: Vec<String>,\n    pub truncation_applied: bool,\n    pub prioritization_strategy: String,\n}",
    "future_code": "pub struct OptimizationInfo {\n    pub excluded_entities: Vec<String>,\n    pub truncation_applied: bool,\n    pub prioritization_strategy: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436676Z",
      "modified_at": "2025-11-01T15:29:24.436676Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:OptimizedEntity:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:66-72",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "OptimizedEntity",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 66,
        "end": 72
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct OptimizedEntity {\n    pub entity: CodeEntity,\n    pub relevance_score: f32,\n    pub inclusion_reason: InclusionReason,\n    pub token_estimate: usize,\n    pub dependencies: Vec<String>,\n}",
    "future_code": "pub struct OptimizedEntity {\n    pub entity: CodeEntity,\n    pub relevance_score: f32,\n    pub inclusion_reason: InclusionReason,\n    pub token_estimate: usize,\n    pub dependencies: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436678Z",
      "modified_at": "2025-11-01T15:29:24.436678Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Parameter:______crates_parseltongue-core_src_entities_rs:411-414",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Parameter",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 411,
        "end": 414
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Parameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n}",
    "future_code": "pub struct Parameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436679Z",
      "modified_at": "2025-11-01T15:29:24.436679Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ParsedEntity:______crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:30-37",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ParsedEntity",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "line_range": {
        "start": 30,
        "end": 37
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ParsedEntity {\n    pub entity_type: EntityType,\n    pub name: String,\n    pub language: Language,\n    pub line_range: (usize, usize),\n    pub file_path: String,\n    pub metadata: HashMap<String, String>,\n}",
    "future_code": "pub struct ParsedEntity {\n    pub entity_type: EntityType,\n    pub name: String,\n    pub language: Language,\n    pub line_range: (usize, usize),\n    pub file_path: String,\n    pub metadata: HashMap<String, String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436680Z",
      "modified_at": "2025-11-01T15:29:24.436680Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:PerformanceMetrics:______crates_parseltongue-core_src_interfaces_rs:517-524",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "PerformanceMetrics",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 517,
        "end": 524
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct PerformanceMetrics {\n    pub operation_count: u64,\n    pub total_duration: std::time::Duration,\n    pub average_duration: std::time::Duration,\n    pub success_rate: f64,\n    pub min_duration: std::time::Duration,\n    pub max_duration: std::time::Duration,\n}",
    "future_code": "pub struct PerformanceMetrics {\n    pub operation_count: u64,\n    pub total_duration: std::time::Duration,\n    pub average_duration: std::time::Duration,\n    pub success_rate: f64,\n    pub min_duration: std::time::Duration,\n    pub max_duration: std::time::Duration,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436681Z",
      "modified_at": "2025-11-01T15:29:24.436681Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:PerformanceViolation:______crates_parseltongue-core_src_interfaces_rs:528-533",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "PerformanceViolation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 528,
        "end": 533
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct PerformanceViolation {\n    pub operation_type: String,\n    pub constraint: String,\n    pub actual_value: String,\n    pub expected_value: String,\n}",
    "future_code": "pub struct PerformanceViolation {\n    pub operation_type: String,\n    pub constraint: String,\n    pub actual_value: String,\n    pub expected_value: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436681Z",
      "modified_at": "2025-11-01T15:29:24.436681Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Position:______crates_parseltongue-core_src_interfaces_rs:245-249",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Position",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 245,
        "end": 249
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Position {\n    pub file_path: String,\n    pub line: u32,\n    pub character: u32,\n}",
    "future_code": "pub struct Position {\n    pub file_path: String,\n    pub line: u32,\n    pub character: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436682Z",
      "modified_at": "2025-11-01T15:29:24.436682Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:Position:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:13-18",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "Position",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 13,
        "end": 18
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct Position {\n    /// Line number (0-indexed)\n    pub line: u32,\n    /// Character offset on the line (0-indexed)\n    pub character: u32,\n}",
    "future_code": "pub struct Position {\n    /// Line number (0-indexed)\n    pub line: u32,\n    /// Character offset on the line (0-indexed)\n    pub character: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436683Z",
      "modified_at": "2025-11-01T15:29:24.436683Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ProposedChange:______crates_parseltongue-core_src_interfaces_rs:338-344",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ProposedChange",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 338,
        "end": 344
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ProposedChange {\n    pub target_entity: String,\n    pub change_type: TemporalAction,\n    pub new_content: String,\n    pub justification: String,\n    pub affected_dependencies: Vec<String>,\n}",
    "future_code": "pub struct ProposedChange {\n    pub target_entity: String,\n    pub change_type: TemporalAction,\n    pub new_content: String,\n    pub justification: String,\n    pub affected_dependencies: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436684Z",
      "modified_at": "2025-11-01T15:29:24.436684Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:PruningSummary:______crates_pt02-llm-cozodb-to-context-writer_src_llm_client_rs:87-93",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "PruningSummary",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/llm_client.rs",
      "line_range": {
        "start": 87,
        "end": 93
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct PruningSummary {\n    pub original_entities: usize,\n    pub pruned_entities: usize,\n    pub retained_entities: usize,\n    pub tokens_saved: usize,\n    pub pruning_ratio: f32,\n}",
    "future_code": "pub struct PruningSummary {\n    pub original_entities: usize,\n    pub pruned_entities: usize,\n    pub retained_entities: usize,\n    pub tokens_saved: usize,\n    pub pruning_ratio: f32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436685Z",
      "modified_at": "2025-11-01T15:29:24.436685Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:PythonParameter:______crates_parseltongue-core_src_entities_rs:424-430",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "PythonParameter",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 424,
        "end": 430
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct PythonParameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n    pub default_value: Option<String>,\n    pub is_varargs: bool,\n    pub is_kwargs: bool,\n}",
    "future_code": "pub struct PythonParameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n    pub default_value: Option<String>,\n    pub is_varargs: bool,\n    pub is_kwargs: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436686Z",
      "modified_at": "2025-11-01T15:29:24.436686Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:PythonSignature:______crates_parseltongue-core_src_entities_rs:381-390",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "PythonSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 381,
        "end": 390
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct PythonSignature {\n    /// Function parameters\n    pub parameters: Vec<PythonParameter>,\n    /// Return type annotation\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Decorators\n    pub decorators: Vec<String>,\n}",
    "future_code": "pub struct PythonSignature {\n    /// Function parameters\n    pub parameters: Vec<PythonParameter>,\n    /// Return type annotation\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Decorators\n    pub decorators: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436687Z",
      "modified_at": "2025-11-01T15:29:24.436687Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:RateLimitStatus:______crates_parseltongue-core_src_interfaces_rs:365-369",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "RateLimitStatus",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 365,
        "end": 369
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct RateLimitStatus {\n    pub requests_remaining: u32,\n    pub reset_time: std::time::SystemTime,\n    pub limit: u32,\n}",
    "future_code": "pub struct RateLimitStatus {\n    pub requests_remaining: u32,\n    pub reset_time: std::time::SystemTime,\n    pub limit: u32,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436688Z",
      "modified_at": "2025-11-01T15:29:24.436688Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:RequestConstraints:______crates_parseltongue-core_src_interfaces_rs:330-334",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "RequestConstraints",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 330,
        "end": 334
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct RequestConstraints {\n    pub max_tokens: usize,\n    pub temperature: f64,\n    pub min_confidence: f64,\n}",
    "future_code": "pub struct RequestConstraints {\n    pub max_tokens: usize,\n    pub temperature: f64,\n    pub min_confidence: f64,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436691Z",
      "modified_at": "2025-11-01T15:29:24.436691Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ResetResult:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:73-80",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ResetResult",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 73,
        "end": 80
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ResetResult {\n    /// Whether reset succeeded\n    pub success: bool,\n    /// Number of entities before reset\n    pub entities_deleted: usize,\n    /// Whether schema was recreated\n    pub schema_recreated: bool,\n}",
    "future_code": "pub struct ResetResult {\n    /// Whether reset succeeded\n    pub success: bool,\n    /// Number of entities before reset\n    pub entities_deleted: usize,\n    /// Whether schema was recreated\n    pub schema_recreated: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436692Z",
      "modified_at": "2025-11-01T15:29:24.436692Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:RustAnalyzerClientImpl:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:62-65",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "RustAnalyzerClientImpl",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 62,
        "end": 65
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct RustAnalyzerClientImpl {\n    // TODO: Add LSP process handle and communication channel\n    enabled: bool,\n}",
    "future_code": "pub struct RustAnalyzerClientImpl {\n    // TODO: Add LSP process handle and communication channel\n    enabled: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436693Z",
      "modified_at": "2025-11-01T15:29:24.436693Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:RustSignature:______crates_parseltongue-core_src_entities_rs:331-342",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "RustSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 331,
        "end": 342
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct RustSignature {\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Lifetime parameters\n    pub lifetimes: Vec<String>,\n    /// Where clauses\n    pub where_clauses: Vec<String>,\n    /// Attributes\n    pub attributes: Vec<String>,\n    /// Trait implementations if this is an impl block\n    pub trait_impl: Option<TraitImpl>,\n}",
    "future_code": "pub struct RustSignature {\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Lifetime parameters\n    pub lifetimes: Vec<String>,\n    /// Where clauses\n    pub where_clauses: Vec<String>,\n    /// Attributes\n    pub attributes: Vec<String>,\n    /// Trait implementations if this is an impl block\n    pub trait_impl: Option<TraitImpl>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436694Z",
      "modified_at": "2025-11-01T15:29:24.436694Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:SemanticToken:______crates_parseltongue-core_src_entities_rs:582-587",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "SemanticToken",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 582,
        "end": 587
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct SemanticToken {\n    pub position: Location,\n    pub length: u32,\n    pub token_type: String,\n    pub modifiers: Vec<String>,\n}",
    "future_code": "pub struct SemanticToken {\n    pub position: Location,\n    pub length: u32,\n    pub token_type: String,\n    pub modifiers: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436695Z",
      "modified_at": "2025-11-01T15:29:24.436695Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:SimpleSyntaxValidator:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:40-42",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "SimpleSyntaxValidator",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 40,
        "end": 42
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct SimpleSyntaxValidator {\n    parser: Parser,\n}",
    "future_code": "pub struct SimpleSyntaxValidator {\n    parser: Parser,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436696Z",
      "modified_at": "2025-11-01T15:29:24.436696Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:SimpleUpdateConfig:______crates_pt03-llm-to-cozodb-writer_src_lib_rs:59-64",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "SimpleUpdateConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "line_range": {
        "start": 59,
        "end": 64
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct SimpleUpdateConfig {\n    pub entity_key: String,\n    pub action: EntityAction,\n    pub future_code: Option<String>,\n    pub db_path: String,\n}",
    "future_code": "pub struct SimpleUpdateConfig {\n    pub entity_key: String,\n    pub action: EntityAction,\n    pub future_code: Option<String>,\n    pub db_path: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436696Z",
      "modified_at": "2025-11-01T15:29:24.436697Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:StateResetManager:______crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:10-12",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "StateResetManager",
      "visibility": "Public",
      "file_path": "../../crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "line_range": {
        "start": 10,
        "end": 12
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct StateResetManager {\n    pub(crate) storage: CozoDbStorage,\n}",
    "future_code": "pub struct StateResetManager {\n    pub(crate) storage: CozoDbStorage,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436697Z",
      "modified_at": "2025-11-01T15:29:24.436697Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:StreamResult:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:37-43",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "StreamResult",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 37,
        "end": 43
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct StreamResult {\n    pub total_files: usize,\n    pub processed_files: usize,\n    pub entities_created: usize,\n    pub errors: Vec<String>,\n    pub duration: std::time::Duration,\n}",
    "future_code": "pub struct StreamResult {\n    pub total_files: usize,\n    pub processed_files: usize,\n    pub entities_created: usize,\n    pub errors: Vec<String>,\n    pub duration: std::time::Duration,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436698Z",
      "modified_at": "2025-11-01T15:29:24.436698Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:StreamStats:______crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:56-60",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "StreamStats",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "line_range": {
        "start": 56,
        "end": 60
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct StreamStats {\n    pub files_processed: usize,\n    pub entities_created: usize,\n    pub errors_encountered: usize,\n}",
    "future_code": "pub struct StreamStats {\n    pub files_processed: usize,\n    pub entities_created: usize,\n    pub errors_encountered: usize,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436699Z",
      "modified_at": "2025-11-01T15:29:24.436699Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:StreamerConfig:______crates_pt01-folder-to-cozodb-streamer_src_lib_rs:42-57",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "StreamerConfig",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "line_range": {
        "start": 42,
        "end": 57
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct StreamerConfig {\n    /// Root directory to scan for code files\n    pub root_dir: PathBuf,\n    /// Database connection string\n    pub db_path: String,\n    /// Maximum file size to process (bytes)\n    pub max_file_size: usize,\n    /// File patterns to include\n    pub include_patterns: Vec<String>,\n    /// File patterns to exclude\n    pub exclude_patterns: Vec<String>,\n    /// Parsing library to use (default: \"tree-sitter\")\n    pub parsing_library: String,\n    /// Chunking strategy to use (default: \"ISGL1\")\n    pub chunking: String,\n}",
    "future_code": "pub struct StreamerConfig {\n    /// Root directory to scan for code files\n    pub root_dir: PathBuf,\n    /// Database connection string\n    pub db_path: String,\n    /// Maximum file size to process (bytes)\n    pub max_file_size: usize,\n    /// File patterns to include\n    pub include_patterns: Vec<String>,\n    /// File patterns to exclude\n    pub exclude_patterns: Vec<String>,\n    /// Parsing library to use (default: \"tree-sitter\")\n    pub parsing_library: String,\n    /// Chunking strategy to use (default: \"ISGL1\")\n    pub chunking: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436700Z",
      "modified_at": "2025-11-01T15:29:24.436700Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:SuccessCriteria:______crates_parseltongue-core_src_interfaces_rs:315-319",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "SuccessCriteria",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 315,
        "end": 319
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct SuccessCriteria {\n    pub min_confidence: f64,\n    pub max_duration: std::time::Duration,\n    pub validation_rules: Vec<ValidationRule>,\n}",
    "future_code": "pub struct SuccessCriteria {\n    pub min_confidence: f64,\n    pub max_duration: std::time::Duration,\n    pub validation_rules: Vec<ValidationRule>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436701Z",
      "modified_at": "2025-11-01T15:29:24.436701Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TaskSpecification:______crates_parseltongue-core_src_interfaces_rs:298-302",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TaskSpecification",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 298,
        "end": 302
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TaskSpecification {\n    pub task_type: TaskType,\n    pub instruction: String,\n    pub success_criteria: SuccessCriteria,\n}",
    "future_code": "pub struct TaskSpecification {\n    pub task_type: TaskType,\n    pub instruction: String,\n    pub success_criteria: SuccessCriteria,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436702Z",
      "modified_at": "2025-11-01T15:29:24.436702Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TddClassification:______crates_parseltongue-core_src_entities_rs:496-511",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TddClassification",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 496,
        "end": 511
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TddClassification {\n    /// Entity classification (test vs production code)\n    pub entity_class: EntityClass,\n    /// Testability level\n    pub testability: TestabilityLevel,\n    /// Complexity assessment\n    pub complexity: ComplexityLevel,\n    /// Number of dependencies\n    pub dependencies: usize,\n    /// Estimated test coverage\n    pub test_coverage_estimate: f64,\n    /// Whether this is on critical path\n    pub critical_path: bool,\n    /// Change risk assessment\n    pub change_risk: RiskLevel,\n}",
    "future_code": "pub struct TddClassification {\n    /// Entity classification (test vs production code)\n    pub entity_class: EntityClass,\n    /// Testability level\n    pub testability: TestabilityLevel,\n    /// Complexity assessment\n    pub complexity: ComplexityLevel,\n    /// Number of dependencies\n    pub dependencies: usize,\n    /// Estimated test coverage\n    pub test_coverage_estimate: f64,\n    /// Whether this is on critical path\n    pub critical_path: bool,\n    /// Change risk assessment\n    pub change_risk: RiskLevel,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436703Z",
      "modified_at": "2025-11-01T15:29:24.436703Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TemporalChange:______crates_parseltongue-core_src_interfaces_rs:455-460",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TemporalChange",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 455,
        "end": 460
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TemporalChange {\n    pub isgl1_key: String,\n    pub action: TemporalAction,\n    pub future_code: Option<String>,\n    pub updated_signature: Option<InterfaceSignature>,\n}",
    "future_code": "pub struct TemporalChange {\n    pub isgl1_key: String,\n    pub action: TemporalAction,\n    pub future_code: Option<String>,\n    pub updated_signature: Option<InterfaceSignature>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436704Z",
      "modified_at": "2025-11-01T15:29:24.436704Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TemporalQuery:______crates_parseltongue-core_src_interfaces_rs:168-179",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TemporalQuery",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 168,
        "end": 179
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TemporalQuery {\n    /// Base entities to start from\n    pub base_entities: Vec<String>,\n    /// Hop depth for dependency analysis\n    pub hop_depth: u32,\n    /// Include future changes only\n    pub future_only: bool,\n    /// Entity type filter\n    pub entity_type_filter: Option<EntityType>,\n    /// Language filter\n    pub language_filter: Option<Language>,\n}",
    "future_code": "pub struct TemporalQuery {\n    /// Base entities to start from\n    pub base_entities: Vec<String>,\n    /// Hop depth for dependency analysis\n    pub hop_depth: u32,\n    /// Include future changes only\n    pub future_only: bool,\n    /// Entity type filter\n    pub entity_type_filter: Option<EntityType>,\n    /// Language filter\n    pub language_filter: Option<Language>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436705Z",
      "modified_at": "2025-11-01T15:29:24.436705Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TemporalState:______crates_parseltongue-core_src_entities_rs:148-155",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TemporalState",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 148,
        "end": 155
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TemporalState {\n    /// Entity exists in current state\n    pub current_ind: bool,\n    /// Entity will exist in future state\n    pub future_ind: bool,\n    /// Action to transition from current to future\n    pub future_action: Option<TemporalAction>,\n}",
    "future_code": "pub struct TemporalState {\n    /// Entity exists in current state\n    pub current_ind: bool,\n    /// Entity will exist in future state\n    pub future_ind: bool,\n    /// Action to transition from current to future\n    pub future_action: Option<TemporalAction>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436706Z",
      "modified_at": "2025-11-01T15:29:24.436706Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TemporalTransitionBuilder:______crates_parseltongue-core_src_temporal_rs:396-401",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TemporalTransitionBuilder",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 396,
        "end": 401
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TemporalTransitionBuilder {\n    isgl1_key: String,\n    action: Option<TemporalAction>,\n    future_code: Option<String>,\n    updated_signature: Option<InterfaceSignature>,\n}",
    "future_code": "pub struct TemporalTransitionBuilder {\n    isgl1_key: String,\n    action: Option<TemporalAction>,\n    future_code: Option<String>,\n    updated_signature: Option<InterfaceSignature>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436707Z",
      "modified_at": "2025-11-01T15:29:24.436707Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TemporalVersioningManager:______crates_parseltongue-core_src_temporal_rs:17-25",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TemporalVersioningManager",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 17,
        "end": 25
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TemporalVersioningManager {\n    /// Current state of all entities\n    entities: HashMap<String, CodeEntity>,\n    /// Pending changes not yet applied\n    #[allow(dead_code)]\n    pending_changes: Vec<TemporalChange>,\n    /// Validation rules\n    validation_rules: Vec<Box<dyn TemporalValidationRule>>,\n}",
    "future_code": "pub struct TemporalVersioningManager {\n    /// Current state of all entities\n    entities: HashMap<String, CodeEntity>,\n    /// Pending changes not yet applied\n    #[allow(dead_code)]\n    pending_changes: Vec<TemporalChange>,\n    /// Validation rules\n    validation_rules: Vec<Box<dyn TemporalValidationRule>>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436708Z",
      "modified_at": "2025-11-01T15:29:24.436708Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TextDocumentIdentifier:______crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:22-25",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TextDocumentIdentifier",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "line_range": {
        "start": 22,
        "end": 25
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TextDocumentIdentifier {\n    /// The document's URI (file:// path)\n    pub uri: String,\n}",
    "future_code": "pub struct TextDocumentIdentifier {\n    /// The document's URI (file:// path)\n    pub uri: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436709Z",
      "modified_at": "2025-11-01T15:29:24.436709Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ToolCapabilities:______crates_parseltongue-core_src_interfaces_rs:125-136",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ToolCapabilities",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 125,
        "end": 136
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ToolCapabilities {\n    /// Supports async execution\n    pub async_execution: bool,\n    /// Supports parallel processing\n    pub parallel_processing: bool,\n    /// Supports incremental processing\n    pub incremental_processing: bool,\n    /// Requires network access\n    pub requires_network: bool,\n    /// Maximum supported input size\n    pub max_input_size: Option<usize>,\n}",
    "future_code": "pub struct ToolCapabilities {\n    /// Supports async execution\n    pub async_execution: bool,\n    /// Supports parallel processing\n    pub parallel_processing: bool,\n    /// Supports incremental processing\n    pub incremental_processing: bool,\n    /// Requires network access\n    pub requires_network: bool,\n    /// Maximum supported input size\n    pub max_input_size: Option<usize>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436710Z",
      "modified_at": "2025-11-01T15:29:24.436710Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ToolFactory:______crates_pt01-folder-to-cozodb-streamer_src_lib_rs:74-74",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ToolFactory",
      "visibility": "Public",
      "file_path": "../../crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "line_range": {
        "start": 74,
        "end": 74
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ToolFactory;",
    "future_code": "pub struct ToolFactory;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436711Z",
      "modified_at": "2025-11-01T15:29:24.436711Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ToolFactory:______crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:68-68",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ToolFactory",
      "visibility": "Public",
      "file_path": "../../crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "line_range": {
        "start": 68,
        "end": 68
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ToolFactory;",
    "future_code": "pub struct ToolFactory;",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436713Z",
      "modified_at": "2025-11-01T15:29:24.436713Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ToolMetadata:______crates_parseltongue-core_src_interfaces_rs:108-121",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ToolMetadata",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 108,
        "end": 121
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ToolMetadata {\n    /// Tool identifier\n    pub id: String,\n    /// Tool name\n    pub name: String,\n    /// Tool version\n    pub version: String,\n    /// Tool description\n    pub description: String,\n    /// Supported input types\n    pub supported_inputs: Vec<String>,\n    /// Tool capabilities\n    pub capabilities: ToolCapabilities,\n}",
    "future_code": "pub struct ToolMetadata {\n    /// Tool identifier\n    pub id: String,\n    /// Tool name\n    pub name: String,\n    /// Tool version\n    pub version: String,\n    /// Tool description\n    pub description: String,\n    /// Supported input types\n    pub supported_inputs: Vec<String>,\n    /// Tool capabilities\n    pub capabilities: ToolCapabilities,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436713Z",
      "modified_at": "2025-11-01T15:29:24.436714Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TraitImpl:______crates_parseltongue-core_src_entities_rs:346-351",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TraitImpl",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 346,
        "end": 351
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TraitImpl {\n    /// Trait being implemented\n    pub trait_name: String,\n    /// Type implementing the trait\n    pub for_type: String,\n}",
    "future_code": "pub struct TraitImpl {\n    /// Trait being implemented\n    pub trait_name: String,\n    /// Type implementing the trait\n    pub for_type: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436714Z",
      "modified_at": "2025-11-01T15:29:24.436714Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TypeInformation:______crates_parseltongue-core_src_entities_rs:550-559",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TypeInformation",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 550,
        "end": 559
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TypeInformation {\n    /// Resolved type\n    pub resolved_type: String,\n    /// Module path\n    pub module_path: Vec<String>,\n    /// Generic parameters\n    pub generic_parameters: Vec<String>,\n    /// Definition location\n    pub definition_location: Option<Location>,\n}",
    "future_code": "pub struct TypeInformation {\n    /// Resolved type\n    pub resolved_type: String,\n    /// Module path\n    pub module_path: Vec<String>,\n    /// Generic parameters\n    pub generic_parameters: Vec<String>,\n    /// Definition location\n    pub definition_location: Option<Location>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436715Z",
      "modified_at": "2025-11-01T15:29:24.436715Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TypeScriptSignature:______crates_parseltongue-core_src_entities_rs:368-377",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TypeScriptSignature",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 368,
        "end": 377
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TypeScriptSignature {\n    /// Function parameters with types\n    pub parameters: Vec<TypedParameter>,\n    /// Return type\n    pub return_type: Option<String>,\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Async function\n    pub is_async: bool,\n}",
    "future_code": "pub struct TypeScriptSignature {\n    /// Function parameters with types\n    pub parameters: Vec<TypedParameter>,\n    /// Return type\n    pub return_type: Option<String>,\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Async function\n    pub is_async: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436716Z",
      "modified_at": "2025-11-01T15:29:24.436716Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:TypedParameter:______crates_parseltongue-core_src_entities_rs:417-421",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "TypedParameter",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 417,
        "end": 421
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct TypedParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub optional: bool,\n}",
    "future_code": "pub struct TypedParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub optional: bool,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436717Z",
      "modified_at": "2025-11-01T15:29:24.436717Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:UsageAnalysis:______crates_parseltongue-core_src_entities_rs:563-570",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "UsageAnalysis",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/entities.rs",
      "line_range": {
        "start": 563,
        "end": 570
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct UsageAnalysis {\n    /// Total references\n    pub total_references: usize,\n    /// Usage locations\n    pub usage_locations: Vec<Location>,\n    /// Dependent entities\n    pub dependents: Vec<String>,\n}",
    "future_code": "pub struct UsageAnalysis {\n    /// Total references\n    pub total_references: usize,\n    /// Usage locations\n    pub usage_locations: Vec<Location>,\n    /// Dependent entities\n    pub dependents: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436718Z",
      "modified_at": "2025-11-01T15:29:24.436718Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidTransitionsRule:______crates_parseltongue-core_src_temporal_rs:354-356",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidTransitionsRule",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/temporal.rs",
      "line_range": {
        "start": 354,
        "end": 356
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidTransitionsRule {\n    _private: (),\n}",
    "future_code": "pub struct ValidTransitionsRule {\n    _private: (),\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436719Z",
      "modified_at": "2025-11-01T15:29:24.436719Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationError:______crates_parseltongue-core_src_interfaces_rs:356-361",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationError",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 356,
        "end": 361
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationError {\n    pub field: String,\n    pub expected: String,\n    pub actual: String,\n    pub message: String,\n}",
    "future_code": "pub struct ValidationError {\n    pub field: String,\n    pub expected: String,\n    pub actual: String,\n    pub message: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436720Z",
      "modified_at": "2025-11-01T15:29:24.436720Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationOutput:______crates_pt04-syntax-preflight-validator_src_types_rs:48-61",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationOutput",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 48,
        "end": 61
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationOutput {\n    /// Whether the validation passed\n    pub is_valid: bool,\n    /// Type of validation performed\n    pub validation_type: ValidationType,\n    /// Errors encountered during validation\n    pub errors: Vec<String>,\n    /// Warnings (non-blocking issues)\n    pub warnings: Vec<String>,\n    /// Execution time in milliseconds\n    pub execution_time_ms: u64,\n    /// Memory usage in bytes\n    pub memory_usage_bytes: usize,\n}",
    "future_code": "pub struct ValidationOutput {\n    /// Whether the validation passed\n    pub is_valid: bool,\n    /// Type of validation performed\n    pub validation_type: ValidationType,\n    /// Errors encountered during validation\n    pub errors: Vec<String>,\n    /// Warnings (non-blocking issues)\n    pub warnings: Vec<String>,\n    /// Execution time in milliseconds\n    pub execution_time_ms: u64,\n    /// Memory usage in bytes\n    pub memory_usage_bytes: usize,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436721Z",
      "modified_at": "2025-11-01T15:29:24.436721Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationReport:______crates_pt04-syntax-preflight-validator_src_types_rs:98-113",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationReport",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/types.rs",
      "line_range": {
        "start": 98,
        "end": 113
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationReport {\n    /// Path to file being validated (if applicable)\n    pub file_path: Option<PathBuf>,\n    /// Code snippet that was validated\n    pub code_snippet: String,\n    /// Individual validation results\n    pub individual_results: Vec<ValidationOutput>,\n    /// Overall validation status (all checks must pass)\n    pub overall_valid: bool,\n    /// Total execution time across all validations\n    pub total_execution_time_ms: u64,\n    /// Total memory usage across all validations\n    pub total_memory_usage_bytes: usize,\n    /// When this report was generated\n    pub generated_at: DateTime<Utc>,\n}",
    "future_code": "pub struct ValidationReport {\n    /// Path to file being validated (if applicable)\n    pub file_path: Option<PathBuf>,\n    /// Code snippet that was validated\n    pub code_snippet: String,\n    /// Individual validation results\n    pub individual_results: Vec<ValidationOutput>,\n    /// Overall validation status (all checks must pass)\n    pub overall_valid: bool,\n    /// Total execution time across all validations\n    pub total_execution_time_ms: u64,\n    /// Total memory usage across all validations\n    pub total_memory_usage_bytes: usize,\n    /// When this report was generated\n    pub generated_at: DateTime<Utc>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436722Z",
      "modified_at": "2025-11-01T15:29:24.436722Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationResult:______crates_parseltongue-core_src_interfaces_rs:472-479",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationResult",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 472,
        "end": 479
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationResult {\n    pub entity: String,\n    pub level: ValidationLevel,\n    pub passed: bool,\n    pub errors: Vec<String>,\n    pub warnings: Vec<String>,\n    pub duration_ms: u64,\n}",
    "future_code": "pub struct ValidationResult {\n    pub entity: String,\n    pub level: ValidationLevel,\n    pub passed: bool,\n    pub errors: Vec<String>,\n    pub warnings: Vec<String>,\n    pub duration_ms: u64,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436723Z",
      "modified_at": "2025-11-01T15:29:24.436723Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationResult:______crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:285-288",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationResult",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "line_range": {
        "start": 285,
        "end": 288
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "struct ValidationResult {\n    is_valid: bool,\n    errors: Vec<String>,\n}",
    "future_code": "struct ValidationResult {\n    is_valid: bool,\n    errors: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436724Z",
      "modified_at": "2025-11-01T15:29:24.436724Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationResult:______crates_pt04-syntax-preflight-validator_src_simple_validator_rs:121-126",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationResult",
      "visibility": "Public",
      "file_path": "../../crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "line_range": {
        "start": 121,
        "end": 126
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationResult {\n    /// Whether syntax is valid\n    pub is_valid: bool,\n    /// List of error messages (empty if valid)\n    pub errors: Vec<String>,\n}",
    "future_code": "pub struct ValidationResult {\n    /// Whether syntax is valid\n    pub is_valid: bool,\n    /// List of error messages (empty if valid)\n    pub errors: Vec<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436725Z",
      "modified_at": "2025-11-01T15:29:24.436725Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:ValidationRule:______crates_parseltongue-core_src_interfaces_rs:323-326",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "ValidationRule",
      "visibility": "Public",
      "file_path": "../../crates/parseltongue-core/src/interfaces.rs",
      "line_range": {
        "start": 323,
        "end": 326
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct ValidationRule {\n    pub field: String,\n    pub constraint: String,\n}",
    "future_code": "pub struct ValidationRule {\n    pub field: String,\n    pub constraint: String,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436726Z",
      "modified_at": "2025-11-01T15:29:24.436726Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:WriteResult:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:6-15",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "WriteResult",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 6,
        "end": 15
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct WriteResult {\n    /// Whether the operation succeeded\n    pub success: bool,\n    /// Path to the file that was written/deleted\n    pub file_path: PathBuf,\n    /// Type of operation performed\n    pub operation: WriteOperation,\n    /// Optional message describing the result\n    pub message: Option<String>,\n}",
    "future_code": "pub struct WriteResult {\n    /// Whether the operation succeeded\n    pub success: bool,\n    /// Path to the file that was written/deleted\n    pub file_path: PathBuf,\n    /// Type of operation performed\n    pub operation: WriteOperation,\n    /// Optional message describing the result\n    pub message: Option<String>,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436727Z",
      "modified_at": "2025-11-01T15:29:24.436727Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "rust:struct:WriteSummary:______crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:60-71",
    "temporal_state": {
      "current_ind": true,
      "future_ind": false,
      "future_action": null
    },
    "interface_signature": {
      "entity_type": "Struct",
      "name": "WriteSummary",
      "visibility": "Public",
      "file_path": "../../crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "line_range": {
        "start": 60,
        "end": 71
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": "pub struct WriteSummary {\n    /// Number of files created\n    pub created: usize,\n    /// Number of files edited\n    pub edited: usize,\n    /// Number of files deleted\n    pub deleted: usize,\n    /// Total number of operations\n    pub total: usize,\n    /// Number of errors encountered\n    pub errors: usize,\n}",
    "future_code": "pub struct WriteSummary {\n    /// Number of files created\n    pub created: usize,\n    /// Number of files edited\n    pub edited: usize,\n    /// Number of files deleted\n    pub deleted: usize,\n    /// Total number of operations\n    pub total: usize,\n    /// Number of errors encountered\n    pub errors: usize,\n}",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Medium"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436728Z",
      "modified_at": "2025-11-01T15:29:24.436728Z",
      "content_hash": "",
      "additional": {}
    }
  },
  {
    "isgl1_key": "test_rs-test-new_test_function",
    "temporal_state": {
      "current_ind": false,
      "future_ind": true,
      "future_action": "Create"
    },
    "interface_signature": {
      "entity_type": "Function",
      "name": "new_test_function",
      "visibility": "Public",
      "file_path": "test_rs",
      "line_range": {
        "start": 1,
        "end": 1
      },
      "module_path": [],
      "documentation": null,
      "language_specific": {
        "language": "rust",
        "generics": [],
        "lifetimes": [],
        "where_clauses": [],
        "attributes": [],
        "trait_impl": null
      }
    },
    "current_code": null,
    "future_code": "fn new_test_function() { println!(\"Hello from new entity!\"); }",
    "tdd_classification": {
      "entity_class": "CodeImplementation",
      "testability": "Medium",
      "complexity": "Simple",
      "dependencies": 0,
      "test_coverage_estimate": 0.0,
      "critical_path": false,
      "change_risk": "Low"
    },
    "lsp_metadata": null,
    "metadata": {
      "created_at": "2025-11-01T15:29:24.436729Z",
      "modified_at": "2025-11-01T15:29:24.436729Z",
      "content_hash": "",
      "additional": {}
    }
  }
]