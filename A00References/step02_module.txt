# Parseltongue v0.2.1: Async-First Project Blueprint

## Directory Structure
```
parseltongue/
â”œâ”€â”€ frontend/                    # Next.js 14+ Frontend
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/                âŒ Next.js App Router
â”‚   â”‚   â”œâ”€â”€ components/         ğŸ”„ React Components
â”‚   â”‚   â””â”€â”€ services/          âŒ API Integration
â”‚       â””â”€â”€ websocket/         # WebSocket connections
â”‚           â”œâ”€â”€ progressSocket.ts  # Real-time progress
â”‚           â””â”€â”€ resultSocket.ts    # Live results
â”‚
â”œâ”€â”€ backend-java/              # Spring WebFlux Backend
â”‚   â”œâ”€â”€ src/main/java/com/parseltongue/
â”‚   â”‚   â”œâ”€â”€ config/           
â”‚   â”‚   â”‚   â”œâ”€â”€ WebFluxConfig.java    # Reactive web config
â”‚   â”‚   â”‚   â”œâ”€â”€ MongoConfig.java      # Reactive MongoDB
â”‚   â”‚   â”‚   â””â”€â”€ WebSocketConfig.java  # WebSocket setup
â”‚   â”‚   â”œâ”€â”€ controller/       
â”‚   â”‚   â”‚   â”œâ”€â”€ AnalysisHandler.java  # Reactive handlers
â”‚   â”‚   â”‚   â””â”€â”€ WebSocketHandler.java # Progress updates
â”‚   â”‚   â”œâ”€ï¿½ï¿½ï¿½ model/            
â”‚   â”‚   â”‚   â”œâ”€â”€ AnalysisJob.java     # Reactive model
â”‚   â”‚   â”‚   â””â”€â”€ FileStream.java      # Stream processor
â”‚   â”‚   â”œâ”€â”€ repository/       
â”‚   â”‚   â”‚   â””â”€â”€ ReactiveAnalysisRepository.java
â”‚   â”‚   â””â”€â”€ service/          
â”‚   â”‚       â”œâ”€â”€ ReactiveAnalysisService.java
â”‚   â”‚       â””â”€â”€ StreamProcessor.java   # Reactive streams
â”‚
â”œâ”€â”€ backend-rust/             # Async Rust Backend
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs          # Tokio runtime setup
â”‚   â”‚   â”œâ”€â”€ config/          
â”‚   â”‚   â”‚   â””â”€â”€ runtime.rs      # Async runtime config
â”‚   â”‚   â”œâ”€â”€ handlers/        
â”‚   â”‚   â”‚   â”œâ”€â”€ ws_handler.rs   # WebSocket handler
â”‚   â”‚   â”‚   â””â”€â”€ analysis.rs     # Async handlers
â”‚   â”‚   â”œâ”€â”€ models/          
â”‚   â”‚   â”‚   â””â”€â”€ streams.rs      # Async streams
â”‚   â”‚   â””â”€â”€ services/        
â”‚   â”‚       â”œâ”€â”€ analyzer.rs     # Concurrent analysis
â”‚   â”‚       â””â”€â”€ processor.rs    # Stream processing
â”‚
â””â”€â”€ shared/                   
    â””â”€â”€ types/               
        â””â”€â”€ async.ts         # Shared async types
```

## Async Implementation Details

### Java Backend (Spring WebFlux)
```java
// ReactiveAnalysisService.java
public interface ReactiveAnalysisService {
    Flux<AnalysisProgress> analyzeFile(Flux<FilePart> file);
    Mono<AnalysisResult> getResults(String jobId);
    Flux<ProgressEvent> streamProgress(String jobId);
}

// StreamProcessor.java
public class StreamProcessor {
    private final Sinks.Many<ProgressEvent> progressSink;
    private final Flux<ProgressEvent> progressFlux;
    
    public Flux<FileChunk> processFileStream(Flux<DataBuffer> input) {
        // Reactive file processing
    }
}
```

### Rust Backend (Tokio)
```rust
// analyzer.rs
pub struct AsyncAnalyzer {
    progress_tx: mpsc::Sender<ProgressEvent>,
    result_tx: oneshot::Sender<AnalysisResult>,
}

impl AsyncAnalyzer {
    pub async fn process_stream(
        mut stream: impl Stream<Item = FileChunk> + Unpin
    ) -> Result<AnalysisResult> {
        // Concurrent processing
    }
}

// processor.rs
pub struct StreamProcessor {
    runtime: Runtime,
    workers: Vec<JoinHandle<()>>,
}
```

## Performance Requirements
- Concurrent File Processing: 10+ files
- WebSocket Latency: < 100ms
- Stream Processing: 50MB/s
- Memory Usage: < 512MB

## Async Features
### Java Backend
- Reactive MongoDB repositories
- Non-blocking WebFlux controllers
- Reactive file streaming
- WebSocket progress updates

### Rust Backend
- Tokio async runtime
- Channel-based communication
- Concurrent file processing
- Async MongoDB operations

## Implementation Status
### Core Async Features
- WebSocket Setup: âŒ
- Reactive Repositories: âŒ
- Stream Processing: âŒ
- Concurrent Analysis: âŒ

### Infrastructure
- WebFlux Config: âŒ
- Tokio Runtime: âŒ
- MongoDB Reactive: âŒ
- WebSocket Handlers: âŒ

## DO's and DON'Ts
### Java Backend
DO:
- Use reactive types (Mono/Flux)
- Implement backpressure
- Use non-blocking operations
- Handle streaming errors

DON'T:
- Block the event loop
- Use synchronous operations
- Mix reactive and blocking code
- Ignore backpressure

### Rust Backend
DO:
- Use async/await consistently
- Implement proper cancellation
- Use channels for communication
- Handle stream errors

DON'T:
- Block the Tokio runtime
- Ignore task cancellation
- Use blocking operations
- Skip error propagation

## Version History
v0.2.0 - Added async-first architecture
v0.1.0 - Initial structure

### Java Backend (Spring Boot) Async Features
```java
// ThreadConfig.java
@Configuration
public class ThreadConfig {
    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("AsyncThread-");
        executor.initialize();
        return executor;
    }
}

// AnalysisService.java
@Service
public class AnalysisService {
    @Async
    public CompletableFuture<AnalysisResult> analyzeFileAsync(MultipartFile file) {
        return CompletableFuture.supplyAsync(() -> {
            // File analysis logic
        });
    }
    
    public CompletableFuture<List<FileMetric>> processFilesParallel(List<File> files) {
        List<CompletableFuture<FileMetric>> futures = files.stream()
            .map(this::processFileAsync)
            .collect(Collectors.toList());
            
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
    
    @Async
    public CompletableFuture<FileMetric> processFileAsync(File file) {
        return CompletableFuture.supplyAsync(() -> {
            // Process single file
        });
    }
}

// AnalysisController.java
@RestController
@RequestMapping("/api/v1/analysis")
public class AnalysisController {
    @PostMapping("/async")
    public CompletableFuture<ResponseEntity<AnalysisResult>> analyzeAsync(
        @RequestParam("file") MultipartFile file
    ) {
        return analysisService.analyzeFileAsync(file)
            .thenApply(ResponseEntity::ok)
            .exceptionally(ex -> ResponseEntity.status(500).build());
    }
    
    @PostMapping("/parallel")
    public CompletableFuture<ResponseEntity<List<FileMetric>>> analyzeParallel(
        @RequestParam("files") List<MultipartFile> files
    ) {
        return analysisService.processFilesParallel(files)
            .thenApply(ResponseEntity::ok)
            .exceptionally(ex -> ResponseEntity.status(500).build());
    }
}

// ProgressTracker.java
@Service
public class ProgressTracker {
    private final Map<String, CompletableFuture<Integer>> progressMap = new ConcurrentHashMap<>();
    
    public void trackProgress(String jobId) {
        progressMap.put(jobId, new CompletableFuture<>());
    }
    
    public CompletableFuture<Integer> getProgress(String jobId) {
        return progressMap.get(jobId);
    }
    
    public void updateProgress(String jobId, int progress) {
        Optional.ofNullable(progressMap.get(jobId))
            .ifPresent(future -> future.complete(progress));
    }
}
```

### Async Processing Features
1. **Thread Pool Management**
   - Custom thread pools for different operations
   - Configurable pool sizes
   - Named threads for better monitoring

2. **Parallel Processing**
   - File chunking and parallel analysis
   - Progress tracking per chunk
   - Results aggregation

3. **Async Operations**
   - Non-blocking file uploads
   - Parallel file processing
   - Async progress updates

4. **Error Handling**
   - Exception propagation
   - Timeout management
   - Recovery strategies

### DO's
- Use appropriate thread pool sizes
- Implement proper error handling
- Monitor thread pool health
- Use CompletableFuture for composition
- Implement timeout mechanisms

### DON'Ts
- Block the event loop
- Create unlimited threads
- Ignore thread pool saturation
- Mix blocking and non-blocking code
- Skip error handling