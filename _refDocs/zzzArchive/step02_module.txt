# Parseltongue v0.2.1: Async-First Project Blueprint

## Directory Structure
```
parseltongue/
├── frontend/                    # Next.js 14+ Frontend
│   ├── src/
│   │   ├── app/                ❌ Next.js App Router
│   │   ├── components/         🔄 React Components
│   │   └── services/          ❌ API Integration
│       └── websocket/         # WebSocket connections
│           ├── progressSocket.ts  # Real-time progress
│           └── resultSocket.ts    # Live results
│
├── backend-java/              # Spring WebFlux Backend
│   ├── src/main/java/com/parseltongue/
│   │   ├── config/           
│   │   │   ├── WebFluxConfig.java    # Reactive web config
│   │   │   ├── MongoConfig.java      # Reactive MongoDB
│   │   │   └── WebSocketConfig.java  # WebSocket setup
│   │   ├── controller/       
│   │   │   ├── AnalysisHandler.java  # Reactive handlers
│   │   │   └── WebSocketHandler.java # Progress updates
│   │   ├─��� model/            
│   │   │   ├── AnalysisJob.java     # Reactive model
│   │   │   └── FileStream.java      # Stream processor
│   │   ├── repository/       
│   │   │   └── ReactiveAnalysisRepository.java
│   │   └── service/          
│   │       ├── ReactiveAnalysisService.java
│   │       └── StreamProcessor.java   # Reactive streams
│
├── backend-rust/             # Async Rust Backend
│   ├── src/
│   │   ├── main.rs          # Tokio runtime setup
│   │   ├── config/          
│   │   │   └── runtime.rs      # Async runtime config
│   │   ├── handlers/        
│   │   │   ├── ws_handler.rs   # WebSocket handler
│   │   │   └── analysis.rs     # Async handlers
│   │   ├── models/          
│   │   │   └── streams.rs      # Async streams
│   │   └── services/        
│   │       ├── analyzer.rs     # Concurrent analysis
│   │       └── processor.rs    # Stream processing
│
└── shared/                   
    └── types/               
        └── async.ts         # Shared async types
```

## Async Implementation Details

### Java Backend (Spring WebFlux)
```java
// ReactiveAnalysisService.java
public interface ReactiveAnalysisService {
    Flux<AnalysisProgress> analyzeFile(Flux<FilePart> file);
    Mono<AnalysisResult> getResults(String jobId);
    Flux<ProgressEvent> streamProgress(String jobId);
}

// StreamProcessor.java
public class StreamProcessor {
    private final Sinks.Many<ProgressEvent> progressSink;
    private final Flux<ProgressEvent> progressFlux;
    
    public Flux<FileChunk> processFileStream(Flux<DataBuffer> input) {
        // Reactive file processing
    }
}
```

### Rust Backend (Tokio)
```rust
// analyzer.rs
pub struct AsyncAnalyzer {
    progress_tx: mpsc::Sender<ProgressEvent>,
    result_tx: oneshot::Sender<AnalysisResult>,
}

impl AsyncAnalyzer {
    pub async fn process_stream(
        mut stream: impl Stream<Item = FileChunk> + Unpin
    ) -> Result<AnalysisResult> {
        // Concurrent processing
    }
}

// processor.rs
pub struct StreamProcessor {
    runtime: Runtime,
    workers: Vec<JoinHandle<()>>,
}
```

## Performance Requirements
- Concurrent File Processing: 10+ files
- WebSocket Latency: < 100ms
- Stream Processing: 50MB/s
- Memory Usage: < 512MB

## Async Features
### Java Backend
- Reactive MongoDB repositories
- Non-blocking WebFlux controllers
- Reactive file streaming
- WebSocket progress updates

### Rust Backend
- Tokio async runtime
- Channel-based communication
- Concurrent file processing
- Async MongoDB operations

## Implementation Status
### Core Async Features
- WebSocket Setup: ❌
- Reactive Repositories: ❌
- Stream Processing: ❌
- Concurrent Analysis: ❌

### Infrastructure
- WebFlux Config: ❌
- Tokio Runtime: ❌
- MongoDB Reactive: ❌
- WebSocket Handlers: ❌

## DO's and DON'Ts
### Java Backend
DO:
- Use reactive types (Mono/Flux)
- Implement backpressure
- Use non-blocking operations
- Handle streaming errors

DON'T:
- Block the event loop
- Use synchronous operations
- Mix reactive and blocking code
- Ignore backpressure

### Rust Backend
DO:
- Use async/await consistently
- Implement proper cancellation
- Use channels for communication
- Handle stream errors

DON'T:
- Block the Tokio runtime
- Ignore task cancellation
- Use blocking operations
- Skip error propagation

## Version History
v0.2.0 - Added async-first architecture
v0.1.0 - Initial structure

### Java Backend (Spring Boot) Async Features
```java
// ThreadConfig.java
@Configuration
public class ThreadConfig {
    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("AsyncThread-");
        executor.initialize();
        return executor;
    }
}

// AnalysisService.java
@Service
public class AnalysisService {
    @Async
    public CompletableFuture<AnalysisResult> analyzeFileAsync(MultipartFile file) {
        return CompletableFuture.supplyAsync(() -> {
            // File analysis logic
        });
    }
    
    public CompletableFuture<List<FileMetric>> processFilesParallel(List<File> files) {
        List<CompletableFuture<FileMetric>> futures = files.stream()
            .map(this::processFileAsync)
            .collect(Collectors.toList());
            
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
    
    @Async
    public CompletableFuture<FileMetric> processFileAsync(File file) {
        return CompletableFuture.supplyAsync(() -> {
            // Process single file
        });
    }
}

// AnalysisController.java
@RestController
@RequestMapping("/api/v1/analysis")
public class AnalysisController {
    @PostMapping("/async")
    public CompletableFuture<ResponseEntity<AnalysisResult>> analyzeAsync(
        @RequestParam("file") MultipartFile file
    ) {
        return analysisService.analyzeFileAsync(file)
            .thenApply(ResponseEntity::ok)
            .exceptionally(ex -> ResponseEntity.status(500).build());
    }
    
    @PostMapping("/parallel")
    public CompletableFuture<ResponseEntity<List<FileMetric>>> analyzeParallel(
        @RequestParam("files") List<MultipartFile> files
    ) {
        return analysisService.processFilesParallel(files)
            .thenApply(ResponseEntity::ok)
            .exceptionally(ex -> ResponseEntity.status(500).build());
    }
}

// ProgressTracker.java
@Service
public class ProgressTracker {
    private final Map<String, CompletableFuture<Integer>> progressMap = new ConcurrentHashMap<>();
    
    public void trackProgress(String jobId) {
        progressMap.put(jobId, new CompletableFuture<>());
    }
    
    public CompletableFuture<Integer> getProgress(String jobId) {
        return progressMap.get(jobId);
    }
    
    public void updateProgress(String jobId, int progress) {
        Optional.ofNullable(progressMap.get(jobId))
            .ifPresent(future -> future.complete(progress));
    }
}
```

### Async Processing Features
1. **Thread Pool Management**
   - Custom thread pools for different operations
   - Configurable pool sizes
   - Named threads for better monitoring

2. **Parallel Processing**
   - File chunking and parallel analysis
   - Progress tracking per chunk
   - Results aggregation

3. **Async Operations**
   - Non-blocking file uploads
   - Parallel file processing
   - Async progress updates

4. **Error Handling**
   - Exception propagation
   - Timeout management
   - Recovery strategies

### DO's
- Use appropriate thread pool sizes
- Implement proper error handling
- Monitor thread pool health
- Use CompletableFuture for composition
- Implement timeout mechanisms

### DON'Ts
- Block the event loop
- Create unlimited threads
- Ignore thread pool saturation
- Mix blocking and non-blocking code
- Skip error handling