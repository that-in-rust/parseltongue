{
  "nodes": [
    {
      "hash": 1754303143792833593,
      "kind": "Struct",
      "name": "User",
      "signature": "struct User",
      "file_path": "src/lib.rs",
      "line": 0
    },
    {
      "hash": 13375578519503559960,
      "kind": "Trait",
      "name": "Display",
      "signature": "trait Display",
      "file_path": "src/lib.rs",
      "line": 0
    },
    {
      "hash": 9478539996234197369,
      "kind": "Function",
      "name": "create_user",
      "signature": "fn pub fn create_user (name : String , age : u32) -> User { User { name , age } } . sig",
      "file_path": "src/lib.rs",
      "line": 0
    },
    {
      "hash": 12380805522957105791,
      "kind": "Function",
      "name": "main",
      "signature": "fn fn main () { let user = create_user (\"Alice\" . to_string () , 30) ; println ! (\"{}\" , user . fmt ()) ; } . sig",
      "file_path": "src/main.rs",
      "line": 0
    },
    {
      "hash": 782495314061803544,
      "kind": "Struct",
      "name": "SlowHddWriter",
      "signature": "struct SlowHddWriter",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 7635645991916988893,
      "kind": "Struct",
      "name": "ChunkReader",
      "signature": "struct ChunkReader",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 6386011504067710609,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () } . sig",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 8040039381671880880,
      "kind": "Function",
      "name": "copy_mem_to_mem",
      "signature": "fn fn copy_mem_to_mem (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_mem_to_mem\" , | b | { b . iter (| | { let task = | | async { let mut source = repeat (0) . take (SOURCE_SIZE) ; let mut dest = Vec :: new () ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 15811822568079292296,
      "kind": "Function",
      "name": "copy_mem_to_slow_hdd",
      "signature": "fn fn copy_mem_to_slow_hdd (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_mem_to_slow_hdd\" , | b | { b . iter (| | { let task = | | async { let mut source = repeat (0) . take (SOURCE_SIZE) ; let mut dest = SlowHddWriter :: new (WRITE_SERVICE_PERIOD , WRITE_BUFFER) ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 14080040348329558648,
      "kind": "Function",
      "name": "copy_chunk_to_mem",
      "signature": "fn fn copy_chunk_to_mem (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_chunk_to_mem\" , | b | { b . iter (| | { let task = | | async { let mut source = ChunkReader :: new (CHUNK_SIZE , READ_SERVICE_PERIOD) . take (SOURCE_SIZE) ; let mut dest = Vec :: new () ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 11846367610239641501,
      "kind": "Function",
      "name": "copy_chunk_to_slow_hdd",
      "signature": "fn fn copy_chunk_to_slow_hdd (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_chunk_to_slow_hdd\" , | b | { b . iter (| | { let task = | | async { let mut source = ChunkReader :: new (CHUNK_SIZE , READ_SERVICE_PERIOD) . take (SOURCE_SIZE) ; let mut dest = SlowHddWriter :: new (WRITE_SERVICE_PERIOD , WRITE_BUFFER) ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
      "file_path": "benches/copy.rs",
      "line": 0
    },
    {
      "hash": 11428664645477927786,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () } . sig",
      "file_path": "benches/fs.rs",
      "line": 0
    },
    {
      "hash": 11892167626102059349,
      "kind": "Function",
      "name": "async_read_codec",
      "signature": "fn fn async_read_codec (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_codec\" , | b | { b . iter (| | { let task = | | async { let file = File :: open (DEV_ZERO) . await . unwrap () ; let mut input_stream = FramedRead :: with_capacity (file , BytesCodec :: new () , BUFFER_SIZE) ; for _i in 0 .. BLOCK_COUNT { let _bytes = input_stream . next () . await . unwrap () ; } } ; rt . block_on (task ()) ; }) }) ; } . sig",
      "file_path": "benches/fs.rs",
      "line": 0
    },
    {
      "hash": 2601600632359889637,
      "kind": "Function",
      "name": "async_read_buf",
      "signature": "fn fn async_read_buf (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_buf\" , | b | { b . iter (| | { let task = | | async { let mut file = File :: open (DEV_ZERO) . await . unwrap () ; let mut buffer = [0u8 ; BUFFER_SIZE] ; for _i in 0 .. BLOCK_COUNT { let count = file . read (& mut buffer) . await . unwrap () ; if count == 0 { break ; } } } ; rt . block_on (task ()) ; }) ; }) ; } . sig",
      "file_path": "benches/fs.rs",
      "line": 0
    },
    {
      "hash": 15055302089181318355,
      "kind": "Function",
      "name": "async_read_std_file",
      "signature": "fn fn async_read_std_file (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_std_file\" , | b | { b . iter (| | { let task = | | async { let mut file = tokio :: task :: block_in_place (| | Box :: pin (StdFile :: open (DEV_ZERO) . unwrap ())) ; for _i in 0 .. BLOCK_COUNT { let mut buffer = [0u8 ; BUFFER_SIZE] ; let mut file_ref = file . as_mut () ; tokio :: task :: block_in_place (move | | { file_ref . read_exact (& mut buffer) . unwrap () ; }) ; } } ; rt . block_on (task ()) ; }) ; }) ; } . sig",
      "file_path": "benches/fs.rs",
      "line": 0
    },
    {
      "hash": 339218688312919021,
      "kind": "Function",
      "name": "sync_read",
      "signature": "fn fn sync_read (c : & mut Criterion) { c . bench_function (\"sync_read\" , | b | { b . iter (| | { let mut file = StdFile :: open (DEV_ZERO) . unwrap () ; let mut buffer = [0u8 ; BUFFER_SIZE] ; for _i in 0 .. BLOCK_COUNT { file . read_exact (& mut buffer) . unwrap () ; } }) }) ; } . sig",
      "file_path": "benches/fs.rs",
      "line": 0
    },
    {
      "hash": 2213906901578742718,
      "kind": "Function",
      "name": "rt_curr_spawn_many_local",
      "signature": "fn fn rt_curr_spawn_many_local (c : & mut Criterion) { let rt = rt () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_local\" , | b | { b . iter (| | { rt . block_on (async { for _ in 0 .. NUM_SPAWN { handles . push (tokio :: spawn (async move { })) ; } for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
      "file_path": "benches/rt_current_thread.rs",
      "line": 0
    },
    {
      "hash": 2136256563062662585,
      "kind": "Function",
      "name": "rt_curr_spawn_many_remote_idle",
      "signature": "fn fn rt_curr_spawn_many_remote_idle (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_remote_idle\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
      "file_path": "benches/rt_current_thread.rs",
      "line": 0
    },
    {
      "hash": 6762467444898488130,
      "kind": "Function",
      "name": "rt_curr_spawn_many_remote_busy",
      "signature": "fn fn rt_curr_spawn_many_remote_busy (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; rt . spawn (async { fn iter () { tokio :: spawn (async { iter () }) ; } iter () }) ; c . bench_function (\"spawn_many_remote_busy\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
      "file_path": "benches/rt_current_thread.rs",
      "line": 0
    },
    {
      "hash": 8463982753367750469,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> Runtime { runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "benches/rt_current_thread.rs",
      "line": 0
    },
    {
      "hash": 12157158536673476720,
      "kind": "Function",
      "name": "rt_multi_spawn_many_local",
      "signature": "fn fn rt_multi_spawn_many_local (c : & mut Criterion) { let rt = rt () ; let (tx , rx) = mpsc :: sync_channel (1000) ; let rem = Arc :: new (AtomicUsize :: new (0)) ; c . bench_function (\"spawn_many_local\" , | b | { b . iter (| | { rem . store (NUM_SPAWN , Relaxed) ; rt . block_on (async { for _ in 0 .. NUM_SPAWN { let tx = tx . clone () ; let rem = rem . clone () ; tokio :: spawn (async move { if 1 == rem . fetch_sub (1 , Relaxed) { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 10732385078068583991,
      "kind": "Function",
      "name": "rt_multi_spawn_many_remote_idle",
      "signature": "fn fn rt_multi_spawn_many_remote_idle (c : & mut Criterion) { let rt = rt () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_remote_idle\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 13079910284899692492,
      "kind": "Function",
      "name": "rt_multi_spawn_many_remote_busy1",
      "signature": "fn fn rt_multi_spawn_many_remote_busy1 (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; let flag = Arc :: new (AtomicBool :: new (true)) ; for _ in 0 .. (2 * NUM_WORKERS) { let flag = flag . clone () ; rt . spawn (async move { while flag . load (Relaxed) { tokio :: task :: yield_now () . await ; stall () ; } }) ; } c . bench_function (\"spawn_many_remote_busy1\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; flag . store (false , Relaxed) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 705251144689251397,
      "kind": "Function",
      "name": "rt_multi_spawn_many_remote_busy2",
      "signature": "fn fn rt_multi_spawn_many_remote_busy2 (c : & mut Criterion) { const NUM_SPAWN : usize = 1_000 ; let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; let flag = Arc :: new (AtomicBool :: new (true)) ; for _ in 0 .. (NUM_WORKERS) { let flag = flag . clone () ; fn iter (flag : Arc < AtomicBool >) { tokio :: spawn (async { if flag . load (Relaxed) { stall () ; iter (flag) ; } }) ; } rt . spawn (async { iter (flag) ; }) ; } c . bench_function (\"spawn_many_remote_busy2\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; flag . store (false , Relaxed) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 4116186088366884858,
      "kind": "Function",
      "name": "rt_multi_yield_many",
      "signature": "fn fn rt_multi_yield_many (c : & mut Criterion) { const NUM_YIELD : usize = 1_000 ; const TASKS : usize = 200 ; c . bench_function (\"yield_many\" , | b | { let rt = rt () ; let (tx , rx) = mpsc :: sync_channel (TASKS) ; b . iter (move | | { for _ in 0 .. TASKS { let tx = tx . clone () ; rt . spawn (async move { for _ in 0 .. NUM_YIELD { tokio :: task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; } for _ in 0 .. TASKS { rx . recv () . unwrap () ; } }) }) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 10998824331344759290,
      "kind": "Function",
      "name": "rt_multi_ping_pong",
      "signature": "fn fn rt_multi_ping_pong (c : & mut Criterion) { const NUM_PINGS : usize = 1_000 ; let rt = rt () ; let (done_tx , done_rx) = mpsc :: sync_channel (1000) ; let rem = Arc :: new (AtomicUsize :: new (0)) ; c . bench_function (\"ping_pong\" , | b | { b . iter (| | { let done_tx = done_tx . clone () ; let rem = rem . clone () ; rem . store (NUM_PINGS , Relaxed) ; rt . block_on (async { tokio :: spawn (async move { for _ in 0 .. NUM_PINGS { let rem = rem . clone () ; let done_tx = done_tx . clone () ; tokio :: spawn (async move { let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; tokio :: spawn (async move { rx1 . await . unwrap () ; tx2 . send (()) . unwrap () ; }) ; tx1 . send (()) . unwrap () ; rx2 . await . unwrap () ; if 1 == rem . fetch_sub (1 , Relaxed) { done_tx . send (()) . unwrap () ; } }) ; } }) ; done_rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 14931655529647385855,
      "kind": "Function",
      "name": "rt_multi_chained_spawn",
      "signature": "fn fn rt_multi_chained_spawn (c : & mut Criterion) { const ITER : usize = 1_000 ; fn iter (done_tx : mpsc :: SyncSender < () > , n : usize) { if n == 0 { done_tx . send (()) . unwrap () ; } else { tokio :: spawn (async move { iter (done_tx , n - 1) ; }) ; } } c . bench_function (\"chained_spawn\" , | b | { let rt = rt () ; let (done_tx , done_rx) = mpsc :: sync_channel (1000) ; b . iter (move | | { let done_tx = done_tx . clone () ; rt . block_on (async { tokio :: spawn (async move { iter (done_tx , ITER) ; }) ; done_rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 10421632034977454260,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (NUM_WORKERS) . enable_all () . build () . unwrap () } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 5368915148894380112,
      "kind": "Function",
      "name": "stall",
      "signature": "fn fn stall () { let now = Instant :: now () ; while now . elapsed () < STALL_DUR { std :: thread :: yield_now () ; } } . sig",
      "file_path": "benches/rt_multi_threaded.rs",
      "line": 0
    },
    {
      "hash": 1497609151114204349,
      "kind": "Struct",
      "name": "Spinner",
      "signature": "struct Spinner",
      "file_path": "benches/signal.rs",
      "line": 0
    },
    {
      "hash": 2753390221145042383,
      "kind": "Function",
      "name": "send_signal",
      "signature": "fn pub fn send_signal (signal : libc :: c_int) { use libc :: { getpid , kill } ; unsafe { assert_eq ! (kill (getpid () , signal) , 0) ; } } . sig",
      "file_path": "benches/signal.rs",
      "line": 0
    },
    {
      "hash": 13391494386389186027,
      "kind": "Function",
      "name": "many_signals",
      "signature": "fn fn many_signals (c : & mut Criterion) { let num_signals = 10 ; let (tx , mut rx) = mpsc :: channel (num_signals) ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let spawn_signal = | kind | { let tx = tx . clone () ; rt . spawn (async move { let mut signal = signal (kind) . expect (\"failed to create signal\") ; while signal . recv () . await . is_some () { if tx . send (()) . await . is_err () { break ; } } }) ; } ; for _ in 0 .. num_signals { spawn_signal (SignalKind :: child ()) ; spawn_signal (SignalKind :: io ()) ; } drop (tx) ; rt . block_on (Spinner :: new ()) ; c . bench_function (\"many_signals\" , | b | { b . iter (| | { rt . block_on (async { send_signal (libc :: SIGCHLD) ; for _ in 0 .. num_signals { rx . recv () . await . expect (\"channel closed\") ; } send_signal (libc :: SIGIO) ; for _ in 0 .. num_signals { rx . recv () . await . expect (\"channel closed\") ; } }) ; }) }) ; } . sig",
      "file_path": "benches/signal.rs",
      "line": 0
    },
    {
      "hash": 15208696934352534681,
      "kind": "Function",
      "name": "work",
      "signature": "fn async fn work () -> usize { let val = 1 + 1 ; tokio :: task :: yield_now () . await ; black_box (val) } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 5108509600448367569,
      "kind": "Function",
      "name": "single_rt",
      "signature": "fn fn single_rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 1978724503248293818,
      "kind": "Function",
      "name": "multi_rt",
      "signature": "fn fn multi_rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 15130594793472716234,
      "kind": "Function",
      "name": "basic_scheduler_spawn",
      "signature": "fn fn basic_scheduler_spawn (c : & mut Criterion) { let runtime = single_rt () ; c . bench_function (\"basic_scheduler_spawn\" , | b | { b . iter (| | { runtime . block_on (async { let h = tokio :: spawn (work ()) ; assert_eq ! (h . await . unwrap () , 2) ; }) ; }) }) ; } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 3186165163269653882,
      "kind": "Function",
      "name": "basic_scheduler_spawn10",
      "signature": "fn fn basic_scheduler_spawn10 (c : & mut Criterion) { let runtime = single_rt () ; c . bench_function (\"basic_scheduler_spawn10\" , | b | { b . iter (| | { runtime . block_on (async { let mut handles = Vec :: with_capacity (10) ; for _ in 0 .. 10 { handles . push (tokio :: spawn (work ())) ; } for handle in handles { assert_eq ! (handle . await . unwrap () , 2) ; } }) ; }) }) ; } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 10012883417368503377,
      "kind": "Function",
      "name": "threaded_scheduler_spawn",
      "signature": "fn fn threaded_scheduler_spawn (c : & mut Criterion) { let runtime = multi_rt () ; c . bench_function (\"threaded_scheduler_spawn\" , | b | { b . iter (| | { runtime . block_on (async { let h = tokio :: spawn (work ()) ; assert_eq ! (h . await . unwrap () , 2) ; }) ; }) }) ; } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 7468400344792312749,
      "kind": "Function",
      "name": "threaded_scheduler_spawn10",
      "signature": "fn fn threaded_scheduler_spawn10 (c : & mut Criterion) { let runtime = multi_rt () ; c . bench_function (\"threaded_scheduler_spawn10\" , | b | { b . iter (| | { runtime . block_on (async { let mut handles = Vec :: with_capacity (10) ; for _ in 0 .. 10 { handles . push (tokio :: spawn (work ())) ; } for handle in handles { assert_eq ! (handle . await . unwrap () , 2) ; } }) ; }) }) ; } . sig",
      "file_path": "benches/spawn.rs",
      "line": 0
    },
    {
      "hash": 7886311824065114452,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () } . sig",
      "file_path": "benches/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 196373074395164667,
      "kind": "Function",
      "name": "do_work",
      "signature": "fn fn do_work (rng : & mut impl RngCore) -> u32 { use std :: fmt :: Write ; let mut message = String :: new () ; for i in 1 ..= 10 { let _ = write ! (& mut message , \" {i}={}\" , rng . random ::< f64 > ()) ; } message . as_bytes () . iter () . map (| & c | c as u32) . fold (0 , u32 :: wrapping_add) } . sig",
      "file_path": "benches/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 5543072255322394519,
      "kind": "Function",
      "name": "contention_impl",
      "signature": "fn fn contention_impl < const N_TASKS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let (tx , _rx) = broadcast :: channel :: < usize > (1000) ; let wg = Arc :: new ((AtomicUsize :: new (0) , Notify :: new ())) ; for n in 0 .. N_TASKS { let wg = wg . clone () ; let mut rx = tx . subscribe () ; let mut rng = rand :: rngs :: StdRng :: seed_from_u64 (n as u64) ; rt . spawn (async move { while (rx . recv () . await) . is_ok () { let r = do_work (& mut rng) ; let _ = black_box (r) ; if wg . 0 . fetch_sub (1 , Ordering :: Relaxed) == 1 { wg . 1 . notify_one () ; } } }) ; } const N_ITERS : usize = 100 ; g . bench_function (N_TASKS . to_string () , | b | { b . iter (| | { rt . block_on ({ let wg = wg . clone () ; let tx = tx . clone () ; async move { for i in 0 .. N_ITERS { assert_eq ! (wg . 0 . fetch_add (N_TASKS , Ordering :: Relaxed) , 0) ; tx . send (i) . unwrap () ; while wg . 0 . load (Ordering :: Relaxed) > 0 { wg . 1 . notified () . await ; } } } }) }) }) ; } . sig",
      "file_path": "benches/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 7165045759250376301,
      "kind": "Function",
      "name": "bench_contention",
      "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contention_impl :: < 10 > (& mut group) ; contention_impl :: < 100 > (& mut group) ; contention_impl :: < 500 > (& mut group) ; contention_impl :: < 1000 > (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 10601889478949083141,
      "kind": "Struct",
      "name": "Medium",
      "signature": "struct Medium",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 17203319456327759372,
      "kind": "Struct",
      "name": "Large",
      "signature": "struct Large",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 284109764973474238,
      "kind": "Function",
      "name": "create_medium",
      "signature": "fn fn create_medium < const SIZE : usize > (g : & mut BenchmarkGroup < WallTime >) { g . bench_function (SIZE . to_string () , | b | { b . iter (| | { black_box (& mpsc :: channel :: < Medium > (SIZE)) ; }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13632390554809176656,
      "kind": "Function",
      "name": "send_data",
      "signature": "fn fn send_data < T : Default , const SIZE : usize > (g : & mut BenchmarkGroup < WallTime > , prefix : & str) { let rt = rt () ; g . bench_function (format ! (\"{prefix}_{SIZE}\") , | b | { b . iter (| | { let (tx , mut rx) = mpsc :: channel :: < T > (SIZE) ; let _ = rt . block_on (tx . send (T :: default ())) ; rt . block_on (rx . recv ()) . unwrap () ; }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10955401617669901620,
      "kind": "Function",
      "name": "contention_bounded",
      "signature": "fn fn contention_bounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10587070179582426513,
      "kind": "Function",
      "name": "contention_bounded_recv_many",
      "signature": "fn fn contention_bounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5746529586947021232,
      "kind": "Function",
      "name": "contention_bounded_full",
      "signature": "fn fn contention_bounded_full (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_full\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (100) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15032288475723247489,
      "kind": "Function",
      "name": "contention_bounded_full_recv_many",
      "signature": "fn fn contention_bounded_full_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_full_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (100) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4469389701899456143,
      "kind": "Function",
      "name": "contention_unbounded",
      "signature": "fn fn contention_unbounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3490394318707973541,
      "kind": "Function",
      "name": "contention_unbounded_recv_many",
      "signature": "fn fn contention_unbounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15849854129881151396,
      "kind": "Function",
      "name": "uncontented_bounded",
      "signature": "fn fn uncontented_bounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for i in 0 .. 5000 { tx . send (i) . await . unwrap () ; } for _ in 0 .. 5_000 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10284260857654608722,
      "kind": "Function",
      "name": "uncontented_bounded_recv_many",
      "signature": "fn fn uncontented_bounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for i in 0 .. 5000 { tx . send (i) . await . unwrap () ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 8496119722228829003,
      "kind": "Function",
      "name": "uncontented_unbounded",
      "signature": "fn fn uncontented_unbounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for i in 0 .. 5000 { tx . send (i) . unwrap () ; } for _ in 0 .. 5_000 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13598681871398747001,
      "kind": "Function",
      "name": "uncontented_unbounded_recv_many",
      "signature": "fn fn uncontented_unbounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for i in 0 .. 5000 { tx . send (i) . unwrap () ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9627108148605252378,
      "kind": "Function",
      "name": "bench_create_medium",
      "signature": "fn fn bench_create_medium (c : & mut Criterion) { let mut group = c . benchmark_group (\"create_medium\") ; create_medium :: < 1 > (& mut group) ; create_medium :: < 100 > (& mut group) ; create_medium :: < 100_000 > (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3128692007366943253,
      "kind": "Function",
      "name": "bench_send",
      "signature": "fn fn bench_send (c : & mut Criterion) { let mut group = c . benchmark_group (\"send\") ; send_data :: < Medium , 1000 > (& mut group , \"medium\") ; send_data :: < Large , 1000 > (& mut group , \"large\") ; group . finish () ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5843819642543933941,
      "kind": "Function",
      "name": "bench_contention",
      "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contention_bounded (& mut group) ; contention_bounded_recv_many (& mut group) ; contention_bounded_full (& mut group) ; contention_bounded_full_recv_many (& mut group) ; contention_unbounded (& mut group) ; contention_unbounded_recv_many (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4659747989772400192,
      "kind": "Function",
      "name": "bench_uncontented",
      "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; uncontented_bounded (& mut group) ; uncontented_bounded_recv_many (& mut group) ; uncontented_unbounded (& mut group) ; uncontented_unbounded_recv_many (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15119419807308025490,
      "kind": "Function",
      "name": "request_reply_current_thread",
      "signature": "fn fn request_reply_current_thread (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; request_reply (c , rt) ; } . sig",
      "file_path": "benches/sync_mpsc_oneshot.rs",
      "line": 0
    },
    {
      "hash": 14430461784745610059,
      "kind": "Function",
      "name": "request_reply_multi_threaded",
      "signature": "fn fn request_reply_multi_threaded (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; request_reply (c , rt) ; } . sig",
      "file_path": "benches/sync_mpsc_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13651396776667968478,
      "kind": "Function",
      "name": "request_reply",
      "signature": "fn fn request_reply (b : & mut Criterion , rt : Runtime) { let tx = rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < oneshot :: Sender < () > > (10) ; tokio :: spawn (async move { while let Some (reply) = rx . recv () . await { reply . send (()) . unwrap () ; } }) ; tx }) ; b . bench_function (\"request_reply\" , | b | { b . iter (| | { let task_tx = tx . clone () ; rt . block_on (async move { for _ in 0 .. 1_000 { let (o_tx , o_rx) = oneshot :: channel () ; task_tx . send (o_tx) . await . unwrap () ; let _ = o_rx . await ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_mpsc_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13754973174505307145,
      "kind": "Function",
      "name": "notify_waiters",
      "signature": "fn fn notify_waiters < const N_WAITERS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let notify = Arc :: new (Notify :: new ()) ; let counter = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. N_WAITERS { rt . spawn ({ let notify = notify . clone () ; let counter = counter . clone () ; async move { loop { notify . notified () . await ; counter . fetch_add (1 , Ordering :: Relaxed) ; } } }) ; } const N_ITERS : usize = 500 ; g . bench_function (N_WAITERS . to_string () , | b | { b . iter (| | { counter . store (0 , Ordering :: Relaxed) ; loop { notify . notify_waiters () ; if counter . load (Ordering :: Relaxed) >= N_ITERS { break ; } } }) }) ; } . sig",
      "file_path": "benches/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 5571932447866150670,
      "kind": "Function",
      "name": "notify_one",
      "signature": "fn fn notify_one < const N_WAITERS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let notify = Arc :: new (Notify :: new ()) ; let counter = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. N_WAITERS { rt . spawn ({ let notify = notify . clone () ; let counter = counter . clone () ; async move { loop { notify . notified () . await ; counter . fetch_add (1 , Ordering :: Relaxed) ; } } }) ; } const N_ITERS : usize = 500 ; g . bench_function (N_WAITERS . to_string () , | b | { b . iter (| | { counter . store (0 , Ordering :: Relaxed) ; loop { notify . notify_one () ; if counter . load (Ordering :: Relaxed) >= N_ITERS { break ; } } }) }) ; } . sig",
      "file_path": "benches/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 14710489399998490680,
      "kind": "Function",
      "name": "bench_notify_one",
      "signature": "fn fn bench_notify_one (c : & mut Criterion) { let mut group = c . benchmark_group (\"notify_one\") ; notify_one :: < 10 > (& mut group) ; notify_one :: < 50 > (& mut group) ; notify_one :: < 100 > (& mut group) ; notify_one :: < 200 > (& mut group) ; notify_one :: < 500 > (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 5375750230042360037,
      "kind": "Function",
      "name": "bench_notify_waiters",
      "signature": "fn fn bench_notify_waiters (c : & mut Criterion) { let mut group = c . benchmark_group (\"notify_waiters\") ; notify_waiters :: < 10 > (& mut group) ; notify_waiters :: < 50 > (& mut group) ; notify_waiters :: < 100 > (& mut group) ; notify_waiters :: < 200 > (& mut group) ; notify_waiters :: < 500 > (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 1351882046899069484,
      "kind": "Function",
      "name": "read_uncontended",
      "signature": "fn fn read_uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { for _ in 0 .. 6 { let read = lock . read () . await ; let _read = black_box (read) ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 1025567070135869735,
      "kind": "Function",
      "name": "read_concurrent_uncontended_multi",
      "signature": "fn fn read_concurrent_uncontended_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent_multi\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 17771570071816071969,
      "kind": "Function",
      "name": "read_concurrent_uncontended",
      "signature": "fn fn read_concurrent_uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { tokio :: join ! { task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) } ; }) }) }) ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 10445821578355120876,
      "kind": "Function",
      "name": "read_concurrent_contended_multi",
      "signature": "fn fn read_concurrent_contended_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent_multi\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let write = lock . write () . await ; let j = tokio :: try_join ! { async move { drop (write) ; Ok (()) } , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , } ; j . unwrap () ; }) }) }) ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 8903025386700765843,
      "kind": "Function",
      "name": "read_concurrent_contended",
      "signature": "fn fn read_concurrent_contended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let write = lock . write () . await ; tokio :: join ! { async move { drop (write) } , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , } ; }) }) }) ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 11729873062108442467,
      "kind": "Function",
      "name": "bench_contention",
      "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; read_concurrent_contended (& mut group) ; read_concurrent_contended_multi (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 5147374163319315231,
      "kind": "Function",
      "name": "bench_uncontented",
      "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; read_uncontended (& mut group) ; read_concurrent_uncontended (& mut group) ; read_concurrent_uncontended_multi (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 10432018048112891593,
      "kind": "Function",
      "name": "single_rt",
      "signature": "fn fn single_rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 11697422185244279928,
      "kind": "Function",
      "name": "multi_rt",
      "signature": "fn fn multi_rt () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 19770281976110512,
      "kind": "Function",
      "name": "uncontended",
      "signature": "fn fn uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { for _ in 0 .. 6 { let permit = s . acquire () . await ; drop (permit) ; } }) }) }) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 11673157008334545269,
      "kind": "Function",
      "name": "task",
      "signature": "fn async fn task (s : Arc < Semaphore >) { let permit = s . acquire () . await ; drop (permit) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 3344189626437515550,
      "kind": "Function",
      "name": "uncontended_concurrent_multi",
      "signature": "fn fn uncontended_concurrent_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"concurrent_multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 4124895664904801390,
      "kind": "Function",
      "name": "uncontended_concurrent_single",
      "signature": "fn fn uncontended_concurrent_single (g : & mut BenchmarkGroup < WallTime >) { let rt = single_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"concurrent_single\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { tokio :: join ! { task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) } ; }) }) }) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 7455476315844284338,
      "kind": "Function",
      "name": "contended_concurrent_multi",
      "signature": "fn fn contended_concurrent_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (5)) ; g . bench_function (\"concurrent_multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 17288686781090577103,
      "kind": "Function",
      "name": "contended_concurrent_single",
      "signature": "fn fn contended_concurrent_single (g : & mut BenchmarkGroup < WallTime >) { let rt = single_rt () ; let s = Arc :: new (Semaphore :: new (5)) ; g . bench_function (\"concurrent_single\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { tokio :: join ! { task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) } ; }) }) }) ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 4342374447523678648,
      "kind": "Function",
      "name": "bench_contention",
      "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contended_concurrent_multi (& mut group) ; contended_concurrent_single (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 5249008699462650691,
      "kind": "Function",
      "name": "bench_uncontented",
      "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; uncontended (& mut group) ; uncontended_concurrent_multi (& mut group) ; uncontended_concurrent_single (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 16621534797823914177,
      "kind": "Function",
      "name": "contention_resubscribe",
      "signature": "fn fn contention_resubscribe < const N_TASKS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let (snd , _) = watch :: channel (0i32) ; let snd = Arc :: new (snd) ; let wg = Arc :: new ((AtomicU64 :: new (0) , Notify :: new ())) ; for n in 0 .. N_TASKS { let mut rcv = snd . subscribe () ; let wg = wg . clone () ; let mut rng = rand :: rngs :: StdRng :: seed_from_u64 (n as u64) ; rt . spawn (async move { while rcv . changed () . await . is_ok () { let _ = * rcv . borrow () ; let r = do_work (& mut rng) ; let _ = black_box (r) ; if wg . 0 . fetch_sub (1 , Ordering :: Release) == 1 { wg . 1 . notify_one () ; } } }) ; } const N_ITERS : usize = 100 ; g . bench_function (N_TASKS . to_string () , | b | { b . iter (| | { rt . block_on ({ let snd = snd . clone () ; let wg = wg . clone () ; async move { tokio :: spawn (async move { for _ in 0 .. N_ITERS { assert_eq ! (wg . 0 . fetch_add (N_TASKS as u64 , Ordering :: Relaxed) , 0) ; let _ = snd . send (black_box (42)) ; while wg . 0 . load (Ordering :: Acquire) > 0 { wg . 1 . notified () . await ; } } }) . await . unwrap () ; } }) ; }) }) ; } . sig",
      "file_path": "benches/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 4402015633310230300,
      "kind": "Function",
      "name": "bench_contention_resubscribe",
      "signature": "fn fn bench_contention_resubscribe (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention_resubscribe\") ; contention_resubscribe :: < 10 > (& mut group) ; contention_resubscribe :: < 100 > (& mut group) ; contention_resubscribe :: < 500 > (& mut group) ; contention_resubscribe :: < 1000 > (& mut group) ; group . finish () ; } . sig",
      "file_path": "benches/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 3185735659588891712,
      "kind": "Function",
      "name": "time_now_current_thread",
      "signature": "fn fn time_now_current_thread (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; c . bench_function (\"time_now_current_thread\" , | b | { b . iter (| | { rt . block_on (async { black_box (tokio :: time :: Instant :: now ()) ; }) }) }) ; } . sig",
      "file_path": "benches/time_now.rs",
      "line": 0
    },
    {
      "hash": 14792906302130009240,
      "kind": "Function",
      "name": "quick_job",
      "signature": "fn async fn quick_job () -> usize { 1 } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 8993899945515075160,
      "kind": "Function",
      "name": "build_run_time",
      "signature": "fn fn build_run_time (workers : usize) -> Runtime { if workers == 1 { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } else { tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (workers) . build () . unwrap () } } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 5073503061651803391,
      "kind": "Function",
      "name": "single_thread_scheduler_timeout",
      "signature": "fn fn single_thread_scheduler_timeout (c : & mut Criterion) { do_timeout_test (c , 1 , \"single_thread_timeout\") ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 4834160861541795551,
      "kind": "Function",
      "name": "multi_thread_scheduler_timeout",
      "signature": "fn fn multi_thread_scheduler_timeout (c : & mut Criterion) { do_timeout_test (c , 8 , \"multi_thread_timeout-8\") ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 2524943235706643897,
      "kind": "Function",
      "name": "do_timeout_test",
      "signature": "fn fn do_timeout_test (c : & mut Criterion , workers : usize , name : & str) { let runtime = build_run_time (workers) ; c . bench_function (name , | b | { b . iter_custom (| iters | { let start = Instant :: now () ; runtime . block_on (async { black_box (spawn_timeout_job (iters as usize , workers)) . await ; }) ; start . elapsed () }) }) ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 14380159736273179793,
      "kind": "Function",
      "name": "spawn_timeout_job",
      "signature": "fn async fn spawn_timeout_job (iters : usize , procs : usize) { let mut handles = Vec :: with_capacity (procs) ; for _ in 0 .. procs { handles . push (tokio :: spawn (async move { for _ in 0 .. iters / procs { let h = timeout (Duration :: from_secs (1) , quick_job ()) ; assert_eq ! (black_box (h . await . unwrap ()) , 1) ; } })) ; } for handle in handles { handle . await . unwrap () ; } } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 4727100421541293655,
      "kind": "Function",
      "name": "single_thread_scheduler_sleep",
      "signature": "fn fn single_thread_scheduler_sleep (c : & mut Criterion) { do_sleep_test (c , 1 , \"single_thread_sleep\") ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 8213706198631922335,
      "kind": "Function",
      "name": "multi_thread_scheduler_sleep",
      "signature": "fn fn multi_thread_scheduler_sleep (c : & mut Criterion) { do_sleep_test (c , 8 , \"multi_thread_sleep-8\") ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 9116727159267257816,
      "kind": "Function",
      "name": "do_sleep_test",
      "signature": "fn fn do_sleep_test (c : & mut Criterion , workers : usize , name : & str) { let runtime = build_run_time (workers) ; c . bench_function (name , | b | { b . iter_custom (| iters | { let start = Instant :: now () ; runtime . block_on (async { black_box (spawn_sleep_job (iters as usize , workers)) . await ; }) ; start . elapsed () }) }) ; } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 11559623218537315581,
      "kind": "Function",
      "name": "spawn_sleep_job",
      "signature": "fn async fn spawn_sleep_job (iters : usize , procs : usize) { let mut handles = Vec :: with_capacity (procs) ; for _ in 0 .. procs { handles . push (tokio :: spawn (async move { for _ in 0 .. iters / procs { let _h = black_box (sleep (Duration :: from_secs (1))) ; } })) ; } for handle in handles { handle . await . unwrap () ; } } . sig",
      "file_path": "benches/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 11551544641386792207,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { use tracing_subscriber :: { fmt :: format :: FmtSpan , EnvFilter } ; tracing_subscriber :: fmt () . with_env_filter (EnvFilter :: from_default_env () . add_directive (\"chat=info\" . parse () ?)) . with_span_events (FmtSpan :: FULL) . init () ; let state = Arc :: new (Mutex :: new (Shared :: new ())) ; let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:6142\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; tracing :: info ! (\"server running on {}\" , addr) ; loop { let (stream , addr) = listener . accept () . await ? ; let state = Arc :: clone (& state) ; tokio :: spawn (async move { tracing :: debug ! (\"accepted connection\") ; if let Err (e) = process (state , stream , addr) . await { tracing :: info ! (\"an error occurred; error = {:?}\" , e) ; } }) ; } } . sig",
      "file_path": "examples/chat.rs",
      "line": 0
    },
    {
      "hash": 1419165564758801161,
      "kind": "Struct",
      "name": "Shared",
      "signature": "struct Shared",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 15685334094175579962,
      "kind": "Struct",
      "name": "Peer",
      "signature": "struct Peer",
      "file_path": "examples/chat.rs",
      "line": 0
    },
    {
      "hash": 15789457802279625204,
      "kind": "Function",
      "name": "process",
      "signature": "fn # [doc = \" Process an individual chat client\"] async fn process (state : Arc < Mutex < Shared > > , stream : TcpStream , addr : SocketAddr ,) -> Result < () , Box < dyn Error > > { let mut lines = Framed :: new (stream , LinesCodec :: new ()) ; lines . send (\"Please enter your username:\") . await ? ; let username = match lines . next () . await { Some (Ok (line)) => line , _ => { tracing :: error ! (\"Failed to get username from {}. Client disconnected.\" , addr) ; return Ok (()) ; } } ; let mut peer = Peer :: new (state . clone () , lines) . await ? ; { let mut state = state . lock () . await ; let msg = format ! (\"{username} has joined the chat\") ; tracing :: info ! (\"{}\" , msg) ; state . broadcast (addr , & msg) . await ; } loop { tokio :: select ! { Some (msg) = peer . rx . recv () => { peer . lines . send (& msg) . await ?; } result = peer . lines . next () => match result { Some (Ok (msg)) => { let mut state = state . lock () . await ; let msg = format ! (\"{username}: {msg}\") ; state . broadcast (addr , & msg) . await ; } Some (Err (e)) => { tracing :: error ! (\"an error occurred while processing messages for {}; error = {:?}\" , username , e) ; } None => break , } , } } { let mut state = state . lock () . await ; state . peers . remove (& addr) ; let msg = format ! (\"{username} has left the chat\") ; tracing :: info ! (\"{}\" , msg) ; state . broadcast (addr , & msg) . await ; } Ok (()) } . sig",
      "file_path": "examples/chat.rs",
      "line": 0
    },
    {
      "hash": 15882921914634354828,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let args = env :: args () . skip (1) . collect :: < Vec < _ > > () ; let addr = args . first () . ok_or (\"this program requires at least one argument\") ? ; let addr = addr . parse :: < SocketAddr > () ? ; let stdin = FramedRead :: new (stdin () , BytesCodec :: new ()) ; let stdin = stdin . map (| i | i . map (| bytes | bytes . freeze ())) ; let stdout = FramedWrite :: new (stdout () , BytesCodec :: new ()) ; connect (& addr , stdin , stdout) . await ? ; Ok (()) } . sig",
      "file_path": "examples/connect-udp.rs",
      "line": 0
    },
    {
      "hash": 16483752364984537792,
      "kind": "Function",
      "name": "connect",
      "signature": "fn pub async fn connect (addr : & SocketAddr , mut stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , mut stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin ,) -> Result < () , Box < dyn Error > > { let mut stream = TcpStream :: connect (addr) . await ? ; let (r , w) = stream . split () ; let mut sink = FramedWrite :: new (w , BytesCodec :: new ()) ; let mut stream = FramedRead :: new (r , BytesCodec :: new ()) . filter_map (| i | match i { Ok (i) => future :: ready (Some (i . freeze ())) , Err (e) => { println ! (\"failed to read from socket; error={e}\") ; future :: ready (None) } }) . map (Ok) ; match future :: join (sink . send_all (& mut stdin) , stdout . send_all (& mut stream)) . await { (Err (e) , _) | (_ , Err (e)) => Err (e . into ()) , _ => Ok (()) , } } . sig",
      "file_path": "examples/connect-tcp.rs",
      "line": 0
    },
    {
      "hash": 16457032768667519830,
      "kind": "Function",
      "name": "connect",
      "signature": "fn pub async fn connect (addr : & SocketAddr , stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin ,) -> Result < () , Box < dyn Error > > { let bind_addr = if addr . ip () . is_ipv4 () { \"0.0.0.0:0\" } else { \"[::]:0\" } ; let socket = UdpSocket :: bind (& bind_addr) . await ? ; socket . connect (addr) . await ? ; tokio :: try_join ! (send (stdin , & socket) , recv (stdout , & socket)) ? ; Ok (()) } . sig",
      "file_path": "examples/connect-udp.rs",
      "line": 0
    },
    {
      "hash": 10758881178593439141,
      "kind": "Function",
      "name": "send",
      "signature": "fn async fn send (mut stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , writer : & UdpSocket ,) -> Result < () , std :: io :: Error > { while let Some (item) = stdin . next () . await { let buf = item ? ; writer . send (& buf [..]) . await ? ; } Ok (()) } . sig",
      "file_path": "examples/connect-udp.rs",
      "line": 0
    },
    {
      "hash": 13850957075240580409,
      "kind": "Function",
      "name": "recv",
      "signature": "fn async fn recv (mut stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin , reader : & UdpSocket ,) -> Result < () , std :: io :: Error > { loop { let mut buf = vec ! [0 ; 1024] ; let n = reader . recv (& mut buf [..]) . await ? ; if n > 0 { stdout . send (Bytes :: copy_from_slice (& buf [.. n])) . await ? ; } } } . sig",
      "file_path": "examples/connect-udp.rs",
      "line": 0
    },
    {
      "hash": 5837657666803958326,
      "kind": "Function",
      "name": "main",
      "signature": "fn fn main () { let (tx , rx) = oneshot :: channel () ; let rt1 = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; rt1 . block_on (rt2 . wrap (async move { let listener = TcpListener :: bind (\"0.0.0.0:0\") . await . unwrap () ; println ! (\"addr: {:?}\" , listener . local_addr ()) ; tx . send (()) . unwrap () ; })) ; futures :: executor :: block_on (rx) . unwrap () ; } . sig",
      "file_path": "examples/custom-executor-tokio-context.rs",
      "line": 0
    },
    {
      "hash": 174782292472203960,
      "kind": "Function",
      "name": "main",
      "signature": "fn fn main () { let (tx , rx) = oneshot :: channel () ; my_custom_runtime :: spawn (async move { let listener = TcpListener :: bind (\"0.0.0.0:0\") . await . unwrap () ; println ! (\"addr: {:?}\" , listener . local_addr ()) ; tx . send (()) . unwrap () ; }) ; futures :: executor :: block_on (rx) . unwrap () ; } . sig",
      "file_path": "examples/custom-executor.rs",
      "line": 0
    },
    {
      "hash": 9072440451744452079,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [cfg (all (tokio_unstable , tokio_taskdump , target_os = \"linux\" , any (target_arch = \"aarch64\" , target_arch = \"x86\" , target_arch = \"x86_64\")))] # [tokio :: main] async fn main () -> Result < () , Box < dyn std :: error :: Error > > { use std :: sync :: Arc ; use tokio :: sync :: Barrier ; # [inline (never)] async fn a (barrier : Arc < Barrier >) { b (barrier) . await } # [inline (never)] async fn b (barrier : Arc < Barrier >) { c (barrier) . await } # [inline (never)] async fn c (barrier : Arc < Barrier >) { barrier . wait () . await ; } async fn dump_or_quit () { use tokio :: time :: { timeout , Duration , Instant } ; let handle = tokio :: runtime :: Handle :: current () ; let mut last_signal : Option < Instant > = None ; while let Ok (_) = tokio :: signal :: ctrl_c () . await { if let Some (time_since_last_signal) = last_signal . map (| i | i . elapsed ()) { if time_since_last_signal < Duration :: from_secs (1) { return ; } } last_signal = Some (Instant :: now ()) ; println ! (\"{:-<80}\" , \"\") ; if let Ok (dump) = timeout (Duration :: from_secs (2) , handle . dump ()) . await { for task in dump . tasks () . iter () { let id = task . id () ; let trace = task . trace () ; println ! (\"TASK {id}:\") ; println ! (\"{trace}\\n\") ; } } else { println ! (\"Task dumping timed out. Use a native debugger (like gdb) to debug the deadlock.\") ; } println ! (\"{:-<80}\" , \"\") ; println ! (\"Input CTRL+C twice within 1 second to exit.\") ; } } println ! (\"This program has a deadlock.\") ; println ! (\"Input CTRL+C to print a task dump.\") ; println ! (\"Input CTRL+C twice within 1 second to exit.\") ; let barrier = Arc :: new (Barrier :: new (3)) ; let task_1 = tokio :: spawn (a (barrier . clone ())) ; let task_2 = tokio :: spawn (a (barrier)) ; tokio :: select ! (_ = dump_or_quit () => { } , _ = task_1 => { } , _ = task_2 => { } ,) ; Ok (()) } . sig",
      "file_path": "examples/dump.rs",
      "line": 0
    },
    {
      "hash": 15064414657331075357,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [cfg (not (all (tokio_unstable , tokio_taskdump , target_os = \"linux\" , any (target_arch = \"aarch64\" , target_arch = \"x86\" , target_arch = \"x86_64\"))))] fn main () { println ! (\"task dumps are not available\") } . sig",
      "file_path": "examples/dump.rs",
      "line": 0
    },
    {
      "hash": 15091977743863913824,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (mut socket , _) = listener . accept () . await ? ; tokio :: spawn (async move { let mut buf = vec ! [0 ; 1024] ; loop { let n = socket . read (& mut buf) . await . expect (\"failed to read data from socket\") ; if n == 0 { return ; } socket . write_all (& buf [0 .. n]) . await . expect (\"failed to write data to socket\") ; } }) ; } } . sig",
      "file_path": "examples/echo-tcp.rs",
      "line": 0
    },
    {
      "hash": 14789709377044601594,
      "kind": "Struct",
      "name": "Server",
      "signature": "struct Server",
      "file_path": "examples/echo-udp.rs",
      "line": 0
    },
    {
      "hash": 16475712140738982831,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let socket = UdpSocket :: bind (& addr) . await ? ; println ! (\"Listening on: {}\" , socket . local_addr () ?) ; let server = Server { socket , buf : vec ! [0 ; 1024] , to_send : None , } ; server . run () . await ? ; Ok (()) } . sig",
      "file_path": "examples/echo-udp.rs",
      "line": 0
    },
    {
      "hash": 2608673707562504959,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] pub async fn main () -> Result < () , Box < dyn Error > > { let mut stream = TcpStream :: connect (\"127.0.0.1:6142\") . await ? ; println ! (\"created stream\") ; let result = stream . write_all (b\"hello world\\n\") . await ; println ! (\"wrote to stream; success={:?}\" , result . is_ok ()) ; Ok (()) } . sig",
      "file_path": "examples/hello_world.rs",
      "line": 0
    },
    {
      "hash": 6535380762414719854,
      "kind": "Function",
      "name": "windows_main",
      "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use std :: time :: Duration ; use tokio :: io :: { AsyncReadExt , AsyncWriteExt } ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; use tokio :: time ; use windows_sys :: Win32 :: Foundation :: ERROR_PIPE_BUSY ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-multi-client\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . first_pipe_instance (true) . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { time :: sleep (Duration :: from_secs (1)) . await ; for _ in 0 .. N { server . connect () . await ? ; let mut inner = server ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; let _ = tokio :: spawn (async move { let mut buf = vec ! [0u8 ; 4] ; inner . read_exact (& mut buf) . await ? ; inner . write_all (b\"pong\") . await ? ; Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let mut client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (5)) . await ; } ; let mut buf = [0u8 ; 4] ; client . write_all (b\"ping\") . await ? ; client . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (& result ? [..] , b\"pong\") ; } server . await ? ? ; Ok (()) } . sig",
      "file_path": "examples/named-pipe-multi-client.rs",
      "line": 0
    },
    {
      "hash": 8637040308360218464,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> io :: Result < () > { # [cfg (windows)] { windows_main () . await ? ; } # [cfg (not (windows))] { println ! (\"Named pipes are only supported on Windows!\") ; } Ok (()) } . sig",
      "file_path": "examples/named-pipe.rs",
      "line": 0
    },
    {
      "hash": 9602313957704650921,
      "kind": "Function",
      "name": "windows_main",
      "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use tokio :: io :: Interest ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let buf = { let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; loop { server . readable () . await ? ; let buf = & mut read_buf [read_buf_cursor ..] ; match server . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } read_buf } ; { let write_buf = b\"pong\\n\" ; let mut write_buf_cursor = 0 ; loop { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { break ; } server . writable () . await ? ; match server . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; let write_buf = b\"ping\\n\" ; let mut write_buf_cursor = 0 ; loop { let mut interest = Interest :: READABLE ; if write_buf_cursor < write_buf . len () { interest |= Interest :: WRITABLE ; } let ready = client . ready (interest) . await ? ; if ready . is_readable () { let buf = & mut read_buf [read_buf_cursor ..] ; match client . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } if ready . is_writable () { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { continue ; } match client . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } let buf = String :: from_utf8_lossy (& read_buf) . into_owned () ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, * b\"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
      "file_path": "examples/named-pipe-ready.rs",
      "line": 0
    },
    {
      "hash": 6718301638312679342,
      "kind": "Function",
      "name": "windows_main",
      "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use tokio :: io :: AsyncWriteExt ; use tokio :: io :: { AsyncBufReadExt , BufReader } ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let mut server = BufReader :: new (server) ; let mut buf = String :: new () ; server . read_line (& mut buf) . await ? ; server . write_all (b\"pong\\n\") . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, \"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
      "file_path": "examples/named-pipe.rs",
      "line": 0
    },
    {
      "hash": 17779897337899809008,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn std :: error :: Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (socket , _) = listener . accept () . await ? ; tokio :: spawn (async move { let mut framed = BytesCodec :: new () . framed (socket) ; while let Some (message) = framed . next () . await { match message { Ok (bytes) => println ! (\"bytes: {bytes:?}\") , Err (err) => println ! (\"Socket closed with error: {err:?}\") , } } println ! (\"Socket received FIN packet and closed connection\") ; }) ; } } . sig",
      "file_path": "examples/print_each_packet.rs",
      "line": 0
    },
    {
      "hash": 7090192846832661758,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let listen_addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8081\" . to_string ()) ; let server_addr = env :: args () . nth (2) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; println ! (\"Listening on: {listen_addr}\") ; println ! (\"Proxying to: {server_addr}\") ; let listener = TcpListener :: bind (listen_addr) . await ? ; while let Ok ((mut inbound , _)) = listener . accept () . await { let mut outbound = TcpStream :: connect (server_addr . clone ()) . await ? ; tokio :: spawn (async move { copy_bidirectional (& mut inbound , & mut outbound) . map (| r | { if let Err (e) = r { println ! (\"Failed to transfer; error={e}\") ; } }) . await }) ; } Ok (()) } . sig",
      "file_path": "examples/proxy.rs",
      "line": 0
    },
    {
      "hash": 9384724845665485774,
      "kind": "Struct",
      "name": "Database",
      "signature": "struct Database",
      "file_path": "examples/tinydb.rs",
      "line": 0
    },
    {
      "hash": 588120491625911312,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; let mut initial_db = HashMap :: new () ; initial_db . insert (\"foo\" . to_string () , \"bar\" . to_string ()) ; let db = Arc :: new (Database { map : Mutex :: new (initial_db) , }) ; loop { match listener . accept () . await { Ok ((socket , _)) => { let db = db . clone () ; tokio :: spawn (async move { let mut lines = Framed :: new (socket , LinesCodec :: new ()) ; while let Some (result) = lines . next () . await { match result { Ok (line) => { let response = handle_request (& line , & db) ; let response = response . serialize () ; if let Err (e) = lines . send (response . as_str ()) . await { println ! (\"error on sending response; error = {e:?}\") ; } } Err (e) => { println ! (\"error on decoding from socket; error = {e:?}\") ; } } } }) ; } Err (e) => println ! (\"error accepting socket; error = {e:?}\") , } } } . sig",
      "file_path": "examples/tinydb.rs",
      "line": 0
    },
    {
      "hash": 13759305022884304069,
      "kind": "Function",
      "name": "handle_request",
      "signature": "fn fn handle_request (line : & str , db : & Arc < Database >) -> Response { let request = match Request :: parse (line) { Ok (req) => req , Err (e) => return Response :: Error { msg : e } , } ; let mut db = db . map . lock () . unwrap () ; match request { Request :: Get { key } => match db . get (& key) { Some (value) => Response :: Value { key , value : value . clone () , } , None => Response :: Error { msg : format ! (\"no key {key}\") , } , } , Request :: Set { key , value } => { let previous = db . insert (key . clone () , value . clone ()) ; Response :: Set { key , value , previous , } } } } . sig",
      "file_path": "examples/tinydb.rs",
      "line": 0
    },
    {
      "hash": 7997845625382229939,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let server = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (stream , _) = server . accept () . await ? ; tokio :: spawn (async move { if let Err (e) = process (stream) . await { println ! (\"failed to process connection; error = {e}\") ; } }) ; } } . sig",
      "file_path": "examples/tinyhttp.rs",
      "line": 0
    },
    {
      "hash": 4094305325795039478,
      "kind": "Function",
      "name": "process",
      "signature": "fn async fn process (stream : TcpStream) -> Result < () , Box < dyn Error > > { let mut transport = Framed :: new (stream , Http) ; while let Some (request) = transport . next () . await { match request { Ok (request) => { let response = respond (request) . await ? ; transport . send (response) . await ? ; } Err (e) => return Err (e . into ()) , } } Ok (()) } . sig",
      "file_path": "examples/tinyhttp.rs",
      "line": 0
    },
    {
      "hash": 4266339409031153545,
      "kind": "Function",
      "name": "respond",
      "signature": "fn async fn respond (req : Request < () >) -> Result < Response < String > , Box < dyn Error > > { let mut response = Response :: builder () ; let body = match req . uri () . path () { \"/plaintext\" => { response = response . header (\"Content-Type\" , \"text/plain\") ; \"Hello, World!\" . to_string () } \"/json\" => { response = response . header (\"Content-Type\" , \"application/json\") ; # [derive (Serialize)] struct Message { message : & 'static str , } serde_json :: to_string (& Message { message : \"Hello, World!\" , }) ? } _ => { response = response . status (StatusCode :: NOT_FOUND) ; String :: new () } } ; let response = response . body (body) . map_err (io :: Error :: other) ? ; Ok (response) } . sig",
      "file_path": "examples/tinyhttp.rs",
      "line": 0
    },
    {
      "hash": 8818354053333760888,
      "kind": "Struct",
      "name": "Http",
      "signature": "struct Http",
      "file_path": "examples/tinyhttp.rs",
      "line": 0
    },
    {
      "hash": 7901974865499008271,
      "kind": "Function",
      "name": "get_stdin_data",
      "signature": "fn fn get_stdin_data () -> Result < Vec < u8 > , Box < dyn std :: error :: Error > > { let mut buf = Vec :: new () ; stdin () . read_to_end (& mut buf) ? ; Ok (buf) } . sig",
      "file_path": "examples/udp-client.rs",
      "line": 0
    },
    {
      "hash": 7989822107692662296,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let remote_addr : SocketAddr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . into ()) . parse () ? ; let local_addr : SocketAddr = if remote_addr . is_ipv4 () { \"0.0.0.0:0\" } else { \"[::]:0\" } . parse () ? ; let socket = UdpSocket :: bind (local_addr) . await ? ; const MAX_DATAGRAM_SIZE : usize = 65_507 ; socket . connect (& remote_addr) . await ? ; let data = get_stdin_data () ? ; socket . send (& data) . await ? ; let mut data = vec ! [0u8 ; MAX_DATAGRAM_SIZE] ; let len = socket . recv (& mut data) . await ? ; println ! (\"Received {} bytes:\\n{}\" , len , String :: from_utf8_lossy (& data [.. len])) ; Ok (()) } . sig",
      "file_path": "examples/udp-client.rs",
      "line": 0
    },
    {
      "hash": 12602583563180801776,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:0\" . to_string ()) ; let a = UdpSocket :: bind (& addr) . await ? ; let b = UdpSocket :: bind (& addr) . await ? ; let b_addr = b . local_addr () ? ; let mut a = UdpFramed :: new (a , BytesCodec :: new ()) ; let mut b = UdpFramed :: new (b , BytesCodec :: new ()) ; let a = ping (& mut a , b_addr) ; let b = pong (& mut b) ; match tokio :: try_join ! (a , b) { Err (e) => println ! (\"an error occurred; error = {e:?}\") , _ => println ! (\"done!\") , } Ok (()) } . sig",
      "file_path": "examples/udp-codec.rs",
      "line": 0
    },
    {
      "hash": 18264311728095026130,
      "kind": "Function",
      "name": "ping",
      "signature": "fn async fn ping (socket : & mut UdpFramed < BytesCodec > , b_addr : SocketAddr) -> Result < () , io :: Error > { socket . send ((Bytes :: from (& b\"PING\" [..]) , b_addr)) . await ? ; for _ in 0 .. 4usize { let (bytes , addr) = socket . next () . map (| e | e . unwrap ()) . await ? ; println ! (\"[a] recv: {}\" , String :: from_utf8_lossy (& bytes)) ; socket . send ((Bytes :: from (& b\"PING\" [..]) , addr)) . await ? ; } Ok (()) } . sig",
      "file_path": "examples/udp-codec.rs",
      "line": 0
    },
    {
      "hash": 11006174420561147427,
      "kind": "Function",
      "name": "pong",
      "signature": "fn async fn pong (socket : & mut UdpFramed < BytesCodec >) -> Result < () , io :: Error > { let timeout = Duration :: from_millis (200) ; while let Ok (Some (Ok ((bytes , addr)))) = time :: timeout (timeout , socket . next ()) . await { println ! (\"[b] recv: {}\" , String :: from_utf8_lossy (& bytes)) ; socket . send ((Bytes :: from (& b\"PONG\" [..]) , addr)) . await ? ; } Ok (()) } . sig",
      "file_path": "examples/udp-codec.rs",
      "line": 0
    },
    {
      "hash": 2656508213913265185,
      "kind": "Function",
      "name": "main",
      "signature": "fn fn main () { let rt = Builder :: new_multi_thread () . enable_io () . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . enable_io () . build () . unwrap () ; rt . spawn (async { let listener = TcpListener :: bind (TCP_ENDPOINT) . await . unwrap () ; let (mut socket , _) = listener . accept () . await . unwrap () ; let (mut rd , mut wr) = socket . split () ; while tokio :: io :: copy (& mut rd , & mut wr) . await . is_ok () { } }) ; sleep (Duration :: from_millis (100)) ; let (tx , mut rx) = oneshot :: channel () ; rt2 . spawn (async { let addr = TCP_ENDPOINT . parse () . unwrap () ; let socket = TcpSocket :: new_v4 () . unwrap () ; let mut stream = socket . connect (addr) . await . unwrap () ; let mut buff = [0 ; MSG_SIZE] ; for _ in 0 .. NUM_MSGS { let one_mega_random_bytes : Vec < u8 > = (0 .. MSG_SIZE) . map (| _ | rand :: random :: < u8 > ()) . collect () ; stream . write_all (one_mega_random_bytes . as_slice ()) . await . unwrap () ; let _ = stream . read (& mut buff) . await . unwrap () ; } tx . send (()) . unwrap () ; }) ; loop { match rx . try_recv () { Err (oneshot :: error :: TryRecvError :: Empty) => () , Err (oneshot :: error :: TryRecvError :: Closed) => panic ! (\"channel got closed...\") , Ok (()) => break , } } } . sig",
      "file_path": "stress-test/examples/simple_echo_tcp.rs",
      "line": 0
    },
    {
      "hash": 16006434256544058945,
      "kind": "Function",
      "name": "compile_fail_full",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn compile_fail_full () { let t = trybuild :: TestCases :: new () ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/forward_args_and_output.rs\") ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/macros_main_return.rs\") ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/macros_main_loop.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_invalid_input.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_dead_code.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_type_mismatch.rs\") ; # [cfg (all (feature = \"rt\" , not (feature = \"full\")))] t . compile_fail (\"tests/fail/macros_core_no_default.rs\") ; drop (t) ; } . sig",
      "file_path": "tests-build/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 4692795003657996114,
      "kind": "Function",
      "name": "test_with_semicolon_without_return_type",
      "signature": "fn # [cfg (feature = \"full\")] # [tokio :: test] async fn test_with_semicolon_without_return_type () { # ! [deny (clippy :: semicolon_if_nothing_returned)] dbg ! (0) ; } . sig",
      "file_path": "tests-build/tests/macros_clippy.rs",
      "line": 0
    },
    {
      "hash": 14884693126204823599,
      "kind": "Function",
      "name": "my_fn",
      "signature": "fn # [tokio :: main] async fn my_fn () { } . sig",
      "file_path": "tests-build/tests/fail/macros_core_no_default.rs",
      "line": 0
    },
    {
      "hash": 9065252973707781037,
      "kind": "Function",
      "name": "main",
      "signature": "fn fn main () { } . sig",
      "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
      "line": 0
    },
    {
      "hash": 6873230474997234196,
      "kind": "Function",
      "name": "f",
      "signature": "fn # [tokio :: main] async fn f () { } . sig",
      "file_path": "tests-build/tests/fail/macros_dead_code.rs",
      "line": 0
    },
    {
      "hash": 9456683778956194729,
      "kind": "Function",
      "name": "main_is_not_async",
      "signature": "fn # [tokio :: main] fn main_is_not_async () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 1939133536922563447,
      "kind": "Function",
      "name": "main_attr_has_unknown_args",
      "signature": "fn # [tokio :: main (foo)] async fn main_attr_has_unknown_args () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 2420740426619435397,
      "kind": "Function",
      "name": "main_attr_has_path_args",
      "signature": "fn # [tokio :: main (threadpool :: bar)] async fn main_attr_has_path_args () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 4329006628052741674,
      "kind": "Function",
      "name": "test_is_not_async",
      "signature": "fn # [tokio :: test] fn test_is_not_async () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 3194892488389721984,
      "kind": "Function",
      "name": "test_attr_has_args",
      "signature": "fn # [tokio :: test (foo)] async fn test_attr_has_args () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 11948251748400710213,
      "kind": "Function",
      "name": "test_unexpected_attr",
      "signature": "fn # [tokio :: test (foo = 123)] async fn test_unexpected_attr () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 2326774143417578825,
      "kind": "Function",
      "name": "test_flavor_not_string",
      "signature": "fn # [tokio :: test (flavor = 123)] async fn test_flavor_not_string () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 10841940607092473340,
      "kind": "Function",
      "name": "test_unknown_flavor",
      "signature": "fn # [tokio :: test (flavor = \"foo\")] async fn test_unknown_flavor () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 13006799703599375879,
      "kind": "Function",
      "name": "test_multi_thread_with_start_paused",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , start_paused = false)] async fn test_multi_thread_with_start_paused () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 1966389084945942050,
      "kind": "Function",
      "name": "test_worker_threads_not_int",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , worker_threads = \"foo\")] async fn test_worker_threads_not_int () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 5504675685474421442,
      "kind": "Function",
      "name": "test_worker_threads_and_current_thread",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\" , worker_threads = 4)] async fn test_worker_threads_and_current_thread () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 11869689961427088102,
      "kind": "Function",
      "name": "test_crate_not_path_int",
      "signature": "fn # [tokio :: test (crate = 456)] async fn test_crate_not_path_int () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 13995279540888029133,
      "kind": "Function",
      "name": "test_crate_not_path_invalid",
      "signature": "fn # [tokio :: test (crate = \"456\")] async fn test_crate_not_path_invalid () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 6531630895325521770,
      "kind": "Function",
      "name": "test_multi_thread_with_unhandled_panic",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , unhandled_panic = \"shutdown_runtime\")] async fn test_multi_thread_with_unhandled_panic () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 4036879977506293584,
      "kind": "Function",
      "name": "test_has_second_test_attr",
      "signature": "fn # [tokio :: test] # [test] async fn test_has_second_test_attr () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 759490097402636508,
      "kind": "Function",
      "name": "test_has_second_test_attr_v1",
      "signature": "fn # [tokio :: test] # [:: core :: prelude :: v1 :: test] async fn test_has_second_test_attr_v1 () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 4990321762059192660,
      "kind": "Function",
      "name": "test_has_second_test_attr_rust_2015",
      "signature": "fn # [tokio :: test] # [core :: prelude :: rust_2015 :: test] async fn test_has_second_test_attr_rust_2015 () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 12555760398060500336,
      "kind": "Function",
      "name": "test_has_second_test_attr_rust_2018",
      "signature": "fn # [tokio :: test] # [:: std :: prelude :: rust_2018 :: test] async fn test_has_second_test_attr_rust_2018 () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 10267709091012828517,
      "kind": "Function",
      "name": "test_has_second_test_attr_rust_2021",
      "signature": "fn # [tokio :: test] # [std :: prelude :: rust_2021 :: test] async fn test_has_second_test_attr_rust_2021 () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 4353650979254260085,
      "kind": "Function",
      "name": "test_has_generated_second_test_attr",
      "signature": "fn # [tokio :: test] # [tokio :: test] async fn test_has_generated_second_test_attr () { } . sig",
      "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
      "line": 0
    },
    {
      "hash": 7729971723699688800,
      "kind": "Function",
      "name": "missing_semicolon_or_return_type",
      "signature": "fn # [tokio :: main] async fn missing_semicolon_or_return_type () { Ok (()) } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 15094279112330438417,
      "kind": "Function",
      "name": "missing_return_type",
      "signature": "fn # [tokio :: main] async fn missing_return_type () { return Ok (()) ; } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 18042320917084740514,
      "kind": "Function",
      "name": "extra_semicolon",
      "signature": "fn # [tokio :: main] async fn extra_semicolon () -> Result < () , () > { Ok (()) ; } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 8110473872859553372,
      "kind": "Function",
      "name": "question_mark_operator_with_invalid_option",
      "signature": "fn # [doc = \" This test is a characterization test for the `?` operator.\"] # [doc = \"\"] # [doc = \" See <https://github.com/tokio-rs/tokio/issues/6930#issuecomment-2572502517> for more details.\"] # [doc = \"\"] # [doc = \" It should fail with a single error message about the return type of the function, but instead\"] # [doc = \" if fails with an extra error message due to the `?` operator being used within the async block\"] # [doc = \" rather than the original function.\"] # [doc = \"\"] # [doc = \" ```text\"] # [doc = \" 28 |     None?;\"] # [doc = \"    |         ^ cannot use the `?` operator in an async block that returns `()`\"] # [doc = \" ```\"] # [tokio :: main] async fn question_mark_operator_with_invalid_option () -> Option < () > { None ? ; } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 8935379186297968959,
      "kind": "Function",
      "name": "question_mark_operator_with_invalid_result",
      "signature": "fn # [doc = \" This test is a characterization test for the `?` operator.\"] # [doc = \"\"] # [doc = \" See <https://github.com/tokio-rs/tokio/issues/6930#issuecomment-2572502517> for more details.\"] # [doc = \"\"] # [doc = \" It should fail with a single error message about the return type of the function, but instead\"] # [doc = \" if fails with an extra error message due to the `?` operator being used within the async block\"] # [doc = \" rather than the original function.\"] # [doc = \"\"] # [doc = \" ```text\"] # [doc = \" 33 |     Ok(())?;\"] # [doc = \"    |           ^ cannot use the `?` operator in an async block that returns `()`\"] # [doc = \" ```\"] # [tokio :: main] async fn question_mark_operator_with_invalid_result () -> Result < () , () > { Ok (()) ? ; } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 5106426483520773148,
      "kind": "Function",
      "name": "issue_4635",
      "signature": "fn # [allow (redundant_semicolons)] # [rustfmt :: skip] # [tokio :: main] async fn issue_4635 () { return 1 ; ; } . sig",
      "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
      "line": 0
    },
    {
      "hash": 9291929027378408543,
      "kind": "Function",
      "name": "test_fn_has_args",
      "signature": "fn # [tokio :: test] async fn test_fn_has_args (_x : u8) { } . sig",
      "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
      "line": 0
    },
    {
      "hash": 5868310964266285052,
      "kind": "Function",
      "name": "test_has_output",
      "signature": "fn # [tokio :: test] async fn test_has_output () -> Result < () , Box < dyn std :: error :: Error > > { Ok (()) } . sig",
      "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
      "line": 0
    },
    {
      "hash": 8300728136095971726,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , () > { loop { if ! never () { return Ok (()) ; } } } . sig",
      "file_path": "tests-build/tests/pass/macros_main_loop.rs",
      "line": 0
    },
    {
      "hash": 1426083267286406449,
      "kind": "Function",
      "name": "never",
      "signature": "fn fn never () -> bool { std :: time :: Instant :: now () > std :: time :: Instant :: now () } . sig",
      "file_path": "tests-build/tests/pass/macros_main_loop.rs",
      "line": 0
    },
    {
      "hash": 864123155144373194,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [tokio :: main] async fn main () -> Result < () , () > { return Ok (()) ; } . sig",
      "file_path": "tests-build/tests/pass/macros_main_return.rs",
      "line": 0
    },
    {
      "hash": 658865956892850340,
      "kind": "Function",
      "name": "basic_main",
      "signature": "fn # [tokio :: main] async fn basic_main () -> usize { 1 } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 15910115911446830064,
      "kind": "Function",
      "name": "generic_fun",
      "signature": "fn # [tokio :: main] async fn generic_fun < T : Default > () -> T { T :: default () } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 9977822629161322453,
      "kind": "Function",
      "name": "spawning",
      "signature": "fn # [tokio :: main] async fn spawning () -> usize { let join = tokio :: spawn (async { 1 }) ; join . await . unwrap () } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 8681765261950286934,
      "kind": "Function",
      "name": "local_main",
      "signature": "fn # [cfg (tokio_unstable)] # [tokio :: main (flavor = \"local\")] async fn local_main () -> usize { let join = tokio :: task :: spawn_local (async { 1 }) ; join . await . unwrap () } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 1604755325918465267,
      "kind": "Function",
      "name": "main_with_spawn",
      "signature": "fn # [test] fn main_with_spawn () { assert_eq ! (1 , spawning ()) ; } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 10769461502823608298,
      "kind": "Function",
      "name": "shell",
      "signature": "fn # [test] fn shell () { assert_eq ! (1 , basic_main ()) ; assert_eq ! (bool :: default () , generic_fun ::< bool > ()) ; # [cfg (tokio_unstable)] assert_eq ! (1 , local_main ()) ; } . sig",
      "file_path": "tests-integration/tests/macros_main.rs",
      "line": 0
    },
    {
      "hash": 17871575106165535289,
      "kind": "Function",
      "name": "my_async_fn",
      "signature": "fn async fn my_async_fn () { } . sig",
      "file_path": "tests-integration/tests/macros_pin.rs",
      "line": 0
    },
    {
      "hash": 11913984618420290186,
      "kind": "Function",
      "name": "pin",
      "signature": "fn # [test] fn pin () { block_on (async { let future = my_async_fn () ; tokio :: pin ! (future) ; (& mut future) . await }) ; } . sig",
      "file_path": "tests-integration/tests/macros_pin.rs",
      "line": 0
    },
    {
      "hash": 2144890875738234164,
      "kind": "Function",
      "name": "join_with_select",
      "signature": "fn # [cfg_attr (not (feature = \"rt-multi-thread\") , ignore = \"WASI: std::thread::spawn not supported\")] # [test] fn join_with_select () { block_on (async { let (tx1 , mut rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , mut rx2) = oneshot :: channel :: < i32 > () ; thread :: spawn (move | | { tx1 . send (123) . unwrap () ; tx2 . send (456) . unwrap () ; }) ; let mut a = None ; let mut b = None ; while a . is_none () || b . is_none () { tokio :: select ! { v1 = (& mut rx1) , if a . is_none () => a = Some (v1 . unwrap ()) , v2 = (& mut rx2) , if b . is_none () => b = Some (v2 . unwrap ()) , } } let (a , b) = (a . unwrap () , b . unwrap ()) ; assert_eq ! (a , 123) ; assert_eq ! (b , 456) ; }) ; } . sig",
      "file_path": "tests-integration/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 14418773218456191499,
      "kind": "Function",
      "name": "cat",
      "signature": "fn fn cat () -> Command { let mut cmd = Command :: new (env ! (\"CARGO_BIN_EXE_test-cat\")) ; cmd . stdin (Stdio :: piped ()) . stdout (Stdio :: piped ()) ; cmd } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 1619287038956516940,
      "kind": "Function",
      "name": "feed_cat",
      "signature": "fn async fn feed_cat (mut cat : Child , n : usize) -> io :: Result < ExitStatus > { let mut stdin = cat . stdin . take () . unwrap () ; let stdout = cat . stdout . take () . unwrap () ; let write = async { for i in 0 .. n { let bytes = format ! (\"line {i}\\n\") . into_bytes () ; stdin . write_all (& bytes) . await . unwrap () ; } drop (stdin) ; } ; let read = async { let mut reader = BufReader :: new (stdout) . lines () ; let mut num_lines = 0 ; loop { let data = reader . next_line () . await . unwrap_or_else (| _ | Some (String :: new ())) . expect (\"failed to read line\") ; let num_read = data . len () ; let done = num_lines >= n ; match (done , num_read) { (false , 0) => panic ! (\"broken pipe\") , (true , n) if n != 0 => panic ! (\"extraneous data\") , _ => { let expected = format ! (\"line {num_lines}\") ; assert_eq ! (expected , data) ; } } ; num_lines += 1 ; if num_lines >= n { break ; } } } ; future :: join3 (write , read , cat . wait ()) . map (| (_ , _ , status) | status) . await } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 14463990689652643995,
      "kind": "Function",
      "name": "feed_a_lot",
      "signature": "fn # [doc = \" Check for the following properties when feeding stdin and\"] # [doc = \" consuming stdout of a cat-like process:\"] # [doc = \"\"] # [doc = \" - A number of lines that amounts to a number of bytes exceeding a\"] # [doc = \"   typical OS buffer size can be fed to the child without\"] # [doc = \"   deadlock. This tests that we also consume the stdout\"] # [doc = \"   concurrently; otherwise this would deadlock.\"] # [doc = \"\"] # [doc = \" - We read the same lines from the child that we fed it.\"] # [doc = \"\"] # [doc = \" - The child does produce EOF on stdout after the last line.\"] # [tokio :: test] async fn feed_a_lot () { let child = cat () . spawn () . unwrap () ; let status = feed_cat (child , 10000) . await . unwrap () ; assert_eq ! (status . code () , Some (0)) ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 6783153146044959488,
      "kind": "Function",
      "name": "wait_with_output_captures",
      "signature": "fn # [tokio :: test] async fn wait_with_output_captures () { let mut child = cat () . spawn () . unwrap () ; let mut stdin = child . stdin . take () . unwrap () ; let write_bytes = b\"1234\" ; let future = async { stdin . write_all (write_bytes) . await ? ; drop (stdin) ; let out = child . wait_with_output () ; out . await } ; let output = future . await . unwrap () ; assert ! (output . status . success ()) ; assert_eq ! (output . stdout , write_bytes) ; assert_eq ! (output . stderr . len () , 0) ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 12800853095865265955,
      "kind": "Function",
      "name": "status_closes_any_pipes",
      "signature": "fn # [tokio :: test] async fn status_closes_any_pipes () { let child = cat () . status () ; assert_ok ! (child . await) ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 17554242780901700117,
      "kind": "Function",
      "name": "try_wait",
      "signature": "fn # [tokio :: test] async fn try_wait () { let mut child = cat () . spawn () . unwrap () ; let id = child . id () . expect (\"missing id\") ; assert ! (id > 0) ; assert_eq ! (None , assert_ok ! (child . try_wait ())) ; drop (child . stdin . take ()) ; drop (child . stderr . take ()) ; drop (child . stdout . take ()) ; assert_ok ! (child . wait () . await) ; assert ! (assert_ok ! (child . try_wait ()) . unwrap () . success ()) ; assert_eq ! (child . id () , None) ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 2962257519129332804,
      "kind": "Function",
      "name": "pipe_from_one_command_to_another",
      "signature": "fn # [tokio :: test] async fn pipe_from_one_command_to_another () { let mut first = cat () . spawn () . expect (\"first cmd\") ; let mut third = cat () . spawn () . expect (\"third cmd\") ; let second_stdin : Stdio = first . stdout . take () . expect (\"first.stdout\") . try_into () . expect (\"first.stdout into Stdio\") ; let second_stdout : Stdio = third . stdin . take () . expect (\"third.stdin\") . try_into () . expect (\"third.stdin into Stdio\") ; let mut second = cat () . stdin (second_stdin) . stdout (second_stdout) . spawn () . expect (\"first cmd\") ; let msg = \"hello world! please pipe this message through\" ; let mut stdin = first . stdin . take () . expect (\"first.stdin\") ; let write = async move { stdin . write_all (msg . as_bytes ()) . await } ; let mut stdout = third . stdout . take () . expect (\"third.stdout\") ; let read = async move { let mut data = String :: new () ; stdout . read_to_string (& mut data) . await . map (| _ | data) } ; let (read , write , first_status , second_status , third_status) = join ! (read , write , first . wait () , second . wait () , third . wait ()) ; assert_eq ! (msg , read . expect (\"read result\")) ; write . expect (\"write result\") ; assert ! (first_status . expect (\"first status\") . success ()) ; assert ! (second_status . expect (\"second status\") . success ()) ; assert ! (third_status . expect (\"third status\") . success ()) ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 9450963162481366056,
      "kind": "Function",
      "name": "vectored_writes",
      "signature": "fn # [tokio :: test] async fn vectored_writes () { use bytes :: { Buf , Bytes } ; use std :: { io :: IoSlice , pin :: Pin } ; use tokio :: io :: AsyncWrite ; let mut cat = cat () . spawn () . unwrap () ; let mut stdin = cat . stdin . take () . unwrap () ; let are_writes_vectored = stdin . is_write_vectored () ; let mut stdout = cat . stdout . take () . unwrap () ; let write = async { let mut input = Bytes :: from_static (b\"hello\\n\") . chain (Bytes :: from_static (b\"world!\\n\")) ; let mut writes_completed = 0 ; std :: future :: poll_fn (| cx | loop { let mut slices = [IoSlice :: new (& []) ; 2] ; let vectored = input . chunks_vectored (& mut slices) ; if vectored == 0 { return std :: task :: Poll :: Ready (std :: io :: Result :: Ok (())) ; } let n = ready ! (Pin :: new (& mut stdin) . poll_write_vectored (cx , & slices)) ? ; writes_completed += 1 ; input . advance (n) ; }) . await ? ; drop (stdin) ; std :: io :: Result :: Ok (writes_completed) } ; let read = async { let mut buffer = Vec :: with_capacity (6 + 7) ; stdout . read_to_end (& mut buffer) . await ? ; std :: io :: Result :: Ok (buffer) } ; let (write , read , status) = future :: join3 (write , read , cat . wait ()) . await ; assert ! (status . unwrap () . success ()) ; let writes_completed = write . unwrap () ; assert_eq ! (writes_completed == 1 , are_writes_vectored) ; assert_eq ! (& read . unwrap () , b\"hello\\nworld!\\n\") ; } . sig",
      "file_path": "tests-integration/tests/process_stdio.rs",
      "line": 0
    },
    {
      "hash": 13002919983719826802,
      "kind": "Function",
      "name": "spawn_send",
      "signature": "fn async fn spawn_send () { let (tx , rx) = oneshot :: channel () ; let task = tokio :: spawn (async { for _ in 0 .. 10 { task :: yield_now () . await ; } tx . send (\"done\") . unwrap () ; }) ; assert_eq ! (\"done\" , rx . await . unwrap ()) ; task . await . unwrap () ; } . sig",
      "file_path": "tests-integration/tests/rt_yield.rs",
      "line": 0
    },
    {
      "hash": 2444066391861383699,
      "kind": "Function",
      "name": "entry_point",
      "signature": "fn # [tokio :: main (flavor = \"current_thread\")] async fn entry_point () { spawn_send () . await ; } . sig",
      "file_path": "tests-integration/tests/rt_yield.rs",
      "line": 0
    },
    {
      "hash": 17469514574260472246,
      "kind": "Function",
      "name": "test_macro",
      "signature": "fn # [tokio :: test] async fn test_macro () { spawn_send () . await ; } . sig",
      "file_path": "tests-integration/tests/rt_yield.rs",
      "line": 0
    },
    {
      "hash": 14145249272394005599,
      "kind": "Function",
      "name": "main_macro",
      "signature": "fn # [test] fn main_macro () { entry_point () ; } . sig",
      "file_path": "tests-integration/tests/rt_yield.rs",
      "line": 0
    },
    {
      "hash": 9649664363910317784,
      "kind": "Function",
      "name": "manual_rt",
      "signature": "fn # [test] fn manual_rt () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { spawn_send () . await }) ; } . sig",
      "file_path": "tests-integration/tests/rt_yield.rs",
      "line": 0
    },
    {
      "hash": 16699763230483587088,
      "kind": "Function",
      "name": "is_unpin",
      "signature": "fn # [cfg (feature = \"io-util\")] # [cfg (test)] fn is_unpin < T : Unpin > () { } . sig",
      "file_path": "tokio/src/lib.rs",
      "line": 0
    },
    {
      "hash": 12075175483603109901,
      "kind": "Function",
      "name": "canonicalize",
      "signature": "fn # [doc = \" Returns the canonical, absolute form of a path with all intermediate\"] # [doc = \" components normalized and symbolic links resolved.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::canonicalize`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `realpath` function on Unix\"] # [doc = \" and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" On Windows, this converts the path to use [extended length path][path]\"] # [doc = \" syntax, which allows your program to use longer path names, but means you\"] # [doc = \" can only join backslash-delimited paths to it, and it may be incompatible\"] # [doc = \" with other applications (if passed to the application on the command-line,\"] # [doc = \" or written to a file another application may read).\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \" [path]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * `path` does not exist.\"] # [doc = \" * A non-final component in path is not a directory.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::io;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     let path = fs::canonicalize(\\\"../a/../foo.txt\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn canonicalize (path : impl AsRef < Path >) -> io :: Result < PathBuf > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: canonicalize (path)) . await } . sig",
      "file_path": "tokio/src/fs/canonicalize.rs",
      "line": 0
    },
    {
      "hash": 14782648526159008944,
      "kind": "Function",
      "name": "copy",
      "signature": "fn # [doc = \" Copies the contents of one file to another. This function will also copy the permission bits\"] # [doc = \" of the original file to the destination file.\"] # [doc = \" This function will overwrite the contents of to.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::copy`].\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::copy(\\\"foo.txt\\\", \\\"bar.txt\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn copy (from : impl AsRef < Path > , to : impl AsRef < Path >) -> Result < u64 , std :: io :: Error > { let from = from . as_ref () . to_owned () ; let to = to . as_ref () . to_owned () ; asyncify (| | std :: fs :: copy (from , to)) . await } . sig",
      "file_path": "tokio/src/fs/copy.rs",
      "line": 0
    },
    {
      "hash": 8290523700223190846,
      "kind": "Function",
      "name": "create_dir",
      "signature": "fn # [doc = \" Creates a new, empty directory at the provided path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::create_dir`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `mkdir` function on Unix\"] # [doc = \" and the `CreateDirectory` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" **NOTE**: If a parent of the given path doesn't exist, this function will\"] # [doc = \" return an error. To create a directory and all its missing parents at the\"] # [doc = \" same time, use the [`create_dir_all`] function.\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * User lacks permissions to create directory at `path`.\"] # [doc = \" * A parent of the given path doesn't exist. (To create a directory and all\"] # [doc = \"   its missing parents at the same time, use the [`create_dir_all`]\"] # [doc = \"   function.)\"] # [doc = \" * `path` already exists.\"] # [doc = \"\"] # [doc = \" [`create_dir_all`]: super::create_dir_all()\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::io;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     fs::create_dir(\\\"/some/dir\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn create_dir (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: create_dir (path)) . await } . sig",
      "file_path": "tokio/src/fs/create_dir.rs",
      "line": 0
    },
    {
      "hash": 12563772599608129520,
      "kind": "Function",
      "name": "create_dir_all",
      "signature": "fn # [doc = \" Recursively creates a directory and all of its parent components if they\"] # [doc = \" are missing.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::create_dir_all`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `mkdir` function on Unix\"] # [doc = \" and the `CreateDirectory` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * If any directory in the path specified by `path` does not already exist\"] # [doc = \"   and it could not be created otherwise. The specific error conditions for\"] # [doc = \"   when a directory is being created (after it is determined to not exist) are\"] # [doc = \"   outlined by [`fs::create_dir`].\"] # [doc = \"\"] # [doc = \" Notable exception is made for situations where any of the directories\"] # [doc = \" specified in the `path` could not be created as it was being created concurrently.\"] # [doc = \" Such cases are considered to be successful. That is, calling `create_dir_all`\"] # [doc = \" concurrently from multiple threads or processes is guaranteed not to fail\"] # [doc = \" due to a race condition with itself.\"] # [doc = \"\"] # [doc = \" [`fs::create_dir`]: std::fs::create_dir\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     fs::create_dir_all(\\\"/some/dir\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn create_dir_all (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: create_dir_all (path)) . await } . sig",
      "file_path": "tokio/src/fs/create_dir_all.rs",
      "line": 0
    },
    {
      "hash": 4731365144558460293,
      "kind": "Struct",
      "name": "DirBuilder",
      "signature": "struct DirBuilder",
      "file_path": "tokio/src/fs/dir_builder.rs",
      "line": 0
    },
    {
      "hash": 14958692035605820931,
      "kind": "Struct",
      "name": "File",
      "signature": "struct File",
      "file_path": "tokio/src/fs/file.rs",
      "line": 0
    },
    {
      "hash": 2444012961140979343,
      "kind": "Struct",
      "name": "Inner",
      "signature": "struct Inner",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 1040885933636163441,
      "kind": "Function",
      "name": "hard_link",
      "signature": "fn # [doc = \" Creates a new hard link on the filesystem.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::hard_link`].\"] # [doc = \"\"] # [doc = \" The `link` path will be a link pointing to the `original` path. Note that systems\"] # [doc = \" often require these two paths to both be located on the same filesystem.\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `link` function on Unix\"] # [doc = \" and the `CreateHardLink` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * The `original` path is not a file or doesn't exist.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     fs::hard_link(\\\"a.txt\\\", \\\"b.txt\\\").await?; // Hard link a.txt to b.txt\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn hard_link (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: fs :: hard_link (original , link)) . await } . sig",
      "file_path": "tokio/src/fs/hard_link.rs",
      "line": 0
    },
    {
      "hash": 8221128131836215495,
      "kind": "Function",
      "name": "metadata",
      "signature": "fn # [doc = \" Given a path, queries the file system to get information about a file,\"] # [doc = \" directory, etc.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::metadata`].\"] # [doc = \"\"] # [doc = \" This function will traverse symbolic links to query information about the\"] # [doc = \" destination file.\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `stat` function on Unix and the\"] # [doc = \" `GetFileAttributesEx` function on Windows.  Note that, this [may change in\"] # [doc = \" the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * The user lacks permissions to perform `metadata` call on `path`.\"] # [doc = \" * `path` does not exist.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     let attr = fs::metadata(\\\"/some/file/path.txt\\\").await?;\"] # [doc = \"     // inspect attr ...\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn metadata (path : impl AsRef < Path >) -> io :: Result < Metadata > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: metadata (path)) . await } . sig",
      "file_path": "tokio/src/fs/metadata.rs",
      "line": 0
    },
    {
      "hash": 3943795181992208225,
      "kind": "Struct",
      "name": "JoinHandle",
      "signature": "struct JoinHandle",
      "file_path": "tokio/src/fs/mocks.rs",
      "line": 0
    },
    {
      "hash": 1731871583419866588,
      "kind": "Function",
      "name": "spawn_blocking",
      "signature": "fn pub (super) fn spawn_blocking < F , R > (f : F) -> JoinHandle < R > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let (tx , rx) = oneshot :: channel () ; let task = Box :: new (move | | { let _ = tx . send (f ()) ; }) ; QUEUE . with (| cell | cell . borrow_mut () . push_back (task)) ; JoinHandle { rx } } . sig",
      "file_path": "tokio/src/fs/mocks.rs",
      "line": 0
    },
    {
      "hash": 11030079056499145975,
      "kind": "Function",
      "name": "spawn_mandatory_blocking",
      "signature": "fn pub (super) fn spawn_mandatory_blocking < F , R > (f : F) -> Option < JoinHandle < R > > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let (tx , rx) = oneshot :: channel () ; let task = Box :: new (move | | { let _ = tx . send (f ()) ; }) ; QUEUE . with (| cell | cell . borrow_mut () . push_back (task)) ; Some (JoinHandle { rx }) } . sig",
      "file_path": "tokio/src/fs/mocks.rs",
      "line": 0
    },
    {
      "hash": 15074935449743974702,
      "kind": "Function",
      "name": "asyncify",
      "signature": "fn pub (crate) async fn asyncify < F , T > (f : F) -> io :: Result < T > where F : FnOnce () -> io :: Result < T > + Send + 'static , T : Send + 'static , { match spawn_blocking (f) . await { Ok (res) => res , Err (_) => Err (io :: Error :: new (io :: ErrorKind :: Other , \"background task failed\" ,)) , } } . sig",
      "file_path": "tokio/src/fs/mod.rs",
      "line": 0
    },
    {
      "hash": 7063003428773597581,
      "kind": "Struct",
      "name": "OpenOptions",
      "signature": "struct OpenOptions",
      "file_path": "tokio/src/fs/open_options.rs",
      "line": 0
    },
    {
      "hash": 17865457130804371471,
      "kind": "Function",
      "name": "read",
      "signature": "fn # [doc = \" Reads the entire contents of a file into a bytes vector.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read`].\"] # [doc = \"\"] # [doc = \" This is a convenience function for using [`File::open`] and [`read_to_end`]\"] # [doc = \" with fewer imports and without an intermediate variable. It pre-allocates a\"] # [doc = \" buffer based on the file size when available, so it is generally faster than\"] # [doc = \" reading into a vector created with `Vec::new()`.\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`File::open`]: super::File::open\"] # [doc = \" [`read_to_end`]: crate::io::AsyncReadExt::read_to_end\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error if `path` does not already exist.\"] # [doc = \" Other errors may also be returned according to [`OpenOptions::open`].\"] # [doc = \"\"] # [doc = \" [`OpenOptions::open`]: super::OpenOptions::open\"] # [doc = \"\"] # [doc = \" It will also return an error if it encounters while reading an error\"] # [doc = \" of a kind other than [`ErrorKind::Interrupted`].\"] # [doc = \"\"] # [doc = \" [`ErrorKind::Interrupted`]: std::io::ErrorKind::Interrupted\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::net::SocketAddr;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\"] # [doc = \"     let contents = fs::read(\\\"address.txt\\\").await?;\"] # [doc = \"     let foo: SocketAddr = String::from_utf8_lossy(&contents).parse()?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn read (path : impl AsRef < Path >) -> io :: Result < Vec < u8 > > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read (path)) . await } . sig",
      "file_path": "tokio/src/fs/read.rs",
      "line": 0
    },
    {
      "hash": 12686114690513306918,
      "kind": "Function",
      "name": "read_dir",
      "signature": "fn # [doc = \" Returns a stream over the entries within a directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read_dir`].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking\"] # [doc = \" operation on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] pub async fn read_dir (path : impl AsRef < Path >) -> io :: Result < ReadDir > { let path = path . as_ref () . to_owned () ; asyncify (| | -> io :: Result < ReadDir > { let mut std = std :: fs :: read_dir (path) ? ; let mut buf = VecDeque :: with_capacity (CHUNK_SIZE) ; let remain = ReadDir :: next_chunk (& mut buf , & mut std) ; Ok (ReadDir (State :: Idle (Some ((buf , std , remain))))) }) . await } . sig",
      "file_path": "tokio/src/fs/read_dir.rs",
      "line": 0
    },
    {
      "hash": 169819094398846688,
      "kind": "Struct",
      "name": "ReadDir",
      "signature": "struct ReadDir",
      "file_path": "tokio/src/fs/read_dir.rs",
      "line": 0
    },
    {
      "hash": 12645502185924679752,
      "kind": "Struct",
      "name": "DirEntry",
      "signature": "struct DirEntry",
      "file_path": "tokio/src/fs/read_dir.rs",
      "line": 0
    },
    {
      "hash": 6580986680998825201,
      "kind": "Function",
      "name": "read_link",
      "signature": "fn # [doc = \" Reads a symbolic link, returning the file that the link points to.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read_link`].\"] pub async fn read_link (path : impl AsRef < Path >) -> io :: Result < PathBuf > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read_link (path)) . await } . sig",
      "file_path": "tokio/src/fs/read_link.rs",
      "line": 0
    },
    {
      "hash": 12856642346790706372,
      "kind": "Function",
      "name": "read_to_string",
      "signature": "fn # [doc = \" Creates a future which will open a file for reading and read the entire\"] # [doc = \" contents into a string and return said string.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::read_to_string`][std].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \" [std]: fn@std::fs::read_to_string\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" let contents = fs::read_to_string(\\\"foo.txt\\\").await?;\"] # [doc = \" println!(\\\"foo.txt contains {} bytes\\\", contents.len());\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_to_string (path : impl AsRef < Path >) -> io :: Result < String > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read_to_string (path)) . await } . sig",
      "file_path": "tokio/src/fs/read_to_string.rs",
      "line": 0
    },
    {
      "hash": 11312355462250255729,
      "kind": "Function",
      "name": "remove_dir",
      "signature": "fn # [doc = \" Removes an existing, empty directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_dir`].\"] pub async fn remove_dir (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_dir (path)) . await } . sig",
      "file_path": "tokio/src/fs/remove_dir.rs",
      "line": 0
    },
    {
      "hash": 10511669700525770178,
      "kind": "Function",
      "name": "remove_dir_all",
      "signature": "fn # [doc = \" Removes a directory at this path, after removing all its contents. Use carefully!\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_dir_all`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::remove_dir_all\"] pub async fn remove_dir_all (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_dir_all (path)) . await } . sig",
      "file_path": "tokio/src/fs/remove_dir_all.rs",
      "line": 0
    },
    {
      "hash": 14445695898638899186,
      "kind": "Function",
      "name": "remove_file",
      "signature": "fn # [doc = \" Removes a file from the filesystem.\"] # [doc = \"\"] # [doc = \" Note that there is no guarantee that the file is immediately deleted (e.g.\"] # [doc = \" depending on platform, other open file descriptors may prevent immediate\"] # [doc = \" removal).\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_file`].\"] pub async fn remove_file (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_file (path)) . await } . sig",
      "file_path": "tokio/src/fs/remove_file.rs",
      "line": 0
    },
    {
      "hash": 17288054488680055610,
      "kind": "Function",
      "name": "rename",
      "signature": "fn # [doc = \" Renames a file or directory to a new name, replacing the original file if\"] # [doc = \" `to` already exists.\"] # [doc = \"\"] # [doc = \" This will not work if the new name is on a different mount point.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::rename`].\"] pub async fn rename (from : impl AsRef < Path > , to : impl AsRef < Path >) -> io :: Result < () > { let from = from . as_ref () . to_owned () ; let to = to . as_ref () . to_owned () ; asyncify (move | | std :: fs :: rename (from , to)) . await } . sig",
      "file_path": "tokio/src/fs/rename.rs",
      "line": 0
    },
    {
      "hash": 2169221545785584135,
      "kind": "Function",
      "name": "set_permissions",
      "signature": "fn # [doc = \" Changes the permissions found on a file or a directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::set_permissions`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::set_permissions\"] pub async fn set_permissions (path : impl AsRef < Path > , perm : Permissions) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: set_permissions (path , perm)) . await } . sig",
      "file_path": "tokio/src/fs/set_permissions.rs",
      "line": 0
    },
    {
      "hash": 3073424801692056554,
      "kind": "Function",
      "name": "symlink",
      "signature": "fn # [doc = \" Creates a new symbolic link on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a symbolic link pointing to the `original` path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::unix::fs::symlink`].\"] pub async fn symlink (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: unix :: fs :: symlink (original , link)) . await } . sig",
      "file_path": "tokio/src/fs/symlink.rs",
      "line": 0
    },
    {
      "hash": 5011702572950243067,
      "kind": "Function",
      "name": "symlink_dir",
      "signature": "fn # [doc = \" Creates a new directory symlink on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a directory symbolic link pointing to the `original`\"] # [doc = \" path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::windows::fs::symlink_dir`][std]\"] # [doc = \"\"] # [doc = \" [std]: https://doc.rust-lang.org/std/os/windows/fs/fn.symlink_dir.html\"] pub async fn symlink_dir (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: windows :: fs :: symlink_dir (original , link)) . await } . sig",
      "file_path": "tokio/src/fs/symlink_dir.rs",
      "line": 0
    },
    {
      "hash": 14758471537731520592,
      "kind": "Function",
      "name": "symlink_file",
      "signature": "fn # [doc = \" Creates a new file symbolic link on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a file symbolic link pointing to the `original`\"] # [doc = \" path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::windows::fs::symlink_file`][std]\"] # [doc = \"\"] # [doc = \" [std]: https://doc.rust-lang.org/std/os/windows/fs/fn.symlink_file.html\"] pub async fn symlink_file (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: windows :: fs :: symlink_file (original , link)) . await } . sig",
      "file_path": "tokio/src/fs/symlink_file.rs",
      "line": 0
    },
    {
      "hash": 16779425045634929805,
      "kind": "Function",
      "name": "symlink_metadata",
      "signature": "fn # [doc = \" Queries the file system metadata for a path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::symlink_metadata`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::symlink_metadata\"] pub async fn symlink_metadata (path : impl AsRef < Path >) -> io :: Result < Metadata > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: symlink_metadata (path)) . await } . sig",
      "file_path": "tokio/src/fs/symlink_metadata.rs",
      "line": 0
    },
    {
      "hash": 6113863447578961807,
      "kind": "Function",
      "name": "try_exists",
      "signature": "fn # [doc = \" Returns `Ok(true)` if the path points at an existing entity.\"] # [doc = \"\"] # [doc = \" This function will traverse symbolic links to query information about the\"] # [doc = \" destination file. In case of broken symbolic links this will return `Ok(false)`.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::path::Path::try_exists`][std].\"] # [doc = \"\"] # [doc = \" [std]: fn@std::path::Path::try_exists\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::try_exists(\\\"foo.txt\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn try_exists (path : impl AsRef < Path >) -> io :: Result < bool > { let path = path . as_ref () . to_owned () ; asyncify (move | | path . try_exists ()) . await } . sig",
      "file_path": "tokio/src/fs/try_exists.rs",
      "line": 0
    },
    {
      "hash": 14584704772184903180,
      "kind": "Function",
      "name": "write",
      "signature": "fn # [doc = \" Creates a future that will open a file for writing and write the entire\"] # [doc = \" contents of `contents` to it.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::write`][std].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \" [std]: fn@std::fs::write\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::write(\\\"foo.txt\\\", b\\\"Hello world!\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn write (path : impl AsRef < Path > , contents : impl AsRef < [u8] >) -> io :: Result < () > { let path = path . as_ref () ; let contents = crate :: util :: as_ref :: upgrade (contents) ; # [cfg (all (tokio_unstable , feature = \"io-uring\" , feature = \"rt\" , feature = \"fs\" , target_os = \"linux\"))] { let handle = crate :: runtime :: Handle :: current () ; let driver_handle = handle . inner . driver () . io () ; if driver_handle . check_and_init () ? { return write_uring (path , contents) . await ; } } write_spawn_blocking (path , contents) . await } . sig",
      "file_path": "tokio/src/fs/write.rs",
      "line": 0
    },
    {
      "hash": 1284504228516132360,
      "kind": "Function",
      "name": "write_uring",
      "signature": "fn # [cfg (all (tokio_unstable , feature = \"io-uring\" , feature = \"rt\" , feature = \"fs\" , target_os = \"linux\"))] async fn write_uring (path : & Path , mut buf : OwnedBuf) -> io :: Result < () > { use crate :: { fs :: OpenOptions , runtime :: driver :: op :: Op } ; use std :: os :: fd :: OwnedFd ; let file = OpenOptions :: new () . write (true) . create (true) . truncate (true) . open (path) . await ? ; let mut fd : OwnedFd = file . try_into_std () . expect (\"unexpected in-flight operation detected\") . into () ; let total : usize = buf . as_ref () . len () ; let mut buf_offset : usize = 0 ; let mut file_offset : u64 = 0 ; while buf_offset < total { let (n , _buf , _fd) = Op :: write_at (fd , buf , buf_offset , file_offset) ? . await ? ; if n == 0 { return Err (io :: ErrorKind :: WriteZero . into ()) ; } buf = _buf ; fd = _fd ; buf_offset += n as usize ; file_offset += n as u64 ; } Ok (()) } . sig",
      "file_path": "tokio/src/fs/write.rs",
      "line": 0
    },
    {
      "hash": 1234454924545468321,
      "kind": "Function",
      "name": "write_spawn_blocking",
      "signature": "fn async fn write_spawn_blocking (path : & Path , contents : OwnedBuf) -> io :: Result < () > { let path = path . to_owned () ; asyncify (move | | std :: fs :: write (path , contents)) . await } . sig",
      "file_path": "tokio/src/fs/write.rs",
      "line": 0
    },
    {
      "hash": 8965938418186564290,
      "kind": "Function",
      "name": "open_read",
      "signature": "fn # [test] fn open_read () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_eq ! (0 , pool :: len ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 10234911856501972990,
      "kind": "Function",
      "name": "read_twice_before_dispatch",
      "signature": "fn # [test] fn read_twice_before_dispatch () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 1876069020161171541,
      "kind": "Function",
      "name": "read_with_smaller_buf",
      "signature": "fn # [test] fn read_with_smaller_buf () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 4) ; assert_eq ! (& buf [..] , & HELLO [.. n]) ; } let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 10) ; assert_eq ! (& buf [.. n] , & HELLO [4 ..]) ; assert_eq ! (0 , pool :: len ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 12954131690218848150,
      "kind": "Function",
      "name": "read_with_bigger_buf",
      "signature": "fn # [test] fn read_with_bigger_buf () { let mut seq = Sequence :: new () ; let mut file = MockFile :: default () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. 4] . copy_from_slice (& HELLO [.. 4]) ; Ok (4) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len () - 4] . copy_from_slice (& HELLO [4 ..]) ; Ok (HELLO . len () - 4) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 4) ; assert_eq ! (& buf [.. n] , & HELLO [.. n]) ; } let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 10) ; assert_eq ! (& buf [.. n] , & HELLO [4 ..]) ; assert_eq ! (0 , pool :: len ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 14900958922916352813,
      "kind": "Function",
      "name": "read_err_then_read_success",
      "signature": "fn # [test] fn read_err_then_read_success () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert_ready_err ! (t . poll ()) ; } { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 17394528321374773295,
      "kind": "Function",
      "name": "open_write",
      "signature": "fn # [test] fn open_write () { let mut file = MockFile :: default () ; file . expect_inner_write () . once () . with (eq (HELLO)) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_eq ! (0 , pool :: len ()) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (! t . is_woken ()) ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 15724994677983891361,
      "kind": "Function",
      "name": "flush_while_idle",
      "signature": "fn # [test] fn flush_while_idle () { let file = MockFile :: default () ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 2315814267933325692,
      "kind": "Function",
      "name": "read_with_buffer_larger_than_max",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn read_with_buffer_larger_than_max () { let chunk_a = crate :: io :: blocking :: DEFAULT_MAX_BUF_SIZE ; let chunk_b = chunk_a * 2 ; let chunk_c = chunk_a * 3 ; let chunk_d = chunk_a * 4 ; assert_eq ! (chunk_d / 1024 / 1024 , 8) ; let mut data = vec ! [] ; for i in 0 .. (chunk_d - 1) { data . push ((i % 151) as u8) ; } let data = Arc :: new (data) ; let d0 = data . clone () ; let d1 = data . clone () ; let d2 = data . clone () ; let d3 = data . clone () ; let mut seq = Sequence :: new () ; let mut file = MockFile :: default () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [0 .. chunk_a] . copy_from_slice (& d0 [0 .. chunk_a]) ; Ok (chunk_a) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a] . copy_from_slice (& d1 [chunk_a .. chunk_b]) ; Ok (chunk_b - chunk_a) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a] . copy_from_slice (& d2 [chunk_b .. chunk_c]) ; Ok (chunk_c - chunk_b) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a - 1] . copy_from_slice (& d3 [chunk_c ..]) ; Ok (chunk_a - 1) }) ; let mut file = File :: from_std (file) ; let mut actual = vec ! [0 ; chunk_d] ; let mut pos = 0 ; while pos < data . len () { let mut t = task :: spawn (file . read (& mut actual [pos ..])) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert ! (n <= chunk_a) ; pos += n ; } assert_eq ! (& data [..] , & actual [.. data . len ()]) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 2923705531445781206,
      "kind": "Function",
      "name": "write_with_buffer_larger_than_max",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn write_with_buffer_larger_than_max () { let chunk_a = crate :: io :: blocking :: DEFAULT_MAX_BUF_SIZE ; let chunk_b = chunk_a * 2 ; let chunk_c = chunk_a * 3 ; let chunk_d = chunk_a * 4 ; assert_eq ! (chunk_d / 1024 / 1024 , 8) ; let mut data = vec ! [] ; for i in 0 .. (chunk_d - 1) { data . push ((i % 151) as u8) ; } let data = Arc :: new (data) ; let d0 = data . clone () ; let d1 = data . clone () ; let d2 = data . clone () ; let d3 = data . clone () ; let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d0 [0 .. chunk_a]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d1 [chunk_a .. chunk_b]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d2 [chunk_b .. chunk_c]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d3 [chunk_c .. chunk_d - 1]) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut rem = & data [..] ; let mut first = true ; while ! rem . is_empty () { let mut task = task :: spawn (file . write (rem)) ; if ! first { assert_pending ! (task . poll ()) ; pool :: run_one () ; assert ! (task . is_woken ()) ; } first = false ; let n = assert_ready_ok ! (task . poll ()) ; rem = & rem [n ..] ; } pool :: run_one () ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 4787080881594454979,
      "kind": "Function",
      "name": "write_twice_before_dispatch",
      "signature": "fn # [test] fn write_twice_before_dispatch () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . flush ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 7933619443660578153,
      "kind": "Function",
      "name": "incomplete_read_followed_by_write",
      "signature": "fn # [test] fn incomplete_read_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 12585535503420727776,
      "kind": "Function",
      "name": "incomplete_partial_read_followed_by_write",
      "signature": "fn # [test] fn incomplete_partial_read_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . in_sequence (& mut seq) . with (eq (SeekFrom :: Current (- 10))) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 3302533612083352487,
      "kind": "Function",
      "name": "incomplete_read_followed_by_flush",
      "signature": "fn # [test] fn incomplete_read_followed_by_flush () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . in_sequence (& mut seq) . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 6807801794723131283,
      "kind": "Function",
      "name": "incomplete_flush_followed_by_write",
      "signature": "fn # [test] fn incomplete_flush_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; let mut t = task :: spawn (file . flush ()) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 4499961879699476434,
      "kind": "Function",
      "name": "read_err",
      "signature": "fn # [test] fn read_err () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 13984253985629519944,
      "kind": "Function",
      "name": "write_write_err",
      "signature": "fn # [test] fn write_write_err () { let mut file = MockFile :: default () ; file . expect_inner_write () . once () . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 10590295755685931704,
      "kind": "Function",
      "name": "write_read_write_err",
      "signature": "fn # [test] fn write_read_write_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 8048897321797244907,
      "kind": "Function",
      "name": "write_read_flush_err",
      "signature": "fn # [test] fn write_read_flush_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 5207033131624525672,
      "kind": "Function",
      "name": "write_seek_write_err",
      "signature": "fn # [test] fn write_seek_write_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Start (0))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; { let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 3066526331947094361,
      "kind": "Function",
      "name": "write_seek_flush_err",
      "signature": "fn # [test] fn write_seek_flush_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Start (0))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; { let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 12373129326952495675,
      "kind": "Function",
      "name": "sync_all_ordered_after_write",
      "signature": "fn # [test] fn sync_all_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_all () . once () . returning (| | Ok (())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_all ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 14513877068339470911,
      "kind": "Function",
      "name": "sync_all_err_ordered_after_write",
      "signature": "fn # [test] fn sync_all_err_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_all () . once () . returning (| | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_all ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 9501878190995698845,
      "kind": "Function",
      "name": "sync_data_ordered_after_write",
      "signature": "fn # [test] fn sync_data_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_data () . once () . returning (| | Ok (())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_data ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 6826606171863136789,
      "kind": "Function",
      "name": "sync_data_err_ordered_after_write",
      "signature": "fn # [test] fn sync_data_err_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_data () . once () . returning (| | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_data ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 18144562114071419140,
      "kind": "Function",
      "name": "open_set_len_ok",
      "signature": "fn # [test] fn open_set_len_ok () { let mut file = MockFile :: default () ; file . expect_set_len () . with (eq (123)) . returning (| _ | Ok (())) ; let file = File :: from_std (file) ; let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 2267853598406014330,
      "kind": "Function",
      "name": "open_set_len_err",
      "signature": "fn # [test] fn open_set_len_err () { let mut file = MockFile :: default () ; file . expect_set_len () . with (eq (123)) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let file = File :: from_std (file) ; let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 4500590667553169577,
      "kind": "Function",
      "name": "partial_read_set_len_ok",
      "signature": "fn # [test] fn partial_read_set_len_ok () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; file . expect_set_len () . once () . in_sequence (& mut seq) . with (eq (123)) . returning (| _ | Ok (())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. FOO . len ()] . copy_from_slice (FOO) ; Ok (FOO . len ()) }) ; let mut buf = [0 ; 32] ; let mut file = File :: from_std (file) ; { let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert_ready_ok ! (t . poll ()) ; } let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , FOO . len ()) ; assert_eq ! (& buf [.. n] , FOO) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 2402131703899093313,
      "kind": "Function",
      "name": "busy_file_seek_error",
      "signature": "fn # [test] fn busy_file_seek_error () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = crate :: io :: BufReader :: new (File :: from_std (file)) ; { let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_ready_err ! (t . poll ()) ; } . sig",
      "file_path": "tokio/src/fs/file/tests.rs",
      "line": 0
    },
    {
      "hash": 14518642087829130126,
      "kind": "Struct",
      "name": "UringOpenOptions",
      "signature": "struct UringOpenOptions",
      "file_path": "tokio/src/fs/open_options/uring_open_options.rs",
      "line": 0
    },
    {
      "hash": 9414500474105433358,
      "kind": "Function",
      "name": "maybe_done",
      "signature": "fn # [doc = \" Wraps a future into a `MaybeDone`.\"] pub fn maybe_done < F : IntoFuture > (future : F) -> MaybeDone < F :: IntoFuture > { MaybeDone :: Future { future : future . into_future () , } } . sig",
      "file_path": "tokio/src/future/maybe_done.rs",
      "line": 0
    },
    {
      "hash": 7670161098547737263,
      "kind": "Trait",
      "name": "InstrumentedFuture",
      "signature": "trait InstrumentedFuture",
      "file_path": "tokio/src/future/trace.rs",
      "line": 0
    },
    {
      "hash": 3683295440906321540,
      "kind": "Function",
      "name": "try_join3",
      "signature": "fn pub (crate) fn try_join3 < T1 , F1 , T2 , F2 , T3 , F3 , E > (future1 : F1 , future2 : F2 , future3 : F3 ,) -> TryJoin3 < F1 , F2 , F3 > where F1 : Future < Output = Result < T1 , E > > , F2 : Future < Output = Result < T2 , E > > , F3 : Future < Output = Result < T3 , E > > , { TryJoin3 { future1 : maybe_done (future1) , future2 : maybe_done (future2) , future3 : maybe_done (future3) , } } . sig",
      "file_path": "tokio/src/future/try_join.rs",
      "line": 0
    },
    {
      "hash": 6345512993515642476,
      "kind": "Trait",
      "name": "AsyncBufRead",
      "signature": "trait AsyncBufRead",
      "file_path": "tokio/src/io/async_buf_read.rs",
      "line": 0
    },
    {
      "hash": 1167953265164851858,
      "kind": "Trait",
      "name": "AsyncRead",
      "signature": "trait AsyncRead",
      "file_path": "tokio/src/io/async_read.rs",
      "line": 0
    },
    {
      "hash": 5016206522292079398,
      "kind": "Trait",
      "name": "AsyncSeek",
      "signature": "trait AsyncSeek",
      "file_path": "tokio/src/io/async_seek.rs",
      "line": 0
    },
    {
      "hash": 14879562979410301075,
      "kind": "Trait",
      "name": "AsyncWrite",
      "signature": "trait AsyncWrite",
      "file_path": "tokio/src/io/async_write.rs",
      "line": 0
    },
    {
      "hash": 17915046734210526762,
      "kind": "Struct",
      "name": "Blocking",
      "signature": "struct Blocking",
      "file_path": "tokio/src/io/blocking.rs",
      "line": 0
    },
    {
      "hash": 4811367854430024608,
      "kind": "Struct",
      "name": "Buf",
      "signature": "struct Buf",
      "file_path": "tokio/src/io/blocking.rs",
      "line": 0
    },
    {
      "hash": 11815005443235129830,
      "kind": "Struct",
      "name": "Interest",
      "signature": "struct Interest",
      "file_path": "tokio/src/io/interest.rs",
      "line": 0
    },
    {
      "hash": 13291555821520292715,
      "kind": "Function",
      "name": "join",
      "signature": "fn # [doc = \" Join two values implementing `AsyncRead` and `AsyncWrite` into a\"] # [doc = \" single handle.\"] pub fn join < R , W > (reader : R , writer : W) -> Join < R , W > where R : AsyncRead , W : AsyncWrite , { Join { reader , writer } } . sig",
      "file_path": "tokio/src/io/join.rs",
      "line": 0
    },
    {
      "hash": 10654647625993360615,
      "kind": "Struct",
      "name": "ReadBuf",
      "signature": "struct ReadBuf",
      "file_path": "tokio/src/io/read_buf.rs",
      "line": 0
    },
    {
      "hash": 6239651531998686585,
      "kind": "Function",
      "name": "slice_to_uninit_mut",
      "signature": "fn unsafe fn slice_to_uninit_mut (slice : & mut [u8]) -> & mut [MaybeUninit < u8 >] { & mut * (slice as * mut [u8] as * mut [MaybeUninit < u8 >]) } . sig",
      "file_path": "tokio/src/io/read_buf.rs",
      "line": 0
    },
    {
      "hash": 11049734510172965443,
      "kind": "Function",
      "name": "slice_assume_init",
      "signature": "fn unsafe fn slice_assume_init (slice : & [MaybeUninit < u8 >]) -> & [u8] { & * (slice as * const [MaybeUninit < u8 >] as * const [u8]) } . sig",
      "file_path": "tokio/src/io/read_buf.rs",
      "line": 0
    },
    {
      "hash": 7649965432671019517,
      "kind": "Function",
      "name": "slice_assume_init_mut",
      "signature": "fn unsafe fn slice_assume_init_mut (slice : & mut [MaybeUninit < u8 >]) -> & mut [u8] { & mut * (slice as * mut [MaybeUninit < u8 >] as * mut [u8]) } . sig",
      "file_path": "tokio/src/io/read_buf.rs",
      "line": 0
    },
    {
      "hash": 12653597373939716282,
      "kind": "Struct",
      "name": "Ready",
      "signature": "struct Ready",
      "file_path": "tokio/src/io/ready.rs",
      "line": 0
    },
    {
      "hash": 16000105034349372693,
      "kind": "Function",
      "name": "seek",
      "signature": "fn pub (crate) fn seek < S > (seek : & mut S , pos : SeekFrom) -> Seek < '_ , S > where S : AsyncSeek + ? Sized + Unpin , { Seek { seek , pos : Some (pos) , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/seek.rs",
      "line": 0
    },
    {
      "hash": 4864556232596093461,
      "kind": "Struct",
      "name": "SplitByUtf8BoundaryIfWindows",
      "signature": "struct SplitByUtf8BoundaryIfWindows",
      "file_path": "tokio/src/io/stdio_common.rs",
      "line": 0
    },
    {
      "hash": 723631225940744240,
      "kind": "Trait",
      "name": "AioSource",
      "signature": "trait AioSource",
      "file_path": "tokio/src/io/bsd/poll_aio.rs",
      "line": 0
    },
    {
      "hash": 14632550413250512930,
      "kind": "Struct",
      "name": "MioSource",
      "signature": "struct MioSource",
      "file_path": "tokio/src/io/bsd/poll_aio.rs",
      "line": 0
    },
    {
      "hash": 4355068537033798308,
      "kind": "Struct",
      "name": "Aio",
      "signature": "struct Aio",
      "file_path": "tokio/src/io/bsd/poll_aio.rs",
      "line": 0
    },
    {
      "hash": 17003849476923712649,
      "kind": "Struct",
      "name": "AioEvent",
      "signature": "struct AioEvent",
      "file_path": "tokio/src/io/bsd/poll_aio.rs",
      "line": 0
    },
    {
      "hash": 6939176434371988369,
      "kind": "Struct",
      "name": "Open",
      "signature": "struct Open",
      "file_path": "tokio/src/io/uring/open.rs",
      "line": 0
    },
    {
      "hash": 4739502433269013736,
      "kind": "Function",
      "name": "cstr",
      "signature": "fn pub (crate) fn cstr (p : & Path) -> io :: Result < CString > { Ok (CString :: new (p . as_os_str () . as_bytes ()) ?) } . sig",
      "file_path": "tokio/src/io/uring/utils.rs",
      "line": 0
    },
    {
      "hash": 15197901525454809434,
      "kind": "Struct",
      "name": "Write",
      "signature": "struct Write",
      "file_path": "tokio/src/io/uring/write.rs",
      "line": 0
    },
    {
      "hash": 9802431309618957698,
      "kind": "Function",
      "name": "chain",
      "signature": "fn pub (super) fn chain < T , U > (first : T , second : U) -> Chain < T , U > where T : AsyncRead , U : AsyncRead , { Chain { first , second , done_first : false , } } . sig",
      "file_path": "tokio/src/io/util/chain.rs",
      "line": 0
    },
    {
      "hash": 8547815621594284024,
      "kind": "Struct",
      "name": "CopyBuffer",
      "signature": "struct CopyBuffer",
      "file_path": "tokio/src/io/util/copy.rs",
      "line": 0
    },
    {
      "hash": 416640111808512217,
      "kind": "Struct",
      "name": "Copy",
      "signature": "struct Copy",
      "file_path": "tokio/src/io/util/copy.rs",
      "line": 0
    },
    {
      "hash": 13864870859363027577,
      "kind": "Function",
      "name": "transfer_one_direction",
      "signature": "fn fn transfer_one_direction < A , B > (cx : & mut Context < '_ > , state : & mut TransferState , r : & mut A , w : & mut B ,) -> Poll < io :: Result < u64 > > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { let mut r = Pin :: new (r) ; let mut w = Pin :: new (w) ; loop { match state { TransferState :: Running (buf) => { let count = ready ! (buf . poll_copy (cx , r . as_mut () , w . as_mut ())) ? ; * state = TransferState :: ShuttingDown (count) ; } TransferState :: ShuttingDown (count) => { ready ! (w . as_mut () . poll_shutdown (cx)) ? ; * state = TransferState :: Done (* count) ; } TransferState :: Done (count) => return Poll :: Ready (Ok (* count)) , } } } . sig",
      "file_path": "tokio/src/io/util/copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 17178458744420004773,
      "kind": "Function",
      "name": "copy_bidirectional",
      "signature": "fn # [doc = \" Copies data in both directions between `a` and `b`.\"] # [doc = \"\"] # [doc = \" This function returns a future that will read from both streams,\"] # [doc = \" writing any data read to the opposing stream.\"] # [doc = \" This happens in both directions concurrently.\"] # [doc = \"\"] # [doc = \" If an EOF is observed on one stream, [`shutdown()`] will be invoked on\"] # [doc = \" the other, and reading from that stream will stop. Copying of data in\"] # [doc = \" the other direction will continue.\"] # [doc = \"\"] # [doc = \" The future will complete successfully once both directions of communication has been shut down.\"] # [doc = \" A direction is shut down when the reader reports EOF,\"] # [doc = \" at which point [`shutdown()`] is called on the corresponding writer. When finished,\"] # [doc = \" it will return a tuple of the number of bytes copied from a to b\"] # [doc = \" and the number of bytes copied from b to a, in that order.\"] # [doc = \"\"] # [doc = \" It uses two 8 KB buffers for transferring bytes between `a` and `b` by default.\"] # [doc = \" To set your own buffers sizes use [`copy_bidirectional_with_sizes()`].\"] # [doc = \"\"] # [doc = \" [`shutdown()`]: crate::io::AsyncWriteExt::shutdown\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" The future will immediately return an error if any IO operation on `a`\"] # [doc = \" or `b` returns an error. Some data read from either stream may be lost (not\"] # [doc = \" written to the other stream) in this case.\"] # [doc = \"\"] # [doc = \" # Return value\"] # [doc = \"\"] # [doc = \" Returns a tuple of bytes copied `a` to `b` and bytes copied `b` to `a`.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub async fn copy_bidirectional < A , B > (a : & mut A , b : & mut B) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { copy_bidirectional_impl (a , b , CopyBuffer :: new (super :: DEFAULT_BUF_SIZE) , CopyBuffer :: new (super :: DEFAULT_BUF_SIZE) ,) . await } . sig",
      "file_path": "tokio/src/io/util/copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 17674167433702706079,
      "kind": "Function",
      "name": "copy_bidirectional_with_sizes",
      "signature": "fn # [doc = \" Copies data in both directions between `a` and `b` using buffers of the specified size.\"] # [doc = \"\"] # [doc = \" This method is the same as the [`copy_bidirectional()`], except that it allows you to set the\"] # [doc = \" size of the internal buffers used when copying data.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub async fn copy_bidirectional_with_sizes < A , B > (a : & mut A , b : & mut B , a_to_b_buf_size : usize , b_to_a_buf_size : usize ,) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { copy_bidirectional_impl (a , b , CopyBuffer :: new (a_to_b_buf_size) , CopyBuffer :: new (b_to_a_buf_size) ,) . await } . sig",
      "file_path": "tokio/src/io/util/copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 9152597321821027706,
      "kind": "Function",
      "name": "copy_bidirectional_impl",
      "signature": "fn async fn copy_bidirectional_impl < A , B > (a : & mut A , b : & mut B , a_to_b_buffer : CopyBuffer , b_to_a_buffer : CopyBuffer ,) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { let mut a_to_b = TransferState :: Running (a_to_b_buffer) ; let mut b_to_a = TransferState :: Running (b_to_a_buffer) ; poll_fn (| cx | { let a_to_b = transfer_one_direction (cx , & mut a_to_b , a , b) ? ; let b_to_a = transfer_one_direction (cx , & mut b_to_a , b , a) ? ; let a_to_b = ready ! (a_to_b) ; let b_to_a = ready ! (b_to_a) ; Poll :: Ready (Ok ((a_to_b , b_to_a))) }) . await } . sig",
      "file_path": "tokio/src/io/util/copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 12734057158106501110,
      "kind": "Function",
      "name": "fill_buf",
      "signature": "fn pub (crate) fn fill_buf < R > (reader : & mut R) -> FillBuf < '_ , R > where R : AsyncBufRead + ? Sized + Unpin , { FillBuf { reader : Some (reader) , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/fill_buf.rs",
      "line": 0
    },
    {
      "hash": 18352725520409328706,
      "kind": "Function",
      "name": "flush",
      "signature": "fn # [doc = \" Creates a future which will entirely flush an I/O object.\"] pub (super) fn flush < A > (a : & mut A) -> Flush < '_ , A > where A : AsyncWrite + Unpin + ? Sized , { Flush { a , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/flush.rs",
      "line": 0
    },
    {
      "hash": 16584701443716357071,
      "kind": "Function",
      "name": "lines",
      "signature": "fn pub (crate) fn lines < R > (reader : R) -> Lines < R > where R : AsyncBufRead , { Lines { reader , buf : String :: new () , bytes : Vec :: new () , read : 0 , } } . sig",
      "file_path": "tokio/src/io/util/lines.rs",
      "line": 0
    },
    {
      "hash": 4673202845414328072,
      "kind": "Struct",
      "name": "DuplexStream",
      "signature": "struct DuplexStream",
      "file_path": "tokio/src/io/util/mem.rs",
      "line": 0
    },
    {
      "hash": 15745933203372030422,
      "kind": "Struct",
      "name": "SimplexStream",
      "signature": "struct SimplexStream",
      "file_path": "tokio/src/io/util/mem.rs",
      "line": 0
    },
    {
      "hash": 2435048278288932645,
      "kind": "Function",
      "name": "duplex",
      "signature": "fn # [doc = \" Create a new pair of `DuplexStream`s that act like a pair of connected sockets.\"] # [doc = \"\"] # [doc = \" The `max_buf_size` argument is the maximum amount of bytes that can be\"] # [doc = \" written to a side before the write returns `Poll::Pending`.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub fn duplex (max_buf_size : usize) -> (DuplexStream , DuplexStream) { let one = Arc :: new (Mutex :: new (SimplexStream :: new_unsplit (max_buf_size))) ; let two = Arc :: new (Mutex :: new (SimplexStream :: new_unsplit (max_buf_size))) ; (DuplexStream { read : one . clone () , write : two . clone () , } , DuplexStream { read : two , write : one , } ,) } . sig",
      "file_path": "tokio/src/io/util/mem.rs",
      "line": 0
    },
    {
      "hash": 11565219069097536846,
      "kind": "Function",
      "name": "simplex",
      "signature": "fn # [doc = \" Creates unidirectional buffer that acts like in memory pipe.\"] # [doc = \"\"] # [doc = \" The `max_buf_size` argument is the maximum amount of bytes that can be\"] # [doc = \" written to a buffer before the it returns `Poll::Pending`.\"] # [doc = \"\"] # [doc = \" # Unify reader and writer\"] # [doc = \"\"] # [doc = \" The reader and writer half can be unified into a single structure\"] # [doc = \" of `SimplexStream` that supports both reading and writing or\"] # [doc = \" the `SimplexStream` can be already created as unified structure\"] # [doc = \" using [`SimplexStream::new_unsplit()`].\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # async fn ex() -> std::io::Result<()> {\"] # [doc = \" # use tokio::io::{AsyncReadExt, AsyncWriteExt};\"] # [doc = \" let (reader, writer) = tokio::io::simplex(64);\"] # [doc = \" let mut simplex_stream = reader.unsplit(writer);\"] # [doc = \" simplex_stream.write_all(b\\\"hello\\\").await?;\"] # [doc = \"\"] # [doc = \" let mut buf = [0u8; 5];\"] # [doc = \" simplex_stream.read_exact(&mut buf).await?;\"] # [doc = \" assert_eq!(&buf, b\\\"hello\\\");\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub fn simplex (max_buf_size : usize) -> (ReadHalf < SimplexStream > , WriteHalf < SimplexStream >) { split (SimplexStream :: new_unsplit (max_buf_size)) } . sig",
      "file_path": "tokio/src/io/util/mem.rs",
      "line": 0
    },
    {
      "hash": 13021355639545692071,
      "kind": "Function",
      "name": "read",
      "signature": "fn # [doc = \" Tries to read some bytes directly into the given `buf` in asynchronous\"] # [doc = \" manner, returning a future type.\"] # [doc = \"\"] # [doc = \" The returned future will resolve to both the I/O stream and the buffer\"] # [doc = \" as well as the number of bytes read once the read operation is completed.\"] pub (crate) fn read < 'a , R > (reader : & 'a mut R , buf : & 'a mut [u8]) -> Read < 'a , R > where R : AsyncRead + Unpin + ? Sized , { Read { reader , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read.rs",
      "line": 0
    },
    {
      "hash": 3881965412715411282,
      "kind": "Function",
      "name": "read_buf",
      "signature": "fn pub (crate) fn read_buf < 'a , R , B > (reader : & 'a mut R , buf : & 'a mut B) -> ReadBuf < 'a , R , B > where R : AsyncRead + Unpin + ? Sized , B : BufMut + ? Sized , { ReadBuf { reader , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_buf.rs",
      "line": 0
    },
    {
      "hash": 9032194239588820842,
      "kind": "Function",
      "name": "read_exact",
      "signature": "fn # [doc = \" A future which can be used to easily read exactly enough bytes to fill\"] # [doc = \" a buffer.\"] # [doc = \"\"] # [doc = \" Created by the [`AsyncReadExt::read_exact`][read_exact].\"] # [doc = \" [`read_exact`]: [`crate::io::AsyncReadExt::read_exact`]\"] pub (crate) fn read_exact < 'a , A > (reader : & 'a mut A , buf : & 'a mut [u8]) -> ReadExact < 'a , A > where A : AsyncRead + Unpin + ? Sized , { ReadExact { reader , buf : ReadBuf :: new (buf) , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_exact.rs",
      "line": 0
    },
    {
      "hash": 17060494203331018902,
      "kind": "Function",
      "name": "eof",
      "signature": "fn fn eof () -> io :: Error { io :: Error :: new (io :: ErrorKind :: UnexpectedEof , \"early eof\") } . sig",
      "file_path": "tokio/src/io/util/read_exact.rs",
      "line": 0
    },
    {
      "hash": 5289561164712869645,
      "kind": "Function",
      "name": "read_line",
      "signature": "fn pub (crate) fn read_line < 'a , R > (reader : & 'a mut R , string : & 'a mut String) -> ReadLine < 'a , R > where R : AsyncBufRead + ? Sized + Unpin , { ReadLine { reader , buf : mem :: take (string) . into_bytes () , output : string , read : 0 , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_line.rs",
      "line": 0
    },
    {
      "hash": 16795228189103900900,
      "kind": "Function",
      "name": "put_back_original_data",
      "signature": "fn fn put_back_original_data (output : & mut String , mut vector : Vec < u8 > , num_bytes_read : usize) { let original_len = vector . len () - num_bytes_read ; vector . truncate (original_len) ; * output = String :: from_utf8 (vector) . expect (\"The original data must be valid utf-8.\") ; } . sig",
      "file_path": "tokio/src/io/util/read_line.rs",
      "line": 0
    },
    {
      "hash": 112084374363379485,
      "kind": "Function",
      "name": "finish_string_read",
      "signature": "fn # [doc = \" This handles the various failure cases and puts the string back into `output`.\"] # [doc = \"\"] # [doc = \" The `truncate_on_io_error` `bool` is necessary because `read_to_string` and `read_line`\"] # [doc = \" disagree on what should happen when an IO error occurs.\"] pub (super) fn finish_string_read (io_res : io :: Result < usize > , utf8_res : Result < String , FromUtf8Error > , read : usize , output : & mut String , truncate_on_io_error : bool ,) -> Poll < io :: Result < usize > > { match (io_res , utf8_res) { (Ok (num_bytes) , Ok (string)) => { debug_assert_eq ! (read , 0) ; * output = string ; Poll :: Ready (Ok (num_bytes)) } (Err (io_err) , Ok (string)) => { * output = string ; if truncate_on_io_error { let original_len = output . len () - read ; output . truncate (original_len) ; } Poll :: Ready (Err (io_err)) } (Ok (num_bytes) , Err (utf8_err)) => { debug_assert_eq ! (read , 0) ; put_back_original_data (output , utf8_err . into_bytes () , num_bytes) ; Poll :: Ready (Err (io :: Error :: new (io :: ErrorKind :: InvalidData , \"stream did not contain valid UTF-8\" ,))) } (Err (io_err) , Err (utf8_err)) => { put_back_original_data (output , utf8_err . into_bytes () , read) ; Poll :: Ready (Err (io_err)) } } } . sig",
      "file_path": "tokio/src/io/util/read_line.rs",
      "line": 0
    },
    {
      "hash": 10104373066004512297,
      "kind": "Function",
      "name": "read_line_internal",
      "signature": "fn pub (super) fn read_line_internal < R : AsyncBufRead + ? Sized > (reader : Pin < & mut R > , cx : & mut Context < '_ > , output : & mut String , buf : & mut Vec < u8 > , read : & mut usize ,) -> Poll < io :: Result < usize > > { let io_res = ready ! (read_until_internal (reader , cx , b'\\n' , buf , read)) ; let utf8_res = String :: from_utf8 (mem :: take (buf)) ; debug_assert ! (buf . is_empty ()) ; debug_assert ! (output . is_empty ()) ; finish_string_read (io_res , utf8_res , * read , output , false) } . sig",
      "file_path": "tokio/src/io/util/read_line.rs",
      "line": 0
    },
    {
      "hash": 5299524993920266840,
      "kind": "Function",
      "name": "read_to_end",
      "signature": "fn pub (crate) fn read_to_end < 'a , R > (reader : & 'a mut R , buffer : & 'a mut Vec < u8 >) -> ReadToEnd < 'a , R > where R : AsyncRead + Unpin + ? Sized , { ReadToEnd { reader , buf : VecWithInitialized :: new (buffer) , read : 0 , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_to_end.rs",
      "line": 0
    },
    {
      "hash": 13649373015325027924,
      "kind": "Function",
      "name": "read_to_end_internal",
      "signature": "fn pub (super) fn read_to_end_internal < V : VecU8 , R : AsyncRead + ? Sized > (buf : & mut VecWithInitialized < V > , mut reader : Pin < & mut R > , num_read : & mut usize , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { loop { let ret = ready ! (poll_read_to_end (buf , reader . as_mut () , cx)) ; match ret { Err (err) => return Poll :: Ready (Err (err)) , Ok (0) => return Poll :: Ready (Ok (mem :: replace (num_read , 0))) , Ok (num) => { * num_read += num ; } } } } . sig",
      "file_path": "tokio/src/io/util/read_to_end.rs",
      "line": 0
    },
    {
      "hash": 7011312261085191191,
      "kind": "Function",
      "name": "poll_read_to_end",
      "signature": "fn # [doc = \" Tries to read from the provided [`AsyncRead`].\"] # [doc = \"\"] # [doc = \" The length of the buffer is increased by the number of bytes read.\"] fn poll_read_to_end < V : VecU8 , R : AsyncRead + ? Sized > (buf : & mut VecWithInitialized < V > , read : Pin < & mut R > , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { const NUM_BYTES : usize = 32 ; let try_small_read = buf . try_small_read_first (NUM_BYTES) ; let mut read_buf ; let poll_result ; let n = if try_small_read { let mut small_buf : [MaybeUninit < u8 > ; NUM_BYTES] = [MaybeUninit :: uninit () ; NUM_BYTES] ; let mut small_read_buf = ReadBuf :: uninit (& mut small_buf) ; poll_result = read . poll_read (cx , & mut small_read_buf) ; let to_write = small_read_buf . filled () ; read_buf = buf . get_read_buf () ; if to_write . len () > read_buf . remaining () { buf . reserve (NUM_BYTES) ; read_buf = buf . get_read_buf () ; } read_buf . put_slice (to_write) ; to_write . len () } else { buf . reserve (NUM_BYTES) ; read_buf = buf . get_read_buf () ; let filled_before = read_buf . filled () . len () ; poll_result = read . poll_read (cx , & mut read_buf) ; read_buf . filled () . len () - filled_before } ; let read_buf_parts = into_read_buf_parts (read_buf) ; buf . apply_read_buf (read_buf_parts) ; match poll_result { Poll :: Pending => { debug_assert_eq ! (n , 0) ; Poll :: Pending } Poll :: Ready (Err (err)) => { debug_assert_eq ! (n , 0) ; Poll :: Ready (Err (err)) } Poll :: Ready (Ok (())) => Poll :: Ready (Ok (n)) , } } . sig",
      "file_path": "tokio/src/io/util/read_to_end.rs",
      "line": 0
    },
    {
      "hash": 957399118234462674,
      "kind": "Function",
      "name": "read_to_string",
      "signature": "fn pub (crate) fn read_to_string < 'a , R > (reader : & 'a mut R , string : & 'a mut String ,) -> ReadToString < 'a , R > where R : AsyncRead + ? Sized + Unpin , { let buf = mem :: take (string) . into_bytes () ; ReadToString { reader , buf : VecWithInitialized :: new (buf) , output : string , read : 0 , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_to_string.rs",
      "line": 0
    },
    {
      "hash": 11126720048788740402,
      "kind": "Function",
      "name": "read_to_string_internal",
      "signature": "fn fn read_to_string_internal < R : AsyncRead + ? Sized > (reader : Pin < & mut R > , output : & mut String , buf : & mut VecWithInitialized < Vec < u8 > > , read : & mut usize , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { let io_res = ready ! (read_to_end_internal (buf , reader , read , cx)) ; let utf8_res = String :: from_utf8 (buf . take ()) ; debug_assert ! (buf . is_empty ()) ; debug_assert ! (output . is_empty ()) ; finish_string_read (io_res , utf8_res , * read , output , true) } . sig",
      "file_path": "tokio/src/io/util/read_to_string.rs",
      "line": 0
    },
    {
      "hash": 4185613733266741913,
      "kind": "Function",
      "name": "read_until",
      "signature": "fn pub (crate) fn read_until < 'a , R > (reader : & 'a mut R , delimiter : u8 , buf : & 'a mut Vec < u8 > ,) -> ReadUntil < 'a , R > where R : AsyncBufRead + ? Sized + Unpin , { ReadUntil { reader , delimiter , buf , read : 0 , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/read_until.rs",
      "line": 0
    },
    {
      "hash": 14910133100399010771,
      "kind": "Function",
      "name": "read_until_internal",
      "signature": "fn pub (super) fn read_until_internal < R : AsyncBufRead + ? Sized > (mut reader : Pin < & mut R > , cx : & mut Context < '_ > , delimiter : u8 , buf : & mut Vec < u8 > , read : & mut usize ,) -> Poll < io :: Result < usize > > { loop { let (done , used) = { let available = ready ! (reader . as_mut () . poll_fill_buf (cx)) ? ; if let Some (i) = memchr :: memchr (delimiter , available) { buf . extend_from_slice (& available [..= i]) ; (true , i + 1) } else { buf . extend_from_slice (available) ; (false , available . len ()) } } ; reader . as_mut () . consume (used) ; * read += used ; if done || used == 0 { return Poll :: Ready (Ok (mem :: replace (read , 0))) ; } } } . sig",
      "file_path": "tokio/src/io/util/read_until.rs",
      "line": 0
    },
    {
      "hash": 12469792550894673731,
      "kind": "Function",
      "name": "shutdown",
      "signature": "fn # [doc = \" Creates a future which will shutdown an I/O object.\"] pub (super) fn shutdown < A > (a : & mut A) -> Shutdown < '_ , A > where A : AsyncWrite + Unpin + ? Sized , { Shutdown { a , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/shutdown.rs",
      "line": 0
    },
    {
      "hash": 13357598992759813113,
      "kind": "Function",
      "name": "split",
      "signature": "fn pub (crate) fn split < R > (reader : R , delim : u8) -> Split < R > where R : AsyncBufRead , { Split { reader , buf : Vec :: new () , delim , read : 0 , } } . sig",
      "file_path": "tokio/src/io/util/split.rs",
      "line": 0
    },
    {
      "hash": 9245909516109513112,
      "kind": "Function",
      "name": "take",
      "signature": "fn pub (super) fn take < R : AsyncRead > (inner : R , limit : u64) -> Take < R > { Take { inner , limit_ : limit , } } . sig",
      "file_path": "tokio/src/io/util/take.rs",
      "line": 0
    },
    {
      "hash": 16217997696412741380,
      "kind": "Trait",
      "name": "VecU8",
      "signature": "trait VecU8",
      "file_path": "tokio/src/io/util/vec_with_initialized.rs",
      "line": 0
    },
    {
      "hash": 16850245347144182176,
      "kind": "Struct",
      "name": "VecWithInitialized",
      "signature": "struct VecWithInitialized",
      "file_path": "tokio/src/io/util/vec_with_initialized.rs",
      "line": 0
    },
    {
      "hash": 6879972518537704187,
      "kind": "Struct",
      "name": "ReadBufParts",
      "signature": "struct ReadBufParts",
      "file_path": "tokio/src/io/util/vec_with_initialized.rs",
      "line": 0
    },
    {
      "hash": 12604626439136198119,
      "kind": "Function",
      "name": "into_read_buf_parts",
      "signature": "fn pub (crate) fn into_read_buf_parts (rb : ReadBuf < '_ >) -> ReadBufParts { ReadBufParts { ptr : rb . filled () . as_ptr () , len : rb . filled () . len () , initialized : rb . initialized () . len () , } } . sig",
      "file_path": "tokio/src/io/util/vec_with_initialized.rs",
      "line": 0
    },
    {
      "hash": 13071618479892550591,
      "kind": "Function",
      "name": "write",
      "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write < 'a , W > (writer : & 'a mut W , buf : & 'a [u8]) -> Write < 'a , W > where W : AsyncWrite + Unpin + ? Sized , { Write { writer , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/write.rs",
      "line": 0
    },
    {
      "hash": 10558191852619735075,
      "kind": "Function",
      "name": "write_all",
      "signature": "fn pub (crate) fn write_all < 'a , W > (writer : & 'a mut W , buf : & 'a [u8]) -> WriteAll < 'a , W > where W : AsyncWrite + Unpin + ? Sized , { WriteAll { writer , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/write_all.rs",
      "line": 0
    },
    {
      "hash": 2252776787147826938,
      "kind": "Function",
      "name": "write_all_buf",
      "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write_all_buf < 'a , W , B > (writer : & 'a mut W , buf : & 'a mut B) -> WriteAllBuf < 'a , W , B > where W : AsyncWrite + Unpin , B : Buf , { WriteAllBuf { writer , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/write_all_buf.rs",
      "line": 0
    },
    {
      "hash": 6545330506524724230,
      "kind": "Function",
      "name": "write_buf",
      "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write_buf < 'a , W , B > (writer : & 'a mut W , buf : & 'a mut B) -> WriteBuf < 'a , W , B > where W : AsyncWrite + Unpin , B : Buf , { WriteBuf { writer , buf , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/write_buf.rs",
      "line": 0
    },
    {
      "hash": 9950115793843090410,
      "kind": "Function",
      "name": "write_vectored",
      "signature": "fn pub (crate) fn write_vectored < 'a , 'b , W > (writer : & 'a mut W , bufs : & 'a [IoSlice < 'b >] ,) -> WriteVectored < 'a , 'b , W > where W : AsyncWrite + Unpin + ? Sized , { WriteVectored { writer , bufs , _pin : PhantomPinned , } } . sig",
      "file_path": "tokio/src/io/util/write_vectored.rs",
      "line": 0
    },
    {
      "hash": 8035980277751108689,
      "kind": "Struct",
      "name": "AtomicU16",
      "signature": "struct AtomicU16",
      "file_path": "tokio/src/loom/std/atomic_u16.rs",
      "line": 0
    },
    {
      "hash": 7031916463067712422,
      "kind": "Struct",
      "name": "AtomicU32",
      "signature": "struct AtomicU32",
      "file_path": "tokio/src/loom/std/atomic_u32.rs",
      "line": 0
    },
    {
      "hash": 2496875989417849615,
      "kind": "Struct",
      "name": "AtomicU64",
      "signature": "struct AtomicU64",
      "file_path": "tokio/src/loom/std/atomic_u64_as_mutex.rs",
      "line": 0
    },
    {
      "hash": 14194726099908242524,
      "kind": "Struct",
      "name": "StaticAtomicU64",
      "signature": "struct StaticAtomicU64",
      "file_path": "tokio/src/loom/std/atomic_u64_static_once_cell.rs",
      "line": 0
    },
    {
      "hash": 15562354346157419544,
      "kind": "Struct",
      "name": "AtomicUsize",
      "signature": "struct AtomicUsize",
      "file_path": "tokio/src/loom/std/atomic_usize.rs",
      "line": 0
    },
    {
      "hash": 1537046269477535614,
      "kind": "Struct",
      "name": "Barrier",
      "signature": "struct Barrier",
      "file_path": "tokio/src/sync/barrier.rs",
      "line": 0
    },
    {
      "hash": 13301721414272360939,
      "kind": "Struct",
      "name": "BarrierState",
      "signature": "struct BarrierState",
      "file_path": "tokio/src/sync/barrier.rs",
      "line": 0
    },
    {
      "hash": 10765219489927572808,
      "kind": "Struct",
      "name": "BarrierWaitResult",
      "signature": "struct BarrierWaitResult",
      "file_path": "tokio/src/sync/barrier.rs",
      "line": 0
    },
    {
      "hash": 9809121699596567856,
      "kind": "Struct",
      "name": "Mutex",
      "signature": "struct Mutex",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 4103560949734909982,
      "kind": "Struct",
      "name": "RwLock",
      "signature": "struct RwLock",
      "file_path": "tokio/src/sync/rwlock.rs",
      "line": 0
    },
    {
      "hash": 12390819425631279626,
      "kind": "Struct",
      "name": "Condvar",
      "signature": "struct Condvar",
      "file_path": "tokio/src/loom/std/parking_lot.rs",
      "line": 0
    },
    {
      "hash": 970187139602289372,
      "kind": "Struct",
      "name": "MutexGuard",
      "signature": "struct MutexGuard",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 17402285446407453362,
      "kind": "Struct",
      "name": "RwLockReadGuard",
      "signature": "struct RwLockReadGuard",
      "file_path": "tokio/src/sync/rwlock/read_guard.rs",
      "line": 0
    },
    {
      "hash": 15896343101583145333,
      "kind": "Struct",
      "name": "RwLockWriteGuard",
      "signature": "struct RwLockWriteGuard",
      "file_path": "tokio/src/sync/rwlock/write_guard.rs",
      "line": 0
    },
    {
      "hash": 14298566096312325503,
      "kind": "Struct",
      "name": "UnsafeCell",
      "signature": "struct UnsafeCell",
      "file_path": "tokio/src/loom/std/unsafe_cell.rs",
      "line": 0
    },
    {
      "hash": 5790051155030096730,
      "kind": "Trait",
      "name": "RotatorSelect",
      "signature": "trait RotatorSelect",
      "file_path": "tokio/src/macros/join.rs",
      "line": 0
    },
    {
      "hash": 13365453521122244993,
      "kind": "Struct",
      "name": "SelectNormal",
      "signature": "struct SelectNormal",
      "file_path": "tokio/src/macros/join.rs",
      "line": 0
    },
    {
      "hash": 2793446354954954618,
      "kind": "Struct",
      "name": "SelectBiased",
      "signature": "struct SelectBiased",
      "file_path": "tokio/src/macros/join.rs",
      "line": 0
    },
    {
      "hash": 12005587811289871661,
      "kind": "Struct",
      "name": "Rotator",
      "signature": "struct Rotator",
      "file_path": "tokio/src/macros/join.rs",
      "line": 0
    },
    {
      "hash": 11779899995655754545,
      "kind": "Struct",
      "name": "BiasedRotator",
      "signature": "struct BiasedRotator",
      "file_path": "tokio/src/macros/join.rs",
      "line": 0
    },
    {
      "hash": 2700627531662076923,
      "kind": "Trait",
      "name": "ToSocketAddrs",
      "signature": "trait ToSocketAddrs",
      "file_path": "tokio/src/net/addr.rs",
      "line": 0
    },
    {
      "hash": 11716424246046734362,
      "kind": "Function",
      "name": "convert_address",
      "signature": "fn fn convert_address (address : socket2 :: SockAddr) -> io :: Result < SocketAddr > { match address . as_socket () { Some (address) => Ok (address) , None => Err (io :: Error :: new (io :: ErrorKind :: InvalidInput , \"invalid address family (not IPv4 or IPv6)\" ,)) , } } . sig",
      "file_path": "tokio/src/net/tcp/socket.rs",
      "line": 0
    },
    {
      "hash": 6577844766864615769,
      "kind": "Struct",
      "name": "ReadHalf",
      "signature": "struct ReadHalf",
      "file_path": "tokio/src/net/unix/split.rs",
      "line": 0
    },
    {
      "hash": 6512766496802867014,
      "kind": "Struct",
      "name": "WriteHalf",
      "signature": "struct WriteHalf",
      "file_path": "tokio/src/net/unix/split.rs",
      "line": 0
    },
    {
      "hash": 1615443346433756703,
      "kind": "Function",
      "name": "split",
      "signature": "fn pub (crate) fn split (stream : & mut TcpStream) -> (ReadHalf < '_ > , WriteHalf < '_ >) { (ReadHalf (& * stream) , WriteHalf (& * stream)) } . sig",
      "file_path": "tokio/src/net/tcp/split.rs",
      "line": 0
    },
    {
      "hash": 14326435287121227,
      "kind": "Struct",
      "name": "OwnedReadHalf",
      "signature": "struct OwnedReadHalf",
      "file_path": "tokio/src/net/unix/split_owned.rs",
      "line": 0
    },
    {
      "hash": 5562919265722378797,
      "kind": "Struct",
      "name": "OwnedWriteHalf",
      "signature": "struct OwnedWriteHalf",
      "file_path": "tokio/src/net/unix/split_owned.rs",
      "line": 0
    },
    {
      "hash": 4027053457040031224,
      "kind": "Function",
      "name": "split_owned",
      "signature": "fn pub (crate) fn split_owned (stream : TcpStream) -> (OwnedReadHalf , OwnedWriteHalf) { let arc = Arc :: new (stream) ; let read = OwnedReadHalf { inner : Arc :: clone (& arc) , } ; let write = OwnedWriteHalf { inner : arc , shutdown_on_drop : true , } ; (read , write) } . sig",
      "file_path": "tokio/src/net/tcp/split_owned.rs",
      "line": 0
    },
    {
      "hash": 4016030442585124977,
      "kind": "Function",
      "name": "reunite",
      "signature": "fn pub (crate) fn reunite (read : OwnedReadHalf , write : OwnedWriteHalf ,) -> Result < TcpStream , ReuniteError > { if Arc :: ptr_eq (& read . inner , & write . inner) { write . forget () ; Ok (Arc :: try_unwrap (read . inner) . expect (\"TcpStream: try_unwrap failed in reunite\")) } else { Err (ReuniteError (read , write)) } } . sig",
      "file_path": "tokio/src/net/tcp/split_owned.rs",
      "line": 0
    },
    {
      "hash": 10674279678464129910,
      "kind": "Struct",
      "name": "ReuniteError",
      "signature": "struct ReuniteError",
      "file_path": "tokio/src/net/unix/split_owned.rs",
      "line": 0
    },
    {
      "hash": 7130976469513546441,
      "kind": "Struct",
      "name": "SocketAddr",
      "signature": "struct SocketAddr",
      "file_path": "tokio/src/net/unix/socketaddr.rs",
      "line": 0
    },
    {
      "hash": 1441301653616205168,
      "kind": "Function",
      "name": "split",
      "signature": "fn pub (crate) fn split (stream : & mut UnixStream) -> (ReadHalf < '_ > , WriteHalf < '_ >) { (ReadHalf (stream) , WriteHalf (stream)) } . sig",
      "file_path": "tokio/src/net/unix/split.rs",
      "line": 0
    },
    {
      "hash": 5391801888061797644,
      "kind": "Function",
      "name": "split_owned",
      "signature": "fn pub (crate) fn split_owned (stream : UnixStream) -> (OwnedReadHalf , OwnedWriteHalf) { let arc = Arc :: new (stream) ; let read = OwnedReadHalf { inner : Arc :: clone (& arc) , } ; let write = OwnedWriteHalf { inner : arc , shutdown_on_drop : true , } ; (read , write) } . sig",
      "file_path": "tokio/src/net/unix/split_owned.rs",
      "line": 0
    },
    {
      "hash": 7863989891689168784,
      "kind": "Function",
      "name": "reunite",
      "signature": "fn pub (crate) fn reunite (read : OwnedReadHalf , write : OwnedWriteHalf ,) -> Result < UnixStream , ReuniteError > { if Arc :: ptr_eq (& read . inner , & write . inner) { write . forget () ; Ok (Arc :: try_unwrap (read . inner) . expect (\"UnixStream: try_unwrap failed in reunite\")) } else { Err (ReuniteError (read , write)) } } . sig",
      "file_path": "tokio/src/net/unix/split_owned.rs",
      "line": 0
    },
    {
      "hash": 13342988012330023384,
      "kind": "Struct",
      "name": "UCred",
      "signature": "struct UCred",
      "file_path": "tokio/src/net/unix/ucred.rs",
      "line": 0
    },
    {
      "hash": 11849087384152744394,
      "kind": "Trait",
      "name": "Kill",
      "signature": "trait Kill",
      "file_path": "tokio/src/process/kill.rs",
      "line": 0
    },
    {
      "hash": 18168044383964444326,
      "kind": "Struct",
      "name": "Child",
      "signature": "struct Child",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 3132039080902624348,
      "kind": "Struct",
      "name": "Waiting",
      "signature": "struct Waiting",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 14608925219580340756,
      "kind": "Function",
      "name": "build_child",
      "signature": "fn pub (crate) fn build_child (mut child : StdChild) -> io :: Result < SpawnedChild > { let stdin = child . stdin . take () . map (stdio) . transpose () ? ; let stdout = child . stdout . take () . map (stdio) . transpose () ? ; let stderr = child . stderr . take () . map (stdio) . transpose () ? ; Ok (SpawnedChild { child : Child { child , waiting : None , } , stdin , stdout , stderr , }) } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 7671635427956008437,
      "kind": "Function",
      "name": "callback",
      "signature": "fn unsafe extern \"system\" fn callback (ptr : * mut std :: ffi :: c_void , _timer_fired : BOOLEAN) { let complete = & mut * (ptr as * mut Option < oneshot :: Sender < () > >) ; let _ = complete . take () . unwrap () . send (()) ; } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 9359461322482530292,
      "kind": "Struct",
      "name": "ArcFile",
      "signature": "struct ArcFile",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 15400329673815263752,
      "kind": "Struct",
      "name": "ChildStdio",
      "signature": "struct ChildStdio",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 14929812064397057700,
      "kind": "Function",
      "name": "stdio",
      "signature": "fn pub (super) fn stdio < T > (io : T) -> io :: Result < ChildStdio > where T : IntoRawHandle , { use std :: os :: windows :: prelude :: FromRawHandle ; let raw = Arc :: new (unsafe { StdFile :: from_raw_handle (io . into_raw_handle ()) }) ; let io = ArcFile (raw . clone ()) ; let io = unsafe { Blocking :: new (io) } ; Ok (ChildStdio { raw , io }) } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 6807119123201373721,
      "kind": "Function",
      "name": "convert_to_file",
      "signature": "fn fn convert_to_file (child_stdio : ChildStdio) -> io :: Result < StdFile > { let ChildStdio { raw , io } = child_stdio ; drop (io) ; Arc :: try_unwrap (raw) . or_else (| raw | duplicate_handle (& * raw)) } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 3500552371731984952,
      "kind": "Function",
      "name": "convert_to_stdio",
      "signature": "fn pub (crate) fn convert_to_stdio (child_stdio : ChildStdio) -> io :: Result < Stdio > { convert_to_file (child_stdio) . map (Stdio :: from) } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 7353554616612584408,
      "kind": "Function",
      "name": "duplicate_handle",
      "signature": "fn fn duplicate_handle < T : AsRawHandle > (io : & T) -> io :: Result < StdFile > { use std :: os :: windows :: prelude :: FromRawHandle ; unsafe { let mut dup_handle = INVALID_HANDLE_VALUE ; let cur_proc = GetCurrentProcess () ; let status = DuplicateHandle (cur_proc , io . as_raw_handle () as _ , cur_proc , & mut dup_handle , 0 , 0 , DUPLICATE_SAME_ACCESS ,) ; if status == 0 { return Err (io :: Error :: last_os_error ()) ; } Ok (StdFile :: from_raw_handle (dup_handle as _)) } } . sig",
      "file_path": "tokio/src/process/windows.rs",
      "line": 0
    },
    {
      "hash": 1799632238248677187,
      "kind": "Struct",
      "name": "GlobalOrphanQueue",
      "signature": "struct GlobalOrphanQueue",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 8541263622498983850,
      "kind": "Function",
      "name": "build_child",
      "signature": "fn pub (crate) fn build_child (mut child : StdChild) -> io :: Result < SpawnedChild > { let stdin = child . stdin . take () . map (stdio) . transpose () ? ; let stdout = child . stdout . take () . map (stdio) . transpose () ? ; let stderr = child . stderr . take () . map (stdio) . transpose () ? ; # [cfg (all (target_os = \"linux\" , feature = \"rt\"))] match pidfd_reaper :: PidfdReaper :: new (child , GlobalOrphanQueue) { Ok (pidfd_reaper) => { return Ok (SpawnedChild { child : Child :: PidfdReaper (pidfd_reaper) , stdin , stdout , stderr , }) } Err ((Some (err) , _child)) => return Err (err) , Err ((None , child_returned)) => child = child_returned , } let signal = signal (SignalKind :: child ()) ? ; Ok (SpawnedChild { child : Child :: SignalReaper (Reaper :: new (child , GlobalOrphanQueue , signal)) , stdin , stdout , stderr , }) } . sig",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 6681868935787467233,
      "kind": "Struct",
      "name": "Pipe",
      "signature": "struct Pipe",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 7373358377075864543,
      "kind": "Function",
      "name": "convert_to_blocking_file",
      "signature": "fn fn convert_to_blocking_file (io : ChildStdio) -> io :: Result < File > { let mut fd = io . inner . into_inner () ? . fd ; set_nonblocking (& mut fd , false) ? ; Ok (fd) } . sig",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 16781499450145015663,
      "kind": "Function",
      "name": "convert_to_stdio",
      "signature": "fn pub (crate) fn convert_to_stdio (io : ChildStdio) -> io :: Result < Stdio > { convert_to_blocking_file (io) . map (Stdio :: from) } . sig",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 12628104678798623362,
      "kind": "Function",
      "name": "set_nonblocking",
      "signature": "fn fn set_nonblocking < T : AsRawFd > (fd : & mut T , nonblocking : bool) -> io :: Result < () > { unsafe { let fd = fd . as_raw_fd () ; let previous = libc :: fcntl (fd , libc :: F_GETFL) ; if previous == - 1 { return Err (io :: Error :: last_os_error ()) ; } let new = if nonblocking { previous | libc :: O_NONBLOCK } else { previous & ! libc :: O_NONBLOCK } ; let r = libc :: fcntl (fd , libc :: F_SETFL , new) ; if r == - 1 { return Err (io :: Error :: last_os_error ()) ; } } Ok (()) } . sig",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 6472497223432865173,
      "kind": "Function",
      "name": "stdio",
      "signature": "fn pub (super) fn stdio < T > (io : T) -> io :: Result < ChildStdio > where T : IntoRawFd , { let mut pipe = Pipe :: from (io) ; set_nonblocking (& mut pipe , true) ? ; PollEvented :: new (pipe) . map (| inner | ChildStdio { inner }) } . sig",
      "file_path": "tokio/src/process/unix/mod.rs",
      "line": 0
    },
    {
      "hash": 10291146043784352541,
      "kind": "Trait",
      "name": "Wait",
      "signature": "trait Wait",
      "file_path": "tokio/src/process/unix/orphan.rs",
      "line": 0
    },
    {
      "hash": 11826005784536820338,
      "kind": "Trait",
      "name": "OrphanQueue",
      "signature": "trait OrphanQueue",
      "file_path": "tokio/src/process/unix/orphan.rs",
      "line": 0
    },
    {
      "hash": 13906014409535178303,
      "kind": "Struct",
      "name": "OrphanQueueImpl",
      "signature": "struct OrphanQueueImpl",
      "file_path": "tokio/src/process/unix/orphan.rs",
      "line": 0
    },
    {
      "hash": 11055329434416596956,
      "kind": "Function",
      "name": "drain_orphan_queue",
      "signature": "fn fn drain_orphan_queue < T > (mut queue : MutexGuard < '_ , Vec < T > >) where T : Wait , { for i in (0 .. queue . len ()) . rev () { match queue [i] . try_wait () { Ok (None) => { } Ok (Some (_)) | Err (_) => { queue . swap_remove (i) ; } } } drop (queue) ; } . sig",
      "file_path": "tokio/src/process/unix/orphan.rs",
      "line": 0
    },
    {
      "hash": 10712842903332264904,
      "kind": "Struct",
      "name": "Pidfd",
      "signature": "struct Pidfd",
      "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
      "line": 0
    },
    {
      "hash": 4852031882900174767,
      "kind": "Struct",
      "name": "PidfdReaperInner",
      "signature": "struct PidfdReaperInner",
      "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
      "line": 0
    },
    {
      "hash": 2478234730478248793,
      "kind": "Function",
      "name": "is_rt_shutdown_err",
      "signature": "fn # [allow (deprecated)] fn is_rt_shutdown_err (err : & io :: Error) -> bool { if let Some (inner) = err . get_ref () { err . kind () == io :: ErrorKind :: Other && inner . source () . is_none () && inner . description () == RUNTIME_SHUTTING_DOWN_ERROR } else { false } } . sig",
      "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
      "line": 0
    },
    {
      "hash": 10128229422878960331,
      "kind": "Struct",
      "name": "PidfdReaper",
      "signature": "struct PidfdReaper",
      "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
      "line": 0
    },
    {
      "hash": 14254838026186164895,
      "kind": "Struct",
      "name": "Reaper",
      "signature": "struct Reaper",
      "file_path": "tokio/src/process/unix/reap.rs",
      "line": 0
    },
    {
      "hash": 4936255414839591057,
      "kind": "Struct",
      "name": "Config",
      "signature": "struct Config",
      "file_path": "tokio/src/runtime/config.rs",
      "line": 0
    },
    {
      "hash": 15895993589705178815,
      "kind": "Struct",
      "name": "Context",
      "signature": "struct Context",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 6526086632450826991,
      "kind": "Function",
      "name": "thread_rng_n",
      "signature": "fn # [cfg (any (feature = \"macros\" , all (feature = \"sync\" , feature = \"rt\")))] pub (crate) fn thread_rng_n (n : u32) -> u32 { CONTEXT . with (| ctx | { let mut rng = ctx . rng . get () . unwrap_or_else (FastRand :: new) ; let ret = rng . fastrand_n (n) ; ctx . rng . set (Some (rng)) ; ret }) } . sig",
      "file_path": "tokio/src/runtime/context.rs",
      "line": 0
    },
    {
      "hash": 15553915853904102163,
      "kind": "Function",
      "name": "budget",
      "signature": "fn pub (crate) fn budget < R > (f : impl FnOnce (& Cell < coop :: Budget >) -> R) -> Result < R , AccessError > { CONTEXT . try_with (| ctx | f (& ctx . budget)) } . sig",
      "file_path": "tokio/src/runtime/context.rs",
      "line": 0
    },
    {
      "hash": 15646866472278851937,
      "kind": "Struct",
      "name": "Driver",
      "signature": "struct Driver",
      "file_path": "tokio/src/runtime/time/mod.rs",
      "line": 0
    },
    {
      "hash": 9414961859488016845,
      "kind": "Struct",
      "name": "Handle",
      "signature": "struct Handle",
      "file_path": "tokio-test/src/io.rs",
      "line": 0
    },
    {
      "hash": 17083925957949135367,
      "kind": "Struct",
      "name": "Cfg",
      "signature": "struct Cfg",
      "file_path": "tokio/src/runtime/driver.rs",
      "line": 0
    },
    {
      "hash": 2392454828865970887,
      "kind": "Struct",
      "name": "Dump",
      "signature": "struct Dump",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 14575083824621107331,
      "kind": "Struct",
      "name": "Tasks",
      "signature": "struct Tasks",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 6741387803506043794,
      "kind": "Struct",
      "name": "Task",
      "signature": "struct Task",
      "file_path": "tokio/tests/io_driver.rs",
      "line": 0
    },
    {
      "hash": 14739006244541652297,
      "kind": "Struct",
      "name": "Address",
      "signature": "struct Address",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 6495855856494695859,
      "kind": "Struct",
      "name": "BacktraceSymbol",
      "signature": "struct BacktraceSymbol",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 8418196382380775499,
      "kind": "Struct",
      "name": "BacktraceFrame",
      "signature": "struct BacktraceFrame",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 10367239397976935118,
      "kind": "Struct",
      "name": "Backtrace",
      "signature": "struct Backtrace",
      "file_path": "tokio/src/runtime/dump.rs",
      "line": 0
    },
    {
      "hash": 13039149255098101573,
      "kind": "Struct",
      "name": "Trace",
      "signature": "struct Trace",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 5125678851585431390,
      "kind": "Struct",
      "name": "EnterGuard",
      "signature": "struct EnterGuard",
      "file_path": "tokio/src/runtime/handle.rs",
      "line": 0
    },
    {
      "hash": 8239531028922241379,
      "kind": "Struct",
      "name": "TryCurrentError",
      "signature": "struct TryCurrentError",
      "file_path": "tokio/src/runtime/handle.rs",
      "line": 0
    },
    {
      "hash": 2867522172588991260,
      "kind": "Struct",
      "name": "Id",
      "signature": "struct Id",
      "file_path": "tokio/src/runtime/task/id.rs",
      "line": 0
    },
    {
      "hash": 9140395075608851404,
      "kind": "Struct",
      "name": "ParkThread",
      "signature": "struct ParkThread",
      "file_path": "tokio/src/runtime/park.rs",
      "line": 0
    },
    {
      "hash": 17649237033376615319,
      "kind": "Struct",
      "name": "UnparkThread",
      "signature": "struct UnparkThread",
      "file_path": "tokio/src/runtime/park.rs",
      "line": 0
    },
    {
      "hash": 14198858968964484858,
      "kind": "Struct",
      "name": "CachedParkThread",
      "signature": "struct CachedParkThread",
      "file_path": "tokio/src/runtime/park.rs",
      "line": 0
    },
    {
      "hash": 15652225210386572366,
      "kind": "Function",
      "name": "current_thread_park_count",
      "signature": "fn # [cfg (loom)] pub (crate) fn current_thread_park_count () -> usize { CURRENT_THREAD_PARK_COUNT . with (| count | count . load (SeqCst)) } . sig",
      "file_path": "tokio/src/runtime/park.rs",
      "line": 0
    },
    {
      "hash": 9382476031578584117,
      "kind": "Struct",
      "name": "Runtime",
      "signature": "struct Runtime",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 17749394841581429318,
      "kind": "Struct",
      "name": "TaskHooks",
      "signature": "struct TaskHooks",
      "file_path": "tokio/src/runtime/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 10390942779014104067,
      "kind": "Struct",
      "name": "TaskMeta",
      "signature": "struct TaskMeta",
      "file_path": "tokio/src/runtime/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 8852352222552441117,
      "kind": "Struct",
      "name": "ThreadId",
      "signature": "struct ThreadId",
      "file_path": "tokio/src/runtime/thread_id.rs",
      "line": 0
    },
    {
      "hash": 2013867546159912036,
      "kind": "Function",
      "name": "exhausted",
      "signature": "fn # [cold] # [allow (dead_code)] fn exhausted () -> ! { panic ! (\"failed to generate unique thread ID: bitspace exhausted\") } . sig",
      "file_path": "tokio/src/runtime/thread_id.rs",
      "line": 0
    },
    {
      "hash": 3110333464034572599,
      "kind": "Function",
      "name": "create_blocking_pool",
      "signature": "fn pub (crate) fn create_blocking_pool (builder : & Builder , thread_cap : usize) -> BlockingPool { BlockingPool :: new (builder , thread_cap) } . sig",
      "file_path": "tokio/src/runtime/blocking/mod.rs",
      "line": 0
    },
    {
      "hash": 1322008553397118637,
      "kind": "Struct",
      "name": "BlockingPool",
      "signature": "struct BlockingPool",
      "file_path": "tokio/src/runtime/blocking/pool.rs",
      "line": 0
    },
    {
      "hash": 11656716703676170115,
      "kind": "Struct",
      "name": "Spawner",
      "signature": "struct Spawner",
      "file_path": "tokio/src/runtime/blocking/pool.rs",
      "line": 0
    },
    {
      "hash": 8187675601702459156,
      "kind": "Struct",
      "name": "SpawnerMetrics",
      "signature": "struct SpawnerMetrics",
      "file_path": "tokio/src/runtime/blocking/pool.rs",
      "line": 0
    },
    {
      "hash": 15199467139456127842,
      "kind": "Function",
      "name": "spawn_blocking",
      "signature": "fn # [doc = \" Runs the provided function on an executor dedicated to blocking operations.\"] # [doc = \" Tasks will be scheduled as non-mandatory, meaning they may not get executed\"] # [doc = \" in case of runtime shutdown.\"] # [track_caller] # [cfg_attr (target_os = \"wasi\" , allow (dead_code))] pub (crate) fn spawn_blocking < F , R > (func : F) -> JoinHandle < R > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let rt = Handle :: current () ; rt . spawn_blocking (func) } . sig",
      "file_path": "tokio/src/runtime/blocking/pool.rs",
      "line": 0
    },
    {
      "hash": 3842286867804140117,
      "kind": "Function",
      "name": "is_temporary_os_thread_error",
      "signature": "fn # [inline] fn is_temporary_os_thread_error (error : & io :: Error) -> bool { matches ! (error . kind () , io :: ErrorKind :: WouldBlock) } . sig",
      "file_path": "tokio/src/runtime/blocking/pool.rs",
      "line": 0
    },
    {
      "hash": 17888422371133996900,
      "kind": "Struct",
      "name": "BlockingSchedule",
      "signature": "struct BlockingSchedule",
      "file_path": "tokio/src/runtime/blocking/schedule.rs",
      "line": 0
    },
    {
      "hash": 14973399440152806641,
      "kind": "Struct",
      "name": "Sender",
      "signature": "struct Sender",
      "file_path": "tokio/src/sync/oneshot.rs",
      "line": 0
    },
    {
      "hash": 3393886809286872111,
      "kind": "Struct",
      "name": "Receiver",
      "signature": "struct Receiver",
      "file_path": "tokio/src/sync/oneshot.rs",
      "line": 0
    },
    {
      "hash": 14828171829259718041,
      "kind": "Function",
      "name": "channel",
      "signature": "fn pub (super) fn channel () -> (Sender , Receiver) { let (tx , rx) = oneshot :: channel () ; let tx = Sender { _tx : Arc :: new (tx) } ; let rx = Receiver { rx } ; (tx , rx) } . sig",
      "file_path": "tokio/src/runtime/blocking/shutdown.rs",
      "line": 0
    },
    {
      "hash": 5850025147717976634,
      "kind": "Struct",
      "name": "BlockingTask",
      "signature": "struct BlockingTask",
      "file_path": "tokio/src/runtime/blocking/task.rs",
      "line": 0
    },
    {
      "hash": 13393193829726136262,
      "kind": "Struct",
      "name": "BlockingRegionGuard",
      "signature": "struct BlockingRegionGuard",
      "file_path": "tokio/src/runtime/context/blocking.rs",
      "line": 0
    },
    {
      "hash": 1424410147613777763,
      "kind": "Struct",
      "name": "DisallowBlockInPlaceGuard",
      "signature": "struct DisallowBlockInPlaceGuard",
      "file_path": "tokio/src/runtime/context/blocking.rs",
      "line": 0
    },
    {
      "hash": 5967507325951780242,
      "kind": "Function",
      "name": "try_enter_blocking_region",
      "signature": "fn pub (crate) fn try_enter_blocking_region () -> Option < BlockingRegionGuard > { CONTEXT . try_with (| c | { if c . runtime . get () . is_entered () { None } else { Some (BlockingRegionGuard :: new ()) } }) . unwrap_or_else (| _ | Some (BlockingRegionGuard :: new ())) } . sig",
      "file_path": "tokio/src/runtime/context/blocking.rs",
      "line": 0
    },
    {
      "hash": 7695858206849466231,
      "kind": "Function",
      "name": "disallow_block_in_place",
      "signature": "fn # [doc = \" Disallows blocking in the current runtime context until the guard is dropped.\"] pub (crate) fn disallow_block_in_place () -> DisallowBlockInPlaceGuard { let reset = CONTEXT . try_with (| c | { if let EnterRuntime :: Entered { allow_block_in_place : true , } = c . runtime . get () { c . runtime . set (EnterRuntime :: Entered { allow_block_in_place : false , }) ; true } else { false } }) ; DisallowBlockInPlaceGuard (reset . unwrap_or (false)) } . sig",
      "file_path": "tokio/src/runtime/context/blocking.rs",
      "line": 0
    },
    {
      "hash": 7758991035866602891,
      "kind": "Struct",
      "name": "SetCurrentGuard",
      "signature": "struct SetCurrentGuard",
      "file_path": "tokio/src/runtime/context/current.rs",
      "line": 0
    },
    {
      "hash": 12396025939514777175,
      "kind": "Struct",
      "name": "HandleCell",
      "signature": "struct HandleCell",
      "file_path": "tokio/src/runtime/context/current.rs",
      "line": 0
    },
    {
      "hash": 14872253411945052709,
      "kind": "Function",
      "name": "try_set_current",
      "signature": "fn # [doc = \" Sets this [`Handle`] as the current active [`Handle`].\"] # [doc = \"\"] # [doc = \" [`Handle`]: crate::runtime::scheduler::Handle\"] pub (crate) fn try_set_current (handle : & scheduler :: Handle) -> Option < SetCurrentGuard > { CONTEXT . try_with (| ctx | ctx . set_current (handle)) . ok () } . sig",
      "file_path": "tokio/src/runtime/context/current.rs",
      "line": 0
    },
    {
      "hash": 3649689108833086010,
      "kind": "Function",
      "name": "with_current",
      "signature": "fn pub (crate) fn with_current < F , R > (f : F) -> Result < R , TryCurrentError > where F : FnOnce (& scheduler :: Handle) -> R , { match CONTEXT . try_with (| ctx | ctx . current . handle . borrow () . as_ref () . map (f)) { Ok (Some (ret)) => Ok (ret) , Ok (None) => Err (TryCurrentError :: new_no_context ()) , Err (_access_error) => Err (TryCurrentError :: new_thread_local_destroyed ()) , } } . sig",
      "file_path": "tokio/src/runtime/context/current.rs",
      "line": 0
    },
    {
      "hash": 9083337840774793749,
      "kind": "Struct",
      "name": "EnterRuntimeGuard",
      "signature": "struct EnterRuntimeGuard",
      "file_path": "tokio/src/runtime/context/runtime.rs",
      "line": 0
    },
    {
      "hash": 13633373657926335581,
      "kind": "Function",
      "name": "enter_runtime",
      "signature": "fn # [doc = \" Marks the current thread as being within the dynamic extent of an\"] # [doc = \" executor.\"] # [track_caller] pub (crate) fn enter_runtime < F , R > (handle : & scheduler :: Handle , allow_block_in_place : bool , f : F) -> R where F : FnOnce (& mut BlockingRegionGuard) -> R , { let maybe_guard = CONTEXT . with (| c | { if c . runtime . get () . is_entered () { None } else { c . runtime . set (EnterRuntime :: Entered { allow_block_in_place , }) ; let rng_seed = handle . seed_generator () . next_seed () ; let mut rng = c . rng . get () . unwrap_or_else (FastRand :: new) ; let old_seed = rng . replace_seed (rng_seed) ; c . rng . set (Some (rng)) ; Some (EnterRuntimeGuard { blocking : BlockingRegionGuard :: new () , handle : c . set_current (handle) , old_seed , }) } }) ; if let Some (mut guard) = maybe_guard { return f (& mut guard . blocking) ; } panic ! (\"Cannot start a runtime from within a runtime. This happens \\\n            because a function (like `block_on`) attempted to block the \\\n            current thread while the thread is being used to drive \\\n            asynchronous tasks.\") ; } . sig",
      "file_path": "tokio/src/runtime/context/runtime.rs",
      "line": 0
    },
    {
      "hash": 8757362896214626213,
      "kind": "Function",
      "name": "current_enter_context",
      "signature": "fn # [doc = \" Returns true if in a runtime context.\"] pub (crate) fn current_enter_context () -> EnterRuntime { CONTEXT . with (| c | c . runtime . get ()) } . sig",
      "file_path": "tokio/src/runtime/context/runtime_mt.rs",
      "line": 0
    },
    {
      "hash": 18426568008349747254,
      "kind": "Function",
      "name": "exit_runtime",
      "signature": "fn # [doc = \" Forces the current \\\"entered\\\" state to be cleared while the closure\"] # [doc = \" is executed.\"] pub (crate) fn exit_runtime < F : FnOnce () -> R , R > (f : F) -> R { struct Reset (EnterRuntime) ; impl Drop for Reset { fn drop (& mut self) { CONTEXT . with (| c | { assert ! (! c . runtime . get () . is_entered () , \"closure claimed permanent executor\") ; c . runtime . set (self . 0) ; }) ; } } let was = CONTEXT . with (| c | { let e = c . runtime . get () ; assert ! (e . is_entered () , \"asked to exit when not entered\") ; c . runtime . set (EnterRuntime :: NotEntered) ; e }) ; let _reset = Reset (was) ; f () } . sig",
      "file_path": "tokio/src/runtime/context/runtime_mt.rs",
      "line": 0
    },
    {
      "hash": 17432448685060635387,
      "kind": "Struct",
      "name": "Scoped",
      "signature": "struct Scoped",
      "file_path": "tokio/src/runtime/context/scoped.rs",
      "line": 0
    },
    {
      "hash": 2919837469106164740,
      "kind": "Struct",
      "name": "Op",
      "signature": "struct Op",
      "file_path": "tokio/src/runtime/driver/op.rs",
      "line": 0
    },
    {
      "hash": 18180661251035268334,
      "kind": "Struct",
      "name": "CqeResult",
      "signature": "struct CqeResult",
      "file_path": "tokio/src/runtime/driver/op.rs",
      "line": 0
    },
    {
      "hash": 16713037418574429162,
      "kind": "Trait",
      "name": "Completable",
      "signature": "trait Completable",
      "file_path": "tokio/src/runtime/driver/op.rs",
      "line": 0
    },
    {
      "hash": 8257726979326412286,
      "kind": "Trait",
      "name": "Cancellable",
      "signature": "trait Cancellable",
      "file_path": "tokio/src/runtime/driver/op.rs",
      "line": 0
    },
    {
      "hash": 8235666133061664691,
      "kind": "Struct",
      "name": "ReadyEvent",
      "signature": "struct ReadyEvent",
      "file_path": "tokio/src/runtime/io/driver.rs",
      "line": 0
    },
    {
      "hash": 6364525469162961435,
      "kind": "Function",
      "name": "_assert_kinds",
      "signature": "fn fn _assert_kinds () { fn _assert < T : Send + Sync > () { } _assert :: < Handle > () ; } . sig",
      "file_path": "tokio/src/runtime/io/driver.rs",
      "line": 0
    },
    {
      "hash": 1742913523571080279,
      "kind": "Function",
      "name": "gone",
      "signature": "fn fn gone () -> io :: Error { io :: Error :: new (io :: ErrorKind :: Other , crate :: util :: error :: RUNTIME_SHUTTING_DOWN_ERROR ,) } . sig",
      "file_path": "tokio/src/runtime/io/registration.rs",
      "line": 0
    },
    {
      "hash": 3365883863542855754,
      "kind": "Struct",
      "name": "RegistrationSet",
      "signature": "struct RegistrationSet",
      "file_path": "tokio/src/runtime/io/registration_set.rs",
      "line": 0
    },
    {
      "hash": 15091221489153699079,
      "kind": "Struct",
      "name": "Synced",
      "signature": "struct Synced",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 11851047772012721739,
      "kind": "Struct",
      "name": "ScheduledIo",
      "signature": "struct ScheduledIo",
      "file_path": "tokio/src/runtime/io/scheduled_io.rs",
      "line": 0
    },
    {
      "hash": 13328688578841180319,
      "kind": "Struct",
      "name": "Waiters",
      "signature": "struct Waiters",
      "file_path": "tokio/src/runtime/io/scheduled_io.rs",
      "line": 0
    },
    {
      "hash": 9865831582146585299,
      "kind": "Struct",
      "name": "Waiter",
      "signature": "struct Waiter",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 6551529384806899515,
      "kind": "Struct",
      "name": "Readiness",
      "signature": "struct Readiness",
      "file_path": "tokio/src/runtime/io/scheduled_io.rs",
      "line": 0
    },
    {
      "hash": 12152460087345010116,
      "kind": "Struct",
      "name": "UringContext",
      "signature": "struct UringContext",
      "file_path": "tokio/src/runtime/io/driver/uring.rs",
      "line": 0
    },
    {
      "hash": 9916963687928350666,
      "kind": "Struct",
      "name": "LocalOptions",
      "signature": "struct LocalOptions",
      "file_path": "tokio/src/runtime/local_runtime/options.rs",
      "line": 0
    },
    {
      "hash": 6163872000780345201,
      "kind": "Struct",
      "name": "LocalRuntime",
      "signature": "struct LocalRuntime",
      "file_path": "tokio/src/runtime/local_runtime/runtime.rs",
      "line": 0
    },
    {
      "hash": 1119273607243901003,
      "kind": "Struct",
      "name": "MetricsBatch",
      "signature": "struct MetricsBatch",
      "file_path": "tokio/src/runtime/metrics/batch.rs",
      "line": 0
    },
    {
      "hash": 12288485990877264665,
      "kind": "Function",
      "name": "duration_as_u64",
      "signature": "fn pub (crate) fn duration_as_u64 (dur : Duration) -> u64 { u64 :: try_from (dur . as_nanos ()) . unwrap_or (u64 :: MAX) } . sig",
      "file_path": "tokio/src/runtime/metrics/batch.rs",
      "line": 0
    },
    {
      "hash": 6192068807249276806,
      "kind": "Function",
      "name": "now",
      "signature": "fn # [doc = \" Gate unsupported time metrics for `wasm32-unknown-unknown`\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/7319>\"] fn now () -> Option < Instant > { if cfg ! (all (target_arch = \"wasm32\" , target_os = \"unknown\" , target_vendor = \"unknown\")) { None } else { Some (Instant :: now ()) } } . sig",
      "file_path": "tokio/src/runtime/metrics/batch.rs",
      "line": 0
    },
    {
      "hash": 11719581595428777603,
      "kind": "Struct",
      "name": "Histogram",
      "signature": "struct Histogram",
      "file_path": "tokio/src/runtime/metrics/histogram.rs",
      "line": 0
    },
    {
      "hash": 8357125503531082097,
      "kind": "Struct",
      "name": "HistogramBuilder",
      "signature": "struct HistogramBuilder",
      "file_path": "tokio/src/runtime/metrics/mock.rs",
      "line": 0
    },
    {
      "hash": 13435874835810001127,
      "kind": "Struct",
      "name": "LegacyBuilder",
      "signature": "struct LegacyBuilder",
      "file_path": "tokio/src/runtime/metrics/histogram.rs",
      "line": 0
    },
    {
      "hash": 7405132643171153483,
      "kind": "Struct",
      "name": "HistogramBatch",
      "signature": "struct HistogramBatch",
      "file_path": "tokio/src/runtime/metrics/histogram.rs",
      "line": 0
    },
    {
      "hash": 6099052123804113495,
      "kind": "Struct",
      "name": "LinearHistogram",
      "signature": "struct LinearHistogram",
      "file_path": "tokio/src/runtime/metrics/histogram.rs",
      "line": 0
    },
    {
      "hash": 650118282191421301,
      "kind": "Struct",
      "name": "LegacyLogHistogram",
      "signature": "struct LegacyLogHistogram",
      "file_path": "tokio/src/runtime/metrics/histogram.rs",
      "line": 0
    },
    {
      "hash": 11625182269192488056,
      "kind": "Struct",
      "name": "IoDriverMetrics",
      "signature": "struct IoDriverMetrics",
      "file_path": "tokio/src/runtime/metrics/io.rs",
      "line": 0
    },
    {
      "hash": 2193459033823737389,
      "kind": "Struct",
      "name": "SchedulerMetrics",
      "signature": "struct SchedulerMetrics",
      "file_path": "tokio/src/runtime/metrics/scheduler.rs",
      "line": 0
    },
    {
      "hash": 13228963285924185949,
      "kind": "Struct",
      "name": "RuntimeMetrics",
      "signature": "struct RuntimeMetrics",
      "file_path": "tokio/src/runtime/metrics/runtime.rs",
      "line": 0
    },
    {
      "hash": 4128759151206728588,
      "kind": "Struct",
      "name": "WorkerMetrics",
      "signature": "struct WorkerMetrics",
      "file_path": "tokio/src/runtime/metrics/worker.rs",
      "line": 0
    },
    {
      "hash": 2275936414389616316,
      "kind": "Struct",
      "name": "LogHistogram",
      "signature": "struct LogHistogram",
      "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
      "line": 0
    },
    {
      "hash": 8018180204513728921,
      "kind": "Struct",
      "name": "LogHistogramBuilder",
      "signature": "struct LogHistogramBuilder",
      "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
      "line": 0
    },
    {
      "hash": 14658547637146918304,
      "kind": "Function",
      "name": "bucket_index",
      "signature": "fn # [doc = \" Compute the index for a given value + p combination\"] # [doc = \"\"] # [doc = \" This function does NOT enforce that the value is within the number of expected buckets.\"] fn bucket_index (value : u64 , p : u32) -> u64 { if value == 0 { return 0 ; } let h = 63 - value . leading_zeros () ; if h <= p { value } else { let w = h - p ; ((w + 1) * (1_u32 << p)) as u64 + ((value - (1_u64 << h)) >> w) } } . sig",
      "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
      "line": 0
    },
    {
      "hash": 8327977663772168807,
      "kind": "Function",
      "name": "block_in_place",
      "signature": "fn # [track_caller] pub (crate) fn block_in_place < F , R > (f : F) -> R where F : FnOnce () -> R , { scheduler :: multi_thread :: block_in_place (f) } . sig",
      "file_path": "tokio/src/runtime/scheduler/block_in_place.rs",
      "line": 0
    },
    {
      "hash": 11665541229258398343,
      "kind": "Struct",
      "name": "Defer",
      "signature": "struct Defer",
      "file_path": "tokio/src/runtime/scheduler/defer.rs",
      "line": 0
    },
    {
      "hash": 14348188884980354242,
      "kind": "Struct",
      "name": "Inject",
      "signature": "struct Inject",
      "file_path": "tokio/src/runtime/scheduler/inject.rs",
      "line": 0
    },
    {
      "hash": 12749312946512523502,
      "kind": "Trait",
      "name": "Lock",
      "signature": "trait Lock",
      "file_path": "tokio/src/runtime/scheduler/lock.rs",
      "line": 0
    },
    {
      "hash": 16867916544205988705,
      "kind": "Struct",
      "name": "CurrentThread",
      "signature": "struct CurrentThread",
      "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
      "line": 0
    },
    {
      "hash": 1601330200640500872,
      "kind": "Struct",
      "name": "Core",
      "signature": "struct Core",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 4905114153357296891,
      "kind": "Function",
      "name": "shutdown2",
      "signature": "fn fn shutdown2 (mut core : Box < Core > , handle : & Handle) -> Box < Core > { handle . shared . owned . close_and_shutdown_all (0) ; while let Some (task) = core . next_local_task (handle) { drop (task) ; } handle . shared . inject . close () ; while let Some (task) = handle . shared . inject . pop () { drop (task) ; } assert ! (handle . shared . owned . is_empty ()) ; core . submit_metrics (handle) ; if let Some (driver) = core . driver . as_mut () { driver . shutdown (& handle . driver) ; } core } . sig",
      "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
      "line": 0
    },
    {
      "hash": 8034736819089670008,
      "kind": "Function",
      "name": "wake_deferred_tasks_and_free",
      "signature": "fn # [cfg (tokio_taskdump)] fn wake_deferred_tasks_and_free (context : & Context) { let wakers = context . defer . take_deferred () ; for waker in wakers { waker . wake () ; } } . sig",
      "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
      "line": 0
    },
    {
      "hash": 16934921135111864104,
      "kind": "Struct",
      "name": "CoreGuard",
      "signature": "struct CoreGuard",
      "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
      "line": 0
    },
    {
      "hash": 8259914765716403570,
      "kind": "Struct",
      "name": "Pop",
      "signature": "struct Pop",
      "file_path": "tokio/src/runtime/scheduler/inject/pop.rs",
      "line": 0
    },
    {
      "hash": 16845938302918152041,
      "kind": "Struct",
      "name": "Counters",
      "signature": "struct Counters",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/counters.rs",
      "line": 0
    },
    {
      "hash": 17201157818720284268,
      "kind": "Struct",
      "name": "Idle",
      "signature": "struct Idle",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/idle.rs",
      "line": 0
    },
    {
      "hash": 4732865856052426954,
      "kind": "Struct",
      "name": "State",
      "signature": "struct State",
      "file_path": "tokio/src/sync/oneshot.rs",
      "line": 0
    },
    {
      "hash": 11127558370520948754,
      "kind": "Function",
      "name": "test_state",
      "signature": "fn # [test] fn test_state () { assert_eq ! (0 , UNPARK_MASK & SEARCH_MASK) ; assert_eq ! (0 , ! (UNPARK_MASK | SEARCH_MASK)) ; let state = State :: new (10) ; assert_eq ! (10 , state . num_unparked ()) ; assert_eq ! (0 , state . num_searching ()) ; } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/idle.rs",
      "line": 0
    },
    {
      "hash": 4650779686731058741,
      "kind": "Struct",
      "name": "MultiThread",
      "signature": "struct MultiThread",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/mod.rs",
      "line": 0
    },
    {
      "hash": 1177113876295277905,
      "kind": "Trait",
      "name": "Overflow",
      "signature": "trait Overflow",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/overflow.rs",
      "line": 0
    },
    {
      "hash": 9818747445302197576,
      "kind": "Struct",
      "name": "Parker",
      "signature": "struct Parker",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/park.rs",
      "line": 0
    },
    {
      "hash": 11196048500090000305,
      "kind": "Struct",
      "name": "Unparker",
      "signature": "struct Unparker",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/park.rs",
      "line": 0
    },
    {
      "hash": 5283359893197682170,
      "kind": "Struct",
      "name": "Local",
      "signature": "struct Local",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 2456145149683692405,
      "kind": "Struct",
      "name": "Steal",
      "signature": "struct Steal",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 5033122755955530681,
      "kind": "Function",
      "name": "make_fixed_size",
      "signature": "fn fn make_fixed_size < T > (buffer : Box < [T] >) -> Box < [T ; LOCAL_QUEUE_CAPACITY] > { assert_eq ! (buffer . len () , LOCAL_QUEUE_CAPACITY) ; unsafe { Box :: from_raw (Box :: into_raw (buffer) . cast ()) } } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 8220325008158956218,
      "kind": "Function",
      "name": "local",
      "signature": "fn # [doc = \" Create a new local run-queue\"] pub (crate) fn local < T : 'static > () -> (Steal < T > , Local < T >) { let mut buffer = Vec :: with_capacity (LOCAL_QUEUE_CAPACITY) ; for _ in 0 .. LOCAL_QUEUE_CAPACITY { buffer . push (UnsafeCell :: new (MaybeUninit :: uninit ())) ; } let inner = Arc :: new (Inner { head : AtomicUnsignedLong :: new (0) , tail : AtomicUnsignedShort :: new (0) , buffer : make_fixed_size (buffer . into_boxed_slice ()) , }) ; let local = Local { inner : inner . clone () , } ; let remote = Steal (inner) ; (remote , local) } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 4228751531413172393,
      "kind": "Function",
      "name": "len",
      "signature": "fn # [doc = \" Calculate the length of the queue using the head and tail.\"] # [doc = \" The `head` can be the `steal` or `real` head.\"] fn len (head : UnsignedShort , tail : UnsignedShort) -> usize { tail . wrapping_sub (head) as usize } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 1176554255696880613,
      "kind": "Function",
      "name": "unpack",
      "signature": "fn # [doc = \" Split the head value into the real head and the index a stealer is working\"] # [doc = \" on.\"] fn unpack (n : UnsignedLong) -> (UnsignedShort , UnsignedShort) { let real = n & UnsignedShort :: MAX as UnsignedLong ; let steal = n >> (mem :: size_of :: < UnsignedShort > () * 8) ; (steal as UnsignedShort , real as UnsignedShort) } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 655726136316602349,
      "kind": "Function",
      "name": "pack",
      "signature": "fn # [doc = \" Join the two head values\"] fn pack (steal : UnsignedShort , real : UnsignedShort) -> UnsignedLong { (real as UnsignedLong) | ((steal as UnsignedLong) << (mem :: size_of :: < UnsignedShort > () * 8)) } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 1517890114865082981,
      "kind": "Function",
      "name": "test_local_queue_capacity",
      "signature": "fn # [test] fn test_local_queue_capacity () { assert ! (LOCAL_QUEUE_CAPACITY - 1 <= u8 :: MAX as usize) ; } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 12924622030832649099,
      "kind": "Struct",
      "name": "Stats",
      "signature": "struct Stats",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/stats.rs",
      "line": 0
    },
    {
      "hash": 10561431910557188985,
      "kind": "Struct",
      "name": "TraceStatus",
      "signature": "struct TraceStatus",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/trace_mock.rs",
      "line": 0
    },
    {
      "hash": 5619858525558069543,
      "kind": "Struct",
      "name": "Worker",
      "signature": "struct Worker",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 17695572755544807340,
      "kind": "Struct",
      "name": "Remote",
      "signature": "struct Remote",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 1458624117494685637,
      "kind": "Struct",
      "name": "Launch",
      "signature": "struct Launch",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 2744088267201905582,
      "kind": "Function",
      "name": "create",
      "signature": "fn pub (super) fn create (size : usize , park : Parker , driver_handle : driver :: Handle , blocking_spawner : blocking :: Spawner , seed_generator : RngSeedGenerator , config : Config ,) -> (Arc < Handle > , Launch) { let mut cores = Vec :: with_capacity (size) ; let mut remotes = Vec :: with_capacity (size) ; let mut worker_metrics = Vec :: with_capacity (size) ; for _ in 0 .. size { let (steal , run_queue) = queue :: local () ; let park = park . clone () ; let unpark = park . unpark () ; let metrics = WorkerMetrics :: from_config (& config) ; let stats = Stats :: new (& metrics) ; cores . push (Box :: new (Core { tick : 0 , lifo_slot : None , lifo_enabled : ! config . disable_lifo_slot , run_queue , is_searching : false , is_shutdown : false , is_traced : false , park : Some (park) , global_queue_interval : stats . tuned_global_queue_interval (& config) , stats , rand : FastRand :: from_seed (config . seed_generator . next_seed ()) , })) ; remotes . push (Remote { steal , unpark }) ; worker_metrics . push (metrics) ; } let (idle , idle_synced) = Idle :: new (size) ; let (inject , inject_synced) = inject :: Shared :: new () ; let remotes_len = remotes . len () ; let handle = Arc :: new (Handle { task_hooks : TaskHooks :: from_config (& config) , shared : Shared { remotes : remotes . into_boxed_slice () , inject , idle , owned : OwnedTasks :: new (size) , synced : Mutex :: new (Synced { idle : idle_synced , inject : inject_synced , }) , shutdown_cores : Mutex :: new (vec ! []) , trace_status : TraceStatus :: new (remotes_len) , config , scheduler_metrics : SchedulerMetrics :: new () , worker_metrics : worker_metrics . into_boxed_slice () , _counters : Counters , } , driver : driver_handle , blocking_spawner , seed_generator , }) ; let mut launch = Launch (vec ! []) ; for (index , core) in cores . drain (..) . enumerate () { launch . 0 . push (Arc :: new (Worker { handle : handle . clone () , index , core : AtomicCell :: new (Some (core)) , })) ; } (handle , launch) } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 15278437079339204227,
      "kind": "Function",
      "name": "block_in_place",
      "signature": "fn # [track_caller] pub (crate) fn block_in_place < F , R > (f : F) -> R where F : FnOnce () -> R , { struct Reset { take_core : bool , budget : coop :: Budget , } impl Drop for Reset { fn drop (& mut self) { with_current (| maybe_cx | { if let Some (cx) = maybe_cx { if self . take_core { let core = cx . worker . core . take () ; if core . is_some () { cx . worker . handle . shared . worker_metrics [cx . worker . index] . set_thread_id (thread :: current () . id ()) ; } let mut cx_core = cx . core . borrow_mut () ; assert ! (cx_core . is_none ()) ; * cx_core = core ; } coop :: set (self . budget) ; } }) ; } } let mut had_entered = false ; let mut take_core = false ; let setup_result = with_current (| maybe_cx | { match (crate :: runtime :: context :: current_enter_context () , maybe_cx . is_some () ,) { (context :: EnterRuntime :: Entered { .. } , true) => { had_entered = true ; } (context :: EnterRuntime :: Entered { allow_block_in_place , } , false ,) => { if allow_block_in_place { had_entered = true ; return Ok (()) ; } else { return Err (\"can call blocking only when running on the multi-threaded runtime\" ,) ; } } (context :: EnterRuntime :: NotEntered , true) => { return Ok (()) ; } (context :: EnterRuntime :: NotEntered , false) => { return Ok (()) ; } } let cx = maybe_cx . expect (\"no .is_some() == false cases above should lead here\") ; let mut core = match cx . core . borrow_mut () . take () { Some (core) => core , None => return Ok (()) , } ; if let Some (task) = core . lifo_slot . take () { core . run_queue . push_back_or_overflow (task , & * cx . worker . handle , & mut core . stats) ; } take_core = true ; assert ! (core . park . is_some ()) ; cx . worker . core . set (core) ; let worker = cx . worker . clone () ; runtime :: spawn_blocking (move | | run (worker)) ; Ok (()) }) ; if let Err (panic_message) = setup_result { panic ! (\"{}\" , panic_message) ; } if had_entered { let _reset = Reset { take_core , budget : coop :: stop () , } ; crate :: runtime :: context :: exit_runtime (f) } else { f () } } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 8389113760377953142,
      "kind": "Function",
      "name": "run",
      "signature": "fn fn run (worker : Arc < Worker >) { # [allow (dead_code)] struct AbortOnPanic ; impl Drop for AbortOnPanic { fn drop (& mut self) { if std :: thread :: panicking () { eprintln ! (\"worker thread panicking; aborting process\") ; std :: process :: abort () ; } } } # [cfg (debug_assertions)] let _abort_on_panic = AbortOnPanic ; let core = match worker . core . take () { Some (core) => core , None => return , } ; worker . handle . shared . worker_metrics [worker . index] . set_thread_id (thread :: current () . id ()) ; let handle = scheduler :: Handle :: MultiThread (worker . handle . clone ()) ; crate :: runtime :: context :: enter_runtime (& handle , true , | _ | { let cx = scheduler :: Context :: MultiThread (Context { worker , core : RefCell :: new (None) , defer : Defer :: new () , }) ; context :: set_scheduler (& cx , | | { let cx = cx . expect_multi_thread () ; assert ! (cx . run (core) . is_err ()) ; cx . defer . wake () ; }) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 3603879184333191072,
      "kind": "Struct",
      "name": "InjectGuard",
      "signature": "struct InjectGuard",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 4555136730296707563,
      "kind": "Function",
      "name": "with_current",
      "signature": "fn # [track_caller] fn with_current < R > (f : impl FnOnce (Option < & Context >) -> R) -> R { use scheduler :: Context :: MultiThread ; context :: with_scheduler (| ctx | match ctx { Some (MultiThread (ctx)) => f (Some (ctx)) , _ => f (None) , }) } . sig",
      "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
      "line": 0
    },
    {
      "hash": 16227133904294378747,
      "kind": "Struct",
      "name": "AbortHandle",
      "signature": "struct AbortHandle",
      "file_path": "tokio/src/runtime/task/abort.rs",
      "line": 0
    },
    {
      "hash": 13678000764175645853,
      "kind": "Struct",
      "name": "Cell",
      "signature": "struct Cell",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 4560557060485598088,
      "kind": "Struct",
      "name": "CoreStage",
      "signature": "struct CoreStage",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 4989101300042388065,
      "kind": "Struct",
      "name": "Header",
      "signature": "struct Header",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 7725559896287014660,
      "kind": "Struct",
      "name": "Trailer",
      "signature": "struct Trailer",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 3495694496181291100,
      "kind": "Struct",
      "name": "TaskIdGuard",
      "signature": "struct TaskIdGuard",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 3882825573407959823,
      "kind": "Function",
      "name": "header_lte_cache_line",
      "signature": "fn # [test] # [cfg (not (loom))] fn header_lte_cache_line () { assert ! (std :: mem :: size_of ::< Header > () <= 8 * std :: mem :: size_of ::<* const () > ()) ; } . sig",
      "file_path": "tokio/src/runtime/task/core.rs",
      "line": 0
    },
    {
      "hash": 5581602254584338600,
      "kind": "Function",
      "name": "panic_payload_as_str",
      "signature": "fn fn panic_payload_as_str (payload : & SyncWrapper < Box < dyn Any + Send > >) -> Option < & str > { if let Some (s) = payload . downcast_ref_sync :: < String > () { return Some (s) ; } if let Some (s) = payload . downcast_ref_sync :: < & 'static str > () { return Some (s) ; } None } . sig",
      "file_path": "tokio/src/runtime/task/error.rs",
      "line": 0
    },
    {
      "hash": 17448278123980501561,
      "kind": "Struct",
      "name": "Harness",
      "signature": "struct Harness",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 14123691814559972490,
      "kind": "Function",
      "name": "can_read_output",
      "signature": "fn fn can_read_output (header : & Header , trailer : & Trailer , waker : & Waker) -> bool { let snapshot = header . state . load () ; debug_assert ! (snapshot . is_join_interested ()) ; if ! snapshot . is_complete () { let res = if snapshot . is_join_waker_set () { if unsafe { trailer . will_wake (waker) } { return false ; } header . state . unset_waker () . and_then (| snapshot | set_join_waker (header , trailer , waker . clone () , snapshot)) } else { set_join_waker (header , trailer , waker . clone () , snapshot) } ; match res { Ok (_) => return false , Err (snapshot) => { assert ! (snapshot . is_complete ()) ; } } } true } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 14201160465409636253,
      "kind": "Function",
      "name": "set_join_waker",
      "signature": "fn fn set_join_waker (header : & Header , trailer : & Trailer , waker : Waker , snapshot : Snapshot ,) -> Result < Snapshot , Snapshot > { assert ! (snapshot . is_join_interested ()) ; assert ! (! snapshot . is_join_waker_set ()) ; unsafe { trailer . set_waker (Some (waker)) ; } let res = header . state . set_join_waker () ; if res . is_err () { unsafe { trailer . set_waker (None) ; } } res } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 16363114676638423829,
      "kind": "Function",
      "name": "cancel_task",
      "signature": "fn # [doc = \" Cancels the task and store the appropriate error in the stage field.\"] fn cancel_task < T : Future , S : Schedule > (core : & Core < T , S >) { let res = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { core . drop_future_or_output () ; })) ; core . store_output (Err (panic_result_to_join_error (core . task_id , res))) ; } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 6781790490145357650,
      "kind": "Function",
      "name": "panic_result_to_join_error",
      "signature": "fn fn panic_result_to_join_error (task_id : Id , res : Result < () , Box < dyn Any + Send + 'static > > ,) -> JoinError { match res { Ok (()) => JoinError :: cancelled (task_id) , Err (panic) => JoinError :: panic (task_id , panic) , } } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 10452079680669811425,
      "kind": "Function",
      "name": "poll_future",
      "signature": "fn # [doc = \" Polls the future. If the future completes, the output is written to the\"] # [doc = \" stage field.\"] fn poll_future < T : Future , S : Schedule > (core : & Core < T , S > , cx : Context < '_ >) -> Poll < () > { let output = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { struct Guard < 'a , T : Future , S : Schedule > { core : & 'a Core < T , S > , } impl < 'a , T : Future , S : Schedule > Drop for Guard < 'a , T , S > { fn drop (& mut self) { self . core . drop_future_or_output () ; } } let guard = Guard { core } ; let res = guard . core . poll (cx) ; mem :: forget (guard) ; res })) ; let output = match output { Ok (Poll :: Pending) => return Poll :: Pending , Ok (Poll :: Ready (output)) => Ok (output) , Err (panic) => Err (panic_to_error (& core . scheduler , core . task_id , panic)) , } ; let res = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { core . store_output (output) ; })) ; if res . is_err () { core . scheduler . unhandled_panic () ; } Poll :: Ready (()) } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 12182619816505015296,
      "kind": "Function",
      "name": "panic_to_error",
      "signature": "fn # [cold] fn panic_to_error < S : Schedule > (scheduler : & S , task_id : Id , panic : Box < dyn Any + Send + 'static > ,) -> JoinError { scheduler . unhandled_panic () ; JoinError :: panic (task_id , panic) } . sig",
      "file_path": "tokio/src/runtime/task/harness.rs",
      "line": 0
    },
    {
      "hash": 10580544618306055630,
      "kind": "Function",
      "name": "id",
      "signature": "fn # [doc = \" Returns the [`Id`] of the currently running task.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if called from outside a task. Please note that calls\"] # [doc = \" to `block_on` do not have task IDs, so the method will panic if called from\"] # [doc = \" within a call to `block_on`. For a version of this function that doesn't\"] # [doc = \" panic, see [`task::try_id()`](crate::runtime::task::try_id()).\"] # [doc = \"\"] # [doc = \" [task ID]: crate::task::Id\"] # [track_caller] pub fn id () -> Id { context :: current_task_id () . expect (\"Can't get a task id when not inside a task\") } . sig",
      "file_path": "tokio/src/runtime/task/id.rs",
      "line": 0
    },
    {
      "hash": 12577627258545834244,
      "kind": "Function",
      "name": "try_id",
      "signature": "fn # [doc = \" Returns the [`Id`] of the currently running task, or `None` if called outside\"] # [doc = \" of a task.\"] # [doc = \"\"] # [doc = \" This function is similar to  [`task::id()`](crate::runtime::task::id()), except\"] # [doc = \" that it returns `None` rather than panicking if called outside of a task\"] # [doc = \" context.\"] # [doc = \"\"] # [doc = \" [task ID]: crate::task::Id\"] # [track_caller] pub fn try_id () -> Option < Id > { context :: current_task_id () } . sig",
      "file_path": "tokio/src/runtime/task/id.rs",
      "line": 0
    },
    {
      "hash": 16284578555921292738,
      "kind": "Struct",
      "name": "OwnedTasks",
      "signature": "struct OwnedTasks",
      "file_path": "tokio/src/runtime/task/list.rs",
      "line": 0
    },
    {
      "hash": 12285010889041326176,
      "kind": "Struct",
      "name": "LocalOwnedTasks",
      "signature": "struct LocalOwnedTasks",
      "file_path": "tokio/src/runtime/task/list.rs",
      "line": 0
    },
    {
      "hash": 11848179663203031494,
      "kind": "Struct",
      "name": "OwnedTasksInner",
      "signature": "struct OwnedTasksInner",
      "file_path": "tokio/src/runtime/task/list.rs",
      "line": 0
    },
    {
      "hash": 3425321755947438400,
      "kind": "Struct",
      "name": "Notified",
      "signature": "struct Notified",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 17384733989723868832,
      "kind": "Struct",
      "name": "LocalNotified",
      "signature": "struct LocalNotified",
      "file_path": "tokio/src/runtime/task/mod.rs",
      "line": 0
    },
    {
      "hash": 16143175764652984750,
      "kind": "Struct",
      "name": "UnownedTask",
      "signature": "struct UnownedTask",
      "file_path": "tokio/src/runtime/task/mod.rs",
      "line": 0
    },
    {
      "hash": 890862913923547791,
      "kind": "Struct",
      "name": "TaskHarnessScheduleHooks",
      "signature": "struct TaskHarnessScheduleHooks",
      "file_path": "tokio/src/runtime/task/mod.rs",
      "line": 0
    },
    {
      "hash": 9230966580944554502,
      "kind": "Trait",
      "name": "Schedule",
      "signature": "trait Schedule",
      "file_path": "tokio/src/runtime/task/mod.rs",
      "line": 0
    },
    {
      "hash": 8614295034672081201,
      "kind": "Struct",
      "name": "RawTask",
      "signature": "struct RawTask",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 14721912477613567433,
      "kind": "Struct",
      "name": "Vtable",
      "signature": "struct Vtable",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 745168117060831428,
      "kind": "Function",
      "name": "vtable",
      "signature": "fn # [doc = \" Get the vtable for the requested `T` and `S` generics.\"] pub (super) fn vtable < T : Future , S : Schedule > () -> & 'static Vtable { & Vtable { poll : poll :: < T , S > , schedule : schedule :: < S > , dealloc : dealloc :: < T , S > , try_read_output : try_read_output :: < T , S > , drop_join_handle_slow : drop_join_handle_slow :: < T , S > , drop_abort_handle : drop_abort_handle :: < T , S > , shutdown : shutdown :: < T , S > , trailer_offset : OffsetHelper :: < T , S > :: TRAILER_OFFSET , scheduler_offset : OffsetHelper :: < T , S > :: SCHEDULER_OFFSET , id_offset : OffsetHelper :: < T , S > :: ID_OFFSET , # [cfg (tokio_unstable)] spawn_location_offset : OffsetHelper :: < T , S > :: SPAWN_LOCATION_OFFSET , } } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 13968537890658220342,
      "kind": "Struct",
      "name": "OffsetHelper",
      "signature": "struct OffsetHelper",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 17979661222001877202,
      "kind": "Function",
      "name": "get_trailer_offset",
      "signature": "fn # [doc = \" Compute the offset of the `Trailer` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_trailer_offset (header_size : usize , core_size : usize , core_align : usize , trailer_align : usize ,) -> usize { let mut offset = header_size ; let core_misalign = offset % core_align ; if core_misalign > 0 { offset += core_align - core_misalign ; } offset += core_size ; let trailer_misalign = offset % trailer_align ; if trailer_misalign > 0 { offset += trailer_align - trailer_misalign ; } offset } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 12449822823582728322,
      "kind": "Function",
      "name": "get_core_offset",
      "signature": "fn # [doc = \" Compute the offset of the `Core<T, S>` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_core_offset (header_size : usize , core_align : usize) -> usize { let mut offset = header_size ; let core_misalign = offset % core_align ; if core_misalign > 0 { offset += core_align - core_misalign ; } offset } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 6436960243814943552,
      "kind": "Function",
      "name": "get_id_offset",
      "signature": "fn # [doc = \" Compute the offset of the `Id` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_id_offset (header_size : usize , core_align : usize , scheduler_size : usize , id_align : usize ,) -> usize { let mut offset = get_core_offset (header_size , core_align) ; offset += scheduler_size ; let id_misalign = offset % id_align ; if id_misalign > 0 { offset += id_align - id_misalign ; } offset } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 7850636232589907741,
      "kind": "Function",
      "name": "get_spawn_location_offset",
      "signature": "fn # [doc = \" Compute the offset of the `&'static Location<'static>` field in `Cell<T, S>`\"] # [doc = \" using the `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] # [cfg (tokio_unstable)] const fn get_spawn_location_offset (header_size : usize , core_align : usize , scheduler_size : usize , id_align : usize , id_size : usize , spawn_location_align : usize ,) -> usize { let mut offset = get_id_offset (header_size , core_align , scheduler_size , id_align) ; offset += id_size ; let spawn_location_misalign = offset % spawn_location_align ; if spawn_location_misalign > 0 { offset += spawn_location_align - spawn_location_misalign ; } offset } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 1612418022201107184,
      "kind": "Function",
      "name": "poll",
      "signature": "fn unsafe fn poll < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . poll () ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 1269818468412072586,
      "kind": "Function",
      "name": "schedule",
      "signature": "fn unsafe fn schedule < S : Schedule > (ptr : NonNull < Header >) { use crate :: runtime :: task :: { Notified , Task } ; let scheduler = Header :: get_scheduler :: < S > (ptr) ; scheduler . as_ref () . schedule (Notified (Task :: from_raw (ptr . cast ()))) ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 4924849134054627287,
      "kind": "Function",
      "name": "dealloc",
      "signature": "fn unsafe fn dealloc < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . dealloc () ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 8128890565796783480,
      "kind": "Function",
      "name": "try_read_output",
      "signature": "fn unsafe fn try_read_output < T : Future , S : Schedule > (ptr : NonNull < Header > , dst : * mut () , waker : & Waker ,) { let out = & mut * (dst as * mut Poll < super :: Result < T :: Output > >) ; let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . try_read_output (out , waker) ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 2340043267484992007,
      "kind": "Function",
      "name": "drop_join_handle_slow",
      "signature": "fn unsafe fn drop_join_handle_slow < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . drop_join_handle_slow () ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 3103933619828053861,
      "kind": "Function",
      "name": "drop_abort_handle",
      "signature": "fn unsafe fn drop_abort_handle < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . drop_reference () ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 442096188456941543,
      "kind": "Function",
      "name": "shutdown",
      "signature": "fn unsafe fn shutdown < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . shutdown () ; } . sig",
      "file_path": "tokio/src/runtime/task/raw.rs",
      "line": 0
    },
    {
      "hash": 8797254861801053865,
      "kind": "Struct",
      "name": "Snapshot",
      "signature": "struct Snapshot",
      "file_path": "tokio/src/runtime/task/state.rs",
      "line": 0
    },
    {
      "hash": 5204367531882275739,
      "kind": "Struct",
      "name": "TransitionToJoinHandleDrop",
      "signature": "struct TransitionToJoinHandleDrop",
      "file_path": "tokio/src/runtime/task/state.rs",
      "line": 0
    },
    {
      "hash": 9527386468921189016,
      "kind": "Struct",
      "name": "WakerRef",
      "signature": "struct WakerRef",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 17343360218465905556,
      "kind": "Function",
      "name": "waker_ref",
      "signature": "fn # [doc = \" Returns a `WakerRef` which avoids having to preemptively increase the\"] # [doc = \" refcount if there is no need to do so.\"] pub (super) fn waker_ref < S > (header : & NonNull < Header >) -> WakerRef < '_ , S > where S : Schedule , { let waker = unsafe { ManuallyDrop :: new (Waker :: from_raw (raw_waker (* header))) } ; WakerRef { waker , _p : PhantomData , } } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 13103201269753958384,
      "kind": "Function",
      "name": "clone_waker",
      "signature": "fn unsafe fn clone_waker (ptr : * const ()) -> RawWaker { let header = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (header , \"waker.clone\") ; header . as_ref () . state . ref_inc () ; raw_waker (header) } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 14270141931940158177,
      "kind": "Function",
      "name": "drop_waker",
      "signature": "fn unsafe fn drop_waker (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.drop\") ; let raw = RawTask :: from_raw (ptr) ; raw . drop_reference () ; } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 5211755909910192034,
      "kind": "Function",
      "name": "wake_by_val",
      "signature": "fn unsafe fn wake_by_val (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.wake\") ; let raw = RawTask :: from_raw (ptr) ; raw . wake_by_val () ; } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 6551271993168476937,
      "kind": "Function",
      "name": "wake_by_ref",
      "signature": "fn unsafe fn wake_by_ref (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.wake_by_ref\") ; let raw = RawTask :: from_raw (ptr) ; raw . wake_by_ref () ; } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 2940449757987330656,
      "kind": "Function",
      "name": "raw_waker",
      "signature": "fn fn raw_waker (header : NonNull < Header >) -> RawWaker { let ptr = header . as_ptr () as * const () ; RawWaker :: new (ptr , & WAKER_VTABLE) } . sig",
      "file_path": "tokio/src/runtime/task/waker.rs",
      "line": 0
    },
    {
      "hash": 6975012733407853389,
      "kind": "Struct",
      "name": "Frame",
      "signature": "struct Frame",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 3651291299646401066,
      "kind": "Function",
      "name": "trace_leaf",
      "signature": "fn # [doc = \" If this is a sub-invocation of [`Trace::capture`], capture a backtrace.\"] # [doc = \"\"] # [doc = \" The captured backtrace will be returned by [`Trace::capture`].\"] # [doc = \"\"] # [doc = \" Invoking this function does nothing when it is not a sub-invocation\"] # [doc = \" [`Trace::capture`].\"] # [inline (never)] pub (crate) fn trace_leaf (cx : & mut task :: Context < '_ >) -> Poll < () > { let did_trace = unsafe { Context :: try_with_current (| context_cell | { if let Some (mut collector) = context_cell . collector . take () { let mut frames = vec ! [] ; let mut above_leaf = false ; if let Some (active_frame) = context_cell . active_frame . get () { let active_frame = active_frame . as_ref () ; backtrace :: trace (| frame | { let below_root = ! ptr :: eq (frame . symbol_address () , active_frame . inner_addr) ; if above_leaf && below_root { frames . push (frame . to_owned () . into ()) ; } if ptr :: eq (frame . symbol_address () , trace_leaf as * const _) { above_leaf = true ; } below_root }) ; } collector . backtraces . push (frames) ; context_cell . collector . set (Some (collector)) ; true } else { false } }) . unwrap_or (false) } ; if did_trace { context :: with_scheduler (| scheduler | { if let Some (scheduler) = scheduler { match scheduler { scheduler :: Context :: CurrentThread (s) => s . defer . defer (cx . waker ()) , # [cfg (feature = \"rt-multi-thread\")] scheduler :: Context :: MultiThread (s) => s . defer . defer (cx . waker ()) , } } }) ; Poll :: Pending } else { Poll :: Ready (()) } } . sig",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 16156295633393473194,
      "kind": "Function",
      "name": "defer",
      "signature": "fn fn defer < F : FnOnce () -> R , R > (f : F) -> impl Drop { use std :: mem :: ManuallyDrop ; struct Defer < F : FnOnce () -> R , R > (ManuallyDrop < F >) ; impl < F : FnOnce () -> R , R > Drop for Defer < F , R > { # [inline (always)] fn drop (& mut self) { unsafe { ManuallyDrop :: take (& mut self . 0) () ; } } } Defer (ManuallyDrop :: new (f)) } . sig",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 1228465052124051702,
      "kind": "Function",
      "name": "trace_current_thread",
      "signature": "fn # [doc = \" Trace and poll all tasks of the `current_thread` runtime.\"] pub (in crate :: runtime) fn trace_current_thread (owned : & OwnedTasks < Arc < current_thread :: Handle > > , local : & mut VecDeque < Notified < Arc < current_thread :: Handle > > > , injection : & Inject < Arc < current_thread :: Handle > > ,) -> Vec < (Id , Trace) > { let mut dequeued = Vec :: new () ; while let Some (task) = local . pop_back () { dequeued . push (task) ; } while let Some (task) = injection . pop () { dequeued . push (task) ; } trace_owned (owned , dequeued) } . sig",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 14083562515026503038,
      "kind": "Function",
      "name": "trace_owned",
      "signature": "fn # [doc = \" Trace the `OwnedTasks`.\"] # [doc = \"\"] # [doc = \" # Preconditions\"] # [doc = \"\"] # [doc = \" This helper presumes exclusive access to each task. The tasks must not exist\"] # [doc = \" in any other queue.\"] fn trace_owned < S : Schedule > (owned : & OwnedTasks < S > , dequeued : Vec < Notified < S > >) -> Vec < (Id , Trace) > { let mut tasks = dequeued ; owned . for_each (| task | { if let Some (notified) = task . notify_for_tracing () { tasks . push (notified) ; } }) ; tasks . into_iter () . map (| task | { let local_notified = owned . assert_owner (task) ; let id = local_notified . task . id () ; let (() , trace) = Trace :: capture (| | local_notified . run ()) ; (id , trace) }) . collect () } . sig",
      "file_path": "tokio/src/runtime/task/trace/mod.rs",
      "line": 0
    },
    {
      "hash": 14994358408068206138,
      "kind": "Struct",
      "name": "Symbol",
      "signature": "struct Symbol",
      "file_path": "tokio/src/runtime/task/trace/symbol.rs",
      "line": 0
    },
    {
      "hash": 6124807426156870755,
      "kind": "Struct",
      "name": "Tree",
      "signature": "struct Tree",
      "file_path": "tokio/src/runtime/task/trace/tree.rs",
      "line": 0
    },
    {
      "hash": 17466794071214845219,
      "kind": "Function",
      "name": "to_symboltrace",
      "signature": "fn # [doc = \" Resolve a sequence of [`backtrace::BacktraceFrame`]s into a sequence of\"] # [doc = \" [`Symbol`]s.\"] fn to_symboltrace (backtrace : Backtrace) -> SymbolTrace { let backtrace : Backtrace = { let mut backtrace = backtrace :: Backtrace :: from (backtrace) ; backtrace . resolve () ; backtrace . into () } ; let mut symboltrace : SymbolTrace = vec ! [] ; let mut state = DefaultHasher :: new () ; for frame in backtrace . into_iter () . rev () { for symbol in frame . symbols () . iter () . rev () { let symbol = Symbol { symbol : symbol . clone () , parent_hash : state . finish () , } ; symbol . hash (& mut state) ; symboltrace . push (symbol) ; } } symboltrace } . sig",
      "file_path": "tokio/src/runtime/task/trace/tree.rs",
      "line": 0
    },
    {
      "hash": 518801543932814791,
      "kind": "Function",
      "name": "push_and_pop",
      "signature": "fn # [test] fn push_and_pop () { const N : usize = 2 ; let (inject , mut synced) = inject :: Shared :: new () ; for i in 0 .. N { assert_eq ! (inject . len () , i) ; let (task , _) = super :: unowned (async { }) ; unsafe { inject . push (& mut synced , task) } ; } for i in 0 .. N { assert_eq ! (inject . len () , N - i) ; assert ! (unsafe { inject . pop (& mut synced) } . is_some ()) ; } println ! (\"--------------\") ; assert ! (unsafe { inject . pop (& mut synced) } . is_none ()) ; } . sig",
      "file_path": "tokio/src/runtime/tests/inject.rs",
      "line": 0
    },
    {
      "hash": 15407032681632095399,
      "kind": "Function",
      "name": "push_batch_and_pop",
      "signature": "fn # [test] fn push_batch_and_pop () { let (inject , mut inject_synced) = inject :: Shared :: new () ; unsafe { inject . push_batch (& mut inject_synced , (0 .. 10) . map (| _ | super :: unowned (async { }) . 0) ,) ; assert_eq ! (5 , inject . pop_n (& mut inject_synced , 5) . count ()) ; assert_eq ! (5 , inject . pop_n (& mut inject_synced , 5) . count ()) ; assert_eq ! (0 , inject . pop_n (& mut inject_synced , 5) . count ()) ; } } . sig",
      "file_path": "tokio/src/runtime/tests/inject.rs",
      "line": 0
    },
    {
      "hash": 1955179702215140550,
      "kind": "Function",
      "name": "pop_n_drains_on_drop",
      "signature": "fn # [test] fn pop_n_drains_on_drop () { let (inject , mut inject_synced) = inject :: Shared :: new () ; unsafe { inject . push_batch (& mut inject_synced , (0 .. 10) . map (| _ | super :: unowned (async { }) . 0) ,) ; let _ = inject . pop_n (& mut inject_synced , 10) ; assert_eq ! (inject . len () , 0) ; } } . sig",
      "file_path": "tokio/src/runtime/tests/inject.rs",
      "line": 0
    },
    {
      "hash": 2059761071001325149,
      "kind": "Function",
      "name": "blocking_shutdown",
      "signature": "fn # [test] fn blocking_shutdown () { loom :: model (| | { let v = Arc :: new (()) ; let rt = mk_runtime (1) ; { let _enter = rt . enter () ; for _ in 0 .. 2 { let v = v . clone () ; crate :: task :: spawn_blocking (move | | { assert ! (1 < Arc :: strong_count (& v)) ; }) ; } } drop (rt) ; assert_eq ! (1 , Arc :: strong_count (& v)) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
      "line": 0
    },
    {
      "hash": 1861255677405909671,
      "kind": "Function",
      "name": "spawn_mandatory_blocking_should_always_run",
      "signature": "fn # [test] fn spawn_mandatory_blocking_should_always_run () { use crate :: runtime :: tests :: loom_oneshot ; loom :: model (| | { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; let (tx , rx) = loom_oneshot :: channel () ; let _enter = rt . enter () ; runtime :: spawn_blocking (| | { }) ; runtime :: spawn_mandatory_blocking (move | | { let _ = tx . send (()) ; }) . unwrap () ; drop (rt) ; let () = rx . recv () ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
      "line": 0
    },
    {
      "hash": 3394136727857901555,
      "kind": "Function",
      "name": "spawn_mandatory_blocking_should_run_even_when_shutting_down_from_other_thread",
      "signature": "fn # [test] fn spawn_mandatory_blocking_should_run_even_when_shutting_down_from_other_thread () { use crate :: runtime :: tests :: loom_oneshot ; loom :: model (| | { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; let handle = rt . handle () . clone () ; { loom :: thread :: spawn (move | | { drop (rt) ; }) ; } let _enter = handle . enter () ; let (tx , rx) = loom_oneshot :: channel () ; let handle = runtime :: spawn_mandatory_blocking (move | | { let _ = tx . send (()) ; }) ; if handle . is_some () { let () = rx . recv () ; } }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
      "line": 0
    },
    {
      "hash": 6246916169140128695,
      "kind": "Function",
      "name": "spawn_blocking_when_paused",
      "signature": "fn # [test] fn spawn_blocking_when_paused () { use std :: time :: Duration ; loom :: model (| | { let rt = crate :: runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; let handle = rt . handle () ; let _enter = handle . enter () ; let a = crate :: task :: spawn_blocking (| | { }) ; let b = crate :: task :: spawn_blocking (| | { }) ; rt . block_on (crate :: time :: timeout (Duration :: from_millis (1) , async move { a . await . expect (\"blocking task should finish\") ; b . await . expect (\"blocking task should finish\") ; })) . expect (\"timeout should not trigger\") ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
      "line": 0
    },
    {
      "hash": 10583527348754986806,
      "kind": "Function",
      "name": "mk_runtime",
      "signature": "fn fn mk_runtime (num_threads : usize) -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (num_threads) . build () . unwrap () } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/yield_now.rs",
      "line": 0
    },
    {
      "hash": 18434132535540040078,
      "kind": "Function",
      "name": "assert_at_most_num_polls",
      "signature": "fn fn assert_at_most_num_polls (rt : Arc < Runtime > , at_most_polls : usize) { let (tx , rx) = oneshot :: channel () ; let num_polls = Arc :: new (AtomicUsize :: new (0)) ; rt . spawn (async move { for _ in 0 .. 12 { task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; rt . block_on (async { BlockedFuture { rx , num_polls : num_polls . clone () , } . await ; }) ; let polls = num_polls . load (Acquire) ; assert ! (polls <= at_most_polls) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 15126982071460518715,
      "kind": "Function",
      "name": "block_on_num_polls",
      "signature": "fn # [test] fn block_on_num_polls () { loom :: model (| | { let at_most = 4 ; let rt1 = Arc :: new (Builder :: new_current_thread () . build () . unwrap ()) ; let rt2 = rt1 . clone () ; let rt3 = rt1 . clone () ; let th1 = thread :: spawn (move | | assert_at_most_num_polls (rt1 , at_most)) ; let th2 = thread :: spawn (move | | assert_at_most_num_polls (rt2 , at_most)) ; let th3 = thread :: spawn (move | | assert_at_most_num_polls (rt3 , at_most)) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; th3 . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 6417071220056202816,
      "kind": "Function",
      "name": "assert_no_unnecessary_polls",
      "signature": "fn # [test] fn assert_no_unnecessary_polls () { loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let (tx , rx) = oneshot :: channel () ; let pending_cnt = Arc :: new (AtomicUsize :: new (0)) ; rt . spawn (async move { for _ in 0 .. 24 { task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; let pending_cnt_clone = pending_cnt . clone () ; rt . block_on (async move { task :: yield_now () . await ; ResetFuture { rx , pending_cnt : pending_cnt_clone , } . await ; }) ; let pending_cnt = pending_cnt . load (Acquire) ; assert ! (pending_cnt <= 1) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 14900203720354027554,
      "kind": "Function",
      "name": "drop_jh_during_schedule",
      "signature": "fn # [test] fn drop_jh_during_schedule () { unsafe fn waker_clone (ptr : * const ()) -> RawWaker { let atomic = unsafe { & * (ptr as * const AtomicUsize) } ; atomic . fetch_add (1 , Ordering :: Relaxed) ; RawWaker :: new (ptr , & VTABLE) } unsafe fn waker_drop (ptr : * const ()) { let atomic = unsafe { & * (ptr as * const AtomicUsize) } ; atomic . fetch_sub (1 , Ordering :: Relaxed) ; } unsafe fn waker_nop (_ptr : * const ()) { } static VTABLE : RawWakerVTable = RawWakerVTable :: new (waker_clone , waker_drop , waker_nop , waker_drop) ; loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let mut jh = rt . spawn (async { }) ; let task_refcnt = jh . abort_handle () ; let waker_refcnt = AtomicUsize :: new (1) ; { use std :: future :: Future ; use std :: pin :: Pin ; let join_waker = unsafe { Waker :: from_raw (RawWaker :: new ((& waker_refcnt) as * const AtomicUsize as * const () , & VTABLE ,)) } ; assert ! (Pin :: new (& mut jh) . poll (& mut Context :: from_waker (& join_waker)) . is_pending ()) ; } assert_eq ! (waker_refcnt . load (Ordering :: Relaxed) , 1) ; let bg_thread = loom :: thread :: spawn (move | | drop (jh)) ; rt . block_on (crate :: task :: yield_now ()) ; bg_thread . join () . unwrap () ; assert_eq ! (waker_refcnt . load (Ordering :: Relaxed) , 0) ; drop (task_refcnt) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 10049942804799096251,
      "kind": "Struct",
      "name": "BlockedFuture",
      "signature": "struct BlockedFuture",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 17449954306277185526,
      "kind": "Struct",
      "name": "ResetFuture",
      "signature": "struct ResetFuture",
      "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
      "line": 0
    },
    {
      "hash": 5911038687164049149,
      "kind": "Function",
      "name": "test_join_set",
      "signature": "fn # [test] fn test_join_set () { loom :: model (| | { let rt = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let mut set = JoinSet :: new () ; rt . block_on (async { assert_eq ! (set . len () , 0) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 2) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 2) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 0) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 1) ; }) ; drop (set) ; drop (rt) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_join_set.rs",
      "line": 0
    },
    {
      "hash": 5161775763491204151,
      "kind": "Function",
      "name": "abort_all_during_completion",
      "signature": "fn # [test] fn abort_all_during_completion () { use std :: sync :: { atomic :: { AtomicBool , Ordering :: SeqCst } , Arc , } ; let complete_happened = Arc :: new (AtomicBool :: new (false)) ; let cancel_happened = Arc :: new (AtomicBool :: new (false)) ; { let complete_happened = complete_happened . clone () ; let cancel_happened = cancel_happened . clone () ; loom :: model (move | | { let rt = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let mut set = JoinSet :: new () ; rt . block_on (async { set . spawn (async { () }) ; set . abort_all () ; match set . join_next () . await { Some (Ok (())) => complete_happened . store (true , SeqCst) , Some (Err (err)) if err . is_cancelled () => cancel_happened . store (true , SeqCst) , Some (Err (err)) => panic ! (\"fail: {}\" , err) , None => { unreachable ! (\"Aborting the task does not remove it from the JoinSet.\") } } assert ! (matches ! (set . join_next () . await , None)) ; }) ; drop (set) ; drop (rt) ; }) ; } assert ! (complete_happened . load (SeqCst)) ; assert ! (cancel_happened . load (SeqCst)) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_join_set.rs",
      "line": 0
    },
    {
      "hash": 3725566978352774647,
      "kind": "Function",
      "name": "wake_during_shutdown",
      "signature": "fn # [doc = \" Waking a runtime will attempt to push a task into a queue of notifications\"] # [doc = \" in the runtime, however the tasks in such a queue usually have a reference\"] # [doc = \" to the runtime itself. This means that if they are not properly removed at\"] # [doc = \" runtime shutdown, this will cause a memory leak.\"] # [doc = \"\"] # [doc = \" This test verifies that waking something during shutdown of a `LocalSet` does\"] # [doc = \" not result in tasks lingering in the queue once shutdown is complete. This\"] # [doc = \" is verified using loom's leak finder.\"] # [test] fn wake_during_shutdown () { loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let ls = LocalSet :: new () ; let (send , recv) = oneshot :: channel () ; ls . spawn_local (async move { let mut send = Some (send) ; let () = std :: future :: poll_fn (| cx | { if let Some (send) = send . take () { send . send (cx . waker () . clone ()) ; } Poll :: Pending }) . await ; }) ; let handle = loom :: thread :: spawn (move | | { let waker = recv . recv () ; waker . wake () ; }) ; ls . block_on (& rt , crate :: task :: yield_now ()) ; drop (ls) ; handle . join () . unwrap () ; drop (rt) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_local.rs",
      "line": 0
    },
    {
      "hash": 17086578618368571864,
      "kind": "Struct",
      "name": "AtomicOneshot",
      "signature": "struct AtomicOneshot",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
      "line": 0
    },
    {
      "hash": 16568557560427081290,
      "kind": "Function",
      "name": "mk_pool",
      "signature": "fn fn mk_pool (num_threads : usize) -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (num_threads) . event_interval (2) . build () . unwrap () } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
      "line": 0
    },
    {
      "hash": 5279952099645095544,
      "kind": "Function",
      "name": "gated2",
      "signature": "fn fn gated2 (thread : bool) -> impl Future < Output = & 'static str > { use loom :: thread ; use std :: sync :: Arc ; let gate = Arc :: new (AtomicBool :: new (false)) ; let mut fired = false ; poll_fn (move | cx | { if ! fired { let gate = gate . clone () ; let waker = cx . waker () . clone () ; if thread { thread :: spawn (move | | { gate . store (true , SeqCst) ; waker . wake_by_ref () ; }) ; } else { spawn (track (async move { gate . store (true , SeqCst) ; waker . wake_by_ref () ; })) ; } fired = true ; return Poll :: Pending ; } if gate . load (SeqCst) { Poll :: Ready (\"hello world\") } else { Poll :: Pending } }) } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
      "line": 0
    },
    {
      "hash": 11635032204941662046,
      "kind": "Function",
      "name": "multi_gated",
      "signature": "fn async fn multi_gated () { struct Gate { waker : loom :: future :: AtomicWaker , count : AtomicUsize , } let gate = Arc :: new (Gate { waker : loom :: future :: AtomicWaker :: new () , count : AtomicUsize :: new (0) , }) ; { let gate = gate . clone () ; spawn (track (async move { for i in 1 .. 3 { gate . count . store (i , SeqCst) ; gate . waker . wake () ; } })) ; } poll_fn (move | cx | { gate . waker . register_by_ref (cx . waker ()) ; if gate . count . load (SeqCst) < 2 { Poll :: Pending } else { Poll :: Ready (()) } }) . await ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
      "line": 0
    },
    {
      "hash": 16130411406260673991,
      "kind": "Function",
      "name": "track",
      "signature": "fn fn track < T : Future > (f : T) -> Track < T > { Track { inner : f , arc : Arc :: new (()) , } } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
      "line": 0
    },
    {
      "hash": 836883376015839301,
      "kind": "Function",
      "name": "channel",
      "signature": "fn pub (crate) fn channel < T > () -> (Sender < T > , Receiver < T >) { let inner = Arc :: new (Inner { notify : Notify :: new () , value : Mutex :: new (None) , }) ; let tx = Sender { inner : inner . clone () , } ; let rx = Receiver { inner } ; (tx , rx) } . sig",
      "file_path": "tokio/src/runtime/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 3212767037355632096,
      "kind": "Function",
      "name": "new_stats",
      "signature": "fn fn new_stats () -> Stats { use crate :: runtime :: WorkerMetrics ; Stats :: new (& WorkerMetrics :: new ()) } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 17732688639593335838,
      "kind": "Function",
      "name": "fits_256_one_at_a_time",
      "signature": "fn # [test] fn fits_256_one_at_a_time () { let (_ , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. 256 { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } cfg_unstable_metrics ! { assert_metrics ! (stats , overflow_count == 0) ; } assert ! (inject . borrow_mut () . pop () . is_none ()) ; while local . pop () . is_some () { } } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 3312440804379108591,
      "kind": "Function",
      "name": "fits_256_all_at_once",
      "signature": "fn # [test] fn fits_256_all_at_once () { let (_ , mut local) = queue :: local () ; let mut tasks = (0 .. 256) . map (| _ | super :: unowned (async { }) . 0) . collect :: < Vec < _ > > () ; local . push_back (tasks . drain (..)) ; let mut i = 0 ; while local . pop () . is_some () { i += 1 ; } assert_eq ! (i , 256) ; } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 11023213306517549622,
      "kind": "Function",
      "name": "fits_256_all_in_chunks",
      "signature": "fn # [test] fn fits_256_all_in_chunks () { let (_ , mut local) = queue :: local () ; let mut tasks = (0 .. 256) . map (| _ | super :: unowned (async { }) . 0) . collect :: < Vec < _ > > () ; local . push_back (tasks . drain (.. 10)) ; local . push_back (tasks . drain (.. 100)) ; local . push_back (tasks . drain (.. 46)) ; local . push_back (tasks . drain (.. 100)) ; let mut i = 0 ; while local . pop () . is_some () { i += 1 ; } assert_eq ! (i , 256) ; } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 15386896390751259804,
      "kind": "Function",
      "name": "overflow",
      "signature": "fn # [test] fn overflow () { let (_ , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. 257 { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } cfg_unstable_metrics ! { assert_metrics ! (stats , overflow_count == 1) ; } let mut n = 0 ; n += inject . borrow_mut () . drain (..) . count () ; while local . pop () . is_some () { n += 1 ; } assert_eq ! (n , 257) ; } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 4016422909737782439,
      "kind": "Function",
      "name": "steal_batch",
      "signature": "fn # [test] fn steal_batch () { let mut stats = new_stats () ; let (steal1 , mut local1) = queue :: local () ; let (_ , mut local2) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; for _ in 0 .. 4 { let (task , _) = super :: unowned (async { }) ; local1 . push_back_or_overflow (task , & inject , & mut stats) ; } assert ! (steal1 . steal_into (& mut local2 , & mut stats) . is_some ()) ; cfg_unstable_metrics ! { assert_metrics ! (stats , steal_count == 2) ; } for _ in 0 .. 1 { assert ! (local2 . pop () . is_some ()) ; } assert ! (local2 . pop () . is_none ()) ; for _ in 0 .. 2 { assert ! (local1 . pop () . is_some ()) ; } assert ! (local1 . pop () . is_none ()) ; } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 9694093941781404323,
      "kind": "Function",
      "name": "normal_or_miri",
      "signature": "fn const fn normal_or_miri (normal : usize , miri : usize) -> usize { if cfg ! (miri) { miri } else { normal } } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 4546867385622750065,
      "kind": "Function",
      "name": "stress1",
      "signature": "fn # [test] fn stress1 () { const NUM_ITER : usize = 5 ; const NUM_STEAL : usize = normal_or_miri (1_000 , 10) ; const NUM_LOCAL : usize = normal_or_miri (1_000 , 10) ; const NUM_PUSH : usize = normal_or_miri (500 , 10) ; const NUM_POP : usize = normal_or_miri (250 , 10) ; let mut stats = new_stats () ; for _ in 0 .. NUM_ITER { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. NUM_STEAL { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } thread :: yield_now () ; } cfg_unstable_metrics ! { assert_metrics ! (stats , steal_count == n as _) ; } n }) ; let mut n = 0 ; for _ in 0 .. NUM_LOCAL { for _ in 0 .. NUM_PUSH { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } for _ in 0 .. NUM_POP { if local . pop () . is_some () { n += 1 ; } else { break ; } } } n += inject . borrow_mut () . drain (..) . count () ; n += th . join () . unwrap () ; assert_eq ! (n , NUM_LOCAL * NUM_PUSH) ; } } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 13732042309115052067,
      "kind": "Function",
      "name": "stress2",
      "signature": "fn # [test] fn stress2 () { const NUM_ITER : usize = 1 ; const NUM_TASKS : usize = normal_or_miri (1_000_000 , 50) ; const NUM_STEAL : usize = normal_or_miri (1_000 , 10) ; let mut stats = new_stats () ; for _ in 0 .. NUM_ITER { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. NUM_STEAL { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } thread :: sleep (Duration :: from_micros (10)) ; } n }) ; let mut num_pop = 0 ; for i in 0 .. NUM_TASKS { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; if i % 128 == 0 && local . pop () . is_some () { num_pop += 1 ; } num_pop += inject . borrow_mut () . drain (..) . count () ; } num_pop += th . join () . unwrap () ; while local . pop () . is_some () { num_pop += 1 ; } num_pop += inject . borrow_mut () . drain (..) . count () ; assert_eq ! (num_pop , NUM_TASKS) ; } } . sig",
      "file_path": "tokio/src/runtime/tests/queue.rs",
      "line": 0
    },
    {
      "hash": 17045567844403284239,
      "kind": "Struct",
      "name": "AssertDropHandle",
      "signature": "struct AssertDropHandle",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 8470427740187697046,
      "kind": "Struct",
      "name": "AssertDrop",
      "signature": "struct AssertDrop",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 4975580649795748214,
      "kind": "Function",
      "name": "create_drop1",
      "signature": "fn # [test] fn create_drop1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (notified) ; handle . assert_not_dropped () ; drop (join) ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 2117350274006518026,
      "kind": "Function",
      "name": "create_drop2",
      "signature": "fn # [test] fn create_drop2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 6079914750780239763,
      "kind": "Function",
      "name": "drop_abort_handle1",
      "signature": "fn # [test] fn drop_abort_handle1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 11832684438296018615,
      "kind": "Function",
      "name": "drop_abort_handle2",
      "signature": "fn # [test] fn drop_abort_handle2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_not_dropped () ; drop (join) ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 11608254374818826630,
      "kind": "Function",
      "name": "drop_abort_handle_clone",
      "signature": "fn # [test] fn drop_abort_handle_clone () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; let abort_clone = abort . clone () ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_not_dropped () ; drop (abort_clone) ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 2914144182017813928,
      "kind": "Function",
      "name": "create_shutdown1",
      "signature": "fn # [test] fn create_shutdown1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (join) ; handle . assert_not_dropped () ; notified . shutdown () ; handle . assert_dropped () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 13008022478314248775,
      "kind": "Function",
      "name": "create_shutdown2",
      "signature": "fn # [test] fn create_shutdown2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; handle . assert_not_dropped () ; notified . shutdown () ; handle . assert_dropped () ; drop (join) ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 12302657335982745342,
      "kind": "Function",
      "name": "unowned_poll",
      "signature": "fn # [test] fn unowned_poll () { let (task , _) = unowned (async { } , NoopSchedule , Id :: next () , SpawnLocation :: capture ()) ; task . run () ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 5096880715697984991,
      "kind": "Function",
      "name": "schedule",
      "signature": "fn # [test] fn schedule () { with (| rt | { rt . spawn (async { crate :: task :: yield_now () . await ; }) ; assert_eq ! (2 , rt . tick ()) ; rt . shutdown () ; }) } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 2141933653157065273,
      "kind": "Function",
      "name": "shutdown",
      "signature": "fn # [test] fn shutdown () { with (| rt | { rt . spawn (async { loop { crate :: task :: yield_now () . await ; } }) ; rt . tick_max (1) ; rt . shutdown () ; }) } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 13416497892416151460,
      "kind": "Function",
      "name": "shutdown_immediately",
      "signature": "fn # [test] fn shutdown_immediately () { with (| rt | { rt . spawn (async { loop { crate :: task :: yield_now () . await ; } }) ; rt . shutdown () ; }) } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 5623037130591268344,
      "kind": "Function",
      "name": "spawn_niche_in_task",
      "signature": "fn # [test] fn spawn_niche_in_task () { use std :: future :: poll_fn ; use std :: task :: { Context , Poll , Waker } ; with (| rt | { let state = Arc :: new (Mutex :: new (State :: new ())) ; let mut subscriber = Subscriber :: new (Arc :: clone (& state) , 1) ; rt . spawn (async move { subscriber . wait () . await ; subscriber . wait () . await ; }) ; rt . spawn (async move { state . lock () . unwrap () . set_version (2) ; state . lock () . unwrap () . set_version (0) ; }) ; rt . tick_max (10) ; assert ! (rt . is_empty ()) ; rt . shutdown () ; }) ; pub (crate) struct Subscriber { state : Arc < Mutex < State > > , observed_version : u64 , waker_key : Option < usize > , } impl Subscriber { pub (crate) fn new (state : Arc < Mutex < State > > , version : u64) -> Self { Self { state , observed_version : version , waker_key : None , } } pub (crate) async fn wait (& mut self) { poll_fn (| cx | { self . state . lock () . unwrap () . poll_update (& mut self . observed_version , & mut self . waker_key , cx) . map (| _ | ()) }) . await ; } } struct State { version : u64 , wakers : Vec < Waker > , } impl State { pub (crate) fn new () -> Self { Self { version : 1 , wakers : Vec :: new () , } } pub (crate) fn poll_update (& mut self , observed_version : & mut u64 , waker_key : & mut Option < usize > , cx : & Context < '_ > ,) -> Poll < Option < () > > { if self . version == 0 { * waker_key = None ; Poll :: Ready (None) } else if * observed_version < self . version { * waker_key = None ; * observed_version = self . version ; Poll :: Ready (Some (())) } else { self . wakers . push (cx . waker () . clone ()) ; * waker_key = Some (self . wakers . len ()) ; Poll :: Pending } } pub (crate) fn set_version (& mut self , version : u64) { self . version = version ; for waker in self . wakers . drain (..) { waker . wake () ; } } } } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 18173389124479660636,
      "kind": "Function",
      "name": "spawn_during_shutdown",
      "signature": "fn # [test] fn spawn_during_shutdown () { static DID_SPAWN : AtomicBool = AtomicBool :: new (false) ; struct SpawnOnDrop (Runtime) ; impl Drop for SpawnOnDrop { fn drop (& mut self) { DID_SPAWN . store (true , Ordering :: SeqCst) ; self . 0 . spawn (async { }) ; } } with (| rt | { let rt2 = rt . clone () ; rt . spawn (async move { let _spawn_on_drop = SpawnOnDrop (rt2) ; loop { crate :: task :: yield_now () . await ; } }) ; rt . tick_max (1) ; rt . shutdown () ; }) ; assert ! (DID_SPAWN . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 15323881205469740218,
      "kind": "Function",
      "name": "with",
      "signature": "fn fn with (f : impl FnOnce (Runtime)) { struct Reset ; impl Drop for Reset { fn drop (& mut self) { let _rt = CURRENT . try_lock () . unwrap () . take () ; } } let _reset = Reset ; let rt = Runtime (Arc :: new (Inner { owned : OwnedTasks :: new (16) , core : Mutex :: new (Core { queue : VecDeque :: new () , }) , })) ; * CURRENT . try_lock () . unwrap () = Some (rt . clone ()) ; f (rt) } . sig",
      "file_path": "tokio/src/runtime/tests/task.rs",
      "line": 0
    },
    {
      "hash": 552865787134143542,
      "kind": "Function",
      "name": "test_combinations",
      "signature": "fn # [test] # [cfg_attr (panic = \"abort\" , ignore)] fn test_combinations () { let mut rt = & [CombiRuntime :: CurrentThread , CombiRuntime :: Multi1 , CombiRuntime :: Multi2 ,] [..] ; if cfg ! (miri) { rt = & [CombiRuntime :: CurrentThread] ; } let ls = [CombiLocalSet :: Yes , CombiLocalSet :: No] ; let task = [CombiTask :: NoPanic , CombiTask :: PanicOnRun , CombiTask :: PanicOnDrop , CombiTask :: PanicOnRunAndDrop ,] ; let output = [CombiOutput :: NoPanic , CombiOutput :: PanicOnDrop] ; let ji = [CombiJoinInterest :: Polled , CombiJoinInterest :: NotPolled] ; let jh = [CombiJoinHandle :: DropImmediately , CombiJoinHandle :: DropFirstPoll , CombiJoinHandle :: DropAfterNoConsume , CombiJoinHandle :: DropAfterConsume ,] ; let abort = [CombiAbort :: NotAborted , CombiAbort :: AbortedImmediately , CombiAbort :: AbortedFirstPoll , CombiAbort :: AbortedAfterFinish , CombiAbort :: AbortedAfterConsumeOutput ,] ; let ah = [None , Some (CombiJoinHandle :: DropImmediately) , Some (CombiJoinHandle :: DropFirstPoll) , Some (CombiJoinHandle :: DropAfterNoConsume) , Some (CombiJoinHandle :: DropAfterConsume) ,] ; for rt in rt . iter () . copied () { for ls in ls . iter () . copied () { for task in task . iter () . copied () { for output in output . iter () . copied () { for ji in ji . iter () . copied () { for jh in jh . iter () . copied () { for abort in abort . iter () . copied () { for ah in ah . iter () . copied () { test_combination (rt , ls , task , output , ji , jh , ah , abort , CombiAbortSource :: JoinHandle ,) ; } test_combination (rt , ls , task , output , ji , jh , None , abort , CombiAbortSource :: AbortHandle ,) ; } } } } } } } } . sig",
      "file_path": "tokio/src/runtime/tests/task_combinations.rs",
      "line": 0
    },
    {
      "hash": 17801307299265193611,
      "kind": "Function",
      "name": "is_debug",
      "signature": "fn fn is_debug < T : fmt :: Debug > (_ : & T) { } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4134704136722729279,
      "kind": "Function",
      "name": "test_combination",
      "signature": "fn # [allow (clippy :: too_many_arguments)] fn test_combination (rt : CombiRuntime , ls : CombiLocalSet , task : CombiTask , output : CombiOutput , ji : CombiJoinInterest , jh : CombiJoinHandle , ah : Option < CombiJoinHandle > , abort : CombiAbort , abort_src : CombiAbortSource ,) { match (abort_src , ah) { (CombiAbortSource :: JoinHandle , _) if (jh as usize) < (abort as usize) => { return ; } (CombiAbortSource :: AbortHandle , Some (_)) => { return ; } _ => { } } if (task == CombiTask :: PanicOnDrop) && (output == CombiOutput :: PanicOnDrop) { return ; } if (task == CombiTask :: PanicOnRunAndDrop) && (abort != CombiAbort :: AbortedImmediately) { return ; } is_debug (& rt) ; is_debug (& ls) ; is_debug (& task) ; is_debug (& output) ; is_debug (& ji) ; is_debug (& jh) ; is_debug (& ah) ; is_debug (& abort) ; is_debug (& abort_src) ; struct Rt { rt : crate :: runtime :: Runtime , ls : Option < crate :: task :: LocalSet > , } impl Rt { fn new (rt : CombiRuntime , ls : CombiLocalSet) -> Self { let rt = match rt { CombiRuntime :: CurrentThread => Builder :: new_current_thread () . build () . unwrap () , CombiRuntime :: Multi1 => Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () , CombiRuntime :: Multi2 => Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () , } ; let ls = match ls { CombiLocalSet :: Yes => Some (crate :: task :: LocalSet :: new ()) , CombiLocalSet :: No => None , } ; Self { rt , ls } } fn block_on < T > (& self , task : T) -> T :: Output where T : Future , { match & self . ls { Some (ls) => ls . block_on (& self . rt , task) , None => self . rt . block_on (task) , } } fn spawn < T > (& self , task : T) -> JoinHandle < T :: Output > where T : Future + Send + 'static , T :: Output : Send + 'static , { match & self . ls { Some (ls) => ls . spawn_local (task) , None => self . rt . spawn (task) , } } } struct Output { panic_on_drop : bool , on_drop : Option < oneshot :: Sender < () > > , } impl Output { fn disarm (& mut self) { self . panic_on_drop = false ; } } impl Drop for Output { fn drop (& mut self) { let _ = self . on_drop . take () . unwrap () . send (()) ; if self . panic_on_drop { panic ! (\"Panicking in Output\") ; } } } struct FutWrapper < F > { inner : F , on_drop : Option < oneshot :: Sender < () > > , panic_on_drop : bool , } impl < F : Future > Future for FutWrapper < F > { type Output = F :: Output ; fn poll (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < F :: Output > { unsafe { let me = Pin :: into_inner_unchecked (self) ; let inner = Pin :: new_unchecked (& mut me . inner) ; inner . poll (cx) } } } impl < F > Drop for FutWrapper < F > { fn drop (& mut self) { let _ : Result < () , () > = self . on_drop . take () . unwrap () . send (()) ; if self . panic_on_drop { panic ! (\"Panicking in FutWrapper\") ; } } } struct Signals { on_first_poll : Option < oneshot :: Sender < () > > , wait_complete : Option < oneshot :: Receiver < () > > , on_output_drop : Option < oneshot :: Sender < () > > , } async fn my_task (mut signal : Signals , task : CombiTask , out : CombiOutput) -> Output { let _ = signal . on_first_poll . take () . unwrap () . send (()) ; let _ = signal . wait_complete . take () . unwrap () . await ; crate :: task :: yield_now () . await ; if task == CombiTask :: PanicOnRun || task == CombiTask :: PanicOnRunAndDrop { panic ! (\"Panicking in my_task on {:?}\" , std :: thread :: current () . id ()) ; } Output { panic_on_drop : out == CombiOutput :: PanicOnDrop , on_drop : signal . on_output_drop . take () , } } let rt = Rt :: new (rt , ls) ; let (on_first_poll , wait_first_poll) = oneshot :: channel () ; let (on_complete , wait_complete) = oneshot :: channel () ; let (on_future_drop , wait_future_drop) = oneshot :: channel () ; let (on_output_drop , wait_output_drop) = oneshot :: channel () ; let signal = Signals { on_first_poll : Some (on_first_poll) , wait_complete : Some (wait_complete) , on_output_drop : Some (on_output_drop) , } ; let mut handle = Some (rt . spawn (FutWrapper { inner : my_task (signal , task , output) , on_drop : Some (on_future_drop) , panic_on_drop : task == CombiTask :: PanicOnDrop || task == CombiTask :: PanicOnRunAndDrop , })) ; let mut aborted = false ; if ji == CombiJoinInterest :: Polled { assert ! (handle . as_mut () . unwrap () . now_or_never () . is_none () , \"Polling handle succeeded\") ; } let mut abort_handle = if ah . is_some () || abort_src == CombiAbortSource :: AbortHandle { handle . as_ref () . map (JoinHandle :: abort_handle) } else { None } ; let do_abort = | abort_handle : & mut Option < AbortHandle > , join_handle : Option < & mut JoinHandle < _ > > | { match abort_src { CombiAbortSource :: AbortHandle => abort_handle . take () . unwrap () . abort () , CombiAbortSource :: JoinHandle => join_handle . unwrap () . abort () , } } ; if abort == CombiAbort :: AbortedImmediately { do_abort (& mut abort_handle , handle . as_mut ()) ; aborted = true ; } if jh == CombiJoinHandle :: DropImmediately { drop (handle . take () . unwrap ()) ; } let got_polled = rt . block_on (wait_first_poll) . is_ok () ; if ! got_polled { assert ! (aborted , \"Task completed without ever being polled but was not aborted.\") ; } if abort == CombiAbort :: AbortedFirstPoll { do_abort (& mut abort_handle , handle . as_mut ()) ; aborted = true ; } if jh == CombiJoinHandle :: DropFirstPoll { drop (handle . take () . unwrap ()) ; } if ah == Some (CombiJoinHandle :: DropFirstPoll) { drop (abort_handle . take () . unwrap ()) ; } let _ = on_complete . send (()) ; assert ! (rt . block_on (wait_future_drop) . is_ok () , \"The future should always be dropped.\") ; if abort == CombiAbort :: AbortedAfterFinish { do_abort (& mut abort_handle , handle . as_mut ()) ; } if jh == CombiJoinHandle :: DropAfterNoConsume { if ah == Some (CombiJoinHandle :: DropAfterNoConsume) { drop (handle . take () . unwrap ()) ; let panic = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { drop (abort_handle . take () . unwrap ()) ; })) ; if panic . is_err () { assert ! ((output == CombiOutput :: PanicOnDrop) && (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Dropping AbortHandle shouldn't panic here\") ; } } else { let panic = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { drop (handle . take () . unwrap ()) ; })) ; if panic . is_err () { assert ! ((output == CombiOutput :: PanicOnDrop) && (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Dropping JoinHandle shouldn't panic here\") ; } } } if jh == CombiJoinHandle :: DropAfterConsume { let result = rt . block_on (handle . as_mut () . unwrap ()) ; match result { Ok (mut output) => { output . disarm () ; assert ! (! aborted , \"Task was aborted but returned output\") ; } Err (err) if err . is_cancelled () => assert ! (aborted , \"Cancelled output but not aborted\") , Err (err) if err . is_panic () => { assert ! ((task == CombiTask :: PanicOnRun) || (task == CombiTask :: PanicOnDrop) || (task == CombiTask :: PanicOnRunAndDrop) || (output == CombiOutput :: PanicOnDrop) , \"Panic but nothing should panic\") ; } _ => unreachable ! () , } let mut handle = handle . take () . unwrap () ; if abort == CombiAbort :: AbortedAfterConsumeOutput { do_abort (& mut abort_handle , Some (& mut handle)) ; } drop (handle) ; if ah == Some (CombiJoinHandle :: DropAfterConsume) { drop (abort_handle . take ()) ; } } let output_created = rt . block_on (wait_output_drop) . is_ok () ; assert_eq ! (output_created , (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Creation of output object\") ; } . sig",
      "file_path": "tokio/src/runtime/tests/task_combinations.rs",
      "line": 0
    },
    {
      "hash": 17029686047466875471,
      "kind": "Function",
      "name": "yield_calls_park_before_scheduling_again",
      "signature": "fn # [test] fn yield_calls_park_before_scheduling_again () { let mut loom = loom :: model :: Builder :: default () ; loom . max_permutations = Some (1) ; loom . check (| | { let rt = mk_runtime () ; let jh = rt . spawn (async { let tid = loom :: thread :: current () . id () ; let park_count = park :: current_thread_park_count () ; crate :: task :: yield_now () . await ; if tid == loom :: thread :: current () . id () { let new_park_count = park :: current_thread_park_count () ; assert_eq ! (park_count + 1 , new_park_count) ; } }) ; rt . block_on (jh) . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread/yield_now.rs",
      "line": 0
    },
    {
      "hash": 4608958510167916996,
      "kind": "Function",
      "name": "mk_runtime",
      "signature": "fn fn mk_runtime () -> Runtime { runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "tokio/src/runtime/tests/loom_current_thread/yield_now.rs",
      "line": 0
    },
    {
      "hash": 47530385687808420,
      "kind": "Function",
      "name": "new_stats",
      "signature": "fn fn new_stats () -> Stats { Stats :: new (& crate :: runtime :: WorkerMetrics :: new ()) } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 9773604709619348529,
      "kind": "Function",
      "name": "basic",
      "signature": "fn # [test] fn basic () { loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. 3 { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } } n }) ; let mut n = 0 ; for _ in 0 .. 2 { for _ in 0 .. 2 { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } if local . pop () . is_some () { n += 1 ; } let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; while local . pop () . is_some () { n += 1 ; } } n += inject . borrow_mut () . drain (..) . count () ; n += th . join () . unwrap () ; assert_eq ! (6 , n) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 11471090388406928778,
      "kind": "Function",
      "name": "steal_overflow",
      "signature": "fn # [test] fn steal_overflow () { loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } n }) ; let mut n = 0 ; let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; if local . pop () . is_some () { n += 1 ; } for _ in 0 .. 6 { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } n += th . join () . unwrap () ; while local . pop () . is_some () { n += 1 ; } n += inject . borrow_mut () . drain (..) . count () ; assert_eq ! (7 , n) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 14583700516177451034,
      "kind": "Function",
      "name": "multi_stealer",
      "signature": "fn # [test] fn multi_stealer () { const NUM_TASKS : usize = 5 ; fn steal_tasks (steal : queue :: Steal < NoopSchedule >) -> usize { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; if steal . steal_into (& mut local , & mut stats) . is_none () { return 0 ; } let mut n = 1 ; while local . pop () . is_some () { n += 1 ; } n } loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. NUM_TASKS { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } let th1 = { let steal = steal . clone () ; thread :: spawn (move | | steal_tasks (steal)) } ; let th2 = thread :: spawn (move | | steal_tasks (steal)) ; let mut n = 0 ; while local . pop () . is_some () { n += 1 ; } n += inject . borrow_mut () . drain (..) . count () ; n += th1 . join () . unwrap () ; n += th2 . join () . unwrap () ; assert_eq ! (n , NUM_TASKS) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 7071641434616805368,
      "kind": "Function",
      "name": "chained_steal",
      "signature": "fn # [test] fn chained_steal () { loom :: model (| | { let mut stats = new_stats () ; let (s1 , mut l1) = queue :: local () ; let (s2 , mut l2) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; for _ in 0 .. 4 { let (task , _) = unowned (async { }) ; l1 . push_back_or_overflow (task , & inject , & mut stats) ; let (task , _) = unowned (async { }) ; l2 . push_back_or_overflow (task , & inject , & mut stats) ; } let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; s1 . steal_into (& mut local , & mut stats) ; while local . pop () . is_some () { } }) ; while l1 . pop () . is_some () { } s2 . steal_into (& mut l1 , & mut stats) ; th . join () . unwrap () ; while l1 . pop () . is_some () { } while l2 . pop () . is_some () { } }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
      "line": 0
    },
    {
      "hash": 8909799026147978728,
      "kind": "Function",
      "name": "join_handle_cancel_on_shutdown",
      "signature": "fn # [test] fn join_handle_cancel_on_shutdown () { let mut builder = loom :: model :: Builder :: new () ; builder . preemption_bound = Some (2) ; builder . check (| | { use futures :: future :: FutureExt ; let rt = Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () ; let handle = rt . block_on (async move { Handle :: current () }) ; let jh1 = handle . spawn (futures :: future :: pending :: < () > ()) ; drop (rt) ; let jh2 = handle . spawn (futures :: future :: pending :: < () > ()) ; let err1 = jh1 . now_or_never () . unwrap () . unwrap_err () ; let err2 = jh2 . now_or_never () . unwrap () . unwrap_err () ; assert ! (err1 . is_cancelled ()) ; assert ! (err2 . is_cancelled ()) ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/shutdown.rs",
      "line": 0
    },
    {
      "hash": 15855968842651076124,
      "kind": "Function",
      "name": "yield_calls_park_before_scheduling_again",
      "signature": "fn # [test] fn yield_calls_park_before_scheduling_again () { let mut loom = loom :: model :: Builder :: default () ; loom . max_permutations = Some (1) ; loom . check (| | { let rt = mk_runtime (2) ; let (tx , rx) = oneshot :: channel :: < () > () ; rt . spawn (async { let tid = loom :: thread :: current () . id () ; let park_count = park :: current_thread_park_count () ; crate :: task :: yield_now () . await ; if tid == loom :: thread :: current () . id () { let new_park_count = park :: current_thread_park_count () ; assert_eq ! (park_count + 1 , new_park_count) ; } tx . send (()) ; }) ; rx . recv () ; }) ; } . sig",
      "file_path": "tokio/src/runtime/tests/loom_multi_thread/yield_now.rs",
      "line": 0
    },
    {
      "hash": 5224599367618022018,
      "kind": "Struct",
      "name": "StateCell",
      "signature": "struct StateCell",
      "file_path": "tokio/src/runtime/time/entry.rs",
      "line": 0
    },
    {
      "hash": 14829525937586796338,
      "kind": "Struct",
      "name": "TimerHandle",
      "signature": "struct TimerHandle",
      "file_path": "tokio/src/runtime/time/entry.rs",
      "line": 0
    },
    {
      "hash": 3632473869751896843,
      "kind": "Struct",
      "name": "TimerShared",
      "signature": "struct TimerShared",
      "file_path": "tokio/src/runtime/time/entry.rs",
      "line": 0
    },
    {
      "hash": 4552157438282588981,
      "kind": "Struct",
      "name": "InnerState",
      "signature": "struct InnerState",
      "file_path": "tokio/src/runtime/time/mod.rs",
      "line": 0
    },
    {
      "hash": 5600289798220993308,
      "kind": "Struct",
      "name": "TimeSource",
      "signature": "struct TimeSource",
      "file_path": "tokio/src/runtime/time/source.rs",
      "line": 0
    },
    {
      "hash": 16169141232806712164,
      "kind": "Function",
      "name": "block_on",
      "signature": "fn fn block_on < T > (f : impl std :: future :: Future < Output = T >) -> T { # [cfg (loom)] return loom :: future :: block_on (f) ; # [cfg (not (loom))] { let rt = crate :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (f) } } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 10961538272330279589,
      "kind": "Function",
      "name": "model",
      "signature": "fn fn model (f : impl Fn () + Send + Sync + 'static) { # [cfg (loom)] loom :: model (f) ; # [cfg (not (loom))] f () ; } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 11971934876117237502,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt (start_paused : bool) -> crate :: runtime :: Runtime { crate :: runtime :: Builder :: new_current_thread () . enable_time () . start_paused (start_paused) . build () . unwrap () } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 7600737981404756041,
      "kind": "Function",
      "name": "single_timer",
      "signature": "fn # [test] fn single_timer () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 6245273847789911812,
      "kind": "Function",
      "name": "drop_timer",
      "signature": "fn # [test] fn drop_timer () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 9001641491332008174,
      "kind": "Function",
      "name": "change_waker",
      "signature": "fn # [test] fn change_waker () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 11297271194149781203,
      "kind": "Function",
      "name": "reset_future",
      "signature": "fn # [test] fn reset_future () { model (| | { let finished_early = Arc :: new (AtomicBool :: new (false)) ; let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let finished_early_ = finished_early . clone () ; let start = handle . inner . driver () . clock () . now () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , start + Duration :: from_secs (1)) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; entry . as_mut () . reset (start + Duration :: from_secs (2) , true) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; finished_early_ . store (true , Ordering :: Relaxed) ; }) ; thread :: yield_now () ; let handle = handle . inner . driver () . time () ; handle . process_at_time (handle . time_source () . instant_to_tick (start + Duration :: from_millis (1500)) ,) ; assert ! (! finished_early . load (Ordering :: Relaxed)) ; handle . process_at_time (handle . time_source () . instant_to_tick (start + Duration :: from_millis (2500)) ,) ; jh . join () . unwrap () ; assert ! (finished_early . load (Ordering :: Relaxed)) ; }) } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 9179056276453303740,
      "kind": "Function",
      "name": "normal_or_miri",
      "signature": "fn # [cfg (not (loom))] fn normal_or_miri < T > (normal : T , miri : T) -> T { if cfg ! (miri) { miri } else { normal } } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 18201697477380257026,
      "kind": "Function",
      "name": "poll_process_levels",
      "signature": "fn # [test] # [cfg (not (loom))] fn poll_process_levels () { let rt = rt (true) ; let handle = rt . handle () ; let mut entries = vec ! [] ; for i in 0 .. normal_or_miri (1024 , 64) { let mut entry = Box :: pin (TimerEntry :: new (handle . inner . clone () , handle . inner . driver () . clock () . now () + Duration :: from_millis (i) ,)) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (noop_waker_ref ())) ; entries . push (entry) ; } for t in 1 .. normal_or_miri (1024 , 64) { handle . inner . driver () . time () . process_at_time (t as u64) ; for (deadline , future) in entries . iter_mut () . enumerate () { let mut context = Context :: from_waker (noop_waker_ref ()) ; if deadline <= t { assert ! (future . as_mut () . poll_elapsed (& mut context) . is_ready ()) ; } else { assert ! (future . as_mut () . poll_elapsed (& mut context) . is_pending ()) ; } } } } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 1040268922215788964,
      "kind": "Function",
      "name": "poll_process_levels_targeted",
      "signature": "fn # [test] # [cfg (not (loom))] fn poll_process_levels_targeted () { let mut context = Context :: from_waker (noop_waker_ref ()) ; let rt = rt (true) ; let handle = rt . handle () ; let e1 = TimerEntry :: new (handle . inner . clone () , handle . inner . driver () . clock () . now () + Duration :: from_millis (193) ,) ; pin ! (e1) ; let handle = handle . inner . driver () . time () ; handle . process_at_time (62) ; assert ! (e1 . as_mut () . poll_elapsed (& mut context) . is_pending ()) ; handle . process_at_time (192) ; handle . process_at_time (192) ; } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 14661683651351499610,
      "kind": "Function",
      "name": "instant_to_tick_max",
      "signature": "fn # [test] # [cfg (not (loom))] fn instant_to_tick_max () { use crate :: runtime :: time :: entry :: MAX_SAFE_MILLIS_DURATION ; let rt = rt (true) ; let handle = rt . handle () . inner . driver () . time () ; let start_time = handle . time_source . start_time () ; let long_future = start_time + std :: time :: Duration :: from_millis (MAX_SAFE_MILLIS_DURATION + 1) ; assert ! (handle . time_source . instant_to_tick (long_future) <= MAX_SAFE_MILLIS_DURATION) ; } . sig",
      "file_path": "tokio/src/runtime/time/tests/mod.rs",
      "line": 0
    },
    {
      "hash": 1237343432264381157,
      "kind": "Struct",
      "name": "Level",
      "signature": "struct Level",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 10273022611456103270,
      "kind": "Struct",
      "name": "Expiration",
      "signature": "struct Expiration",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 7245515654742391276,
      "kind": "Function",
      "name": "occupied_bit",
      "signature": "fn fn occupied_bit (slot : usize) -> u64 { 1 << slot } . sig",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 11590841382191015202,
      "kind": "Function",
      "name": "slot_range",
      "signature": "fn fn slot_range (level : usize) -> u64 { LEVEL_MULT . pow (level as u32) as u64 } . sig",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 8823627186469916092,
      "kind": "Function",
      "name": "level_range",
      "signature": "fn fn level_range (level : usize) -> u64 { LEVEL_MULT as u64 * slot_range (level) } . sig",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 13986596122041930373,
      "kind": "Function",
      "name": "slot_for",
      "signature": "fn # [doc = \" Converts a duration (milliseconds) and a level to a slot position.\"] fn slot_for (duration : u64 , level : usize) -> usize { ((duration >> (level * 6)) % LEVEL_MULT as u64) as usize } . sig",
      "file_path": "tokio/src/runtime/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 16016028118543583960,
      "kind": "Struct",
      "name": "Wheel",
      "signature": "struct Wheel",
      "file_path": "tokio-util/src/time/wheel/mod.rs",
      "line": 0
    },
    {
      "hash": 9732745163910956150,
      "kind": "Function",
      "name": "level_for",
      "signature": "fn fn level_for (elapsed : u64 , when : u64) -> usize { const SLOT_MASK : u64 = (1 << 6) - 1 ; let mut masked = elapsed ^ when | SLOT_MASK ; if masked >= MAX_DURATION { masked = MAX_DURATION - 1 ; } let leading_zeros = masked . leading_zeros () as usize ; let significant = 63 - leading_zeros ; significant / NUM_LEVELS } . sig",
      "file_path": "tokio/src/runtime/time/wheel/mod.rs",
      "line": 0
    },
    {
      "hash": 12785935703487373841,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn # [doc = \" Completes when a \\\"ctrl-c\\\" notification is sent to the process.\"] # [doc = \"\"] # [doc = \" While signals are handled very differently between Unix and Windows, both\"] # [doc = \" platforms support receiving a signal on \\\"ctrl-c\\\". This function provides a\"] # [doc = \" portable API for receiving this notification.\"] # [doc = \"\"] # [doc = \" Once the returned future is polled, a listener is registered. The future\"] # [doc = \" will complete on the first received `ctrl-c` **after** the initial call to\"] # [doc = \" either `Future::poll` or `.await`.\"] # [doc = \"\"] # [doc = \" # Caveats\"] # [doc = \"\"] # [doc = \" On Unix platforms, the first time that a `Signal` instance is registered for a\"] # [doc = \" particular signal kind, an OS signal-handler is installed which replaces the\"] # [doc = \" default platform behavior when that signal is received, **for the duration of\"] # [doc = \" the entire process**.\"] # [doc = \"\"] # [doc = \" For example, Unix systems will terminate a process by default when it\"] # [doc = \" receives a signal generated by `\\\"CTRL+C\\\"` on the terminal. But, when a\"] # [doc = \" `ctrl_c` stream is created to listen for this signal, the time it arrives,\"] # [doc = \" it will be translated to a stream event, and the process will continue to\"] # [doc = \" execute.  **Even if this `Signal` instance is dropped, subsequent `SIGINT`\"] # [doc = \" deliveries will end up captured by Tokio, and the default platform behavior\"] # [doc = \" will NOT be reset**.\"] # [doc = \"\"] # [doc = \" Thus, applications should take care to ensure the expected signal behavior\"] # [doc = \" occurs as expected after listening for specific signals.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"waiting for ctrl-c\\\");\"] # [doc = \"\"] # [doc = \"     signal::ctrl_c().await.expect(\\\"failed to listen for event\\\");\"] # [doc = \"\"] # [doc = \"     println!(\\\"received ctrl-c event\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Listen in the background:\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" tokio::spawn(async move {\"] # [doc = \"     tokio::signal::ctrl_c().await.unwrap();\"] # [doc = \"     // Your handler here\"] # [doc = \" });\"] # [doc = \" ```\"] pub async fn ctrl_c () -> io :: Result < () > { os_impl :: ctrl_c () ? . recv () . await ; Ok (()) } . sig",
      "file_path": "tokio/src/signal/ctrl_c.rs",
      "line": 0
    },
    {
      "hash": 5758561130673339581,
      "kind": "Struct",
      "name": "RxFuture",
      "signature": "struct RxFuture",
      "file_path": "tokio/src/signal/mod.rs",
      "line": 0
    },
    {
      "hash": 1947510703204240680,
      "kind": "Function",
      "name": "make_future",
      "signature": "fn async fn make_future (mut rx : Receiver < () >) -> Receiver < () > { rx . changed () . await . expect (\"signal sender went away\") ; rx } . sig",
      "file_path": "tokio/src/signal/mod.rs",
      "line": 0
    },
    {
      "hash": 10546130717860449933,
      "kind": "Struct",
      "name": "EventInfo",
      "signature": "struct EventInfo",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 1476899036862037828,
      "kind": "Trait",
      "name": "Storage",
      "signature": "trait Storage",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 2155555586112145469,
      "kind": "Trait",
      "name": "Init",
      "signature": "trait Init",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 9269389982484711539,
      "kind": "Struct",
      "name": "Registry",
      "signature": "struct Registry",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 2742310895564075902,
      "kind": "Struct",
      "name": "Globals",
      "signature": "struct Globals",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 2046622449076126649,
      "kind": "Function",
      "name": "globals_init",
      "signature": "fn fn globals_init () -> Globals where OsExtraData : 'static + Send + Sync + Init , OsStorage : 'static + Send + Sync + Init , { Globals { extra : OsExtraData :: init () , registry : Registry :: new (OsStorage :: init ()) , } } . sig",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 2194192267709006552,
      "kind": "Function",
      "name": "globals",
      "signature": "fn pub (crate) fn globals () -> & 'static Globals where OsExtraData : 'static + Send + Sync + Init , OsStorage : 'static + Send + Sync + Init , { static GLOBALS : OnceLock < Globals > = OnceLock :: new () ; GLOBALS . get_or_init (globals_init) } . sig",
      "file_path": "tokio/src/signal/registry.rs",
      "line": 0
    },
    {
      "hash": 15483250621420644775,
      "kind": "Struct",
      "name": "ReusableBoxFuture",
      "signature": "struct ReusableBoxFuture",
      "file_path": "tokio-util/src/sync/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 3020593632513718178,
      "kind": "Struct",
      "name": "OsExtraData",
      "signature": "struct OsExtraData",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 8826337200476862962,
      "kind": "Struct",
      "name": "SignalKind",
      "signature": "struct SignalKind",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 10816310067861531159,
      "kind": "Struct",
      "name": "SignalInfo",
      "signature": "struct SignalInfo",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 4725212307548374811,
      "kind": "Function",
      "name": "action",
      "signature": "fn # [doc = \" Our global signal handler for all signals registered by this module.\"] # [doc = \"\"] # [doc = \" The purpose of this signal handler is to primarily:\"] # [doc = \"\"] # [doc = \" 1. Flag that our specific signal was received (e.g. store an atomic flag)\"] # [doc = \" 2. Wake up the driver by writing a byte to a pipe\"] # [doc = \"\"] # [doc = \" Those two operations should both be async-signal safe.\"] fn action (globals : & 'static Globals , signal : libc :: c_int) { globals . record_event (signal as EventId) ; let mut sender = & globals . sender ; drop (sender . write (& [1])) ; } . sig",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 12682341117219354791,
      "kind": "Function",
      "name": "signal_enable",
      "signature": "fn # [doc = \" Enables this module to receive signal notifications for the `signal`\"] # [doc = \" provided.\"] # [doc = \"\"] # [doc = \" This will register the signal handler if it hasn't already been registered,\"] # [doc = \" returning any error along the way if that fails.\"] fn signal_enable (signal : SignalKind , handle : & Handle) -> io :: Result < () > { let signal = signal . 0 ; if signal < 0 || signal_hook_registry :: FORBIDDEN . contains (& signal) { return Err (Error :: new (ErrorKind :: Other , format ! (\"Refusing to register signal {signal}\") ,)) ; } handle . check_inner () ? ; let globals = globals () ; let siginfo = match globals . storage () . get (signal as EventId) { Some (slot) => slot , None => return Err (io :: Error :: new (io :: ErrorKind :: Other , \"signal too large\")) , } ; let mut registered = Ok (()) ; siginfo . init . call_once (| | { registered = unsafe { signal_hook_registry :: register (signal , move | | action (globals , signal)) . map (| _ | ()) } ; if registered . is_ok () { siginfo . initialized . store (true , Ordering :: Relaxed) ; } }) ; registered ? ; if siginfo . initialized . load (Ordering :: Relaxed) { Ok (()) } else { Err (Error :: new (ErrorKind :: Other , \"Failed to register signal handler\" ,)) } } . sig",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 9930574543778187483,
      "kind": "Struct",
      "name": "Signal",
      "signature": "struct Signal",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 17317475449038343459,
      "kind": "Function",
      "name": "signal",
      "signature": "fn # [doc = \" Creates a new listener which will receive notifications when the current\"] # [doc = \" process receives the specified signal `kind`.\"] # [doc = \"\"] # [doc = \" This function will create a new stream which binds to the default reactor.\"] # [doc = \" The `Signal` stream is an infinite stream which will receive\"] # [doc = \" notifications whenever a signal is received. More documentation can be\"] # [doc = \" found on `Signal` itself, but to reiterate:\"] # [doc = \"\"] # [doc = \" * Signals may be coalesced beyond what the kernel already does.\"] # [doc = \" * Once a signal handler is registered with the process the underlying\"] # [doc = \"   libc signal handler is never unregistered.\"] # [doc = \"\"] # [doc = \" A `Signal` stream can be created for a particular signal number\"] # [doc = \" multiple times. When a signal is received then all the associated\"] # [doc = \" channels will receive the signal notification.\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" * If the lower-level C functions fail for some reason.\"] # [doc = \" * If the previous initialization of this specific signal failed.\"] # [doc = \" * If the signal is one of\"] # [doc = \"   [`signal_hook::FORBIDDEN`](fn@signal_hook_registry::register#panics)\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current reactor set, or if the `rt`\"] # [doc = \" feature flag is not enabled.\"] # [track_caller] pub fn signal (kind : SignalKind) -> io :: Result < Signal > { let handle = scheduler :: Handle :: current () ; let rx = signal_with_handle (kind , handle . driver () . signal ()) ? ; Ok (Signal { inner : RxFuture :: new (rx) , }) } . sig",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 12521491221106975398,
      "kind": "Function",
      "name": "signal_with_handle",
      "signature": "fn pub (crate) fn signal_with_handle (kind : SignalKind , handle : & Handle ,) -> io :: Result < watch :: Receiver < () > > { signal_enable (kind , handle) ? ; Ok (globals () . register_listener (kind . 0 as EventId)) } . sig",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 8033908629069695487,
      "kind": "Trait",
      "name": "InternalStream",
      "signature": "trait InternalStream",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 10022299250894031439,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn pub (crate) fn ctrl_c () -> io :: Result < Signal > { signal (SignalKind :: interrupt ()) } . sig",
      "file_path": "tokio/src/signal/unix.rs",
      "line": 0
    },
    {
      "hash": 6901413326858116456,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-c\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_c;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-C events.\"] # [doc = \"     let mut signal = ctrl_c()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-C event is received.\"] # [doc = \"     for countdown in (0..3).rev() {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got CTRL-C. {} more to exit\\\", countdown);\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_c () -> io :: Result < CtrlC > { Ok (CtrlC { inner : self :: imp :: ctrl_c () ? , }) } . sig",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 9397120727286101444,
      "kind": "Struct",
      "name": "CtrlC",
      "signature": "struct CtrlC",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 13687479403183172509,
      "kind": "Struct",
      "name": "CtrlBreak",
      "signature": "struct CtrlBreak",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 2992172417732382415,
      "kind": "Function",
      "name": "ctrl_break",
      "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-break\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_break;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-BREAK events.\"] # [doc = \"     let mut signal = ctrl_break()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-BREAK event is received.\"] # [doc = \"     loop {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got signal CTRL-BREAK\\\");\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_break () -> io :: Result < CtrlBreak > { Ok (CtrlBreak { inner : self :: imp :: ctrl_break () ? , }) } . sig",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 12545123057389068019,
      "kind": "Function",
      "name": "ctrl_close",
      "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-close\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_close;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-CLOSE events.\"] # [doc = \"     let mut signal = ctrl_close()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-CLOSE event is received.\"] # [doc = \"     for countdown in (0..3).rev() {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got CTRL-CLOSE. {} more to exit\\\", countdown);\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_close () -> io :: Result < CtrlClose > { Ok (CtrlClose { inner : self :: imp :: ctrl_close () ? , }) } . sig",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 15025030724304218966,
      "kind": "Struct",
      "name": "CtrlClose",
      "signature": "struct CtrlClose",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 8187056151378410515,
      "kind": "Function",
      "name": "ctrl_shutdown",
      "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-shutdown\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_shutdown;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-SHUTDOWN events.\"] # [doc = \"     let mut signal = ctrl_shutdown()?;\"] # [doc = \"\"] # [doc = \"     signal.recv().await;\"] # [doc = \"     println!(\\\"got CTRL-SHUTDOWN. Cleaning up before exiting\\\");\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_shutdown () -> io :: Result < CtrlShutdown > { Ok (CtrlShutdown { inner : self :: imp :: ctrl_shutdown () ? , }) } . sig",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 23081904334613825,
      "kind": "Struct",
      "name": "CtrlShutdown",
      "signature": "struct CtrlShutdown",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 8034403791475995764,
      "kind": "Function",
      "name": "ctrl_logoff",
      "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-logoff\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_logoff;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-LOGOFF events.\"] # [doc = \"     let mut signal = ctrl_logoff()?;\"] # [doc = \"\"] # [doc = \"     signal.recv().await;\"] # [doc = \"     println!(\\\"got CTRL-LOGOFF. Cleaning up before exiting\\\");\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_logoff () -> io :: Result < CtrlLogoff > { Ok (CtrlLogoff { inner : self :: imp :: ctrl_logoff () ? , }) } . sig",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 3296804313549774132,
      "kind": "Struct",
      "name": "CtrlLogoff",
      "signature": "struct CtrlLogoff",
      "file_path": "tokio/src/signal/windows.rs",
      "line": 0
    },
    {
      "hash": 11798824412119525038,
      "kind": "Function",
      "name": "ctrl_break",
      "signature": "fn pub (super) fn ctrl_break () -> io :: Result < RxFuture > { panic ! () } . sig",
      "file_path": "tokio/src/signal/windows/stub.rs",
      "line": 0
    },
    {
      "hash": 1251849668838633285,
      "kind": "Function",
      "name": "ctrl_close",
      "signature": "fn pub (super) fn ctrl_close () -> io :: Result < RxFuture > { panic ! () } . sig",
      "file_path": "tokio/src/signal/windows/stub.rs",
      "line": 0
    },
    {
      "hash": 3099047243509402529,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn pub (super) fn ctrl_c () -> io :: Result < RxFuture > { panic ! () } . sig",
      "file_path": "tokio/src/signal/windows/stub.rs",
      "line": 0
    },
    {
      "hash": 1353798589099989145,
      "kind": "Function",
      "name": "ctrl_logoff",
      "signature": "fn pub (super) fn ctrl_logoff () -> io :: Result < RxFuture > { panic ! () } . sig",
      "file_path": "tokio/src/signal/windows/stub.rs",
      "line": 0
    },
    {
      "hash": 9635519749507584806,
      "kind": "Function",
      "name": "ctrl_shutdown",
      "signature": "fn pub (super) fn ctrl_shutdown () -> io :: Result < RxFuture > { panic ! () } . sig",
      "file_path": "tokio/src/signal/windows/stub.rs",
      "line": 0
    },
    {
      "hash": 13055085203339383389,
      "kind": "Function",
      "name": "ctrl_break",
      "signature": "fn pub (super) fn ctrl_break () -> io :: Result < RxFuture > { new (console :: CTRL_BREAK_EVENT) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 10662921282166471398,
      "kind": "Function",
      "name": "ctrl_close",
      "signature": "fn pub (super) fn ctrl_close () -> io :: Result < RxFuture > { new (console :: CTRL_CLOSE_EVENT) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 6813440715831494331,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn pub (super) fn ctrl_c () -> io :: Result < RxFuture > { new (console :: CTRL_C_EVENT) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 5455614212939989165,
      "kind": "Function",
      "name": "ctrl_logoff",
      "signature": "fn pub (super) fn ctrl_logoff () -> io :: Result < RxFuture > { new (console :: CTRL_LOGOFF_EVENT) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 7885036312301365764,
      "kind": "Function",
      "name": "ctrl_shutdown",
      "signature": "fn pub (super) fn ctrl_shutdown () -> io :: Result < RxFuture > { new (console :: CTRL_SHUTDOWN_EVENT) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 10388541013596177163,
      "kind": "Function",
      "name": "new",
      "signature": "fn fn new (signum : u32) -> io :: Result < RxFuture > { global_init () ? ; let rx = globals () . register_listener (signum as EventId) ; Ok (RxFuture :: new (rx)) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 18036099852170788447,
      "kind": "Function",
      "name": "event_requires_infinite_sleep_in_handler",
      "signature": "fn fn event_requires_infinite_sleep_in_handler (signum : u32) -> bool { match signum { console :: CTRL_CLOSE_EVENT => true , console :: CTRL_LOGOFF_EVENT => true , console :: CTRL_SHUTDOWN_EVENT => true , _ => false , } } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 12753751648257178987,
      "kind": "Struct",
      "name": "OsStorage",
      "signature": "struct OsStorage",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 3429845791483069044,
      "kind": "Function",
      "name": "global_init",
      "signature": "fn fn global_init () -> io :: Result < () > { static INIT : Once = Once :: new () ; let mut init = None ; INIT . call_once (| | unsafe { let rc = console :: SetConsoleCtrlHandler (Some (handler) , 1) ; let ret = if rc == 0 { Err (io :: Error :: last_os_error ()) } else { Ok (()) } ; init = Some (ret) ; }) ; init . unwrap_or_else (| | Ok (())) } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 7798296953737638121,
      "kind": "Function",
      "name": "handler",
      "signature": "fn unsafe extern \"system\" fn handler (ty : u32) -> BOOL { let globals = globals () ; globals . record_event (ty as EventId) ; let event_was_handled = globals . broadcast () ; if event_was_handled && event_requires_infinite_sleep_in_handler (ty) { loop { std :: thread :: park () ; } } if event_was_handled { 1 } else { 0 } } . sig",
      "file_path": "tokio/src/signal/windows/sys.rs",
      "line": 0
    },
    {
      "hash": 5670051415881967404,
      "kind": "Struct",
      "name": "Semaphore",
      "signature": "struct Semaphore",
      "file_path": "tokio/src/sync/mpsc/unbounded.rs",
      "line": 0
    },
    {
      "hash": 7560877969284783180,
      "kind": "Struct",
      "name": "Waitlist",
      "signature": "struct Waitlist",
      "file_path": "tokio/src/sync/batch_semaphore.rs",
      "line": 0
    },
    {
      "hash": 11037690642226759374,
      "kind": "Struct",
      "name": "AcquireError",
      "signature": "struct AcquireError",
      "file_path": "tokio/src/sync/batch_semaphore.rs",
      "line": 0
    },
    {
      "hash": 13178838707244483023,
      "kind": "Struct",
      "name": "Acquire",
      "signature": "struct Acquire",
      "file_path": "tokio/src/sync/batch_semaphore.rs",
      "line": 0
    },
    {
      "hash": 16882020342739871868,
      "kind": "Struct",
      "name": "OwnedMutexGuard",
      "signature": "struct OwnedMutexGuard",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 15179404085153225767,
      "kind": "Struct",
      "name": "MappedMutexGuard",
      "signature": "struct MappedMutexGuard",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 17867219859629974311,
      "kind": "Struct",
      "name": "OwnedMappedMutexGuard",
      "signature": "struct OwnedMappedMutexGuard",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 6762231423414727943,
      "kind": "Struct",
      "name": "MutexGuardInner",
      "signature": "struct MutexGuardInner",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 497271189537023908,
      "kind": "Struct",
      "name": "OwnedMutexGuardInner",
      "signature": "struct OwnedMutexGuardInner",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 9547244520370319012,
      "kind": "Struct",
      "name": "MappedMutexGuardInner",
      "signature": "struct MappedMutexGuardInner",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 5358482088839283562,
      "kind": "Struct",
      "name": "OwnedMappedMutexGuardInner",
      "signature": "struct OwnedMappedMutexGuardInner",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 4831197805017781396,
      "kind": "Struct",
      "name": "TryLockError",
      "signature": "struct TryLockError",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 12789910471956454751,
      "kind": "Function",
      "name": "bounds",
      "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_send < T : Send > () { } fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } fn check_send_sync < T : Send + Sync > () { } fn check_static < T : 'static > () { } fn check_static_val < T : 'static > (_t : T) { } check_send :: < MutexGuard < '_ , u32 > > () ; check_send :: < OwnedMutexGuard < u32 > > () ; check_unpin :: < Mutex < u32 > > () ; check_send_sync :: < Mutex < u32 > > () ; check_static :: < OwnedMutexGuard < u32 > > () ; let mutex = Mutex :: new (1) ; check_send_sync_val (mutex . lock ()) ; let arc_mutex = Arc :: new (Mutex :: new (1)) ; check_send_sync_val (arc_mutex . clone () . lock_owned ()) ; check_static_val (arc_mutex . lock_owned ()) ; } . sig",
      "file_path": "tokio/src/sync/mutex.rs",
      "line": 0
    },
    {
      "hash": 4403305803619190898,
      "kind": "Struct",
      "name": "Notify",
      "signature": "struct Notify",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 2104964063075836865,
      "kind": "Struct",
      "name": "AtomicNotification",
      "signature": "struct AtomicNotification",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 10459916301509235264,
      "kind": "Struct",
      "name": "NotifyWaitersList",
      "signature": "struct NotifyWaitersList",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 14066432243081409991,
      "kind": "Struct",
      "name": "OwnedNotified",
      "signature": "struct OwnedNotified",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 648384271068571295,
      "kind": "Struct",
      "name": "NotifiedProject",
      "signature": "struct NotifiedProject",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 182707731855933506,
      "kind": "Function",
      "name": "set_state",
      "signature": "fn fn set_state (data : usize , state : usize) -> usize { (data & NOTIFY_WAITERS_CALLS_MASK) | (state & STATE_MASK) } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 17720871907423086859,
      "kind": "Function",
      "name": "get_state",
      "signature": "fn fn get_state (data : usize) -> usize { data & STATE_MASK } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 14912619264573487659,
      "kind": "Function",
      "name": "get_num_notify_waiters_calls",
      "signature": "fn fn get_num_notify_waiters_calls (data : usize) -> usize { (data & NOTIFY_WAITERS_CALLS_MASK) >> NOTIFY_WAITERS_SHIFT } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 16247359082815343902,
      "kind": "Function",
      "name": "inc_num_notify_waiters_calls",
      "signature": "fn fn inc_num_notify_waiters_calls (data : usize) -> usize { data + (1 << NOTIFY_WAITERS_SHIFT) } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 16291910088844968667,
      "kind": "Function",
      "name": "atomic_inc_num_notify_waiters_calls",
      "signature": "fn fn atomic_inc_num_notify_waiters_calls (data : & AtomicUsize) { data . fetch_add (1 << NOTIFY_WAITERS_SHIFT , SeqCst) ; } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 14783542128401764398,
      "kind": "Function",
      "name": "notify_locked",
      "signature": "fn fn notify_locked (waiters : & mut WaitList , state : & AtomicUsize , curr : usize , strategy : NotifyOneStrategy ,) -> Option < Waker > { match get_state (curr) { EMPTY | NOTIFIED => { let res = state . compare_exchange (curr , set_state (curr , NOTIFIED) , SeqCst , SeqCst) ; match res { Ok (_) => None , Err (actual) => { let actual_state = get_state (actual) ; assert ! (actual_state == EMPTY || actual_state == NOTIFIED) ; state . store (set_state (actual , NOTIFIED) , SeqCst) ; None } } } WAITING => { let waiter = match strategy { NotifyOneStrategy :: Fifo => waiters . pop_back () . unwrap () , NotifyOneStrategy :: Lifo => waiters . pop_front () . unwrap () , } ; let waiter = unsafe { waiter . as_ref () } ; let waker = unsafe { waiter . waker . with_mut (| waker | (* waker) . take ()) } ; waiter . notification . store_release (Notification :: One (strategy)) ; if waiters . is_empty () { state . store (set_state (curr , EMPTY) , SeqCst) ; } waker } _ => unreachable ! () , } } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 10686962778765721083,
      "kind": "Function",
      "name": "is_unpin",
      "signature": "fn fn is_unpin < T : Unpin > () { } . sig",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 2406822825471114119,
      "kind": "Struct",
      "name": "NotifyGuard",
      "signature": "struct NotifyGuard",
      "file_path": "tokio/src/sync/notify.rs",
      "line": 0
    },
    {
      "hash": 18021997974700980961,
      "kind": "Struct",
      "name": "OnceCell",
      "signature": "struct OnceCell",
      "file_path": "tokio/src/sync/once_cell.rs",
      "line": 0
    },
    {
      "hash": 7143116332028643169,
      "kind": "Function",
      "name": "channel",
      "signature": "fn # [doc = \" Creates a new one-shot channel for sending single values across asynchronous\"] # [doc = \" tasks.\"] # [doc = \"\"] # [doc = \" The function returns separate \\\"send\\\" and \\\"receive\\\" handles. The `Sender`\"] # [doc = \" handle is used by the producer to send the value. The `Receiver` handle is\"] # [doc = \" used by the consumer to receive the value.\"] # [doc = \"\"] # [doc = \" Each handle can be used on separate tasks.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \"\"] # [doc = \" tokio::spawn(async move {\"] # [doc = \"     if let Err(_) = tx.send(3) {\"] # [doc = \"         println!(\\\"the receiver dropped\\\");\"] # [doc = \"     }\"] # [doc = \" });\"] # [doc = \"\"] # [doc = \" match rx.await {\"] # [doc = \"     Ok(v) => println!(\\\"got = {:?}\\\", v),\"] # [doc = \"     Err(_) => println!(\\\"the sender dropped\\\"),\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [track_caller] pub fn channel < T > () -> (Sender < T > , Receiver < T >) { # [cfg (all (tokio_unstable , feature = \"tracing\"))] let resource_span = { let location = std :: panic :: Location :: caller () ; let resource_span = tracing :: trace_span ! (parent : None , \"runtime.resource\" , concrete_type = \"Sender|Receiver\" , kind = \"Sync\" , loc . file = location . file () , loc . line = location . line () , loc . col = location . column () ,) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , tx_dropped = false , tx_dropped . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , rx_dropped = false , rx_dropped . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , value_sent = false , value_sent . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , value_received = false , value_received . op = \"override\" ,) }) ; resource_span } ; let inner = Arc :: new (Inner { state : AtomicUsize :: new (State :: new () . as_usize ()) , value : UnsafeCell :: new (None) , tx_task : Task (UnsafeCell :: new (MaybeUninit :: uninit ())) , rx_task : Task (UnsafeCell :: new (MaybeUninit :: uninit ())) , }) ; let tx = Sender { inner : Some (inner . clone ()) , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span : resource_span . clone () , } ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let async_op_span = resource_span . in_scope (| | tracing :: trace_span ! (\"runtime.resource.async_op\" , source = \"Receiver::await\")) ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let async_op_poll_span = async_op_span . in_scope (| | tracing :: trace_span ! (\"runtime.resource.async_op.poll\")) ; let rx = Receiver { inner : Some (inner) , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span , # [cfg (all (tokio_unstable , feature = \"tracing\"))] async_op_span , # [cfg (all (tokio_unstable , feature = \"tracing\"))] async_op_poll_span , } ; (tx , rx) } . sig",
      "file_path": "tokio/src/sync/oneshot.rs",
      "line": 0
    },
    {
      "hash": 1216433999045074157,
      "kind": "Function",
      "name": "mut_load",
      "signature": "fn fn mut_load (this : & mut AtomicUsize) -> usize { this . with_mut (| v | * v) } . sig",
      "file_path": "tokio/src/sync/oneshot.rs",
      "line": 0
    },
    {
      "hash": 9762819939100806830,
      "kind": "Function",
      "name": "bounds",
      "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_send < T : Send > () { } fn check_sync < T : Sync > () { } fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } check_send :: < RwLock < u32 > > () ; check_sync :: < RwLock < u32 > > () ; check_unpin :: < RwLock < u32 > > () ; check_send :: < RwLockReadGuard < '_ , u32 > > () ; check_sync :: < RwLockReadGuard < '_ , u32 > > () ; check_unpin :: < RwLockReadGuard < '_ , u32 > > () ; check_send :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_sync :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_unpin :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_send :: < RwLockWriteGuard < '_ , u32 > > () ; check_sync :: < RwLockWriteGuard < '_ , u32 > > () ; check_unpin :: < RwLockWriteGuard < '_ , u32 > > () ; check_send :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_sync :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_unpin :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_send :: < OwnedRwLockWriteGuard < u32 > > () ; check_sync :: < OwnedRwLockWriteGuard < u32 > > () ; check_unpin :: < OwnedRwLockWriteGuard < u32 > > () ; check_send :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; check_sync :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; check_unpin :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; let rwlock = Arc :: new (RwLock :: new (0)) ; check_send_sync_val (rwlock . read ()) ; check_send_sync_val (Arc :: clone (& rwlock) . read_owned ()) ; check_send_sync_val (rwlock . write ()) ; check_send_sync_val (Arc :: clone (& rwlock) . write_owned ()) ; } . sig",
      "file_path": "tokio/src/sync/rwlock.rs",
      "line": 0
    },
    {
      "hash": 17424534004089504472,
      "kind": "Struct",
      "name": "SemaphorePermit",
      "signature": "struct SemaphorePermit",
      "file_path": "tokio/src/sync/semaphore.rs",
      "line": 0
    },
    {
      "hash": 17408188724879741305,
      "kind": "Struct",
      "name": "OwnedSemaphorePermit",
      "signature": "struct OwnedSemaphorePermit",
      "file_path": "tokio/src/sync/semaphore.rs",
      "line": 0
    },
    {
      "hash": 5006846363743704101,
      "kind": "Function",
      "name": "bounds",
      "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } fn check_send_sync < T : Send + Sync > () { } check_unpin :: < Semaphore > () ; check_unpin :: < SemaphorePermit < '_ > > () ; check_send_sync :: < Semaphore > () ; let semaphore = Semaphore :: new (0) ; check_send_sync_val (semaphore . acquire ()) ; } . sig",
      "file_path": "tokio/src/sync/semaphore.rs",
      "line": 0
    },
    {
      "hash": 5755375721445070105,
      "kind": "Struct",
      "name": "SetOnce",
      "signature": "struct SetOnce",
      "file_path": "tokio/src/sync/set_once.rs",
      "line": 0
    },
    {
      "hash": 16517926799049916176,
      "kind": "Struct",
      "name": "SetOnceError",
      "signature": "struct SetOnceError",
      "file_path": "tokio/src/sync/set_once.rs",
      "line": 0
    },
    {
      "hash": 1155673813110406031,
      "kind": "Struct",
      "name": "Block",
      "signature": "struct Block",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 13547779286906908827,
      "kind": "Struct",
      "name": "BlockHeader",
      "signature": "struct BlockHeader",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 6644370669382425935,
      "kind": "Struct",
      "name": "Values",
      "signature": "struct Values",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 9864344324725565697,
      "kind": "Function",
      "name": "start_index",
      "signature": "fn # [doc = \" Returns the index of the first slot in the block referenced by `slot_index`.\"] # [inline (always)] pub (crate) fn start_index (slot_index : usize) -> usize { BLOCK_MASK & slot_index } . sig",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 13542753076433642835,
      "kind": "Function",
      "name": "offset",
      "signature": "fn # [doc = \" Returns the offset into the block referenced by `slot_index`.\"] # [inline (always)] pub (crate) fn offset (slot_index : usize) -> usize { SLOT_MASK & slot_index } . sig",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 6957229095562331690,
      "kind": "Function",
      "name": "is_ready",
      "signature": "fn # [doc = \" Returns `true` if the specified slot has a value ready to be consumed.\"] fn is_ready (bits : usize , slot : usize) -> bool { let mask = 1 << slot ; mask == mask & bits } . sig",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 952976086619786278,
      "kind": "Function",
      "name": "is_tx_closed",
      "signature": "fn # [doc = \" Returns `true` if the closed flag has been set.\"] fn is_tx_closed (bits : usize) -> bool { TX_CLOSED == bits & TX_CLOSED } . sig",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 18236013118438970082,
      "kind": "Function",
      "name": "assert_no_stack_overflow",
      "signature": "fn # [cfg (all (test , not (loom)))] # [test] fn assert_no_stack_overflow () { struct Foo { _a : [u8 ; 2_000_000] , } assert_eq ! (Layout :: new ::< MaybeUninit < Block < Foo >>> () , Layout :: new ::< Block < Foo >> ()) ; let _block = Block :: < Foo > :: new (0) ; } . sig",
      "file_path": "tokio/src/sync/mpsc/block.rs",
      "line": 0
    },
    {
      "hash": 13549939549552019888,
      "kind": "Struct",
      "name": "Tx",
      "signature": "struct Tx",
      "file_path": "tokio/src/sync/mpsc/list.rs",
      "line": 0
    },
    {
      "hash": 6330198458390221717,
      "kind": "Struct",
      "name": "Rx",
      "signature": "struct Rx",
      "file_path": "tokio/src/sync/mpsc/list.rs",
      "line": 0
    },
    {
      "hash": 4282859715798227402,
      "kind": "Trait",
      "name": "Semaphore",
      "signature": "trait Semaphore",
      "file_path": "tokio/src/sync/mpsc/chan.rs",
      "line": 0
    },
    {
      "hash": 535854226926303779,
      "kind": "Struct",
      "name": "Chan",
      "signature": "struct Chan",
      "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 11624074788074320574,
      "kind": "Struct",
      "name": "RxFields",
      "signature": "struct RxFields",
      "file_path": "tokio/src/sync/mpsc/chan.rs",
      "line": 0
    },
    {
      "hash": 16375171073034509421,
      "kind": "Function",
      "name": "channel",
      "signature": "fn pub (crate) fn channel < T , S : Semaphore > (semaphore : S) -> (Tx < T , S > , Rx < T , S >) { let (tx , rx) = list :: channel () ; let chan = Arc :: new (Chan { notify_rx_closed : Notify :: new () , tx : CachePadded :: new (tx) , semaphore , rx_waker : CachePadded :: new (AtomicWaker :: new ()) , tx_count : AtomicUsize :: new (1) , tx_weak_count : AtomicUsize :: new (0) , rx_fields : UnsafeCell :: new (RxFields { list : rx , rx_closed : false , }) , }) ; (Tx :: new (chan . clone ()) , Rx :: new (chan)) } . sig",
      "file_path": "tokio/src/sync/mpsc/chan.rs",
      "line": 0
    },
    {
      "hash": 195233381880592766,
      "kind": "Struct",
      "name": "SendError",
      "signature": "struct SendError",
      "file_path": "tokio/src/sync/mpsc/error.rs",
      "line": 0
    },
    {
      "hash": 15223354668242353363,
      "kind": "Struct",
      "name": "RecvError",
      "signature": "struct RecvError",
      "file_path": "tokio/src/sync/mpsc/error.rs",
      "line": 0
    },
    {
      "hash": 6163790652058974981,
      "kind": "Function",
      "name": "channel",
      "signature": "fn pub (crate) fn channel < T > () -> (Tx < T > , Rx < T >) { let initial_block = Block :: new (0) ; let initial_block_ptr = Box :: into_raw (initial_block) ; let tx = Tx { block_tail : AtomicPtr :: new (initial_block_ptr) , tail_position : AtomicUsize :: new (0) , } ; let head = NonNull :: new (initial_block_ptr) . unwrap () ; let rx = Rx { head , index : 0 , free_head : head , } ; (tx , rx) } . sig",
      "file_path": "tokio/src/sync/mpsc/list.rs",
      "line": 0
    },
    {
      "hash": 6385034665475837701,
      "kind": "Struct",
      "name": "UnboundedSender",
      "signature": "struct UnboundedSender",
      "file_path": "tokio/src/sync/mpsc/unbounded.rs",
      "line": 0
    },
    {
      "hash": 17324488208694218184,
      "kind": "Struct",
      "name": "WeakUnboundedSender",
      "signature": "struct WeakUnboundedSender",
      "file_path": "tokio/src/sync/mpsc/unbounded.rs",
      "line": 0
    },
    {
      "hash": 6775699799553248360,
      "kind": "Struct",
      "name": "UnboundedReceiver",
      "signature": "struct UnboundedReceiver",
      "file_path": "tokio/src/sync/mpsc/unbounded.rs",
      "line": 0
    },
    {
      "hash": 18229434299241055954,
      "kind": "Function",
      "name": "unbounded_channel",
      "signature": "fn # [doc = \" Creates an unbounded mpsc channel for communicating between asynchronous\"] # [doc = \" tasks without backpressure.\"] # [doc = \"\"] # [doc = \" A `send` on this channel will always succeed as long as the receive half has\"] # [doc = \" not been closed. If the receiver falls behind, messages will be arbitrarily\"] # [doc = \" buffered.\"] # [doc = \"\"] # [doc = \" **Note** that the amount of available system memory is an implicit bound to\"] # [doc = \" the channel. Using an `unbounded` channel has the ability of causing the\"] # [doc = \" process to run out of memory. In this case, the process will be aborted.\"] pub fn unbounded_channel < T > () -> (UnboundedSender < T > , UnboundedReceiver < T >) { let (tx , rx) = chan :: channel (Semaphore (AtomicUsize :: new (0))) ; let tx = UnboundedSender :: new (tx) ; let rx = UnboundedReceiver :: new (rx) ; (tx , rx) } . sig",
      "file_path": "tokio/src/sync/mpsc/unbounded.rs",
      "line": 0
    },
    {
      "hash": 10956851563449199782,
      "kind": "Struct",
      "name": "OwnedRwLockReadGuard",
      "signature": "struct OwnedRwLockReadGuard",
      "file_path": "tokio/src/sync/rwlock/owned_read_guard.rs",
      "line": 0
    },
    {
      "hash": 9553687379687383683,
      "kind": "Struct",
      "name": "OwnedRwLockWriteGuard",
      "signature": "struct OwnedRwLockWriteGuard",
      "file_path": "tokio/src/sync/rwlock/owned_write_guard.rs",
      "line": 0
    },
    {
      "hash": 15597723212883881259,
      "kind": "Struct",
      "name": "OwnedRwLockMappedWriteGuard",
      "signature": "struct OwnedRwLockMappedWriteGuard",
      "file_path": "tokio/src/sync/rwlock/owned_write_guard_mapped.rs",
      "line": 0
    },
    {
      "hash": 7837141704646244853,
      "kind": "Struct",
      "name": "RwLockMappedWriteGuard",
      "signature": "struct RwLockMappedWriteGuard",
      "file_path": "tokio/src/sync/rwlock/write_guard_mapped.rs",
      "line": 0
    },
    {
      "hash": 14542899099915851850,
      "kind": "Struct",
      "name": "AtomicWaker",
      "signature": "struct AtomicWaker",
      "file_path": "tokio/src/sync/task/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 9136671734963883385,
      "kind": "Trait",
      "name": "WakerRef",
      "signature": "trait WakerRef",
      "file_path": "tokio/src/sync/task/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 13233862909537158735,
      "kind": "Trait",
      "name": "AssertSend",
      "signature": "trait AssertSend",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 12948692393582067867,
      "kind": "Trait",
      "name": "AssertSync",
      "signature": "trait AssertSync",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 5093783150582530962,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [test] fn basic_usage () { let mut waker = task :: spawn (AtomicWaker :: new ()) ; waker . enter (| cx , waker | waker . register_by_ref (cx . waker ())) ; waker . wake () ; assert ! (waker . is_woken ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 14625662389760972907,
      "kind": "Function",
      "name": "wake_without_register",
      "signature": "fn # [test] fn wake_without_register () { let mut waker = task :: spawn (AtomicWaker :: new ()) ; waker . wake () ; waker . enter (| cx , waker | waker . register_by_ref (cx . waker ())) ; assert ! (! waker . is_woken ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 16336199544202652054,
      "kind": "Function",
      "name": "failed_wake_synchronizes",
      "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn failed_wake_synchronizes () { for _ in 0 .. 1000 { failed_wake_synchronizes_inner () ; } } . sig",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 1089346181460232081,
      "kind": "Function",
      "name": "failed_wake_synchronizes_inner",
      "signature": "fn fn failed_wake_synchronizes_inner () { use futures :: task :: noop_waker_ref ; use std :: sync :: atomic :: { AtomicBool , Ordering } ; static DID_SYNCHRONIZE : AtomicBool = AtomicBool :: new (false) ; DID_SYNCHRONIZE . store (false , Ordering :: Relaxed) ; let waker = AtomicWaker :: new () ; waker . register_by_ref (noop_waker_ref ()) ; std :: thread :: scope (| s | { let jh = s . spawn (| | { DID_SYNCHRONIZE . store (true , Ordering :: Relaxed) ; waker . take_waker () }) ; waker . take_waker () ; waker . register_by_ref (noop_waker_ref ()) ; let did_synchronize = DID_SYNCHRONIZE . load (Ordering :: Relaxed) ; let did_take = jh . join () . unwrap () . is_some () ; assert ! (did_synchronize || did_take) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 15162523380149857115,
      "kind": "Function",
      "name": "atomic_waker_panic_safe",
      "signature": "fn # [cfg (panic = \"unwind\")] # [test] # [cfg (not (target_family = \"wasm\"))] fn atomic_waker_panic_safe () { use std :: panic ; use std :: ptr ; use std :: task :: { RawWaker , RawWakerVTable , Waker } ; static PANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | panic ! (\"clone\") , | _ | unimplemented ! (\"wake\") , | _ | unimplemented ! (\"wake_by_ref\") , | _ | () ,) ; static NONPANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | RawWaker :: new (ptr :: null () , & NONPANICKING_VTABLE) , | _ | unimplemented ! (\"wake\") , | _ | unimplemented ! (\"wake_by_ref\") , | _ | () ,) ; let panicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & PANICKING_VTABLE)) } ; let nonpanicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & NONPANICKING_VTABLE)) } ; let atomic_waker = AtomicWaker :: new () ; let panicking = panic :: AssertUnwindSafe (& panicking) ; let result = panic :: catch_unwind (| | { let panic :: AssertUnwindSafe (panicking) = panicking ; atomic_waker . register_by_ref (panicking) ; }) ; assert ! (result . is_err ()) ; assert ! (atomic_waker . take_waker () . is_none ()) ; atomic_waker . register_by_ref (& nonpanicking) ; assert ! (atomic_waker . take_waker () . is_some ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 10292279913864224205,
      "kind": "Function",
      "name": "basic_notification",
      "signature": "fn # [test] fn basic_notification () { const NUM_NOTIFY : usize = 2 ; loom :: model (| | { let chan = Arc :: new (Chan { num : AtomicUsize :: new (0) , task : AtomicWaker :: new () , }) ; for _ in 0 .. NUM_NOTIFY { let chan = chan . clone () ; thread :: spawn (move | | { chan . num . fetch_add (1 , Relaxed) ; chan . task . wake () ; }) ; } block_on (poll_fn (move | cx | { chan . task . register_by_ref (cx . waker ()) ; if NUM_NOTIFY == chan . num . load (Relaxed) { return Ready (()) ; } Pending })) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 15648669815427880817,
      "kind": "Function",
      "name": "test_panicky_waker",
      "signature": "fn # [test] fn test_panicky_waker () { use std :: panic ; use std :: ptr ; use std :: task :: { RawWaker , RawWakerVTable , Waker } ; static PANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | panic ! (\"clone\") , | _ | () , | _ | () , | _ | ()) ; let panicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & PANICKING_VTABLE)) } ; const NUM_NOTIFY : usize = 2 ; loom :: model (move | | { let chan = Arc :: new (Chan { num : AtomicUsize :: new (0) , task : AtomicWaker :: new () , }) ; for _ in 0 .. NUM_NOTIFY { let chan = chan . clone () ; thread :: spawn (move | | { chan . num . fetch_add (1 , Relaxed) ; chan . task . wake () ; }) ; } let _ = panic :: catch_unwind (| | chan . task . register_by_ref (& panicking)) ; block_on (poll_fn (move | cx | { chan . task . register_by_ref (cx . waker ()) ; if NUM_NOTIFY == chan . num . load (Relaxed) { return Ready (()) ; } Pending })) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
      "line": 0
    },
    {
      "hash": 9764452499839082628,
      "kind": "Function",
      "name": "broadcast_send",
      "signature": "fn # [test] fn broadcast_send () { loom :: model (| | { let (tx1 , mut rx) = broadcast :: channel (2) ; let tx1 = Arc :: new (tx1) ; let tx2 = tx1 . clone () ; let th1 = thread :: spawn (move | | { block_on (async { assert_ok ! (tx1 . send (\"one\")) ; assert_ok ! (tx1 . send (\"two\")) ; assert_ok ! (tx1 . send (\"three\")) ; }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { assert_ok ! (tx2 . send (\"eins\")) ; assert_ok ! (tx2 . send (\"zwei\")) ; assert_ok ! (tx2 . send (\"drei\")) ; }) ; }) ; block_on (async { let mut num = 0 ; loop { match rx . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 6) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
      "line": 0
    },
    {
      "hash": 14583000353858713143,
      "kind": "Function",
      "name": "broadcast_two",
      "signature": "fn # [test] fn broadcast_two () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel :: < Arc < & 'static str > > (16) ; let mut rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (* v , \"hello\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (* v , \"world\") ; match assert_err ! (rx1 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx2 . recv () . await) ; assert_eq ! (* v , \"hello\") ; let v = assert_ok ! (rx2 . recv () . await) ; assert_eq ! (* v , \"world\") ; match assert_err ! (rx2 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; assert_ok ! (tx . send (Arc :: new (\"hello\"))) ; assert_ok ! (tx . send (Arc :: new (\"world\"))) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
      "line": 0
    },
    {
      "hash": 8343358611259029649,
      "kind": "Function",
      "name": "broadcast_wrap",
      "signature": "fn # [test] fn broadcast_wrap () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel (2) ; let mut rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let mut num = 0 ; loop { match rx1 . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 3) ; }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { let mut num = 0 ; loop { match rx2 . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 3) ; }) ; }) ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_ok ! (tx . send (\"three\")) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
      "line": 0
    },
    {
      "hash": 7624655271209301001,
      "kind": "Function",
      "name": "drop_rx",
      "signature": "fn # [test] fn drop_rx () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel (16) ; let rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"one\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"two\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"three\") ; match assert_err ! (rx1 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; let th2 = thread :: spawn (move | | { drop (rx2) ; }) ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_ok ! (tx . send (\"three\")) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
      "line": 0
    },
    {
      "hash": 9117315940824114064,
      "kind": "Function",
      "name": "drop_multiple_rx_with_overflow",
      "signature": "fn # [test] fn drop_multiple_rx_with_overflow () { loom :: model (move | | { let (tx , mut rx) = broadcast :: channel (1) ; let _rx2 = tx . subscribe () ; let _ = tx . send (()) ; let tx2 = tx . clone () ; let th1 = thread :: spawn (move | | { block_on (async { for _ in 0 .. 100 { let _ = tx2 . send (()) ; } }) ; }) ; let _ = tx . send (()) ; let th2 = thread :: spawn (move | | { block_on (async { while let Ok (_) = rx . recv () . await { } }) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
      "line": 0
    },
    {
      "hash": 2480751490900247207,
      "kind": "Function",
      "name": "smoke",
      "signature": "fn # [test] fn smoke () { use crate :: sync :: mpsc :: block :: Read ; const NUM_TX : usize = 2 ; const NUM_MSG : usize = 2 ; loom :: model (| | { let (tx , mut rx) = list :: channel () ; let tx = Arc :: new (tx) ; for th in 0 .. NUM_TX { let tx = tx . clone () ; thread :: spawn (move | | { for i in 0 .. NUM_MSG { tx . push ((th , i)) ; } }) ; } let mut next = vec ! [0 ; NUM_TX] ; loop { match rx . pop (& tx) { Some (Read :: Value ((th , v))) => { assert_eq ! (v , next [th]) ; next [th] += 1 ; if next . iter () . all (| & i | i == NUM_MSG) { break ; } } Some (Read :: Closed) => { panic ! () ; } None => { thread :: yield_now () ; } } } }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_list.rs",
      "line": 0
    },
    {
      "hash": 13677520235758131928,
      "kind": "Function",
      "name": "closing_tx",
      "signature": "fn # [test] fn closing_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: channel (16) ; thread :: spawn (move | | { tx . try_send (()) . unwrap () ; drop (tx) ; }) ; let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1201260913695530347,
      "kind": "Function",
      "name": "closing_unbounded_tx",
      "signature": "fn # [test] fn closing_unbounded_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: unbounded_channel () ; thread :: spawn (move | | { tx . send (()) . unwrap () ; drop (tx) ; }) ; let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7385224706828879761,
      "kind": "Function",
      "name": "closing_bounded_rx",
      "signature": "fn # [test] fn closing_bounded_rx () { loom :: model (| | { let (tx1 , rx) = mpsc :: channel :: < () > (16) ; let tx2 = tx1 . clone () ; thread :: spawn (move | | { drop (rx) ; }) ; block_on (tx1 . closed ()) ; block_on (tx2 . closed ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9990015451029701671,
      "kind": "Function",
      "name": "closing_and_sending",
      "signature": "fn # [test] fn closing_and_sending () { loom :: model (| | { let (tx1 , mut rx) = mpsc :: channel :: < () > (16) ; let tx1 = Arc :: new (tx1) ; let tx2 = tx1 . clone () ; let th1 = thread :: spawn (move | | { tx1 . try_send (()) . unwrap () ; }) ; let th2 = thread :: spawn (move | | { block_on (tx2 . closed ()) ; }) ; let th3 = thread :: spawn (move | | { let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; drop (rx) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5997185458640480362,
      "kind": "Function",
      "name": "closing_unbounded_rx",
      "signature": "fn # [test] fn closing_unbounded_rx () { loom :: model (| | { let (tx1 , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx1 . clone () ; thread :: spawn (move | | { drop (rx) ; }) ; block_on (tx1 . closed ()) ; block_on (tx2 . closed ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9502977612437958331,
      "kind": "Function",
      "name": "dropping_tx",
      "signature": "fn # [test] fn dropping_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: channel :: < () > (16) ; for _ in 0 .. 2 { let tx = tx . clone () ; thread :: spawn (move | | { drop (tx) ; }) ; } drop (tx) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 8188238538289996020,
      "kind": "Function",
      "name": "dropping_unbounded_tx",
      "signature": "fn # [test] fn dropping_unbounded_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; for _ in 0 .. 2 { let tx = tx . clone () ; thread :: spawn (move | | { drop (tx) ; }) ; } drop (tx) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13527125262019726331,
      "kind": "Function",
      "name": "try_recv",
      "signature": "fn # [test] fn try_recv () { loom :: model (| | { use crate :: sync :: { mpsc , Semaphore } ; use loom :: sync :: { Arc , Mutex } ; const PERMITS : usize = 2 ; const TASKS : usize = 2 ; const CYCLES : usize = 1 ; struct Context { sem : Arc < Semaphore > , tx : mpsc :: Sender < () > , rx : Mutex < mpsc :: Receiver < () > > , } fn run (ctx : & Context) { block_on (async { let permit = ctx . sem . acquire () . await ; assert_ok ! (ctx . rx . lock () . unwrap () . try_recv ()) ; crate :: task :: yield_now () . await ; assert_ok ! (ctx . tx . clone () . try_send (())) ; drop (permit) ; }) ; } let (tx , rx) = mpsc :: channel (PERMITS) ; let sem = Arc :: new (Semaphore :: new (PERMITS)) ; let ctx = Arc :: new (Context { sem , tx , rx : Mutex :: new (rx) , }) ; for _ in 0 .. PERMITS { assert_ok ! (ctx . tx . clone () . try_send (())) ; } let mut ths = Vec :: new () ; for _ in 0 .. TASKS { let ctx = ctx . clone () ; ths . push (thread :: spawn (move | | { run (& ctx) ; })) ; } run (& ctx) ; for th in ths { th . join () . unwrap () ; } }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3607862064237108451,
      "kind": "Function",
      "name": "len_nonzero_after_send",
      "signature": "fn # [test] fn len_nonzero_after_send () { loom :: model (| | { let (send , recv) = mpsc :: channel (10) ; let send2 = send . clone () ; let join = thread :: spawn (move | | { block_on (send2 . send (\"message2\")) . unwrap () ; }) ; block_on (send . send (\"message1\")) . unwrap () ; assert ! (recv . len () != 0) ; join . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3688115653290336840,
      "kind": "Function",
      "name": "nonempty_after_send",
      "signature": "fn # [test] fn nonempty_after_send () { loom :: model (| | { let (send , recv) = mpsc :: channel (10) ; let send2 = send . clone () ; let join = thread :: spawn (move | | { block_on (send2 . send (\"message2\")) . unwrap () ; }) ; block_on (send . send (\"message1\")) . unwrap () ; assert ! (! recv . is_empty ()) ; join . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
      "line": 0
    },
    {
      "hash": 16241334379209996516,
      "kind": "Function",
      "name": "notify_one",
      "signature": "fn # [test] fn notify_one () { loom :: model (| | { let tx = Arc :: new (Notify :: new ()) ; let rx = tx . clone () ; let th = thread :: spawn (move | | { block_on (async { rx . notified () . await ; }) ; }) ; tx . notify_one () ; th . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 1726348725542137082,
      "kind": "Function",
      "name": "notify_waiters",
      "signature": "fn # [test] fn notify_waiters () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let tx = notify . clone () ; let notified1 = notify . notified () ; let notified2 = notify . notified () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; block_on (async { notified1 . await ; notified2 . await ; }) ; th . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 5761841985714470122,
      "kind": "Function",
      "name": "notify_waiters_and_one",
      "signature": "fn # [test] fn notify_waiters_and_one () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let tx1 = notify . clone () ; let tx2 = notify . clone () ; let th1 = thread :: spawn (move | | { tx1 . notify_waiters () ; }) ; let th2 = thread :: spawn (move | | { tx2 . notify_one () ; }) ; let th3 = thread :: spawn (move | | { let notified = notify . notified () ; block_on (async { notified . await ; }) ; }) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; th3 . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 15754822651790620166,
      "kind": "Function",
      "name": "notify_multi",
      "signature": "fn # [test] fn notify_multi () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let mut ths = vec ! [] ; for _ in 0 .. 2 { let notify = notify . clone () ; ths . push (thread :: spawn (move | | { block_on (async { notify . notified () . await ; notify . notify_one () ; }) })) ; } notify . notify_one () ; for th in ths . drain (..) { th . join () . unwrap () ; } block_on (async { notify . notified () . await ; }) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 13306123188128447380,
      "kind": "Function",
      "name": "notify_drop",
      "signature": "fn # [test] fn notify_drop () { use std :: future :: { poll_fn , Future } ; use std :: task :: Poll ; loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let rx1 = notify . clone () ; let rx2 = notify . clone () ; let th1 = thread :: spawn (move | | { let mut recv = Box :: pin (rx1 . notified ()) ; block_on (poll_fn (| cx | { if recv . as_mut () . poll (cx) . is_ready () { rx1 . notify_one () ; } Poll :: Ready (()) })) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { rx2 . notified () . await ; rx2 . notify_one () ; rx2 . notified () . await ; }) ; }) ; notify . notify_one () ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 9163974666510792896,
      "kind": "Function",
      "name": "notify_waiters_poll_consistency",
      "signature": "fn # [doc = \" Polls two `Notified` futures and checks if poll results are consistent\"] # [doc = \" with each other. If the first future is notified by a `notify_waiters`\"] # [doc = \" call, then the second one must be notified as well.\"] # [test] fn notify_waiters_poll_consistency () { fn notify_waiters_poll_consistency_variant (poll_setting : [bool ; 2]) { let notify = Arc :: new (Notify :: new ()) ; let mut notified = [tokio_test :: task :: spawn (notify . notified ()) , tokio_test :: task :: spawn (notify . notified ()) ,] ; for i in 0 .. 2 { if poll_setting [i] { assert_pending ! (notified [i] . poll ()) ; } } let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; let res1 = notified [0] . poll () ; let res2 = notified [1] . poll () ; assert ! (res1 . is_pending () || res2 . is_ready ()) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_poll_consistency_variant ([false , false])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([true , false])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([false , true])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([true , true])) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 17186394960530225432,
      "kind": "Function",
      "name": "notify_waiters_poll_consistency_many",
      "signature": "fn # [doc = \" Polls two `Notified` futures and checks if poll results are consistent\"] # [doc = \" with each other. If the first future is notified by a `notify_waiters`\"] # [doc = \" call, then the second one must be notified as well.\"] # [doc = \"\"] # [doc = \" Here we also add other `Notified` futures in between to force the two\"] # [doc = \" tested futures to end up in different chunks.\"] # [test] fn notify_waiters_poll_consistency_many () { fn notify_waiters_poll_consistency_many_variant (order : [usize ; 2]) { let notify = Arc :: new (Notify :: new ()) ; let mut futs = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | tokio_test :: task :: spawn (notify . notified ())) . collect :: < Vec < _ > > () ; assert_pending ! (futs [order [0]] . poll ()) ; for i in 2 .. futs . len () { assert_pending ! (futs [i] . poll ()) ; } assert_pending ! (futs [order [1]] . poll ()) ; let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; let res1 = futs [0] . poll () ; let res2 = futs [1] . poll () ; assert ! (res1 . is_pending () || res2 . is_ready ()) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_poll_consistency_many_variant ([0 , 1])) ; loom :: model (| | notify_waiters_poll_consistency_many_variant ([1 , 0])) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 63384701233721966,
      "kind": "Function",
      "name": "notify_waiters_is_atomic",
      "signature": "fn # [doc = \" Checks if a call to `notify_waiters` is observed as atomic when combined\"] # [doc = \" with a concurrent call to `notify_one`.\"] # [test] fn notify_waiters_is_atomic () { fn notify_waiters_is_atomic_variant (tested_fut_index : usize) { let notify = Arc :: new (Notify :: new ()) ; let mut futs = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | tokio_test :: task :: spawn (notify . notified ())) . collect :: < Vec < _ > > () ; for fut in & mut futs { assert_pending ! (fut . poll ()) ; } let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; block_on (async { futs . remove (tested_fut_index) . await ; let mut new_fut = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (new_fut . poll ()) ; notify . notify_one () ; assert_ready ! (new_fut . poll ()) ; }) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_is_atomic_variant (0)) ; loom :: model (| | notify_waiters_is_atomic_variant (32)) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 12584787481943012176,
      "kind": "Function",
      "name": "notify_waiters_sequential_notified_await",
      "signature": "fn # [doc = \" Checks if a single call to `notify_waiters` does not get through two `Notified`\"] # [doc = \" futures created and awaited sequentially like this:\"] # [doc = \" ```ignore\"] # [doc = \" notify.notified().await;\"] # [doc = \" notify.notified().await;\"] # [doc = \" ```\"] # [test] fn notify_waiters_sequential_notified_await () { use crate :: sync :: oneshot ; loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let (tx_fst , rx_fst) = oneshot :: channel () ; let (tx_snd , rx_snd) = oneshot :: channel () ; let receiver = thread :: spawn ({ let notify = notify . clone () ; move | | { block_on (async { let mut first_notified = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (first_notified . poll ()) ; let _task_pile = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | { let mut fut = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (fut . poll ()) ; fut }) . collect :: < Vec < _ > > () ; tx_fst . send (()) . unwrap () ; first_notified . await ; let mut second_notified = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (second_notified . poll ()) ; rx_snd . await . unwrap () ; assert_pending ! (second_notified . poll ()) ; }) ; } }) ; block_on (rx_fst) . unwrap () ; notify . notify_waiters () ; tx_snd . send (()) . unwrap () ; receiver . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_notify.rs",
      "line": 0
    },
    {
      "hash": 14684654829973107585,
      "kind": "Function",
      "name": "smoke",
      "signature": "fn # [test] fn smoke () { loom :: model (| | { let (tx , rx) = oneshot :: channel () ; thread :: spawn (move | | { tx . send (1) . unwrap () ; }) ; let value = block_on (rx) . unwrap () ; assert_eq ! (1 , value) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 16733333720036567421,
      "kind": "Function",
      "name": "changing_rx_task",
      "signature": "fn # [test] fn changing_rx_task () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { tx . send (1) . unwrap () ; }) ; let rx = thread :: spawn (move | | { let ready = block_on (poll_fn (| cx | match Pin :: new (& mut rx) . poll (cx) { Ready (Ok (value)) => { assert_eq ! (1 , value) ; Ready (true) } Ready (Err (_)) => unimplemented ! () , Pending => Ready (false) , })) ; if ready { None } else { Some (rx) } }) . join () . unwrap () ; if let Some (rx) = rx { let value = block_on (rx) . unwrap () ; assert_eq ! (1 , value) ; } }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 1628771126068430833,
      "kind": "Function",
      "name": "try_recv_close",
      "signature": "fn # [test] fn try_recv_close () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { let _ = tx . send (()) ; }) ; rx . close () ; let _ = rx . try_recv () ; }) } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 9926677225608356751,
      "kind": "Function",
      "name": "recv_closed",
      "signature": "fn # [test] fn recv_closed () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { let _ = tx . send (1) ; }) ; rx . close () ; let _ = block_on (rx) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 3530408716121609357,
      "kind": "Struct",
      "name": "OnClose",
      "signature": "struct OnClose",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 7539431085985877194,
      "kind": "Function",
      "name": "changing_tx_task",
      "signature": "fn # [test] fn changing_tx_task () { loom :: model (| | { let (mut tx , rx) = oneshot :: channel :: < i32 > () ; thread :: spawn (move | | { drop (rx) ; }) ; let tx = thread :: spawn (move | | { let t1 = block_on (OnClose :: new (& mut tx)) ; if t1 { None } else { Some (tx) } }) . join () . unwrap () ; if let Some (mut tx) = tx { block_on (OnClose :: new (& mut tx)) ; } }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 3929616888398939156,
      "kind": "Function",
      "name": "checking_tx_send_ok_not_drop",
      "signature": "fn # [test] fn checking_tx_send_ok_not_drop () { use std :: borrow :: Borrow ; use std :: cell :: Cell ; loom :: thread_local ! { static IS_RX : Cell < bool > = Cell :: new (true) ; } struct Msg ; impl Drop for Msg { fn drop (& mut self) { IS_RX . with (| is_rx : & Cell < _ > | { assert ! (is_rx . get ()) ; }) ; } } let mut builder = loom :: model :: Builder :: new () ; builder . preemption_bound = Some (2) ; builder . check (| | { let (tx , rx) = oneshot :: channel () ; let tx_thread_join_handle = thread :: spawn (move | | { IS_RX . with (| is_rx : & Cell < _ > | { is_rx . set (false) ; }) ; if let Err (msg) = tx . send (Msg) { std :: mem :: forget (msg) ; } }) ; drop (rx) ; tx_thread_join_handle . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13742055554093293073,
      "kind": "Function",
      "name": "concurrent_write",
      "signature": "fn # [test] fn concurrent_write () { let b = loom :: model :: Builder :: new () ; b . check (| | { let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone = rwlock . clone () ; let t1 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t2 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write_owned () . await ; * guard += 5 ; }) ; }) ; t1 . join () . expect (\"thread 1 write should not panic\") ; t2 . join () . expect (\"thread 2 write should not panic\") ; let guard = block_on (rwlock . read ()) ; assert_eq ! (10 , * guard) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
      "line": 0
    },
    {
      "hash": 4534699436982523988,
      "kind": "Function",
      "name": "concurrent_read_write",
      "signature": "fn # [test] fn concurrent_read_write () { let b = loom :: model :: Builder :: new () ; b . check (| | { let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone = rwlock . clone () ; let t1 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t2 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write_owned () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t3 = thread :: spawn (move | | { block_on (async { let guard = rwclone . read () . await ; assert ! (* guard == 0 || * guard == 5 || * guard == 10) ; }) ; }) ; { let guard = block_on (rwlock . clone () . read_owned ()) ; assert ! (* guard == 0 || * guard == 5 || * guard == 10) ; } t1 . join () . expect (\"thread 1 write should not panic\") ; t2 . join () . expect (\"thread 2 write should not panic\") ; t3 . join () . expect (\"thread 3 read should not panic\") ; let guard = block_on (rwlock . read ()) ; assert_eq ! (10 , * guard) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
      "line": 0
    },
    {
      "hash": 15158767271820069488,
      "kind": "Function",
      "name": "downgrade",
      "signature": "fn # [test] fn downgrade () { loom :: model (| | { let lock = Arc :: new (RwLock :: new (1)) ; let n = block_on (lock . write ()) ; let cloned_lock = lock . clone () ; let handle = thread :: spawn (move | | { let mut guard = block_on (cloned_lock . write ()) ; * guard = 2 ; }) ; let n = n . downgrade () ; assert_eq ! (* n , 1) ; drop (n) ; handle . join () . unwrap () ; assert_eq ! (* block_on (lock . read ()) , 2) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
      "line": 0
    },
    {
      "hash": 532339345312471242,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [test] fn basic_usage () { const NUM : usize = 2 ; struct Shared { semaphore : Semaphore , active : AtomicUsize , } async fn actor (shared : Arc < Shared >) { shared . semaphore . acquire (1) . await . unwrap () ; let actual = shared . active . fetch_add (1 , SeqCst) ; assert ! (actual <= NUM - 1) ; let actual = shared . active . fetch_sub (1 , SeqCst) ; assert ! (actual <= NUM) ; shared . semaphore . release (1) ; } loom :: model (| | { let shared = Arc :: new (Shared { semaphore : Semaphore :: new (NUM) , active : AtomicUsize :: new (0) , }) ; for _ in 0 .. NUM { let shared = shared . clone () ; thread :: spawn (move | | { block_on (actor (shared)) ; }) ; } block_on (actor (shared)) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 7161386852560881735,
      "kind": "Function",
      "name": "release",
      "signature": "fn # [test] fn release () { loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; { let semaphore = semaphore . clone () ; thread :: spawn (move | | { block_on (semaphore . acquire (1)) . unwrap () ; semaphore . release (1) ; }) ; } block_on (semaphore . acquire (1)) . unwrap () ; semaphore . release (1) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 15060775929439844641,
      "kind": "Function",
      "name": "basic_closing",
      "signature": "fn # [test] fn basic_closing () { const NUM : usize = 2 ; loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; for _ in 0 .. NUM { let semaphore = semaphore . clone () ; thread :: spawn (move | | { for _ in 0 .. 2 { block_on (semaphore . acquire (1)) . map_err (| _ | ()) ? ; semaphore . release (1) ; } Ok :: < () , () > (()) }) ; } semaphore . close () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 2076746780412793796,
      "kind": "Function",
      "name": "concurrent_close",
      "signature": "fn # [test] fn concurrent_close () { const NUM : usize = 3 ; loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; for _ in 0 .. NUM { let semaphore = semaphore . clone () ; thread :: spawn (move | | { block_on (semaphore . acquire (1)) . map_err (| _ | ()) ? ; semaphore . release (1) ; semaphore . close () ; Ok :: < () , () > (()) }) ; } }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 8057740828977290357,
      "kind": "Function",
      "name": "concurrent_cancel",
      "signature": "fn # [test] fn concurrent_cancel () { async fn poll_and_cancel (semaphore : Arc < Semaphore >) { let mut acquire1 = Some (semaphore . acquire (1)) ; let mut acquire2 = Some (semaphore . acquire (1)) ; poll_fn (| cx | { if let Some (acquire) = acquire1 . take () { pin ! (acquire) ; let _ = acquire . poll (cx) ; } if let Some (acquire) = acquire2 . take () { pin ! (acquire) ; let _ = acquire . poll (cx) ; } Poll :: Ready (()) }) . await } loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (0)) ; let t1 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; let t2 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; let t3 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; t1 . join () . unwrap () ; semaphore . release (10) ; t2 . join () . unwrap () ; t3 . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 7438869334745008932,
      "kind": "Function",
      "name": "batch",
      "signature": "fn # [test] fn batch () { let mut b = loom :: model :: Builder :: new () ; b . preemption_bound = Some (1) ; b . check (| | { let semaphore = Arc :: new (Semaphore :: new (10)) ; let active = Arc :: new (AtomicUsize :: new (0)) ; let mut ths = vec ! [] ; for _ in 0 .. 2 { let semaphore = semaphore . clone () ; let active = active . clone () ; ths . push (thread :: spawn (move | | { for n in & [4 , 10 , 8] { block_on (semaphore . acquire (* n)) . unwrap () ; active . fetch_add (* n as usize , SeqCst) ; let num_active = active . load (SeqCst) ; assert ! (num_active <= 10) ; thread :: yield_now () ; active . fetch_sub (* n as usize , SeqCst) ; semaphore . release (* n as usize) ; } })) ; } for th in ths . into_iter () { th . join () . unwrap () ; } assert_eq ! (10 , semaphore . available_permits ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 14160929273061816561,
      "kind": "Function",
      "name": "release_during_acquire",
      "signature": "fn # [test] fn release_during_acquire () { loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (10)) ; semaphore . try_acquire (8) . expect (\"try_acquire should succeed; semaphore uncontended\") ; let semaphore2 = semaphore . clone () ; let thread = thread :: spawn (move | | block_on (semaphore2 . acquire (4)) . unwrap ()) ; semaphore . release (8) ; thread . join () . unwrap () ; semaphore . release (4) ; assert_eq ! (10 , semaphore . available_permits ()) ; }) } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 13062530132046035168,
      "kind": "Function",
      "name": "concurrent_permit_updates",
      "signature": "fn # [test] fn concurrent_permit_updates () { loom :: model (move | | { let semaphore = Arc :: new (Semaphore :: new (5)) ; let t1 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | semaphore . release (3)) } ; let t2 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | { semaphore . try_acquire (1) . expect (\"try_acquire should succeed\") }) } ; let t3 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | semaphore . forget_permits (2)) } ; t1 . join () . unwrap () ; t2 . join () . unwrap () ; t3 . join () . unwrap () ; assert_eq ! (semaphore . available_permits () , 5) ; }) } . sig",
      "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 12874590448276057086,
      "kind": "Struct",
      "name": "DropCounter",
      "signature": "struct DropCounter",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 2871305629853516212,
      "kind": "Function",
      "name": "set_once_drop_test",
      "signature": "fn # [test] fn set_once_drop_test () { loom :: model (| | { let set_once = Arc :: new (SetOnce :: new ()) ; let set_once_clone = Arc :: clone (& set_once) ; let drop_counter = DropCounter :: new () ; let counter_cl = drop_counter . clone () ; let thread = thread :: spawn (move | | set_once_clone . set (counter_cl) . is_ok ()) ; let foo = drop_counter . clone () ; let set = set_once . set (foo) . is_ok () ; let res = thread . join () . unwrap () ; drop (set_once) ; drop_counter . assert_num_drops (2) ; assert ! (res != set) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_set_once.rs",
      "line": 0
    },
    {
      "hash": 2870243999957536466,
      "kind": "Function",
      "name": "set_once_wait_test",
      "signature": "fn # [test] fn set_once_wait_test () { loom :: model (| | { let tx = Arc :: new (SetOnce :: new ()) ; let rx_one = tx . clone () ; let rx_two = tx . clone () ; let thread = thread :: spawn (move | | { assert ! (rx_one . set (2) . is_ok ()) ; }) ; block_on (async { assert_eq ! (* rx_two . wait () . await , 2) ; }) ; thread . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_set_once.rs",
      "line": 0
    },
    {
      "hash": 18100425984493070887,
      "kind": "Function",
      "name": "smoke",
      "signature": "fn # [test] fn smoke () { loom :: model (| | { let (tx , mut rx1) = watch :: channel (1) ; let mut rx2 = rx1 . clone () ; let mut rx3 = rx1 . clone () ; let mut rx4 = rx1 . clone () ; let mut rx5 = rx1 . clone () ; let th = thread :: spawn (move | | { tx . send (2) . unwrap () ; }) ; block_on (rx1 . changed ()) . unwrap () ; assert_eq ! (* rx1 . borrow () , 2) ; block_on (rx2 . changed ()) . unwrap () ; assert_eq ! (* rx2 . borrow () , 2) ; block_on (rx3 . changed ()) . unwrap () ; assert_eq ! (* rx3 . borrow () , 2) ; block_on (rx4 . changed ()) . unwrap () ; assert_eq ! (* rx4 . borrow () , 2) ; block_on (rx5 . changed ()) . unwrap () ; assert_eq ! (* rx5 . borrow () , 2) ; th . join () . unwrap () ; }) } . sig",
      "file_path": "tokio/src/sync/tests/loom_watch.rs",
      "line": 0
    },
    {
      "hash": 2714755234036112748,
      "kind": "Function",
      "name": "wait_for_test",
      "signature": "fn # [test] fn wait_for_test () { loom :: model (move | | { let (tx , mut rx) = watch :: channel (false) ; let tx_arc = Arc :: new (tx) ; let tx1 = tx_arc . clone () ; let tx2 = tx_arc . clone () ; let th1 = thread :: spawn (move | | { for _ in 0 .. 2 { tx1 . send_modify (| _x | { }) ; } }) ; let th2 = thread :: spawn (move | | { tx2 . send (true) . unwrap () ; }) ; assert_eq ! (* block_on (rx . wait_for (| x | * x)) . unwrap () , true) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_watch.rs",
      "line": 0
    },
    {
      "hash": 17353709853432622039,
      "kind": "Function",
      "name": "wait_for_returns_correct_value",
      "signature": "fn # [test] fn wait_for_returns_correct_value () { loom :: model (move | | { let (tx , mut rx) = watch :: channel (0) ; let jh = thread :: spawn (move | | { tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; tx . send (3) . unwrap () ; }) ; let mut stopped_at = usize :: MAX ; let returned = * block_on (rx . wait_for (| x | { stopped_at = * x ; true })) . unwrap () ; assert_eq ! (stopped_at , returned) ; jh . join () . unwrap () ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_watch.rs",
      "line": 0
    },
    {
      "hash": 6698412218282532238,
      "kind": "Function",
      "name": "multiple_sender_drop_concurrently",
      "signature": "fn # [test] fn multiple_sender_drop_concurrently () { loom :: model (move | | { let (tx1 , rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let jh = thread :: spawn (move | | { drop (tx2) ; }) ; assert ! (rx . has_changed () . is_ok ()) ; drop (tx1) ; jh . join () . unwrap () ; assert ! (rx . has_changed () . is_err ()) ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/loom_watch.rs",
      "line": 0
    },
    {
      "hash": 4261159893911865758,
      "kind": "Function",
      "name": "notify_clones_waker_before_lock",
      "signature": "fn # [test] fn notify_clones_waker_before_lock () { const VTABLE : & RawWakerVTable = & RawWakerVTable :: new (clone_w , wake , wake_by_ref , drop_w) ; unsafe fn clone_w (data : * const ()) -> RawWaker { let ptr = data as * const Notify ; Arc :: < Notify > :: increment_strong_count (ptr) ; (* ptr) . notify_one () ; RawWaker :: new (data , VTABLE) } unsafe fn drop_w (data : * const ()) { drop (Arc :: < Notify > :: from_raw (data as * const Notify)) ; } unsafe fn wake (_data : * const ()) { unreachable ! () } unsafe fn wake_by_ref (_data : * const ()) { unreachable ! () } let notify = Arc :: new (Notify :: new ()) ; let notify2 = notify . clone () ; let waker = unsafe { Waker :: from_raw (RawWaker :: new (Arc :: into_raw (notify2) as * const _ , VTABLE)) } ; let mut cx = Context :: from_waker (& waker) ; let future = notify . notified () ; pin ! (future) ; let _ = future . poll (& mut cx) ; } . sig",
      "file_path": "tokio/src/sync/tests/notify.rs",
      "line": 0
    },
    {
      "hash": 6920495329088931695,
      "kind": "Function",
      "name": "notify_waiters_handles_panicking_waker",
      "signature": "fn # [cfg (panic = \"unwind\")] # [test] fn notify_waiters_handles_panicking_waker () { use futures :: task :: ArcWake ; let notify = Arc :: new (Notify :: new ()) ; struct PanickingWaker (# [allow (dead_code)] Arc < Notify >) ; impl ArcWake for PanickingWaker { fn wake_by_ref (_arc_self : & Arc < Self >) { panic ! (\"waker panicked\") ; } } let bad_fut = notify . notified () ; pin ! (bad_fut) ; let waker = futures :: task :: waker (Arc :: new (PanickingWaker (notify . clone ()))) ; let mut cx = Context :: from_waker (& waker) ; let _ = bad_fut . poll (& mut cx) ; let mut futs = Vec :: new () ; for _ in 0 .. 32 { let mut fut = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut . poll () . is_pending ()) ; futs . push (fut) ; } assert ! (std :: panic :: catch_unwind (|| { notify . notify_waiters () ; }) . is_err ()) ; for mut fut in futs { assert ! (fut . poll () . is_ready ()) ; } } . sig",
      "file_path": "tokio/src/sync/tests/notify.rs",
      "line": 0
    },
    {
      "hash": 7038770439348200718,
      "kind": "Function",
      "name": "notify_simple",
      "signature": "fn # [test] fn notify_simple () { let notify = Notify :: new () ; let mut fut1 = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut1 . poll () . is_pending ()) ; let mut fut2 = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut2 . poll () . is_pending ()) ; notify . notify_waiters () ; assert ! (fut1 . poll () . is_ready ()) ; assert ! (fut2 . poll () . is_ready ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/notify.rs",
      "line": 0
    },
    {
      "hash": 7104271106258405180,
      "kind": "Function",
      "name": "watch_test",
      "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] fn watch_test () { let rt = crate :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let (tx , mut rx) = crate :: sync :: watch :: channel (()) ; crate :: spawn (async move { let _ = tx . send (()) ; }) ; let _ = rx . changed () . await ; }) ; } . sig",
      "file_path": "tokio/src/sync/tests/notify.rs",
      "line": 0
    },
    {
      "hash": 12810835141148670610,
      "kind": "Function",
      "name": "poll_acquire_one_available",
      "signature": "fn # [test] fn poll_acquire_one_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 99) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 1928577688820318808,
      "kind": "Function",
      "name": "poll_acquire_many_available",
      "signature": "fn # [test] fn poll_acquire_many_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ready_ok ! (task :: spawn (s . acquire (5)) . poll ()) ; assert_eq ! (s . available_permits () , 95) ; assert_ready_ok ! (task :: spawn (s . acquire (5)) . poll ()) ; assert_eq ! (s . available_permits () , 90) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 18156922906891176035,
      "kind": "Function",
      "name": "try_acquire_one_available",
      "signature": "fn # [test] fn try_acquire_one_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 99) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 98) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 6311957084463942630,
      "kind": "Function",
      "name": "try_acquire_many_available",
      "signature": "fn # [test] fn try_acquire_many_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ok ! (s . try_acquire (5)) ; assert_eq ! (s . available_permits () , 95) ; assert_ok ! (s . try_acquire (5)) ; assert_eq ! (s . available_permits () , 90) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 14078415299636785086,
      "kind": "Function",
      "name": "poll_acquire_one_unavailable",
      "signature": "fn # [test] fn poll_acquire_one_unavailable () { let s = Semaphore :: new (1) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire_2 = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 0) ; assert ! (acquire_2 . is_woken ()) ; assert_ready_ok ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 11603552873554975491,
      "kind": "Function",
      "name": "poll_acquire_many_unavailable",
      "signature": "fn # [test] fn poll_acquire_many_unavailable () { let s = Semaphore :: new (5) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 4) ; let mut acquire_2 = task :: spawn (s . acquire (5)) ; assert_pending ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire_3 = task :: spawn (s . acquire (3)) ; assert_pending ! (acquire_3 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 0) ; assert ! (acquire_2 . is_woken ()) ; assert_ready_ok ! (acquire_2 . poll ()) ; assert ! (! acquire_3 . is_woken ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert ! (! acquire_3 . is_woken ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (2) ; assert ! (acquire_3 . is_woken ()) ; assert_ready_ok ! (acquire_3 . poll ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 8192646047141853695,
      "kind": "Function",
      "name": "try_acquire_one_unavailable",
      "signature": "fn # [test] fn try_acquire_one_unavailable () { let s = Semaphore :: new (1) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 0) ; assert_err ! (s . try_acquire (1)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; assert_ok ! (s . try_acquire (1)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 18016584796528161052,
      "kind": "Function",
      "name": "try_acquire_many_unavailable",
      "signature": "fn # [test] fn try_acquire_many_unavailable () { let s = Semaphore :: new (5) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 4) ; assert_err ! (s . try_acquire (5)) ; s . release (1) ; assert_eq ! (s . available_permits () , 5) ; assert_ok ! (s . try_acquire (5)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; s . release (1) ; assert_eq ! (s . available_permits () , 2) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 15353893420052486097,
      "kind": "Function",
      "name": "poll_acquire_one_zero_permits",
      "signature": "fn # [test] fn poll_acquire_one_zero_permits () { let s = Semaphore :: new (0) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire . poll ()) ; s . release (1) ; assert ! (acquire . is_woken ()) ; assert_ready_ok ! (acquire . poll ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 10261916901396439778,
      "kind": "Function",
      "name": "max_permits_doesnt_panic",
      "signature": "fn # [test] fn max_permits_doesnt_panic () { Semaphore :: new (MAX_PERMITS) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 6212408356303911184,
      "kind": "Function",
      "name": "validates_max_permits",
      "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn validates_max_permits () { Semaphore :: new (MAX_PERMITS + 1) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 3851123109477838272,
      "kind": "Function",
      "name": "close_semaphore_prevents_acquire",
      "signature": "fn # [test] fn close_semaphore_prevents_acquire () { let s = Semaphore :: new (5) ; s . close () ; assert_eq ! (5 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (5 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (5 , s . available_permits ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 18349048933079197103,
      "kind": "Function",
      "name": "close_semaphore_notifies_permit1",
      "signature": "fn # [test] fn close_semaphore_notifies_permit1 () { let s = Semaphore :: new (0) ; let mut acquire = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire . poll ()) ; s . close () ; assert ! (acquire . is_woken ()) ; assert_ready_err ! (acquire . poll ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 10276083040301046613,
      "kind": "Function",
      "name": "close_semaphore_notifies_permit2",
      "signature": "fn # [test] fn close_semaphore_notifies_permit2 () { let s = Semaphore :: new (2) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; let mut acquire3 = task :: spawn (s . acquire (1)) ; let mut acquire4 = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire3 . poll ()) ; assert_pending ! (acquire4 . poll ()) ; s . close () ; assert ! (acquire3 . is_woken ()) ; assert ! (acquire4 . is_woken ()) ; assert_ready_err ! (acquire3 . poll ()) ; assert_ready_err ! (acquire4 . poll ()) ; assert_eq ! (0 , s . available_permits ()) ; s . release (1) ; assert_eq ! (1 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; s . release (1) ; assert_eq ! (2 , s . available_permits ()) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 15239179367311694675,
      "kind": "Function",
      "name": "cancel_acquire_releases_permits",
      "signature": "fn # [test] fn cancel_acquire_releases_permits () { let s = Semaphore :: new (10) ; s . try_acquire (4) . expect (\"uncontended try_acquire succeeds\") ; assert_eq ! (6 , s . available_permits ()) ; let mut acquire = task :: spawn (s . acquire (8)) ; assert_pending ! (acquire . poll ()) ; assert_eq ! (0 , s . available_permits ()) ; drop (acquire) ; assert_eq ! (6 , s . available_permits ()) ; assert_ok ! (s . try_acquire (6)) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 17573044402591574182,
      "kind": "Function",
      "name": "release_permits_at_drop",
      "signature": "fn # [test] fn release_permits_at_drop () { use crate :: sync :: semaphore :: * ; use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let sem = Arc :: new (Semaphore :: new (1)) ; struct ReleaseOnDrop (# [allow (dead_code)] Option < OwnedSemaphorePermit >) ; impl ArcWake for ReleaseOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } let mut fut = Box :: pin (async { let _permit = sem . acquire () . await . unwrap () ; }) ; for _ in 0 ..= 1 { let waker = futures :: task :: waker (Arc :: new (ReleaseOnDrop (sem . clone () . try_acquire_owned () . ok () ,))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 13682284541609376014,
      "kind": "Function",
      "name": "forget_permits_basic",
      "signature": "fn # [test] fn forget_permits_basic () { let s = Semaphore :: new (10) ; assert_eq ! (s . forget_permits (4) , 4) ; assert_eq ! (s . available_permits () , 6) ; assert_eq ! (s . forget_permits (10) , 6) ; assert_eq ! (s . available_permits () , 0) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 9047933634786919854,
      "kind": "Function",
      "name": "update_permits_many_times",
      "signature": "fn # [test] fn update_permits_many_times () { let s = Semaphore :: new (5) ; let mut acquire = task :: spawn (s . acquire (7)) ; assert_pending ! (acquire . poll ()) ; s . release (5) ; assert_ready_ok ! (acquire . poll ()) ; assert_eq ! (s . available_permits () , 3) ; assert_eq ! (s . forget_permits (3) , 3) ; assert_eq ! (s . available_permits () , 0) ; } . sig",
      "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
      "line": 0
    },
    {
      "hash": 15825895908469325286,
      "kind": "Struct",
      "name": "Builder",
      "signature": "struct Builder",
      "file_path": "tokio-util/src/codec/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 3264110669062029814,
      "kind": "Struct",
      "name": "JoinSet",
      "signature": "struct JoinSet",
      "file_path": "tokio/src/task/join_set.rs",
      "line": 0
    },
    {
      "hash": 10832242367550664280,
      "kind": "Struct",
      "name": "LocalState",
      "signature": "struct LocalState",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 8934508545126550921,
      "kind": "Struct",
      "name": "LocalData",
      "signature": "struct LocalData",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 12365161313297499432,
      "kind": "Struct",
      "name": "LocalDataEnterGuard",
      "signature": "struct LocalDataEnterGuard",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 15230823562989329398,
      "kind": "Struct",
      "name": "LocalEnterGuard",
      "signature": "struct LocalEnterGuard",
      "file_path": "tokio/src/task/local.rs",
      "line": 0
    },
    {
      "hash": 3028526416860422256,
      "kind": "Struct",
      "name": "LocalKey",
      "signature": "struct LocalKey",
      "file_path": "tokio/src/task/task_local.rs",
      "line": 0
    },
    {
      "hash": 14606729505894253697,
      "kind": "Struct",
      "name": "AccessError",
      "signature": "struct AccessError",
      "file_path": "tokio/src/task/task_local.rs",
      "line": 0
    },
    {
      "hash": 9519508719714092725,
      "kind": "Function",
      "name": "yield_now",
      "signature": "fn # [doc = \" Yields execution back to the Tokio runtime.\"] # [doc = \"\"] # [doc = \" A task yields by awaiting on `yield_now()`, and may resume when that future\"] # [doc = \" completes (with no output.) The current task will be re-added as a pending\"] # [doc = \" task at the _back_ of the pending queue. Any other pending tasks will be\"] # [doc = \" scheduled. No other waking is required for the task to continue.\"] # [doc = \"\"] # [doc = \" See also the usage example in the [task module](index.html#yield_now).\"] # [doc = \"\"] # [doc = \" ## Non-guarantees\"] # [doc = \"\"] # [doc = \" This function may not yield all the way up to the executor if there are any\"] # [doc = \" special combinators above it in the call stack. For example, if a\"] # [doc = \" [`tokio::select!`] has another branch complete during the same poll as the\"] # [doc = \" `yield_now()`, then the yield is not propagated all the way up to the\"] # [doc = \" runtime.\"] # [doc = \"\"] # [doc = \" It is generally not guaranteed that the runtime behaves like you expect it\"] # [doc = \" to when deciding which task to schedule next after a call to `yield_now()`.\"] # [doc = \" In particular, the runtime may choose to poll the task that just ran\"] # [doc = \" `yield_now()` again immediately without polling any other tasks first. For\"] # [doc = \" example, the runtime will not drive the IO driver between every poll of a\"] # [doc = \" task, and this could result in the runtime polling the current task again\"] # [doc = \" immediately even if there is another task that could make progress if that\"] # [doc = \" other task is waiting for a notification from the IO driver.\"] # [doc = \"\"] # [doc = \" In general, changes to the order in which the runtime polls tasks is not\"] # [doc = \" considered a breaking change, and your program should be correct no matter\"] # [doc = \" which order the runtime polls your tasks in.\"] # [doc = \"\"] # [doc = \" [`tokio::select!`]: macro@crate::select\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub async fn yield_now () { # [doc = \" Yield implementation\"] struct YieldNow { yielded : bool , } impl Future for YieldNow { type Output = () ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < () > { ready ! (crate :: trace :: trace_leaf (cx)) ; if self . yielded { return Poll :: Ready (()) ; } self . yielded = true ; context :: defer (cx . waker ()) ; Poll :: Pending } } YieldNow { yielded : false } . await ; } . sig",
      "file_path": "tokio/src/task/yield_now.rs",
      "line": 0
    },
    {
      "hash": 13567357682825472748,
      "kind": "Function",
      "name": "consume_budget",
      "signature": "fn # [doc = \" Consumes a unit of budget and returns the execution back to the Tokio\"] # [doc = \" runtime *if* the task's coop budget was exhausted.\"] # [doc = \"\"] # [doc = \" The task will only yield if its entire coop budget has been exhausted.\"] # [doc = \" This function can be used in order to insert optional yield points into long\"] # [doc = \" computations that do not use Tokio resources like sockets or semaphores,\"] # [doc = \" without redundantly yielding to the runtime each time.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Make sure that a function which returns a sum of (potentially lots of)\"] # [doc = \" iterated values is cooperative.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" async fn sum_iterator(input: &mut impl std::iter::Iterator<Item=i64>) -> i64 {\"] # [doc = \"     let mut sum: i64 = 0;\"] # [doc = \"     while let Some(i) = input.next() {\"] # [doc = \"         sum += i;\"] # [doc = \"         tokio::task::consume_budget().await\"] # [doc = \"     }\"] # [doc = \"     sum\"] # [doc = \" }\"] # [doc = \" ```\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub async fn consume_budget () { let mut status = std :: task :: Poll :: Pending ; std :: future :: poll_fn (move | cx | { std :: task :: ready ! (crate :: trace :: trace_leaf (cx)) ; if status . is_ready () { return status ; } status = crate :: task :: coop :: poll_proceed (cx) . map (| restore | { restore . made_progress () ; }) ; status }) . await } . sig",
      "file_path": "tokio/src/task/coop/consume_budget.rs",
      "line": 0
    },
    {
      "hash": 12570167144759420880,
      "kind": "Struct",
      "name": "Budget",
      "signature": "struct Budget",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 6355235056528634466,
      "kind": "Struct",
      "name": "BudgetDecrement",
      "signature": "struct BudgetDecrement",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 13398100553439517927,
      "kind": "Function",
      "name": "budget",
      "signature": "fn # [doc = \" Runs the given closure with a cooperative task budget. When the function\"] # [doc = \" returns, the budget is reset to the value prior to calling the function.\"] # [inline (always)] pub (crate) fn budget < R > (f : impl FnOnce () -> R) -> R { with_budget (Budget :: initial () , f) } . sig",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 3319522257091482469,
      "kind": "Function",
      "name": "with_unconstrained",
      "signature": "fn # [doc = \" Runs the given closure with an unconstrained task budget. When the function returns, the budget\"] # [doc = \" is reset to the value prior to calling the function.\"] # [inline (always)] pub (crate) fn with_unconstrained < R > (f : impl FnOnce () -> R) -> R { with_budget (Budget :: unconstrained () , f) } . sig",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 7529687166888124357,
      "kind": "Function",
      "name": "with_budget",
      "signature": "fn # [inline (always)] fn with_budget < R > (budget : Budget , f : impl FnOnce () -> R) -> R { struct ResetGuard { prev : Budget , } impl Drop for ResetGuard { fn drop (& mut self) { let _ = context :: budget (| cell | { cell . set (self . prev) ; }) ; } } # [allow (unused_variables)] let maybe_guard = context :: budget (| cell | { let prev = cell . get () ; cell . set (budget) ; ResetGuard { prev } }) ; f () } . sig",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 6058755581786127217,
      "kind": "Function",
      "name": "has_budget_remaining",
      "signature": "fn # [doc = \" Returns `true` if there is still budget left on the task.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" This example defines a `Timeout` future that requires a given `future` to complete before the\"] # [doc = \" specified duration elapses. If it does, its result is returned; otherwise, an error is returned\"] # [doc = \" and the future is canceled.\"] # [doc = \"\"] # [doc = \" Note that the future could exhaust the budget before we evaluate the timeout. Using `has_budget_remaining`,\"] # [doc = \" we can detect this scenario and ensure the timeout is always checked.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # use std::future::Future;\"] # [doc = \" # use std::pin::{pin, Pin};\"] # [doc = \" # use std::task::{ready, Context, Poll};\"] # [doc = \" # use tokio::task::coop;\"] # [doc = \" # use tokio::time::Sleep;\"] # [doc = \" pub struct Timeout<T> {\"] # [doc = \"     future: T,\"] # [doc = \"     delay: Pin<Box<Sleep>>,\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" impl<T> Future for Timeout<T>\"] # [doc = \" where\"] # [doc = \"     T: Future + Unpin,\"] # [doc = \" {\"] # [doc = \"     type Output = Result<T::Output, ()>;\"] # [doc = \"\"] # [doc = \"     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\"] # [doc = \"         let this = Pin::into_inner(self);\"] # [doc = \"         let future = Pin::new(&mut this.future);\"] # [doc = \"         let delay = Pin::new(&mut this.delay);\"] # [doc = \"\"] # [doc = \"         // check if the future is ready\"] # [doc = \"         let had_budget_before = coop::has_budget_remaining();\"] # [doc = \"         if let Poll::Ready(v) = future.poll(cx) {\"] # [doc = \"             return Poll::Ready(Ok(v));\"] # [doc = \"         }\"] # [doc = \"         let has_budget_now = coop::has_budget_remaining();\"] # [doc = \"\"] # [doc = \"         // evaluate the timeout\"] # [doc = \"         if let (true, false) = (had_budget_before, has_budget_now) {\"] # [doc = \"             // it is the underlying future that exhausted the budget\"] # [doc = \"             ready!(pin!(coop::unconstrained(delay)).poll(cx));\"] # [doc = \"         } else {\"] # [doc = \"             ready!(delay.poll(cx));\"] # [doc = \"         }\"] # [doc = \"         return Poll::Ready(Err(()));\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"```\"] # [inline (always)] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub fn has_budget_remaining () -> bool { context :: budget (| cell | cell . get () . has_remaining ()) . unwrap_or (true) } . sig",
      "file_path": "tokio/src/task/coop/mod.rs",
      "line": 0
    },
    {
      "hash": 1571381262840402140,
      "kind": "Function",
      "name": "unconstrained",
      "signature": "fn # [doc = \" Turn off cooperative scheduling for a future. The future will never be forced to yield by\"] # [doc = \" Tokio. Using this exposes your service to starvation if the unconstrained future never yields\"] # [doc = \" otherwise.\"] # [doc = \"\"] # [doc = \" See also the usage example in the [task module](index.html#unconstrained).\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub fn unconstrained < F > (inner : F) -> Unconstrained < F > { Unconstrained { inner } } . sig",
      "file_path": "tokio/src/task/coop/unconstrained.rs",
      "line": 0
    },
    {
      "hash": 5873623981022757307,
      "kind": "Struct",
      "name": "Error",
      "signature": "struct Error",
      "file_path": "tokio/src/time/error.rs",
      "line": 0
    },
    {
      "hash": 3909859045206798157,
      "kind": "Struct",
      "name": "Elapsed",
      "signature": "struct Elapsed",
      "file_path": "tokio-stream/src/stream_ext/timeout.rs",
      "line": 0
    },
    {
      "hash": 7414181083087627922,
      "kind": "Struct",
      "name": "Instant",
      "signature": "struct Instant",
      "file_path": "tokio/src/time/instant.rs",
      "line": 0
    },
    {
      "hash": 1463533296392268793,
      "kind": "Function",
      "name": "interval",
      "signature": "fn # [doc = \" Creates new [`Interval`] that yields with interval of `period`. The first\"] # [doc = \" tick completes immediately. The default [`MissedTickBehavior`] is\"] # [doc = \" [`Burst`](MissedTickBehavior::Burst), but this can be configured\"] # [doc = \" by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\"] # [doc = \"\"] # [doc = \" An interval will tick indefinitely. At any time, the [`Interval`] value can\"] # [doc = \" be dropped. This cancels the interval.\"] # [doc = \"\"] # [doc = \" This function is equivalent to\"] # [doc = \" [`interval_at(Instant::now(), period)`](interval_at).\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if `period` is zero.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{self, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut interval = time::interval(Duration::from_millis(10));\"] # [doc = \"\"] # [doc = \" interval.tick().await; // ticks immediately\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \"\"] # [doc = \" // approximately 20ms have elapsed.\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" A simple example using `interval` to execute a task every two seconds.\"] # [doc = \"\"] # [doc = \" The difference between `interval` and [`sleep`] is that an [`Interval`]\"] # [doc = \" measures the time since the last tick, which means that [`.tick().await`]\"] # [doc = \" may wait for a shorter time than the duration specified for the interval\"] # [doc = \" if some time has passed between calls to [`.tick().await`].\"] # [doc = \"\"] # [doc = \" If the tick in the example below was replaced with [`sleep`], the task\"] # [doc = \" would only be executed once every three seconds, and not every two\"] # [doc = \" seconds.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time;\"] # [doc = \"\"] # [doc = \" async fn task_that_takes_a_second() {\"] # [doc = \"     println!(\\\"hello\\\");\"] # [doc = \"     time::sleep(time::Duration::from_secs(1)).await\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut interval = time::interval(time::Duration::from_secs(2));\"] # [doc = \" for _i in 0..5 {\"] # [doc = \"     interval.tick().await;\"] # [doc = \"     task_that_takes_a_second().await;\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" [`sleep`]: crate::time::sleep()\"] # [doc = \" [`.tick().await`]: Interval::tick\"] # [track_caller] pub fn interval (period : Duration) -> Interval { assert ! (period > Duration :: new (0 , 0) , \"`period` must be non-zero.\") ; internal_interval_at (Instant :: now () , period , trace :: caller_location ()) } . sig",
      "file_path": "tokio/src/time/interval.rs",
      "line": 0
    },
    {
      "hash": 11589751503404311250,
      "kind": "Function",
      "name": "interval_at",
      "signature": "fn # [doc = \" Creates new [`Interval`] that yields with interval of `period` with the\"] # [doc = \" first tick completing at `start`. The default [`MissedTickBehavior`] is\"] # [doc = \" [`Burst`](MissedTickBehavior::Burst), but this can be configured\"] # [doc = \" by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\"] # [doc = \"\"] # [doc = \" An interval will tick indefinitely. At any time, the [`Interval`] value can\"] # [doc = \" be dropped. This cancels the interval.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if `period` is zero.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{interval_at, Duration, Instant};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let start = Instant::now() + Duration::from_millis(50);\"] # [doc = \" let mut interval = interval_at(start, Duration::from_millis(10));\"] # [doc = \"\"] # [doc = \" interval.tick().await; // ticks after 50ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \"\"] # [doc = \" // approximately 70ms have elapsed.\"] # [doc = \" # }\"] # [doc = \" ```\"] # [track_caller] pub fn interval_at (start : Instant , period : Duration) -> Interval { assert ! (period > Duration :: new (0 , 0) , \"`period` must be non-zero.\") ; internal_interval_at (start , period , trace :: caller_location ()) } . sig",
      "file_path": "tokio/src/time/interval.rs",
      "line": 0
    },
    {
      "hash": 15313977825431611271,
      "kind": "Function",
      "name": "internal_interval_at",
      "signature": "fn # [cfg_attr (not (all (tokio_unstable , feature = \"tracing\")) , allow (unused_variables))] fn internal_interval_at (start : Instant , period : Duration , location : Option < & 'static Location < 'static > > ,) -> Interval { # [cfg (all (tokio_unstable , feature = \"tracing\"))] let resource_span = { let location = location . expect (\"should have location if tracing\") ; tracing :: trace_span ! (parent : None , \"runtime.resource\" , concrete_type = \"Interval\" , kind = \"timer\" , loc . file = location . file () , loc . line = location . line () , loc . col = location . column () ,) } ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let delay = resource_span . in_scope (| | Box :: pin (sleep_until (start))) ; # [cfg (not (all (tokio_unstable , feature = \"tracing\")))] let delay = Box :: pin (sleep_until (start)) ; Interval { delay , period , missed_tick_behavior : MissedTickBehavior :: default () , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span , } } . sig",
      "file_path": "tokio/src/time/interval.rs",
      "line": 0
    },
    {
      "hash": 7102222144293432462,
      "kind": "Struct",
      "name": "Interval",
      "signature": "struct Interval",
      "file_path": "tokio/src/time/interval.rs",
      "line": 0
    },
    {
      "hash": 8996064072232931505,
      "kind": "Function",
      "name": "sleep_until",
      "signature": "fn # [doc = \" Waits until `deadline` is reached.\"] # [doc = \"\"] # [doc = \" No work is performed while awaiting on the sleep future to complete. `Sleep`\"] # [doc = \" operates at millisecond granularity and should not be used for tasks that\"] # [doc = \" require high-resolution timers.\"] # [doc = \"\"] # [doc = \" To run something regularly on a schedule, see [`interval`].\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Canceling a sleep instance is done by dropping the returned future. No additional\"] # [doc = \" cleanup work is required.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Wait 100ms and print \\\"100 ms have elapsed\\\".\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{sleep_until, Instant, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" sleep_until(Instant::now() + Duration::from_millis(100)).await;\"] # [doc = \" println!(\\\"100 ms have elapsed\\\");\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" See the documentation for the [`Sleep`] type for more examples.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Sleep`]: struct@crate::time::Sleep\"] # [doc = \" [`interval`]: crate::time::interval()\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [cfg_attr (docsrs , doc (alias = \"delay_until\"))] # [track_caller] pub fn sleep_until (deadline : Instant) -> Sleep { Sleep :: new_timeout (deadline , trace :: caller_location ()) } . sig",
      "file_path": "tokio/src/time/sleep.rs",
      "line": 0
    },
    {
      "hash": 11422209223261538980,
      "kind": "Function",
      "name": "sleep",
      "signature": "fn # [doc = \" Waits until `duration` has elapsed.\"] # [doc = \"\"] # [doc = \" Equivalent to `sleep_until(Instant::now() + duration)`. An asynchronous\"] # [doc = \" analog to `std::thread::sleep`.\"] # [doc = \"\"] # [doc = \" No work is performed while awaiting on the sleep future to complete. `Sleep`\"] # [doc = \" operates at millisecond granularity and should not be used for tasks that\"] # [doc = \" require high-resolution timers. The implementation is platform specific,\"] # [doc = \" and some platforms (specifically Windows) will provide timers with a\"] # [doc = \" larger resolution than 1 ms.\"] # [doc = \"\"] # [doc = \" To run something regularly on a schedule, see [`interval`].\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Canceling a sleep instance is done by dropping the returned future. No additional\"] # [doc = \" cleanup work is required.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Wait 100ms and print \\\"100 ms have elapsed\\\".\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{sleep, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" sleep(Duration::from_millis(100)).await;\"] # [doc = \" println!(\\\"100 ms have elapsed\\\");\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" See the documentation for the [`Sleep`] type for more examples.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Sleep`]: struct@crate::time::Sleep\"] # [doc = \" [`interval`]: crate::time::interval()\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [cfg_attr (docsrs , doc (alias = \"delay_for\"))] # [cfg_attr (docsrs , doc (alias = \"wait\"))] # [track_caller] pub fn sleep (duration : Duration) -> Sleep { let location = trace :: caller_location () ; match Instant :: now () . checked_add (duration) { Some (deadline) => Sleep :: new_timeout (deadline , location) , None => Sleep :: new_timeout (Instant :: far_future () , location) , } } . sig",
      "file_path": "tokio/src/time/sleep.rs",
      "line": 0
    },
    {
      "hash": 9858109770367776432,
      "kind": "Function",
      "name": "timeout",
      "signature": "fn # [doc = \" Requires a `Future` to complete before the specified duration has elapsed.\"] # [doc = \"\"] # [doc = \" If the future completes before the duration has elapsed, then the completed\"] # [doc = \" value is returned. Otherwise, an error is returned and the future is\"] # [doc = \" canceled.\"] # [doc = \"\"] # [doc = \" Note that the timeout is checked before polling the future, so if the future\"] # [doc = \" does not yield during execution then it is possible for the future to complete\"] # [doc = \" and exceed the timeout _without_ returning an error.\"] # [doc = \"\"] # [doc = \" This function returns a future whose return type is [`Result`]`<T,`[`Elapsed`]`>`, where `T` is the\"] # [doc = \" return type of the provided future.\"] # [doc = \"\"] # [doc = \" If the provided future completes immediately, then the future returned from\"] # [doc = \" this function is guaranteed to complete immediately with an [`Ok`] variant\"] # [doc = \" no matter the provided duration.\"] # [doc = \"\"] # [doc = \" [`Ok`]: std::result::Result::Ok\"] # [doc = \" [`Result`]: std::result::Result\"] # [doc = \" [`Elapsed`]: crate::time::error::Elapsed\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Cancelling a timeout is done by dropping the future. No additional cleanup\"] # [doc = \" or other work is required.\"] # [doc = \"\"] # [doc = \" The original future may be obtained by calling [`Timeout::into_inner`]. This\"] # [doc = \" consumes the `Timeout`.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Create a new `Timeout` set to expire in 10 milliseconds.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio::time::timeout;\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" use std::time::Duration;\"] # [doc = \"\"] # [doc = \" # async fn dox() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \" # tx.send(()).unwrap();\"] # [doc = \"\"] # [doc = \" // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\"] # [doc = \" if let Err(_) = timeout(Duration::from_millis(10), rx).await {\"] # [doc = \"     println!(\\\"did not receive value within 10 ms\\\");\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [track_caller] pub fn timeout < F > (duration : Duration , future : F) -> Timeout < F :: IntoFuture > where F : IntoFuture , { let location = trace :: caller_location () ; let deadline = Instant :: now () . checked_add (duration) ; let delay = match deadline { Some (deadline) => Sleep :: new_timeout (deadline , location) , None => Sleep :: far_future (location) , } ; Timeout :: new_with_delay (future . into_future () , delay) } . sig",
      "file_path": "tokio/src/time/timeout.rs",
      "line": 0
    },
    {
      "hash": 12772868912746233615,
      "kind": "Function",
      "name": "timeout_at",
      "signature": "fn # [doc = \" Requires a `Future` to complete before the specified instant in time.\"] # [doc = \"\"] # [doc = \" If the future completes before the instant is reached, then the completed\"] # [doc = \" value is returned. Otherwise, an error is returned.\"] # [doc = \"\"] # [doc = \" This function returns a future whose return type is [`Result`]`<T,`[`Elapsed`]`>`, where `T` is the\"] # [doc = \" return type of the provided future.\"] # [doc = \"\"] # [doc = \" If the provided future completes immediately, then the future returned from\"] # [doc = \" this function is guaranteed to complete immediately with an [`Ok`] variant\"] # [doc = \" no matter the provided deadline.\"] # [doc = \"\"] # [doc = \" [`Ok`]: std::result::Result::Ok\"] # [doc = \" [`Result`]: std::result::Result\"] # [doc = \" [`Elapsed`]: crate::time::error::Elapsed\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Cancelling a timeout is done by dropping the future. No additional cleanup\"] # [doc = \" or other work is required.\"] # [doc = \"\"] # [doc = \" The original future may be obtained by calling [`Timeout::into_inner`]. This\"] # [doc = \" consumes the `Timeout`.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Create a new `Timeout` set to expire in 10 milliseconds.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio::time::{Instant, timeout_at};\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" use std::time::Duration;\"] # [doc = \"\"] # [doc = \" # async fn dox() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \" # tx.send(()).unwrap();\"] # [doc = \"\"] # [doc = \" // Wrap the future with a `Timeout` set to expire 10 milliseconds into the\"] # [doc = \" // future.\"] # [doc = \" if let Err(_) = timeout_at(Instant::now() + Duration::from_millis(10), rx).await {\"] # [doc = \"     println!(\\\"did not receive value within 10 ms\\\");\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn timeout_at < F > (deadline : Instant , future : F) -> Timeout < F :: IntoFuture > where F : IntoFuture , { let delay = sleep_until (deadline) ; Timeout { value : future . into_future () , delay , } } . sig",
      "file_path": "tokio/src/time/timeout.rs",
      "line": 0
    },
    {
      "hash": 6312284295211599774,
      "kind": "Function",
      "name": "poll_delay",
      "signature": "fn fn poll_delay (had_budget_before : bool , delay : Pin < & mut Sleep > , cx : & mut task :: Context < '_ > ,) -> Poll < Elapsed > { let delay_poll = | | match delay . poll (cx) { Poll :: Ready (()) => Poll :: Ready (Elapsed :: new ()) , Poll :: Pending => Poll :: Pending , } ; let has_budget_now = coop :: has_budget_remaining () ; if let (true , false) = (had_budget_before , has_budget_now) { coop :: with_unconstrained (delay_poll) } else { delay_poll () } } . sig",
      "file_path": "tokio/src/time/timeout.rs",
      "line": 0
    },
    {
      "hash": 933569055724737762,
      "kind": "Function",
      "name": "upgrade",
      "signature": "fn pub (crate) fn upgrade < B : AsRef < [u8] > > (buf : B) -> OwnedBuf { let buf = match unsafe { typeid :: try_transmute :: < B , Vec < u8 > > (buf) } { Ok (vec) => return OwnedBuf :: Vec (vec) , Err (original_buf) => original_buf , } ; let buf = match unsafe { typeid :: try_transmute :: < B , String > (buf) } { Ok (string) => return OwnedBuf :: Vec (string . into_bytes ()) , Err (original_buf) => original_buf , } ; # [cfg (feature = \"io-util\")] let buf = match unsafe { typeid :: try_transmute :: < B , bytes :: Bytes > (buf) } { Ok (bytes) => return OwnedBuf :: Bytes (bytes) , Err (original_buf) => original_buf , } ; OwnedBuf :: Vec (buf . as_ref () . to_owned ()) } . sig",
      "file_path": "tokio/src/util/as_ref.rs",
      "line": 0
    },
    {
      "hash": 10915321467882904144,
      "kind": "Struct",
      "name": "AtomicCell",
      "signature": "struct AtomicCell",
      "file_path": "tokio/src/util/atomic_cell.rs",
      "line": 0
    },
    {
      "hash": 1726342779830273459,
      "kind": "Function",
      "name": "to_raw",
      "signature": "fn fn to_raw < T > (data : Option < Box < T > >) -> * mut T { data . map_or (ptr :: null_mut () , Box :: into_raw) } . sig",
      "file_path": "tokio/src/util/atomic_cell.rs",
      "line": 0
    },
    {
      "hash": 5039736836919456231,
      "kind": "Function",
      "name": "from_raw",
      "signature": "fn fn from_raw < T > (val : * mut T) -> Option < Box < T > > { if val . is_null () { None } else { Some (unsafe { Box :: from_raw (val) }) } } . sig",
      "file_path": "tokio/src/util/atomic_cell.rs",
      "line": 0
    },
    {
      "hash": 8937447363073878536,
      "kind": "Struct",
      "name": "Pack",
      "signature": "struct Pack",
      "file_path": "tokio/src/util/bit.rs",
      "line": 0
    },
    {
      "hash": 10987953263358120218,
      "kind": "Function",
      "name": "mask_for",
      "signature": "fn # [doc = \" Returns a `usize` with the right-most `n` bits set.\"] pub (crate) const fn mask_for (n : u32) -> usize { let shift = 1usize . wrapping_shl (n - 1) ; shift | (shift - 1) } . sig",
      "file_path": "tokio/src/util/bit.rs",
      "line": 0
    },
    {
      "hash": 1861090943332221440,
      "kind": "Function",
      "name": "unpack",
      "signature": "fn # [doc = \" Unpacks a value using a mask & shift.\"] pub (crate) const fn unpack (src : usize , mask : usize , shift : u32) -> usize { (src & mask) >> shift } . sig",
      "file_path": "tokio/src/util/bit.rs",
      "line": 0
    },
    {
      "hash": 18145371526053911964,
      "kind": "Function",
      "name": "check_socket_for_blocking",
      "signature": "fn # [cfg (unix)] # [allow (unused_variables)] # [track_caller] pub (crate) fn check_socket_for_blocking < S : AsFd > (s : & S) -> crate :: io :: Result < () > { # [cfg (not (tokio_allow_from_blocking_fd))] { let sock = socket2 :: SockRef :: from (s) ; debug_assert ! (sock . nonblocking () ?, \"Registering a blocking socket with the tokio runtime is unsupported. \\\n            If you wish to do anyways, please add `--cfg tokio_allow_from_blocking_fd` to your \\\n            RUSTFLAGS. See github.com/tokio-rs/tokio/issues/7172 for details.\") ; } Ok (()) } . sig",
      "file_path": "tokio/src/util/blocking_check.rs",
      "line": 0
    },
    {
      "hash": 16506814110603836655,
      "kind": "Function",
      "name": "check_socket_for_blocking",
      "signature": "fn # [cfg (not (unix))] # [allow (unused_variables)] pub (crate) fn check_socket_for_blocking < S > (s : & S) -> crate :: io :: Result < () > { Ok (()) } . sig",
      "file_path": "tokio/src/util/blocking_check.rs",
      "line": 0
    },
    {
      "hash": 803655828950513455,
      "kind": "Struct",
      "name": "CachePadded",
      "signature": "struct CachePadded",
      "file_path": "tokio/src/util/cacheline.rs",
      "line": 0
    },
    {
      "hash": 8028781251209699750,
      "kind": "Struct",
      "name": "IdleNotifiedSet",
      "signature": "struct IdleNotifiedSet",
      "file_path": "tokio/src/util/idle_notified_set.rs",
      "line": 0
    },
    {
      "hash": 3533852421004534842,
      "kind": "Struct",
      "name": "EntryInOneOfTheLists",
      "signature": "struct EntryInOneOfTheLists",
      "file_path": "tokio/src/util/idle_notified_set.rs",
      "line": 0
    },
    {
      "hash": 2843645076260527188,
      "kind": "Struct",
      "name": "ListsInner",
      "signature": "struct ListsInner",
      "file_path": "tokio/src/util/idle_notified_set.rs",
      "line": 0
    },
    {
      "hash": 18105273027691498854,
      "kind": "Struct",
      "name": "ListEntry",
      "signature": "struct ListEntry",
      "file_path": "tokio/src/util/idle_notified_set.rs",
      "line": 0
    },
    {
      "hash": 9665091449112208429,
      "kind": "Function",
      "name": "move_to_new_list",
      "signature": "fn # [doc = \" # Safety\"] # [doc = \"\"] # [doc = \" The mutex for the entries must be held, and the target list must be such\"] # [doc = \" that setting `my_list` to `Neither` is ok.\"] unsafe fn move_to_new_list < T > (from : & mut LinkedList < T > , to : & mut LinkedList < T >) { while let Some (entry) = from . pop_back () { entry . my_list . with_mut (| ptr | { * ptr = List :: Neither ; }) ; to . push_front (entry) ; } } . sig",
      "file_path": "tokio/src/util/idle_notified_set.rs",
      "line": 0
    },
    {
      "hash": 13392530409491223263,
      "kind": "Struct",
      "name": "LinkedList",
      "signature": "struct LinkedList",
      "file_path": "tokio/src/util/linked_list.rs",
      "line": 0
    },
    {
      "hash": 777262590239786932,
      "kind": "Trait",
      "name": "Link",
      "signature": "trait Link",
      "file_path": "tokio/src/util/linked_list.rs",
      "line": 0
    },
    {
      "hash": 11639200552159283708,
      "kind": "Struct",
      "name": "Pointers",
      "signature": "struct Pointers",
      "file_path": "tokio/src/util/linked_list.rs",
      "line": 0
    },
    {
      "hash": 17232887110242734610,
      "kind": "Struct",
      "name": "PointersInner",
      "signature": "struct PointersInner",
      "file_path": "tokio/src/util/linked_list.rs",
      "line": 0
    },
    {
      "hash": 2530843226065804559,
      "kind": "Struct",
      "name": "SyncNotSend",
      "signature": "struct SyncNotSend",
      "file_path": "tokio/src/util/markers.rs",
      "line": 0
    },
    {
      "hash": 18285851994822427184,
      "kind": "Function",
      "name": "memchr",
      "signature": "fn # [cfg (not (all (unix , feature = \"libc\")))] pub (crate) fn memchr (needle : u8 , haystack : & [u8]) -> Option < usize > { haystack . iter () . position (| val | needle == * val) } . sig",
      "file_path": "tokio/src/util/memchr.rs",
      "line": 0
    },
    {
      "hash": 8107294559076665710,
      "kind": "Function",
      "name": "memchr",
      "signature": "fn # [cfg (all (unix , feature = \"libc\"))] pub (crate) fn memchr (needle : u8 , haystack : & [u8]) -> Option < usize > { let start = haystack . as_ptr () ; let ptr = unsafe { libc :: memchr (start . cast () , needle as _ , haystack . len ()) } ; if ptr . is_null () { None } else { Some (ptr as usize - start as usize) } } . sig",
      "file_path": "tokio/src/util/memchr.rs",
      "line": 0
    },
    {
      "hash": 7787673287485288482,
      "kind": "Struct",
      "name": "MetricAtomicU64",
      "signature": "struct MetricAtomicU64",
      "file_path": "tokio/src/util/metric_atomics.rs",
      "line": 0
    },
    {
      "hash": 735723065646696793,
      "kind": "Struct",
      "name": "MetricAtomicUsize",
      "signature": "struct MetricAtomicUsize",
      "file_path": "tokio/src/util/metric_atomics.rs",
      "line": 0
    },
    {
      "hash": 1561275788732558981,
      "kind": "Function",
      "name": "pin_as_deref_mut",
      "signature": "fn # [doc = \" Copy of [`std::pin::Pin::as_deref_mut`].\"] pub (crate) fn pin_as_deref_mut < P : DerefMut > (ptr : Pin < & mut Pin < P > >) -> Pin < & mut P :: Target > { unsafe { ptr . get_unchecked_mut () } . as_mut () } . sig",
      "file_path": "tokio/src/util/mod.rs",
      "line": 0
    },
    {
      "hash": 16029053580057512291,
      "kind": "Struct",
      "name": "PtrExposeDomain",
      "signature": "struct PtrExposeDomain",
      "file_path": "tokio/src/util/ptr_expose.rs",
      "line": 0
    },
    {
      "hash": 9611895111273462118,
      "kind": "Struct",
      "name": "RngSeed",
      "signature": "struct RngSeed",
      "file_path": "tokio/src/util/rand.rs",
      "line": 0
    },
    {
      "hash": 5640727703173730405,
      "kind": "Struct",
      "name": "FastRand",
      "signature": "struct FastRand",
      "file_path": "tokio/src/util/rand.rs",
      "line": 0
    },
    {
      "hash": 17560168360552328276,
      "kind": "Struct",
      "name": "RcCell",
      "signature": "struct RcCell",
      "file_path": "tokio/src/util/rc_cell.rs",
      "line": 0
    },
    {
      "hash": 17486145203314496531,
      "kind": "Struct",
      "name": "ShardedList",
      "signature": "struct ShardedList",
      "file_path": "tokio/src/util/sharded_list.rs",
      "line": 0
    },
    {
      "hash": 9511322880922071441,
      "kind": "Trait",
      "name": "ShardedListItem",
      "signature": "trait ShardedListItem",
      "file_path": "tokio/src/util/sharded_list.rs",
      "line": 0
    },
    {
      "hash": 13136902118673018938,
      "kind": "Struct",
      "name": "ShardGuard",
      "signature": "struct ShardGuard",
      "file_path": "tokio/src/util/sharded_list.rs",
      "line": 0
    },
    {
      "hash": 6384695876191823486,
      "kind": "Struct",
      "name": "SyncWrapper",
      "signature": "struct SyncWrapper",
      "file_path": "tokio/src/util/sync_wrapper.rs",
      "line": 0
    },
    {
      "hash": 11496917649745377512,
      "kind": "Struct",
      "name": "TryLock",
      "signature": "struct TryLock",
      "file_path": "tokio/src/util/try_lock.rs",
      "line": 0
    },
    {
      "hash": 13427948307676389788,
      "kind": "Struct",
      "name": "LockGuard",
      "signature": "struct LockGuard",
      "file_path": "tokio/src/util/try_lock.rs",
      "line": 0
    },
    {
      "hash": 10595663174159977370,
      "kind": "Function",
      "name": "try_transmute",
      "signature": "fn pub (super) unsafe fn try_transmute < Src , Target : 'static > (x : Src) -> Result < Target , Src > { if nonstatic_typeid :: < Src > () == TypeId :: of :: < Target > () { let x = ManuallyDrop :: new (x) ; Ok (mem :: transmute_copy :: < Src , Target > (& x)) } else { Err (x) } } . sig",
      "file_path": "tokio/src/util/typeid.rs",
      "line": 0
    },
    {
      "hash": 11717594451496614958,
      "kind": "Function",
      "name": "nonstatic_typeid",
      "signature": "fn # [inline (always)] fn nonstatic_typeid < T > () -> TypeId where T : ? Sized , { trait NonStaticAny { fn get_type_id (& self) -> TypeId where Self : 'static ; } impl < T : ? Sized > NonStaticAny for PhantomData < T > { # [inline (always)] fn get_type_id (& self) -> TypeId where Self : 'static , { TypeId :: of :: < T > () } } let phantom_data = PhantomData :: < T > ; NonStaticAny :: get_type_id (unsafe { mem :: transmute :: < & dyn NonStaticAny , & (dyn NonStaticAny + 'static) > (& phantom_data) }) } . sig",
      "file_path": "tokio/src/util/typeid.rs",
      "line": 0
    },
    {
      "hash": 9871640248292113454,
      "kind": "Trait",
      "name": "Wake",
      "signature": "trait Wake",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 454074575859199089,
      "kind": "Function",
      "name": "waker",
      "signature": "fn # [doc = \" Creates a waker from a `Arc<impl Wake>`.\"] pub (crate) fn waker < W : Wake > (wake : Arc < W >) -> Waker { unsafe { Waker :: from_raw (RawWaker :: new (Arc :: into_raw (wake) . cast () , waker_vtable :: < W > () ,)) } } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 1630071486872652880,
      "kind": "Function",
      "name": "waker_vtable",
      "signature": "fn fn waker_vtable < W : Wake > () -> & 'static RawWakerVTable { & RawWakerVTable :: new (clone_arc_raw :: < W > , wake_arc_raw :: < W > , wake_by_ref_arc_raw :: < W > , drop_arc_raw :: < W > ,) } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 14666229420188134855,
      "kind": "Function",
      "name": "clone_arc_raw",
      "signature": "fn unsafe fn clone_arc_raw < T : Wake > (data : * const ()) -> RawWaker { Arc :: < T > :: increment_strong_count (data as * const T) ; RawWaker :: new (data , waker_vtable :: < T > ()) } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 16372787201471417255,
      "kind": "Function",
      "name": "wake_arc_raw",
      "signature": "fn unsafe fn wake_arc_raw < T : Wake > (data : * const ()) { let arc : Arc < T > = Arc :: from_raw (data as * const T) ; Wake :: wake (arc) ; } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 7003400896726753371,
      "kind": "Function",
      "name": "wake_by_ref_arc_raw",
      "signature": "fn unsafe fn wake_by_ref_arc_raw < T : Wake > (data : * const ()) { let arc = ManuallyDrop :: new (Arc :: < T > :: from_raw (data . cast ())) ; Wake :: wake_by_ref (& arc) ; } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 8683155460986918023,
      "kind": "Function",
      "name": "drop_arc_raw",
      "signature": "fn unsafe fn drop_arc_raw < T : Wake > (data : * const ()) { drop (Arc :: < T > :: from_raw (data . cast ())) ; } . sig",
      "file_path": "tokio/src/util/wake.rs",
      "line": 0
    },
    {
      "hash": 4519997891041310405,
      "kind": "Struct",
      "name": "WakeList",
      "signature": "struct WakeList",
      "file_path": "tokio/src/util/wake_list.rs",
      "line": 0
    },
    {
      "hash": 11645825158186976268,
      "kind": "Struct",
      "name": "RngSeedGenerator",
      "signature": "struct RngSeedGenerator",
      "file_path": "tokio/src/util/rand/rt.rs",
      "line": 0
    },
    {
      "hash": 15985323652845327625,
      "kind": "Struct",
      "name": "YY",
      "signature": "struct YY",
      "file_path": "tokio/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 13038125365922303807,
      "kind": "Struct",
      "name": "YN",
      "signature": "struct YN",
      "file_path": "tokio/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 1741035008588028646,
      "kind": "Struct",
      "name": "NN",
      "signature": "struct NN",
      "file_path": "tokio/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 7338411884822868539,
      "kind": "Function",
      "name": "require_send",
      "signature": "fn # [allow (dead_code)] fn require_send < T : Send > (_t : & T) { } . sig",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 4537435276531293775,
      "kind": "Function",
      "name": "require_sync",
      "signature": "fn # [allow (dead_code)] fn require_sync < T : Sync > (_t : & T) { } . sig",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 18396894959049875477,
      "kind": "Function",
      "name": "require_unpin",
      "signature": "fn # [allow (dead_code)] fn require_unpin < T : Unpin > (_t : & T) { } . sig",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 8323496411672812149,
      "kind": "Struct",
      "name": "Invalid",
      "signature": "struct Invalid",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 6396862342586915888,
      "kind": "Trait",
      "name": "AmbiguousIfSend",
      "signature": "trait AmbiguousIfSend",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 13716088718175480779,
      "kind": "Trait",
      "name": "AmbiguousIfSync",
      "signature": "trait AmbiguousIfSync",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 12150229016678334145,
      "kind": "Trait",
      "name": "AmbiguousIfUnpin",
      "signature": "trait AmbiguousIfUnpin",
      "file_path": "tokio-stream/tests/async_send_sync.rs",
      "line": 0
    },
    {
      "hash": 5571613793108379797,
      "kind": "Function",
      "name": "echo_server",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo_server () { const N : usize = 1024 ; let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let msg = \"foo bar baz\" ; let t = thread :: spawn (move | | { let mut s = assert_ok ! (TcpStream :: connect (addr)) ; let t2 = thread :: spawn (move | | { let mut s = assert_ok ! (TcpStream :: connect (addr)) ; let mut b = vec ! [0 ; msg . len () * N] ; assert_ok ! (s . read_exact (& mut b)) ; b }) ; let mut expected = Vec :: < u8 > :: new () ; for _i in 0 .. N { expected . extend (msg . as_bytes ()) ; let res = assert_ok ! (s . write (msg . as_bytes ())) ; assert_eq ! (res , msg . len ()) ; } (expected , t2) }) ; let (mut a , _) = assert_ok ! (srv . accept () . await) ; let (mut b , _) = assert_ok ! (srv . accept () . await) ; let n = assert_ok ! (tokio :: io :: copy (& mut a , & mut b) . await) ; let (expected , t2) = t . join () . unwrap () ; let actual = t2 . join () . unwrap () ; assert ! (expected == actual) ; assert_eq ! (n , msg . len () as u64 * 1024) ; } . sig",
      "file_path": "tokio/tests/buffered.rs",
      "line": 0
    },
    {
      "hash": 2121600807170694726,
      "kind": "Function",
      "name": "coop_budget_udp_send_recv",
      "signature": "fn # [doc = \" Ensure that UDP sockets have functional budgeting\"] # [doc = \"\"] # [doc = \" # Design\"] # [doc = \" Two sockets communicate by spamming packets from one to the other.\"] # [doc = \"\"] # [doc = \" In Linux, this packet will be slammed through the entire network stack and into the receiver's buffer during the\"] # [doc = \" send system call because we are using the loopback interface.\"] # [doc = \" This happens because the softirq chain invoked on send when using the loopback interface covers virtually the\"] # [doc = \" entirety of the lifecycle of a packet within the kernel network stack.\"] # [doc = \"\"] # [doc = \" As a result, neither socket will ever encounter an EWOULDBLOCK, and the only way for these to yield during the loop\"] # [doc = \" is through budgeting.\"] # [doc = \"\"] # [doc = \" A second task runs in the background and increments a counter before yielding, allowing us to know how many times sockets yielded.\"] # [doc = \" Since we are both sending and receiving, that should happen once per 64 packets, because budgets are of size 128\"] # [doc = \" and there are two budget events per packet, a send and a recv.\"] # [tokio :: test] # [cfg_attr (miri , ignore)] async fn coop_budget_udp_send_recv () { const N_ITERATIONS : usize = 1024 ; const PACKET : & [u8] = b\"Hello, world\" ; const PACKET_LEN : usize = 12 ; assert_eq ! (PACKET_LEN , PACKET . len () , \"Defect in test, programmer can't do math\") ; let tx = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let rx = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; tx . connect (rx . local_addr () . unwrap ()) . await . unwrap () ; rx . connect (tx . local_addr () . unwrap ()) . await . unwrap () ; let tracker = Arc :: new (AtomicUsize :: default ()) ; let tracker_clone = Arc :: clone (& tracker) ; tokio :: task :: yield_now () . await ; tokio :: spawn (async move { loop { tracker_clone . fetch_add (1 , Ordering :: SeqCst) ; tokio :: task :: yield_now () . await ; } }) ; for _ in 0 .. N_ITERATIONS { tx . send (PACKET) . await . unwrap () ; let mut tmp = [0 ; PACKET_LEN] ; assert_eq ! (PACKET_LEN , rx . recv (& mut tmp) . await . unwrap () , \"Defect in test case, received unexpected result from socket\") ; assert_eq ! (PACKET , & tmp , \"Defect in test case, received unexpected result from socket\") ; } assert_eq ! (N_ITERATIONS / (BUDGET / 2) , tracker . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/coop_budget.rs",
      "line": 0
    },
    {
      "hash": 8273875926787892256,
      "kind": "Function",
      "name": "test_has_budget_remaining",
      "signature": "fn # [tokio :: test] async fn test_has_budget_remaining () { assert ! (has_budget_remaining ()) ; for _ in 0 .. BUDGET { consume_budget () . await ; } assert ! (! has_budget_remaining ()) ; } . sig",
      "file_path": "tokio/tests/coop_budget.rs",
      "line": 0
    },
    {
      "hash": 7281395190848785454,
      "kind": "Function",
      "name": "a",
      "signature": "fn # [inline (never)] async fn a () { black_box (b ()) . await } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 5410098681905657034,
      "kind": "Function",
      "name": "b",
      "signature": "fn # [inline (never)] async fn b () { black_box (c ()) . await } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 10148264638244669991,
      "kind": "Function",
      "name": "c",
      "signature": "fn # [inline (never)] async fn c () { loop { black_box (tokio :: task :: yield_now ()) . await } } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 17340690591157339589,
      "kind": "Function",
      "name": "current_thread",
      "signature": "fn # [test] fn current_thread () { let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; async fn dump () { let handle = Handle :: current () ; let dump = handle . dump () . await ; let tasks : Vec < _ > = dump . tasks () . iter () . collect () ; assert_eq ! (tasks . len () , 3) ; for task in tasks { let id = task . id () ; let trace = task . trace () . to_string () ; eprintln ! (\"\\n\\n{id}:\\n{trace}\\n\\n\") ; assert ! (trace . contains (\"dump::a\")) ; assert ! (trace . contains (\"dump::b\")) ; assert ! (trace . contains (\"dump::c\")) ; assert ! (trace . contains (\"tokio::task::yield_now\")) ; } } rt . block_on (async { tokio :: select ! (biased ; _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = dump () => { } ,) ; }) ; } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 4695264342628044270,
      "kind": "Function",
      "name": "multi_thread",
      "signature": "fn # [test] fn multi_thread () { let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (3) . build () . unwrap () ; async fn dump () { let handle = Handle :: current () ; let dump = handle . dump () . await ; let tasks : Vec < _ > = dump . tasks () . iter () . collect () ; assert_eq ! (tasks . len () , 3) ; for task in tasks { let id = task . id () ; let trace = task . trace () . to_string () ; eprintln ! (\"\\n\\n{id}:\\n{trace}\\n\\n\") ; assert ! (trace . contains (\"dump::a\")) ; assert ! (trace . contains (\"dump::b\")) ; assert ! (trace . contains (\"dump::c\")) ; assert ! (trace . contains (\"tokio::task::yield_now\")) ; } } rt . block_on (async { tokio :: select ! (biased ; _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = dump () => { } ,) ; }) ; } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 15111860066561074932,
      "kind": "Function",
      "name": "notified_during_tracing",
      "signature": "fn # [doc = \" Regression test for #6051.\"] # [doc = \"\"] # [doc = \" This test ensures that tasks notified outside of a worker will not be\"] # [doc = \" traced, since doing so will un-set their notified bit prior to them being\"] # [doc = \" run and panic.\"] # [test] fn notified_during_tracing () { let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (3) . build () . unwrap () ; let timeout = async { tokio :: time :: sleep (tokio :: time :: Duration :: from_secs (1)) . await ; } ; let timer = rt . spawn (async { loop { tokio :: time :: sleep (tokio :: time :: Duration :: from_nanos (1)) . await ; } }) ; let dump = async { loop { let handle = Handle :: current () ; let _dump = handle . dump () . await ; } } ; rt . block_on (async { tokio :: select ! (biased ; _ = timeout => { } , _ = timer => { } , _ = dump => { } ,) ; }) ; } . sig",
      "file_path": "tokio/tests/dump.rs",
      "line": 0
    },
    {
      "hash": 13063473631416538196,
      "kind": "Function",
      "name": "write_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored () { let (mut client , mut server) = tokio :: io :: duplex (64) ; let ret = client . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; client . flush () . await . unwrap () ; drop (client) ; let mut buf = Vec :: with_capacity (HELLO . len () * 2) ; let bytes_read = server . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (bytes_read , HELLO . len () * 2) ; assert_eq ! (buf , [HELLO , HELLO] . concat ()) ; } . sig",
      "file_path": "tokio/tests/duplex_stream.rs",
      "line": 0
    },
    {
      "hash": 4699546385997682333,
      "kind": "Function",
      "name": "write_vectored_and_shutdown",
      "signature": "fn # [tokio :: test] async fn write_vectored_and_shutdown () { let (mut client , mut server) = tokio :: io :: duplex (64) ; let ret = client . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; client . shutdown () . await . unwrap () ; drop (client) ; let mut buf = Vec :: with_capacity (HELLO . len () * 2) ; let bytes_read = server . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (bytes_read , HELLO . len () * 2) ; assert_eq ! (buf , [HELLO , HELLO] . concat ()) ; } . sig",
      "file_path": "tokio/tests/duplex_stream.rs",
      "line": 0
    },
    {
      "hash": 1234256271652464506,
      "kind": "Function",
      "name": "path_read_write",
      "signature": "fn # [tokio :: test] async fn path_read_write () { let temp = tempdir () ; let dir = temp . path () ; assert_ok ! (fs :: write (dir . join (\"bar\") , b\"bytes\") . await) ; let out = assert_ok ! (fs :: read (dir . join (\"bar\")) . await) ; assert_eq ! (out , b\"bytes\") ; } . sig",
      "file_path": "tokio/tests/fs.rs",
      "line": 0
    },
    {
      "hash": 16122842965727756102,
      "kind": "Function",
      "name": "try_clone_should_preserve_max_buf_size",
      "signature": "fn # [tokio :: test] async fn try_clone_should_preserve_max_buf_size () { let buf_size = 128 ; let temp = tempdir () ; let dir = temp . path () ; let mut file = fs :: File :: create (dir . join (\"try_clone_should_preserve_max_buf_size\")) . await . unwrap () ; file . set_max_buf_size (buf_size) ; let cloned = file . try_clone () . await . unwrap () ; assert_eq ! (cloned . max_buf_size () , buf_size) ; } . sig",
      "file_path": "tokio/tests/fs.rs",
      "line": 0
    },
    {
      "hash": 12504225538672647537,
      "kind": "Function",
      "name": "tempdir",
      "signature": "fn fn tempdir () -> tempfile :: TempDir { tempfile :: tempdir () . unwrap () } . sig",
      "file_path": "tokio/tests/fs.rs",
      "line": 0
    },
    {
      "hash": 15074629346971423872,
      "kind": "Function",
      "name": "canonicalize_root_dir_unix",
      "signature": "fn # [tokio :: test] # [cfg (unix)] async fn canonicalize_root_dir_unix () { assert_eq ! (fs :: canonicalize (\"/.\") . await . unwrap () . to_str () . unwrap () , \"/\") ; } . sig",
      "file_path": "tokio/tests/fs_canonicalize_dir.rs",
      "line": 0
    },
    {
      "hash": 12646730815469381658,
      "kind": "Function",
      "name": "canonicalize_root_dir_windows",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn canonicalize_root_dir_windows () { let dir_path = fs :: canonicalize (\"C:\\\\.\\\\\") . await . unwrap () ; let dir_name = dir_path . to_str () . unwrap () ; assert ! (dir_name . starts_with (\"\\\\\\\\\")) ; assert ! (dir_name . ends_with (\"C:\\\\\")) ; } . sig",
      "file_path": "tokio/tests/fs_canonicalize_dir.rs",
      "line": 0
    },
    {
      "hash": 2111021768657037745,
      "kind": "Function",
      "name": "copy",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn copy () { let dir = tempdir () . unwrap () ; let source_path = dir . path () . join (\"foo.txt\") ; let dest_path = dir . path () . join (\"bar.txt\") ; fs :: write (& source_path , b\"Hello File!\") . await . unwrap () ; fs :: copy (& source_path , & dest_path) . await . unwrap () ; let from = fs :: read (& source_path) . await . unwrap () ; let to = fs :: read (& dest_path) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
      "file_path": "tokio/tests/fs_copy.rs",
      "line": 0
    },
    {
      "hash": 10508103367038099161,
      "kind": "Function",
      "name": "copy_permissions",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn copy_permissions () { let dir = tempdir () . unwrap () ; let from_path = dir . path () . join (\"foo.txt\") ; let to_path = dir . path () . join (\"bar.txt\") ; let from = tokio :: fs :: File :: create (& from_path) . await . unwrap () ; let mut from_perms = from . metadata () . await . unwrap () . permissions () ; from_perms . set_readonly (true) ; from . set_permissions (from_perms . clone ()) . await . unwrap () ; tokio :: fs :: copy (from_path , & to_path) . await . unwrap () ; let to_perms = tokio :: fs :: metadata (to_path) . await . unwrap () . permissions () ; assert_eq ! (from_perms , to_perms) ; } . sig",
      "file_path": "tokio/tests/fs_copy.rs",
      "line": 0
    },
    {
      "hash": 15331245018970164093,
      "kind": "Function",
      "name": "create_dir",
      "signature": "fn # [tokio :: test] async fn create_dir () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: create_dir (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 13552114105359940095,
      "kind": "Function",
      "name": "create_all",
      "signature": "fn # [tokio :: test] async fn create_all () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") . join (\"bar\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: create_dir_all (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 13484619624115296974,
      "kind": "Function",
      "name": "build_dir",
      "signature": "fn # [tokio :: test] async fn build_dir () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") . join (\"bar\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: DirBuilder :: new () . recursive (true) . create (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; assert_err ! (fs :: DirBuilder :: new () . recursive (false) . create (new_dir_2) . await) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 12829772694679932176,
      "kind": "Function",
      "name": "build_dir_mode_read_only",
      "signature": "fn # [tokio :: test] # [cfg (unix)] async fn build_dir_mode_read_only () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"abc\") ; assert_ok ! (fs :: DirBuilder :: new () . recursive (true) . mode (0o444) . create (& new_dir) . await) ; assert ! (fs :: metadata (new_dir) . await . expect (\"metadata result\") . permissions () . readonly ()) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 9390229088703193278,
      "kind": "Function",
      "name": "remove",
      "signature": "fn # [tokio :: test] async fn remove () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") ; let new_dir_2 = new_dir . clone () ; std :: fs :: create_dir (new_dir . clone ()) . unwrap () ; assert_ok ! (fs :: remove_dir (new_dir) . await) ; assert ! (! new_dir_2 . exists ()) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 16719514743930629086,
      "kind": "Function",
      "name": "read_inherent",
      "signature": "fn # [tokio :: test] async fn read_inherent () { let base_dir = tempdir () . unwrap () ; let p = base_dir . path () ; std :: fs :: create_dir (p . join (\"aa\")) . unwrap () ; std :: fs :: create_dir (p . join (\"bb\")) . unwrap () ; std :: fs :: create_dir (p . join (\"cc\")) . unwrap () ; let files = Arc :: new (Mutex :: new (Vec :: new ())) ; let f = files . clone () ; let p = p . to_path_buf () ; let mut entries = fs :: read_dir (p) . await . unwrap () ; while let Some (e) = assert_ok ! (entries . next_entry () . await) { let s = e . file_name () . to_str () . unwrap () . to_string () ; f . lock () . unwrap () . push (s) ; } let mut files = files . lock () . unwrap () ; files . sort () ; assert_eq ! (* files , vec ! [\"aa\" . to_string () , \"bb\" . to_string () , \"cc\" . to_string ()]) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 7779526698240375745,
      "kind": "Function",
      "name": "read_dir_entry_info",
      "signature": "fn # [tokio :: test] async fn read_dir_entry_info () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; let mut dir = fs :: read_dir (temp_dir . path ()) . await . unwrap () ; let first_entry = dir . next_entry () . await . unwrap () . unwrap () ; assert_eq ! (first_entry . path () , file_path) ; assert_eq ! (first_entry . file_name () , \"a.txt\") ; assert ! (first_entry . metadata () . await . unwrap () . is_file ()) ; assert ! (first_entry . file_type () . await . unwrap () . is_file ()) ; } . sig",
      "file_path": "tokio/tests/fs_dir.rs",
      "line": 0
    },
    {
      "hash": 13325897953818296672,
      "kind": "Function",
      "name": "basic_read",
      "signature": "fn # [tokio :: test] async fn basic_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 9552052686326848810,
      "kind": "Function",
      "name": "basic_write",
      "signature": "fn # [tokio :: test] async fn basic_write () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . write_all (HELLO) . await . unwrap () ; file . flush () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 16283624812550336532,
      "kind": "Function",
      "name": "basic_write_and_shutdown",
      "signature": "fn # [tokio :: test] async fn basic_write_and_shutdown () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . write_all (HELLO) . await . unwrap () ; file . shutdown () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 16557649066546836685,
      "kind": "Function",
      "name": "write_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; let ret = file . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; file . flush () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , [HELLO , HELLO] . concat ()) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 1671628954964295181,
      "kind": "Function",
      "name": "write_vectored_and_shutdown",
      "signature": "fn # [tokio :: test] async fn write_vectored_and_shutdown () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; let ret = file . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; file . shutdown () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , [HELLO , HELLO] . concat ()) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 14728205937058128938,
      "kind": "Function",
      "name": "rewind_seek_position",
      "signature": "fn # [tokio :: test] async fn rewind_seek_position () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . seek (SeekFrom :: Current (10)) . await . unwrap () ; file . rewind () . await . unwrap () ; assert_eq ! (file . stream_position () . await . unwrap () , 0) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 6054043429334223599,
      "kind": "Function",
      "name": "coop",
      "signature": "fn # [tokio :: test] async fn coop () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut task = task :: spawn (async { let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; loop { let _ = file . read (& mut buf) . await . unwrap () ; file . seek (std :: io :: SeekFrom :: Start (0)) . await . unwrap () ; } }) ; for _ in 0 .. 1_000 { if task . poll () . is_pending () { return ; } } panic ! (\"did not yield\") ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 2621999039726545476,
      "kind": "Function",
      "name": "write_to_clone",
      "signature": "fn # [tokio :: test] async fn write_to_clone () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut clone = file . try_clone () . await . unwrap () ; clone . write_all (HELLO) . await . unwrap () ; clone . flush () . await . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 1877715552307706987,
      "kind": "Function",
      "name": "write_into_std",
      "signature": "fn # [tokio :: test] async fn write_into_std () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut std_file = file . into_std () . await ; std_file . write_all (HELLO) . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 878179461727888264,
      "kind": "Function",
      "name": "write_into_std_immediate",
      "signature": "fn # [tokio :: test] async fn write_into_std_immediate () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut std_file = file . try_into_std () . unwrap () ; std_file . write_all (HELLO) . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 3060030268825826978,
      "kind": "Function",
      "name": "read_file_from_std",
      "signature": "fn # [tokio :: test] async fn read_file_from_std () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let std_file = std :: fs :: File :: open (tempfile . path ()) . unwrap () ; let mut file = File :: from (std_file) ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 15744373316463265894,
      "kind": "Function",
      "name": "empty_read",
      "signature": "fn # [tokio :: test] async fn empty_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; assert ! (matches ! (file . read (& mut []) . now_or_never () , Some (Ok (0)))) ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 5721959949794748062,
      "kind": "Function",
      "name": "tempfile",
      "signature": "fn fn tempfile () -> NamedTempFile { NamedTempFile :: new () . unwrap () } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 2288823734736163735,
      "kind": "Function",
      "name": "set_max_buf_size_read",
      "signature": "fn # [tokio :: test] async fn set_max_buf_size_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; file . set_max_buf_size (1) ; assert_eq ! (file . read (& mut buf) . await . unwrap () , 1) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 3405590002147954378,
      "kind": "Function",
      "name": "set_max_buf_size_write",
      "signature": "fn # [tokio :: test] async fn set_max_buf_size_write () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . set_max_buf_size (1) ; assert_eq ! (file . write (HELLO) . await . unwrap () , 1) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 7037692654077679882,
      "kind": "Function",
      "name": "file_debug_fmt",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (unix)] async fn file_debug_fmt () { let tempfile = tempfile () ; let file = File :: open (tempfile . path ()) . await . unwrap () ; assert_eq ! (& format ! (\"{file:?}\") [0 .. 33] , \"tokio::fs::File { std: File { fd:\") ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 13396301819648641093,
      "kind": "Function",
      "name": "file_debug_fmt",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn file_debug_fmt () { let tempfile = tempfile () ; let file = File :: open (tempfile . path ()) . await . unwrap () ; assert_eq ! (& format ! (\"{:?}\" , file) [0 .. 37] , \"tokio::fs::File { std: File { handle:\") ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 3050171567094683113,
      "kind": "Function",
      "name": "unix_fd_is_valid",
      "signature": "fn # [tokio :: test] # [cfg (unix)] async fn unix_fd_is_valid () { use std :: os :: unix :: io :: AsRawFd ; let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; assert ! (file . as_raw_fd () as u64 > 0) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 4049435939563335904,
      "kind": "Function",
      "name": "read_file_from_unix_fd",
      "signature": "fn # [tokio :: test] # [cfg (unix)] async fn read_file_from_unix_fd () { use std :: os :: unix :: io :: { FromRawFd , IntoRawFd } ; let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let file1 = File :: open (tempfile . path ()) . await . unwrap () ; let raw_fd = file1 . into_std () . await . into_raw_fd () ; assert ! (raw_fd > 0) ; let mut file2 = unsafe { File :: from_raw_fd (raw_fd) } ; let mut buf = [0 ; 1024] ; let n = file2 . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 11109340262673117368,
      "kind": "Function",
      "name": "windows_handle",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn windows_handle () { use std :: os :: windows :: io :: AsRawHandle ; let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; assert ! (file . as_raw_handle () as u64 > 0) ; } . sig",
      "file_path": "tokio/tests/fs_file.rs",
      "line": 0
    },
    {
      "hash": 17188752641550134912,
      "kind": "Function",
      "name": "test_hard_link",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_hard_link () { let dir = tempdir () . unwrap () ; let src = dir . path () . join (\"src.txt\") ; let dst = dir . path () . join (\"dst.txt\") ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"hello\") . unwrap () ; fs :: hard_link (& src , & dst) . await . unwrap () ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"new-data\") . unwrap () ; let content = fs :: read (& dst) . await . unwrap () ; assert_eq ! (content , b\"new-data\") ; assert ! (fs :: read_link (& dst) . await . is_err ()) ; } . sig",
      "file_path": "tokio/tests/fs_link.rs",
      "line": 0
    },
    {
      "hash": 17567265244934797973,
      "kind": "Function",
      "name": "test_symlink",
      "signature": "fn # [cfg (unix)] # [tokio :: test] async fn test_symlink () { let dir = tempdir () . unwrap () ; let src = dir . path () . join (\"src.txt\") ; let dst = dir . path () . join (\"dst.txt\") ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"hello\") . unwrap () ; fs :: symlink (& src , & dst) . await . unwrap () ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"new-data\") . unwrap () ; let content = fs :: read (& dst) . await . unwrap () ; assert_eq ! (content , b\"new-data\") ; let read = fs :: read_link (dst . clone ()) . await . unwrap () ; assert ! (read == src) ; let symlink_meta = fs :: symlink_metadata (dst . clone ()) . await . unwrap () ; assert ! (symlink_meta . file_type () . is_symlink ()) ; } . sig",
      "file_path": "tokio/tests/fs_link.rs",
      "line": 0
    },
    {
      "hash": 8798551426351959406,
      "kind": "Function",
      "name": "open_with_open_options_and_read",
      "signature": "fn # [tokio :: test] async fn open_with_open_options_and_read () { let mut tempfile = NamedTempFile :: new () . unwrap () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = OpenOptions :: new () . read (true) . open (tempfile) . await . unwrap () ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 13570346201730967493,
      "kind": "Function",
      "name": "open_options_write",
      "signature": "fn # [tokio :: test] async fn open_options_write () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . write (true)) . contains (\"write: true\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 3011826406020092419,
      "kind": "Function",
      "name": "open_options_append",
      "signature": "fn # [tokio :: test] async fn open_options_append () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . append (true)) . contains (\"append: true\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 5197027610984471373,
      "kind": "Function",
      "name": "open_options_truncate",
      "signature": "fn # [tokio :: test] async fn open_options_truncate () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . truncate (true)) . contains (\"truncate: true\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 8203984572317938349,
      "kind": "Function",
      "name": "open_options_create",
      "signature": "fn # [tokio :: test] async fn open_options_create () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . create (true)) . contains (\"create: true\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 15863180201388540496,
      "kind": "Function",
      "name": "open_options_create_new",
      "signature": "fn # [tokio :: test] async fn open_options_create_new () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . create_new (true)) . contains (\"create_new: true\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 13211921510092725443,
      "kind": "Function",
      "name": "open_options_mode",
      "signature": "fn # [tokio :: test] # [cfg (unix)] async fn open_options_mode () { let mode = format ! (\"{:?}\" , OpenOptions :: new () . mode (0o644)) ; assert ! (mode . contains (\"mode: 420\") || mode . contains (\"mode: 0o000644\") , \"mode is: {mode}\") ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 17649538935917607345,
      "kind": "Function",
      "name": "open_options_custom_flags_linux",
      "signature": "fn # [tokio :: test] # [cfg (target_os = \"linux\")] async fn open_options_custom_flags_linux () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (libc :: O_TRUNC)) . contains (\"custom_flags: 512\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 911260374940377368,
      "kind": "Function",
      "name": "open_options_custom_flags_bsd_family",
      "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"freebsd\" , target_os = \"macos\"))] async fn open_options_custom_flags_bsd_family () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (libc :: O_NOFOLLOW)) . contains (\"custom_flags: 256,\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options.rs",
      "line": 0
    },
    {
      "hash": 8872900112018169198,
      "kind": "Function",
      "name": "open_options_windows_access_mode",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_access_mode () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . access_mode (0)) . contains (\"access_mode: Some(0)\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options_windows.rs",
      "line": 0
    },
    {
      "hash": 13973501334907573495,
      "kind": "Function",
      "name": "open_options_windows_share_mode",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_share_mode () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . share_mode (0)) . contains (\"share_mode: 0,\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options_windows.rs",
      "line": 0
    },
    {
      "hash": 14953516441494874025,
      "kind": "Function",
      "name": "open_options_windows_custom_flags",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_custom_flags () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (FileSystem :: FILE_FLAG_DELETE_ON_CLOSE)) . contains (\"custom_flags: 67108864,\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options_windows.rs",
      "line": 0
    },
    {
      "hash": 14407156266531656107,
      "kind": "Function",
      "name": "open_options_windows_attributes",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_attributes () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . attributes (FileSystem :: FILE_ATTRIBUTE_HIDDEN)) . contains (\"attributes: 2,\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options_windows.rs",
      "line": 0
    },
    {
      "hash": 15960446732825496330,
      "kind": "Function",
      "name": "open_options_windows_security_qos_flags",
      "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_security_qos_flags () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . security_qos_flags (FileSystem :: SECURITY_IDENTIFICATION)) . contains (\"security_qos_flags: 1114112,\")) ; } . sig",
      "file_path": "tokio/tests/fs_open_options_windows.rs",
      "line": 0
    },
    {
      "hash": 13511505701347070546,
      "kind": "Function",
      "name": "remove_dir_all",
      "signature": "fn # [tokio :: test] async fn remove_dir_all () { let temp_dir = tempdir () . unwrap () ; let test_dir = temp_dir . path () . join (\"test\") ; fs :: create_dir (& test_dir) . await . unwrap () ; let file_path = test_dir . as_path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; fs :: remove_dir_all (test_dir . as_path ()) . await . unwrap () ; match fs :: try_exists (test_dir) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_dir_all\") , } ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_dir_all\") , } ; } . sig",
      "file_path": "tokio/tests/fs_remove_dir_all.rs",
      "line": 0
    },
    {
      "hash": 5795306707725106792,
      "kind": "Function",
      "name": "remove_file",
      "signature": "fn # [tokio :: test] async fn remove_file () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; assert ! (fs :: try_exists (& file_path) . await . unwrap ()) ; fs :: remove_file (& file_path) . await . unwrap () ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_file\") , } ; } . sig",
      "file_path": "tokio/tests/fs_remove_file.rs",
      "line": 0
    },
    {
      "hash": 8241708668435601393,
      "kind": "Function",
      "name": "rename_file",
      "signature": "fn # [tokio :: test] async fn rename_file () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; assert ! (fs :: try_exists (& file_path) . await . unwrap ()) ; let new_file_path = temp_dir . path () . join (\"b.txt\") ; fs :: rename (& file_path , & new_file_path) . await . unwrap () ; assert ! (fs :: try_exists (new_file_path) . await . unwrap ()) ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after rename\") , } ; } . sig",
      "file_path": "tokio/tests/fs_rename.rs",
      "line": 0
    },
    {
      "hash": 3868159317245808309,
      "kind": "Function",
      "name": "symlink_file_windows",
      "signature": "fn # [tokio :: test] async fn symlink_file_windows () { const FILE_NAME : & str = \"abc.txt\" ; let temp_dir = tempdir () . unwrap () ; let dir1 = temp_dir . path () . join (\"a\") ; fs :: create_dir (& dir1) . await . unwrap () ; let file1 = dir1 . as_path () . join (FILE_NAME) ; fs :: write (& file1 , b\"Hello File!\") . await . unwrap () ; let dir2 = temp_dir . path () . join (\"b\") ; fs :: symlink_dir (& dir1 , & dir2) . await . unwrap () ; fs :: write (& file1 , b\"new data!\") . await . unwrap () ; let file2 = dir2 . as_path () . join (FILE_NAME) ; let from = fs :: read (& file1) . await . unwrap () ; let to = fs :: read (& file2) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
      "file_path": "tokio/tests/fs_symlink_dir_windows.rs",
      "line": 0
    },
    {
      "hash": 15320297112150505327,
      "kind": "Function",
      "name": "symlink_file_windows",
      "signature": "fn # [tokio :: test] async fn symlink_file_windows () { let dir = tempdir () . unwrap () ; let source_path = dir . path () . join (\"foo.txt\") ; let dest_path = dir . path () . join (\"bar.txt\") ; fs :: write (& source_path , b\"Hello File!\") . await . unwrap () ; fs :: symlink_file (& source_path , & dest_path) . await . unwrap () ; fs :: write (& source_path , b\"new data!\") . await . unwrap () ; let from = fs :: read (& source_path) . await . unwrap () ; let to = fs :: read (& dest_path) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
      "file_path": "tokio/tests/fs_symlink_file_windows.rs",
      "line": 0
    },
    {
      "hash": 17947162289822305693,
      "kind": "Function",
      "name": "try_exists",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_exists () { let dir = tempdir () . unwrap () ; let existing_path = dir . path () . join (\"foo.txt\") ; fs :: write (& existing_path , b\"Hello File!\") . await . unwrap () ; let nonexisting_path = dir . path () . join (\"bar.txt\") ; assert ! (fs :: try_exists (existing_path) . await . unwrap ()) ; assert ! (! fs :: try_exists (nonexisting_path) . await . unwrap ()) ; # [cfg (all (unix , not (any (target_os = \"freebsd\" , all (tokio_unstable , feature = \"io-uring\")))))] { use std :: os :: unix :: prelude :: PermissionsExt ; let permission_denied_directory_path = dir . path () . join (\"baz\") ; fs :: create_dir (& permission_denied_directory_path) . await . unwrap () ; let permission_denied_file_path = permission_denied_directory_path . join (\"baz.txt\") ; fs :: write (& permission_denied_file_path , b\"Hello File!\") . await . unwrap () ; let mut perms = tokio :: fs :: metadata (& permission_denied_directory_path) . await . unwrap () . permissions () ; perms . set_mode (0o244) ; fs :: set_permissions (& permission_denied_directory_path , perms) . await . unwrap () ; let permission_denied_result = fs :: try_exists (permission_denied_file_path) . await ; assert_eq ! (permission_denied_result . err () . unwrap () . kind () , std :: io :: ErrorKind :: PermissionDenied) ; } } . sig",
      "file_path": "tokio/tests/fs_try_exists.rs",
      "line": 0
    },
    {
      "hash": 8907192105161461208,
      "kind": "Function",
      "name": "multi_rt",
      "signature": "fn fn multi_rt (n : usize) -> Box < dyn Fn () -> Runtime > { Box :: new (move | | { Builder :: new_multi_thread () . worker_threads (n) . enable_all () . build () . unwrap () }) } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 9687246575210623122,
      "kind": "Function",
      "name": "current_rt",
      "signature": "fn fn current_rt () -> Box < dyn Fn () -> Runtime > { Box :: new (| | Builder :: new_current_thread () . enable_all () . build () . unwrap ()) } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 15164051468884452300,
      "kind": "Function",
      "name": "rt_combinations",
      "signature": "fn fn rt_combinations () -> Vec < Box < dyn Fn () -> Runtime > > { vec ! [current_rt () , multi_rt (1) , multi_rt (2) , multi_rt (8) , multi_rt (64) , multi_rt (256) ,] } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 16718340591033733389,
      "kind": "Function",
      "name": "shutdown_runtime_while_performing_io_uring_ops",
      "signature": "fn # [test] fn shutdown_runtime_while_performing_io_uring_ops () { fn run (rt : Runtime) { let (tx , rx) = mpsc :: channel () ; let (done_tx , done_rx) = mpsc :: channel () ; let (_tmp , path) = create_tmp_files (1) ; rt . spawn (async move { let path = path [0] . clone () ; loop { let path = path . clone () ; tokio :: spawn (async move { let mut opt = OpenOptions :: new () ; opt . read (true) ; opt . open (& path) . await . unwrap () ; }) ; tokio :: task :: yield_now () . await ; } }) ; std :: thread :: spawn (move | | { let rt : Runtime = rx . recv () . unwrap () ; rt . shutdown_timeout (Duration :: from_millis (300)) ; done_tx . send (()) . unwrap () ; }) ; tx . send (rt) . unwrap () ; done_rx . recv () . unwrap () ; } for rt in rt_combinations () { run (rt ()) ; } } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 15605494320866853332,
      "kind": "Function",
      "name": "open_many_files",
      "signature": "fn # [test] fn open_many_files () { fn run (rt : Runtime) { const NUM_FILES : usize = 512 ; let (_tmp_files , paths) : (Vec < NamedTempFile > , Vec < PathBuf >) = create_tmp_files (NUM_FILES) ; rt . block_on (async move { let tracker = TaskTracker :: new () ; for i in 0 .. 10_000 { let path = paths . get (i % NUM_FILES) . unwrap () . clone () ; tracker . spawn (async move { let _file = OpenOptions :: new () . read (true) . open (path) . await . unwrap () ; }) ; } tracker . close () ; tracker . wait () . await ; }) ; } for rt in rt_combinations () { run (rt ()) ; } } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 6998925303146705720,
      "kind": "Function",
      "name": "cancel_op_future",
      "signature": "fn # [tokio :: test] async fn cancel_op_future () { let (_tmp_file , path) : (Vec < NamedTempFile > , Vec < PathBuf >) = create_tmp_files (1) ; let (tx , mut rx) = tokio :: sync :: mpsc :: unbounded_channel () ; let handle = tokio :: spawn (async move { poll_fn (| cx | { let opt = { let mut opt = tokio :: fs :: OpenOptions :: new () ; opt . read (true) ; opt } ; let fut = opt . open (& path [0]) ; let _pending = Box :: pin (fut) . poll_unpin (cx) ; tx . send (()) . unwrap () ; Poll :: < () > :: Pending }) . await ; }) ; rx . recv () . await . unwrap () ; handle . abort () ; let res = handle . await . unwrap_err () ; assert ! (res . is_cancelled ()) ; } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 4449913453239906968,
      "kind": "Function",
      "name": "create_tmp_files",
      "signature": "fn fn create_tmp_files (num_files : usize) -> (Vec < NamedTempFile > , Vec < PathBuf >) { let mut files = Vec :: with_capacity (num_files) ; for _ in 0 .. num_files { let tmp = NamedTempFile :: new () . unwrap () ; let path = tmp . path () . to_path_buf () ; files . push ((tmp , path)) ; } files . into_iter () . unzip () } . sig",
      "file_path": "tokio/tests/fs_uring.rs",
      "line": 0
    },
    {
      "hash": 10583337009396800813,
      "kind": "Function",
      "name": "write",
      "signature": "fn # [tokio :: test] async fn write () { let dir = tempdir () . unwrap () ; let path = dir . path () . join (\"test.txt\") ; fs :: write (& path , \"Hello, World!\") . await . unwrap () ; let contents = fs :: read_to_string (& path) . await . unwrap () ; assert_eq ! (contents , \"Hello, World!\") ; } . sig",
      "file_path": "tokio/tests/fs_write.rs",
      "line": 0
    },
    {
      "hash": 5481645881695620830,
      "kind": "Struct",
      "name": "TestWaker",
      "signature": "struct TestWaker",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 237663724995851557,
      "kind": "Struct",
      "name": "TestWakerInner",
      "signature": "struct TestWakerInner",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 13514667287720432615,
      "kind": "Struct",
      "name": "FileDescriptor",
      "signature": "struct FileDescriptor",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 1996867164517766475,
      "kind": "Function",
      "name": "set_nonblocking",
      "signature": "fn fn set_nonblocking (fd : RawFd) { use nix :: fcntl :: { OFlag , F_GETFL , F_SETFL } ; let flags = nix :: fcntl :: fcntl (fd , F_GETFL) . expect (\"fcntl(F_GETFD)\") ; if flags < 0 { panic ! (\"bad return value from fcntl(F_GETFL): {} ({:?})\" , flags , nix :: Error :: last ()) ; } let flags = OFlag :: from_bits_truncate (flags) | OFlag :: O_NONBLOCK ; nix :: fcntl :: fcntl (fd , F_SETFL (flags)) . expect (\"fcntl(F_SETFD)\") ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 12673547035439800943,
      "kind": "Function",
      "name": "socketpair",
      "signature": "fn fn socketpair () -> (FileDescriptor , FileDescriptor) { use nix :: sys :: socket :: { self , AddressFamily , SockFlag , SockType } ; let (fd_a , fd_b) = socket :: socketpair (AddressFamily :: Unix , SockType :: Stream , None , SockFlag :: empty () ,) . expect (\"socketpair\") ; let fds = (FileDescriptor { fd : fd_a } , FileDescriptor { fd : fd_b }) ; set_nonblocking (fds . 0 . fd . as_raw_fd ()) ; set_nonblocking (fds . 1 . fd . as_raw_fd ()) ; fds } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 5349435796547074616,
      "kind": "Function",
      "name": "drain",
      "signature": "fn fn drain (mut fd : & FileDescriptor , mut amt : usize) { let mut buf = [0u8 ; 512] ; while amt > 0 { match fd . read (& mut buf [..]) { Err (e) if e . kind () == ErrorKind :: WouldBlock => { } Ok (0) => panic ! (\"unexpected EOF\") , Err (e) => panic ! (\"unexpected error: {e:?}\") , Ok (x) => amt -= x , } } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 12027759230822549447,
      "kind": "Function",
      "name": "initially_writable",
      "signature": "fn # [tokio :: test] async fn initially_writable () { let (a , b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let afd_b = AsyncFd :: new (b) . unwrap () ; afd_a . writable () . await . unwrap () . clear_ready () ; afd_b . writable () . await . unwrap () . clear_ready () ; tokio :: select ! { biased ; _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } , _ = afd_a . readable () => panic ! (\"Unexpected readable state\") , _ = afd_b . readable () => panic ! (\"Unexpected readable state\") , } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 7908163483042799755,
      "kind": "Function",
      "name": "reset_readable",
      "signature": "fn # [tokio :: test] async fn reset_readable () { let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; let mut guard = readable . await . unwrap () ; guard . try_io (| _ | afd_a . get_ref () . read (& mut [0])) . unwrap () . unwrap () ; afd_a . readable () . await . unwrap () . retain_ready () ; guard . clear_ready () ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; afd_a . readable () . await . unwrap () . clear_ready () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 1774510807221732455,
      "kind": "Function",
      "name": "reset_writable",
      "signature": "fn # [tokio :: test] async fn reset_writable () { let (a , b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let mut guard = afd_a . writable () . await . unwrap () ; let mut bytes = 0 ; while let Ok (Ok (amt)) = guard . try_io (| _ | afd_a . get_ref () . write (& [0 ; 512] [..])) { bytes += amt ; } let writable = afd_a . writable () ; tokio :: pin ! (writable) ; tokio :: select ! { _ = writable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } drain (& b , bytes) ; let _ = writable . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 7683331555701708095,
      "kind": "Struct",
      "name": "ArcFd",
      "signature": "struct ArcFd",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 16042778696112988015,
      "kind": "Function",
      "name": "drop_closes",
      "signature": "fn # [tokio :: test] async fn drop_closes () { let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; std :: mem :: drop (afd_a) ; assert_eq ! (0 , b . read (& mut [0]) . unwrap ()) ; let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let _a : FileDescriptor = afd_a . into_inner () ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; let (a , mut b) = socketpair () ; let arc_fd = Arc :: new (a) ; let afd_a = AsyncFd :: new (ArcFd (arc_fd . clone ())) . unwrap () ; std :: mem :: drop (afd_a) ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; std :: mem :: drop (arc_fd) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 16390732708624651148,
      "kind": "Function",
      "name": "reregister",
      "signature": "fn # [tokio :: test] async fn reregister () { let (a , _b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let a = afd_a . into_inner () ; AsyncFd :: new (a) . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 13614163353312697834,
      "kind": "Function",
      "name": "guard_try_io",
      "signature": "fn # [tokio :: test] async fn guard_try_io () { let (a , mut b) = socketpair () ; b . write_all (b\"0\") . unwrap () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let mut guard = afd_a . readable () . await . unwrap () ; afd_a . get_ref () . read_exact (& mut [0]) . unwrap () ; let _ = guard . try_io (| _ | Ok (())) ; let _ = afd_a . readable () . await . unwrap () ; let _ = guard . try_io (| _ | io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ())) ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; let _ = readable . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 4035933877435786316,
      "kind": "Function",
      "name": "try_io_readable",
      "signature": "fn # [tokio :: test] async fn try_io_readable () { let (a , mut b) = socketpair () ; let mut afd_a = AsyncFd :: new (a) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io_mut (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket should not be readable\") ; } b . write_all (& [0]) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (called , \"closure should have been called, since socket should have data available to read\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ()) }) ; assert ! (called , \"closure should have been called, since socket should have data available to read\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket readable state should have been cleared\") ; } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 13728384492538985436,
      "kind": "Function",
      "name": "try_io_writable",
      "signature": "fn # [tokio :: test] async fn try_io_writable () { let (a , _b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; Ok (()) }) ; assert ! (called , \"closure should have been called, since socket should still be marked as writable\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ()) }) ; assert ! (called , \"closure should have been called, since socket should still be marked as writable\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket writable state should have been cleared\") ; } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 2312126476043196915,
      "kind": "Function",
      "name": "multiple_waiters",
      "signature": "fn # [tokio :: test] async fn multiple_waiters () { let (a , mut b) = socketpair () ; let afd_a = Arc :: new (AsyncFd :: new (a) . unwrap ()) ; let barrier = Arc :: new (tokio :: sync :: Barrier :: new (11)) ; let mut tasks = Vec :: new () ; for _ in 0 .. 10 { let afd_a = afd_a . clone () ; let barrier = barrier . clone () ; let f = async move { let notify_barrier = async { barrier . wait () . await ; futures :: future :: pending :: < () > () . await ; } ; tokio :: select ! { biased ; guard = afd_a . readable () => { tokio :: task :: yield_now () . await ; guard . unwrap () . clear_ready () } , _ = notify_barrier => unreachable ! () , } std :: mem :: drop (afd_a) ; } ; tasks . push (tokio :: spawn (f)) ; } let mut all_tasks = futures :: future :: try_join_all (tasks) ; tokio :: select ! { r = std :: pin :: Pin :: new (& mut all_tasks) => { r . unwrap () ; panic ! (\"Tasks exited unexpectedly\") } , _ = barrier . wait () => { } } b . write_all (b\"0\") . unwrap () ; all_tasks . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 3581829599867414393,
      "kind": "Function",
      "name": "poll_fns",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_fns () { let (a , b) = socketpair () ; let afd_a = Arc :: new (AsyncFd :: new (a) . unwrap ()) ; let afd_b = Arc :: new (AsyncFd :: new (b) . unwrap ()) ; let mut bytes = 0 ; while let Ok (amt) = afd_a . get_ref () . write (& [0 ; 512]) { bytes += amt ; } let waker = TestWaker :: new () ; assert_pending ! (afd_a . as_ref () . poll_read_ready (& mut waker . context ())) ; let afd_a_2 = afd_a . clone () ; let r_barrier = Arc :: new (tokio :: sync :: Barrier :: new (2)) ; let barrier_clone = r_barrier . clone () ; let read_fut = tokio :: spawn (async move { assert_pending ! (poll ! (std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_read_ready (cx)))) ; barrier_clone . wait () . await ; let _ = std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_read_ready (cx)) . await ; }) ; let afd_a_2 = afd_a . clone () ; let w_barrier = Arc :: new (tokio :: sync :: Barrier :: new (2)) ; let barrier_clone = w_barrier . clone () ; let mut write_fut = tokio :: spawn (async move { assert_pending ! (poll ! (std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_write_ready (cx)))) ; barrier_clone . wait () . await ; let _ = std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_write_ready (cx)) . await ; }) ; r_barrier . wait () . await ; w_barrier . wait () . await ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = & mut readable => unreachable ! () , _ = tokio :: task :: yield_now () => { } } afd_b . get_ref () . write_all (b\"0\") . unwrap () ; let _ = tokio :: join ! (readable , read_fut) ; assert ! (! waker . awoken ()) ; tokio :: select ! { _ = & mut write_fut => unreachable ! () , _ = tokio :: time :: sleep (Duration :: from_millis (5)) => { } } drain (afd_b . get_ref () , bytes) ; let _ = write_fut . await ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 5183348754431870253,
      "kind": "Function",
      "name": "assert_pending",
      "signature": "fn fn assert_pending < T : std :: fmt :: Debug , F : Future < Output = T > > (f : F) -> std :: pin :: Pin < Box < F > > { let mut pinned = Box :: pin (f) ; assert_pending ! (pinned . as_mut () . poll (& mut Context :: from_waker (futures :: task :: noop_waker_ref ()))) ; pinned } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 15015799316728733513,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 11342329011746243226,
      "kind": "Function",
      "name": "driver_shutdown_wakes_currently_pending",
      "signature": "fn # [test] fn driver_shutdown_wakes_currently_pending () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let readable = assert_pending (afd_a . readable ()) ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (readable)) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 10591168638984008118,
      "kind": "Function",
      "name": "driver_shutdown_wakes_future_pending",
      "signature": "fn # [test] fn driver_shutdown_wakes_future_pending () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 14305400743398756428,
      "kind": "Function",
      "name": "driver_shutdown_wakes_pending_race",
      "signature": "fn # [test] fn driver_shutdown_wakes_pending_race () { for _ in 0 .. 100 { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let _ = std :: thread :: spawn (move | | std :: mem :: drop (rt)) ; let _ = futures :: executor :: block_on (afd_a . readable ()) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 16404525548588834144,
      "kind": "Function",
      "name": "poll_readable",
      "signature": "fn async fn poll_readable < T : AsRawFd > (fd : & AsyncFd < T >) -> std :: io :: Result < AsyncFdReadyGuard < '_ , T > > { std :: future :: poll_fn (| cx | fd . poll_read_ready (cx)) . await } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 14435614210917244200,
      "kind": "Function",
      "name": "poll_writable",
      "signature": "fn async fn poll_writable < T : AsRawFd > (fd : & AsyncFd < T >) -> std :: io :: Result < AsyncFdReadyGuard < '_ , T > > { std :: future :: poll_fn (| cx | fd . poll_write_ready (cx)) . await } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 3876773222126273627,
      "kind": "Function",
      "name": "driver_shutdown_wakes_currently_pending_polls",
      "signature": "fn # [test] fn driver_shutdown_wakes_currently_pending_polls () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; while afd_a . get_ref () . write (& [0 ; 512]) . is_ok () { } let readable = assert_pending (poll_readable (& afd_a)) ; let writable = assert_pending (poll_writable (& afd_a)) ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (readable)) ; assert_err ! (futures :: executor :: block_on (writable)) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 562847693614946201,
      "kind": "Function",
      "name": "driver_shutdown_wakes_poll",
      "signature": "fn # [test] fn driver_shutdown_wakes_poll () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (poll_readable (& afd_a))) ; assert_err ! (futures :: executor :: block_on (poll_writable (& afd_a))) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 6045990253673239580,
      "kind": "Function",
      "name": "driver_shutdown_then_clear_readiness",
      "signature": "fn # [test] fn driver_shutdown_then_clear_readiness () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let mut write_ready = rt . block_on (afd_a . writable ()) . unwrap () ; std :: mem :: drop (rt) ; write_ready . clear_ready () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 3963632961322313999,
      "kind": "Function",
      "name": "driver_shutdown_wakes_poll_race",
      "signature": "fn # [test] fn driver_shutdown_wakes_poll_race () { for _ in 0 .. 100 { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; while afd_a . get_ref () . write (& [0 ; 512]) . is_ok () { } let _ = std :: thread :: spawn (move | | std :: mem :: drop (rt)) ; assert_err ! (futures :: executor :: block_on (poll_readable (& afd_a))) ; assert_err ! (futures :: executor :: block_on (poll_writable (& afd_a))) ; } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 3471824063681418992,
      "kind": "Function",
      "name": "priority_event_on_oob_data",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] async fn priority_event_on_oob_data () { use std :: net :: SocketAddr ; use tokio :: io :: Interest ; let addr : SocketAddr = \"127.0.0.1:0\" . parse () . unwrap () ; let listener = std :: net :: TcpListener :: bind (addr) . unwrap () ; let addr = listener . local_addr () . unwrap () ; let client = std :: net :: TcpStream :: connect (addr) . unwrap () ; let client = AsyncFd :: with_interest (client , Interest :: PRIORITY) . unwrap () ; let (stream , _) = listener . accept () . unwrap () ; send_oob_data (& stream , b\"hello\") . unwrap () ; let _ = client . ready (Interest :: PRIORITY) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 17388137114185551112,
      "kind": "Function",
      "name": "send_oob_data",
      "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] fn send_oob_data < S : AsRawFd > (stream : & S , data : & [u8]) -> io :: Result < usize > { unsafe { let res = libc :: send (stream . as_raw_fd () , data . as_ptr () . cast () , data . len () , libc :: MSG_OOB ,) ; if res == - 1 { Err (io :: Error :: last_os_error ()) } else { Ok (res as usize) } } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 6017146677253878161,
      "kind": "Function",
      "name": "clear_ready_matching_clears_ready",
      "signature": "fn # [tokio :: test] async fn clear_ready_matching_clears_ready () { use tokio :: io :: { Interest , Ready } ; let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; b . write_all (b\"0\") . unwrap () ; let mut guard = afd_a . ready (Interest :: READABLE | Interest :: WRITABLE) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: READABLE | Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: READABLE) ; assert_eq ! (guard . ready () , Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: WRITABLE) ; assert_eq ! (guard . ready () , Ready :: EMPTY) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 6511032789604781109,
      "kind": "Function",
      "name": "clear_ready_matching_clears_ready_mut",
      "signature": "fn # [tokio :: test] async fn clear_ready_matching_clears_ready_mut () { use tokio :: io :: { Interest , Ready } ; let (a , mut b) = socketpair () ; let mut afd_a = AsyncFd :: new (a) . unwrap () ; b . write_all (b\"0\") . unwrap () ; let mut guard = afd_a . ready_mut (Interest :: READABLE | Interest :: WRITABLE) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: READABLE | Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: READABLE) ; assert_eq ! (guard . ready () , Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: WRITABLE) ; assert_eq ! (guard . ready () , Ready :: EMPTY) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 143990568765105356,
      "kind": "Function",
      "name": "await_error_readiness_timestamping",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (target_os = \"linux\")] async fn await_error_readiness_timestamping () { use std :: net :: { Ipv4Addr , SocketAddr } ; use tokio :: io :: { Interest , Ready } ; let address_a = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let address_b = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let socket = std :: net :: UdpSocket :: bind (address_a) . unwrap () ; socket . set_nonblocking (true) . unwrap () ; configure_timestamping_socket (& socket) . unwrap () ; socket . connect (address_b) . unwrap () ; let fd = AsyncFd :: new (socket) . unwrap () ; tokio :: select ! { _ = fd . ready (Interest :: ERROR) => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } let buf = b\"hello there\" ; fd . get_ref () . send (buf) . unwrap () ; let guard = fd . ready (Interest :: ERROR) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: ERROR) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 320256185506357641,
      "kind": "Function",
      "name": "configure_timestamping_socket",
      "signature": "fn # [cfg (target_os = \"linux\")] fn configure_timestamping_socket (udp_socket : & std :: net :: UdpSocket) -> std :: io :: Result < libc :: c_int > { let options = libc :: SOF_TIMESTAMPING_SOFTWARE | libc :: SOF_TIMESTAMPING_TX_SOFTWARE ; let res = unsafe { libc :: setsockopt (udp_socket . as_raw_fd () , libc :: SOL_SOCKET , libc :: SO_TIMESTAMP , & options as * const _ as * const libc :: c_void , std :: mem :: size_of_val (& options) as libc :: socklen_t ,) } ; if res == - 1 { Err (std :: io :: Error :: last_os_error ()) } else { Ok (res) } } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 7472825460002516788,
      "kind": "Function",
      "name": "await_error_readiness_invalid_address",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (target_os = \"linux\")] async fn await_error_readiness_invalid_address () { use std :: net :: { Ipv4Addr , SocketAddr } ; use tokio :: io :: { Interest , Ready } ; let socket_addr = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let socket = std :: net :: UdpSocket :: bind (socket_addr) . unwrap () ; let socket_fd = socket . as_raw_fd () ; let recv_err : libc :: c_int = 1 ; unsafe { let res = libc :: setsockopt (socket . as_raw_fd () , libc :: SOL_IP , libc :: IP_RECVERR , & recv_err as * const _ as * const libc :: c_void , std :: mem :: size_of_val (& recv_err) as libc :: socklen_t ,) ; if res == - 1 { panic ! (\"{:?}\" , std :: io :: Error :: last_os_error ()) ; } } tokio :: spawn (async move { let mut dest_addr = unsafe { std :: mem :: MaybeUninit :: < libc :: sockaddr_in > :: zeroed () . assume_init () } ; dest_addr . sin_family = libc :: AF_INET as _ ; dest_addr . sin_port = 512u16 . to_be () ; let message = \"Hello, Socket!\" ; let mut iov = libc :: iovec { iov_base : message . as_ptr () as * mut libc :: c_void , iov_len : message . len () , } ; let dest_sockaddr : * const libc :: sockaddr = & dest_addr as * const _ as * const libc :: sockaddr ; let dest_addrlen : libc :: socklen_t = std :: mem :: size_of_val (& dest_addr) as libc :: socklen_t ; let mut msg : libc :: msghdr = unsafe { std :: mem :: MaybeUninit :: zeroed () . assume_init () } ; msg . msg_name = dest_sockaddr as * mut libc :: c_void ; msg . msg_namelen = dest_addrlen ; msg . msg_iov = & mut iov ; msg . msg_iovlen = 1 ; if unsafe { libc :: sendmsg (socket_fd , & msg , 0) } == - 1 { panic ! (\"{:?}\" , std :: io :: Error :: last_os_error ()) } }) ; let fd = AsyncFd :: new (socket) . unwrap () ; let guard = fd . ready (Interest :: ERROR) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: ERROR) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 15751676786826055322,
      "kind": "Struct",
      "name": "InvalidSource",
      "signature": "struct InvalidSource",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 11466804656659673777,
      "kind": "Function",
      "name": "try_new",
      "signature": "fn # [tokio :: test] async fn try_new () { let original = Arc :: new (InvalidSource) ; let error = AsyncFd :: try_new (original . clone ()) . unwrap_err () ; let (returned , _cause) = error . into_parts () ; assert ! (Arc :: ptr_eq (& original , & returned)) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 14548212911268224037,
      "kind": "Function",
      "name": "try_with_interest",
      "signature": "fn # [tokio :: test] async fn try_with_interest () { let original = Arc :: new (InvalidSource) ; let error = AsyncFd :: try_with_interest (original . clone () , Interest :: READABLE) . unwrap_err () ; let (returned , _cause) = error . into_parts () ; assert ! (Arc :: ptr_eq (& original , & returned)) ; } . sig",
      "file_path": "tokio/tests/io_async_fd.rs",
      "line": 0
    },
    {
      "hash": 4139302017696859116,
      "kind": "Function",
      "name": "assert_obj_safe",
      "signature": "fn # [test] fn assert_obj_safe () { fn _assert < T > () { } _assert :: < Box < dyn AsyncRead > > () ; } . sig",
      "file_path": "tokio/tests/io_async_read.rs",
      "line": 0
    },
    {
      "hash": 15783196389732907094,
      "kind": "Struct",
      "name": "MaybePending",
      "signature": "struct MaybePending",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 9402513853564668093,
      "kind": "Function",
      "name": "test_buffered_reader",
      "signature": "fn # [tokio :: test] async fn test_buffered_reader () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , inner) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 3) ; assert_eq ! (buf , [5 , 6 , 7]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 2) ; assert_eq ! (buf , [0 , 1]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [2]) ; assert_eq ! (reader . buffer () , [3]) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [3 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [4 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 9627062869204727432,
      "kind": "Function",
      "name": "test_buffered_reader_seek",
      "signature": "fn # [tokio :: test] async fn test_buffered_reader_seek () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , Cursor :: new (inner)) ; assert_eq ! (reader . seek (SeekFrom :: Start (3)) . await . unwrap () , 3) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . is_err ()) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert_eq ! (reader . seek (SeekFrom :: Current (1)) . await . unwrap () , 4) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [1 , 2] [..]) ; Pin :: new (& mut reader) . consume (1) ; assert_eq ! (reader . seek (SeekFrom :: Current (- 2)) . await . unwrap () , 3) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 92454708564085324,
      "kind": "Function",
      "name": "test_buffered_reader_seek_underflow",
      "signature": "fn # [tokio :: test] async fn test_buffered_reader_seek_underflow () { struct PositionReader { pos : u64 , } impl AsyncRead for PositionReader { fn poll_read (mut self : Pin < & mut Self > , _ : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { let b = buf . initialize_unfilled () ; let len = b . len () ; for x in b { * x = self . pos as u8 ; self . pos = self . pos . wrapping_add (1) ; } buf . advance (len) ; Poll :: Ready (Ok (())) } } impl AsyncSeek for PositionReader { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { match pos { SeekFrom :: Start (n) => { self . pos = n ; } SeekFrom :: Current (n) => { self . pos = self . pos . wrapping_add (n as u64) ; } SeekFrom :: End (n) => { self . pos = u64 :: MAX . wrapping_add (n as u64) ; } } Ok (()) } fn poll_complete (self : Pin < & mut Self > , _ : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { Poll :: Ready (Ok (self . pos)) } } let mut reader = BufReader :: with_capacity (5 , PositionReader { pos : 0 }) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1 , 2 , 3 , 4] [..]) ; assert_eq ! (reader . seek (SeekFrom :: End (- 5)) . await . unwrap () , u64 :: MAX - 5) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () . len () , 5) ; let expected = 9_223_372_036_854_775_802 ; assert_eq ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . unwrap () , expected) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () . len () , 5) ; assert_eq ! (reader . seek (SeekFrom :: Current (0)) . await . unwrap () , expected) ; assert_eq ! (reader . get_ref () . pos , expected) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 13494491099911126969,
      "kind": "Function",
      "name": "test_short_reads",
      "signature": "fn # [tokio :: test] async fn test_short_reads () { # [doc = \" A dummy reader intended at testing short-reads propagation.\"] struct ShortReader { lengths : Vec < usize > , } impl AsyncRead for ShortReader { fn poll_read (mut self : Pin < & mut Self > , _ : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { if ! self . lengths . is_empty () { buf . advance (self . lengths . remove (0)) ; } Poll :: Ready (Ok (())) } } let inner = ShortReader { lengths : vec ! [0 , 1 , 2 , 0 , 1 , 0] , } ; let mut reader = BufReader :: new (inner) ; let mut buf = [0 , 0] ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 1) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 2) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 1) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 17215980740824424801,
      "kind": "Function",
      "name": "maybe_pending",
      "signature": "fn # [tokio :: test] async fn maybe_pending () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , MaybePending :: new (inner)) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 3) ; assert_eq ! (buf , [5 , 6 , 7]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 2) ; assert_eq ! (buf , [0 , 1]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [2]) ; assert_eq ! (reader . buffer () , [3]) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [3 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [4 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 5961981987068326235,
      "kind": "Function",
      "name": "maybe_pending_buf_read",
      "signature": "fn # [tokio :: test] async fn maybe_pending_buf_read () { let inner = MaybePending :: new (& [0 , 1 , 2 , 3 , 1 , 0]) ; let mut reader = BufReader :: with_capacity (2 , inner) ; let mut v = Vec :: new () ; reader . read_until (3 , & mut v) . await . unwrap () ; assert_eq ! (v , [0 , 1 , 2 , 3]) ; v . clear () ; reader . read_until (1 , & mut v) . await . unwrap () ; assert_eq ! (v , [1]) ; v . clear () ; reader . read_until (8 , & mut v) . await . unwrap () ; assert_eq ! (v , [0]) ; v . clear () ; reader . read_until (9 , & mut v) . await . unwrap () ; assert_eq ! (v , []) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 4083081864118138912,
      "kind": "Function",
      "name": "maybe_pending_seek",
      "signature": "fn # [tokio :: test] async fn maybe_pending_seek () { struct MaybePendingSeek < 'a > { inner : Cursor < & 'a [u8] > , ready : bool , seek_res : Option < io :: Result < () > > , } impl < 'a > MaybePendingSeek < 'a > { fn new (inner : & 'a [u8]) -> Self { Self { inner : Cursor :: new (inner) , ready : true , seek_res : None , } } } impl AsyncRead for MaybePendingSeek < '_ > { fn poll_read (mut self : Pin < & mut Self > , cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_read (cx , buf) } } impl AsyncBufRead for MaybePendingSeek < '_ > { fn poll_fill_buf (mut self : Pin < & mut Self > , cx : & mut Context < '_ > ,) -> Poll < io :: Result < & [u8] > > { let this : * mut Self = & mut * self as * mut _ ; Pin :: new (& mut unsafe { & mut * this } . inner) . poll_fill_buf (cx) } fn consume (mut self : Pin < & mut Self > , amt : usize) { Pin :: new (& mut self . inner) . consume (amt) } } impl AsyncSeek for MaybePendingSeek < '_ > { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { self . seek_res = Some (Pin :: new (& mut self . inner) . start_seek (pos)) ; Ok (()) } fn poll_complete (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { if self . ready { self . ready = false ; self . seek_res . take () . unwrap_or (Ok (())) ? ; Pin :: new (& mut self . inner) . poll_complete (cx) } else { self . ready = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } } let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , MaybePendingSeek :: new (inner)) ; assert_eq ! (reader . seek (SeekFrom :: Current (3)) . await . unwrap () , 3) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . is_err ()) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert_eq ! (reader . seek (SeekFrom :: Current (1)) . await . unwrap () , 4) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [1 , 2] [..]) ; Pin :: new (& mut reader) . consume (1) ; assert_eq ! (reader . seek (SeekFrom :: Current (- 2)) . await . unwrap () , 3) ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 92018033509919828,
      "kind": "Function",
      "name": "test_fill_buf_wrapper",
      "signature": "fn # [tokio :: test] async fn test_fill_buf_wrapper () { let (mut write , read) = tokio :: io :: duplex (16) ; let mut read = BufReader :: new (read) ; write . write_all (b\"hello world\") . await . unwrap () ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"hello world\") ; read . consume (b\"hello \" . len ()) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"world\") ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"world\") ; read . consume (b\"world\" . len ()) ; let mut fill = spawn (read . fill_buf ()) ; assert_pending ! (fill . poll ()) ; write . write_all (b\"foo bar\") . await . unwrap () ; assert_eq ! (assert_ready ! (fill . poll ()) . unwrap () , b\"foo bar\") ; drop (fill) ; drop (write) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"foo bar\") ; read . consume (b\"foo bar\" . len ()) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"\") ; } . sig",
      "file_path": "tokio/tests/io_buf_reader.rs",
      "line": 0
    },
    {
      "hash": 13382128731813455078,
      "kind": "Function",
      "name": "write_vectored",
      "signature": "fn async fn write_vectored < W > (writer : & mut W , bufs : & [IoSlice < '_ >]) -> io :: Result < usize > where W : AsyncWrite + Unpin , { let mut writer = Pin :: new (writer) ; future :: poll_fn (| cx | writer . as_mut () . poll_write_vectored (cx , bufs)) . await } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 294289194624451602,
      "kind": "Function",
      "name": "buf_writer",
      "signature": "fn # [tokio :: test] async fn buf_writer () { let mut writer = BufWriter :: with_capacity (2 , Vec :: new ()) ; assert_eq ! (writer . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; assert_eq ! (writer . write (& [2]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2]) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; assert_eq ! (writer . write (& [3]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2 , 3]) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [4]) . await . unwrap () , 1) ; assert_eq ! (writer . write (& [5]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [4 , 5]) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [6]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [6]) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5]) ; assert_eq ! (writer . write (& [7 , 8]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8]) ; assert_eq ! (writer . write (& [9 , 10 , 11]) . await . unwrap () , 3) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 16516673530421042183,
      "kind": "Function",
      "name": "buf_writer_inner_flushes",
      "signature": "fn # [tokio :: test] async fn buf_writer_inner_flushes () { let mut w = BufWriter :: with_capacity (3 , Vec :: new ()) ; assert_eq ! (w . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (* w . get_ref () , []) ; w . flush () . await . unwrap () ; let w = w . into_inner () ; assert_eq ! (w , [0 , 1]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 3467778897972936543,
      "kind": "Function",
      "name": "buf_writer_seek",
      "signature": "fn # [tokio :: test] async fn buf_writer_seek () { let mut w = BufWriter :: with_capacity (3 , Cursor :: new (Vec :: new ())) ; w . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await . unwrap () ; w . write_all (& [6 , 7]) . await . unwrap () ; assert_eq ! (w . seek (SeekFrom :: Current (0)) . await . unwrap () , 8) ; assert_eq ! (& w . get_ref () . get_ref () [..] , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7] [..]) ; assert_eq ! (w . seek (SeekFrom :: Start (2)) . await . unwrap () , 2) ; w . write_all (& [8 , 9]) . await . unwrap () ; w . flush () . await . unwrap () ; assert_eq ! (& w . into_inner () . into_inner () [..] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 17214353986305182452,
      "kind": "Function",
      "name": "maybe_pending_buf_writer",
      "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer () { let mut writer = BufWriter :: with_capacity (2 , MaybePending :: new (Vec :: new ())) ; assert_eq ! (writer . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; assert_eq ! (writer . write (& [2]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; assert_eq ! (writer . write (& [3]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2 , 3]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [4]) . await . unwrap () , 1) ; assert_eq ! (writer . write (& [5]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [4 , 5]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [6]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [6]) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5]) ; assert_eq ! (writer . write (& [7 , 8]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8]) ; assert_eq ! (writer . write (& [9 , 10 , 11]) . await . unwrap () , 3) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 9837771562561672546,
      "kind": "Function",
      "name": "maybe_pending_buf_writer_inner_flushes",
      "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer_inner_flushes () { let mut w = BufWriter :: with_capacity (3 , MaybePending :: new (Vec :: new ())) ; assert_eq ! (w . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (& w . get_ref () . inner , & []) ; w . flush () . await . unwrap () ; let w = w . into_inner () . inner ; assert_eq ! (w , [0 , 1]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 7288495224515753136,
      "kind": "Function",
      "name": "maybe_pending_buf_writer_seek",
      "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer_seek () { struct MaybePendingSeek { inner : Cursor < Vec < u8 > > , ready_write : bool , ready_seek : bool , seek_res : Option < io :: Result < () > > , } impl MaybePendingSeek { fn new (inner : Vec < u8 >) -> Self { Self { inner : Cursor :: new (inner) , ready_write : false , ready_seek : false , seek_res : None , } } } impl AsyncWrite for MaybePendingSeek { fn poll_write (mut self : Pin < & mut Self > , cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { if self . ready_write { self . ready_write = false ; Pin :: new (& mut self . inner) . poll_write (cx , buf) } else { self . ready_write = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } fn poll_flush (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_flush (cx) } fn poll_shutdown (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_shutdown (cx) } } impl AsyncSeek for MaybePendingSeek { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { self . seek_res = Some (Pin :: new (& mut self . inner) . start_seek (pos)) ; Ok (()) } fn poll_complete (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { if self . ready_seek { self . ready_seek = false ; self . seek_res . take () . unwrap_or (Ok (())) ? ; Pin :: new (& mut self . inner) . poll_complete (cx) } else { self . ready_seek = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } } let mut w = BufWriter :: with_capacity (3 , MaybePendingSeek :: new (Vec :: new ())) ; w . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await . unwrap () ; w . write_all (& [6 , 7]) . await . unwrap () ; assert_eq ! (w . seek (SeekFrom :: Current (0)) . await . unwrap () , 8) ; assert_eq ! (& w . get_ref () . inner . get_ref () [..] , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7] [..]) ; assert_eq ! (w . seek (SeekFrom :: Start (2)) . await . unwrap () , 2) ; w . write_all (& [8 , 9]) . await . unwrap () ; w . flush () . await . unwrap () ; assert_eq ! (& w . into_inner () . inner . into_inner () [..] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 1216213135963578216,
      "kind": "Struct",
      "name": "MockWriter",
      "signature": "struct MockWriter",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 18391380394425834145,
      "kind": "Function",
      "name": "write_vectored_empty_on_non_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_empty_on_non_vectored () { let mut w = BufWriter :: new (MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & []) . await) ; assert_eq ! (n , 0) ; let io_vec = [IoSlice :: new (& []) ; 3] ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 0) ; assert_ok ! (w . flush () . await) ; assert ! (w . get_ref () . data . is_empty ()) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 1483738834139904843,
      "kind": "Function",
      "name": "write_vectored_empty_on_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_empty_on_vectored () { let mut w = BufWriter :: new (MockWriter :: vectored (4)) ; let n = assert_ok ! (write_vectored (& mut w , & []) . await) ; assert_eq ! (n , 0) ; let io_vec = [IoSlice :: new (& []) ; 3] ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 0) ; assert_ok ! (w . flush () . await) ; assert ! (w . get_ref () . data . is_empty ()) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 10525625329707137917,
      "kind": "Function",
      "name": "write_vectored_basic_on_non_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_basic_on_non_vectored () { let msg = b\"foo bar baz\" ; let bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let mut w = BufWriter :: new (MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & bufs) . await) ; assert_eq ! (n , msg . len ()) ; assert ! (w . buffer () == & msg [..]) ; assert_ok ! (w . flush () . await) ; assert_eq ! (w . get_ref () . data , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 10023659092396163063,
      "kind": "Function",
      "name": "write_vectored_basic_on_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_basic_on_vectored () { let msg = b\"foo bar baz\" ; let bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let mut w = BufWriter :: new (MockWriter :: vectored (4)) ; let n = assert_ok ! (write_vectored (& mut w , & bufs) . await) ; assert_eq ! (n , msg . len ()) ; assert ! (w . buffer () == & msg [..]) ; assert_ok ! (w . flush () . await) ; assert_eq ! (w . get_ref () . data , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 1503058179503088424,
      "kind": "Function",
      "name": "write_vectored_large_total_on_non_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_large_total_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let io_vec = IoBufs :: new (& mut bufs) ; let mut w = BufWriter :: with_capacity (8 , MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 8) ; assert ! (w . buffer () == & msg [.. 8]) ; let io_vec = io_vec . advance (n) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 3) ; assert ! (w . get_ref () . data . as_slice () == & msg [.. 8]) ; assert ! (w . buffer () == & msg [8 ..]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 12807846234330802145,
      "kind": "Function",
      "name": "write_vectored_large_total_on_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_large_total_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let io_vec = IoBufs :: new (& mut bufs) ; let mut w = BufWriter :: with_capacity (8 , MockWriter :: vectored (10)) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 10) ; assert ! (w . buffer () . is_empty ()) ; let io_vec = io_vec . advance (n) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 1) ; assert ! (w . get_ref () . data . as_slice () == & msg [.. 10]) ; assert ! (w . buffer () == & msg [10 ..]) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 9386042395346187843,
      "kind": "Struct",
      "name": "VectoredWriteHarness",
      "signature": "struct VectoredWriteHarness",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 6871222040018634784,
      "kind": "Function",
      "name": "write_vectored_odd_on_non_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_odd_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& []) , IoSlice :: new (& msg [4 .. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: new (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 16719677375729287049,
      "kind": "Function",
      "name": "write_vectored_odd_on_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_odd_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& []) , IoSlice :: new (& msg [4 .. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: with_vectored_backend (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 5335629090201662297,
      "kind": "Function",
      "name": "write_vectored_large_slice_on_non_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_large_slice_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& []) , IoSlice :: new (& msg [.. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: new (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 14896195210978553205,
      "kind": "Function",
      "name": "write_vectored_large_slice_on_vectored",
      "signature": "fn # [tokio :: test] async fn write_vectored_large_slice_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& []) , IoSlice :: new (& msg [.. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: with_vectored_backend (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
      "file_path": "tokio/tests/io_buf_writer.rs",
      "line": 0
    },
    {
      "hash": 6651905548946312203,
      "kind": "Function",
      "name": "chain",
      "signature": "fn # [tokio :: test] async fn chain () { let mut buf = Vec :: new () ; let rd1 : & [u8] = b\"hello \" ; let rd2 : & [u8] = b\"world\" ; let mut rd = rd1 . chain (rd2) ; assert_ok ! (rd . read_to_end (& mut buf) . await) ; assert_eq ! (buf , b\"hello world\") ; } . sig",
      "file_path": "tokio/tests/io_chain.rs",
      "line": 0
    },
    {
      "hash": 3518268031413339244,
      "kind": "Function",
      "name": "copy",
      "signature": "fn # [tokio :: test] async fn copy () { struct Rd (bool) ; impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { if self . 0 { buf . put_slice (b\"hello world\") ; self . 0 = false ; Poll :: Ready (Ok (())) } else { Poll :: Ready (Ok (())) } } } let mut rd = Rd (true) ; let mut wr = Vec :: new () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , 11) ; assert_eq ! (wr , b\"hello world\") ; } . sig",
      "file_path": "tokio/tests/io_copy.rs",
      "line": 0
    },
    {
      "hash": 9298609560144514176,
      "kind": "Function",
      "name": "proxy",
      "signature": "fn # [tokio :: test] async fn proxy () { struct BufferedWd { buf : BytesMut , writer : io :: DuplexStream , } impl AsyncWrite for BufferedWd { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { self . get_mut () . buf . extend_from_slice (buf) ; Poll :: Ready (Ok (buf . len ())) } fn poll_flush (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { let this = self . get_mut () ; while ! this . buf . is_empty () { let n = ready ! (Pin :: new (& mut this . writer) . poll_write (cx , & this . buf)) ? ; let _ = this . buf . split_to (n) ; } Pin :: new (& mut this . writer) . poll_flush (cx) } fn poll_shutdown (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . writer) . poll_shutdown (cx) } } let (rd , wd) = io :: duplex (1024) ; let mut rd = rd . take (1024) ; let mut wd = BufferedWd { buf : BytesMut :: new () , writer : wd , } ; assert_ok ! (wd . write_all (& [0x42 ; 512]) . await) ; assert_ok ! (wd . flush () . await) ; let n = assert_ok ! (io :: copy (& mut rd , & mut wd) . await) ; assert_eq ! (n , 1024) ; } . sig",
      "file_path": "tokio/tests/io_copy.rs",
      "line": 0
    },
    {
      "hash": 9273626379552982074,
      "kind": "Function",
      "name": "copy_is_cooperative",
      "signature": "fn # [tokio :: test] async fn copy_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut reader : & [u8] = b\"hello\" ; let mut writer : Vec < u8 > = vec ! [] ; let _ = io :: copy (& mut reader , & mut writer) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_copy.rs",
      "line": 0
    },
    {
      "hash": 13743182242345054324,
      "kind": "Function",
      "name": "make_socketpair",
      "signature": "fn async fn make_socketpair () -> (TcpStream , TcpStream) { let listener = tokio :: net :: TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let addr = listener . local_addr () . unwrap () ; let connector = TcpStream :: connect (addr) ; let acceptor = listener . accept () ; let (c1 , c2) = tokio :: join ! (connector , acceptor) ; (c1 . unwrap () , c2 . unwrap () . 0) } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 8844482351226865001,
      "kind": "Function",
      "name": "block_write",
      "signature": "fn async fn block_write (s : & mut TcpStream) -> usize { static BUF : [u8 ; 2048] = [0 ; 2048] ; let mut copied = 0 ; loop { tokio :: select ! { result = s . write (& BUF) => { copied += result . expect (\"write error\") } , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { break ; } } } copied } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 15239866266013000180,
      "kind": "Function",
      "name": "symmetric",
      "signature": "fn async fn symmetric < F , Fut > (mut cb : F) where F : FnMut (JoinHandle < io :: Result < (u64 , u64) > > , TcpStream , TcpStream) -> Fut , Fut : std :: future :: Future < Output = () > , { let (a , mut a1) = make_socketpair () . await ; let (b , mut b1) = make_socketpair () . await ; let handle = tokio :: spawn (async move { copy_bidirectional (& mut a1 , & mut b1) . await }) ; cb (handle , a , b) . await ; let (a , mut a1) = make_socketpair () . await ; let (b , mut b1) = make_socketpair () . await ; let handle = tokio :: spawn (async move { copy_bidirectional (& mut b1 , & mut a1) . await }) ; cb (handle , b , a) . await ; } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 7160540546097166928,
      "kind": "Function",
      "name": "test_basic_transfer",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_basic_transfer () { symmetric (| _handle , mut a , mut b | async move { a . write_all (b\"test\") . await . unwrap () ; let mut tmp = [0 ; 4] ; b . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"test\") ; }) . await } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 15541945769282695101,
      "kind": "Function",
      "name": "test_transfer_after_close",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_transfer_after_close () { symmetric (| handle , mut a , mut b | async move { AsyncWriteExt :: shutdown (& mut a) . await . unwrap () ; b . read_to_end (& mut Vec :: new ()) . await . unwrap () ; b . write_all (b\"quux\") . await . unwrap () ; let mut tmp = [0 ; 4] ; a . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"quux\") ; drop (b) ; assert_eq ! (handle . await . unwrap () . unwrap () , (0 , 4)) ; }) . await } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 13200695595594746206,
      "kind": "Function",
      "name": "blocking_one_side_does_not_block_other",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn blocking_one_side_does_not_block_other () { symmetric (| handle , mut a , mut b | async move { block_write (& mut a) . await ; b . write_all (b\"quux\") . await . unwrap () ; let mut tmp = [0 ; 4] ; a . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"quux\") ; AsyncWriteExt :: shutdown (& mut a) . await . unwrap () ; let mut buf = Vec :: new () ; b . read_to_end (& mut buf) . await . unwrap () ; drop (b) ; assert_eq ! (handle . await . unwrap () . unwrap () , (buf . len () as u64 , 4)) ; }) . await } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 4916971138879823339,
      "kind": "Function",
      "name": "immediate_exit_on_write_error",
      "signature": "fn # [tokio :: test] async fn immediate_exit_on_write_error () { let payload = b\"here, take this\" ; let error = | | io :: Error :: new (io :: ErrorKind :: Other , \"no thanks!\") ; let mut a = tokio_test :: io :: Builder :: new () . read (payload) . write_error (error ()) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read (payload) . write_error (error ()) . build () ; assert ! (copy_bidirectional (& mut a , & mut b) . await . is_err ()) ; } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 15496600683916996342,
      "kind": "Function",
      "name": "immediate_exit_on_read_error",
      "signature": "fn # [tokio :: test] async fn immediate_exit_on_read_error () { let error = | | io :: Error :: new (io :: ErrorKind :: Other , \"got nothing!\") ; let mut a = tokio_test :: io :: Builder :: new () . read_error (error ()) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read_error (error ()) . build () ; assert ! (copy_bidirectional (& mut a , & mut b) . await . is_err ()) ; } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 319861860385563732,
      "kind": "Function",
      "name": "copy_bidirectional_is_cooperative",
      "signature": "fn # [tokio :: test] async fn copy_bidirectional_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let payload = b\"here, take this\" ; let mut a = tokio_test :: io :: Builder :: new () . read (payload) . write (payload) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read (payload) . write (payload) . build () ; let _ = copy_bidirectional (& mut a , & mut b) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_copy_bidirectional.rs",
      "line": 0
    },
    {
      "hash": 15393452173799424121,
      "kind": "Function",
      "name": "test_drop_on_notify",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn test_drop_on_notify () { let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let (addr_tx , addr_rx) = mpsc :: channel () ; let task = Arc :: new (Task :: new (async move { let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = listener . local_addr () . unwrap () ; addr_tx . send (addr) . unwrap () ; loop { let _ = listener . accept () . await ; } })) ; { let _enter = rt . enter () ; let waker = waker_ref (& task) ; let mut cx = Context :: from_waker (& waker) ; assert_pending ! (task . future . lock () . unwrap () . as_mut () . poll (& mut cx)) ; } let addr = addr_rx . recv () . unwrap () ; drop (task) ; let _s = TcpStream :: connect (addr) . unwrap () ; rt . block_on (async { }) ; } . sig",
      "file_path": "tokio/tests/io_driver.rs",
      "line": 0
    },
    {
      "hash": 12787170749644705941,
      "kind": "Function",
      "name": "panics_when_io_disabled",
      "signature": "fn # [test] # [should_panic (expected = \"A Tokio 1.x context was found, but IO is disabled. Call `enable_io` on the runtime builder to enable IO.\")] # [cfg_attr (miri , ignore)] fn panics_when_io_disabled () { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; let _ = tokio :: net :: TcpListener :: from_std (listener) ; }) ; } . sig",
      "file_path": "tokio/tests/io_driver.rs",
      "line": 0
    },
    {
      "hash": 17297250368606632262,
      "kind": "Function",
      "name": "tcp_doesnt_block",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_doesnt_block () { let rt = rt () ; let listener = { let _enter = rt . enter () ; let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; TcpListener :: from_std (listener) . unwrap () } ; drop (rt) ; let mut task = task :: spawn (async move { assert_err ! (listener . accept () . await) ; }) ; assert_ready ! (task . poll ()) ; } . sig",
      "file_path": "tokio/tests/io_driver_drop.rs",
      "line": 0
    },
    {
      "hash": 17708758271268012173,
      "kind": "Function",
      "name": "drop_wakes",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn drop_wakes () { let rt = rt () ; let listener = { let _enter = rt . enter () ; let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; TcpListener :: from_std (listener) . unwrap () } ; let mut task = task :: spawn (async move { assert_err ! (listener . accept () . await) ; }) ; assert_pending ! (task . poll ()) ; drop (rt) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; } . sig",
      "file_path": "tokio/tests/io_driver_drop.rs",
      "line": 0
    },
    {
      "hash": 10219830608208424399,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> runtime :: Runtime { runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/io_driver_drop.rs",
      "line": 0
    },
    {
      "hash": 2518544997095460789,
      "kind": "Function",
      "name": "fill_buf_file",
      "signature": "fn # [tokio :: test] async fn fill_buf_file () { let file = NamedTempFile :: new () . unwrap () ; assert_ok ! (std :: fs :: write (file . path () , b\"hello\")) ; let file = assert_ok ! (File :: open (file . path ()) . await) ; let mut file = BufReader :: new (file) ; let mut contents = Vec :: new () ; loop { let consumed = { let buffer = assert_ok ! (file . fill_buf () . await) ; if buffer . is_empty () { break ; } contents . extend_from_slice (buffer) ; buffer . len () } ; file . consume (consumed) ; } assert_eq ! (contents , b\"hello\") ; } . sig",
      "file_path": "tokio/tests/io_fill_buf.rs",
      "line": 0
    },
    {
      "hash": 4224420485998508068,
      "kind": "Struct",
      "name": "R",
      "signature": "struct R",
      "file_path": "tokio/tests/io_join.rs",
      "line": 0
    },
    {
      "hash": 742670182768673483,
      "kind": "Struct",
      "name": "W",
      "signature": "struct W",
      "file_path": "tokio/tests/io_join.rs",
      "line": 0
    },
    {
      "hash": 4604071384034101480,
      "kind": "Function",
      "name": "is_send_and_sync",
      "signature": "fn # [test] fn is_send_and_sync () { fn assert_bound < T : Send + Sync > () { } assert_bound :: < Join < W , R > > () ; } . sig",
      "file_path": "tokio/tests/io_join.rs",
      "line": 0
    },
    {
      "hash": 2932974350305499048,
      "kind": "Function",
      "name": "method_delegation",
      "signature": "fn # [test] fn method_delegation () { let mut rw = join (R , W) ; let mut buf = [0 ; 1] ; tokio_test :: block_on (async move { assert_eq ! (1 , rw . read (& mut buf) . await . unwrap ()) ; assert_eq ! (b'z' , buf [0]) ; assert_eq ! (1 , rw . write (b\"x\") . await . unwrap ()) ; assert_eq ! (2 , rw . write_vectored (& [io :: IoSlice :: new (b\"x\")]) . await . unwrap ()) ; assert ! (rw . is_write_vectored ()) ; assert ! (rw . flush () . await . is_ok ()) ; assert ! (rw . shutdown () . await . is_ok ()) ; }) ; } . sig",
      "file_path": "tokio/tests/io_join.rs",
      "line": 0
    },
    {
      "hash": 6882793824108665885,
      "kind": "Function",
      "name": "lines_inherent",
      "signature": "fn # [tokio :: test] async fn lines_inherent () { let rd : & [u8] = b\"hello\\r\\nworld\\n\\n\" ; let mut st = rd . lines () ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"hello\") ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"world\") ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"\") ; assert ! (assert_ok ! (st . next_line () . await) . is_none ()) ; } . sig",
      "file_path": "tokio/tests/io_lines.rs",
      "line": 0
    },
    {
      "hash": 10078033231746853473,
      "kind": "Function",
      "name": "ping_pong",
      "signature": "fn # [tokio :: test] async fn ping_pong () { let (mut a , mut b) = duplex (32) ; let mut buf = [0u8 ; 4] ; a . write_all (b\"ping\") . await . unwrap () ; b . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"ping\") ; b . write_all (b\"pong\") . await . unwrap () ; a . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"pong\") ; } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 7518320543250898015,
      "kind": "Function",
      "name": "across_tasks",
      "signature": "fn # [tokio :: test] async fn across_tasks () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { a . write_all (b\"ping\") . await . unwrap () ; let mut buf = [0u8 ; 4] ; a . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"pong\") ; }) ; let t2 = tokio :: spawn (async move { let mut buf = [0u8 ; 4] ; b . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"ping\") ; b . write_all (b\"pong\") . await . unwrap () ; }) ; t1 . await . unwrap () ; t2 . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 10810858346822141989,
      "kind": "Function",
      "name": "disconnect",
      "signature": "fn # [tokio :: test] async fn disconnect () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { a . write_all (b\"ping\") . await . unwrap () ; }) ; let t2 = tokio :: spawn (async move { let mut buf = [0u8 ; 32] ; let n = b . read (& mut buf) . await . unwrap () ; assert_eq ! (& buf [.. n] , b\"ping\") ; let n = b . read (& mut buf) . await . unwrap () ; assert_eq ! (n , 0) ; }) ; t1 . await . unwrap () ; t2 . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 7479202263728689335,
      "kind": "Function",
      "name": "disconnect_reader",
      "signature": "fn # [tokio :: test] async fn disconnect_reader () { let (a , mut b) = duplex (2) ; let t1 = tokio :: spawn (async move { b . write_all (b\"ping\") . await . unwrap_err () ; }) ; let t2 = tokio :: spawn (async move { drop (a) ; }) ; t2 . await . unwrap () ; t1 . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 7816258332265455180,
      "kind": "Function",
      "name": "max_write_size",
      "signature": "fn # [tokio :: test] async fn max_write_size () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { let n = a . write (& [0u8 ; 64]) . await . unwrap () ; assert_eq ! (n , 32) ; let n = a . write (& [0u8 ; 64]) . await . unwrap () ; assert_eq ! (n , 4) ; }) ; let mut buf = [0u8 ; 4] ; b . read_exact (& mut buf) . await . unwrap () ; t1 . await . unwrap () ; drop (b) ; } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 3445741956000155573,
      "kind": "Function",
      "name": "duplex_is_cooperative",
      "signature": "fn # [tokio :: test] async fn duplex_is_cooperative () { let (mut tx , mut rx) = tokio :: io :: duplex (1024 * 8) ; tokio :: select ! { biased ; _ = async { loop { let buf = [3u8 ; 4096] ; tx . write_all (& buf) . await . unwrap () ; let mut buf = [0u8 ; 4096] ; let _ = rx . read (& mut buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_mem_stream.rs",
      "line": 0
    },
    {
      "hash": 5691854271883518363,
      "kind": "Struct",
      "name": "RW",
      "signature": "struct RW",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 14075501182341175614,
      "kind": "Function",
      "name": "read_buf_initialize_unfilled_to_panic_caller",
      "signature": "fn # [test] fn read_buf_initialize_unfilled_to_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . initialize_unfilled_to (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 3150107149587861175,
      "kind": "Function",
      "name": "read_buf_advance_panic_caller",
      "signature": "fn # [test] fn read_buf_advance_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . advance (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 17393990754379565818,
      "kind": "Function",
      "name": "read_buf_set_filled_panic_caller",
      "signature": "fn # [test] fn read_buf_set_filled_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . set_filled (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 3324205900409590763,
      "kind": "Function",
      "name": "read_buf_put_slice_panic_caller",
      "signature": "fn # [test] fn read_buf_put_slice_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; let new_slice = [0x40_u8 , 0x41_u8] ; read_buf . put_slice (& new_slice) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 9621299201500849052,
      "kind": "Function",
      "name": "unsplit_panic_caller",
      "signature": "fn # [test] fn unsplit_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (r1 , _w1) = split (RW) ; let (_r2 , w2) = split (RW) ; r1 . unsplit (w2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 2367836568268599513,
      "kind": "Function",
      "name": "async_fd_new_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] fn async_fd_new_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: new (fd) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 12383547517487232130,
      "kind": "Function",
      "name": "async_fd_with_interest_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] fn async_fd_with_interest_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: io :: Interest ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: with_interest (fd , Interest :: READABLE) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 15570674322119207172,
      "kind": "Function",
      "name": "async_fd_try_new_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] fn async_fd_try_new_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: try_new (fd) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 13576666703079373430,
      "kind": "Function",
      "name": "async_fd_try_with_interest_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] fn async_fd_try_with_interest_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: io :: Interest ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: try_with_interest (fd , Interest :: READABLE) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/io_panic.rs",
      "line": 0
    },
    {
      "hash": 5127828682508388586,
      "kind": "Function",
      "name": "read",
      "signature": "fn # [tokio :: test] async fn read () { # [derive (Default)] struct Rd { poll_cnt : usize , } impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { assert_eq ! (0 , self . poll_cnt) ; self . poll_cnt += 1 ; buf . put_slice (b\"hello world\") ; Poll :: Ready (Ok (())) } } let mut buf = Box :: new ([0 ; 11]) ; let mut rd = Rd :: default () ; let n = assert_ok ! (rd . read (& mut buf [..]) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_read.rs",
      "line": 0
    },
    {
      "hash": 1727337242908034942,
      "kind": "Struct",
      "name": "BadAsyncRead",
      "signature": "struct BadAsyncRead",
      "file_path": "tokio/tests/io_read.rs",
      "line": 0
    },
    {
      "hash": 12953803144241544313,
      "kind": "Function",
      "name": "read_buf_bad_async_read",
      "signature": "fn # [tokio :: test] # [should_panic] async fn read_buf_bad_async_read () { let mut buf = Vec :: with_capacity (10) ; BadAsyncRead :: new () . read_buf (& mut buf) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_read.rs",
      "line": 0
    },
    {
      "hash": 2952172017003981614,
      "kind": "Function",
      "name": "read_buf",
      "signature": "fn # [tokio :: test] async fn read_buf () { struct Rd { cnt : usize , } impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { self . cnt += 1 ; buf . put_slice (b\"hello world\") ; Poll :: Ready (Ok (())) } } let mut buf = vec ! [] ; let mut rd = Rd { cnt : 0 } ; let n = assert_ok ! (rd . read_buf (& mut buf) . await) ; assert_eq ! (1 , rd . cnt) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_read_buf.rs",
      "line": 0
    },
    {
      "hash": 1212769150067707542,
      "kind": "Function",
      "name": "issue_5588",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"io-util\")] async fn issue_5588 () { use bytes :: BufMut ; let mut buf = [0 ; 8] ; let mut read_buf = ReadBuf :: new (& mut buf) ; assert_eq ! (read_buf . remaining_mut () , 8) ; assert_eq ! (read_buf . chunk_mut () . len () , 8) ; unsafe { read_buf . advance_mut (1) ; } assert_eq ! (read_buf . remaining_mut () , 7) ; assert_eq ! (read_buf . chunk_mut () . len () , 7) ; unsafe { read_buf . advance_mut (5) ; } assert_eq ! (read_buf . remaining_mut () , 2) ; assert_eq ! (read_buf . chunk_mut () . len () , 2) ; unsafe { read_buf . advance_mut (2) ; } assert_eq ! (read_buf . remaining_mut () , 0) ; assert_eq ! (read_buf . chunk_mut () . len () , 0) ; let mut buf = [0 ; 8] ; let mut read_buf = ReadBuf :: new (& mut buf) ; assert_eq ! (read_buf . remaining_mut () , 8) ; assert_eq ! (read_buf . chunk_mut () . len () , 8) ; unsafe { read_buf . advance_mut (8) ; } assert_eq ! (read_buf . remaining_mut () , 0) ; assert_eq ! (read_buf . chunk_mut () . len () , 0) ; let mut buf = [std :: mem :: MaybeUninit :: new (1) ; 8] ; let mut uninit = ReadBuf :: uninit (& mut buf) ; assert_eq ! (uninit . remaining_mut () , 8) ; assert_eq ! (uninit . chunk_mut () . len () , 8) ; let mut buf = [std :: mem :: MaybeUninit :: uninit () ; 8] ; let mut uninit = ReadBuf :: uninit (& mut buf) ; unsafe { uninit . advance_mut (4) ; } assert_eq ! (uninit . remaining_mut () , 4) ; assert_eq ! (uninit . chunk_mut () . len () , 4) ; uninit . put_u8 (1) ; assert_eq ! (uninit . remaining_mut () , 3) ; assert_eq ! (uninit . chunk_mut () . len () , 3) ; uninit . put_slice (& [1 , 2 , 3]) ; assert_eq ! (uninit . remaining_mut () , 0) ; assert_eq ! (uninit . chunk_mut () . len () , 0) ; } . sig",
      "file_path": "tokio/tests/io_read_buf.rs",
      "line": 0
    },
    {
      "hash": 4936481204764566562,
      "kind": "Function",
      "name": "read_exact",
      "signature": "fn # [tokio :: test] async fn read_exact () { let mut buf = Box :: new ([0 ; 8]) ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_exact (& mut buf [..]) . await) ; assert_eq ! (n , 8) ; assert_eq ! (buf [..] , b\"hello wo\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_read_exact.rs",
      "line": 0
    },
    {
      "hash": 7902916092301537366,
      "kind": "Function",
      "name": "read_line",
      "signature": "fn # [tokio :: test] async fn read_line () { let mut buf = String :: new () ; let mut rd = Cursor :: new (b\"hello\\nworld\\n\\n\") ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , \"hello\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , \"world\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 1) ; assert_eq ! (buf , \"\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 0) ; assert_eq ! (buf , \"\") ; } . sig",
      "file_path": "tokio/tests/io_read_line.rs",
      "line": 0
    },
    {
      "hash": 4973613552781869108,
      "kind": "Function",
      "name": "read_line_not_all_ready",
      "signature": "fn # [tokio :: test] async fn read_line_not_all_ready () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"ld\\nFizzBuz\") . read (b\"z\\n1\\n2\") . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"We say \" . to_string () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , \"Hello World\\n\" . len ()) ; assert_eq ! (line . as_str () , \"We say Hello World\\n\") ; line = \"I solve \" . to_string () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , \"FizzBuzz\\n\" . len ()) ; assert_eq ! (line . as_str () , \"I solve FizzBuzz\\n\") ; line . clear () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , 2) ; assert_eq ! (line . as_str () , \"1\\n\") ; line . clear () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , 1) ; assert_eq ! (line . as_str () , \"2\") ; } . sig",
      "file_path": "tokio/tests/io_read_line.rs",
      "line": 0
    },
    {
      "hash": 363966450863150608,
      "kind": "Function",
      "name": "read_line_invalid_utf8",
      "signature": "fn # [tokio :: test] async fn read_line_invalid_utf8 () { let mock = Builder :: new () . read (b\"Hello Wor\\xffld.\\n\") . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: InvalidData) ; assert_eq ! (err . to_string () , \"stream did not contain valid UTF-8\") ; assert_eq ! (line . as_str () , \"Foo\") ; } . sig",
      "file_path": "tokio/tests/io_read_line.rs",
      "line": 0
    },
    {
      "hash": 2229075808473357149,
      "kind": "Function",
      "name": "read_line_fail",
      "signature": "fn # [tokio :: test] async fn read_line_fail () { let mock = Builder :: new () . read (b\"Hello Wor\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (line . as_str () , \"FooHello Wor\") ; } . sig",
      "file_path": "tokio/tests/io_read_line.rs",
      "line": 0
    },
    {
      "hash": 14024938450764128601,
      "kind": "Function",
      "name": "read_line_fail_and_utf8_fail",
      "signature": "fn # [tokio :: test] async fn read_line_fail_and_utf8_fail () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"\\xff\\xff\\xff\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (line . as_str () , \"Foo\") ; } . sig",
      "file_path": "tokio/tests/io_read_line.rs",
      "line": 0
    },
    {
      "hash": 3887559273725325952,
      "kind": "Function",
      "name": "read_to_end",
      "signature": "fn # [tokio :: test] async fn read_to_end () { let mut buf = vec ! [] ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_to_end (& mut buf) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_read_to_end.rs",
      "line": 0
    },
    {
      "hash": 4753086605202827496,
      "kind": "Struct",
      "name": "UninitTest",
      "signature": "struct UninitTest",
      "file_path": "tokio/tests/io_read_to_end.rs",
      "line": 0
    },
    {
      "hash": 1044371067345270369,
      "kind": "Function",
      "name": "read_to_end_uninit",
      "signature": "fn # [tokio :: test] async fn read_to_end_uninit () { let mut buf = Vec :: with_capacity (64) ; let mut test = UninitTest { num_init : 0 , state : State :: Initializing , } ; test . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf . len () , 33) ; } . sig",
      "file_path": "tokio/tests/io_read_to_end.rs",
      "line": 0
    },
    {
      "hash": 5390534251226874061,
      "kind": "Function",
      "name": "read_to_end_doesnt_grow_with_capacity",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn read_to_end_doesnt_grow_with_capacity () { let arr : Vec < u8 > = (0 .. 100) . collect () ; for len in 32 .. 100 { let bytes = & arr [.. len] ; for split in 0 .. len { for cap in 0 .. 101 { let mut mock = if split == 0 { Builder :: new () . read (bytes) . build () } else { Builder :: new () . read (& bytes [.. split]) . read (& bytes [split ..]) . build () } ; let mut buf = Vec :: with_capacity (cap) ; AsyncReadExt :: read_to_end (& mut mock , & mut buf) . await . unwrap () ; assert_eq ! (buf . as_slice () , bytes) ; if cap >= len { assert_eq ! (buf . capacity () , cap) ; } } } } } . sig",
      "file_path": "tokio/tests/io_read_to_end.rs",
      "line": 0
    },
    {
      "hash": 5453391009861902710,
      "kind": "Function",
      "name": "read_to_end_grows_capacity_if_unfit",
      "signature": "fn # [tokio :: test] async fn read_to_end_grows_capacity_if_unfit () { let bytes = b\"the_vector_startingcap_will_be_smaller\" ; let mut mock = Builder :: new () . read (bytes) . build () ; let initial_capacity = bytes . len () - 4 ; let mut buf = Vec :: with_capacity (initial_capacity) ; AsyncReadExt :: read_to_end (& mut mock , & mut buf) . await . unwrap () ; assert_eq ! (buf . capacity () , initial_capacity * 4) ; } . sig",
      "file_path": "tokio/tests/io_read_to_end.rs",
      "line": 0
    },
    {
      "hash": 16445738063890992293,
      "kind": "Function",
      "name": "read_to_string",
      "signature": "fn # [tokio :: test] async fn read_to_string () { let mut buf = String :: new () ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_to_string (& mut buf) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , \"hello world\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_read_to_string.rs",
      "line": 0
    },
    {
      "hash": 318652754193722346,
      "kind": "Function",
      "name": "to_string_does_not_truncate_on_utf8_error",
      "signature": "fn # [tokio :: test] async fn to_string_does_not_truncate_on_utf8_error () { let data = vec ! [0xff , 0xff , 0xff] ; let mut s = \"abc\" . to_string () ; match AsyncReadExt :: read_to_string (& mut data . as_slice () , & mut s) . await { Ok (len) => panic ! (\"Should fail: {len} bytes.\") , Err (err) if err . to_string () == \"stream did not contain valid UTF-8\" => { } Err (err) => panic ! (\"Fail: {err}.\") , } assert_eq ! (s , \"abc\") ; } . sig",
      "file_path": "tokio/tests/io_read_to_string.rs",
      "line": 0
    },
    {
      "hash": 8809942204395607107,
      "kind": "Function",
      "name": "to_string_does_not_truncate_on_io_error",
      "signature": "fn # [tokio :: test] async fn to_string_does_not_truncate_on_io_error () { let mut mock = Builder :: new () . read (b\"def\") . read_error (io :: Error :: new (io :: ErrorKind :: Other , \"whoops\")) . build () ; let mut s = \"abc\" . to_string () ; match AsyncReadExt :: read_to_string (& mut mock , & mut s) . await { Ok (len) => panic ! (\"Should fail: {len} bytes.\") , Err (err) if err . to_string () == \"whoops\" => { } Err (err) => panic ! (\"Fail: {err}.\") , } assert_eq ! (s , \"abc\") ; } . sig",
      "file_path": "tokio/tests/io_read_to_string.rs",
      "line": 0
    },
    {
      "hash": 2178661250532473337,
      "kind": "Function",
      "name": "to_string_appends",
      "signature": "fn # [tokio :: test] async fn to_string_appends () { let data = b\"def\" . to_vec () ; let mut s = \"abc\" . to_string () ; let len = AsyncReadExt :: read_to_string (& mut data . as_slice () , & mut s) . await . unwrap () ; assert_eq ! (len , 3) ; assert_eq ! (s , \"abcdef\") ; } . sig",
      "file_path": "tokio/tests/io_read_to_string.rs",
      "line": 0
    },
    {
      "hash": 8591985980126144934,
      "kind": "Function",
      "name": "read_until",
      "signature": "fn # [tokio :: test] async fn read_until () { let mut buf = vec ! [] ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , b\"hello \") ; buf . clear () ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 5) ; assert_eq ! (buf , b\"world\") ; buf . clear () ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 0) ; assert_eq ! (buf , []) ; } . sig",
      "file_path": "tokio/tests/io_read_until.rs",
      "line": 0
    },
    {
      "hash": 4139802063727946545,
      "kind": "Function",
      "name": "read_until_not_all_ready",
      "signature": "fn # [tokio :: test] async fn read_until_not_all_ready () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"ld#Fizz\\xffBuz\") . read (b\"z#1#2\") . build () ; let mut read = BufReader :: new (mock) ; let mut chunk = b\"We say \" . to_vec () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , b\"Hello World#\" . len ()) ; assert_eq ! (chunk , b\"We say Hello World#\") ; chunk = b\"I solve \" . to_vec () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , b\"Fizz\\xffBuzz\\n\" . len ()) ; assert_eq ! (chunk , b\"I solve Fizz\\xffBuzz#\") ; chunk . clear () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , 2) ; assert_eq ! (chunk , b\"1#\") ; chunk . clear () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , 1) ; assert_eq ! (chunk , b\"2\") ; } . sig",
      "file_path": "tokio/tests/io_read_until.rs",
      "line": 0
    },
    {
      "hash": 3836043815673516578,
      "kind": "Function",
      "name": "read_until_fail",
      "signature": "fn # [tokio :: test] async fn read_until_fail () { let mock = Builder :: new () . read (b\"Hello \\xffWor\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut chunk = b\"Foo\" . to_vec () ; let err = read . read_until (b'#' , & mut chunk) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (chunk , b\"FooHello \\xffWor\") ; } . sig",
      "file_path": "tokio/tests/io_read_until.rs",
      "line": 0
    },
    {
      "hash": 5711015907885529890,
      "kind": "Function",
      "name": "repeat_poll_read_is_cooperative",
      "signature": "fn # [tokio :: test] async fn repeat_poll_read_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = [0u8 ; 4096] ; tokio :: io :: repeat (0b101) . read_exact (& mut buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_repeat.rs",
      "line": 0
    },
    {
      "hash": 11716483387887472880,
      "kind": "Function",
      "name": "sink_poll_write_is_cooperative",
      "signature": "fn # [tokio :: test] async fn sink_poll_write_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let buf = vec ! [1 , 2 , 3] ; tokio :: io :: sink () . write_all (& buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_sink.rs",
      "line": 0
    },
    {
      "hash": 7472275423143456042,
      "kind": "Function",
      "name": "sink_poll_flush_is_cooperative",
      "signature": "fn # [tokio :: test] async fn sink_poll_flush_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { tokio :: io :: sink () . flush () . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_sink.rs",
      "line": 0
    },
    {
      "hash": 4263837096953106133,
      "kind": "Function",
      "name": "sink_poll_shutdown_is_cooperative",
      "signature": "fn # [tokio :: test] async fn sink_poll_shutdown_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { tokio :: io :: sink () . shutdown () . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_sink.rs",
      "line": 0
    },
    {
      "hash": 6420153567152290624,
      "kind": "Function",
      "name": "is_send_and_sync",
      "signature": "fn # [test] fn is_send_and_sync () { fn assert_bound < T : Send + Sync > () { } assert_bound :: < ReadHalf < RW > > () ; assert_bound :: < WriteHalf < RW > > () ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 17894254766906736519,
      "kind": "Function",
      "name": "split_stream_id",
      "signature": "fn # [test] fn split_stream_id () { let (r1 , w1) = split (RW) ; let (r2 , w2) = split (RW) ; assert ! (r1 . is_pair_of (& w1)) ; assert ! (! r1 . is_pair_of (& w2)) ; assert ! (r2 . is_pair_of (& w2)) ; assert ! (! r2 . is_pair_of (& w1)) ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 18298599656790964668,
      "kind": "Function",
      "name": "unsplit_ok",
      "signature": "fn # [test] fn unsplit_ok () { let (r , w) = split (RW) ; r . unsplit (w) ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 1286500489595165374,
      "kind": "Function",
      "name": "unsplit_err1",
      "signature": "fn # [test] # [should_panic] fn unsplit_err1 () { let (r , _) = split (RW) ; let (_ , w) = split (RW) ; r . unsplit (w) ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 12002768185671853774,
      "kind": "Function",
      "name": "unsplit_err2",
      "signature": "fn # [test] # [should_panic] fn unsplit_err2 () { let (_ , w) = split (RW) ; let (r , _) = split (RW) ; r . unsplit (w) ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 2631180343431270730,
      "kind": "Function",
      "name": "method_delegation",
      "signature": "fn # [test] fn method_delegation () { let (mut r , mut w) = split (RW) ; let mut buf = [0 ; 1] ; tokio_test :: block_on (async move { assert_eq ! (1 , r . read (& mut buf) . await . unwrap ()) ; assert_eq ! (b'z' , buf [0]) ; assert_eq ! (1 , w . write (b\"x\") . await . unwrap ()) ; assert_eq ! (2 , w . write_vectored (& [io :: IoSlice :: new (b\"x\")]) . await . unwrap ()) ; assert ! (w . is_write_vectored ()) ; assert ! (w . flush () . await . is_ok ()) ; assert ! (w . shutdown () . await . is_ok ()) ; }) ; } . sig",
      "file_path": "tokio/tests/io_split.rs",
      "line": 0
    },
    {
      "hash": 15913240699793179003,
      "kind": "Function",
      "name": "take",
      "signature": "fn # [tokio :: test] async fn take () { let mut buf = [0 ; 6] ; let rd : & [u8] = b\"hello world\" ; let mut rd = rd . take (4) ; let n = assert_ok ! (rd . read (& mut buf) . await) ; assert_eq ! (n , 4) ; assert_eq ! (& buf , & b\"hell\\0\\0\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_take.rs",
      "line": 0
    },
    {
      "hash": 8423153676452263082,
      "kind": "Function",
      "name": "issue_4435",
      "signature": "fn # [tokio :: test] async fn issue_4435 () { let mut buf = [0 ; 8] ; let rd : & [u8] = b\"hello world\" ; let rd = rd . take (4) ; tokio :: pin ! (rd) ; let mut read_buf = ReadBuf :: new (& mut buf) ; read_buf . put_slice (b\"AB\") ; std :: future :: poll_fn (| cx | rd . as_mut () . poll_read (cx , & mut read_buf)) . await . unwrap () ; assert_eq ! (& buf , & b\"ABhell\\0\\0\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_take.rs",
      "line": 0
    },
    {
      "hash": 5641839105613328909,
      "kind": "Struct",
      "name": "BadReader",
      "signature": "struct BadReader",
      "file_path": "tokio/tests/io_take.rs",
      "line": 0
    },
    {
      "hash": 15530277421529951212,
      "kind": "Function",
      "name": "bad_reader_fails",
      "signature": "fn # [tokio :: test] # [should_panic] async fn bad_reader_fails () { let mut buf = Vec :: with_capacity (10) ; BadReader :: new () . take (10) . read_buf (& mut buf) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/io_take.rs",
      "line": 0
    },
    {
      "hash": 14494029756417502910,
      "kind": "Function",
      "name": "empty_read_is_cooperative",
      "signature": "fn # [tokio :: test] async fn empty_read_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = [0u8 ; 4096] ; let _ = tokio :: io :: empty () . read (& mut buf) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_util_empty.rs",
      "line": 0
    },
    {
      "hash": 9590066501764591720,
      "kind": "Function",
      "name": "empty_buf_reads_are_cooperative",
      "signature": "fn # [tokio :: test] async fn empty_buf_reads_are_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = String :: new () ; let _ = tokio :: io :: empty () . read_line (& mut buf) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
      "file_path": "tokio/tests/io_util_empty.rs",
      "line": 0
    },
    {
      "hash": 11659954973890304549,
      "kind": "Function",
      "name": "empty_seek",
      "signature": "fn # [tokio :: test] async fn empty_seek () { use std :: io :: SeekFrom ; let mut empty = tokio :: io :: empty () ; assert ! (matches ! (empty . seek (SeekFrom :: Start (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Start (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Start (u64 :: MAX)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (i64 :: MIN)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (- 1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (i64 :: MAX)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (i64 :: MIN)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (- 1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (i64 :: MAX)) . await , Ok (0))) ; } . sig",
      "file_path": "tokio/tests/io_util_empty.rs",
      "line": 0
    },
    {
      "hash": 13693729138099445791,
      "kind": "Function",
      "name": "write",
      "signature": "fn # [tokio :: test] async fn write () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { assert_eq ! (self . cnt , 0) ; self . buf . extend (& buf [0 .. 4]) ; Ok (4) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let n = assert_ok ! (wr . write (b\"hello world\") . await) ; assert_eq ! (n , 4) ; assert_eq ! (wr . buf , b\"hell\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_write.rs",
      "line": 0
    },
    {
      "hash": 7411134257082335308,
      "kind": "Function",
      "name": "write_cursor",
      "signature": "fn # [tokio :: test] async fn write_cursor () { use std :: io :: Cursor ; let mut wr = Cursor :: new (Vec :: new ()) ; let n = assert_ok ! (wr . write (b\"hello world\") . await) ; assert_eq ! (n , 11) ; assert_eq ! (wr . get_ref () . as_slice () , & b\"hello world\" [..]) ; } . sig",
      "file_path": "tokio/tests/io_write.rs",
      "line": 0
    },
    {
      "hash": 11670013850922789509,
      "kind": "Function",
      "name": "write_all",
      "signature": "fn # [tokio :: test] async fn write_all () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { let n = cmp :: min (4 , buf . len ()) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; assert_ok ! (wr . write_all (b\"hello world\") . await) ; assert_eq ! (wr . buf , b\"hello world\" [..]) ; assert_eq ! (wr . cnt , 3) ; } . sig",
      "file_path": "tokio/tests/io_write_all.rs",
      "line": 0
    },
    {
      "hash": 3056886745393025696,
      "kind": "Function",
      "name": "write_all_buf",
      "signature": "fn # [tokio :: test] async fn write_all_buf () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { let n = cmp :: min (4 , buf . len ()) ; dbg ! (buf) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\"world\")) ; assert_ok ! (wr . write_all_buf (& mut buf) . await) ; assert_eq ! (wr . buf , b\"helloworld\" [..]) ; assert_eq ! (wr . cnt , 4) ; assert ! (! buf . has_remaining ()) ; } . sig",
      "file_path": "tokio/tests/io_write_all_buf.rs",
      "line": 0
    },
    {
      "hash": 11769073691596459751,
      "kind": "Function",
      "name": "write_buf_err",
      "signature": "fn # [tokio :: test] async fn write_buf_err () { # [doc = \" Error out after writing the first 4 bytes\"] struct Wr { cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { self . cnt += 1 ; if self . cnt == 2 { return Poll :: Ready (Err (io :: Error :: new (io :: ErrorKind :: Other , \"whoops\"))) ; } Poll :: Ready (Ok (4)) } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { cnt : 0 } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\"world\")) ; assert_err ! (wr . write_all_buf (& mut buf) . await) ; assert_eq ! (buf . copy_to_bytes (buf . remaining ()) , Bytes :: from_static (b\"oworld\")) ; } . sig",
      "file_path": "tokio/tests/io_write_all_buf.rs",
      "line": 0
    },
    {
      "hash": 8896463058062216673,
      "kind": "Function",
      "name": "write_all_buf_vectored",
      "signature": "fn # [tokio :: test] async fn write_all_buf_vectored () { struct Wr { buf : BytesMut , } impl AsyncWrite for Wr { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { panic ! (\"shouldn't be called\") } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_write_vectored (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , bufs : & [io :: IoSlice < '_ >] ,) -> Poll < Result < usize , io :: Error > > { for buf in bufs { self . buf . extend_from_slice (buf) ; } let n = self . buf . len () ; Ok (n) . into () } fn is_write_vectored (& self) -> bool { true } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\" \")) . chain (Bytes :: from_static (b\"world\")) ; wr . write_all_buf (& mut buf) . await . unwrap () ; assert_eq ! (& wr . buf [..] , b\"hello world\") ; } . sig",
      "file_path": "tokio/tests/io_write_all_buf.rs",
      "line": 0
    },
    {
      "hash": 5896410979036069113,
      "kind": "Function",
      "name": "write_all",
      "signature": "fn # [tokio :: test] async fn write_all () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { assert_eq ! (self . cnt , 0) ; let n = cmp :: min (4 , buf . len ()) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let mut buf = Cursor :: new (& b\"hello world\" [..]) ; assert_ok ! (wr . write_buf (& mut buf) . await) ; assert_eq ! (wr . buf , b\"hell\" [..]) ; assert_eq ! (wr . cnt , 1) ; assert_eq ! (buf . position () , 4) ; } . sig",
      "file_path": "tokio/tests/io_write_buf.rs",
      "line": 0
    },
    {
      "hash": 11592945860131919135,
      "kind": "Function",
      "name": "write_int_should_err_if_write_count_0",
      "signature": "fn # [tokio :: test] async fn write_int_should_err_if_write_count_0 () { struct Wr { } impl AsyncWrite for Wr { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { Ok (0) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { } ; assert ! (wr . write_i8 (0) . await . is_err ()) ; assert ! (wr . write_i32 (12) . await . is_err ()) ; } . sig",
      "file_path": "tokio/tests/io_write_int.rs",
      "line": 0
    },
    {
      "hash": 16849796676674614798,
      "kind": "Struct",
      "name": "PanicsOnDrop",
      "signature": "struct PanicsOnDrop",
      "file_path": "tokio/tests/join_handle_panic.rs",
      "line": 0
    },
    {
      "hash": 6837161155936400042,
      "kind": "Function",
      "name": "test_panics_do_not_propagate_when_dropping_join_handle",
      "signature": "fn # [tokio :: test] async fn test_panics_do_not_propagate_when_dropping_join_handle () { let join_handle = tokio :: spawn (async move { PanicsOnDrop }) ; tokio :: time :: sleep (std :: time :: Duration :: from_millis (3)) . await ; drop (join_handle) ; } . sig",
      "file_path": "tokio/tests/join_handle_panic.rs",
      "line": 0
    },
    {
      "hash": 12370305366188349159,
      "kind": "Function",
      "name": "sync_one_lit_expr_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: join ! (async { 1 } ,) ; assert_eq ! (foo , (1 ,)) ; let foo = tokio :: join ! (biased ; async { 1 } ,) ; assert_eq ! (foo , (1 ,)) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 16515500125752799130,
      "kind": "Function",
      "name": "sync_one_lit_expr_no_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: join ! (async { 1 }) ; assert_eq ! (foo , (1 ,)) ; let foo = tokio :: join ! (biased ; async { 1 }) ; assert_eq ! (foo , (1 ,)) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 1392330196220421098,
      "kind": "Function",
      "name": "sync_two_lit_expr_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_comma () { let foo = tokio :: join ! (async { 1 } , async { 2 } ,) ; assert_eq ! (foo , (1 , 2)) ; let foo = tokio :: join ! (biased ; async { 1 } , async { 2 } ,) ; assert_eq ! (foo , (1 , 2)) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 15992735590789564954,
      "kind": "Function",
      "name": "sync_two_lit_expr_no_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_no_comma () { let foo = tokio :: join ! (async { 1 } , async { 2 }) ; assert_eq ! (foo , (1 , 2)) ; let foo = tokio :: join ! (biased ; async { 1 } , async { 2 }) ; assert_eq ! (foo , (1 , 2)) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 10285329055099718755,
      "kind": "Function",
      "name": "two_await",
      "signature": "fn # [maybe_tokio_test] async fn two_await () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: join ! (async { rx1 . await . unwrap () } , async { rx2 . await . unwrap () }) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; tx1 . send (\"hello\") . unwrap () ; assert ! (join . is_woken ()) ; let res = assert_ready ! (join . poll ()) ; assert_eq ! ((\"hello\" , 123) , res) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 16305280023519964076,
      "kind": "Function",
      "name": "join_size",
      "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn join_size () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (0i32) ; tokio :: join ! (ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 32) ; let fut = async { let ready1 = future :: ready (0i32) ; let ready2 = future :: ready (0i32) ; tokio :: join ! (ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 48) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 6126124048375092896,
      "kind": "Function",
      "name": "non_cooperative_task",
      "signature": "fn async fn non_cooperative_task (permits : Arc < Semaphore >) -> usize { let mut exceeded_budget = 0 ; for _ in 0 .. 5 { for _ in 0 .. 128 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; } exceeded_budget += 1 ; } exceeded_budget } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 7313729805702465449,
      "kind": "Function",
      "name": "poor_little_task",
      "signature": "fn async fn poor_little_task (permits : Arc < Semaphore >) -> usize { let mut how_many_times_i_got_to_run = 0 ; for _ in 0 .. 5 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; how_many_times_i_got_to_run += 1 ; } how_many_times_i_got_to_run } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 1295999090491495393,
      "kind": "Function",
      "name": "join_does_not_allow_tasks_to_starve",
      "signature": "fn # [tokio :: test] async fn join_does_not_allow_tasks_to_starve () { let permits = Arc :: new (Semaphore :: new (1)) ; let (non_cooperative_result , little_task_result) = tokio :: join ! (non_cooperative_task (Arc :: clone (& permits)) , poor_little_task (permits)) ; assert_eq ! (5 , non_cooperative_result) ; assert_eq ! (5 , little_task_result) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 12625036989621165973,
      "kind": "Function",
      "name": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
      "signature": "fn # [tokio :: test] async fn a_different_future_is_polled_first_every_time_poll_fn_is_polled () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } } ; tokio :: join ! (fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) ; assert_eq ! (vec ! [1 , 2 , 3 , 2 , 3 , 1 , 3 , 1 , 2 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 5792808517795448471,
      "kind": "Function",
      "name": "futures_are_polled_in_order_in_biased_mode",
      "signature": "fn # [tokio :: test] async fn futures_are_polled_in_order_in_biased_mode () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } } ; tokio :: join ! (biased ; fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) ; assert_eq ! (vec ! [1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 6131308045107189825,
      "kind": "Function",
      "name": "join_size_biased",
      "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn join_size_biased () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (0i32) ; tokio :: join ! (biased ; ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 24) ; let fut = async { let ready1 = future :: ready (0i32) ; let ready2 = future :: ready (0i32) ; tokio :: join ! (biased ; ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 40) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 17604900300444718756,
      "kind": "Function",
      "name": "empty_join",
      "signature": "fn # [tokio :: test] # [allow (clippy :: unit_cmp)] async fn empty_join () { assert_eq ! (tokio :: join ! () , ()) ; assert_eq ! (tokio :: join ! (biased ;) , ()) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 16534480505183074942,
      "kind": "Function",
      "name": "join_into_future",
      "signature": "fn # [tokio :: test] async fn join_into_future () { struct NotAFuture ; impl std :: future :: IntoFuture for NotAFuture { type Output = () ; type IntoFuture = std :: future :: Ready < () > ; fn into_future (self) -> Self :: IntoFuture { std :: future :: ready (()) } } tokio :: join ! (NotAFuture) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 8370306908693660372,
      "kind": "Function",
      "name": "caller_names_const_count",
      "signature": "fn # [tokio :: test] async fn caller_names_const_count () { let (tx , rx) = oneshot :: channel :: < u32 > () ; const COUNT : u32 = 2 ; let mut join = task :: spawn (async { tokio :: join ! (async { tx . send (COUNT) . unwrap () }) }) ; assert_ready ! (join . poll ()) ; let res = rx . await . unwrap () ; assert_eq ! (2 , res) ; } . sig",
      "file_path": "tokio/tests/macros_join.rs",
      "line": 0
    },
    {
      "hash": 8980740107749742884,
      "kind": "Function",
      "name": "one",
      "signature": "fn async fn one () { } . sig",
      "file_path": "tokio/tests/macros_pin.rs",
      "line": 0
    },
    {
      "hash": 4984073563964423391,
      "kind": "Function",
      "name": "two",
      "signature": "fn async fn two () { } . sig",
      "file_path": "tokio/tests/macros_pin.rs",
      "line": 0
    },
    {
      "hash": 1751934371125276363,
      "kind": "Function",
      "name": "multi_pin",
      "signature": "fn # [maybe_tokio_test] async fn multi_pin () { tokio :: pin ! { let f1 = one () ; let f2 = two () ; } (& mut f1) . await ; (& mut f2) . await ; } . sig",
      "file_path": "tokio/tests/macros_pin.rs",
      "line": 0
    },
    {
      "hash": 16529813848239341921,
      "kind": "Function",
      "name": "compute",
      "signature": "fn async fn compute () -> usize { let join = tokio1 :: spawn (async { 1 }) ; join . await . unwrap () } . sig",
      "file_path": "tokio/tests/macros_rename_test.rs",
      "line": 0
    },
    {
      "hash": 4381720610465395851,
      "kind": "Function",
      "name": "compute_main",
      "signature": "fn # [tokio1 :: main (crate = \"tokio1\")] async fn compute_main () -> usize { compute () . await } . sig",
      "file_path": "tokio/tests/macros_rename_test.rs",
      "line": 0
    },
    {
      "hash": 16607365793206568125,
      "kind": "Function",
      "name": "crate_rename_main",
      "signature": "fn # [test] fn crate_rename_main () { assert_eq ! (1 , compute_main ()) ; } . sig",
      "file_path": "tokio/tests/macros_rename_test.rs",
      "line": 0
    },
    {
      "hash": 6937698064486455016,
      "kind": "Function",
      "name": "crate_rename_test",
      "signature": "fn # [tokio1 :: test (crate = \"tokio1\")] async fn crate_rename_test () { assert_eq ! (1 , compute () . await) ; } . sig",
      "file_path": "tokio/tests/macros_rename_test.rs",
      "line": 0
    },
    {
      "hash": 9939012814742592769,
      "kind": "Function",
      "name": "crate_path_test",
      "signature": "fn # [test :: tokio :: test (crate = \"test::tokio\")] async fn crate_path_test () { assert_eq ! (1 , compute () . await) ; } . sig",
      "file_path": "tokio/tests/macros_rename_test.rs",
      "line": 0
    },
    {
      "hash": 2730709123627771497,
      "kind": "Function",
      "name": "sync_one_lit_expr_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: select ! { foo = async { 1 } => foo , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 13435394048678445030,
      "kind": "Function",
      "name": "no_branch_else_only",
      "signature": "fn # [maybe_tokio_test] async fn no_branch_else_only () { let foo = tokio :: select ! { else => 1 , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 5741236893851016222,
      "kind": "Function",
      "name": "no_branch_else_only_biased",
      "signature": "fn # [maybe_tokio_test] async fn no_branch_else_only_biased () { let foo = tokio :: select ! { biased ; else => 1 , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 4496496821291269627,
      "kind": "Function",
      "name": "nested_one",
      "signature": "fn # [maybe_tokio_test] async fn nested_one () { let foo = tokio :: select ! { foo = async { 1 } => tokio :: select ! { bar = async { foo } => bar , } , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10943357688535223055,
      "kind": "Function",
      "name": "sync_one_lit_expr_no_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: select ! { foo = async { 1 } => foo } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 15477454272991601774,
      "kind": "Function",
      "name": "sync_one_lit_expr_block",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_block () { let foo = tokio :: select ! { foo = async { 1 } => { foo } } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 18258645828929253367,
      "kind": "Function",
      "name": "sync_one_await",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_await () { let foo = tokio :: select ! { foo = one () => foo , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 13702351000627539383,
      "kind": "Function",
      "name": "sync_one_ident",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_ident () { let one = one () ; let foo = tokio :: select ! { foo = one => foo , } ; assert_eq ! (foo , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 4054141073376207134,
      "kind": "Function",
      "name": "sync_two",
      "signature": "fn # [maybe_tokio_test] async fn sync_two () { use std :: cell :: Cell ; let cnt = Cell :: new (0) ; let res = tokio :: select ! { foo = async { cnt . set (cnt . get () + 1) ; 1 } => foo , bar = async { cnt . set (cnt . get () + 1) ; 2 } => bar , } ; assert_eq ! (1 , cnt . get ()) ; assert ! (res == 1 || res == 2) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 17992626506398758239,
      "kind": "Function",
      "name": "drop_in_fut",
      "signature": "fn # [maybe_tokio_test] async fn drop_in_fut () { let s = \"hello\" . to_string () ; let res = tokio :: select ! { foo = async { let v = one () . await ; drop (s) ; v } => foo } ; assert_eq ! (res , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 7094898015131516307,
      "kind": "Function",
      "name": "one_ready",
      "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn one_ready () { let (tx1 , rx1) = oneshot :: channel :: < i32 > () ; let (_tx2 , rx2) = oneshot :: channel :: < i32 > () ; tx1 . send (1) . unwrap () ; let v = tokio :: select ! { res = rx1 => { assert_ok ! (res) } , _ = rx2 => unreachable ! () , } ; assert_eq ! (1 , v) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 3807670986903618079,
      "kind": "Function",
      "name": "select_streams",
      "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn select_streams () { use tokio :: sync :: mpsc ; let (tx1 , mut rx1) = mpsc :: unbounded_channel :: < i32 > () ; let (tx2 , mut rx2) = mpsc :: unbounded_channel :: < i32 > () ; tokio :: spawn (async move { assert_ok ! (tx2 . send (1)) ; tokio :: task :: yield_now () . await ; assert_ok ! (tx1 . send (2)) ; tokio :: task :: yield_now () . await ; assert_ok ! (tx2 . send (3)) ; tokio :: task :: yield_now () . await ; drop ((tx1 , tx2)) ; }) ; let mut rem = true ; let mut msgs = vec ! [] ; while rem { tokio :: select ! { Some (x) = rx1 . recv () => { msgs . push (x) ; } Some (y) = rx2 . recv () => { msgs . push (y) ; } else => { rem = false ; } } } msgs . sort_unstable () ; assert_eq ! (& msgs [..] , & [1 , 2 , 3]) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 18412255901479547303,
      "kind": "Function",
      "name": "move_uncompleted_futures",
      "signature": "fn # [maybe_tokio_test] async fn move_uncompleted_futures () { let (tx1 , mut rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , mut rx2) = oneshot :: channel :: < i32 > () ; tx1 . send (1) . unwrap () ; tx2 . send (2) . unwrap () ; let ran ; tokio :: select ! { res = & mut rx1 => { assert_eq ! (1 , assert_ok ! (res)) ; assert_eq ! (2 , assert_ok ! (rx2 . await)) ; ran = true ; } , res = & mut rx2 => { assert_eq ! (2 , assert_ok ! (res)) ; assert_eq ! (1 , assert_ok ! (rx1 . await)) ; ran = true ; } , } assert ! (ran) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 13273664636283233676,
      "kind": "Function",
      "name": "nested",
      "signature": "fn # [maybe_tokio_test] async fn nested () { let res = tokio :: select ! { x = async { 1 } => { tokio :: select ! { y = async { 2 } => x + y , } } } ; assert_eq ! (res , 3) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 2057493726310540554,
      "kind": "Function",
      "name": "mutable_borrowing_future_with_same_borrow_in_block",
      "signature": "fn # [maybe_tokio_test] async fn mutable_borrowing_future_with_same_borrow_in_block () { let mut value = 234 ; tokio :: select ! { _ = require_mutable (& mut value) => { } , _ = async_noop () => { value += 5 ; } , } assert ! (value >= 234) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10535163398034506654,
      "kind": "Function",
      "name": "mutable_borrowing_future_with_same_borrow_in_block_and_else",
      "signature": "fn # [maybe_tokio_test] async fn mutable_borrowing_future_with_same_borrow_in_block_and_else () { let mut value = 234 ; tokio :: select ! { _ = require_mutable (& mut value) => { } , _ = async_noop () => { value += 5 ; } , else => { value += 27 ; } , } assert ! (value >= 234) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 16411681355819864397,
      "kind": "Function",
      "name": "future_panics_after_poll",
      "signature": "fn # [maybe_tokio_test] async fn future_panics_after_poll () { use tokio_test :: task ; let (tx , rx) = oneshot :: channel () ; let mut polled = false ; let f = poll_fn (| _ | { assert ! (! polled) ; polled = true ; Ready (None :: < () >) }) ; let mut f = task :: spawn (async { tokio :: select ! { Some (_) = f => unreachable ! () , ret = rx => ret . unwrap () , } }) ; assert_pending ! (f . poll ()) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx . send (1)) ; let res = assert_ready ! (f . poll ()) ; assert_eq ! (1 , res) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10973617359857547253,
      "kind": "Function",
      "name": "disable_with_if",
      "signature": "fn # [maybe_tokio_test] async fn disable_with_if () { use tokio_test :: task ; let f = poll_fn (| _ | panic ! ()) ; let (tx , rx) = oneshot :: channel () ; let mut f = task :: spawn (async { tokio :: select ! { _ = f , if false => unreachable ! () , _ = rx => () , } }) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx . send (())) ; assert ! (f . is_woken ()) ; assert_ready ! (f . poll ()) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 9046679068580598070,
      "kind": "Function",
      "name": "join_with_select",
      "signature": "fn # [maybe_tokio_test] async fn join_with_select () { use tokio_test :: task ; let (tx1 , mut rx1) = oneshot :: channel () ; let (tx2 , mut rx2) = oneshot :: channel () ; let mut f = task :: spawn (async { let mut a = None ; let mut b = None ; while a . is_none () || b . is_none () { tokio :: select ! { v1 = & mut rx1 , if a . is_none () => a = Some (assert_ok ! (v1)) , v2 = & mut rx2 , if b . is_none () => b = Some (assert_ok ! (v2)) } } (a . unwrap () , b . unwrap ()) }) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx1 . send (123)) ; assert ! (f . is_woken ()) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx2 . send (456)) ; assert ! (f . is_woken ()) ; let (a , b) = assert_ready ! (f . poll ()) ; assert_eq ! (a , 123) ; assert_eq ! (b , 456) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 15962754763521124138,
      "kind": "Function",
      "name": "use_future_in_if_condition",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn use_future_in_if_condition () { use tokio :: time :: { self , Duration } ; tokio :: select ! { _ = time :: sleep (Duration :: from_millis (10)) , if false => { panic ! (\"if condition ignored\") } _ = async { 1u32 } => { } } } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 2171306901647276088,
      "kind": "Function",
      "name": "use_future_in_if_condition_biased",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn use_future_in_if_condition_biased () { use tokio :: time :: { self , Duration } ; tokio :: select ! { biased ; _ = time :: sleep (Duration :: from_millis (10)) , if false => { panic ! (\"if condition ignored\") } _ = async { 1u32 } => { } } } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10563736137230297098,
      "kind": "Function",
      "name": "many_branches",
      "signature": "fn # [maybe_tokio_test] async fn many_branches () { let num = tokio :: select ! { x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , } ; assert_eq ! (1 , num) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10927293346581829010,
      "kind": "Function",
      "name": "never_branch_no_warnings",
      "signature": "fn # [maybe_tokio_test] async fn never_branch_no_warnings () { let t = tokio :: select ! { _ = async_never () => 0 , one_async_ready = one () => one_async_ready , } ; assert_eq ! (t , 1) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 18188978168497632056,
      "kind": "Function",
      "name": "one",
      "signature": "fn async fn one () -> usize { 1 } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 14729813952362807470,
      "kind": "Function",
      "name": "require_mutable",
      "signature": "fn async fn require_mutable (_ : & mut i32) { } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 18305858180702198504,
      "kind": "Function",
      "name": "async_noop",
      "signature": "fn async fn async_noop () { } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 17570594118577779147,
      "kind": "Function",
      "name": "async_never",
      "signature": "fn async fn async_never () -> ! { futures :: future :: pending () . await } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 16901912570827195691,
      "kind": "Function",
      "name": "mut_on_left_hand_side",
      "signature": "fn # [maybe_tokio_test] async fn mut_on_left_hand_side () { let v = async move { let ok = async { 1 } ; tokio :: pin ! (ok) ; tokio :: select ! { mut a = & mut ok => { a += 1 ; a } } } . await ; assert_eq ! (v , 2) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 1128841815798114001,
      "kind": "Function",
      "name": "biased_one_not_ready",
      "signature": "fn # [maybe_tokio_test] async fn biased_one_not_ready () { let (_tx1 , rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , rx2) = oneshot :: channel :: < i32 > () ; let (tx3 , rx3) = oneshot :: channel :: < i32 > () ; tx2 . send (2) . unwrap () ; tx3 . send (3) . unwrap () ; let v = tokio :: select ! { biased ; _ = rx1 => unreachable ! () , res = rx2 => { assert_ok ! (res) } , _ = rx3 => { panic ! (\"This branch should never be activated because `rx2` should be polled before `rx3` due to `biased;`.\") } } ; assert_eq ! (2 , v) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 16990083732039474424,
      "kind": "Function",
      "name": "biased_eventually_ready",
      "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn biased_eventually_ready () { use tokio :: task :: yield_now ; let one = async { } ; let two = async { yield_now () . await } ; let three = async { yield_now () . await } ; let mut count = 0u8 ; tokio :: pin ! (one , two , three) ; loop { tokio :: select ! { biased ; _ = & mut two , if count < 2 => { count += 1 ; assert_eq ! (count , 2) ; } _ = & mut three , if count < 3 => { count += 1 ; assert_eq ! (count , 3) ; } _ = & mut one , if count < 1 => { count += 1 ; assert_eq ! (count , 1) ; } else => break , } } assert_eq ! (count , 3) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 6848210317877124513,
      "kind": "Function",
      "name": "default_numeric_fallback",
      "signature": "fn # [warn (clippy :: default_numeric_fallback)] pub async fn default_numeric_fallback () { tokio :: select ! { _ = async { } => () , else => () , } } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 3235271525042889218,
      "kind": "Function",
      "name": "mut_ref_patterns",
      "signature": "fn # [maybe_tokio_test] async fn mut_ref_patterns () { tokio :: select ! { Some (mut foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (foo , \"1\") ; foo = \"2\" . to_string () ; assert_eq ! (foo , \"2\") ; } , } ; tokio :: select ! { Some (ref foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (* foo , \"1\") ; } , } ; tokio :: select ! { Some (ref mut foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (* foo , \"1\") ; * foo = \"2\" . to_string () ; assert_eq ! (* foo , \"2\") ; } , } ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 7567735469397781299,
      "kind": "Function",
      "name": "select_into_future",
      "signature": "fn # [tokio :: test] async fn select_into_future () { struct NotAFuture ; impl std :: future :: IntoFuture for NotAFuture { type Output = () ; type IntoFuture = std :: future :: Ready < () > ; fn into_future (self) -> Self :: IntoFuture { std :: future :: ready (()) } } tokio :: select ! { () = NotAFuture => { } , } } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 10988853570784268689,
      "kind": "Function",
      "name": "temporary_lifetime_extension",
      "signature": "fn # [tokio :: test] async fn temporary_lifetime_extension () { tokio :: select ! { () = & mut std :: future :: ready (()) => { } , } } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 84236918663515572,
      "kind": "Function",
      "name": "select_is_budget_aware",
      "signature": "fn # [tokio :: test] async fn select_is_budget_aware () { const BUDGET : usize = 128 ; let task = | | { Box :: pin (async move { tokio :: select ! { biased ; () = tokio :: task :: coop :: consume_budget () => { } , () = std :: future :: ready (()) => { } } }) } ; for _ in 0 .. BUDGET { let poll = futures :: poll ! (& mut task ()) ; assert ! (poll . is_ready ()) ; } let poll = futures :: poll ! (& mut task ()) ; assert ! (poll . is_pending ()) ; } . sig",
      "file_path": "tokio/tests/macros_select.rs",
      "line": 0
    },
    {
      "hash": 6060176771851580171,
      "kind": "Function",
      "name": "test_macro_can_be_used_via_use",
      "signature": "fn # [test] async fn test_macro_can_be_used_via_use () { tokio :: spawn (async { }) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 3614777136395074587,
      "kind": "Function",
      "name": "test_macro_is_resilient_to_shadowing",
      "signature": "fn # [tokio :: test] async fn test_macro_is_resilient_to_shadowing () { tokio :: spawn (async { }) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 388612277458668606,
      "kind": "Function",
      "name": "unused_braces_main",
      "signature": "fn # [rustfmt :: skip] # [tokio :: main] pub async fn unused_braces_main () { println ! (\"hello\") } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 14144628584047193598,
      "kind": "Function",
      "name": "unused_braces_test",
      "signature": "fn # [rustfmt :: skip] # [tokio :: test] async fn unused_braces_test () { assert_eq ! (1 + 1 , 2) } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 9100407931288394659,
      "kind": "Function",
      "name": "trait_method",
      "signature": "fn # [std :: prelude :: v1 :: test] fn trait_method () { trait A { fn f (self) ; fn g (self) ; } impl A for () { # [tokio :: main] async fn f (self) { self . g () } fn g (self) { } } () . f () } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 1752647371297089084,
      "kind": "Function",
      "name": "issue_4175_main_1",
      "signature": "fn # [tokio :: main] pub async fn issue_4175_main_1 () -> ! { panic ! () ; } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 14479443340832872252,
      "kind": "Function",
      "name": "issue_4175_main_2",
      "signature": "fn # [tokio :: main] pub async fn issue_4175_main_2 () -> std :: io :: Result < () > { panic ! () ; } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 4293189062251406319,
      "kind": "Function",
      "name": "issue_4175_test",
      "signature": "fn # [allow (unreachable_code)] # [tokio :: test] pub async fn issue_4175_test () -> std :: io :: Result < () > { return Ok (()) ; panic ! () ; } . sig",
      "file_path": "tokio/tests/macros_test.rs",
      "line": 0
    },
    {
      "hash": 1871929258835952868,
      "kind": "Function",
      "name": "sync_one_lit_expr_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: try_join ! (async { ok (1) } ,) ; assert_eq ! (foo , Ok ((1 ,))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } ,) ; assert_eq ! (foo , Ok ((1 ,))) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 7451929747526998566,
      "kind": "Function",
      "name": "sync_one_lit_expr_no_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: try_join ! (async { ok (1) }) ; assert_eq ! (foo , Ok ((1 ,))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) }) ; assert_eq ! (foo , Ok ((1 ,))) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 3117634726596564735,
      "kind": "Function",
      "name": "sync_two_lit_expr_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_comma () { let foo = tokio :: try_join ! (async { ok (1) } , async { ok (2) } ,) ; assert_eq ! (foo , Ok ((1 , 2))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } , async { ok (2) } ,) ; assert_eq ! (foo , Ok ((1 , 2))) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 14305784739157601496,
      "kind": "Function",
      "name": "sync_two_lit_expr_no_comma",
      "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_no_comma () { let foo = tokio :: try_join ! (async { ok (1) } , async { ok (2) }) ; assert_eq ! (foo , Ok ((1 , 2))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } , async { ok (2) }) ; assert_eq ! (foo , Ok ((1 , 2))) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 12324520427639556566,
      "kind": "Function",
      "name": "two_await",
      "signature": "fn # [maybe_tokio_test] async fn two_await () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: try_join ! (rx1 , rx2) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; tx1 . send (\"hello\") . unwrap () ; assert ! (join . is_woken ()) ; let res : Result < (& str , u32) , _ > = assert_ready ! (join . poll ()) ; assert_eq ! (Ok ((\"hello\" , 123)) , res) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 9744175922176589205,
      "kind": "Function",
      "name": "err_abort_early",
      "signature": "fn # [maybe_tokio_test] async fn err_abort_early () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let (_tx3 , rx3) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: try_join ! (rx1 , rx2 , rx3) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; drop (tx1) ; assert ! (join . is_woken ()) ; let res = assert_ready ! (join . poll ()) ; assert ! (res . is_err ()) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 6704912178019645338,
      "kind": "Function",
      "name": "try_join_size",
      "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn try_join_size () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (ok (0i32)) ; tokio :: try_join ! (ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 32) ; let fut = async { let ready1 = future :: ready (ok (0i32)) ; let ready2 = future :: ready (ok (0i32)) ; tokio :: try_join ! (ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 48) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 10213810878940467106,
      "kind": "Function",
      "name": "ok",
      "signature": "fn fn ok < T > (val : T) -> Result < T , () > { Ok (val) } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 15405317851407057188,
      "kind": "Function",
      "name": "non_cooperative_task",
      "signature": "fn async fn non_cooperative_task (permits : Arc < Semaphore >) -> Result < usize , String > { let mut exceeded_budget = 0 ; for _ in 0 .. 5 { for _ in 0 .. 128 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; } exceeded_budget += 1 ; } Ok (exceeded_budget) } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 10957662864911698851,
      "kind": "Function",
      "name": "poor_little_task",
      "signature": "fn async fn poor_little_task (permits : Arc < Semaphore >) -> Result < usize , String > { let mut how_many_times_i_got_to_run = 0 ; for _ in 0 .. 5 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; how_many_times_i_got_to_run += 1 ; } Ok (how_many_times_i_got_to_run) } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 8002239911723128698,
      "kind": "Function",
      "name": "try_join_does_not_allow_tasks_to_starve",
      "signature": "fn # [tokio :: test] async fn try_join_does_not_allow_tasks_to_starve () { let permits = Arc :: new (Semaphore :: new (10)) ; let result = tokio :: try_join ! (non_cooperative_task (Arc :: clone (& permits)) , poor_little_task (permits)) ; let (non_cooperative_result , little_task_result) = result . unwrap () ; assert_eq ! (5 , non_cooperative_result) ; assert_eq ! (5 , little_task_result) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 11135959100869161108,
      "kind": "Function",
      "name": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
      "signature": "fn # [tokio :: test] async fn a_different_future_is_polled_first_every_time_poll_fn_is_polled () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } Ok :: < () , Infallible > (()) } ; tokio :: try_join ! (fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) . unwrap () ; assert_eq ! (vec ! [1 , 2 , 3 , 2 , 3 , 1 , 3 , 1 , 2 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 5693496212372126226,
      "kind": "Function",
      "name": "futures_are_polled_in_order_in_biased_mode",
      "signature": "fn # [tokio :: test] async fn futures_are_polled_in_order_in_biased_mode () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } Ok :: < () , Infallible > (()) } ; tokio :: try_join ! (biased ; fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) . unwrap () ; assert_eq ! (vec ! [1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 15909384358003533540,
      "kind": "Function",
      "name": "try_join_size_biased",
      "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn try_join_size_biased () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (ok (0i32)) ; tokio :: try_join ! (biased ; ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 24) ; let fut = async { let ready1 = future :: ready (ok (0i32)) ; let ready2 = future :: ready (ok (0i32)) ; tokio :: try_join ! (biased ; ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 40) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 1223705366338809694,
      "kind": "Function",
      "name": "empty_try_join",
      "signature": "fn # [tokio :: test] async fn empty_try_join () { assert_eq ! (tokio :: try_join ! () as Result < _ , () >, Ok (())) ; assert_eq ! (tokio :: try_join ! (biased ;) as Result < _ , () >, Ok (())) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 13471983106481382501,
      "kind": "Function",
      "name": "caller_names_const_count",
      "signature": "fn # [tokio :: test] async fn caller_names_const_count () { let (tx , rx) = oneshot :: channel :: < u32 > () ; const COUNT : u32 = 2 ; let mut try_join = task :: spawn (async { tokio :: try_join ! (async { tx . send (COUNT) }) }) ; assert_ready ! (try_join . poll ()) . unwrap () ; let res = rx . await . unwrap () ; assert_eq ! (2 , res) ; } . sig",
      "file_path": "tokio/tests/macros_try_join.rs",
      "line": 0
    },
    {
      "hash": 9011649023735394278,
      "kind": "Function",
      "name": "no_runtime_panics_binding_net_tcp_listener",
      "signature": "fn # [test] # [should_panic] # [cfg_attr (miri , ignore)] fn no_runtime_panics_binding_net_tcp_listener () { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") . expect (\"failed to bind listener\") ; let _ = TcpListener :: try_from (listener) ; } . sig",
      "file_path": "tokio/tests/net_bind_resource.rs",
      "line": 0
    },
    {
      "hash": 5984841880328094066,
      "kind": "Function",
      "name": "lookup_socket_addr",
      "signature": "fn # [tokio :: test] async fn lookup_socket_addr () { let addr : SocketAddr = \"127.0.0.1:8000\" . parse () . unwrap () ; let actual = assert_ok ! (net :: lookup_host (addr) . await) . collect :: < Vec < _ > > () ; assert_eq ! (vec ! [addr] , actual) ; } . sig",
      "file_path": "tokio/tests/net_lookup_host.rs",
      "line": 0
    },
    {
      "hash": 13664281781865498864,
      "kind": "Function",
      "name": "lookup_str_socket_addr",
      "signature": "fn # [tokio :: test] async fn lookup_str_socket_addr () { let addr : SocketAddr = \"127.0.0.1:8000\" . parse () . unwrap () ; let actual = assert_ok ! (net :: lookup_host (\"127.0.0.1:8000\") . await) . collect :: < Vec < _ > > () ; assert_eq ! (vec ! [addr] , actual) ; } . sig",
      "file_path": "tokio/tests/net_lookup_host.rs",
      "line": 0
    },
    {
      "hash": 13295992785345474112,
      "kind": "Function",
      "name": "resolve_dns",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn resolve_dns () -> io :: Result < () > { let mut hosts = net :: lookup_host (\"localhost:3000\") . await ? ; let host = hosts . next () . unwrap () ; let expected = if host . is_ipv4 () { SocketAddr :: new (IpAddr :: V4 (Ipv4Addr :: new (127 , 0 , 0 , 1)) , 3000) } else { SocketAddr :: new (IpAddr :: V6 (Ipv6Addr :: new (0 , 0 , 0 , 0 , 0 , 0 , 0 , 1)) , 3000) } ; assert_eq ! (host , expected) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_lookup_host.rs",
      "line": 0
    },
    {
      "hash": 6866182662979154715,
      "kind": "Function",
      "name": "test_named_pipe_client_drop",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_client_drop () -> io :: Result < () > { const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-client-drop\" ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let client = ClientOptions :: new () . open (PIPE_NAME) ? ; server . connect () . await ? ; drop (client) ; match server . write_all (b\"ping\") . await { Err (e) if e . raw_os_error () == Some (ERROR_NO_DATA as i32) => () , x => panic ! (\"{:?}\" , x) , } Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 8341371448231511151,
      "kind": "Function",
      "name": "test_named_pipe_single_client",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_single_client () -> io :: Result < () > { use tokio :: io :: { AsyncBufReadExt as _ , BufReader } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let mut server = BufReader :: new (server) ; let mut buf = String :: new () ; server . read_line (& mut buf) . await ? ; server . write_all (b\"pong\\n\") . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, \"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 668591255904027651,
      "kind": "Function",
      "name": "test_named_pipe_multi_client",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_multi_client () -> io :: Result < () > { use tokio :: io :: { AsyncBufReadExt as _ , BufReader } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-multi-client\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { for _ in 0 .. N { server . connect () . await ? ; let mut inner = BufReader :: new (server) ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; tokio :: spawn (async move { let mut buf = String :: new () ; inner . read_line (& mut buf) . await ? ; inner . write_all (b\"pong\\n\") . await ? ; inner . flush () . await ? ; Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) if e . kind () == io :: ErrorKind :: NotFound => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (10)) . await ; } ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . flush () . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (result ?, \"pong\\n\") ; } server . await ? ? ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 12959019996165417608,
      "kind": "Function",
      "name": "test_named_pipe_multi_client_ready",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_multi_client_ready () -> io :: Result < () > { use tokio :: io :: Interest ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-multi-client-ready\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { for _ in 0 .. N { server . connect () . await ? ; let inner_server = server ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; tokio :: spawn (async move { let server = inner_server ; { let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; loop { server . readable () . await ? ; let buf = & mut read_buf [read_buf_cursor ..] ; match server . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } ; { let write_buf = b\"pong\\n\" ; let mut write_buf_cursor = 0 ; loop { server . writable () . await ? ; let buf = & write_buf [write_buf_cursor ..] ; match server . try_write (buf) { Ok (n) => { write_buf_cursor += n ; if write_buf_cursor == write_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) if e . kind () == io :: ErrorKind :: NotFound => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (10)) . await ; } ; let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; let write_buf = b\"ping\\n\" ; let mut write_buf_cursor = 0 ; loop { let mut interest = Interest :: READABLE ; if write_buf_cursor < write_buf . len () { interest |= Interest :: WRITABLE ; } let ready = client . ready (interest) . await ? ; if ready . is_readable () { let buf = & mut read_buf [read_buf_cursor ..] ; match client . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } if ready . is_writable () { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { continue ; } match client . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } let buf = String :: from_utf8_lossy (& read_buf) . into_owned () ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (result ?, \"pong\\n\") ; } server . await ? ? ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 12250813024283705053,
      "kind": "Function",
      "name": "test_named_pipe_mode_message",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_mode_message () -> io :: Result < () > { _named_pipe_mode_message (PipeMode :: Message) . await ? ; _named_pipe_mode_message (PipeMode :: Byte) . await } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 15475430233401202829,
      "kind": "Function",
      "name": "_named_pipe_mode_message",
      "signature": "fn async fn _named_pipe_mode_message (mode : PipeMode) -> io :: Result < () > { let pipe_name = format ! (r\"\\\\.\\pipe\\test-named-pipe-mode-message-{}\" , matches ! (mode , PipeMode :: Message)) ; let mut buf = [0u8 ; 32] ; let mut server = ServerOptions :: new () . first_pipe_instance (true) . pipe_mode (mode) . create (& pipe_name) ? ; let mut client = ClientOptions :: new () . pipe_mode (mode) . open (& pipe_name) ? ; server . connect () . await ? ; for _ in 0 .. 10 { client . write_all (b\"hello\") . await ? ; server . write_all (b\"world\") . await ? ; } for _ in 0 .. 10 { let n = server . read (& mut buf) . await ? ; if buf [.. n] != b\"hello\" [..] { assert ! (matches ! (mode , PipeMode :: Byte)) ; return Ok (()) ; } let n = client . read (& mut buf) . await ? ; if buf [.. n] != b\"world\" [..] { assert ! (matches ! (mode , PipeMode :: Byte)) ; return Ok (()) ; } } assert ! (matches ! (mode , PipeMode :: Message)) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 13462774131557735937,
      "kind": "Function",
      "name": "test_named_pipe_access",
      "signature": "fn # [tokio :: test] async fn test_named_pipe_access () -> io :: Result < () > { const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-access\" ; for (inb , outb) in [(true , true) , (true , false) , (false , true)] { let (tx , rx) = tokio :: sync :: oneshot :: channel () ; let server = tokio :: spawn (async move { let s = ServerOptions :: new () . access_inbound (inb) . access_outbound (outb) . create (PIPE_NAME) ? ; let mut connect_fut = tokio_test :: task :: spawn (s . connect ()) ; assert ! (connect_fut . poll () . is_pending ()) ; tx . send (()) . unwrap () ; connect_fut . await }) ; rx . await . unwrap () ; let _ = ClientOptions :: new () . read (outb) . write (inb) . open (PIPE_NAME) ? ; server . await ? ? ; } Ok (()) } . sig",
      "file_path": "tokio/tests/net_named_pipe.rs",
      "line": 0
    },
    {
      "hash": 10332319819708194335,
      "kind": "Function",
      "name": "udp_socket_from_std_panic_caller",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn udp_socket_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use std :: net :: SocketAddr ; use tokio :: net :: UdpSocket ; let addr = \"127.0.0.1:0\" . parse :: < SocketAddr > () . unwrap () ; let std_sock = std :: net :: UdpSocket :: bind (addr) . unwrap () ; std_sock . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _sock = UdpSocket :: from_std (std_sock) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 7271621701291301091,
      "kind": "Function",
      "name": "tcp_listener_from_std_panic_caller",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_listener_from_std_panic_caller () -> Result < () , Box < dyn Error > > { let std_listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; std_listener . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = TcpListener :: from_std (std_listener) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 17105815045088346285,
      "kind": "Function",
      "name": "tcp_stream_from_std_panic_caller",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_stream_from_std_panic_caller () -> Result < () , Box < dyn Error > > { let std_listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let std_stream = std :: net :: TcpStream :: connect (std_listener . local_addr () . unwrap ()) . unwrap () ; std_stream . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = TcpStream :: from_std (std_stream) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 16080101886852862942,
      "kind": "Function",
      "name": "unix_listener_bind_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_listener_bind_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixListener ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixListener :: bind (& sock_path) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 7571992842182286492,
      "kind": "Function",
      "name": "unix_listener_from_std_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_listener_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixListener ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let std_listener = std :: os :: unix :: net :: UnixListener :: bind (sock_path) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixListener :: from_std (std_listener) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 9785838585919913376,
      "kind": "Function",
      "name": "unix_stream_from_std_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_stream_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixStream ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let _std_listener = std :: os :: unix :: net :: UnixListener :: bind (& sock_path) . unwrap () ; let std_stream = std :: os :: unix :: net :: UnixStream :: connect (& sock_path) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixStream :: from_std (std_stream) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 4864034673885993177,
      "kind": "Function",
      "name": "unix_datagram_from_std_panic_caller",
      "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_datagram_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use std :: os :: unix :: net :: UnixDatagram as StdUDS ; use tokio :: net :: UnixDatagram ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let std_socket = StdUDS :: bind (sock_path) . unwrap () ; std_socket . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (move | | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixDatagram :: from_std (std_socket) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 14381329312703738081,
      "kind": "Function",
      "name": "server_options_max_instances_panic_caller",
      "signature": "fn # [test] # [cfg (windows)] fn server_options_max_instances_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: windows :: named_pipe :: ServerOptions ; let panic_location_file = test_panic (move | | { let rt = runtime_without_io () ; rt . block_on (async { let mut options = ServerOptions :: new () ; options . max_instances (255) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 1255282676501625785,
      "kind": "Function",
      "name": "runtime_without_io",
      "signature": "fn fn runtime_without_io () -> Runtime { Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/net_panic.rs",
      "line": 0
    },
    {
      "hash": 18139678556481992178,
      "kind": "Function",
      "name": "socket_works_with_quickack",
      "signature": "fn # [tokio :: test] async fn socket_works_with_quickack () { const MESSAGE : & str = \"Hello, tokio!\" ; let (tx_port , rx_port) = oneshot :: channel () ; let server = tokio :: spawn (async move { let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let addr = listener . local_addr () . unwrap () ; tx_port . send (addr . port ()) . unwrap () ; let (mut stream , _) = listener . accept () . await . unwrap () ; stream . set_quickack (true) . unwrap () ; assert ! (stream . quickack () . unwrap ()) ; stream . write_all (MESSAGE . as_bytes ()) . await . unwrap () ; let mut buf = vec ! [0 ; MESSAGE . len ()] ; stream . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (buf , MESSAGE . as_bytes ()) ; stream . set_quickack (false) . unwrap () ; assert ! (! stream . quickack () . unwrap ()) ; stream . shutdown () . await . unwrap () ; }) ; let port = rx_port . await . unwrap () ; let client = tokio :: spawn (async move { let mut stream = TcpStream :: connect (format ! (\"127.0.0.1:{port}\")) . await . unwrap () ; stream . set_quickack (true) . unwrap () ; assert ! (stream . quickack () . unwrap ()) ; let mut buf = vec ! [0 ; MESSAGE . len ()] ; stream . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (buf , MESSAGE . as_bytes ()) ; stream . write_all (MESSAGE . as_bytes ()) . await . unwrap () ; stream . set_quickack (false) . unwrap () ; assert ! (! stream . quickack () . unwrap ()) ; stream . shutdown () . await . unwrap () ; }) ; tokio :: try_join ! (server , client) . unwrap () ; } . sig",
      "file_path": "tokio/tests/net_quickack.rs",
      "line": 0
    },
    {
      "hash": 12616098601378870042,
      "kind": "Struct",
      "name": "TempFifo",
      "signature": "struct TempFifo",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 13480483288537185345,
      "kind": "Function",
      "name": "fifo_simple_send",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn fifo_simple_send () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"simple_send\") ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; let mut writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; writer . write_all (DATA) . await ? ; while ! read_fut . is_woken () { tokio :: task :: yield_now () . await ; } let read_data = assert_ready_ok ! (read_fut . poll ()) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 8518097997204483354,
      "kind": "Function",
      "name": "fifo_simple_send_sender_first",
      "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] # [cfg_attr (miri , ignore)] async fn fifo_simple_send_sender_first () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"simple_send_sender_first\") ? ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& fifo)) ; assert_eq ! (err . raw_os_error () , Some (libc :: ENXIO)) ; let mut writer = pipe :: OpenOptions :: new () . read_write (true) . open_sender (& fifo) ? ; writer . write_all (DATA) . await ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let mut read_data = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut read_data) . await ? ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 17308425687223043077,
      "kind": "Function",
      "name": "write_and_close",
      "signature": "fn async fn write_and_close (path : impl AsRef < Path > , msg : & [u8]) -> io :: Result < () > { let mut writer = pipe :: OpenOptions :: new () . open_sender (path) ? ; writer . write_all (msg) . await ? ; drop (writer) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 4717606306593918205,
      "kind": "Function",
      "name": "fifo_multiple_writes",
      "signature": "fn # [doc = \" Checks EOF behavior with single reader and writers sequentially opening\"] # [doc = \" and closing a FIFO.\"] # [tokio :: test] # [cfg_attr (miri , ignore)] async fn fifo_multiple_writes () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"fifo_multiple_writes\") ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; write_and_close (& fifo , DATA) . await ? ; let ev = reader . ready (Interest :: READABLE) . await ? ; assert ! (ev . is_readable ()) ; let mut read_data = vec ! [0 ; DATA . len ()] ; assert_ok ! (reader . read_exact (& mut read_data) . await) ; let err = assert_err ! (reader . read_exact (& mut read_data) . await) ; assert_eq ! (err . kind () , io :: ErrorKind :: UnexpectedEof) ; write_and_close (& fifo , DATA) . await ? ; assert_ok ! (reader . read_exact (& mut read_data) . await) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 11944080803023047582,
      "kind": "Function",
      "name": "fifo_resilient_reader",
      "signature": "fn # [doc = \" Checks behavior of a resilient reader (Receiver in O_RDWR access mode)\"] # [doc = \" with writers sequentially opening and closing a FIFO.\"] # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] # [cfg_attr (miri , ignore)] async fn fifo_resilient_reader () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"fifo_resilient_reader\") ? ; let mut reader = pipe :: OpenOptions :: new () . read_write (true) . open_receiver (& fifo) ? ; write_and_close (& fifo , DATA) . await ? ; let ev = reader . ready (Interest :: READABLE) . await ? ; let mut read_data = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut read_data) . await ? ; assert ! (! ev . is_read_closed ()) ; let mut second_read_fut = task :: spawn (reader . read_exact (& mut read_data)) ; assert_pending ! (second_read_fut . poll ()) ; write_and_close (& fifo , DATA) . await ? ; assert_ok ! (second_read_fut . await) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 4751187120905401952,
      "kind": "Function",
      "name": "open_detects_not_a_fifo",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn open_detects_not_a_fifo () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-fifo-tests\") . tempdir () . unwrap () ; let path = dir . path () . join (\"not_a_fifo\") ; File :: create (& path) ? ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& path)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& path)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 14941558676080643344,
      "kind": "Function",
      "name": "from_file",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"from_file\") ? ; let file = std :: fs :: OpenOptions :: new () . read (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let mut reader = pipe :: Receiver :: from_file (file) ? ; let file = std :: fs :: OpenOptions :: new () . write (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let mut writer = pipe :: Sender :: from_file (file) ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; writer . write_all (DATA) . await ? ; let read_data = assert_ok ! (read_fut . await) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 14016604441546289415,
      "kind": "Function",
      "name": "from_file_detects_not_a_fifo",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_detects_not_a_fifo () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-fifo-tests\") . tempdir () . unwrap () ; let path = dir . path () . join (\"not_a_fifo\") ; File :: create (& path) ? ; let file = std :: fs :: OpenOptions :: new () . write (true) . open (& path) ? ; let err = assert_err ! (pipe :: Sender :: from_file (file)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let file = std :: fs :: OpenOptions :: new () . read (true) . open (& path) ? ; let err = assert_err ! (pipe :: Receiver :: from_file (file)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 4538916259248050821,
      "kind": "Function",
      "name": "from_file_detects_wrong_access_mode",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_detects_wrong_access_mode () -> io :: Result < () > { let fifo = TempFifo :: new (\"wrong_access_mode\") ? ; let _reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let wronly = std :: fs :: OpenOptions :: new () . write (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let err = assert_err ! (pipe :: Receiver :: from_file (wronly)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let rdonly = std :: fs :: OpenOptions :: new () . read (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let err = assert_err ! (pipe :: Sender :: from_file (rdonly)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 2559661891124145520,
      "kind": "Function",
      "name": "is_nonblocking",
      "signature": "fn fn is_nonblocking < T : AsRawFd > (fd : & T) -> io :: Result < bool > { let flags = nix :: fcntl :: fcntl (fd . as_raw_fd () , nix :: fcntl :: F_GETFL) ? ; Ok ((flags & libc :: O_NONBLOCK) != 0) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 7239247394443572126,
      "kind": "Function",
      "name": "from_file_sets_nonblock",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_sets_nonblock () -> io :: Result < () > { let fifo = TempFifo :: new (\"sets_nonblock\") ? ; let _reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let _writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let rdonly = std :: fs :: OpenOptions :: new () . read (true) . open (& fifo) ? ; assert ! (! is_nonblocking (& rdonly) ?) ; let reader = pipe :: Receiver :: from_file (rdonly) ? ; assert ! (is_nonblocking (& reader) ?) ; let wronly = std :: fs :: OpenOptions :: new () . write (true) . open (& fifo) ? ; assert ! (! is_nonblocking (& wronly) ?) ; let writer = pipe :: Sender :: from_file (wronly) ? ; assert ! (is_nonblocking (& writer) ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 4140893839224378836,
      "kind": "Function",
      "name": "writable_by_poll",
      "signature": "fn fn writable_by_poll (writer : & pipe :: Sender) -> bool { task :: spawn (writer . writable ()) . poll () . is_ready () } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 4630151552199150540,
      "kind": "Function",
      "name": "try_read_write",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write (DATA) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; match reader . try_read (& mut read_data [i ..]) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 11681296322568993422,
      "kind": "Function",
      "name": "try_read_write_vectored",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write_vectored () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write_vectored\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let write_bufs : Vec < _ > = DATA . chunks (3) . map (io :: IoSlice :: new) . collect () ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write_vectored (& write_bufs) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; let mut read_bufs : Vec < _ > = read_data [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match reader . try_read_vectored (& mut read_bufs) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 14154402543898427110,
      "kind": "Function",
      "name": "try_read_buf",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_buf () -> std :: io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write_vectored\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write (DATA) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; match reader . try_read_buf (& mut read_data) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 1648719256553407058,
      "kind": "Function",
      "name": "anon_pipe_simple_send",
      "signature": "fn # [tokio :: test] async fn anon_pipe_simple_send () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the pipe\" ; let (mut writer , mut reader) = pipe :: pipe () ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; writer . write_all (DATA) . await ? ; while ! read_fut . is_woken () { tokio :: task :: yield_now () . await ; } let read_data = assert_ready_ok ! (read_fut . poll ()) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 17242742461126779440,
      "kind": "Function",
      "name": "anon_pipe_spawn_echo",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn anon_pipe_spawn_echo () -> std :: io :: Result < () > { use tokio :: process :: Command ; const DATA : & str = \"this is some data to write to the pipe\" ; let (tx , mut rx) = pipe :: pipe () ? ; let status = Command :: new (\"echo\") . arg (\"-n\") . arg (DATA) . stdout (tx . into_blocking_fd () ?) . status () ; let mut buf = vec ! [0 ; DATA . len ()] ; rx . read_exact (& mut buf) . await ? ; assert_eq ! (String :: from_utf8 (buf) . unwrap () , DATA) ; let exit_code = status . await ? ; assert ! (exit_code . success ()) ; buf = Vec :: new () ; let total = assert_ok ! (rx . try_read (& mut buf)) ; assert_eq ! (total , 0) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 13298319523599666990,
      "kind": "Function",
      "name": "anon_pipe_from_owned_fd",
      "signature": "fn # [tokio :: test] # [cfg (target_os = \"linux\")] # [cfg_attr (miri , ignore)] async fn anon_pipe_from_owned_fd () -> std :: io :: Result < () > { use nix :: fcntl :: OFlag ; const DATA : & [u8] = b\"this is some data to write to the pipe\" ; let (rx_fd , tx_fd) = nix :: unistd :: pipe2 (OFlag :: O_CLOEXEC | OFlag :: O_NONBLOCK) ? ; let mut rx = pipe :: Receiver :: from_owned_fd (rx_fd) ? ; let mut tx = pipe :: Sender :: from_owned_fd (tx_fd) ? ; let mut buf = vec ! [0 ; DATA . len ()] ; tx . write_all (DATA) . await ? ; rx . read_exact (& mut buf) . await ? ; assert_eq ! (buf , DATA) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 3948222329740019519,
      "kind": "Function",
      "name": "anon_pipe_into_nonblocking_fd",
      "signature": "fn # [tokio :: test] async fn anon_pipe_into_nonblocking_fd () -> std :: io :: Result < () > { let (tx , rx) = pipe :: pipe () ? ; let tx_fd = tx . into_nonblocking_fd () ? ; let rx_fd = rx . into_nonblocking_fd () ? ; assert ! (is_nonblocking (& tx_fd) ?) ; assert ! (is_nonblocking (& rx_fd) ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 7577173895359209207,
      "kind": "Function",
      "name": "anon_pipe_into_blocking_fd",
      "signature": "fn # [tokio :: test] async fn anon_pipe_into_blocking_fd () -> std :: io :: Result < () > { let (tx , rx) = pipe :: pipe () ? ; let tx_fd = tx . into_blocking_fd () ? ; let rx_fd = rx . into_blocking_fd () ? ; assert ! (! is_nonblocking (& tx_fd) ?) ; assert ! (! is_nonblocking (& rx_fd) ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/net_unix_pipe.rs",
      "line": 0
    },
    {
      "hash": 15292895710601041019,
      "kind": "Function",
      "name": "timeout_panics_when_no_tokio_context",
      "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] fn timeout_panics_when_no_tokio_context () { block_on (timeout_value ()) ; } . sig",
      "file_path": "tokio/tests/no_rt.rs",
      "line": 0
    },
    {
      "hash": 4131743813719068919,
      "kind": "Function",
      "name": "panics_when_no_reactor",
      "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] # [cfg_attr (miri , ignore)] fn panics_when_no_reactor () { let srv = TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let addr = srv . local_addr () . unwrap () ; block_on (TcpStream :: connect (& addr)) . unwrap () ; } . sig",
      "file_path": "tokio/tests/no_rt.rs",
      "line": 0
    },
    {
      "hash": 9801848480683875607,
      "kind": "Function",
      "name": "timeout_value",
      "signature": "fn async fn timeout_value () { let (_tx , rx) = oneshot :: channel :: < () > () ; let dur = Duration :: from_millis (10) ; let _ = timeout (dur , rx) . await ; } . sig",
      "file_path": "tokio/tests/no_rt.rs",
      "line": 0
    },
    {
      "hash": 15151995325058666773,
      "kind": "Function",
      "name": "io_panics_when_no_tokio_context",
      "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] # [cfg_attr (miri , ignore)] fn io_panics_when_no_tokio_context () { let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; let _ = tokio :: net :: TcpListener :: from_std (listener) ; } . sig",
      "file_path": "tokio/tests/no_rt.rs",
      "line": 0
    },
    {
      "hash": 15216706782778949028,
      "kind": "Function",
      "name": "arg0",
      "signature": "fn # [tokio :: test] async fn arg0 () { let mut cmd = Command :: new (\"sh\") ; cmd . arg0 (\"test_string\") . arg (\"-c\") . arg (\"echo $0\") ; let output = cmd . output () . await . unwrap () ; assert_eq ! (output . stdout , b\"test_string\\n\") ; } . sig",
      "file_path": "tokio/tests/process_arg0.rs",
      "line": 0
    },
    {
      "hash": 5669687897980665331,
      "kind": "Function",
      "name": "process_spawned_and_wait_in_different_runtime",
      "signature": "fn # [test] fn process_spawned_and_wait_in_different_runtime () { let mut child = Runtime :: new () . unwrap () . block_on (async { Command :: new (\"true\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () . unwrap () }) ; Runtime :: new () . unwrap () . block_on (async { let _ = child . wait () . await . unwrap () ; }) ; } . sig",
      "file_path": "tokio/tests/process_change_of_runtime.rs",
      "line": 0
    },
    {
      "hash": 3811882506437701727,
      "kind": "Function",
      "name": "process_spawned_outside_runtime",
      "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] fn process_spawned_outside_runtime () { let _ = Command :: new (\"true\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () ; } . sig",
      "file_path": "tokio/tests/process_change_of_runtime.rs",
      "line": 0
    },
    {
      "hash": 11126221144466086426,
      "kind": "Function",
      "name": "issue_2174",
      "signature": "fn # [tokio :: test] # [cfg_attr (panic = \"abort\" , ignore)] async fn issue_2174 () { let mut child = Command :: new (\"sleep\") . arg (\"2\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () . unwrap () ; let mut input = child . stdin . take () . unwrap () ; let handle = tokio :: spawn (async move { let data = [0u8 ; 8192] ; loop { input . write_all (& data) . await . unwrap () ; } }) ; time :: sleep (Duration :: from_secs (1)) . await ; child . kill () . await . unwrap () ; assert_err ! (handle . await) ; } . sig",
      "file_path": "tokio/tests/process_issue_2174.rs",
      "line": 0
    },
    {
      "hash": 8817127727291537353,
      "kind": "Function",
      "name": "issue_42",
      "signature": "fn # [tokio :: test] async fn issue_42 () { let join_handles = (0 .. 10usize) . map (| _ | { task :: spawn (async { let processes = (0 .. 10usize) . map (| i | { let mut child = Command :: new (\"echo\") . arg (format ! (\"I am spawned process #{i}\")) . stdin (Stdio :: null ()) . stdout (Stdio :: null ()) . stderr (Stdio :: null ()) . kill_on_drop (true) . spawn () . unwrap () ; async move { child . wait () . await } }) ; join_all (processes) . await ; }) }) ; join_all (join_handles) . await ; } . sig",
      "file_path": "tokio/tests/process_issue_42.rs",
      "line": 0
    },
    {
      "hash": 310794108307644102,
      "kind": "Function",
      "name": "issue_7144",
      "signature": "fn # [tokio :: test] async fn issue_7144 () { let mut threads = vec ! [] ; for _ in 0 .. 20 { threads . push (tokio :: spawn (test_one ())) ; } for thread in threads { thread . await . unwrap () ; } } . sig",
      "file_path": "tokio/tests/process_issue_7144.rs",
      "line": 0
    },
    {
      "hash": 15626769975460137810,
      "kind": "Function",
      "name": "test_one",
      "signature": "fn async fn test_one () { let mut t = Command :: new (\"strace\") . args (\"-o /dev/null -D sleep 5\" . split (' ')) . spawn () . unwrap () ; sleep (Duration :: from_millis (100)) . await ; unsafe { libc :: kill (t . id () . unwrap () as _ , libc :: SIGINT) } ; t . wait () . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/process_issue_7144.rs",
      "line": 0
    },
    {
      "hash": 5153839655020682350,
      "kind": "Function",
      "name": "kill_after_wait",
      "signature": "fn # [tokio :: test] async fn kill_after_wait () { let mut cmd ; if cfg ! (windows) { cmd = Command :: new (\"cmd\") ; cmd . arg (\"/c\") ; } else { cmd = Command :: new (\"sh\") ; cmd . arg (\"-c\") ; } let mut child = cmd . arg (\"exit 2\") . spawn () . unwrap () ; child . start_kill () . unwrap () ; child . wait () . await . unwrap () ; child . start_kill () . unwrap () ; child . kill () . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/process_kill_after_wait.rs",
      "line": 0
    },
    {
      "hash": 7252920897805502197,
      "kind": "Function",
      "name": "kill_on_drop",
      "signature": "fn # [tokio :: test] async fn kill_on_drop () { let mut cmd = Command :: new (\"bash\") ; cmd . args ([\"-c\" , \"\n       # Fork another child that won't get killed\n       sh -c 'sleep 1; echo child ran' &\n       disown -a\n\n       # Await our death\n       sleep 5\n       echo hello from beyond the grave\n    \" ,]) ; let e = cmd . kill_on_drop (true) . stdout (Stdio :: piped ()) . spawn () ; if e . is_err () && e . as_ref () . unwrap_err () . kind () == ErrorKind :: NotFound { println ! (\"bash not available; skipping test\") ; return ; } let mut child = e . unwrap () ; sleep (Duration :: from_secs (2)) . await ; let mut out = child . stdout . take () . unwrap () ; drop (child) ; let mut msg = String :: new () ; assert_ok ! (out . read_to_string (& mut msg) . await) ; assert_eq ! (\"child ran\\n\" , msg) ; } . sig",
      "file_path": "tokio/tests/process_kill_on_drop.rs",
      "line": 0
    },
    {
      "hash": 12351972288679256760,
      "kind": "Function",
      "name": "obtain_raw_handle",
      "signature": "fn # [tokio :: test] async fn obtain_raw_handle () { let mut cmd = Command :: new (\"cmd\") ; cmd . kill_on_drop (true) ; cmd . arg (\"/c\") ; cmd . arg (\"pause\") ; let child = cmd . spawn () . unwrap () ; let orig_id = child . id () . expect (\"missing id\") ; assert ! (orig_id > 0) ; let handle = child . raw_handle () . expect (\"process stopped\") ; let handled_id = unsafe { GetProcessId (handle as _) } ; assert_eq ! (handled_id , orig_id) ; } . sig",
      "file_path": "tokio/tests/process_raw_handle.rs",
      "line": 0
    },
    {
      "hash": 7947202550434111365,
      "kind": "Function",
      "name": "simple",
      "signature": "fn # [tokio :: test] async fn simple () { let mut cmd ; if cfg ! (windows) { cmd = Command :: new (\"cmd\") ; cmd . arg (\"/c\") ; } else { cmd = Command :: new (\"sh\") ; cmd . arg (\"-c\") ; } let mut child = cmd . arg (\"exit 2\") . spawn () . unwrap () ; let id = child . id () . expect (\"missing id\") ; assert ! (id > 0) ; let status = assert_ok ! (child . wait () . await) ; assert_eq ! (status . code () , Some (2)) ; let status = assert_ok ! (child . wait () . await) ; assert_eq ! (status . code () , Some (2)) ; assert_eq ! (child . id () , None) ; drop (child . kill ()) ; } . sig",
      "file_path": "tokio/tests/process_smoke.rs",
      "line": 0
    },
    {
      "hash": 12167457124640887997,
      "kind": "Function",
      "name": "spawned_task_does_not_progress_without_block_on",
      "signature": "fn # [test] fn spawned_task_does_not_progress_without_block_on () { let (tx , mut rx) = oneshot :: channel () ; let rt = rt () ; rt . spawn (async move { assert_ok ! (tx . send (\"hello\")) ; }) ; thread :: sleep (Duration :: from_millis (50)) ; assert_err ! (rx . try_recv ()) ; let out = rt . block_on (async { assert_ok ! (rx . await) }) ; assert_eq ! (out , \"hello\") ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 15512954030682414961,
      "kind": "Function",
      "name": "no_extra_poll",
      "signature": "fn # [test] fn no_extra_poll () { use pin_project_lite :: pin_project ; use std :: pin :: Pin ; use std :: sync :: { atomic :: { AtomicUsize , Ordering :: SeqCst } , Arc , } ; use std :: task :: { Context , Poll } ; use tokio_stream :: { Stream , StreamExt } ; pin_project ! { struct TrackPolls < S > { npolls : Arc < AtomicUsize >, # [pin] s : S , } } impl < S > Stream for TrackPolls < S > where S : Stream , { type Item = S :: Item ; fn poll_next (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < Option < Self :: Item > > { let this = self . project () ; this . npolls . fetch_add (1 , SeqCst) ; this . s . poll_next (cx) } } let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream :: < () > () ; let rx = TrackPolls { npolls : Arc :: new (AtomicUsize :: new (0)) , s : rx , } ; let npolls = Arc :: clone (& rx . npolls) ; let rt = rt () ; let mut rx = Box :: pin (rx) ; rt . spawn (async move { while rx . next () . await . is_some () { } }) ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1) ; tx . send (()) . unwrap () ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1 + 2) ; drop (tx) ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1 + 2 + 1) ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 18035447551533787314,
      "kind": "Function",
      "name": "acquire_mutex_in_drop",
      "signature": "fn # [test] fn acquire_mutex_in_drop () { use futures :: future :: pending ; use tokio :: task ; let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; let rt = rt () ; rt . spawn (async move { let _ = rx2 . await ; unreachable ! () ; }) ; rt . spawn (async move { let _ = rx1 . await ; tx2 . send (()) . unwrap () ; unreachable ! () ; }) ; rt . spawn (async move { pending :: < () > () . await ; tx1 . send (()) . unwrap () ; }) ; rt . block_on (async { task :: yield_now () . await ; }) ; drop (rt) ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 16051869774192140757,
      "kind": "Function",
      "name": "drop_tasks_in_context",
      "signature": "fn # [test] fn drop_tasks_in_context () { static SUCCESS : AtomicBool = AtomicBool :: new (false) ; struct ContextOnDrop ; impl Future for ContextOnDrop { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for ContextOnDrop { fn drop (& mut self) { if tokio :: runtime :: Handle :: try_current () . is_ok () { SUCCESS . store (true , Ordering :: SeqCst) ; } } } let rt = rt () ; rt . spawn (ContextOnDrop) ; drop (rt) ; assert ! (SUCCESS . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 4842370719270433828,
      "kind": "Function",
      "name": "wake_in_drop_after_panic",
      "signature": "fn # [test] # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [should_panic (expected = \"boom\")] fn wake_in_drop_after_panic () { struct WakeOnDrop (Option < oneshot :: Sender < () > >) ; impl Drop for WakeOnDrop { fn drop (& mut self) { let _ = self . 0 . take () . unwrap () . send (()) ; } } let rt = rt () ; let (tx1 , rx1) = oneshot :: channel :: < () > () ; let (tx2 , rx2) = oneshot :: channel :: < () > () ; rt . spawn (async move { let _wake_on_drop = WakeOnDrop (Some (tx2)) ; let _ = rx1 . await ; unreachable ! () }) ; rt . spawn (async move { let _wake_on_drop = WakeOnDrop (Some (tx1)) ; let _ = rx2 . await ; unreachable ! () }) ; rt . block_on (async { tokio :: task :: yield_now () . await ; panic ! (\"boom\") ; }) ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 3084176697347820673,
      "kind": "Function",
      "name": "spawn_two",
      "signature": "fn # [test] fn spawn_two () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (\"ZOMG\") . unwrap () ; }) ; }) ; assert_ok ! (rx . await) }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (0 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (2 , local) ; } } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 17363974890128550383,
      "kind": "Function",
      "name": "spawn_remote",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"WASI: std::thread::spawn not supported\")] # [test] fn spawn_remote () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async move { std :: thread :: spawn (move | | { std :: thread :: sleep (Duration :: from_millis (10)) ; tx . send (\"ZOMG\") . unwrap () ; }) ; rx . await . unwrap () }) ; handle . await . unwrap () }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (1 , local) ; } } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 6922425322812776260,
      "kind": "Function",
      "name": "timeout_panics_when_no_time_handle",
      "signature": "fn # [test] # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [should_panic (expected = \"A Tokio 1.x context was found, but timers are disabled. Call `enable_time` on the runtime builder to enable timers.\")] fn timeout_panics_when_no_time_handle () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let (_tx , rx) = oneshot :: channel :: < () > () ; let dur = Duration :: from_millis (20) ; let _ = timeout (dur , rx) . await ; }) ; } . sig",
      "file_path": "tokio/tests/rt_basic.rs",
      "line": 0
    },
    {
      "hash": 11529701762797791462,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/signal_multi_rt.rs",
      "line": 0
    },
    {
      "hash": 4335672377577550055,
      "kind": "Function",
      "name": "send_sync_bound",
      "signature": "fn # [test] fn send_sync_bound () { use tokio :: runtime :: Runtime ; fn is_send < T : Send + Sync > () { } is_send :: < Runtime > () ; } . sig",
      "file_path": "tokio/tests/rt_common.rs",
      "line": 0
    },
    {
      "hash": 2271870533045992906,
      "kind": "Function",
      "name": "basic_enter",
      "signature": "fn # [test] # [cfg_attr (panic = \"abort\" , ignore)] fn basic_enter () { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter2) ; drop (enter1) ; } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 13882358888261773666,
      "kind": "Function",
      "name": "interleave_enter_different_rt",
      "signature": "fn # [test] # [should_panic] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_enter_different_rt () { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter1) ; drop (enter2) ; } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 3219661752989320561,
      "kind": "Function",
      "name": "interleave_enter_same_rt",
      "signature": "fn # [test] # [should_panic] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_enter_same_rt () { let rt1 = rt () ; let _enter1 = rt1 . enter () ; let enter2 = rt1 . enter () ; let enter3 = rt1 . enter () ; drop (enter2) ; drop (enter3) ; } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 4618888334630141573,
      "kind": "Function",
      "name": "interleave_then_enter",
      "signature": "fn # [test] # [cfg (not (target_os = \"wasi\"))] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_then_enter () { let _ = std :: panic :: catch_unwind (| | { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter1) ; drop (enter2) ; }) ; let rt3 = rt () ; let _enter = rt3 . enter () ; } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 11880657057793435796,
      "kind": "Function",
      "name": "drop_tasks_with_reference_cycle",
      "signature": "fn # [test] fn drop_tasks_with_reference_cycle () { rt () . block_on (async { let (tx , mut rx) = mpsc :: channel (1) ; let barrier = Arc :: new (Barrier :: new (3)) ; let barrier_a = barrier . clone () ; let barrier_b = barrier . clone () ; let a = tokio :: spawn (async move { let b = rx . recv () . await . unwrap () ; futures :: future :: select (b , std :: future :: ready (())) . await ; barrier_a . wait () . await ; }) ; let b = tokio :: spawn (async move { futures :: future :: select (a , std :: future :: ready (())) . await ; barrier_b . wait () . await ; }) ; tx . send (b) . await . unwrap () ; barrier . wait () . await ; }) ; } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 17028342575679862605,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_handle.rs",
      "line": 0
    },
    {
      "hash": 2122440082012168480,
      "kind": "Function",
      "name": "basic",
      "signature": "fn # [test] fn basic () { test_with_runtimes (| | { let one = Handle :: current () . block_on (async { 1 }) ; assert_eq ! (1 , one) ; }) ; } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 10545179882130514002,
      "kind": "Function",
      "name": "bounded_mpsc_channel",
      "signature": "fn # [test] fn bounded_mpsc_channel () { test_with_runtimes (| | { let (tx , mut rx) = mpsc :: channel (1024) ; Handle :: current () . block_on (tx . send (42)) . unwrap () ; let value = Handle :: current () . block_on (rx . recv ()) . unwrap () ; assert_eq ! (value , 42) ; }) ; } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 4464205819626438069,
      "kind": "Function",
      "name": "unbounded_mpsc_channel",
      "signature": "fn # [test] fn unbounded_mpsc_channel () { test_with_runtimes (| | { let (tx , mut rx) = mpsc :: unbounded_channel () ; let _ = tx . send (42) ; let value = Handle :: current () . block_on (rx . recv ()) . unwrap () ; assert_eq ! (value , 42) ; }) } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 16855861792923717729,
      "kind": "Function",
      "name": "yield_in_block_in_place",
      "signature": "fn # [test] fn yield_in_block_in_place () { test_with_runtimes (| | { Handle :: current () . block_on (async { tokio :: task :: block_in_place (| | { Handle :: current () . block_on (tokio :: task :: yield_now ()) ; }) ; }) ; }) } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 9765111165040372785,
      "kind": "Function",
      "name": "new_multi_thread",
      "signature": "fn # [doc = \" Create a new multi threaded runtime\"] # [cfg (not (target_os = \"wasi\"))] fn new_multi_thread (n : usize) -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (n) . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 8405397372861863731,
      "kind": "Function",
      "name": "new_current_thread",
      "signature": "fn # [doc = \" Create a new single threaded runtime\"] fn new_current_thread () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 16998625244925292733,
      "kind": "Function",
      "name": "test_with_runtimes",
      "signature": "fn # [doc = \" Utility to test things on both kinds of runtimes both before and after shutting it down.\"] fn test_with_runtimes < F > (f : F) where F : Fn () , { { let rt = new_current_thread () ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } # [cfg (not (target_os = \"wasi\"))] { let rt = new_multi_thread (1) ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } # [cfg (not (target_os = \"wasi\"))] { let rt = new_multi_thread (4) ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } } . sig",
      "file_path": "tokio/tests/rt_handle_block_on.rs",
      "line": 0
    },
    {
      "hash": 8384813679861201207,
      "kind": "Function",
      "name": "test_spawn_local_in_runtime",
      "signature": "fn # [test] fn test_spawn_local_in_runtime () { let rt = rt () ; let res = rt . block_on (async move { let (tx , rx) = tokio :: sync :: oneshot :: channel () ; spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 403286920977543687,
      "kind": "Function",
      "name": "test_spawn_from_handle",
      "signature": "fn # [test] fn test_spawn_from_handle () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; rt . handle () . spawn (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 11316126910137872418,
      "kind": "Function",
      "name": "test_spawn_local_on_runtime_object",
      "signature": "fn # [test] fn test_spawn_local_on_runtime_object () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; rt . spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 13881675664893131025,
      "kind": "Function",
      "name": "test_spawn_local_from_guard",
      "signature": "fn # [test] fn test_spawn_local_from_guard () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; let _guard = rt . enter () ; spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 3132313663247333526,
      "kind": "Function",
      "name": "test_spawn_from_guard_other_thread",
      "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn test_spawn_from_guard_other_thread () { let (tx , rx) = std :: sync :: mpsc :: channel () ; std :: thread :: spawn (move | | { let rt = rt () ; let handle = rt . handle () . clone () ; tx . send (handle) . unwrap () ; }) ; let handle = rx . recv () . unwrap () ; let _guard = handle . enter () ; tokio :: spawn (async { }) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 16712629555755960406,
      "kind": "Function",
      "name": "test_spawn_local_from_guard_other_thread",
      "signature": "fn # [test] # [should_panic = \"Local tasks can only be spawned on a LocalRuntime from the thread the runtime was created on\"] # [cfg_attr (target_family = \"wasm\" , ignore)] fn test_spawn_local_from_guard_other_thread () { let (tx , rx) = std :: sync :: mpsc :: channel () ; std :: thread :: spawn (move | | { let rt = rt () ; let handle = rt . handle () . clone () ; tx . send (handle) . unwrap () ; }) ; let handle = rx . recv () . unwrap () ; let _guard = handle . enter () ; spawn_local (async { }) ; } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 17383867376888247512,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: LocalRuntime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build_local (LocalOptions :: default ()) . unwrap () } . sig",
      "file_path": "tokio/tests/rt_local.rs",
      "line": 0
    },
    {
      "hash": 16615341209927102658,
      "kind": "Function",
      "name": "num_workers",
      "signature": "fn # [test] fn num_workers () { let rt = current_thread () ; assert_eq ! (1 , rt . metrics () . num_workers ()) ; let rt = threaded () ; assert_eq ! (2 , rt . metrics () . num_workers ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 11320624023493389371,
      "kind": "Function",
      "name": "num_alive_tasks",
      "signature": "fn # [test] fn num_alive_tasks () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . num_alive_tasks ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . num_alive_tasks ()) ; })) . unwrap () ; assert_eq ! (0 , rt . metrics () . num_alive_tasks ()) ; let rt = threaded () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . num_alive_tasks ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . num_alive_tasks ()) ; })) . unwrap () ; for _ in 0 .. 100 { if rt . metrics () . num_alive_tasks () == 0 { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert_eq ! (0 , rt . metrics () . num_alive_tasks ()) ; } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 4339841764192507184,
      "kind": "Function",
      "name": "global_queue_depth_current_thread",
      "signature": "fn # [test] fn global_queue_depth_current_thread () { use std :: thread ; let rt = current_thread () ; let handle = rt . handle () . clone () ; let metrics = rt . metrics () ; thread :: spawn (move | | { handle . spawn (async { }) ; }) . join () . unwrap () ; assert_eq ! (1 , metrics . global_queue_depth ()) ; } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 18118620761820633615,
      "kind": "Function",
      "name": "global_queue_depth_multi_thread",
      "signature": "fn # [test] fn global_queue_depth_multi_thread () { for _ in 0 .. 10 { let rt = threaded () ; let metrics = rt . metrics () ; if let Ok (_blocking_tasks) = try_block_threaded (& rt) { for i in 0 .. 10 { assert_eq ! (i , metrics . global_queue_depth ()) ; rt . spawn (async { }) ; } return ; } } panic ! (\"exhausted every try to block the runtime\") ; } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 5813862121012069196,
      "kind": "Function",
      "name": "worker_total_busy_duration",
      "signature": "fn # [test] fn worker_total_busy_duration () { const N : usize = 5 ; let zero = Duration :: from_millis (0) ; let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { tokio :: task :: yield_now () . await ; }) . await . unwrap () ; } }) ; drop (rt) ; assert ! (zero < metrics . worker_total_busy_duration (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { tokio :: task :: yield_now () . await ; }) . await . unwrap () ; } }) ; drop (rt) ; for i in 0 .. metrics . num_workers () { assert ! (zero < metrics . worker_total_busy_duration (i)) ; } } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 143312265834780709,
      "kind": "Function",
      "name": "worker_park_count",
      "signature": "fn # [test] fn worker_park_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (1 <= metrics . worker_park_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (1 <= metrics . worker_park_count (0)) ; assert ! (1 <= metrics . worker_park_count (1)) ; } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 5464325870133860804,
      "kind": "Function",
      "name": "worker_park_unpark_count",
      "signature": "fn # [test] fn worker_park_unpark_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (rt . spawn (async { })) . unwrap () ; drop (rt) ; assert ! (2 <= metrics . worker_park_unpark_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; for _ in 0 .. 100 { if 1 <= metrics . worker_park_unpark_count (0) && 1 <= metrics . worker_park_unpark_count (1) { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert_eq ! (1 , metrics . worker_park_unpark_count (0)) ; assert_eq ! (1 , metrics . worker_park_unpark_count (1)) ; rt . block_on (rt . spawn (async { })) . unwrap () ; for _ in 0 .. 100 { if 3 <= metrics . worker_park_unpark_count (0) || 3 <= metrics . worker_park_unpark_count (1) { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert ! (3 <= metrics . worker_park_unpark_count (0) || 3 <= metrics . worker_park_unpark_count (1)) ; drop (rt) ; assert_eq ! (0 , metrics . worker_park_unpark_count (0) % 2) ; assert_eq ! (0 , metrics . worker_park_unpark_count (1) % 2) ; assert ! (4 <= metrics . worker_park_unpark_count (0) || 4 <= metrics . worker_park_unpark_count (1)) ; } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 14295864374102293918,
      "kind": "Function",
      "name": "try_block_threaded",
      "signature": "fn fn try_block_threaded (rt : & Runtime) -> Result < Vec < mpsc :: Sender < () > > , mpsc :: RecvTimeoutError > { let (tx , rx) = mpsc :: channel () ; let blocking_tasks = (0 .. rt . metrics () . num_workers ()) . map (| _ | { let tx = tx . clone () ; let (task , barrier) = mpsc :: channel () ; rt . spawn (async move { tx . send (()) . ok () ; barrier . recv () . ok () ; }) ; task }) . collect () ; for _ in 0 .. rt . metrics () . num_workers () { rx . recv_timeout (Duration :: from_secs (1)) ? ; } Ok (blocking_tasks) } . sig",
      "file_path": "tokio/tests/rt_metrics.rs",
      "line": 0
    },
    {
      "hash": 1106228909641814315,
      "kind": "Function",
      "name": "current_thread",
      "signature": "fn fn current_thread () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 3512262294896758496,
      "kind": "Function",
      "name": "threaded",
      "signature": "fn fn threaded () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 3660875677410040738,
      "kind": "Function",
      "name": "current_handle_panic_caller",
      "signature": "fn # [test] fn current_handle_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Handle :: current () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_panic.rs",
      "line": 0
    },
    {
      "hash": 12943638549382476363,
      "kind": "Function",
      "name": "into_panic_panic_caller",
      "signature": "fn # [test] fn into_panic_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (move | | { let rt = current_thread () ; rt . block_on (async { let handle = tokio :: spawn (future :: pending :: < () > ()) ; handle . abort () ; let err = handle . await . unwrap_err () ; assert ! (!& err . is_panic ()) ; let _ = err . into_panic () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_panic.rs",
      "line": 0
    },
    {
      "hash": 8598272494075888394,
      "kind": "Function",
      "name": "builder_worker_threads_panic_caller",
      "signature": "fn # [test] fn builder_worker_threads_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . worker_threads (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_panic.rs",
      "line": 0
    },
    {
      "hash": 18161608984603509153,
      "kind": "Function",
      "name": "builder_max_blocking_threads_panic_caller",
      "signature": "fn # [test] fn builder_max_blocking_threads_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . max_blocking_threads (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_panic.rs",
      "line": 0
    },
    {
      "hash": 13616756693128657710,
      "kind": "Function",
      "name": "builder_global_queue_interval_panic_caller",
      "signature": "fn # [test] fn builder_global_queue_interval_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . global_queue_interval (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_panic.rs",
      "line": 0
    },
    {
      "hash": 7027220144270564573,
      "kind": "Function",
      "name": "callbacks_fire_multi_thread",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn callbacks_fire_multi_thread () { let poll_start_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_stop_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_start = poll_start_counter . clone () ; let poll_stop = poll_stop_counter . clone () ; let before_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let after_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let before_task_poll_callback_task_id_ref = Arc :: clone (& before_task_poll_callback_task_id) ; let after_task_poll_callback_task_id_ref = Arc :: clone (& after_task_poll_callback_task_id) ; let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . on_before_task_poll (move | task_meta | { before_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_start_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . on_after_task_poll (move | task_meta | { after_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_stop_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . build () . unwrap () ; let task = rt . spawn (async { yield_now () . await ; yield_now () . await ; yield_now () . await ; }) ; let spawned_task_id = task . id () ; rt . block_on (task) . expect (\"task should succeed\") ; drop (rt) ; assert_eq ! (before_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (after_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; let actual_count = 4 ; assert_eq ! (poll_start . load (std :: sync :: atomic :: Ordering :: Relaxed) , actual_count , \"unexpected number of poll starts\") ; assert_eq ! (poll_stop . load (std :: sync :: atomic :: Ordering :: Relaxed) , actual_count , \"unexpected number of poll stops\") ; } . sig",
      "file_path": "tokio/tests/rt_poll_callbacks.rs",
      "line": 0
    },
    {
      "hash": 14368715749240300390,
      "kind": "Function",
      "name": "callbacks_fire_current_thread",
      "signature": "fn # [test] fn callbacks_fire_current_thread () { let poll_start_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_stop_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_start = poll_start_counter . clone () ; let poll_stop = poll_stop_counter . clone () ; let before_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let after_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let before_task_poll_callback_task_id_ref = Arc :: clone (& before_task_poll_callback_task_id) ; let after_task_poll_callback_task_id_ref = Arc :: clone (& after_task_poll_callback_task_id) ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . on_before_task_poll (move | task_meta | { before_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_start_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . on_after_task_poll (move | task_meta | { after_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_stop_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . build () . unwrap () ; let task = rt . spawn (async { yield_now () . await ; yield_now () . await ; yield_now () . await ; }) ; let spawned_task_id = task . id () ; let _ = rt . block_on (task) ; drop (rt) ; assert_eq ! (before_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (after_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (poll_start . load (std :: sync :: atomic :: Ordering :: Relaxed) , 4) ; assert_eq ! (poll_stop . load (std :: sync :: atomic :: Ordering :: Relaxed) , 4) ; } . sig",
      "file_path": "tokio/tests/rt_poll_callbacks.rs",
      "line": 0
    },
    {
      "hash": 8435297105910206723,
      "kind": "Function",
      "name": "single_thread",
      "signature": "fn # [test] fn single_thread () { let _ = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (1) . build () . unwrap () ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 13661768438335470554,
      "kind": "Function",
      "name": "many_oneshot_futures",
      "signature": "fn # [test] fn many_oneshot_futures () { const NUM : usize = 1_000 ; for _ in 0 .. 5 { let (tx , rx) = mpsc :: channel () ; let rt = rt () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. NUM { let cnt = cnt . clone () ; let tx = tx . clone () ; rt . spawn (async move { let num = cnt . fetch_add (1 , Relaxed) + 1 ; if num == NUM { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; drop (rt) ; } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 2437796359609207913,
      "kind": "Function",
      "name": "spawn_two",
      "signature": "fn # [test] fn spawn_two () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (\"ZOMG\") . unwrap () ; }) ; }) ; assert_ok ! (rx . await) }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (1 , local) ; } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 9692895105397555406,
      "kind": "Function",
      "name": "many_multishot_futures",
      "signature": "fn # [test] fn many_multishot_futures () { const CHAIN : usize = 200 ; const CYCLES : usize = 5 ; const TRACKS : usize = 50 ; for _ in 0 .. 50 { let rt = rt () ; let mut start_txs = Vec :: with_capacity (TRACKS) ; let mut final_rxs = Vec :: with_capacity (TRACKS) ; for _ in 0 .. TRACKS { let (start_tx , mut chain_rx) = tokio :: sync :: mpsc :: channel (10) ; for _ in 0 .. CHAIN { let (next_tx , next_rx) = tokio :: sync :: mpsc :: channel (10) ; rt . spawn (async move { while let Some (v) = chain_rx . recv () . await { next_tx . send (v) . await . unwrap () ; } }) ; chain_rx = next_rx ; } let (final_tx , final_rx) = tokio :: sync :: mpsc :: channel (10) ; let cycle_tx = start_tx . clone () ; let mut rem = CYCLES ; rt . spawn (async move { for _ in 0 .. CYCLES { let msg = chain_rx . recv () . await . unwrap () ; rem -= 1 ; if rem == 0 { final_tx . send (msg) . await . unwrap () ; } else { cycle_tx . send (msg) . await . unwrap () ; } } }) ; start_txs . push (start_tx) ; final_rxs . push (final_rx) ; } { rt . block_on (async move { for start_tx in start_txs { start_tx . send (\"ping\") . await . unwrap () ; } for mut final_rx in final_rxs { final_rx . recv () . await . unwrap () ; } }) ; } } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 16361159069606736798,
      "kind": "Function",
      "name": "lifo_slot_budget",
      "signature": "fn # [test] fn lifo_slot_budget () { async fn my_fn () { spawn_another () ; } fn spawn_another () { tokio :: spawn (my_fn ()) ; } let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (1) . build () . unwrap () ; let (send , recv) = oneshot :: channel () ; rt . spawn (async move { tokio :: spawn (my_fn ()) ; let _ = send . send (()) ; }) ; let _ = rt . block_on (recv) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 3998914446804152888,
      "kind": "Function",
      "name": "spawn_shutdown",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn spawn_shutdown () { let rt = rt () ; let (tx , rx) = mpsc :: channel () ; rt . block_on (async { tokio :: spawn (client_server (tx . clone ())) ; }) ; rt . spawn (client_server (tx)) ; assert_ok ! (rx . recv ()) ; assert_ok ! (rx . recv ()) ; drop (rt) ; assert_err ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 12876297769619828038,
      "kind": "Function",
      "name": "client_server",
      "signature": "fn async fn client_server (tx : mpsc :: Sender < () >) { let server = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (server . local_addr ()) ; tokio :: spawn (async move { let (mut socket , _) = server . accept () . await . unwrap () ; socket . write_all (b\"hello\") . await . unwrap () ; }) ; let mut client = TcpStream :: connect (& addr) . await . unwrap () ; let mut buf = vec ! [] ; client . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf , b\"hello\") ; tx . send (()) . unwrap () ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 6788073273774376799,
      "kind": "Function",
      "name": "drop_threadpool_drops_futures",
      "signature": "fn # [test] fn drop_threadpool_drops_futures () { for _ in 0 .. 1_000 { let num_inc = Arc :: new (AtomicUsize :: new (0)) ; let num_dec = Arc :: new (AtomicUsize :: new (0)) ; let num_drop = Arc :: new (AtomicUsize :: new (0)) ; struct Never (Arc < AtomicUsize >) ; impl Future for Never { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for Never { fn drop (& mut self) { self . 0 . fetch_add (1 , Relaxed) ; } } let a = num_inc . clone () ; let b = num_dec . clone () ; let rt = runtime :: Builder :: new_multi_thread () . enable_all () . on_thread_start (move | | { a . fetch_add (1 , Relaxed) ; }) . on_thread_stop (move | | { b . fetch_add (1 , Relaxed) ; }) . build () . unwrap () ; rt . spawn (Never (num_drop . clone ())) ; drop (rt) ; let a = num_inc . load (Relaxed) ; assert ! (a >= 1) ; let b = num_dec . load (Relaxed) ; assert_eq ! (a , b) ; let c = num_drop . load (Relaxed) ; assert_eq ! (c , 1) ; } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 18123019806159080153,
      "kind": "Function",
      "name": "start_stop_callbacks_called",
      "signature": "fn # [test] fn start_stop_callbacks_called () { use std :: sync :: atomic :: { AtomicUsize , Ordering } ; let after_start = Arc :: new (AtomicUsize :: new (0)) ; let before_stop = Arc :: new (AtomicUsize :: new (0)) ; let after_inner = after_start . clone () ; let before_inner = before_stop . clone () ; let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . on_thread_start (move | | { after_inner . clone () . fetch_add (1 , Ordering :: Relaxed) ; }) . on_thread_stop (move | | { before_inner . clone () . fetch_add (1 , Ordering :: Relaxed) ; }) . build () . unwrap () ; let (tx , rx) = oneshot :: channel () ; rt . spawn (async move { assert_ok ! (tx . send (())) ; }) ; assert_ok ! (rt . block_on (rx)) ; drop (rt) ; assert ! (after_start . load (Ordering :: Relaxed) > 0) ; assert ! (before_stop . load (Ordering :: Relaxed) > 0) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 14977091788739946437,
      "kind": "Function",
      "name": "blocking",
      "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn blocking () { const NUM : usize = 1_000 ; for _ in 0 .. 10 { let (tx , rx) = mpsc :: channel () ; let rt = rt () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; let block = Arc :: new (std :: sync :: Barrier :: new (5)) ; for _ in 0 .. 4 { let block = block . clone () ; rt . spawn (async move { tokio :: task :: block_in_place (move | | { block . wait () ; block . wait () ; }) }) ; } block . wait () ; for _ in 0 .. NUM { let cnt = cnt . clone () ; let tx = tx . clone () ; rt . spawn (async move { let num = cnt . fetch_add (1 , Relaxed) + 1 ; if num == NUM { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; block . wait () ; } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 4106484550047371575,
      "kind": "Function",
      "name": "multi_threadpool",
      "signature": "fn # [test] fn multi_threadpool () { use tokio :: sync :: oneshot ; let rt1 = rt () ; let rt2 = rt () ; let (tx , rx) = oneshot :: channel () ; let (done_tx , done_rx) = mpsc :: channel () ; rt2 . spawn (async move { rx . await . unwrap () ; done_tx . send (()) . unwrap () ; }) ; rt1 . spawn (async move { tx . send (()) . unwrap () ; }) ; done_rx . recv () . unwrap () ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 12134866955824319943,
      "kind": "Function",
      "name": "coop_and_block_in_place",
      "signature": "fn # [test] fn coop_and_block_in_place () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (1) . build () . unwrap () ; rt . block_on (async move { let (tx , mut rx) = tokio :: sync :: mpsc :: channel (1024) ; for _ in 0 .. 1024 { tx . send (()) . await . unwrap () ; } drop (tx) ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | { }) ; poll_fn (| cx | { while let Poll :: Ready (v) = { tokio :: pin ! { let fut = rx . recv () ; } Pin :: new (& mut fut) . poll (cx) } { if v . is_none () { panic ! (\"did not yield\") ; } } Poll :: Ready (()) }) . await }) . await . unwrap () ; }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 4704405757628913684,
      "kind": "Function",
      "name": "yield_after_block_in_place",
      "signature": "fn # [test] fn yield_after_block_in_place () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { tokio :: spawn (async move { tokio :: task :: block_in_place (| | { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; }) ; tokio :: task :: yield_now () . await ; }) . await . unwrap () }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 4918197834484225533,
      "kind": "Function",
      "name": "max_blocking_threads",
      "signature": "fn # [test] fn max_blocking_threads () { let _rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (1) . build () . unwrap () ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 8324648793069208749,
      "kind": "Function",
      "name": "max_blocking_threads_set_to_zero",
      "signature": "fn # [test] # [should_panic] fn max_blocking_threads_set_to_zero () { let _rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (0) . build () . unwrap () ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 12697870949720351473,
      "kind": "Function",
      "name": "global_queue_interval_set_to_one",
      "signature": "fn # [doc = \" Regression test for #6445.\"] # [doc = \"\"] # [doc = \" After #6445, setting `global_queue_interval` to 1 is now technically valid.\"] # [doc = \" This test confirms that there is no regression in `multi_thread_runtime`\"] # [doc = \" when global_queue_interval is set to 1.\"] # [test] fn global_queue_interval_set_to_one () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . global_queue_interval (1) . build () . unwrap () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; rt . block_on (async { let mut set = tokio :: task :: JoinSet :: new () ; for _ in 0 .. 10 { let cnt = cnt . clone () ; set . spawn (async move { cnt . fetch_add (1 , Ordering :: Relaxed) }) ; } while let Some (res) = set . join_next () . await { res . unwrap () ; } }) ; assert_eq ! (cnt . load (Relaxed) , 10) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 5939813439463859559,
      "kind": "Function",
      "name": "hang_on_shutdown",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 2)] async fn hang_on_shutdown () { let (sync_tx , sync_rx) = std :: sync :: mpsc :: channel :: < () > () ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | sync_rx . recv () . ok ()) ; }) ; tokio :: spawn (async { tokio :: time :: sleep (std :: time :: Duration :: from_secs (2)) . await ; drop (sync_tx) ; }) ; tokio :: time :: sleep (std :: time :: Duration :: from_secs (1)) . await ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 12812769069519733635,
      "kind": "Function",
      "name": "wake_during_shutdown",
      "signature": "fn # [doc = \" Demonstrates tokio-rs/tokio#3869\"] # [test] fn wake_during_shutdown () { struct Shared { waker : Option < Waker > , } struct MyFuture { shared : Arc < Mutex < Shared > > , put_waker : bool , } impl MyFuture { fn new () -> (Self , Self) { let shared = Arc :: new (Mutex :: new (Shared { waker : None })) ; let f1 = MyFuture { shared : shared . clone () , put_waker : true , } ; let f2 = MyFuture { shared , put_waker : false , } ; (f1 , f2) } } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < () > { let me = Pin :: into_inner (self) ; let mut lock = me . shared . lock () . unwrap () ; if me . put_waker { lock . waker = Some (cx . waker () . clone ()) ; } Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let mut lock = self . shared . lock () . unwrap () ; if ! self . put_waker { lock . waker . take () . unwrap () . wake () ; } drop (lock) ; } } let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; let (f1 , f2) = MyFuture :: new () ; rt . spawn (f1) ; rt . spawn (f2) ; rt . block_on (async { tokio :: time :: sleep (tokio :: time :: Duration :: from_millis (20)) . await }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 5107248223092428884,
      "kind": "Function",
      "name": "test_block_in_place1",
      "signature": "fn # [should_panic] # [tokio :: test] async fn test_block_in_place1 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 8997564491459536676,
      "kind": "Function",
      "name": "test_block_in_place2",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn test_block_in_place2 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 10597853252271793407,
      "kind": "Function",
      "name": "test_block_in_place3",
      "signature": "fn # [should_panic] # [tokio :: main (flavor = \"current_thread\")] # [test] async fn test_block_in_place3 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 860177209669287253,
      "kind": "Function",
      "name": "test_block_in_place4",
      "signature": "fn # [tokio :: main] # [test] async fn test_block_in_place4 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 15651533216361787017,
      "kind": "Function",
      "name": "test_nested_block_in_place_with_block_on_between",
      "signature": "fn # [test] fn test_nested_block_in_place_with_block_on_between () { let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . max_blocking_threads (1) . build () . unwrap () ; for _ in 0 .. 100 { let h = rt . handle () . clone () ; rt . block_on (async move { tokio :: spawn (async move { tokio :: task :: block_in_place (| | { h . block_on (async { tokio :: task :: block_in_place (| | { }) ; }) ; }) }) . await . unwrap () }) ; } } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 5092388683299236661,
      "kind": "Function",
      "name": "yield_now_in_block_in_place",
      "signature": "fn # [test] fn yield_now_in_block_in_place () { let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { tokio :: spawn (async { tokio :: task :: block_in_place (| | { tokio :: runtime :: Handle :: current () . block_on (tokio :: task :: yield_now ()) ; }) }) . await . unwrap () }) } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 11873160393126203539,
      "kind": "Function",
      "name": "mutex_in_block_in_place",
      "signature": "fn # [test] fn mutex_in_block_in_place () { const BUDGET : usize = 128 ; let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { let lock = tokio :: sync :: Mutex :: new (0) ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | { tokio :: runtime :: Handle :: current () . block_on (async move { for i in 0 .. (BUDGET + 1) { let mut guard = lock . lock () . await ; * guard = i ; } }) ; }) }) . await . unwrap () ; }) } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 1657497730026152954,
      "kind": "Function",
      "name": "test_tuning",
      "signature": "fn # [test] # [cfg (not (tokio_no_tuning_tests))] fn test_tuning () { use std :: sync :: atomic :: AtomicBool ; use std :: time :: Duration ; let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; fn iter (flag : Arc < AtomicBool > , counter : Arc < AtomicUsize > , stall : bool) { if flag . load (Relaxed) { if stall { std :: thread :: sleep (Duration :: from_micros (5)) ; } counter . fetch_add (1 , Relaxed) ; tokio :: spawn (async move { iter (flag , counter , stall) }) ; } } let flag = Arc :: new (AtomicBool :: new (true)) ; let counter = Arc :: new (AtomicUsize :: new (61)) ; let interval = Arc :: new (AtomicUsize :: new (61)) ; { let flag = flag . clone () ; let counter = counter . clone () ; rt . spawn (async move { iter (flag , counter , true) }) ; } let mut n = 0 ; loop { let curr = interval . load (Relaxed) ; if curr <= 8 { n += 1 ; } else { n = 0 ; } if n == 3 { break ; } if Arc :: strong_count (& interval) < 5_000 { let counter = counter . clone () ; let interval = interval . clone () ; rt . spawn (async move { let prev = counter . swap (0 , Relaxed) ; interval . store (prev , Relaxed) ; }) ; std :: thread :: yield_now () ; } } flag . store (false , Relaxed) ; let w = Arc :: downgrade (& interval) ; drop (interval) ; while w . strong_count () > 0 { std :: thread :: sleep (Duration :: from_micros (500)) ; } let flag = Arc :: new (AtomicBool :: new (true)) ; let counter = Arc :: new (AtomicUsize :: new (10_000)) ; let interval = Arc :: new (AtomicUsize :: new (10_000)) ; { let flag = flag . clone () ; let counter = counter . clone () ; rt . spawn (async move { iter (flag , counter , false) }) ; } let mut n = 0 ; loop { let curr = interval . load (Relaxed) ; if curr <= 1_000 && curr > 32 { n += 1 ; } else { n = 0 ; } if n == 3 { break ; } if Arc :: strong_count (& interval) <= 5_000 { let counter = counter . clone () ; let interval = interval . clone () ; rt . spawn (async move { let prev = counter . swap (0 , Relaxed) ; interval . store (prev , Relaxed) ; }) ; } std :: thread :: yield_now () ; } flag . store (false , Relaxed) ; } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 4604345873723597178,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> runtime :: Runtime { runtime :: Runtime :: new () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_threaded.rs",
      "line": 0
    },
    {
      "hash": 9881665274151055043,
      "kind": "Function",
      "name": "test_start_paused",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_start_paused () { let now = Instant :: now () ; for _ in 0 .. 5 { std :: thread :: sleep (Duration :: from_millis (1)) ; assert_eq ! (now , Instant :: now ()) ; } } . sig",
      "file_path": "tokio/tests/rt_time_start_paused.rs",
      "line": 0
    },
    {
      "hash": 17062397296076918684,
      "kind": "Function",
      "name": "num_blocking_threads",
      "signature": "fn # [test] fn num_blocking_threads () { let rt = current_thread () ; assert_eq ! (0 , rt . metrics () . num_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; assert_eq ! (1 , rt . metrics () . num_blocking_threads ()) ; let rt = threaded () ; assert_eq ! (0 , rt . metrics () . num_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; assert_eq ! (1 , rt . metrics () . num_blocking_threads ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 10907714503864544456,
      "kind": "Function",
      "name": "num_idle_blocking_threads",
      "signature": "fn # [test] fn num_idle_blocking_threads () { let rt = current_thread () ; assert_eq ! (0 , rt . metrics () . num_idle_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; rt . block_on (async { time :: sleep (Duration :: from_millis (5)) . await ; }) ; if 0 == rt . metrics () . num_idle_blocking_threads () { rt . block_on (async { time :: sleep (Duration :: from_secs (1)) . await ; }) ; } assert_eq ! (1 , rt . metrics () . num_idle_blocking_threads ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 12785520012449284801,
      "kind": "Function",
      "name": "blocking_queue_depth",
      "signature": "fn # [test] fn blocking_queue_depth () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . max_blocking_threads (1) . build () . unwrap () ; assert_eq ! (0 , rt . metrics () . blocking_queue_depth ()) ; let ready = Arc :: new (Mutex :: new (())) ; let guard = ready . lock () . unwrap () ; let ready_cloned = ready . clone () ; let wait_until_ready = move | | { let _unused = ready_cloned . lock () . unwrap () ; } ; let h1 = rt . spawn_blocking (wait_until_ready . clone ()) ; let h2 = rt . spawn_blocking (wait_until_ready) ; assert ! (rt . metrics () . blocking_queue_depth () > 0) ; drop (guard) ; let _ = rt . block_on (h1) ; let _ = rt . block_on (h2) ; assert_eq ! (0 , rt . metrics () . blocking_queue_depth ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 17384564940253273393,
      "kind": "Function",
      "name": "spawned_tasks_count",
      "signature": "fn # [test] fn spawned_tasks_count () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . spawned_tasks_count ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . spawned_tasks_count ()) ; })) . unwrap () ; assert_eq ! (1 , rt . metrics () . spawned_tasks_count ()) ; let rt = threaded () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . spawned_tasks_count ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . spawned_tasks_count ()) ; })) . unwrap () ; assert_eq ! (1 , rt . metrics () . spawned_tasks_count ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 7471093667245957935,
      "kind": "Function",
      "name": "remote_schedule_count",
      "signature": "fn # [test] fn remote_schedule_count () { use std :: thread ; let rt = current_thread () ; let handle = rt . handle () . clone () ; let task = thread :: spawn (move | | { handle . spawn (async { }) }) . join () . unwrap () ; rt . block_on (task) . unwrap () ; assert_eq ! (1 , rt . metrics () . remote_schedule_count ()) ; let rt = threaded () ; let handle = rt . handle () . clone () ; let task = thread :: spawn (move | | { handle . spawn (async { }) }) . join () . unwrap () ; rt . block_on (task) . unwrap () ; assert_eq ! (1 , rt . metrics () . remote_schedule_count ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 17353854653668852945,
      "kind": "Function",
      "name": "worker_thread_id_current_thread",
      "signature": "fn # [test] fn worker_thread_id_current_thread () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { }) ; assert_eq ! (Some (thread :: current () . id ()) , metrics . worker_thread_id (0)) ; let thread_id = std :: thread :: scope (| scope | { let join_handle = scope . spawn (| | { rt . block_on (async { }) ; }) ; join_handle . thread () . id () }) ; assert_eq ! (Some (thread_id) , metrics . worker_thread_id (0)) ; rt . block_on (async { }) ; assert_eq ! (Some (thread :: current () . id ()) , metrics . worker_thread_id (0)) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 16239726844261864646,
      "kind": "Function",
      "name": "worker_thread_id_threaded",
      "signature": "fn # [test] fn worker_thread_id_threaded () { let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (rt . spawn (async move { let thread_id = std :: thread :: current () . id () ; let this_worker = (0 .. 2) . position (| w | metrics . worker_thread_id (w) == Some (thread_id)) . expect (\"task not running on any worker thread\") ; let moved_thread_id = tokio :: task :: block_in_place (| | { assert_eq ! (thread_id , std :: thread :: current () . id ()) ; for _ in 0 .. 100 { let new_id = metrics . worker_thread_id (this_worker) . unwrap () ; if thread_id != new_id { return new_id ; } std :: thread :: sleep (Duration :: from_millis (100)) ; } panic ! (\"worker did not move to new thread\") ; }) ; assert ! (metrics . worker_thread_id (this_worker) == Some (moved_thread_id) || metrics . worker_thread_id (this_worker) == Some (thread_id)) ; })) . unwrap () } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 3722601912012548982,
      "kind": "Function",
      "name": "worker_noop_count",
      "signature": "fn # [test] fn worker_noop_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (0 < metrics . worker_noop_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (0 < metrics . worker_noop_count (0)) ; assert ! (0 < metrics . worker_noop_count (1)) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 16315620555417189312,
      "kind": "Function",
      "name": "worker_steal_count",
      "signature": "fn # [test] fn worker_steal_count () { for _ in 0 .. 10 { let rt = threaded_no_lifo () ; let metrics = rt . metrics () ; let successfully_spawned_stealable_task = rt . block_on (async { try_spawn_stealable_task () . await . is_ok () }) ; drop (rt) ; if successfully_spawned_stealable_task { let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_steal_count (i)) . sum () ; assert_eq ! (1 , n) ; return ; } } panic ! (\"exhausted every try to schedule the stealable task\") ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 14831149560228276411,
      "kind": "Function",
      "name": "worker_poll_count_and_time",
      "signature": "fn # [test] fn worker_poll_count_and_time () { const N : u64 = 5 ; async fn task () { std :: thread :: sleep (std :: time :: Duration :: from_micros (10)) ; } let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (task ()) . await . unwrap () ; } }) ; drop (rt) ; assert_eq ! (N , metrics . worker_poll_count (0)) ; assert_eq ! (Duration :: default () , metrics . worker_mean_poll_time (0)) ; assert ! (! metrics . poll_time_histogram_enabled ()) ; for i in 0 .. 10 { assert_eq ! (0 , metrics . poll_time_histogram_bucket_count (0 , i)) ; } let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (task ()) . await . unwrap () ; } }) ; drop (rt) ; let n = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_poll_count (i)) . sum () ; assert_eq ! (N , n) ; let n : Duration = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_mean_poll_time (i)) . sum () ; assert ! (n > Duration :: default ()) ; assert ! (! metrics . poll_time_histogram_enabled ()) ; for n in 0 .. metrics . num_workers () { for i in 0 .. 10 { assert_eq ! (0 , metrics . poll_time_histogram_bucket_count (n , i)) ; } } } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 7645886886856482174,
      "kind": "Function",
      "name": "log_histogram",
      "signature": "fn # [test] fn log_histogram () { const N : u64 = 50 ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: builder () . max_value (Duration :: from_secs (60)) . min_value (Duration :: from_nanos (100)) . max_error (0.25) ,)) . build () . unwrap () ; let metrics = rt . metrics () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 119) ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) . await . unwrap () ; } }) ; drop (rt) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , Duration :: from_nanos (0) .. Duration :: from_nanos (96)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , Duration :: from_nanos (96) .. Duration :: from_nanos (96 + 2_u64 . pow (4))) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (118) . end , Duration :: from_nanos (u64 :: MAX)) ; let n = (0 .. metrics . num_workers ()) . flat_map (| i | (0 .. num_buckets) . map (move | j | (i , j))) . map (| (worker , bucket) | metrics . poll_time_histogram_bucket_count (worker , bucket)) . sum () ; assert_eq ! (N , n) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 3849009459481385313,
      "kind": "Function",
      "name": "minimal_log_histogram",
      "signature": "fn # [test] fn minimal_log_histogram () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: builder () . max_value (Duration :: from_millis (4)) . min_value (Duration :: from_micros (20)) . precision_exact (0) ,)) . build () . unwrap () ; let metrics = rt . metrics () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; for b in 1 .. num_buckets - 1 { let range = metrics . poll_time_histogram_bucket_range (b) ; let size = range . end - range . start ; assert_eq ! (size , Duration :: from_nanos ((1 << (b - 1)) * 16384) , \"incorrect range for {b}\") ; } assert_eq ! (num_buckets , 10) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 5370933433979373375,
      "kind": "Function",
      "name": "legacy_log_histogram",
      "signature": "fn # [test] # [allow (deprecated)] fn legacy_log_histogram () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_count_histogram_scale (HistogramScale :: Log) . metrics_poll_count_histogram_resolution (Duration :: from_micros (50)) . metrics_poll_count_histogram_buckets (20) . build () . unwrap () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 20) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 8420221455433717122,
      "kind": "Function",
      "name": "log_histogram_default_configuration",
      "signature": "fn # [test] fn log_histogram_default_configuration () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: default () ,)) . build () . unwrap () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 119) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 333563364151571872,
      "kind": "Function",
      "name": "worker_poll_count_histogram",
      "signature": "fn # [test] fn worker_poll_count_histogram () { const N : u64 = 5 ; let rts = [tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () , tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () ,] ; for rt in rts { let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) . await . unwrap () ; } }) ; drop (rt) ; let num_workers = metrics . num_workers () ; let num_buckets = metrics . poll_time_histogram_num_buckets () ; assert ! (metrics . poll_time_histogram_enabled ()) ; assert_eq ! (num_buckets , 3) ; let n = (0 .. num_workers) . flat_map (| i | (0 .. num_buckets) . map (move | j | (i , j))) . map (| (worker , bucket) | metrics . poll_time_histogram_bucket_count (worker , bucket)) . sum () ; assert_eq ! (N , n) ; } } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 5107333556906474539,
      "kind": "Function",
      "name": "worker_poll_count_histogram_range",
      "signature": "fn # [test] fn worker_poll_count_histogram_range () { let max = Duration :: from_nanos (u64 :: MAX) ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (us (50) , 3)) . build () . unwrap () ; let metrics = rt . metrics () ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , us (0) .. us (50)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , us (50) .. us (100)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (2) , us (100) .. max) ; # [allow (deprecated)] let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_count_histogram_scale (tokio :: runtime :: HistogramScale :: Log) . metrics_poll_count_histogram_buckets (3) . metrics_poll_count_histogram_resolution (us (50)) . build () . unwrap () ; let metrics = rt . metrics () ; let a = Duration :: from_nanos (50000_u64 . next_power_of_two ()) ; let b = a * 2 ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , us (0) .. a) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , a .. b) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (2) , b .. max) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 8450388866656479258,
      "kind": "Function",
      "name": "worker_poll_count_histogram_disabled_without_explicit_enable",
      "signature": "fn # [test] fn worker_poll_count_histogram_disabled_without_explicit_enable () { let rts = [tokio :: runtime :: Builder :: new_current_thread () . enable_all () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () , tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () ,] ; for rt in rts { let metrics = rt . metrics () ; assert ! (! metrics . poll_time_histogram_enabled ()) ; } } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 17249217190215975897,
      "kind": "Function",
      "name": "worker_local_schedule_count",
      "signature": "fn # [test] fn worker_local_schedule_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { }) . await . unwrap () ; }) ; drop (rt) ; assert_eq ! (1 , metrics . worker_local_schedule_count (0)) ; assert_eq ! (0 , metrics . remote_schedule_count ()) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { tokio :: spawn (async { }) . await . unwrap () ; }) . await . unwrap () ; }) ; drop (rt) ; let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_local_schedule_count (i)) . sum () ; assert_eq ! (2 , n) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 7693441058573795739,
      "kind": "Function",
      "name": "worker_overflow_count",
      "signature": "fn # [test] fn worker_overflow_count () { let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { let (tx1 , rx1) = std :: sync :: mpsc :: channel () ; let (tx2 , rx2) = std :: sync :: mpsc :: channel () ; tokio :: task :: spawn_blocking (| | { tokio :: spawn (async move { tx1 . send (()) . unwrap () ; rx2 . recv () . unwrap () ; }) ; }) ; rx1 . recv () . unwrap () ; for _ in 0 .. 300 { tokio :: spawn (async { }) ; } tx2 . send (()) . unwrap () ; }) . await . unwrap () ; }) ; drop (rt) ; let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_overflow_count (i)) . sum () ; assert_eq ! (1 , n) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 8324451840253612017,
      "kind": "Function",
      "name": "worker_local_queue_depth",
      "signature": "fn # [test] fn worker_local_queue_depth () { const N : usize = 100 ; let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) ; } assert_eq ! (N , metrics . worker_local_queue_depth (0)) ; }) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async move { tokio :: spawn (async move { let (tx1 , rx1) = std :: sync :: mpsc :: channel () ; let (tx2 , rx2) = std :: sync :: mpsc :: channel () ; tokio :: spawn (async move { tx1 . send (()) . unwrap () ; rx2 . recv () . unwrap () ; }) ; tokio :: spawn (async { }) ; rx1 . recv () . unwrap () ; for _ in 0 .. 100 { tokio :: spawn (async { }) ; } let n : usize = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_local_queue_depth (i)) . sum () ; assert_eq ! (n , N) ; tx2 . send (()) . unwrap () ; }) . await . unwrap () ; }) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 4472050091359441608,
      "kind": "Function",
      "name": "budget_exhaustion_yield",
      "signature": "fn # [test] fn budget_exhaustion_yield () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . budget_forced_yield_count ()) ; let mut did_yield = false ; rt . block_on (poll_fn (| cx | loop { if did_yield { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield = true ; return Poll :: Pending ; } })) ; assert_eq ! (1 , rt . metrics () . budget_forced_yield_count ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 4090868430259822962,
      "kind": "Function",
      "name": "budget_exhaustion_yield_with_joins",
      "signature": "fn # [test] fn budget_exhaustion_yield_with_joins () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . budget_forced_yield_count ()) ; let mut did_yield_1 = false ; let mut did_yield_2 = false ; rt . block_on (async { tokio :: join ! (poll_fn (| cx | loop { if did_yield_1 { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield_1 = true ; return Poll :: Pending ; } }) , poll_fn (| cx | loop { if did_yield_2 { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield_2 = true ; return Poll :: Pending ; } })) }) ; assert_eq ! (1 , rt . metrics () . budget_forced_yield_count ()) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 15850626178657318216,
      "kind": "Function",
      "name": "io_driver_fd_count",
      "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"macos\"))] # [test] fn io_driver_fd_count () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (metrics . io_driver_fd_registered_count () , 0) ; let stream = tokio :: net :: TcpStream :: connect (\"google.com:80\") ; let stream = rt . block_on (async move { stream . await . unwrap () }) ; assert_eq ! (metrics . io_driver_fd_registered_count () , 1) ; assert_eq ! (metrics . io_driver_fd_deregistered_count () , 0) ; drop (stream) ; assert_eq ! (metrics . io_driver_fd_deregistered_count () , 1) ; assert_eq ! (metrics . io_driver_fd_registered_count () , 1) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 13025625805354957949,
      "kind": "Function",
      "name": "io_driver_ready_count",
      "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"macos\"))] # [test] fn io_driver_ready_count () { let rt = current_thread () ; let metrics = rt . metrics () ; let stream = tokio :: net :: TcpStream :: connect (\"google.com:80\") ; let _stream = rt . block_on (async move { stream . await . unwrap () }) ; assert_eq ! (metrics . io_driver_ready_count () , 1) ; } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 2024183281334094928,
      "kind": "Function",
      "name": "try_spawn_stealable_task",
      "signature": "fn async fn try_spawn_stealable_task () -> Result < () , mpsc :: RecvTimeoutError > { let (tx , rx) = mpsc :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (()) . unwrap () ; }) ; rx . recv_timeout (Duration :: from_secs (1)) }) . await . unwrap () ? ; Ok (()) } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 6262297364335455895,
      "kind": "Function",
      "name": "threaded_no_lifo",
      "signature": "fn fn threaded_no_lifo () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . disable_lifo_slot () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 13640786847208732371,
      "kind": "Function",
      "name": "us",
      "signature": "fn fn us (n : u64) -> Duration { Duration :: from_micros (n) } . sig",
      "file_path": "tokio/tests/rt_unstable_metrics.rs",
      "line": 0
    },
    {
      "hash": 9317806446871635444,
      "kind": "Function",
      "name": "ctrl_c",
      "signature": "fn # [tokio :: test] async fn ctrl_c () { let ctrl_c = signal :: ctrl_c () ; tokio :: spawn (async { send_signal (libc :: SIGINT) ; }) ; assert_ok ! (ctrl_c . await) ; } . sig",
      "file_path": "tokio/tests/signal_ctrl_c.rs",
      "line": 0
    },
    {
      "hash": 11116343738403426836,
      "kind": "Function",
      "name": "drop_then_get_a_signal",
      "signature": "fn # [tokio :: test] async fn drop_then_get_a_signal () { let kind = SignalKind :: user_defined1 () ; let sig = signal (kind) . expect (\"failed to create first signal\") ; drop (sig) ; send_signal (libc :: SIGUSR1) ; let mut sig = signal (kind) . expect (\"failed to create second signal\") ; let _ = sig . recv () . await ; } . sig",
      "file_path": "tokio/tests/signal_drop_recv.rs",
      "line": 0
    },
    {
      "hash": 14748676689431403627,
      "kind": "Function",
      "name": "dropping_loops_does_not_cause_starvation",
      "signature": "fn # [test] fn dropping_loops_does_not_cause_starvation () { let kind = SignalKind :: user_defined1 () ; let first_rt = rt () ; let mut first_signal = first_rt . block_on (async { signal (kind) . expect (\"failed to register first signal\") }) ; let second_rt = rt () ; let mut second_signal = second_rt . block_on (async { signal (kind) . expect (\"failed to register second signal\") }) ; send_signal (libc :: SIGUSR1) ; first_rt . block_on (first_signal . recv ()) . expect (\"failed to await first signal\") ; drop (first_rt) ; drop (first_signal) ; send_signal (libc :: SIGUSR1) ; second_rt . block_on (second_signal . recv ()) ; } . sig",
      "file_path": "tokio/tests/signal_drop_rt.rs",
      "line": 0
    },
    {
      "hash": 11743482645915521627,
      "kind": "Function",
      "name": "dropping_signal_does_not_deregister_any_other_instances",
      "signature": "fn # [tokio :: test] async fn dropping_signal_does_not_deregister_any_other_instances () { let kind = SignalKind :: user_defined1 () ; let first_duplicate_signal = signal (kind) . expect (\"failed to register first duplicate signal\") ; let mut sig = signal (kind) . expect (\"failed to register signal\") ; let second_duplicate_signal = signal (kind) . expect (\"failed to register second duplicate signal\") ; drop (first_duplicate_signal) ; drop (second_duplicate_signal) ; send_signal (libc :: SIGUSR1) ; let _ = sig . recv () . await ; } . sig",
      "file_path": "tokio/tests/signal_drop_signal.rs",
      "line": 0
    },
    {
      "hash": 15809924907893403360,
      "kind": "Function",
      "name": "siginfo",
      "signature": "fn # [tokio :: test] async fn siginfo () { let mut sig = signal :: unix :: signal (SignalKind :: info ()) . expect (\"installed signal handler\") ; tokio :: spawn (async { send_signal (libc :: SIGINFO) ; }) ; timeout (Duration :: from_secs (5) , sig . recv ()) . await . expect (\"received SIGINFO signal in time\") . expect (\"received SIGINFO signal\") ; } . sig",
      "file_path": "tokio/tests/signal_info.rs",
      "line": 0
    },
    {
      "hash": 6183312403086969499,
      "kind": "Function",
      "name": "multi_loop",
      "signature": "fn # [test] fn multi_loop () { let (sender , receiver) = channel () ; for _ in 0 .. 10 { let threads : Vec < _ > = (0 .. 4) . map (| _ | { let sender = sender . clone () ; thread :: spawn (move | | { let rt = rt () ; let _ = rt . block_on (async { let mut signal = signal (SignalKind :: hangup ()) . unwrap () ; sender . send (()) . unwrap () ; signal . recv () . await }) ; }) }) . collect () ; for & _ in threads . iter () { receiver . recv () . unwrap () ; } send_signal (libc :: SIGHUP) ; for t in threads { t . join () . unwrap () ; } } } . sig",
      "file_path": "tokio/tests/signal_multi_rt.rs",
      "line": 0
    },
    {
      "hash": 16464120108767702362,
      "kind": "Function",
      "name": "no_runtime_panics_creating_signals",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [test] # [should_panic] fn no_runtime_panics_creating_signals () { let _ = signal (SignalKind :: hangup ()) ; } . sig",
      "file_path": "tokio/tests/signal_no_rt.rs",
      "line": 0
    },
    {
      "hash": 8306540198530639228,
      "kind": "Function",
      "name": "notify_both",
      "signature": "fn # [tokio :: test] async fn notify_both () { let kind = SignalKind :: user_defined2 () ; let mut signal1 = signal (kind) . expect (\"failed to create signal1\") ; let mut signal2 = signal (kind) . expect (\"failed to create signal2\") ; send_signal (libc :: SIGUSR2) ; signal1 . recv () . await ; signal2 . recv () . await ; } . sig",
      "file_path": "tokio/tests/signal_notify_both.rs",
      "line": 0
    },
    {
      "hash": 14674580658951912839,
      "kind": "Function",
      "name": "signal_panic_caller",
      "signature": "fn # [test] fn signal_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let kind = SignalKind :: from_raw (- 1) ; let _ = signal (kind) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/signal_panic.rs",
      "line": 0
    },
    {
      "hash": 12036587199103545040,
      "kind": "Function",
      "name": "signal_realtime",
      "signature": "fn # [tokio :: test] async fn signal_realtime () { let signals = (libc :: SIGRTMIN () ..= sigrt_max ()) . map (| signum | { let sig = assert_ok ! (signal (SignalKind :: from_raw (signum)) , \"failed to create signal for {}\" , sigrtnum_to_string (signum) ,) ; (signum , sig) }) . collect :: < Vec < _ > > () ; eprintln ! (\"registered {} signals in the range {}..={}\" , signals . len () , libc :: SIGRTMIN () , libc :: SIGRTMAX ()) ; for signum in libc :: SIGRTMIN () ..= sigrt_max () { send_signal (signum) ; } let futures = signals . into_iter () . map (| (signum , mut sig) | async move { let res = sig . recv () . await ; (signum , res) }) . collect :: < FuturesUnordered < _ > > () ; let sleep = std :: pin :: pin ! (sleep (Duration :: from_secs (5))) ; let done = futures . take_until (sleep) . collect :: < HashMap < _ , _ > > () . await ; let mut none = Vec :: new () ; let mut missing = Vec :: new () ; for signum in libc :: SIGRTMIN () ..= sigrt_max () { match done . get (& signum) { Some (Some (())) => { } Some (None) => none . push (signum) , None => missing . push (signum) , } } if none . is_empty () && missing . is_empty () { return ; } let mut msg = String :: new () ; if ! none . is_empty () { msg . push_str (\"no signals received for:\\n\") ; for signum in none { msg . push_str (& format ! (\"- {}\\n\" , sigrtnum_to_string (signum))) ; } } if ! missing . is_empty () { msg . push_str (\"missing signals for:\\n\") ; for signum in missing { msg . push_str (& format ! (\"- {}\\n\" , sigrtnum_to_string (signum))) ; } } panic ! (\"{}\" , msg) ; } . sig",
      "file_path": "tokio/tests/signal_realtime.rs",
      "line": 0
    },
    {
      "hash": 9867819986236470652,
      "kind": "Function",
      "name": "sigrt_max",
      "signature": "fn fn sigrt_max () -> c_int { libc :: SIGRTMAX () . min (libc :: SIGRTMIN () + 27) } . sig",
      "file_path": "tokio/tests/signal_realtime.rs",
      "line": 0
    },
    {
      "hash": 10460680514572133473,
      "kind": "Function",
      "name": "sigrtnum_to_string",
      "signature": "fn fn sigrtnum_to_string (signum : i32) -> String { format ! (\"SIGRTMIN+{} (signal {})\" , signum - libc :: SIGRTMIN () , signum) } . sig",
      "file_path": "tokio/tests/signal_realtime.rs",
      "line": 0
    },
    {
      "hash": 6977366463625205571,
      "kind": "Function",
      "name": "twice",
      "signature": "fn # [tokio :: test] async fn twice () { let kind = SignalKind :: user_defined1 () ; let mut sig = signal (kind) . expect (\"failed to get signal\") ; for _ in 0 .. 2 { send_signal (libc :: SIGUSR1) ; assert ! (sig . recv () . await . is_some ()) ; } } . sig",
      "file_path": "tokio/tests/signal_twice.rs",
      "line": 0
    },
    {
      "hash": 1163632000315862587,
      "kind": "Function",
      "name": "signal_usr1",
      "signature": "fn # [tokio :: test] async fn signal_usr1 () { let mut signal = assert_ok ! (signal (SignalKind :: user_defined1 ()) , \"failed to create signal\") ; send_signal (libc :: SIGUSR1) ; signal . recv () . await ; } . sig",
      "file_path": "tokio/tests/signal_usr1.rs",
      "line": 0
    },
    {
      "hash": 4301456319344566682,
      "kind": "Struct",
      "name": "IsSend",
      "signature": "struct IsSend",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 12917508169724229361,
      "kind": "Function",
      "name": "barrier_future_is_send",
      "signature": "fn # [test] fn barrier_future_is_send () { let b = Barrier :: new (0) ; IsSend (b . wait ()) ; } . sig",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 6565092299764854779,
      "kind": "Function",
      "name": "zero_does_not_block",
      "signature": "fn # [test] fn zero_does_not_block () { let b = Barrier :: new (0) ; { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } } . sig",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 220457495757576835,
      "kind": "Function",
      "name": "single",
      "signature": "fn # [test] fn single () { let b = Barrier :: new (1) ; { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } } . sig",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 11346217193550792434,
      "kind": "Function",
      "name": "tango",
      "signature": "fn # [test] fn tango () { let b = Barrier :: new (2) ; let mut w1 = spawn (b . wait ()) ; assert_pending ! (w1 . poll ()) ; let mut w2 = spawn (b . wait ()) ; let wr2 = assert_ready ! (w2 . poll ()) ; let wr1 = assert_ready ! (w1 . poll ()) ; assert ! (wr1 . is_leader () || wr2 . is_leader ()) ; assert ! (! (wr1 . is_leader () && wr2 . is_leader ())) ; } . sig",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 14819180380642775960,
      "kind": "Function",
      "name": "lots",
      "signature": "fn # [test] fn lots () { let b = Barrier :: new (100) ; for _ in 0 .. 10 { let mut wait = Vec :: new () ; for _ in 0 .. 99 { let mut w = spawn (b . wait ()) ; assert_pending ! (w . poll ()) ; wait . push (w) ; } for w in & mut wait { assert_pending ! (w . poll ()) ; } let mut w = spawn (b . wait ()) ; let mut found_leader = assert_ready ! (w . poll ()) . is_leader () ; for mut w in wait { let wr = assert_ready ! (w . poll ()) ; if wr . is_leader () { assert ! (! found_leader) ; found_leader = true ; } } assert ! (found_leader) ; } } . sig",
      "file_path": "tokio/tests/sync_barrier.rs",
      "line": 0
    },
    {
      "hash": 4757549829480395352,
      "kind": "Function",
      "name": "send_try_recv_bounded",
      "signature": "fn # [test] fn send_try_recv_bounded () { let (tx , mut rx) = broadcast :: channel (16) ; assert_empty ! (rx) ; let n = assert_ok ! (tx . send (\"hello\")) ; assert_eq ! (n , 1) ; let val = assert_recv ! (rx) ; assert_eq ! (val , \"hello\") ; assert_empty ! (rx) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 9793340567791897762,
      "kind": "Function",
      "name": "send_two_recv",
      "signature": "fn # [test] fn send_two_recv () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; assert_empty ! (rx1) ; assert_empty ! (rx2) ; let n = assert_ok ! (tx . send (\"hello\")) ; assert_eq ! (n , 2) ; let val = assert_recv ! (rx1) ; assert_eq ! (val , \"hello\") ; let val = assert_recv ! (rx2) ; assert_eq ! (val , \"hello\") ; assert_empty ! (rx1) ; assert_empty ! (rx2) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 16395743234374519327,
      "kind": "Function",
      "name": "send_recv_bounded",
      "signature": "fn # [test] fn send_recv_bounded () { let (tx , mut rx) = broadcast :: channel (16) ; let mut recv = task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; assert_ok ! (tx . send (\"hello\")) ; assert ! (recv . is_woken ()) ; let val = assert_ready_ok ! (recv . poll ()) ; assert_eq ! (val , \"hello\") ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 7056765094823041765,
      "kind": "Function",
      "name": "send_two_recv_bounded",
      "signature": "fn # [test] fn send_two_recv_bounded () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; assert_ok ! (tx . send (\"hello\")) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; let val1 = assert_ready_ok ! (recv1 . poll ()) ; let val2 = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val1 , \"hello\") ; assert_eq ! (val2 , \"hello\") ; drop ((recv1 , recv2)) ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_ok ! (tx . send (\"world\")) ; assert ! (recv1 . is_woken ()) ; assert ! (! recv2 . is_woken ()) ; let val1 = assert_ready_ok ! (recv1 . poll ()) ; let val2 = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val1 , \"world\") ; assert_eq ! (val2 , \"world\") ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 10778199346451613899,
      "kind": "Function",
      "name": "change_tasks",
      "signature": "fn # [test] fn change_tasks () { let (tx , mut rx) = broadcast :: channel (1) ; let mut recv = Box :: pin (rx . recv ()) ; let mut task1 = task :: spawn (& mut recv) ; assert_pending ! (task1 . poll ()) ; let mut task2 = task :: spawn (& mut recv) ; assert_pending ! (task2 . poll ()) ; tx . send (\"hello\") . unwrap () ; assert ! (task2 . is_woken ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 4686172269702243474,
      "kind": "Function",
      "name": "send_slow_rx",
      "signature": "fn # [test] fn send_slow_rx () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; { let mut recv2 = task :: spawn (rx2 . recv ()) ; { let mut recv1 = task :: spawn (rx1 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; assert_ok ! (tx . send (\"one\")) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; assert_ok ! (tx . send (\"two\")) ; let val = assert_ready_ok ! (recv1 . poll ()) ; assert_eq ! (val , \"one\") ; } let val = assert_ready_ok ! (task :: spawn (rx1 . recv ()) . poll ()) ; assert_eq ! (val , \"two\") ; let mut recv1 = task :: spawn (rx1 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_ok ! (tx . send (\"three\")) ; assert ! (recv1 . is_woken ()) ; let val = assert_ready_ok ! (recv1 . poll ()) ; assert_eq ! (val , \"three\") ; let val = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val , \"one\") ; } let val = assert_recv ! (rx2) ; assert_eq ! (val , \"two\") ; let val = assert_recv ! (rx2) ; assert_eq ! (val , \"three\") ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 8622628272577732838,
      "kind": "Function",
      "name": "drop_rx_while_values_remain",
      "signature": "fn # [test] fn drop_rx_while_values_remain () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_recv ! (rx1) ; assert_recv ! (rx2) ; drop (rx2) ; drop (rx1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 5594659905646370389,
      "kind": "Function",
      "name": "lagging_rx",
      "signature": "fn # [test] fn lagging_rx () { let (tx , mut rx1) = broadcast :: channel (2) ; let mut rx2 = tx . subscribe () ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_eq ! (\"one\" , assert_recv ! (rx1)) ; assert_ok ! (tx . send (\"three\")) ; let x = dbg ! (rx2 . try_recv ()) ; assert_lagged ! (x , 1) ; assert_eq ! (\"two\" , assert_recv ! (rx2)) ; assert_eq ! (\"two\" , assert_recv ! (rx1)) ; assert_eq ! (\"three\" , assert_recv ! (rx1)) ; assert_ok ! (tx . send (\"four\")) ; assert_ok ! (tx . send (\"five\")) ; assert_lagged ! (rx2 . try_recv () , 1) ; assert_ok ! (tx . send (\"six\")) ; assert_lagged ! (rx2 . try_recv () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 4751844652707440593,
      "kind": "Function",
      "name": "send_no_rx",
      "signature": "fn # [test] fn send_no_rx () { let (tx , _) = broadcast :: channel (16) ; assert_err ! (tx . send (\"hello\")) ; let mut rx = tx . subscribe () ; assert_ok ! (tx . send (\"world\")) ; let val = assert_recv ! (rx) ; assert_eq ! (\"world\" , val) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 13771468165087243974,
      "kind": "Function",
      "name": "zero_capacity",
      "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn zero_capacity () { broadcast :: channel :: < () > (0) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 13792576765082365230,
      "kind": "Function",
      "name": "capacity_too_big",
      "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn capacity_too_big () { broadcast :: channel :: < () > (1 + (usize :: MAX >> 1)) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 1220036475440340048,
      "kind": "Function",
      "name": "panic_in_clone",
      "signature": "fn # [test] # [cfg (panic = \"unwind\")] # [cfg (not (target_family = \"wasm\"))] fn panic_in_clone () { use std :: panic :: { self , AssertUnwindSafe } ; # [derive (Eq , PartialEq , Debug)] struct MyVal (usize) ; impl Clone for MyVal { fn clone (& self) -> MyVal { assert_ne ! (0 , self . 0) ; MyVal (self . 0) } } let (tx , mut rx) = broadcast :: channel (16) ; assert_ok ! (tx . send (MyVal (0))) ; assert_ok ! (tx . send (MyVal (1))) ; let res = panic :: catch_unwind (AssertUnwindSafe (| | { let _ = rx . try_recv () ; })) ; assert_err ! (res) ; let val = assert_recv ! (rx) ; assert_eq ! (val , MyVal (1)) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 15885656395436648870,
      "kind": "Function",
      "name": "dropping_tx_notifies_rx",
      "signature": "fn # [test] fn dropping_tx_notifies_rx () { let (tx , mut rx1) = broadcast :: channel :: < () > (16) ; let mut rx2 = tx . subscribe () ; let tx2 = tx . clone () ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; drop (tx) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; drop (tx2) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; let err = assert_ready_err ! (recv1 . poll ()) ; assert ! (is_closed (err)) ; let err = assert_ready_err ! (recv2 . poll ()) ; assert ! (is_closed (err)) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 1010178706494639007,
      "kind": "Function",
      "name": "unconsumed_messages_are_dropped",
      "signature": "fn # [test] fn unconsumed_messages_are_dropped () { let (tx , rx) = broadcast :: channel (16) ; let msg = Arc :: new (()) ; assert_ok ! (tx . send (msg . clone ())) ; assert_eq ! (2 , Arc :: strong_count (& msg)) ; drop (rx) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 17981947475614052587,
      "kind": "Function",
      "name": "single_capacity_recvs",
      "signature": "fn # [test] fn single_capacity_recvs () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_empty ! (rx) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 11954970828671393472,
      "kind": "Function",
      "name": "single_capacity_recvs_after_drop_1",
      "signature": "fn # [test] fn single_capacity_recvs_after_drop_1 () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; drop (tx) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_closed ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 9797990380250773143,
      "kind": "Function",
      "name": "single_capacity_recvs_after_drop_2",
      "signature": "fn # [test] fn single_capacity_recvs_after_drop_2 () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_closed ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 16995143910768647619,
      "kind": "Function",
      "name": "dropping_sender_does_not_overwrite",
      "signature": "fn # [test] fn dropping_sender_does_not_overwrite () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; drop (tx) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_closed ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 8617172917268906974,
      "kind": "Function",
      "name": "lagging_receiver_recovers_after_wrap_closed_1",
      "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_closed_1 () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_closed ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 3659440195241367000,
      "kind": "Function",
      "name": "lagging_receiver_recovers_after_wrap_closed_2",
      "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_closed_2 () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; assert_ok ! (tx . send (4)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_eq ! (assert_recv ! (rx) , 4) ; assert_closed ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 8801282602984334659,
      "kind": "Function",
      "name": "lagging_receiver_recovers_after_wrap_open",
      "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_open () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_empty ! (rx) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 17528918561471666252,
      "kind": "Function",
      "name": "receiver_len_with_lagged",
      "signature": "fn # [test] fn receiver_len_with_lagged () { let (tx , mut rx) = broadcast :: channel (3) ; tx . send (10) . unwrap () ; tx . send (20) . unwrap () ; tx . send (30) . unwrap () ; tx . send (40) . unwrap () ; assert_eq ! (rx . len () , 4) ; assert_eq ! (assert_recv ! (rx) , 10) ; tx . send (50) . unwrap () ; tx . send (60) . unwrap () ; assert_eq ! (rx . len () , 5) ; assert_lagged ! (rx . try_recv () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 14927352278717464072,
      "kind": "Function",
      "name": "is_closed",
      "signature": "fn fn is_closed (err : broadcast :: error :: RecvError) -> bool { matches ! (err , broadcast :: error :: RecvError :: Closed) } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 7554080994029739348,
      "kind": "Function",
      "name": "resubscribe_points_to_tail",
      "signature": "fn # [test] fn resubscribe_points_to_tail () { let (tx , mut rx) = broadcast :: channel (3) ; tx . send (1) . unwrap () ; let mut rx_resub = rx . resubscribe () ; assert_empty ! (rx_resub) ; assert_eq ! (assert_recv ! (rx) , 1) ; tx . send (2) . unwrap () ; assert_eq ! (assert_recv ! (rx_resub) , 2) ; tx . send (3) . unwrap () ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_empty ! (rx) ; assert_eq ! (assert_recv ! (rx_resub) , 3) ; assert_empty ! (rx_resub) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 18380067800380369525,
      "kind": "Function",
      "name": "resubscribe_lagged",
      "signature": "fn # [test] fn resubscribe_lagged () { let (tx , mut rx) = broadcast :: channel (1) ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut rx_resub = rx . resubscribe () ; assert_lagged ! (rx . try_recv () , 1) ; assert_empty ! (rx_resub) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_empty ! (rx) ; assert_empty ! (rx_resub) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 4993694405138247403,
      "kind": "Function",
      "name": "resubscribe_to_closed_channel",
      "signature": "fn # [test] fn resubscribe_to_closed_channel () { let (tx , rx) = tokio :: sync :: broadcast :: channel :: < u32 > (2) ; drop (tx) ; let mut rx_resub = rx . resubscribe () ; assert_closed ! (rx_resub . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 9099918041955848568,
      "kind": "Function",
      "name": "sender_len",
      "signature": "fn # [test] fn sender_len () { let (tx , mut rx1) = broadcast :: channel (4) ; let mut rx2 = tx . subscribe () ; assert_eq ! (tx . len () , 0) ; assert ! (tx . is_empty ()) ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; tx . send (3) . unwrap () ; assert_eq ! (tx . len () , 3) ; assert ! (! tx . is_empty ()) ; assert_recv ! (rx1) ; assert_recv ! (rx1) ; assert_eq ! (tx . len () , 3) ; assert ! (! tx . is_empty ()) ; assert_recv ! (rx2) ; assert_eq ! (tx . len () , 2) ; assert ! (! tx . is_empty ()) ; tx . send (4) . unwrap () ; tx . send (5) . unwrap () ; tx . send (6) . unwrap () ; assert_eq ! (tx . len () , 4) ; assert ! (! tx . is_empty ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 16200575755677844508,
      "kind": "Function",
      "name": "sender_len_random",
      "signature": "fn # [test] # [cfg (not (all (target_family = \"wasm\" , not (target_os = \"wasi\"))))] fn sender_len_random () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; for _ in 0 .. 1000 { match rand :: random_range (0 .. 4) { 0 => { let _ = rx1 . try_recv () ; } 1 => { let _ = rx2 . try_recv () ; } _ => { tx . send (0) . unwrap () ; } } let expected_len = usize :: min (usize :: max (rx1 . len () , rx2 . len ()) , 16) ; assert_eq ! (tx . len () , expected_len) ; } } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 15809869404017365608,
      "kind": "Function",
      "name": "send_in_waker_drop",
      "signature": "fn # [test] fn send_in_waker_drop () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: task :: Context ; struct SendOnDrop (broadcast :: Sender < () >) ; impl Drop for SendOnDrop { fn drop (& mut self) { let _ = self . 0 . send (()) ; } } impl ArcWake for SendOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } let (tx , mut rx) = broadcast :: channel (16) ; let mut fut = Box :: pin (async { let _ = rx . recv () . await ; }) ; let waker = futures :: task :: waker (Arc :: new (SendOnDrop (tx))) ; let mut cx = Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; drop (waker) ; let mut cx = Context :: from_waker (futures :: task :: noop_waker_ref ()) ; let _ = fut . as_mut () . poll (& mut cx) ; let (tx , mut rx) = broadcast :: channel (16) ; let mut fut = Box :: pin (async { let _ = rx . recv () . await ; }) ; let waker = futures :: task :: waker (Arc :: new (SendOnDrop (tx . clone ()))) ; let mut cx = Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; drop (waker) ; let _ = tx . send (()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 17531347807425558106,
      "kind": "Function",
      "name": "receiver_recv_is_cooperative",
      "signature": "fn # [tokio :: test] async fn receiver_recv_is_cooperative () { let (tx , mut rx) = broadcast :: channel (8) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (()) . is_ok ()) ; assert ! (rx . recv () . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 15102493832123776490,
      "kind": "Function",
      "name": "broadcast_sender_closed",
      "signature": "fn # [test] fn broadcast_sender_closed () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let rx2 = tx . subscribe () ; let mut task = task :: spawn (tx . closed ()) ; assert_pending ! (task . poll ()) ; drop (rx) ; assert ! (! task . is_woken ()) ; assert_pending ! (task . poll ()) ; drop (rx2) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 15395417489384154224,
      "kind": "Function",
      "name": "broadcast_sender_closed_with_extra_subscribe",
      "signature": "fn # [test] fn broadcast_sender_closed_with_extra_subscribe () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let rx2 = tx . subscribe () ; let mut task = task :: spawn (tx . closed ()) ; assert_pending ! (task . poll ()) ; drop (rx) ; assert ! (! task . is_woken ()) ; assert_pending ! (task . poll ()) ; drop (rx2) ; assert ! (task . is_woken ()) ; let rx3 = tx . subscribe () ; assert_pending ! (task . poll ()) ; drop (rx3) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; let mut task2 = task :: spawn (tx . closed ()) ; assert_ready ! (task2 . poll ()) ; let rx4 = tx . subscribe () ; let mut task3 = task :: spawn (tx . closed ()) ; assert_pending ! (task3 . poll ()) ; drop (rx4) ; assert ! (task3 . is_woken ()) ; assert_ready ! (task3 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 6150036476198222162,
      "kind": "Function",
      "name": "broadcast_sender_new_must_be_closed",
      "signature": "fn # [tokio :: test] async fn broadcast_sender_new_must_be_closed () { let capacity = 1 ; let tx : broadcast :: Sender < () > = broadcast :: Sender :: new (capacity) ; let mut task = task :: spawn (tx . closed ()) ; assert_ready ! (task . poll ()) ; let _rx = tx . subscribe () ; let mut task2 = task :: spawn (tx . closed ()) ; assert_pending ! (task2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast.rs",
      "line": 0
    },
    {
      "hash": 13296196294088103246,
      "kind": "Function",
      "name": "weak_sender",
      "signature": "fn # [tokio :: test] async fn weak_sender () { let (tx , mut rx) = channel (11) ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Ok (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } Err (_) => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 12308871217517922423,
      "kind": "Function",
      "name": "downgrade_upgrade_sender_failure",
      "signature": "fn # [test] fn downgrade_upgrade_sender_failure () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 17168086911137423421,
      "kind": "Function",
      "name": "downgrade_drop_upgrade",
      "signature": "fn # [test] fn downgrade_drop_upgrade () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 16811221806362976908,
      "kind": "Function",
      "name": "test_tx_count_weak_sender",
      "signature": "fn # [test] fn test_tx_count_weak_sender () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (tx . weak_count () , 2) ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none ()) ; assert ! (tx_weak2 . upgrade () . is_none ()) ; assert_eq ! (tx_weak . strong_count () , 0) ; assert_eq ! (tx_weak . weak_count () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 13313168554329352110,
      "kind": "Function",
      "name": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = broadcast :: channel :: < () > (10) ; let weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert_eq ! (weak_sender . strong_count () , 0) ; assert_eq ! (weak_sender . weak_count () , 1) ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 12938657461473810245,
      "kind": "Function",
      "name": "sender_strong_count_when_cloned",
      "signature": "fn # [tokio :: test] async fn sender_strong_count_when_cloned () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 18228872055420290737,
      "kind": "Function",
      "name": "sender_weak_count_when_downgraded",
      "signature": "fn # [tokio :: test] async fn sender_weak_count_when_downgraded () { let (tx , _rx) = broadcast :: channel :: < () > (1) ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 18221390563060281757,
      "kind": "Function",
      "name": "sender_strong_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn sender_strong_count_when_dropped () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 7260773495937904408,
      "kind": "Function",
      "name": "sender_weak_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn sender_weak_count_when_dropped () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 18083900357223733116,
      "kind": "Function",
      "name": "sender_strong_and_weak_conut",
      "signature": "fn # [tokio :: test] async fn sender_strong_and_weak_conut () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_broadcast_weak.rs",
      "line": 0
    },
    {
      "hash": 9992595326804955560,
      "kind": "Function",
      "name": "is_error",
      "signature": "fn fn is_error < T : std :: error :: Error + Send + Sync > () { } . sig",
      "file_path": "tokio/tests/sync_errors.rs",
      "line": 0
    },
    {
      "hash": 504089738156405603,
      "kind": "Function",
      "name": "mpsc_error_bound",
      "signature": "fn # [test] fn mpsc_error_bound () { use tokio :: sync :: mpsc :: error ; is_error :: < error :: SendError < () > > () ; is_error :: < error :: TrySendError < () > > () ; } . sig",
      "file_path": "tokio/tests/sync_errors.rs",
      "line": 0
    },
    {
      "hash": 800309581543488772,
      "kind": "Function",
      "name": "oneshot_error_bound",
      "signature": "fn # [test] fn oneshot_error_bound () { use tokio :: sync :: oneshot :: error ; is_error :: < error :: RecvError > () ; is_error :: < error :: TryRecvError > () ; } . sig",
      "file_path": "tokio/tests/sync_errors.rs",
      "line": 0
    },
    {
      "hash": 25997532201000,
      "kind": "Function",
      "name": "watch_error_bound",
      "signature": "fn # [test] fn watch_error_bound () { use tokio :: sync :: watch :: error ; is_error :: < error :: SendError < () > > () ; } . sig",
      "file_path": "tokio/tests/sync_errors.rs",
      "line": 0
    },
    {
      "hash": 4965400430733254705,
      "kind": "Trait",
      "name": "AssertRefUnwindSafe",
      "signature": "trait AssertRefUnwindSafe",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2445510119823751426,
      "kind": "Trait",
      "name": "AssertUnwindSafe",
      "signature": "trait AssertUnwindSafe",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 12371635152359788257,
      "kind": "Function",
      "name": "send_recv_with_buffer",
      "signature": "fn # [maybe_tokio_test] async fn send_recv_with_buffer () { let (tx , mut rx) = mpsc :: channel :: < i32 > (16) ; let permit = tx . reserve () . await . unwrap () ; permit . send (1) ; tx . try_send (2) . unwrap () ; drop (tx) ; let val = rx . recv () . await ; assert_eq ! (val , Some (1)) ; let val = rx . recv () . await ; assert_eq ! (val , Some (2)) ; let val = rx . recv () . await ; assert ! (val . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14623751241579053056,
      "kind": "Function",
      "name": "reserve_disarm",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn reserve_disarm () { let (tx , mut rx) = mpsc :: channel :: < i32 > (2) ; let tx1 = tx . clone () ; let tx2 = tx . clone () ; let tx3 = tx . clone () ; let tx4 = tx ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let permit2 = assert_ok ! (tx2 . reserve () . await) ; let mut r3 = tokio_test :: task :: spawn (tx3 . reserve ()) ; assert_pending ! (r3 . poll ()) ; let mut r4 = tokio_test :: task :: spawn (tx4 . reserve ()) ; assert_pending ! (r4 . poll ()) ; permit1 . send (1) ; assert ! (! r3 . is_woken ()) ; rx . recv () . await . unwrap () ; assert ! (r3 . is_woken ()) ; assert ! (! r4 . is_woken ()) ; drop (permit2) ; assert ! (r4 . is_woken ()) ; let mut r1 = tokio_test :: task :: spawn (tx1 . reserve ()) ; assert_pending ! (r1 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2409184299768751680,
      "kind": "Function",
      "name": "send_recv_stream_with_buffer",
      "signature": "fn # [tokio :: test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] async fn send_recv_stream_with_buffer () { use tokio_stream :: StreamExt ; let (tx , rx) = support :: mpsc_stream :: channel_stream :: < i32 > (16) ; let mut rx = Box :: pin (rx) ; tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; }) ; assert_eq ! (Some (1) , rx . next () . await) ; assert_eq ! (Some (2) , rx . next () . await) ; assert_eq ! (None , rx . next () . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 711067181767323043,
      "kind": "Function",
      "name": "async_send_recv_with_buffer",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_with_buffer () { let (tx , mut rx) = mpsc :: channel (16) ; tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; }) ; assert_eq ! (Some (1) , rx . recv () . await) ; assert_eq ! (Some (2) , rx . recv () . await) ; assert_eq ! (None , rx . recv () . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15289651584815067754,
      "kind": "Function",
      "name": "async_send_recv_many_with_buffer",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_many_with_buffer () { let (tx , mut rx) = mpsc :: channel (2) ; let mut buffer = Vec :: < i32 > :: with_capacity (3) ; assert_eq ! (0 , rx . recv_many (& mut buffer , 0) . await) ; let handle = tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; assert_ok ! (tx . send (7) . await) ; assert_ok ! (tx . send (0) . await) ; }) ; let limit = 3 ; let mut recv_count = 0usize ; while recv_count < 4 { recv_count += rx . recv_many (& mut buffer , limit) . await ; assert_eq ! (buffer . len () , recv_count) ; } assert_eq ! (vec ! [1 , 2 , 7 , 0] , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4062738957065091183,
      "kind": "Function",
      "name": "start_send_past_cap",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn start_send_past_cap () { use std :: future :: Future ; let mut t1 = tokio_test :: task :: spawn (()) ; let (tx1 , mut rx) = mpsc :: channel (1) ; let tx2 = tx1 . clone () ; assert_ok ! (tx1 . try_send (())) ; let mut r1 = Box :: pin (tx1 . reserve ()) ; t1 . enter (| cx , _ | assert_pending ! (r1 . as_mut () . poll (cx))) ; { let mut r2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (r2 . poll ()) ; drop (r1) ; assert ! (rx . recv () . await . is_some ()) ; assert ! (r2 . is_woken ()) ; assert ! (! t1 . is_woken ()) ; } drop (tx1) ; drop (tx2) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9419983061152508405,
      "kind": "Function",
      "name": "buffer_gteq_one",
      "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn buffer_gteq_one () { mpsc :: channel :: < i32 > (0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 12300297821689487363,
      "kind": "Function",
      "name": "send_recv_unbounded",
      "signature": "fn # [maybe_tokio_test] async fn send_recv_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < i32 > () ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_eq ! (rx . recv () . await , Some (1)) ; assert_eq ! (rx . recv () . await , Some (2)) ; drop (tx) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4371966036944484528,
      "kind": "Function",
      "name": "send_recv_many_unbounded",
      "signature": "fn # [maybe_tokio_test] async fn send_recv_many_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < i32 > () ; let mut buffer : Vec < i32 > = Vec :: new () ; rx . recv_many (& mut buffer , 0) . await ; assert_eq ! (0 , buffer . len ()) ; assert_ok ! (tx . send (7)) ; assert_ok ! (tx . send (13)) ; assert_ok ! (tx . send (100)) ; assert_ok ! (tx . send (1002)) ; rx . recv_many (& mut buffer , 0) . await ; assert_eq ! (0 , buffer . len ()) ; let mut count = 0 ; while count < 4 { count += rx . recv_many (& mut buffer , 1) . await ; } assert_eq ! (count , 4) ; assert_eq ! (vec ! [7 , 13 , 100 , 1002] , buffer) ; let final_capacity = buffer . capacity () ; assert ! (final_capacity > 0) ; buffer . clear () ; assert_ok ! (tx . send (5)) ; assert_ok ! (tx . send (6)) ; assert_ok ! (tx . send (7)) ; assert_ok ! (tx . send (2)) ; count = rx . recv_many (& mut buffer , 32) . await ; assert_eq ! (final_capacity , buffer . capacity ()) ; assert_eq ! (count , 4) ; assert_eq ! (vec ! [5 , 6 , 7 , 2] , buffer) ; drop (tx) ; assert_eq ! (0 , rx . recv_many (& mut buffer , 4) . await) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5546680101446206539,
      "kind": "Function",
      "name": "send_recv_many_bounded_capacity",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_many_bounded_capacity () { let mut buffer : Vec < String > = Vec :: with_capacity (9) ; let limit = buffer . capacity () ; let (tx , mut rx) = mpsc :: channel (100) ; let mut expected : Vec < String > = (0 .. limit) . map (| x : usize | format ! (\"{x}\")) . collect :: < Vec < _ > > () ; for x in expected . clone () { tx . send (x) . await . unwrap () } tx . send (\"one more\" . to_string ()) . await . unwrap () ; assert_eq ! (buffer . capacity () , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; assert_eq ! (limit , buffer . capacity ()) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; assert ! (buffer . capacity () > limit) ; expected . push (\"one more\" . to_string ()) ; assert_eq ! (expected , buffer) ; tokio :: spawn (async move { tx . send (\"final\" . to_string ()) . await . unwrap () ; }) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; expected . push (\"final\" . to_string ()) ; assert_eq ! (expected , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3031050287375018117,
      "kind": "Function",
      "name": "send_recv_many_unbounded_capacity",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_many_unbounded_capacity () { let mut buffer : Vec < String > = Vec :: with_capacity (9) ; let limit = buffer . capacity () ; let (tx , mut rx) = mpsc :: unbounded_channel () ; let mut expected : Vec < String > = (0 .. limit) . map (| x : usize | format ! (\"{x}\")) . collect :: < Vec < _ > > () ; for x in expected . clone () { tx . send (x) . unwrap () } tx . send (\"one more\" . to_string ()) . unwrap () ; assert_eq ! (buffer . capacity () , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; assert_eq ! (limit , buffer . capacity ()) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; assert ! (buffer . capacity () > limit) ; expected . push (\"one more\" . to_string ()) ; assert_eq ! (expected , buffer) ; tokio :: spawn (async move { tx . send (\"final\" . to_string ()) . unwrap () ; }) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; expected . push (\"final\" . to_string ()) ; assert_eq ! (expected , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9065201275244311867,
      "kind": "Function",
      "name": "async_send_recv_unbounded",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tokio :: spawn (async move { assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; }) ; assert_eq ! (Some (1) , rx . recv () . await) ; assert_eq ! (Some (2) , rx . recv () . await) ; assert_eq ! (None , rx . recv () . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13178512802766692069,
      "kind": "Function",
      "name": "send_recv_stream_unbounded",
      "signature": "fn # [tokio :: test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] async fn send_recv_stream_unbounded () { use tokio_stream :: StreamExt ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream :: < i32 > () ; let mut rx = Box :: pin (rx) ; tokio :: spawn (async move { assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; }) ; assert_eq ! (Some (1) , rx . next () . await) ; assert_eq ! (Some (2) , rx . next () . await) ; assert_eq ! (None , rx . next () . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7002903034608432110,
      "kind": "Function",
      "name": "no_t_bounds_buffer",
      "signature": "fn # [maybe_tokio_test] async fn no_t_bounds_buffer () { struct NoImpls ; let (tx , mut rx) = mpsc :: channel (100) ; is_debug (& tx) ; is_debug (& rx) ; assert ! (tx . clone () . try_send (NoImpls) . is_ok ()) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 6439588391023935889,
      "kind": "Function",
      "name": "no_t_bounds_unbounded",
      "signature": "fn # [maybe_tokio_test] async fn no_t_bounds_unbounded () { struct NoImpls ; let (tx , mut rx) = mpsc :: unbounded_channel () ; is_debug (& tx) ; is_debug (& rx) ; assert ! (tx . clone () . send (NoImpls) . is_ok ()) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9490603767388570473,
      "kind": "Function",
      "name": "send_recv_buffer_limited",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_buffer_limited () { let (tx , mut rx) = mpsc :: channel :: < i32 > (1) ; let p1 = assert_ok ! (tx . reserve () . await) ; p1 . send (1) ; let mut p2 = tokio_test :: task :: spawn (tx . reserve ()) ; assert_pending ! (p2 . poll ()) ; assert ! (rx . recv () . await . is_some ()) ; assert ! (p2 . is_woken ()) ; assert_err ! (tx . try_send (1337)) ; let permit = assert_ready_ok ! (p2 . poll ()) ; permit . send (2) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 327290669886996158,
      "kind": "Function",
      "name": "recv_close_gets_none_idle",
      "signature": "fn # [maybe_tokio_test] async fn recv_close_gets_none_idle () { let (tx , mut rx) = mpsc :: channel :: < i32 > (10) ; rx . close () ; assert ! (rx . recv () . await . is_none ()) ; assert_err ! (tx . send (1) . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7353046815253914343,
      "kind": "Function",
      "name": "recv_close_gets_none_reserved",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn recv_close_gets_none_reserved () { let (tx1 , mut rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx1 . clone () ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let mut permit2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (permit2 . poll ()) ; rx . close () ; assert ! (permit2 . is_woken ()) ; assert_ready_err ! (permit2 . poll ()) ; { let mut recv = tokio_test :: task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; permit1 . send (123) ; assert ! (recv . is_woken ()) ; let v = assert_ready ! (recv . poll ()) ; assert_eq ! (v , Some (123)) ; } assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11629466873034937373,
      "kind": "Function",
      "name": "tx_close_gets_none",
      "signature": "fn # [maybe_tokio_test] async fn tx_close_gets_none () { let (_ , mut rx) = mpsc :: channel :: < i32 > (10) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10874359309206987120,
      "kind": "Function",
      "name": "try_send_fail",
      "signature": "fn # [maybe_tokio_test] async fn try_send_fail () { let (tx , mut rx) = mpsc :: channel (1) ; tx . try_send (\"hello\") . unwrap () ; match assert_err ! (tx . try_send (\"fail\")) { TrySendError :: Full (..) => { } _ => panic ! () , } assert_eq ! (rx . recv () . await , Some (\"hello\")) ; assert_ok ! (tx . try_send (\"goodbye\")) ; drop (tx) ; assert_eq ! (rx . recv () . await , Some (\"goodbye\")) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15112682995221348330,
      "kind": "Function",
      "name": "try_send_fail_with_try_recv",
      "signature": "fn # [maybe_tokio_test] async fn try_send_fail_with_try_recv () { let (tx , mut rx) = mpsc :: channel (1) ; tx . try_send (\"hello\") . unwrap () ; match assert_err ! (tx . try_send (\"fail\")) { TrySendError :: Full (..) => { } _ => panic ! () , } assert_eq ! (rx . try_recv () , Ok (\"hello\")) ; assert_ok ! (tx . try_send (\"goodbye\")) ; drop (tx) ; assert_eq ! (rx . try_recv () , Ok (\"goodbye\")) ; assert_eq ! (rx . try_recv () , Err (TryRecvError :: Disconnected)) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5798528615206534367,
      "kind": "Function",
      "name": "reserve_many_above_cap",
      "signature": "fn # [maybe_tokio_test] async fn reserve_many_above_cap () { const MAX_PERMITS : usize = tokio :: sync :: Semaphore :: MAX_PERMITS ; let (tx , _rx) = mpsc :: channel :: < () > (1) ; assert_err ! (tx . reserve_many (2) . await) ; assert_err ! (tx . reserve_many (MAX_PERMITS + 1) . await) ; assert_err ! (tx . reserve_many (usize :: MAX) . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7798058822201841970,
      "kind": "Function",
      "name": "try_reserve_many_zero",
      "signature": "fn # [test] fn try_reserve_many_zero () { let (tx , rx) = mpsc :: channel :: < () > (1) ; assert ! (assert_ok ! (tx . try_reserve_many (0)) . next () . is_none ()) ; tx . try_send (()) . unwrap () ; assert ! (assert_ok ! (tx . try_reserve_many (0)) . next () . is_none ()) ; drop (rx) ; assert_eq ! (assert_err ! (tx . try_reserve_many (0)) , TrySendError :: Closed (())) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1376192805692503583,
      "kind": "Function",
      "name": "reserve_many_zero",
      "signature": "fn # [maybe_tokio_test] async fn reserve_many_zero () { let (tx , rx) = mpsc :: channel :: < () > (1) ; assert ! (assert_ok ! (tx . reserve_many (0) . await) . next () . is_none ()) ; tx . send (()) . await . unwrap () ; assert ! (assert_ok ! (tx . reserve_many (0) . await) . next () . is_none ()) ; drop (rx) ; assert_err ! (tx . reserve_many (0) . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4951688199816888498,
      "kind": "Function",
      "name": "try_reserve_many_edge_cases",
      "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_edge_cases () { const MAX_PERMITS : usize = tokio :: sync :: Semaphore :: MAX_PERMITS ; let (tx , rx) = mpsc :: channel :: < () > (1) ; let mut permit = assert_ok ! (tx . try_reserve_many (0)) ; assert ! (permit . next () . is_none ()) ; let permit = tx . try_reserve_many (MAX_PERMITS + 1) ; match assert_err ! (permit) { TrySendError :: Full (..) => { } _ => panic ! () , } let permit = tx . try_reserve_many (usize :: MAX) ; match assert_err ! (permit) { TrySendError :: Full (..) => { } _ => panic ! () , } drop (rx) ; assert_err ! (tx . reserve_many (0) . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9906158502494845230,
      "kind": "Function",
      "name": "try_reserve_fails",
      "signature": "fn # [maybe_tokio_test] async fn try_reserve_fails () { let (tx , mut rx) = mpsc :: channel (1) ; let permit = tx . try_reserve () . unwrap () ; match assert_err ! (tx . try_reserve ()) { TrySendError :: Full (()) => { } _ => panic ! () , } permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; let permit = tx . try_reserve () . unwrap () ; drop (permit) ; let _permit = tx . try_reserve () . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3195782451944382813,
      "kind": "Function",
      "name": "reserve_many_and_send",
      "signature": "fn # [maybe_tokio_test] async fn reserve_many_and_send () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { for permit in assert_ok ! (tx . reserve_many (i) . await) { permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13679494429102567532,
      "kind": "Function",
      "name": "try_reserve_many_and_send",
      "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_and_send () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { for permit in assert_ok ! (tx . try_reserve_many (i)) { permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 9616417842502596994,
      "kind": "Function",
      "name": "reserve_many_on_closed_channel",
      "signature": "fn # [maybe_tokio_test] async fn reserve_many_on_closed_channel () { let (tx , rx) = mpsc :: channel :: < () > (100) ; drop (rx) ; assert_err ! (tx . reserve_many (10) . await) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11648397641087044714,
      "kind": "Function",
      "name": "try_reserve_many_on_closed_channel",
      "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_on_closed_channel () { let (tx , rx) = mpsc :: channel :: < usize > (100) ; drop (rx) ; match assert_err ! (tx . try_reserve_many (10)) { TrySendError :: Closed (()) => { } _ => panic ! () , } ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1874978602056286977,
      "kind": "Function",
      "name": "try_reserve_many_full",
      "signature": "fn # [maybe_tokio_test] # [cfg_attr (miri , ignore)] async fn try_reserve_many_full () { for n in 1 .. 100 { for k in 0 .. n { let (tx , mut rx) = mpsc :: channel :: < usize > (n) ; let permits = assert_ok ! (tx . try_reserve_many (n)) ; assert_eq ! (permits . len () , n) ; assert_eq ! (tx . capacity () , 0) ; match assert_err ! (tx . try_reserve_many (1)) { TrySendError :: Full (..) => { } _ => panic ! () , } ; for permit in permits . take (k) { permit . send (0) ; } assert_eq ! (tx . capacity () , n - k) ; assert_ok ! (tx . try_reserve_many (1)) ; match assert_err ! (tx . try_reserve_many (n - k + 1)) { TrySendError :: Full (..) => { } _ => panic ! () , } ; for _i in 0 .. k { assert_eq ! (rx . recv () . await , Some (0)) ; } assert_eq ! (tx . capacity () , n) ; } } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2597540929856106379,
      "kind": "Function",
      "name": "drop_permit_releases_permit",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn drop_permit_releases_permit () { let (tx1 , _rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx1 . clone () ; let permit = assert_ok ! (tx1 . reserve () . await) ; let mut reserve2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (reserve2 . poll ()) ; drop (permit) ; assert ! (reserve2 . is_woken ()) ; assert_ready_ok ! (reserve2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15280991132715696852,
      "kind": "Function",
      "name": "drop_permit_iterator_releases_permits",
      "signature": "fn # [maybe_tokio_test] async fn drop_permit_iterator_releases_permits () { for n in 1 .. 100 { let (tx1 , _rx) = mpsc :: channel :: < i32 > (n) ; let tx2 = tx1 . clone () ; let permits = assert_ok ! (tx1 . reserve_many (n) . await) ; let mut reserve2 = tokio_test :: task :: spawn (tx2 . reserve_many (n)) ; assert_pending ! (reserve2 . poll ()) ; drop (permits) ; assert ! (reserve2 . is_woken ()) ; let permits = assert_ready_ok ! (reserve2 . poll ()) ; drop (permits) ; assert_eq ! (tx1 . capacity () , n) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5300634012668009775,
      "kind": "Function",
      "name": "dropping_rx_closes_channel",
      "signature": "fn # [maybe_tokio_test] async fn dropping_rx_closes_channel () { let (tx , rx) = mpsc :: channel (100) ; let msg = Arc :: new (()) ; assert_ok ! (tx . try_send (msg . clone ())) ; drop (rx) ; assert_err ! (tx . reserve () . await) ; assert_err ! (tx . reserve_many (10) . await) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 18162900537507256128,
      "kind": "Function",
      "name": "dropping_rx_closes_channel_for_try",
      "signature": "fn # [test] fn dropping_rx_closes_channel_for_try () { let (tx , rx) = mpsc :: channel (100) ; let msg = Arc :: new (()) ; tx . try_send (msg . clone ()) . unwrap () ; drop (rx) ; assert ! (matches ! (tx . try_send (msg . clone ()) , Err (TrySendError :: Closed (_)))) ; assert ! (matches ! (tx . try_reserve () , Err (TrySendError :: Closed (_)))) ; assert ! (matches ! (tx . try_reserve_owned () , Err (TrySendError :: Closed (_)))) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15138299610468672290,
      "kind": "Function",
      "name": "unconsumed_messages_are_dropped",
      "signature": "fn # [test] fn unconsumed_messages_are_dropped () { let msg = Arc :: new (()) ; let (tx , rx) = mpsc :: channel (100) ; tx . try_send (msg . clone ()) . unwrap () ; assert_eq ! (2 , Arc :: strong_count (& msg)) ; drop ((tx , rx)) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11923128687934377112,
      "kind": "Function",
      "name": "blocking_recv",
      "signature": "fn # [test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] fn blocking_recv () { let (tx , mut rx) = mpsc :: channel :: < u8 > (1) ; let sync_code = std :: thread :: spawn (move | | { assert_eq ! (Some (10) , rx . blocking_recv ()) ; }) ; tokio :: runtime :: Runtime :: new () . unwrap () . block_on (async move { let _ = tx . send (10) . await ; }) ; sync_code . join () . unwrap () } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7885676817637531712,
      "kind": "Function",
      "name": "blocking_recv_async",
      "signature": "fn # [tokio :: test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] async fn blocking_recv_async () { let (_tx , mut rx) = mpsc :: channel :: < () > (1) ; let _ = rx . blocking_recv () ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13481305450234030381,
      "kind": "Function",
      "name": "blocking_send",
      "signature": "fn # [test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] fn blocking_send () { let (tx , mut rx) = mpsc :: channel :: < u8 > (1) ; let sync_code = std :: thread :: spawn (move | | { tx . blocking_send (10) . unwrap () ; }) ; tokio :: runtime :: Runtime :: new () . unwrap () . block_on (async move { assert_eq ! (Some (10) , rx . recv () . await) ; }) ; sync_code . join () . unwrap () } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7683778469709830486,
      "kind": "Function",
      "name": "blocking_send_async",
      "signature": "fn # [tokio :: test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] async fn blocking_send_async () { let (tx , _rx) = mpsc :: channel :: < () > (1) ; let _ = tx . blocking_send (()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4952252294496297501,
      "kind": "Function",
      "name": "ready_close_cancel_bounded",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn ready_close_cancel_bounded () { let (tx , mut rx) = mpsc :: channel :: < () > (100) ; let _tx2 = tx . clone () ; let permit = assert_ok ! (tx . reserve () . await) ; rx . close () ; let mut recv = tokio_test :: task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; drop (permit) ; assert ! (recv . is_woken ()) ; let val = assert_ready ! (recv . poll ()) ; assert ! (val . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 17014659013274895711,
      "kind": "Function",
      "name": "permit_available_not_acquired_close",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn permit_available_not_acquired_close () { let (tx1 , mut rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx1 . clone () ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let mut permit2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (permit2 . poll ()) ; rx . close () ; drop (permit1) ; assert ! (permit2 . is_woken ()) ; drop (permit2) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 214943799429937500,
      "kind": "Function",
      "name": "try_recv_bounded",
      "signature": "fn # [test] fn try_recv_bounded () { let (tx , mut rx) = mpsc :: channel (5) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert ! (tx . try_send (\"hello\") . is_err ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert ! (tx . try_send (\"hello\") . is_err ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; drop (tx) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15082556501701410711,
      "kind": "Function",
      "name": "try_recv_unbounded",
      "signature": "fn # [test] fn try_recv_unbounded () { for num in 0 .. 100 { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. num { tx . send (i) . unwrap () ; } for i in 0 .. num { assert_eq ! (rx . try_recv () , Ok (i)) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; drop (tx) ; assert_eq ! (rx . try_recv () , Err (TryRecvError :: Disconnected)) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 13534601401366474426,
      "kind": "Function",
      "name": "try_recv_close_while_empty_bounded",
      "signature": "fn # [test] fn try_recv_close_while_empty_bounded () { let (tx , mut rx) = mpsc :: channel :: < () > (5) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; drop (tx) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 554729475982871519,
      "kind": "Function",
      "name": "try_recv_close_while_empty_unbounded",
      "signature": "fn # [test] fn try_recv_close_while_empty_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; drop (tx) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7825197184535669386,
      "kind": "Function",
      "name": "recv_timeout",
      "signature": "fn # [tokio :: test (start_paused = true)] # [cfg (feature = \"full\")] async fn recv_timeout () { use tokio :: sync :: mpsc :: error :: SendTimeoutError :: { Closed , Timeout } ; use tokio :: time :: Duration ; let (tx , rx) = mpsc :: channel (5) ; assert_eq ! (tx . send_timeout (10 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (20 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (30 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (40 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (50 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (60 , Duration :: from_secs (1)) . await , Err (Timeout (60))) ; drop (rx) ; assert_eq ! (tx . send_timeout (70 , Duration :: from_secs (1)) . await , Err (Closed (70))) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7057117041178741762,
      "kind": "Function",
      "name": "recv_timeout_panic",
      "signature": "fn # [test] # [should_panic = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\"] # [cfg (not (target_family = \"wasm\"))] fn recv_timeout_panic () { use futures :: future :: FutureExt ; use tokio :: time :: Duration ; let (tx , _rx) = mpsc :: channel (5) ; tx . send_timeout (10 , Duration :: from_secs (1)) . now_or_never () ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11896691074664676787,
      "kind": "Function",
      "name": "test_tx_capacity",
      "signature": "fn # [tokio :: test] async fn test_tx_capacity () { let (tx , _rx) = mpsc :: channel :: < () > (10) ; assert_eq ! (tx . capacity () , 10) ; assert_eq ! (tx . max_capacity () , 10) ; let _permit = tx . reserve () . await . unwrap () ; assert_eq ! (tx . capacity () , 9) ; assert_eq ! (tx . max_capacity () , 10) ; tx . send (()) . await . unwrap () ; assert_eq ! (tx . capacity () , 8) ; assert_eq ! (tx . max_capacity () , 10) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14750259027349742387,
      "kind": "Function",
      "name": "test_rx_is_closed_when_calling_close_with_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_calling_close_with_sender () { let (_tx , mut rx) = mpsc :: channel :: < () > (10) ; rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2632836108439601201,
      "kind": "Function",
      "name": "test_rx_is_closed_when_dropping_all_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let another_tx = tx . clone () ; let task = tokio :: spawn (async move { drop (another_tx) ; }) ; drop (tx) ; let _ = task . await ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 16575719631814130117,
      "kind": "Function",
      "name": "test_rx_is_not_closed_when_there_are_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_senders () { let (_tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (! rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10816625185970754022,
      "kind": "Function",
      "name": "test_rx_is_not_closed_when_there_are_senders_and_buffer_filled",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_senders_and_buffer_filled () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } assert ! (! rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14183631243944098500,
      "kind": "Function",
      "name": "test_rx_is_closed_when_there_are_no_senders_and_there_are_messages",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_there_are_no_senders_and_there_are_messages () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2689090229288533597,
      "kind": "Function",
      "name": "test_rx_is_closed_when_there_are_messages_and_close_is_called",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_there_are_messages_and_close_is_called () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 3621108350725996117,
      "kind": "Function",
      "name": "test_rx_is_not_closed_when_there_are_permits_but_not_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_permits_but_not_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let _permit = tx . reserve_owned () . await . expect (\"Failed to reserve permit\") ; assert ! (! rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7146709591230171666,
      "kind": "Function",
      "name": "test_rx_is_empty_when_no_messages_were_sent",
      "signature": "fn # [tokio :: test] async fn test_rx_is_empty_when_no_messages_were_sent () { let (_tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 10336071460024447515,
      "kind": "Function",
      "name": "test_rx_is_not_empty_when_there_are_messages_in_the_buffer",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_there_are_messages_in_the_buffer () { let (tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (tx . send (()) . await . is_ok ()) ; assert ! (! rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7614815410757900302,
      "kind": "Function",
      "name": "test_rx_is_not_empty_when_the_buffer_is_full",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_the_buffer_is_full () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } assert ! (! rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11278154243640081156,
      "kind": "Function",
      "name": "test_rx_is_not_empty_when_all_but_one_messages_are_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_all_but_one_messages_are_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } for _ in 0 .. 9 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (! rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14954024149861035969,
      "kind": "Function",
      "name": "test_rx_is_empty_when_all_messages_are_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_is_empty_when_all_messages_are_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } while rx . try_recv () . is_ok () { } assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 12361301170856084409,
      "kind": "Function",
      "name": "test_rx_is_empty_all_senders_are_dropped_and_messages_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_is_empty_all_senders_are_dropped_and_messages_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; for _ in 0 .. 10 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 303183882393637958,
      "kind": "Function",
      "name": "test_rx_len_on_empty_channel",
      "signature": "fn # [tokio :: test] async fn test_rx_len_on_empty_channel () { let (_tx , rx) = mpsc :: channel :: < () > (100) ; assert_eq ! (rx . len () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2516327927569917987,
      "kind": "Function",
      "name": "test_rx_len_on_empty_channel_without_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_len_on_empty_channel_without_senders () { let (tx , rx) = mpsc :: channel :: < () > (100) ; drop (tx) ; assert_eq ! (rx . len () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 4386525187547456419,
      "kind": "Function",
      "name": "test_rx_len_on_filled_channel",
      "signature": "fn # [tokio :: test] async fn test_rx_len_on_filled_channel () { let (tx , rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; } assert_eq ! (rx . len () , 100) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 16194547689867327469,
      "kind": "Function",
      "name": "test_rx_len_on_filled_channel_without_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_len_on_filled_channel_without_senders () { let (tx , rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; assert_eq ! (rx . len () , 100) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 6588264371191146543,
      "kind": "Function",
      "name": "test_rx_len_when_consuming_all_messages",
      "signature": "fn # [tokio :: test] async fn test_rx_len_when_consuming_all_messages () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; assert_eq ! (rx . len () , i + 1) ; } drop (tx) ; for i in (0 .. 100) . rev () { assert ! (rx . recv () . await . is_some ()) ; assert_eq ! (rx . len () , i) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5099764527521684310,
      "kind": "Function",
      "name": "test_rx_len_when_close_is_called",
      "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 656561093029308973,
      "kind": "Function",
      "name": "test_rx_len_when_close_is_called_before_dropping_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called_before_dropping_sender () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; rx . close () ; drop (tx) ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15084080711766334343,
      "kind": "Function",
      "name": "test_rx_len_when_close_is_called_after_dropping_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called_after_dropping_sender () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; drop (tx) ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 17324079274958353724,
      "kind": "Function",
      "name": "test_rx_unbounded_is_closed_when_calling_close_with_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_calling_close_with_sender () { let (_tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1016764568471227128,
      "kind": "Function",
      "name": "test_rx_unbounded_is_closed_when_dropping_all_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_dropping_all_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let another_tx = tx . clone () ; let task = tokio :: spawn (async move { drop (another_tx) ; }) ; drop (tx) ; let _ = task . await ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 8973476751126503090,
      "kind": "Function",
      "name": "test_rx_unbounded_is_not_closed_when_there_are_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_closed_when_there_are_senders () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert ! (! rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 15754024457567676895,
      "kind": "Function",
      "name": "test_rx_unbounded_is_closed_when_there_are_no_senders_and_there_are_messages",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_there_are_no_senders_and_there_are_messages () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 18401741043062394152,
      "kind": "Function",
      "name": "test_rx_unbounded_is_closed_when_there_are_messages_and_close_is_called",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_there_are_messages_and_close_is_called () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1022916457819331842,
      "kind": "Function",
      "name": "test_rx_unbounded_is_empty_when_no_messages_were_sent",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_when_no_messages_were_sent () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 18304642315073888261,
      "kind": "Function",
      "name": "test_rx_unbounded_is_not_empty_when_there_are_messages_in_the_buffer",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_empty_when_there_are_messages_in_the_buffer () { let (tx , rx) = mpsc :: unbounded_channel () ; assert ! (tx . send (()) . is_ok ()) ; assert ! (! rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 5220333498261774099,
      "kind": "Function",
      "name": "test_rx_unbounded_is_not_empty_when_all_but_one_messages_are_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_empty_when_all_but_one_messages_are_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } for _ in 0 .. 9 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (! rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 2404162861861462610,
      "kind": "Function",
      "name": "test_rx_unbounded_is_empty_when_all_messages_are_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_when_all_messages_are_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } while rx . try_recv () . is_ok () { } assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14418326903043857083,
      "kind": "Function",
      "name": "test_rx_unbounded_is_empty_all_senders_are_dropped_and_messages_consumed",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_all_senders_are_dropped_and_messages_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; for _ in 0 .. 10 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (rx . is_empty ()) } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 14133261899696256631,
      "kind": "Function",
      "name": "test_rx_unbounded_len_on_empty_channel",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_on_empty_channel () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert_eq ! (rx . len () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 11332739473468263954,
      "kind": "Function",
      "name": "test_rx_unbounded_len_on_empty_channel_without_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_on_empty_channel_without_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; drop (tx) ; assert_eq ! (rx . len () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 17404416206841135265,
      "kind": "Function",
      "name": "test_rx_unbounded_len_with_multiple_messages",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_with_multiple_messages () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; } assert_eq ! (rx . len () , 100) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 7552894364283881385,
      "kind": "Function",
      "name": "test_rx_unbounded_len_with_multiple_messages_and_dropped_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_with_multiple_messages_and_dropped_senders () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; assert_eq ! (rx . len () , 100) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 805869572676692927,
      "kind": "Function",
      "name": "test_rx_unbounded_len_when_consuming_all_messages",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_consuming_all_messages () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; assert_eq ! (rx . len () , i + 1) ; } drop (tx) ; for i in (0 .. 100) . rev () { assert ! (rx . recv () . await . is_some ()) ; assert_eq ! (rx . len () , i) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 6900239863791347390,
      "kind": "Function",
      "name": "test_rx_unbounded_len_when_close_is_called",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 57391408980655939,
      "kind": "Function",
      "name": "test_rx_unbounded_len_when_close_is_called_before_dropping_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called_before_dropping_sender () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; rx . close () ; drop (tx) ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 16078798057746417463,
      "kind": "Function",
      "name": "test_rx_unbounded_len_when_close_is_called_after_dropping_sender",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called_after_dropping_sender () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; drop (tx) ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 1221548607653939641,
      "kind": "Function",
      "name": "test_is_empty_32_msgs",
      "signature": "fn # [tokio :: test] async fn test_is_empty_32_msgs () { let (sender , mut receiver) = mpsc :: channel (33) ; for value in 1 .. 257 { sender . send (value) . await . unwrap () ; receiver . recv () . await . unwrap () ; assert ! (receiver . is_empty () , \"{value}. len: {}\" , receiver . len ()) ; } } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 16758573951464415782,
      "kind": "Function",
      "name": "drop_all_elements_during_panic",
      "signature": "fn # [test] # [cfg (not (panic = \"abort\"))] fn drop_all_elements_during_panic () { use std :: sync :: atomic :: AtomicUsize ; use std :: sync :: atomic :: Ordering :: Relaxed ; use tokio :: sync :: mpsc :: UnboundedReceiver ; use tokio :: sync :: mpsc :: UnboundedSender ; static COUNTER : AtomicUsize = AtomicUsize :: new (0) ; struct A (bool) ; impl Drop for A { fn drop (& mut self) { COUNTER . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; if self . 0 { panic ! (\"panic!\") } } } fn func (tx : UnboundedSender < A > , rx : UnboundedReceiver < A >) { tx . send (A (true)) . unwrap () ; tx . send (A (false)) . unwrap () ; tx . send (A (false)) . unwrap () ; drop (rx) ; } let (tx , rx) = mpsc :: unbounded_channel () ; let _ = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { func (tx . clone () , rx) ; })) ; assert_eq ! (COUNTER . load (Relaxed) , 3) ; drop (tx) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc.rs",
      "line": 0
    },
    {
      "hash": 6116230462990893783,
      "kind": "Function",
      "name": "weak_sender",
      "signature": "fn # [tokio :: test] async fn weak_sender () { let (tx , mut rx) = channel (11) ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . await . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) . await ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Some (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } None => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 9379260467266495440,
      "kind": "Function",
      "name": "actor_weak_sender",
      "signature": "fn # [tokio :: test] async fn actor_weak_sender () { pub struct MyActor { receiver : mpsc :: Receiver < ActorMessage > , sender : mpsc :: WeakSender < ActorMessage > , next_id : u32 , pub received_self_msg : bool , } enum ActorMessage { GetUniqueId { respond_to : oneshot :: Sender < u32 > } , SelfMessage { } , } impl MyActor { fn new (receiver : mpsc :: Receiver < ActorMessage > , sender : mpsc :: WeakSender < ActorMessage > ,) -> Self { MyActor { receiver , sender , next_id : 0 , received_self_msg : false , } } fn handle_message (& mut self , msg : ActorMessage) { match msg { ActorMessage :: GetUniqueId { respond_to } => { self . next_id += 1 ; let _ = respond_to . send (self . next_id) ; } ActorMessage :: SelfMessage { .. } => { self . received_self_msg = true ; } } } async fn send_message_to_self (& mut self) { let msg = ActorMessage :: SelfMessage { } ; let sender = self . sender . clone () ; if let Some (sender) = sender . upgrade () { let _ = sender . send (msg) . await ; self . sender = sender . downgrade () ; } } async fn run (& mut self) { let mut i = 0 ; while let Some (msg) = self . receiver . recv () . await { self . handle_message (msg) ; if i == 0 { self . send_message_to_self () . await ; } i += 1 } assert ! (self . received_self_msg) ; } } # [derive (Clone)] pub struct MyActorHandle { sender : mpsc :: Sender < ActorMessage > , } impl MyActorHandle { pub fn new () -> (Self , MyActor) { let (sender , receiver) = mpsc :: channel (8) ; let actor = MyActor :: new (receiver , sender . clone () . downgrade ()) ; (Self { sender } , actor) } pub async fn get_unique_id (& self) -> u32 { let (send , recv) = oneshot :: channel () ; let msg = ActorMessage :: GetUniqueId { respond_to : send } ; let _ = self . sender . send (msg) . await ; recv . await . expect (\"Actor task has been killed\") } } let (handle , mut actor) = MyActorHandle :: new () ; let actor_handle = tokio :: spawn (async move { actor . run () . await }) ; let _ = tokio :: spawn (async move { let _ = handle . get_unique_id () . await ; drop (handle) ; }) . await ; let _ = actor_handle . await ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 8454132182499147581,
      "kind": "Struct",
      "name": "Msg",
      "signature": "struct Msg",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 8279380553358201051,
      "kind": "Function",
      "name": "test_msgs_dropped_on_rx_drop",
      "signature": "fn # [tokio :: test] async fn test_msgs_dropped_on_rx_drop () { let (tx , mut rx) = mpsc :: channel (3) ; tx . send (Msg { }) . await . unwrap () ; tx . send (Msg { }) . await . unwrap () ; let sent_fut = tx . send (Msg { }) ; let _ = rx . recv () . await . unwrap () ; let _ = rx . recv () . await . unwrap () ; sent_fut . await . unwrap () ; drop (rx) ; assert_eq ! (NUM_DROPPED . load (Acquire) , 3) ; assert ! (tx . send (Msg { }) . await . is_err ()) ; assert_eq ! (NUM_DROPPED . load (Acquire) , 4) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 13033685620962287686,
      "kind": "Function",
      "name": "downgrade_upgrade_sender_success",
      "signature": "fn # [test] fn downgrade_upgrade_sender_success () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 326753816427090927,
      "kind": "Function",
      "name": "downgrade_upgrade_sender_failure",
      "signature": "fn # [test] fn downgrade_upgrade_sender_failure () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 667042572611851449,
      "kind": "Function",
      "name": "downgrade_drop_upgrade",
      "signature": "fn # [test] fn downgrade_drop_upgrade () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 727976116715151165,
      "kind": "Function",
      "name": "downgrade_get_permit_upgrade_no_senders",
      "signature": "fn # [tokio :: test] async fn downgrade_get_permit_upgrade_no_senders () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; let _permit = tx . reserve_owned () . await . unwrap () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 17792142002729049671,
      "kind": "Function",
      "name": "downgrade_upgrade_get_permit_no_senders",
      "signature": "fn # [tokio :: test] async fn downgrade_upgrade_get_permit_no_senders () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx . clone () ; let _permit = tx . reserve_owned () . await . unwrap () ; let weak_tx = tx2 . downgrade () ; drop (tx2) ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 11203317584606032464,
      "kind": "Function",
      "name": "test_tx_count_weak_sender",
      "signature": "fn # [test] fn test_tx_count_weak_sender () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none () && tx_weak2 . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 8806059954071366007,
      "kind": "Function",
      "name": "weak_unbounded_sender",
      "signature": "fn # [tokio :: test] async fn weak_unbounded_sender () { let (tx , mut rx) = unbounded_channel () ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Some (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } None => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 14230643069215813915,
      "kind": "Function",
      "name": "actor_weak_unbounded_sender",
      "signature": "fn # [tokio :: test] async fn actor_weak_unbounded_sender () { pub struct MyActor { receiver : mpsc :: UnboundedReceiver < ActorMessage > , sender : mpsc :: WeakUnboundedSender < ActorMessage > , next_id : u32 , pub received_self_msg : bool , } enum ActorMessage { GetUniqueId { respond_to : oneshot :: Sender < u32 > } , SelfMessage { } , } impl MyActor { fn new (receiver : mpsc :: UnboundedReceiver < ActorMessage > , sender : mpsc :: WeakUnboundedSender < ActorMessage > ,) -> Self { MyActor { receiver , sender , next_id : 0 , received_self_msg : false , } } fn handle_message (& mut self , msg : ActorMessage) { match msg { ActorMessage :: GetUniqueId { respond_to } => { self . next_id += 1 ; let _ = respond_to . send (self . next_id) ; } ActorMessage :: SelfMessage { .. } => { self . received_self_msg = true ; } } } async fn send_message_to_self (& mut self) { let msg = ActorMessage :: SelfMessage { } ; let sender = self . sender . clone () ; if let Some (sender) = sender . upgrade () { let _ = sender . send (msg) ; self . sender = sender . downgrade () ; } } async fn run (& mut self) { let mut i = 0 ; while let Some (msg) = self . receiver . recv () . await { self . handle_message (msg) ; if i == 0 { self . send_message_to_self () . await ; } i += 1 } assert ! (self . received_self_msg) ; } } # [derive (Clone)] pub struct MyActorHandle { sender : mpsc :: UnboundedSender < ActorMessage > , } impl MyActorHandle { pub fn new () -> (Self , MyActor) { let (sender , receiver) = mpsc :: unbounded_channel () ; let actor = MyActor :: new (receiver , sender . clone () . downgrade ()) ; (Self { sender } , actor) } pub async fn get_unique_id (& self) -> u32 { let (send , recv) = oneshot :: channel () ; let msg = ActorMessage :: GetUniqueId { respond_to : send } ; let _ = self . sender . send (msg) ; recv . await . expect (\"Actor task has been killed\") } } let (handle , mut actor) = MyActorHandle :: new () ; let actor_handle = tokio :: spawn (async move { actor . run () . await }) ; let _ = tokio :: spawn (async move { let _ = handle . get_unique_id () . await ; drop (handle) ; }) . await ; let _ = actor_handle . await ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 3570993375102823715,
      "kind": "Struct",
      "name": "MsgUnbounded",
      "signature": "struct MsgUnbounded",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 1471813481286957450,
      "kind": "Function",
      "name": "test_msgs_dropped_on_unbounded_rx_drop",
      "signature": "fn # [tokio :: test] async fn test_msgs_dropped_on_unbounded_rx_drop () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (MsgUnbounded { }) . unwrap () ; tx . send (MsgUnbounded { }) . unwrap () ; let sent = tx . send (MsgUnbounded { }) ; let _ = rx . recv () . await . unwrap () ; let _ = rx . recv () . await . unwrap () ; sent . unwrap () ; drop (rx) ; assert_eq ! (NUM_DROPPED_UNBOUNDED . load (Acquire) , 3) ; assert ! (tx . send (MsgUnbounded { }) . is_err ()) ; assert_eq ! (NUM_DROPPED_UNBOUNDED . load (Acquire) , 4) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 559750195454429227,
      "kind": "Function",
      "name": "downgrade_upgrade_unbounded_sender_success",
      "signature": "fn # [test] fn downgrade_upgrade_unbounded_sender_success () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . downgrade () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 1072429472256107133,
      "kind": "Function",
      "name": "downgrade_upgrade_unbounded_sender_failure",
      "signature": "fn # [test] fn downgrade_upgrade_unbounded_sender_failure () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 13024861213565764248,
      "kind": "Function",
      "name": "downgrade_drop_upgrade_unbounded",
      "signature": "fn # [test] fn downgrade_drop_upgrade_unbounded () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 8077941341968871463,
      "kind": "Function",
      "name": "test_tx_count_weak_unbounded_sender",
      "signature": "fn # [test] fn test_tx_count_weak_unbounded_sender () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none () && tx_weak2 . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 14832854181706171032,
      "kind": "Function",
      "name": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let _weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 14563585065371571863,
      "kind": "Function",
      "name": "test_rx_unbounded_is_closed_when_dropping_all_senders_except_weak_senders",
      "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let _weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 8536038854733958852,
      "kind": "Function",
      "name": "sender_strong_count_when_cloned",
      "signature": "fn # [tokio :: test] async fn sender_strong_count_when_cloned () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 10545823962296934307,
      "kind": "Function",
      "name": "sender_weak_count_when_downgraded",
      "signature": "fn # [tokio :: test] async fn sender_weak_count_when_downgraded () { let (tx , _rx) = mpsc :: channel :: < () > (1) ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 13130082976517627744,
      "kind": "Function",
      "name": "sender_strong_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn sender_strong_count_when_dropped () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 7866940376068295647,
      "kind": "Function",
      "name": "sender_weak_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn sender_weak_count_when_dropped () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 16094261880662906859,
      "kind": "Function",
      "name": "sender_strong_and_weak_conut",
      "signature": "fn # [tokio :: test] async fn sender_strong_and_weak_conut () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 10231339068565390807,
      "kind": "Function",
      "name": "unbounded_sender_strong_count_when_cloned",
      "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_count_when_cloned () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 2934313972791117777,
      "kind": "Function",
      "name": "unbounded_sender_weak_count_when_downgraded",
      "signature": "fn # [tokio :: test] async fn unbounded_sender_weak_count_when_downgraded () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 13156029859662290727,
      "kind": "Function",
      "name": "unbounded_sender_strong_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_count_when_dropped () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 16290467030300200427,
      "kind": "Function",
      "name": "unbounded_sender_weak_count_when_dropped",
      "signature": "fn # [tokio :: test] async fn unbounded_sender_weak_count_when_dropped () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 9841784867746416649,
      "kind": "Function",
      "name": "unbounded_sender_strong_and_weak_conut",
      "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_and_weak_conut () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
      "file_path": "tokio/tests/sync_mpsc_weak.rs",
      "line": 0
    },
    {
      "hash": 6574174391413972416,
      "kind": "Function",
      "name": "straight_execution",
      "signature": "fn # [test] fn straight_execution () { let l = Mutex :: new (100) ; { let mut t = spawn (l . lock ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 100) ; * g = 99 ; } { let mut t = spawn (l . lock ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 99) ; * g = 98 ; } { let mut t = spawn (l . lock ()) ; let g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 98) ; } } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 11520958776182273273,
      "kind": "Function",
      "name": "readiness",
      "signature": "fn # [test] fn readiness () { let l1 = Arc :: new (Mutex :: new (100)) ; let l2 = Arc :: clone (& l1) ; let mut t1 = spawn (l1 . lock ()) ; let mut t2 = spawn (l2 . lock ()) ; let g = assert_ready ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; drop (g) ; assert ! (t2 . is_woken ()) ; let _t2 = assert_ready ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 9071427709626983897,
      "kind": "Function",
      "name": "aborted_future_1",
      "signature": "fn # [doc = \" Ensure a mutex is unlocked if a future holding the lock\"] # [doc = \" is aborted prematurely.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_1 () { use std :: time :: Duration ; use tokio :: time :: { interval , timeout } ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let iv = interval (Duration :: from_millis (1000)) ; tokio :: pin ! (iv) ; let _g = m2 . lock () . await ; iv . as_mut () . tick () . await ; iv . as_mut () . tick () . await ; }) . await . unwrap_err () ; } timeout (Duration :: from_millis (1u64) , async move { let _g = m1 . lock () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 14426736565731550333,
      "kind": "Function",
      "name": "aborted_future_2",
      "signature": "fn # [doc = \" This test is similar to `aborted_future_1` but this time the\"] # [doc = \" aborted future is waiting for the lock.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_2 () { use std :: time :: Duration ; use tokio :: time :: timeout ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let _lock = m1 . lock () . await ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let _g = m2 . lock () . await ; }) . await . unwrap_err () ; } } timeout (Duration :: from_millis (1u64) , async move { let _g = m1 . lock () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 4452477900755696282,
      "kind": "Function",
      "name": "try_lock",
      "signature": "fn # [test] fn try_lock () { let m : Mutex < usize > = Mutex :: new (0) ; { let g1 = m . try_lock () ; assert ! (g1 . is_ok ()) ; let g2 = m . try_lock () ; assert ! (g2 . is_err ()) ; } let g3 = m . try_lock () ; assert ! (g3 . is_ok ()) ; } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 12440075736748220262,
      "kind": "Function",
      "name": "debug_format",
      "signature": "fn # [maybe_tokio_test] async fn debug_format () { let s = \"debug\" ; let m = Mutex :: new (s . to_string ()) ; assert_eq ! (format ! (\"{s:?}\") , format ! (\"{:?}\" , m . lock () . await)) ; } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 238105879158152397,
      "kind": "Function",
      "name": "mutex_debug",
      "signature": "fn # [maybe_tokio_test] async fn mutex_debug () { let s = \"data\" ; let m = Mutex :: new (s . to_string ()) ; assert_eq ! (format ! (\"{m:?}\") , r#\"Mutex { data: \"data\" }\"#) ; let _guard = m . lock () . await ; assert_eq ! (format ! (\"{m:?}\") , r#\"Mutex { data: <locked> }\"#) } . sig",
      "file_path": "tokio/tests/sync_mutex.rs",
      "line": 0
    },
    {
      "hash": 2102348677138179050,
      "kind": "Function",
      "name": "straight_execution",
      "signature": "fn # [test] fn straight_execution () { let l = Arc :: new (Mutex :: new (100)) ; { let mut t = spawn (l . clone () . lock_owned ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 100) ; * g = 99 ; } { let mut t = spawn (l . clone () . lock_owned ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 99) ; * g = 98 ; } { let mut t = spawn (l . lock_owned ()) ; let g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 98) ; } } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 487996848613682923,
      "kind": "Function",
      "name": "readiness",
      "signature": "fn # [test] fn readiness () { let l = Arc :: new (Mutex :: new (100)) ; let mut t1 = spawn (l . clone () . lock_owned ()) ; let mut t2 = spawn (l . lock_owned ()) ; let g = assert_ready ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; drop (g) ; assert ! (t2 . is_woken ()) ; assert_ready ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 8315838790450442356,
      "kind": "Function",
      "name": "aborted_future_1",
      "signature": "fn # [doc = \" Ensure a mutex is unlocked if a future holding the lock\"] # [doc = \" is aborted prematurely.\"] # [tokio :: test] # [cfg (feature = \"full\")] # [cfg_attr (miri , ignore)] async fn aborted_future_1 () { use std :: time :: Duration ; use tokio :: time :: { interval , timeout } ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let iv = interval (Duration :: from_millis (1000)) ; tokio :: pin ! (iv) ; m2 . lock_owned () . await ; iv . as_mut () . tick () . await ; iv . as_mut () . tick () . await ; }) . await . unwrap_err () ; } timeout (Duration :: from_millis (1u64) , async move { m1 . lock_owned () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 12897500905588911721,
      "kind": "Function",
      "name": "aborted_future_2",
      "signature": "fn # [doc = \" This test is similar to `aborted_future_1` but this time the\"] # [doc = \" aborted future is waiting for the lock.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_2 () { use std :: time :: Duration ; use tokio :: time :: timeout ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let _lock = m1 . clone () . lock_owned () . await ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { m2 . lock_owned () . await ; }) . await . unwrap_err () ; } } timeout (Duration :: from_millis (1u64) , async move { m1 . lock_owned () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 16728428855592920568,
      "kind": "Function",
      "name": "try_lock_owned",
      "signature": "fn # [test] fn try_lock_owned () { let m : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let g1 = m . clone () . try_lock_owned () ; assert ! (g1 . is_ok ()) ; let g2 = m . clone () . try_lock_owned () ; assert ! (g2 . is_err ()) ; } let g3 = m . try_lock_owned () ; assert ! (g3 . is_ok ()) ; } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 3876720302527398864,
      "kind": "Function",
      "name": "debug_format",
      "signature": "fn # [maybe_tokio_test] async fn debug_format () { let s = \"debug\" ; let m = Arc :: new (Mutex :: new (s . to_string ())) ; assert_eq ! (format ! (\"{s:?}\") , format ! (\"{:?}\" , m . lock_owned () . await)) ; } . sig",
      "file_path": "tokio/tests/sync_mutex_owned.rs",
      "line": 0
    },
    {
      "hash": 10424118762157278519,
      "kind": "Function",
      "name": "notify_notified_one",
      "signature": "fn # [test] fn notify_notified_one () { let notify = Notify :: new () ; let mut notified = spawn (async { notify . notified () . await }) ; notify . notify_one () ; assert_ready ! (notified . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 15133984706775000756,
      "kind": "Function",
      "name": "notify_multi_notified_one",
      "signature": "fn # [test] fn notify_multi_notified_one () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 3073076091790242571,
      "kind": "Function",
      "name": "notify_multi_notified_last",
      "signature": "fn # [test] fn notify_multi_notified_last () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_last () ; assert_pending ! (notified1 . poll ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 8451330543681235982,
      "kind": "Function",
      "name": "notified_one_notify",
      "signature": "fn # [test] fn notified_one_notify () { let notify = Notify :: new () ; let mut notified = spawn (async { notify . notified () . await }) ; assert_pending ! (notified . poll ()) ; notify . notify_one () ; assert ! (notified . is_woken ()) ; assert_ready ! (notified . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 6536289631741497242,
      "kind": "Function",
      "name": "notified_multi_notify",
      "signature": "fn # [test] fn notified_multi_notify () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 2079979804811701813,
      "kind": "Function",
      "name": "notify_notified_multi",
      "signature": "fn # [test] fn notify_notified_multi () { let notify = Notify :: new () ; notify . notify_one () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 9653049599967455254,
      "kind": "Function",
      "name": "notified_drop_notified_notify",
      "signature": "fn # [test] fn notified_drop_notified_notify () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; drop (notified1) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 11319759214646004088,
      "kind": "Function",
      "name": "notified_multi_notify_drop_one",
      "signature": "fn # [test] fn notified_multi_notify_drop_one () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; drop (notified1) ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 260913253946897298,
      "kind": "Function",
      "name": "notified_multi_notify_one_drop",
      "signature": "fn # [test] fn notified_multi_notify_one_drop () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; let mut notified3 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_one () ; drop (notified1) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 17288148594079783872,
      "kind": "Function",
      "name": "notified_multi_notify_last_drop",
      "signature": "fn # [test] fn notified_multi_notify_last_drop () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; let mut notified3 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_last () ; drop (notified3) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified1 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 10620587561938480012,
      "kind": "Function",
      "name": "notify_in_drop_after_wake",
      "signature": "fn # [test] fn notify_in_drop_after_wake () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let notify = Arc :: new (Notify :: new ()) ; struct NotifyOnDrop (Arc < Notify >) ; impl ArcWake for NotifyOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } impl Drop for NotifyOnDrop { fn drop (& mut self) { self . 0 . notify_waiters () ; } } let mut fut = Box :: pin (async { notify . notified () . await ; }) ; { let waker = futures :: task :: waker (Arc :: new (NotifyOnDrop (notify . clone ()))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } notify . notify_waiters () ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 10431532406620137224,
      "kind": "Function",
      "name": "notify_one_after_dropped_all",
      "signature": "fn # [test] fn notify_one_after_dropped_all () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; notify . notify_waiters () ; notify . notify_one () ; drop (notified1) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 7842097458713424119,
      "kind": "Function",
      "name": "test_notify_one_not_enabled",
      "signature": "fn # [test] fn test_notify_one_not_enabled () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 12816987347122882943,
      "kind": "Function",
      "name": "test_notify_one_after_enable",
      "signature": "fn # [test] fn test_notify_one_after_enable () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; future . enter (| _ , fut | assert ! (fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 11391230618975804726,
      "kind": "Function",
      "name": "test_poll_after_enable",
      "signature": "fn # [test] fn test_poll_after_enable () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; assert_pending ! (future . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 18279577008333153891,
      "kind": "Function",
      "name": "test_enable_after_poll",
      "signature": "fn # [test] fn test_enable_after_poll () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; assert_pending ! (future . poll ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 82904669048883506,
      "kind": "Function",
      "name": "test_enable_consumes_permit",
      "signature": "fn # [test] fn test_enable_consumes_permit () { let notify = Notify :: new () ; notify . notify_one () ; let mut future1 = spawn (notify . notified ()) ; future1 . enter (| _ , fut | assert ! (fut . enable ())) ; let mut future2 = spawn (notify . notified ()) ; future2 . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 9911040974111720976,
      "kind": "Function",
      "name": "test_waker_update",
      "signature": "fn # [test] fn test_waker_update () { use futures :: task :: noop_waker ; use std :: future :: Future ; use std :: task :: Context ; let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; let noop = noop_waker () ; future . enter (| _ , fut | assert_pending ! (fut . poll (& mut Context :: from_waker (& noop)))) ; assert_pending ! (future . poll ()) ; notify . notify_one () ; assert ! (future . is_woken ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify.rs",
      "line": 0
    },
    {
      "hash": 15154182775825480774,
      "kind": "Function",
      "name": "notify_notified_one",
      "signature": "fn # [test] fn notify_notified_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified = spawn (async { notify . clone () . notified_owned () . await }) ; notify . notify_one () ; assert_ready ! (notified . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 8486087953111080246,
      "kind": "Function",
      "name": "notify_multi_notified_one",
      "signature": "fn # [test] fn notify_multi_notified_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 11157231193932617187,
      "kind": "Function",
      "name": "notify_multi_notified_last",
      "signature": "fn # [test] fn notify_multi_notified_last () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_last () ; assert_pending ! (notified1 . poll ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 6423074782709303702,
      "kind": "Function",
      "name": "notified_one_notify",
      "signature": "fn # [test] fn notified_one_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified . poll ()) ; notify . notify_one () ; assert ! (notified . is_woken ()) ; assert_ready ! (notified . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 8568923533304913444,
      "kind": "Function",
      "name": "notified_multi_notify",
      "signature": "fn # [test] fn notified_multi_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 1752229850065974169,
      "kind": "Function",
      "name": "notify_notified_multi",
      "signature": "fn # [test] fn notify_notified_multi () { let notify = Arc :: new (Notify :: new ()) ; notify . notify_one () ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 11521138668384174584,
      "kind": "Function",
      "name": "notified_drop_notified_notify",
      "signature": "fn # [test] fn notified_drop_notified_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; drop (notified1) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 7344463655719870066,
      "kind": "Function",
      "name": "notified_multi_notify_drop_one",
      "signature": "fn # [test] fn notified_multi_notify_drop_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; drop (notified1) ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 6697861594616688502,
      "kind": "Function",
      "name": "notified_multi_notify_one_drop",
      "signature": "fn # [test] fn notified_multi_notify_one_drop () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified3 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_one () ; drop (notified1) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 13730798712804098361,
      "kind": "Function",
      "name": "notified_multi_notify_last_drop",
      "signature": "fn # [test] fn notified_multi_notify_last_drop () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified3 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_last () ; drop (notified3) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified1 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 17432337745583915062,
      "kind": "Function",
      "name": "notify_in_drop_after_wake",
      "signature": "fn # [test] fn notify_in_drop_after_wake () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let notify = Arc :: new (Notify :: new ()) ; struct NotifyOnDrop (Arc < Notify >) ; impl ArcWake for NotifyOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } impl Drop for NotifyOnDrop { fn drop (& mut self) { self . 0 . notify_waiters () ; } } let mut fut = Box :: pin (async { notify . clone () . notified_owned () . await ; }) ; { let waker = futures :: task :: waker (Arc :: new (NotifyOnDrop (notify . clone ()))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } notify . notify_waiters () ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 7920867792374910229,
      "kind": "Function",
      "name": "notify_one_after_dropped_all",
      "signature": "fn # [test] fn notify_one_after_dropped_all () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; notify . notify_waiters () ; notify . notify_one () ; drop (notified1) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_ready ! (notified2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 1782922406339579642,
      "kind": "Function",
      "name": "test_notify_one_not_enabled",
      "signature": "fn # [test] fn test_notify_one_not_enabled () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 9627575576349970931,
      "kind": "Function",
      "name": "test_notify_one_after_enable",
      "signature": "fn # [test] fn test_notify_one_after_enable () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; future . enter (| _ , fut | assert ! (fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 2540735676740385283,
      "kind": "Function",
      "name": "test_poll_after_enable",
      "signature": "fn # [test] fn test_poll_after_enable () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; assert_pending ! (future . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 15082897851918752658,
      "kind": "Function",
      "name": "test_enable_after_poll",
      "signature": "fn # [test] fn test_enable_after_poll () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; assert_pending ! (future . poll ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 11000339681744676590,
      "kind": "Function",
      "name": "test_enable_consumes_permit",
      "signature": "fn # [test] fn test_enable_consumes_permit () { let notify = Arc :: new (Notify :: new ()) ; notify . notify_one () ; let mut future1 = spawn (notify . clone () . notified_owned ()) ; future1 . enter (| _ , fut | assert ! (fut . enable ())) ; let mut future2 = spawn (notify . clone () . notified_owned ()) ; future2 . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 3519670286457491827,
      "kind": "Function",
      "name": "test_waker_update",
      "signature": "fn # [test] fn test_waker_update () { use futures :: task :: noop_waker ; use std :: future :: Future ; use std :: task :: Context ; let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; let noop = noop_waker () ; future . enter (| _ , fut | assert_pending ! (fut . poll (& mut Context :: from_waker (& noop)))) ; assert_pending ! (future . poll ()) ; notify . notify_one () ; assert ! (future . is_woken ()) ; } . sig",
      "file_path": "tokio/tests/sync_notify_owned.rs",
      "line": 0
    },
    {
      "hash": 3991649952184495395,
      "kind": "Struct",
      "name": "Foo",
      "signature": "struct Foo",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 5001062419234102166,
      "kind": "Function",
      "name": "drop_cell",
      "signature": "fn # [test] fn drop_cell () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; { let once_cell = OnceCell :: new () ; let prev = once_cell . set (Foo :: from (num_drops . clone ())) ; assert ! (prev . is_ok ()) } assert ! (num_drops . load (Ordering :: Acquire) == 1) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 9317632985260395812,
      "kind": "Function",
      "name": "drop_cell_new_with",
      "signature": "fn # [test] fn drop_cell_new_with () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; { let once_cell = OnceCell :: new_with (Some (Foo :: from (num_drops . clone ()))) ; assert ! (once_cell . initialized ()) ; } assert ! (num_drops . load (Ordering :: Acquire) == 1) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 7017052281566177712,
      "kind": "Function",
      "name": "drop_into_inner",
      "signature": "fn # [test] fn drop_into_inner () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; let once_cell = OnceCell :: new () ; assert ! (once_cell . set (Foo :: from (num_drops . clone ())) . is_ok ()) ; let fooer = once_cell . into_inner () ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 0) ; drop (fooer) ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 1) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 4994308462459916005,
      "kind": "Function",
      "name": "drop_into_inner_new_with",
      "signature": "fn # [test] fn drop_into_inner_new_with () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; let fooer = Foo :: from (num_drops . clone ()) ; let once_cell = OnceCell :: new_with (Some (fooer)) ; let fooer = once_cell . into_inner () ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 0) ; mem :: drop (fooer) ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 1) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 12314779742217584007,
      "kind": "Function",
      "name": "from",
      "signature": "fn # [test] fn from () { let cell = OnceCell :: from (2) ; assert_eq ! (* cell . get () . unwrap () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 11397905610964715664,
      "kind": "Function",
      "name": "func1",
      "signature": "fn async fn func1 () -> u32 { 5 } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 6434108474763504070,
      "kind": "Function",
      "name": "func2",
      "signature": "fn async fn func2 () -> u32 { time :: sleep (Duration :: from_millis (1)) . await ; 10 } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 9290220524594507248,
      "kind": "Function",
      "name": "func_err",
      "signature": "fn async fn func_err () -> Result < u32 , () > { Err (()) } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 5150379750797664123,
      "kind": "Function",
      "name": "func_ok",
      "signature": "fn async fn func_ok () -> Result < u32 , () > { Ok (10) } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 2048281035223226894,
      "kind": "Function",
      "name": "func_panic",
      "signature": "fn async fn func_panic () -> u32 { time :: sleep (Duration :: from_millis (1)) . await ; panic ! () ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 3042520603875541244,
      "kind": "Function",
      "name": "sleep_and_set",
      "signature": "fn async fn sleep_and_set () -> u32 { time :: sleep (Duration :: from_millis (2)) . await ; 5 } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 11087881617142031111,
      "kind": "Function",
      "name": "advance_time_and_set",
      "signature": "fn async fn advance_time_and_set (cell : & 'static OnceCell < u32 > , v : u32) -> Result < () , SetError < u32 > > { time :: advance (Duration :: from_millis (1)) . await ; cell . set (v) } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 477246881335490284,
      "kind": "Function",
      "name": "get_or_init",
      "signature": "fn # [test] fn get_or_init () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let handle1 = rt . spawn (async { ONCE . get_or_init (func1) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_init (func2) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; time :: resume () ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert_eq ! (* result2 , 5) ; }) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 17058517393583232456,
      "kind": "Function",
      "name": "get_or_init_panic",
      "signature": "fn # [test] fn get_or_init_panic () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { time :: pause () ; let handle1 = rt . spawn (async { ONCE . get_or_init (func1) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_init (func_panic) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert_eq ! (* result2 , 5) ; }) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 14303538245955415174,
      "kind": "Function",
      "name": "set_and_get",
      "signature": "fn # [test] fn set_and_get () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let _ = rt . spawn (async { ONCE . set (5) }) . await ; let value = ONCE . get () . unwrap () ; assert_eq ! (* value , 5) ; }) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 15705832274590767981,
      "kind": "Function",
      "name": "get_uninit",
      "signature": "fn # [test] fn get_uninit () { static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; let uninit = ONCE . get () ; assert ! (uninit . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 17258547834958113747,
      "kind": "Function",
      "name": "set_twice",
      "signature": "fn # [test] fn set_twice () { static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; let first = ONCE . set (5) ; assert_eq ! (first , Ok (())) ; let second = ONCE . set (6) ; assert ! (second . err () . unwrap () . is_already_init_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 6964194431607108929,
      "kind": "Function",
      "name": "set_while_initializing",
      "signature": "fn # [test] fn set_while_initializing () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { time :: pause () ; let handle1 = rt . spawn (async { ONCE . get_or_init (sleep_and_set) . await }) ; let handle2 = rt . spawn (async { advance_time_and_set (& ONCE , 10) . await }) ; time :: advance (Duration :: from_millis (2)) . await ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert ! (result2 . err () . unwrap () . is_initializing_err ()) ; }) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 9072091557324944968,
      "kind": "Function",
      "name": "get_or_try_init",
      "signature": "fn # [test] fn get_or_try_init () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let handle1 = rt . spawn (async { ONCE . get_or_try_init (func_err) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_try_init (func_ok) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; time :: resume () ; let result1 = handle1 . await . unwrap () ; assert ! (result1 . is_err ()) ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result2 . unwrap () , 10) ; }) ; } . sig",
      "file_path": "tokio/tests/sync_once_cell.rs",
      "line": 0
    },
    {
      "hash": 1969396240316671147,
      "kind": "Trait",
      "name": "SenderExt",
      "signature": "trait SenderExt",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 17994791686586844876,
      "kind": "Function",
      "name": "send_recv",
      "signature": "fn # [test] fn send_recv () { let (tx , rx) = oneshot :: channel () ; let mut rx = task :: spawn (rx) ; assert_pending ! (rx . poll ()) ; assert_ok ! (tx . send (1)) ; assert ! (rx . is_woken ()) ; let val = assert_ready_ok ! (rx . poll ()) ; assert_eq ! (val , 1) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13109379819306122212,
      "kind": "Function",
      "name": "async_send_recv",
      "signature": "fn # [maybe_tokio_test] async fn async_send_recv () { let (tx , rx) = oneshot :: channel () ; assert_ok ! (tx . send (1)) ; assert_eq ! (1 , assert_ok ! (rx . await)) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 16696943653629348348,
      "kind": "Function",
      "name": "close_tx",
      "signature": "fn # [test] fn close_tx () { let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; assert_pending ! (rx . poll ()) ; drop (tx) ; assert ! (rx . is_woken ()) ; assert_ready_err ! (rx . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 5027249219812451354,
      "kind": "Function",
      "name": "close_rx",
      "signature": "fn # [test] fn close_rx () { let (tx , _) = oneshot :: channel () ; assert_err ! (tx . send (1)) ; let (tx , rx) = oneshot :: channel () ; let mut tx = task :: spawn (tx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; drop (rx) ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (tx . into_inner () . send (1)) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 14777455879208594976,
      "kind": "Function",
      "name": "async_rx_closed",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_rx_closed () { let (mut tx , rx) = oneshot :: channel :: < () > () ; tokio :: spawn (async move { drop (rx) ; }) ; tx . closed () . await ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 7850756345084297777,
      "kind": "Function",
      "name": "explicit_close_poll",
      "signature": "fn # [test] fn explicit_close_poll () { let (tx , rx) = oneshot :: channel () ; let mut rx = task :: spawn (rx) ; assert_ok ! (tx . send (1)) ; rx . close () ; let value = assert_ready_ok ! (rx . poll ()) ; assert_eq ! (value , 1) ; let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; let mut rx = task :: spawn (rx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (tx . into_inner () . send (1)) ; assert_ready_err ! (rx . poll ()) ; let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; let mut rx = task :: spawn (rx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_ready_err ! (rx . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13886148988975171564,
      "kind": "Function",
      "name": "explicit_close_try_recv",
      "signature": "fn # [test] fn explicit_close_try_recv () { let (tx , mut rx) = oneshot :: channel () ; assert_ok ! (tx . send (1)) ; rx . close () ; let val = assert_ok ! (rx . try_recv ()) ; assert_eq ! (1 , val) ; let (tx , mut rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (rx . try_recv ()) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13175656862886113404,
      "kind": "Function",
      "name": "close_try_recv_poll",
      "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn close_try_recv_poll () { let (_tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; rx . close () ; assert_err ! (rx . try_recv ()) ; let _ = rx . poll () ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 5474500791394756446,
      "kind": "Function",
      "name": "close_after_recv",
      "signature": "fn # [test] fn close_after_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; tx . send (17) . unwrap () ; assert_eq ! (17 , rx . try_recv () . unwrap ()) ; rx . close () ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 16175909860881315452,
      "kind": "Function",
      "name": "try_recv_after_completion",
      "signature": "fn # [test] fn try_recv_after_completion () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; tx . send (17) . unwrap () ; assert_eq ! (17 , rx . try_recv () . unwrap ()) ; assert_eq ! (Err (TryRecvError :: Closed) , rx . try_recv ()) ; rx . close () ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 12119452970778983675,
      "kind": "Function",
      "name": "try_recv_after_completion_await",
      "signature": "fn # [test] fn try_recv_after_completion_await () { let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; tx . send (17) . unwrap () ; assert_eq ! (Ok (17) , assert_ready ! (rx . poll ())) ; assert_eq ! (Err (TryRecvError :: Closed) , rx . try_recv ()) ; rx . close () ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 10032279885238824788,
      "kind": "Function",
      "name": "drops_tasks",
      "signature": "fn # [test] fn drops_tasks () { let (mut tx , mut rx) = oneshot :: channel :: < i32 > () ; let mut tx_task = task :: spawn (()) ; let mut rx_task = task :: spawn (()) ; assert_pending ! (tx_task . enter (| cx , _ | tx . poll_closed (cx))) ; assert_pending ! (rx_task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; drop (tx) ; drop (rx) ; assert_eq ! (1 , tx_task . waker_ref_count ()) ; assert_eq ! (1 , rx_task . waker_ref_count ()) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 10428918252321003565,
      "kind": "Function",
      "name": "receiver_changes_task",
      "signature": "fn # [test] fn receiver_changes_task () { let (tx , mut rx) = oneshot :: channel () ; let mut task1 = task :: spawn (()) ; let mut task2 = task :: spawn (()) ; assert_pending ! (task1 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; assert_eq ! (2 , task1 . waker_ref_count ()) ; assert_eq ! (1 , task2 . waker_ref_count ()) ; assert_pending ! (task2 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; assert_eq ! (1 , task1 . waker_ref_count ()) ; assert_eq ! (2 , task2 . waker_ref_count ()) ; assert_ok ! (tx . send (1)) ; assert ! (! task1 . is_woken ()) ; assert ! (task2 . is_woken ()) ; assert_ready_ok ! (task2 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 10566655847681709553,
      "kind": "Function",
      "name": "sender_changes_task",
      "signature": "fn # [test] fn sender_changes_task () { let (mut tx , rx) = oneshot :: channel :: < i32 > () ; let mut task1 = task :: spawn (()) ; let mut task2 = task :: spawn (()) ; assert_pending ! (task1 . enter (| cx , _ | tx . poll_closed (cx))) ; assert_eq ! (2 , task1 . waker_ref_count ()) ; assert_eq ! (1 , task2 . waker_ref_count ()) ; assert_pending ! (task2 . enter (| cx , _ | tx . poll_closed (cx))) ; assert_eq ! (1 , task1 . waker_ref_count ()) ; assert_eq ! (2 , task2 . waker_ref_count ()) ; drop (rx) ; assert ! (! task1 . is_woken ()) ; assert ! (task2 . is_woken ()) ; assert_ready ! (task2 . enter (| cx , _ | tx . poll_closed (cx))) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 6371216244622844437,
      "kind": "Function",
      "name": "receiver_is_terminated_send",
      "signature": "fn # [test] fn receiver_is_terminated_send () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after value is sent\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_eq ! (poll , Ok (17)) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 17731004004016348016,
      "kind": "Function",
      "name": "receiver_is_terminated_try_recv",
      "signature": "fn # [test] fn receiver_is_terminated_try_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after value is sent\") ; let value = rx . try_recv () . expect (\"value is waiting\") ; assert_eq ! (value , 17) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 1862345064428175899,
      "kind": "Function",
      "name": "receiver_is_terminated_drop",
      "signature": "fn # [test] fn receiver_is_terminated_drop () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before sender is dropped\") ; drop (tx) ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after sender is dropped\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 11141766459023402366,
      "kind": "Function",
      "name": "receiver_is_terminated_rx_close",
      "signature": "fn # [test] fn receiver_is_terminated_rx_close () { let (_tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before closing\") ; rx . close () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before closing\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 9591636243057856415,
      "kind": "Function",
      "name": "receiver_is_empty_send",
      "signature": "fn # [test] fn receiver_is_empty_send () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_empty () , \"channel is NOT empty after value is sent\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_eq ! (poll , Ok (17)) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 5693885904923475421,
      "kind": "Function",
      "name": "receiver_is_empty_try_recv",
      "signature": "fn # [test] fn receiver_is_empty_try_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_empty () , \"channel is NOT empty after value is sent\") ; let value = rx . try_recv () . expect (\"value is waiting\") ; assert_eq ! (value , 17) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13040337662070384666,
      "kind": "Function",
      "name": "receiver_is_empty_drop",
      "signature": "fn # [test] fn receiver_is_empty_drop () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before sender is dropped\") ; drop (tx) ; assert ! (rx . is_empty () , \"channel IS empty after sender is dropped\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 470189846105961926,
      "kind": "Function",
      "name": "receiver_is_empty_rx_close",
      "signature": "fn # [test] fn receiver_is_empty_rx_close () { let (_tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty ()) ; rx . close () ; assert ! (rx . is_empty ()) ; } . sig",
      "file_path": "tokio/tests/sync_oneshot.rs",
      "line": 0
    },
    {
      "hash": 13387572600071577568,
      "kind": "Function",
      "name": "broadcast_channel_panic_caller",
      "signature": "fn # [test] fn broadcast_channel_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (_ , _) = broadcast :: channel :: < u32 > (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 4046853522903389038,
      "kind": "Function",
      "name": "mutex_blocking_lock_panic_caller",
      "signature": "fn # [test] fn mutex_blocking_lock_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let mutex = Mutex :: new (5_u32) ; let _g = mutex . blocking_lock () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 12415336164037288491,
      "kind": "Function",
      "name": "oneshot_blocking_recv_panic_caller",
      "signature": "fn # [test] fn oneshot_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let (_tx , rx) = oneshot :: channel :: < u8 > () ; let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 8616392022137605352,
      "kind": "Function",
      "name": "rwlock_with_max_readers_panic_caller",
      "signature": "fn # [test] fn rwlock_with_max_readers_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = RwLock :: < u8 > :: with_max_readers (0 , (u32 :: MAX >> 3) + 1) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 17677697161768004342,
      "kind": "Function",
      "name": "rwlock_blocking_read_panic_caller",
      "signature": "fn # [test] fn rwlock_blocking_read_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let lock = RwLock :: < u8 > :: new (0) ; let _ = lock . blocking_read () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 13996574191640162977,
      "kind": "Function",
      "name": "rwlock_blocking_write_panic_caller",
      "signature": "fn # [test] fn rwlock_blocking_write_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let lock = RwLock :: < u8 > :: new (0) ; let _ = lock . blocking_write () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 5824058687812636065,
      "kind": "Function",
      "name": "mpsc_bounded_channel_panic_caller",
      "signature": "fn # [test] fn mpsc_bounded_channel_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (_ , _) = mpsc :: channel :: < u8 > (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 17993338085371167502,
      "kind": "Function",
      "name": "mpsc_bounded_receiver_blocking_recv_panic_caller",
      "signature": "fn # [test] fn mpsc_bounded_receiver_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 6212760877888170181,
      "kind": "Function",
      "name": "mpsc_bounded_receiver_blocking_recv_many_panic_caller",
      "signature": "fn # [test] fn mpsc_bounded_receiver_blocking_recv_many_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 11699235876623644050,
      "kind": "Function",
      "name": "mpsc_bounded_sender_blocking_send_panic_caller",
      "signature": "fn # [test] fn mpsc_bounded_sender_blocking_send_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (tx , _rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = tx . blocking_send (3) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 3764433035131759370,
      "kind": "Function",
      "name": "mpsc_unbounded_receiver_blocking_recv_panic_caller",
      "signature": "fn # [test] fn mpsc_unbounded_receiver_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: unbounded_channel :: < u8 > () ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 16882407884217890778,
      "kind": "Function",
      "name": "mpsc_unbounded_receiver_blocking_recv_many_panic_caller",
      "signature": "fn # [test] fn mpsc_unbounded_receiver_blocking_recv_many_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: unbounded_channel :: < u8 > () ; let mut vec = vec ! [] ; rt . block_on (async { let _ = rx . blocking_recv_many (& mut vec , 1) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 623338922291859441,
      "kind": "Function",
      "name": "semaphore_merge_unrelated_owned_permits",
      "signature": "fn # [test] fn semaphore_merge_unrelated_owned_permits () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let sem1 = Arc :: new (Semaphore :: new (42)) ; let sem2 = Arc :: new (Semaphore :: new (42)) ; let mut p1 = sem1 . try_acquire_owned () . unwrap () ; let p2 = sem2 . try_acquire_owned () . unwrap () ; p1 . merge (p2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 11008384395982268474,
      "kind": "Function",
      "name": "semaphore_merge_unrelated_permits",
      "signature": "fn # [test] fn semaphore_merge_unrelated_permits () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let sem1 = Semaphore :: new (42) ; let sem2 = Semaphore :: new (42) ; let mut p1 = sem1 . try_acquire () . unwrap () ; let p2 = sem2 . try_acquire () . unwrap () ; p1 . merge (p2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 17607925505439277,
      "kind": "Function",
      "name": "current_thread",
      "signature": "fn fn current_thread () -> Runtime { Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/sync_panic.rs",
      "line": 0
    },
    {
      "hash": 5845542486756332877,
      "kind": "Function",
      "name": "into_inner",
      "signature": "fn # [test] fn into_inner () { let rwlock = RwLock :: new (42) ; assert_eq ! (rwlock . into_inner () , 42) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 9358600024226061435,
      "kind": "Function",
      "name": "read_shared",
      "signature": "fn # [test] fn read_shared () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 5105449445798562513,
      "kind": "Function",
      "name": "write_shared_pending",
      "signature": "fn # [test] fn write_shared_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 12825535575301769255,
      "kind": "Function",
      "name": "read_exclusive_pending",
      "signature": "fn # [test] fn read_exclusive_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . write ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 49237567465953362,
      "kind": "Function",
      "name": "exhaust_reading",
      "signature": "fn # [test] fn exhaust_reading () { let rwlock = RwLock :: with_max_readers (100 , 1024) ; let mut reads = Vec :: new () ; loop { let mut t = spawn (rwlock . read ()) ; match t . poll () { Poll :: Ready (guard) => reads . push (guard) , Poll :: Pending => break , } } let mut t1 = spawn (rwlock . read ()) ; assert_pending ! (t1 . poll ()) ; let g2 = reads . pop () . unwrap () ; drop (g2) ; assert ! (t1 . is_woken ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 10359963539923626784,
      "kind": "Function",
      "name": "write_exclusive_pending",
      "signature": "fn # [test] fn write_exclusive_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . write ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 12857767006419407040,
      "kind": "Function",
      "name": "write_shared_drop",
      "signature": "fn # [test] fn write_shared_drop () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; drop (g1) ; assert ! (t2 . is_woken ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 11603403211237010673,
      "kind": "Function",
      "name": "write_read_shared_pending",
      "signature": "fn # [test] fn write_read_shared_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; let mut t3 = spawn (rwlock . write ()) ; assert_pending ! (t3 . poll ()) ; let mut t4 = spawn (rwlock . read ()) ; assert_pending ! (t4 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 15753246857635031917,
      "kind": "Function",
      "name": "write_read_shared_drop_pending",
      "signature": "fn # [test] fn write_read_shared_drop_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; let mut t3 = spawn (rwlock . read ()) ; assert_pending ! (t3 . poll ()) ; drop (t2) ; assert ! (t3 . is_woken ()) ; let _t3 = assert_ready ! (t3 . poll ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 13497141107428436781,
      "kind": "Function",
      "name": "read_uncontested",
      "signature": "fn # [maybe_tokio_test] async fn read_uncontested () { let rwlock = RwLock :: new (100) ; let result = * rwlock . read () . await ; assert_eq ! (result , 100) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 17365295272533537489,
      "kind": "Function",
      "name": "write_uncontested",
      "signature": "fn # [maybe_tokio_test] async fn write_uncontested () { let rwlock = RwLock :: new (100) ; let mut result = rwlock . write () . await ; * result += 50 ; assert_eq ! (* result , 150) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 4356799462924789562,
      "kind": "Function",
      "name": "write_order",
      "signature": "fn # [maybe_tokio_test] async fn write_order () { let rwlock = RwLock :: < Vec < u32 > > :: new (vec ! []) ; let fut2 = rwlock . write () . map (| mut guard | guard . push (2)) ; let fut1 = rwlock . write () . map (| mut guard | guard . push (1)) ; fut1 . await ; fut2 . await ; let g = rwlock . read () . await ; assert_eq ! (* g , vec ! [1 , 2]) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 12269597151649622305,
      "kind": "Function",
      "name": "multithreaded",
      "signature": "fn # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [cfg_attr (miri , ignore)] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 8)] async fn multithreaded () { use futures :: stream :: { self , StreamExt } ; use std :: sync :: Arc ; use tokio :: sync :: Barrier ; let barrier = Arc :: new (Barrier :: new (5)) ; let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone1 = rwlock . clone () ; let rwclone2 = rwlock . clone () ; let rwclone3 = rwlock . clone () ; let rwclone4 = rwlock . clone () ; let b1 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone1 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 2 ; } }) . await ; b1 . wait () . await ; }) ; let b2 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone2 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 3 ; } }) . await ; b2 . wait () . await ; }) ; let b3 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone3 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 5 ; } }) . await ; b3 . wait () . await ; }) ; let b4 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone4 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 7 ; } }) . await ; b4 . wait () . await ; }) ; barrier . wait () . await ; let g = rwlock . read () . await ; assert_eq ! (* g , 17_000) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 8804353858268345228,
      "kind": "Function",
      "name": "try_write",
      "signature": "fn # [maybe_tokio_test] async fn try_write () { let lock = RwLock :: new (0) ; let read_guard = lock . read () . await ; assert ! (lock . try_write () . is_err ()) ; drop (read_guard) ; assert ! (lock . try_write () . is_ok ()) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 4023945475641070281,
      "kind": "Function",
      "name": "try_read_try_write",
      "signature": "fn # [test] fn try_read_try_write () { let lock : RwLock < usize > = RwLock :: new (15) ; { let rg1 = lock . try_read () . unwrap () ; assert_eq ! (* rg1 , 15) ; assert ! (lock . try_write () . is_err ()) ; let rg2 = lock . try_read () . unwrap () ; assert_eq ! (* rg2 , 15) } { let mut wg = lock . try_write () . unwrap () ; * wg = 1515 ; assert ! (lock . try_read () . is_err ()) } assert_eq ! (* lock . try_read () . unwrap () , 1515) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 734958047055574608,
      "kind": "Function",
      "name": "downgrade_map",
      "signature": "fn # [maybe_tokio_test] async fn downgrade_map () { let lock = RwLock :: new (0) ; let write_guard = lock . write () . await ; let mut read_t = spawn (lock . read ()) ; assert_pending ! (read_t . poll ()) ; let read_guard1 = RwLockWriteGuard :: downgrade_map (write_guard , | v | { assert_pending ! (read_t . poll ()) ; v }) ; let read_guard2 = assert_ready ! (read_t . poll ()) ; assert_eq ! (&* read_guard1 as * const _ , &* read_guard2 as * const _) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 12806647527548423135,
      "kind": "Function",
      "name": "try_downgrade_map",
      "signature": "fn # [maybe_tokio_test] async fn try_downgrade_map () { let lock = RwLock :: new (0) ; let write_guard = lock . write () . await ; let mut read_t = spawn (lock . read ()) ; assert_pending ! (read_t . poll ()) ; let write_guard = RwLockWriteGuard :: try_downgrade_map (write_guard , | _ | { assert_pending ! (read_t . poll ()) ; None :: < & () > }) . expect_err (\"downgrade didn't fail\") ; assert_pending ! (read_t . poll ()) ; let read_guard1 = RwLockWriteGuard :: try_downgrade_map (write_guard , | v | Some (v)) . expect (\"downgrade didn't succeed\") ; let read_guard2 = assert_ready ! (read_t . poll ()) ; assert_eq ! (&* read_guard1 as * const _ , &* read_guard2 as * const _) ; } . sig",
      "file_path": "tokio/tests/sync_rwlock.rs",
      "line": 0
    },
    {
      "hash": 14406021201451424159,
      "kind": "Function",
      "name": "no_permits",
      "signature": "fn # [test] fn no_permits () { Semaphore :: new (0) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 1717347946596122850,
      "kind": "Function",
      "name": "try_acquire",
      "signature": "fn # [test] fn try_acquire () { let sem = Semaphore :: new (1) ; { let p1 = sem . try_acquire () ; assert ! (p1 . is_ok ()) ; let p2 = sem . try_acquire () ; assert ! (p2 . is_err ()) ; } let p3 = sem . try_acquire () ; assert ! (p3 . is_ok ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 13596880641557707768,
      "kind": "Function",
      "name": "acquire",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; let p1 = sem . try_acquire () . unwrap () ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire () . await ; }) ; drop (p1) ; j . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 16006162866700185492,
      "kind": "Function",
      "name": "add_permits",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn add_permits () { let sem = Arc :: new (Semaphore :: new (0)) ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire () . await ; }) ; sem . add_permits (1) ; j . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 2536253094907845123,
      "kind": "Function",
      "name": "forget",
      "signature": "fn # [test] fn forget () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p = sem . try_acquire () . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p . forget () ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 0) ; assert ! (sem . try_acquire () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 9550107141495422084,
      "kind": "Function",
      "name": "merge",
      "signature": "fn # [test] fn merge () { let sem = Arc :: new (Semaphore :: new (3)) ; { let mut p1 = sem . try_acquire () . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; let p2 = sem . try_acquire_many (2) . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p1 . merge (p2) ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 3) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 2857251921484565077,
      "kind": "Function",
      "name": "merge_unrelated_permits",
      "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] # [should_panic] fn merge_unrelated_permits () { let sem1 = Arc :: new (Semaphore :: new (3)) ; let sem2 = Arc :: new (Semaphore :: new (3)) ; let mut p1 = sem1 . try_acquire () . unwrap () ; let p2 = sem2 . try_acquire () . unwrap () ; p1 . merge (p2) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 16255500363657317664,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [test] fn split () { let sem = Semaphore :: new (5) ; let mut p1 = sem . try_acquire_many (3) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 3) ; let mut p2 = p1 . split (1) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 2) ; assert_eq ! (p2 . num_permits () , 1) ; let p3 = p1 . split (0) . unwrap () ; assert_eq ! (p3 . num_permits () , 0) ; drop (p1) ; assert_eq ! (sem . available_permits () , 4) ; let p4 = p2 . split (1) . unwrap () ; assert_eq ! (p2 . num_permits () , 0) ; assert_eq ! (p4 . num_permits () , 1) ; assert ! (p2 . split (1) . is_none ()) ; drop (p2) ; assert_eq ! (sem . available_permits () , 4) ; drop (p3) ; assert_eq ! (sem . available_permits () , 4) ; drop (p4) ; assert_eq ! (sem . available_permits () , 5) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 10041162398952795139,
      "kind": "Function",
      "name": "stress_test",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn stress_test () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut join_handles = Vec :: new () ; for _ in 0 .. 1000 { let sem_clone = sem . clone () ; join_handles . push (tokio :: spawn (async move { let _p = sem_clone . acquire () . await ; })) ; } for j in join_handles { j . await . unwrap () ; } let _p1 = sem . try_acquire () . unwrap () ; let _p2 = sem . try_acquire () . unwrap () ; let _p3 = sem . try_acquire () . unwrap () ; let _p4 = sem . try_acquire () . unwrap () ; let _p5 = sem . try_acquire () . unwrap () ; assert ! (sem . try_acquire () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 8987688131265299552,
      "kind": "Function",
      "name": "add_max_amount_permits",
      "signature": "fn # [test] fn add_max_amount_permits () { let s = tokio :: sync :: Semaphore :: new (0) ; s . add_permits (tokio :: sync :: Semaphore :: MAX_PERMITS) ; assert_eq ! (s . available_permits () , tokio :: sync :: Semaphore :: MAX_PERMITS) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 17237727762946709599,
      "kind": "Function",
      "name": "add_more_than_max_amount_permits1",
      "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn add_more_than_max_amount_permits1 () { let s = tokio :: sync :: Semaphore :: new (1) ; s . add_permits (tokio :: sync :: Semaphore :: MAX_PERMITS) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 18066783702060485169,
      "kind": "Function",
      "name": "add_more_than_max_amount_permits2",
      "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn add_more_than_max_amount_permits2 () { let s = Semaphore :: new (Semaphore :: MAX_PERMITS - 1) ; s . add_permits (1) ; s . add_permits (1) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 18013155987519105622,
      "kind": "Function",
      "name": "panic_when_exceeds_maxpermits",
      "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn panic_when_exceeds_maxpermits () { let _ = Semaphore :: new (Semaphore :: MAX_PERMITS + 1) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 4880120132243140406,
      "kind": "Function",
      "name": "no_panic_at_maxpermits",
      "signature": "fn # [test] fn no_panic_at_maxpermits () { let _ = Semaphore :: new (Semaphore :: MAX_PERMITS) ; let s = Semaphore :: new (Semaphore :: MAX_PERMITS - 1) ; s . add_permits (1) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore.rs",
      "line": 0
    },
    {
      "hash": 17673379437685994280,
      "kind": "Function",
      "name": "try_acquire",
      "signature": "fn # [test] fn try_acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p1 = sem . clone () . try_acquire_owned () ; assert ! (p1 . is_ok ()) ; let p2 = sem . clone () . try_acquire_owned () ; assert ! (p2 . is_err ()) ; } let p3 = sem . try_acquire_owned () ; assert ! (p3 . is_ok ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 5397099392776132675,
      "kind": "Function",
      "name": "try_acquire_many",
      "signature": "fn # [test] fn try_acquire_many () { let sem = Arc :: new (Semaphore :: new (42)) ; { let p1 = sem . clone () . try_acquire_many_owned (42) ; assert ! (p1 . is_ok ()) ; let p2 = sem . clone () . try_acquire_owned () ; assert ! (p2 . is_err ()) ; } let p3 = sem . clone () . try_acquire_many_owned (32) ; assert ! (p3 . is_ok ()) ; let p4 = sem . clone () . try_acquire_many_owned (10) ; assert ! (p4 . is_ok ()) ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 18038142062003201880,
      "kind": "Function",
      "name": "acquire",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; let p1 = sem . clone () . try_acquire_owned () . unwrap () ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire_owned () . await ; }) ; drop (p1) ; j . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 12904843231265233106,
      "kind": "Function",
      "name": "acquire_many",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire_many () { let semaphore = Arc :: new (Semaphore :: new (42)) ; let permit32 = semaphore . clone () . try_acquire_many_owned (32) . unwrap () ; let (sender , receiver) = tokio :: sync :: oneshot :: channel () ; let join_handle = tokio :: spawn (async move { let _permit10 = semaphore . clone () . acquire_many_owned (10) . await . unwrap () ; sender . send (()) . unwrap () ; let _permit32 = semaphore . acquire_many_owned (32) . await . unwrap () ; }) ; receiver . await . unwrap () ; drop (permit32) ; join_handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 2521262392708424595,
      "kind": "Function",
      "name": "add_permits",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn add_permits () { let sem = Arc :: new (Semaphore :: new (0)) ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire_owned () . await ; }) ; sem . add_permits (1) ; j . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 12752097356256320379,
      "kind": "Function",
      "name": "forget",
      "signature": "fn # [test] fn forget () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p = sem . clone () . try_acquire_owned () . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p . forget () ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 0) ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 14900951068720847215,
      "kind": "Function",
      "name": "merge",
      "signature": "fn # [test] fn merge () { let sem = Arc :: new (Semaphore :: new (3)) ; { let mut p1 = sem . clone () . try_acquire_owned () . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; let p2 = sem . clone () . try_acquire_many_owned (2) . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p1 . merge (p2) ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 3) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 5878307469221997005,
      "kind": "Function",
      "name": "merge_unrelated_permits",
      "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] # [should_panic] fn merge_unrelated_permits () { let sem1 = Arc :: new (Semaphore :: new (3)) ; let sem2 = Arc :: new (Semaphore :: new (3)) ; let mut p1 = sem1 . try_acquire_owned () . unwrap () ; let p2 = sem2 . try_acquire_owned () . unwrap () ; p1 . merge (p2) } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 2738234679007965981,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [test] fn split () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut p1 = sem . clone () . try_acquire_many_owned (3) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 3) ; let mut p2 = p1 . split (1) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 2) ; assert_eq ! (p2 . num_permits () , 1) ; let p3 = p1 . split (0) . unwrap () ; assert_eq ! (p3 . num_permits () , 0) ; drop (p1) ; assert_eq ! (sem . available_permits () , 4) ; let p4 = p2 . split (1) . unwrap () ; assert_eq ! (p2 . num_permits () , 0) ; assert_eq ! (p4 . num_permits () , 1) ; assert ! (p2 . split (1) . is_none ()) ; drop (p2) ; assert_eq ! (sem . available_permits () , 4) ; drop (p3) ; assert_eq ! (sem . available_permits () , 4) ; drop (p4) ; assert_eq ! (sem . available_permits () , 5) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 8848367746501360969,
      "kind": "Function",
      "name": "stress_test",
      "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn stress_test () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut join_handles = Vec :: new () ; for _ in 0 .. 1000 { let sem_clone = sem . clone () ; join_handles . push (tokio :: spawn (async move { let _p = sem_clone . acquire_owned () . await ; })) ; } for j in join_handles { j . await . unwrap () ; } let _p1 = sem . clone () . try_acquire_owned () . unwrap () ; let _p2 = sem . clone () . try_acquire_owned () . unwrap () ; let _p3 = sem . clone () . try_acquire_owned () . unwrap () ; let _p4 = sem . clone () . try_acquire_owned () . unwrap () ; let _p5 = sem . clone () . try_acquire_owned () . unwrap () ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_semaphore_owned.rs",
      "line": 0
    },
    {
      "hash": 12051801016839634738,
      "kind": "Function",
      "name": "drop_cell",
      "signature": "fn # [test] fn drop_cell () { let fooer = DropCounter :: new () ; let fooer_cl = fooer . clone () ; { let once_cell = SetOnce :: new () ; let prev = once_cell . set (fooer_cl) ; assert ! (prev . is_ok ()) } fooer . assert_num_drops (1) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 13753212680145301838,
      "kind": "Function",
      "name": "drop_cell_new_with",
      "signature": "fn # [test] fn drop_cell_new_with () { let fooer = DropCounter :: new () ; { let once_cell = SetOnce :: new_with (Some (fooer . clone ())) ; assert ! (once_cell . initialized ()) ; } fooer . assert_num_drops (1) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 13543917476209624133,
      "kind": "Function",
      "name": "drop_into_inner",
      "signature": "fn # [test] fn drop_into_inner () { let fooer = DropCounter :: new () ; let once_cell = SetOnce :: new () ; assert ! (once_cell . set (fooer . clone ()) . is_ok ()) ; let val = once_cell . into_inner () ; fooer . assert_num_drops (0) ; drop (val) ; fooer . assert_num_drops (1) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 7442706838848849029,
      "kind": "Function",
      "name": "drop_into_inner_new_with",
      "signature": "fn # [test] fn drop_into_inner_new_with () { let fooer = DropCounter :: new () ; let once_cell = SetOnce :: new_with (Some (fooer . clone ())) ; let val = once_cell . into_inner () ; fooer . assert_num_drops (0) ; drop (val) ; fooer . assert_num_drops (1) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 3960996571918112875,
      "kind": "Function",
      "name": "from",
      "signature": "fn # [test] fn from () { let cell = SetOnce :: from (2) ; assert_eq ! (* cell . get () . unwrap () , 2) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 15817568885586622853,
      "kind": "Function",
      "name": "set_and_get",
      "signature": "fn # [test] fn set_and_get () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; ONCE . set (5) . unwrap () ; let value = ONCE . get () . unwrap () ; assert_eq ! (* value , 5) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 15782416632361324711,
      "kind": "Function",
      "name": "set_and_wait",
      "signature": "fn # [tokio :: test] async fn set_and_wait () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; tokio :: spawn (async { ONCE . set (5) }) ; let value = ONCE . wait () . await ; assert_eq ! (* value , 5) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 13047256565425365288,
      "kind": "Function",
      "name": "set_and_wait_multiple_threads",
      "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn set_and_wait_multiple_threads () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let res1 = std :: thread :: spawn (| | ONCE . set (4)) ; let res2 = std :: thread :: spawn (| | ONCE . set (3)) ; let result_first = res1 . join () . unwrap () . is_err () ; let result_two = res2 . join () . unwrap () . is_err () ; assert ! (result_first != result_two) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 11363767960369034351,
      "kind": "Function",
      "name": "set_and_wait_threads",
      "signature": "fn # [tokio :: test] # [cfg_attr (target_family = \"wasm\" , ignore)] async fn set_and_wait_threads () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let thread = std :: thread :: spawn (| | { ONCE . set (4) . unwrap () ; }) ; let value = ONCE . wait () . await ; thread . join () . unwrap () ; assert_eq ! (* value , 4) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 8363364559973783969,
      "kind": "Function",
      "name": "get_uninit",
      "signature": "fn # [test] fn get_uninit () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let uninit = ONCE . get () ; assert ! (uninit . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 838307664020404964,
      "kind": "Function",
      "name": "set_twice",
      "signature": "fn # [test] fn set_twice () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let first = ONCE . set (5) ; assert_eq ! (first , Ok (())) ; let second = ONCE . set (6) ; assert ! (second . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 10056611433369687627,
      "kind": "Function",
      "name": "is_none_initializing",
      "signature": "fn # [test] fn is_none_initializing () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; assert_eq ! (ONCE . get () , None) ; ONCE . set (20) . unwrap () ; assert ! (ONCE . set (10) . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 16533938244754402427,
      "kind": "Function",
      "name": "is_some_initializing",
      "signature": "fn # [tokio :: test] async fn is_some_initializing () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; tokio :: spawn (async { ONCE . set (20) }) ; assert_eq ! (* ONCE . wait () . await , 20) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 14302160050580222099,
      "kind": "Function",
      "name": "into_inner_int_empty_setonce",
      "signature": "fn # [test] fn into_inner_int_empty_setonce () { let once = SetOnce :: < u32 > :: new () ; let val = once . into_inner () ; assert ! (val . is_none ()) ; } . sig",
      "file_path": "tokio/tests/sync_set_once.rs",
      "line": 0
    },
    {
      "hash": 6066616950069622713,
      "kind": "Function",
      "name": "single_rx_recv",
      "signature": "fn # [test] fn single_rx_recv () { let (tx , mut rx) = watch :: channel (\"one\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"one\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; tx . send (\"two\") . unwrap () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; drop (tx) ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 8013851127435986358,
      "kind": "Function",
      "name": "rx_version_underflow",
      "signature": "fn # [test] fn rx_version_underflow () { let (_tx , mut rx) = watch :: channel (\"one\") ; rx . mark_changed () ; rx . mark_changed () ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 10593803889051059607,
      "kind": "Function",
      "name": "rx_mark_changed",
      "signature": "fn # [test] fn rx_mark_changed () { let (tx , mut rx) = watch :: channel (\"one\") ; let mut rx2 = rx . clone () ; let mut rx3 = rx . clone () ; let mut rx4 = rx . clone () ; { rx . mark_changed () ; assert ! (rx . has_changed () . unwrap ()) ; let mut t = spawn (rx . changed ()) ; assert_ready_ok ! (t . poll ()) ; } { assert ! (! rx2 . has_changed () . unwrap ()) ; let mut t = spawn (rx2 . changed ()) ; assert_pending ! (t . poll ()) ; } { rx3 . mark_changed () ; assert_eq ! (* rx3 . borrow () , \"one\") ; assert ! (rx3 . has_changed () . unwrap ()) ; assert_eq ! (* rx3 . borrow_and_update () , \"one\") ; assert ! (! rx3 . has_changed () . unwrap ()) ; let mut t = spawn (rx3 . changed ()) ; assert_pending ! (t . poll ()) ; } { tx . send (\"two\") . unwrap () ; assert ! (rx4 . has_changed () . unwrap ()) ; assert_eq ! (* rx4 . borrow_and_update () , \"two\") ; rx4 . mark_changed () ; assert ! (rx4 . has_changed () . unwrap ()) ; assert_eq ! (* rx4 . borrow_and_update () , \"two\") } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 14444046628469454148,
      "kind": "Function",
      "name": "rx_mark_unchanged",
      "signature": "fn # [test] fn rx_mark_unchanged () { let (tx , mut rx) = watch :: channel (\"one\") ; let mut rx2 = rx . clone () ; { assert ! (! rx . has_changed () . unwrap ()) ; rx . mark_changed () ; assert ! (rx . has_changed () . unwrap ()) ; rx . mark_unchanged () ; assert ! (! rx . has_changed () . unwrap ()) ; let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; } { assert ! (! rx2 . has_changed () . unwrap ()) ; tx . send (\"two\") . unwrap () ; assert ! (rx2 . has_changed () . unwrap ()) ; rx2 . mark_unchanged () ; assert ! (! rx2 . has_changed () . unwrap ()) ; assert_eq ! (* rx2 . borrow_and_update () , \"two\") ; } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 6770073573256664576,
      "kind": "Function",
      "name": "multi_rx",
      "signature": "fn # [test] fn multi_rx () { let (tx , mut rx1) = watch :: channel (\"one\") ; let mut rx2 = rx1 . clone () ; { let mut t1 = spawn (rx1 . changed ()) ; let mut t2 = spawn (rx2 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"one\") ; assert_eq ! (* rx2 . borrow () , \"one\") ; let mut t2 = spawn (rx2 . changed ()) ; { let mut t1 = spawn (rx1 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; tx . send (\"two\") . unwrap () ; assert ! (t1 . is_woken ()) ; assert ! (t2 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"two\") ; { let mut t1 = spawn (rx1 . changed ()) ; assert_pending ! (t1 . poll ()) ; tx . send (\"three\") . unwrap () ; assert ! (t1 . is_woken ()) ; assert ! (t2 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; assert_ready_ok ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"three\") ; drop (t2) ; assert_eq ! (* rx2 . borrow () , \"three\") ; { let mut t1 = spawn (rx1 . changed ()) ; let mut t2 = spawn (rx2 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; tx . send (\"four\") . unwrap () ; assert_ready_ok ! (t1 . poll ()) ; assert_ready_ok ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"four\") ; assert_eq ! (* rx2 . borrow () , \"four\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 3468270449624115941,
      "kind": "Function",
      "name": "rx_observes_final_value",
      "signature": "fn # [test] fn rx_observes_final_value () { let (tx , mut rx) = watch :: channel (\"one\") ; drop (tx) ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_err ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"one\") ; let (tx , mut rx) = watch :: channel (\"one\") ; tx . send (\"two\") . unwrap () ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; { let mut t1 = spawn (rx . changed ()) ; assert_pending ! (t1 . poll ()) ; tx . send (\"three\") . unwrap () ; drop (tx) ; assert ! (t1 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"three\") ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_err ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"three\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 13117402382950414003,
      "kind": "Function",
      "name": "poll_close",
      "signature": "fn # [test] fn poll_close () { let (tx , rx) = watch :: channel (\"one\") ; { let mut t = spawn (tx . closed ()) ; assert_pending ! (t . poll ()) ; drop (rx) ; assert ! (t . is_woken ()) ; assert_ready ! (t . poll ()) ; } assert ! (tx . send (\"two\") . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 15022632830338580533,
      "kind": "Function",
      "name": "borrow_and_update",
      "signature": "fn # [test] fn borrow_and_update () { let (tx , mut rx) = watch :: channel (\"one\") ; assert ! (! rx . has_changed () . unwrap ()) ; tx . send (\"two\") . unwrap () ; assert ! (rx . has_changed () . unwrap ()) ; assert_ready ! (spawn (rx . changed ()) . poll ()) . unwrap () ; assert_pending ! (spawn (rx . changed ()) . poll ()) ; assert ! (! rx . has_changed () . unwrap ()) ; tx . send (\"three\") . unwrap () ; assert ! (rx . has_changed () . unwrap ()) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; assert_pending ! (spawn (rx . changed ()) . poll ()) ; assert ! (! rx . has_changed () . unwrap ()) ; drop (tx) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; assert_ready ! (spawn (rx . changed ()) . poll ()) . unwrap_err () ; assert ! (rx . has_changed () . is_err ()) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 13175693783830068357,
      "kind": "Function",
      "name": "reopened_after_subscribe",
      "signature": "fn # [test] fn reopened_after_subscribe () { let (tx , rx) = watch :: channel (\"one\") ; assert ! (! tx . is_closed ()) ; drop (rx) ; assert ! (tx . is_closed ()) ; let rx = tx . subscribe () ; assert ! (! tx . is_closed ()) ; drop (rx) ; assert ! (tx . is_closed ()) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 16294777613398298359,
      "kind": "Function",
      "name": "send_modify_panic",
      "signature": "fn # [test] # [cfg (panic = \"unwind\")] # [cfg (not (target_family = \"wasm\"))] fn send_modify_panic () { let (tx , mut rx) = watch :: channel (\"one\") ; tx . send_modify (| old | * old = \"two\") ; assert_eq ! (* rx . borrow_and_update () , \"two\") ; let mut rx2 = rx . clone () ; assert_eq ! (* rx2 . borrow_and_update () , \"two\") ; let mut task = spawn (rx2 . changed ()) ; let result = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { tx . send_modify (| old | { * old = \"panicked\" ; panic ! () ; }) })) ; assert ! (result . is_err ()) ; assert_pending ! (task . poll ()) ; assert_eq ! (* rx . borrow () , \"panicked\") ; tx . send_modify (| old | * old = \"three\") ; assert_ready_ok ! (task . poll ()) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 18232709095137727819,
      "kind": "Function",
      "name": "multiple_sender",
      "signature": "fn # [tokio :: test] async fn multiple_sender () { let (tx1 , mut rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let mut t = spawn (async { rx . changed () . await . unwrap () ; let v1 = * rx . borrow_and_update () ; rx . changed () . await . unwrap () ; let v2 = * rx . borrow_and_update () ; (v1 , v2) }) ; tx1 . send (1) . unwrap () ; assert_pending ! (t . poll ()) ; tx2 . send (2) . unwrap () ; assert_ready_eq ! (t . poll () , (1 , 2)) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 2102936959955655875,
      "kind": "Function",
      "name": "receiver_is_notified_when_last_sender_is_dropped",
      "signature": "fn # [tokio :: test] async fn receiver_is_notified_when_last_sender_is_dropped () { let (tx1 , mut rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; drop (tx1) ; assert ! (! t . is_woken ()) ; drop (tx2) ; assert ! (t . is_woken ()) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 219987130776239827,
      "kind": "Function",
      "name": "receiver_changed_is_cooperative",
      "signature": "fn # [tokio :: test] async fn receiver_changed_is_cooperative () { let (tx , mut rx) = watch :: channel (()) ; drop (tx) ; tokio :: select ! { biased ; _ = async { loop { assert ! (rx . changed () . await . is_err ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 6973280746688202650,
      "kind": "Function",
      "name": "receiver_changed_is_cooperative_ok",
      "signature": "fn # [tokio :: test] async fn receiver_changed_is_cooperative_ok () { let (tx , mut rx) = watch :: channel (()) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (()) . is_ok ()) ; assert ! (rx . changed () . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 9166842214839340874,
      "kind": "Function",
      "name": "receiver_wait_for_is_cooperative",
      "signature": "fn # [tokio :: test] async fn receiver_wait_for_is_cooperative () { let (tx , mut rx) = watch :: channel (0) ; drop (tx) ; tokio :: select ! { biased ; _ = async { loop { assert ! (rx . wait_for (| val | * val == 1) . await . is_err ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 2303482192688884829,
      "kind": "Function",
      "name": "receiver_wait_for_is_cooperative_ok",
      "signature": "fn # [tokio :: test] async fn receiver_wait_for_is_cooperative_ok () { let (tx , mut rx) = watch :: channel (0) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (1) . is_ok ()) ; assert ! (rx . wait_for (| val | * val == 1) . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 8527983839554978650,
      "kind": "Function",
      "name": "sender_closed_is_cooperative",
      "signature": "fn # [tokio :: test] async fn sender_closed_is_cooperative () { let (tx , rx) = watch :: channel (()) ; drop (rx) ; tokio :: select ! { _ = async { loop { tx . closed () . await ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 5082376378849013940,
      "kind": "Function",
      "name": "changed_succeeds_on_closed_channel_with_unseen_value",
      "signature": "fn # [tokio :: test] async fn changed_succeeds_on_closed_channel_with_unseen_value () { let (tx , mut rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . changed () . await . expect (\"should not return error as long as the current value is not seen\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 5492992113408616365,
      "kind": "Function",
      "name": "changed_errors_on_closed_channel_with_seen_value",
      "signature": "fn # [tokio :: test] async fn changed_errors_on_closed_channel_with_seen_value () { let (tx , mut rx) = watch :: channel (\"A\") ; drop (tx) ; rx . changed () . await . expect_err (\"should return error if the tx is closed and the current value is seen\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 7109059002590088102,
      "kind": "Function",
      "name": "has_changed_errors_on_closed_channel_with_unseen_value",
      "signature": "fn # [test] fn has_changed_errors_on_closed_channel_with_unseen_value () { let (tx , rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . has_changed () . expect_err (\"`has_changed` returns an error if and only if channel is closed. Even if the current value is not seen.\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 14262788797876679526,
      "kind": "Function",
      "name": "has_changed_errors_on_closed_channel_with_seen_value",
      "signature": "fn # [test] fn has_changed_errors_on_closed_channel_with_seen_value () { let (tx , rx) = watch :: channel (\"A\") ; drop (tx) ; rx . has_changed () . expect_err (\"`has_changed` returns an error if and only if channel is closed.\") ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 234139619143288476,
      "kind": "Function",
      "name": "wait_for_errors_on_closed_channel_true_predicate",
      "signature": "fn # [tokio :: test] async fn wait_for_errors_on_closed_channel_true_predicate () { let (tx , mut rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . wait_for (| _ | true) . await . expect (\"`wait_for` call does not return error even if channel is closed when predicate is true for last value.\" ,) ; } . sig",
      "file_path": "tokio/tests/sync_watch.rs",
      "line": 0
    },
    {
      "hash": 983126370980333480,
      "kind": "Struct",
      "name": "PanicOnDrop",
      "signature": "struct PanicOnDrop",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 2566757506768345690,
      "kind": "Function",
      "name": "test_abort_without_panic_3157",
      "signature": "fn # [doc = \" Checks that a suspended task can be aborted without panicking as reported in\"] # [doc = \" issue #3157: <https://github.com/tokio-rs/tokio/issues/3157>.\"] # [test] fn test_abort_without_panic_3157 () { let rt = Builder :: new_multi_thread () . enable_time () . worker_threads (1) . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; let _ = handle . await ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 8388576016128305616,
      "kind": "Function",
      "name": "test_abort_without_panic_3662",
      "signature": "fn # [doc = \" Checks that a suspended task can be aborted inside of a current_thread\"] # [doc = \" executor without panicking as reported in issue #3662:\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/3662>.\"] # [test] fn test_abort_without_panic_3662 () { use std :: sync :: atomic :: { AtomicBool , Ordering } ; use std :: sync :: Arc ; struct DropCheck (Arc < AtomicBool >) ; impl Drop for DropCheck { fn drop (& mut self) { self . 0 . store (true , Ordering :: SeqCst) ; } } let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let drop_flag = Arc :: new (AtomicBool :: new (false)) ; let drop_check = DropCheck (drop_flag . clone ()) ; let j = tokio :: spawn (async move { let _drop_check = drop_check ; futures :: future :: pending :: < () > () . await ; }) ; let drop_flag2 = drop_flag . clone () ; let task = std :: thread :: spawn (move | | { assert ! (! drop_flag2 . load (Ordering :: SeqCst)) ; j . abort () ; j }) . join () . unwrap () ; let result = task . await ; assert ! (drop_flag . load (Ordering :: SeqCst)) ; assert ! (result . unwrap_err () . is_cancelled ()) ; let i = tokio :: spawn (async move { tokio :: task :: yield_now () . await ; }) ; i . await . unwrap () ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 17974487892964773120,
      "kind": "Function",
      "name": "remote_abort_local_set_3929",
      "signature": "fn # [doc = \" Checks that a suspended LocalSet task can be aborted from a remote thread\"] # [doc = \" without panicking and without running the tasks destructor on the wrong thread.\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/3929>\"] # [test] fn remote_abort_local_set_3929 () { struct DropCheck { created_on : std :: thread :: ThreadId , not_send : std :: marker :: PhantomData < * const () > , } impl DropCheck { fn new () -> Self { Self { created_on : std :: thread :: current () . id () , not_send : std :: marker :: PhantomData , } } } impl Drop for DropCheck { fn drop (& mut self) { if std :: thread :: current () . id () != self . created_on { panic ! (\"non-Send value dropped in another thread!\") ; } } } let rt = Builder :: new_current_thread () . build () . unwrap () ; let local = tokio :: task :: LocalSet :: new () ; let check = DropCheck :: new () ; let jh = local . spawn_local (async move { futures :: future :: pending :: < () > () . await ; drop (check) ; }) ; let jh2 = std :: thread :: spawn (move | | { sleep (Duration :: from_millis (10)) ; jh . abort () ; }) ; rt . block_on (local) ; jh2 . join () . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 9367289239089058458,
      "kind": "Function",
      "name": "test_abort_wakes_task_3964",
      "signature": "fn # [doc = \" Checks that a suspended task can be aborted even if the `JoinHandle` is immediately dropped.\"] # [doc = \" issue #3964: <https://github.com/tokio-rs/tokio/issues/3964>.\"] # [test] fn test_abort_wakes_task_3964 () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let notify_dropped = Arc :: new (()) ; let weak_notify_dropped = Arc :: downgrade (& notify_dropped) ; let handle = tokio :: spawn (async move { let _notify_dropped = notify_dropped ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; drop (handle) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; assert ! (weak_notify_dropped . upgrade () . is_none ()) ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 2947330532719257759,
      "kind": "Function",
      "name": "test_abort_task_that_panics_on_drop_contained",
      "signature": "fn # [doc = \" Checks that aborting a task whose destructor panics does not allow the\"] # [doc = \" panic to escape the task.\"] # [test] # [cfg (panic = \"unwind\")] fn test_abort_task_that_panics_on_drop_contained () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { let _panic_dropped = PanicOnDrop ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; drop (handle) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 3409992334577242023,
      "kind": "Function",
      "name": "test_abort_task_that_panics_on_drop_returned",
      "signature": "fn # [doc = \" Checks that aborting a task whose destructor panics has the expected result.\"] # [test] # [cfg (panic = \"unwind\")] fn test_abort_task_that_panics_on_drop_returned () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { let _panic_dropped = PanicOnDrop ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; assert ! (handle . await . unwrap_err () . is_panic ()) ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 6148786205299129274,
      "kind": "Function",
      "name": "test_join_error_display",
      "signature": "fn # [doc = \" Checks that a `JoinError` with a panic payload prints the expected text.\"] # [test] # [cfg (panic = \"unwind\")] fn test_join_error_display () { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let join_err = tokio :: spawn (async move { let value = 1234 ; panic ! (\"Format-args payload: {value}\") }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked with message \\\"Format-args payload: 1234\\\"\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { panic ! (\"Const payload\") }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked with message \\\"Const payload\\\"\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { std :: panic :: panic_any (1234i32) }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked\") , \"Unexpected join_err_str {join_err_str:?}\") ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 16852406746961538207,
      "kind": "Function",
      "name": "test_join_error_debug",
      "signature": "fn # [doc = \" Checks that a `JoinError` with a panic payload prints the expected text from `Debug`.\"] # [test] # [cfg (panic = \"unwind\")] fn test_join_error_debug () { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let join_err = tokio :: spawn (async move { let value = 1234 ; panic ! (\"Format-args payload: {value}\") }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), \\\"Format-args payload: 1234\\\", ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { panic ! (\"Const payload\") }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), \\\"Const payload\\\", ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { std :: panic :: panic_any (1234i32) }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; }) ; } . sig",
      "file_path": "tokio/tests/task_abort.rs",
      "line": 0
    },
    {
      "hash": 14572529044994272123,
      "kind": "Function",
      "name": "basic_blocking",
      "signature": "fn # [tokio :: test] async fn basic_blocking () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { assert_ok ! (task :: spawn_blocking (|| { thread :: sleep (Duration :: from_millis (5)) ; \"hello\" }) . await) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 17204268364515458921,
      "kind": "Function",
      "name": "block_in_blocking",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn block_in_blocking () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { assert_ok ! (task :: spawn_blocking (|| { task :: block_in_place (|| { thread :: sleep (Duration :: from_millis (5)) ; }) ; \"hello\" }) . await) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 117701026360274840,
      "kind": "Function",
      "name": "block_in_block",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn block_in_block () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { task :: block_in_place (|| { task :: block_in_place (|| { thread :: sleep (Duration :: from_millis (5)) ; }) ; \"hello\" }) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 17775213447400972110,
      "kind": "Function",
      "name": "no_block_in_current_thread_scheduler",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] # [should_panic] async fn no_block_in_current_thread_scheduler () { task :: block_in_place (| | { }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 2872224969240922192,
      "kind": "Function",
      "name": "yes_block_in_threaded_block_on",
      "signature": "fn # [test] fn yes_block_in_threaded_block_on () { let rt = runtime :: Runtime :: new () . unwrap () ; rt . block_on (async { task :: block_in_place (| | { }) ; }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 2928509390795519568,
      "kind": "Function",
      "name": "no_block_in_current_thread_block_on",
      "signature": "fn # [test] # [should_panic] fn no_block_in_current_thread_block_on () { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { task :: block_in_place (| | { }) ; }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 16984774707604121219,
      "kind": "Function",
      "name": "can_enter_current_thread_rt_from_within_block_in_place",
      "signature": "fn # [test] fn can_enter_current_thread_rt_from_within_block_in_place () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { tokio :: task :: block_in_place (| | { let inner = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; inner . block_on (async { }) }) }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 9931759585688607366,
      "kind": "Function",
      "name": "useful_panic_message_when_dropping_rt_in_rt",
      "signature": "fn # [test] # [cfg (panic = \"unwind\")] fn useful_panic_message_when_dropping_rt_in_rt () { use std :: panic :: { catch_unwind , AssertUnwindSafe } ; let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; let result = catch_unwind (AssertUnwindSafe (| | { outer . block_on (async { let _ = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; }) ; })) ; assert ! (result . is_err ()) ; let err = result . unwrap_err () ; let err : & 'static str = err . downcast_ref :: < & 'static str > () . unwrap () ; assert ! (err . contains (\"Cannot drop a runtime\") , \"Wrong panic message: {err:?}\") ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 10010775776514873031,
      "kind": "Function",
      "name": "can_shutdown_with_zero_timeout_in_runtime",
      "signature": "fn # [test] fn can_shutdown_with_zero_timeout_in_runtime () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . shutdown_timeout (Duration :: from_nanos (0)) ; }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 14348664321070547147,
      "kind": "Function",
      "name": "can_shutdown_now_in_runtime",
      "signature": "fn # [test] fn can_shutdown_now_in_runtime () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . shutdown_background () ; }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 7074527432724656832,
      "kind": "Function",
      "name": "coop_disabled_in_block_in_place",
      "signature": "fn # [test] fn coop_disabled_in_block_in_place () { let outer = tokio :: runtime :: Builder :: new_multi_thread () . enable_time () . build () . unwrap () ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream () ; for i in 0 .. 200 { tx . send (i) . unwrap () ; } drop (tx) ; outer . block_on (async move { let jh = tokio :: spawn (async move { tokio :: task :: block_in_place (move | | { futures :: executor :: block_on (async move { use tokio_stream :: StreamExt ; assert_eq ! (rx . fold (0 , | n , _ | n + 1) . await , 200) ; }) }) }) ; tokio :: time :: timeout (Duration :: from_secs (1) , jh) . await . expect (\"timed out (probably hanging)\") . unwrap () }) ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 2093040174447671866,
      "kind": "Function",
      "name": "coop_disabled_in_block_in_place_in_block_on",
      "signature": "fn # [test] fn coop_disabled_in_block_in_place_in_block_on () { let (done_tx , done_rx) = std :: sync :: mpsc :: channel () ; let done = done_tx . clone () ; thread :: spawn (move | | { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream () ; for i in 0 .. 200 { tx . send (i) . unwrap () ; } drop (tx) ; outer . block_on (async move { tokio :: task :: block_in_place (move | | { futures :: executor :: block_on (async move { use tokio_stream :: StreamExt ; assert_eq ! (rx . fold (0 , | n , _ | n + 1) . await , 200) ; }) }) }) ; let _ = done . send (Ok (())) ; }) ; thread :: spawn (move | | { thread :: sleep (Duration :: from_secs (1)) ; let _ = done_tx . send (Err (\"timed out (probably hanging)\")) ; }) ; done_rx . recv () . unwrap () . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 17848449554212688447,
      "kind": "Function",
      "name": "blocking_when_paused",
      "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn blocking_when_paused () { time :: timeout (Duration :: from_secs (3) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (1))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; time :: timeout (Duration :: from_millis (1) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (50))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 18421974516022270047,
      "kind": "Function",
      "name": "blocking_task_wakes_paused_runtime",
      "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; time :: timeout (Duration :: from_secs (15) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (1))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 7390633862046505019,
      "kind": "Function",
      "name": "unawaited_blocking_task_wakes_paused_runtime",
      "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn unawaited_blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; let a = task :: spawn_blocking (| | { thread :: sleep (Duration :: from_millis (1)) ; }) ; crate :: time :: sleep (Duration :: from_secs (15)) . await ; a . await . expect (\"blocking task should finish\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 9612728547527856522,
      "kind": "Function",
      "name": "panicking_blocking_task_wakes_paused_runtime",
      "signature": "fn # [cfg (panic = \"unwind\")] # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn panicking_blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; let result = time :: timeout (Duration :: from_secs (15) , task :: spawn_blocking (| | { thread :: sleep (Duration :: from_millis (1)) ; panic ! (\"blocking task panicked\") ; }) ,) . await . expect (\"timeout should not trigger\") ; assert ! (result . is_err () , \"blocking task should have panicked\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
      "file_path": "tokio/tests/task_blocking.rs",
      "line": 0
    },
    {
      "hash": 16715109667259604586,
      "kind": "Function",
      "name": "spawn_with_name",
      "signature": "fn # [test] async fn spawn_with_name () { let result = Builder :: new () . name (\"name\") . spawn (async { \"task executed\" }) . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 14047628887411235549,
      "kind": "Function",
      "name": "spawn_blocking_with_name",
      "signature": "fn # [test] async fn spawn_blocking_with_name () { let result = Builder :: new () . name (\"name\") . spawn_blocking (| | \"task executed\") . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 3510089865164660056,
      "kind": "Function",
      "name": "spawn_local_with_name",
      "signature": "fn # [test] async fn spawn_local_with_name () { let unsend_data = Rc :: new (\"task executed\") ; let result = LocalSet :: new () . run_until (async move { Builder :: new () . name (\"name\") . spawn_local (async move { unsend_data }) . unwrap () . await }) . await ; assert_eq ! (* result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 12670744175653245698,
      "kind": "Function",
      "name": "spawn_without_name",
      "signature": "fn # [test] async fn spawn_without_name () { let result = Builder :: new () . spawn (async { \"task executed\" }) . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 14554923631877301842,
      "kind": "Function",
      "name": "spawn_blocking_without_name",
      "signature": "fn # [test] async fn spawn_blocking_without_name () { let result = Builder :: new () . spawn_blocking (| | \"task executed\") . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 18370874875487581382,
      "kind": "Function",
      "name": "spawn_local_without_name",
      "signature": "fn # [test] async fn spawn_local_without_name () { let unsend_data = Rc :: new (\"task executed\") ; let result = LocalSet :: new () . run_until (async move { Builder :: new () . spawn_local (async move { unsend_data }) . unwrap () . await }) . await ; assert_eq ! (* result . unwrap () , \"task executed\") ; } . sig",
      "file_path": "tokio/tests/task_builder.rs",
      "line": 0
    },
    {
      "hash": 8213991664402424135,
      "kind": "Function",
      "name": "spawn_task_hook_fires",
      "signature": "fn # [doc = \" Assert that the spawn task hook always fires when set.\"] # [test] fn spawn_task_hook_fires () { let count = Arc :: new (AtomicUsize :: new (0)) ; let count2 = Arc :: clone (& count) ; let ids = Arc :: new (Mutex :: new (HashSet :: new ())) ; let ids2 = Arc :: clone (& ids) ; let runtime = Builder :: new_current_thread () . on_task_spawn (move | data | { ids2 . lock () . unwrap () . insert (data . id ()) ; count2 . fetch_add (1 , Ordering :: SeqCst) ; }) . build () . unwrap () ; for _ in 0 .. TASKS { runtime . spawn (std :: future :: pending :: < () > ()) ; } let count_realized = count . load (Ordering :: SeqCst) ; assert_eq ! (TASKS , count_realized , \"Total number of spawned task hook invocations was incorrect, expected {TASKS}, got {count_realized}\") ; let count_ids_realized = ids . lock () . unwrap () . len () ; assert_eq ! (TASKS , count_ids_realized , \"Total number of spawned task hook invocations was incorrect, expected {TASKS}, got {count_realized}\") ; } . sig",
      "file_path": "tokio/tests/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 11998762311337940711,
      "kind": "Function",
      "name": "terminate_task_hook_fires",
      "signature": "fn # [doc = \" Assert that the terminate task hook always fires when set.\"] # [test] fn terminate_task_hook_fires () { let count = Arc :: new (AtomicUsize :: new (0)) ; let count2 = Arc :: clone (& count) ; let runtime = Builder :: new_current_thread () . on_task_terminate (move | _data | { count2 . fetch_add (1 , Ordering :: SeqCst) ; }) . build () . unwrap () ; for _ in 0 .. TASKS { runtime . spawn (std :: future :: ready (())) ; } runtime . block_on (async { for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; assert_eq ! (TASKS , count . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 6444771624024440531,
      "kind": "Function",
      "name": "task_hook_spawn_location_current_thread",
      "signature": "fn # [doc = \" Test that the correct spawn location is provided to the task hooks on a\"] # [doc = \" current thread runtime.\"] # [test] fn task_hook_spawn_location_current_thread () { let spawns = Arc :: new (AtomicUsize :: new (0)) ; let poll_starts = Arc :: new (AtomicUsize :: new (0)) ; let poll_ends = Arc :: new (AtomicUsize :: new (0)) ; let runtime = Builder :: new_current_thread () . on_task_spawn (mk_spawn_location_hook (\"(current_thread) on_task_spawn\" , & spawns ,)) . on_before_task_poll (mk_spawn_location_hook (\"(current_thread) on_before_task_poll\" , & poll_starts ,)) . on_after_task_poll (mk_spawn_location_hook (\"(current_thread) on_after_task_poll\" , & poll_ends ,)) . build () . unwrap () ; let task = runtime . spawn (async move { tokio :: task :: yield_now () . await }) ; runtime . block_on (async move { task . await . unwrap () ; tokio :: spawn (async move { }) . await . unwrap () ; for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; assert_eq ! (spawns . load (Ordering :: SeqCst) , 2) ; let poll_starts = poll_starts . load (Ordering :: SeqCst) ; assert ! (poll_starts > 2) ; assert_eq ! (poll_starts , poll_ends . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 3563936144158874833,
      "kind": "Function",
      "name": "task_hook_spawn_location_multi_thread",
      "signature": "fn # [doc = \" Test that the correct spawn location is provided to the task hooks on a\"] # [doc = \" multi-thread runtime.\"] # [doc = \"\"] # [doc = \" Testing this separately is necessary as the spawn code paths are different\"] # [doc = \" and we should ensure that `#[track_caller]` is passed through correctly\"] # [doc = \" for both runtimes.\"] # [cfg_attr (target_os = \"wasi\" , ignore = \"WASI does not support multi-threaded runtime\")] # [test] fn task_hook_spawn_location_multi_thread () { let spawns = Arc :: new (AtomicUsize :: new (0)) ; let poll_starts = Arc :: new (AtomicUsize :: new (0)) ; let poll_ends = Arc :: new (AtomicUsize :: new (0)) ; let runtime = Builder :: new_multi_thread () . on_task_spawn (mk_spawn_location_hook (\"(multi_thread) on_task_spawn\" , & spawns ,)) . on_before_task_poll (mk_spawn_location_hook (\"(multi_thread) on_before_task_poll\" , & poll_starts ,)) . on_after_task_poll (mk_spawn_location_hook (\"(multi_thread) on_after_task_poll\" , & poll_ends ,)) . build () . unwrap () ; let task = runtime . spawn (async move { tokio :: task :: yield_now () . await }) ; runtime . block_on (async move { task . await . unwrap () ; tokio :: spawn (async move { }) . await . unwrap () ; for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; runtime . shutdown_timeout (std :: time :: Duration :: from_secs (60)) ; assert_eq ! (spawns . fetch_add (0 , Ordering :: SeqCst) , 2) ; let poll_starts = poll_starts . fetch_add (0 , Ordering :: SeqCst) ; assert ! (poll_starts > 2) ; assert_eq ! (poll_starts , poll_ends . fetch_add (0 , Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 16678979107221977201,
      "kind": "Function",
      "name": "mk_spawn_location_hook",
      "signature": "fn fn mk_spawn_location_hook (event : & 'static str , count : & Arc < AtomicUsize > ,) -> impl Fn (& tokio :: runtime :: TaskMeta < '_ >) { let count = Arc :: clone (count) ; move | data | { eprintln ! (\"{event} ({:?}): {:?}\" , data . id () , data . spawned_at ()) ; assert_eq ! (data . spawned_at () . file () , file ! () , \"incorrect spawn location in {event} hook\" ,) ; count . fetch_add (1 , Ordering :: SeqCst) ; } } . sig",
      "file_path": "tokio/tests/task_hooks.rs",
      "line": 0
    },
    {
      "hash": 367455857625888554,
      "kind": "Function",
      "name": "task_id_spawn",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn () { tokio :: spawn (async { println ! (\"task id: {}\" , task :: id ()) }) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 1492014721713161550,
      "kind": "Function",
      "name": "task_id_spawn_blocking",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn_blocking () { task :: spawn_blocking (| | println ! (\"task id: {}\" , task :: id ())) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 6423050855454923144,
      "kind": "Function",
      "name": "task_id_collision_current_thread",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_collision_current_thread () { let handle1 = tokio :: spawn (async { task :: id () }) ; let handle2 = tokio :: spawn (async { task :: id () }) ; let (id1 , id2) = tokio :: join ! (handle1 , handle2) ; assert_ne ! (id1 . unwrap () , id2 . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 12217291724632354523,
      "kind": "Function",
      "name": "task_id_collision_multi_thread",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_collision_multi_thread () { let handle1 = tokio :: spawn (async { task :: id () }) ; let handle2 = tokio :: spawn (async { task :: id () }) ; let (id1 , id2) = tokio :: join ! (handle1 , handle2) ; assert_ne ! (id1 . unwrap () , id2 . unwrap ()) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 7376601800174650245,
      "kind": "Function",
      "name": "task_ids_match_current_thread",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_ids_match_current_thread () { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async { let id = rx . await . unwrap () ; assert_eq ! (id , task :: id ()) ; }) ; tx . send (handle . id ()) . unwrap () ; handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 16937513537180172270,
      "kind": "Function",
      "name": "task_ids_match_multi_thread",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_ids_match_multi_thread () { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async { let id = rx . await . unwrap () ; assert_eq ! (id , task :: id ()) ; }) ; tx . send (handle . id ()) . unwrap () ; handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 4119980755931230505,
      "kind": "Function",
      "name": "task_id_future_destructor_completion",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_future_destructor_completion () { struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Ready (()) } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; handle . await . unwrap () ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 6129210290358737687,
      "kind": "Function",
      "name": "task_id_future_destructor_abort",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_future_destructor_abort () { struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; handle . abort () ; assert ! (handle . await . unwrap_err () . is_cancelled ()) ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 10380131602880152661,
      "kind": "Function",
      "name": "task_id_output_destructor_handle_dropped_before_completion",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_output_destructor_handle_dropped_before_completion () { struct MyOutput { tx : Option < oneshot :: Sender < Id > > , } impl Drop for MyOutput { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = MyOutput ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < Self :: Output > { Poll :: Ready (MyOutput { tx : self . tx . take () }) } } let (tx , mut rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; drop (handle) ; assert ! (rx . try_recv () . is_err ()) ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 15694100891088291563,
      "kind": "Function",
      "name": "task_id_output_destructor_handle_dropped_after_completion",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_output_destructor_handle_dropped_after_completion () { struct MyOutput { tx : Option < oneshot :: Sender < Id > > , } impl Drop for MyOutput { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } struct MyFuture { tx_output : Option < oneshot :: Sender < Id > > , tx_future : Option < oneshot :: Sender < () > > , } impl Future for MyFuture { type Output = MyOutput ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < Self :: Output > { let _ = self . tx_future . take () . unwrap () . send (()) ; Poll :: Ready (MyOutput { tx : self . tx_output . take () , }) } } let (tx_output , mut rx_output) = oneshot :: channel () ; let (tx_future , rx_future) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx_output : Some (tx_output) , tx_future : Some (tx_future) , }) ; let id = handle . id () ; rx_future . await . unwrap () ; assert ! (rx_output . try_recv () . is_err ()) ; drop (handle) ; assert_eq ! (rx_output . await . unwrap () , id) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 9184818769294877101,
      "kind": "Function",
      "name": "task_try_id_outside_task",
      "signature": "fn # [test] fn task_try_id_outside_task () { assert_eq ! (None , task :: try_id ()) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 9450237520324146012,
      "kind": "Function",
      "name": "task_try_id_inside_block_on",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn task_try_id_inside_block_on () { let rt = Runtime :: new () . unwrap () ; rt . block_on (async { assert_eq ! (None , task :: try_id ()) ; }) ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 347824363962640268,
      "kind": "Function",
      "name": "task_id_spawn_local",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn_local () { LocalSet :: new () . run_until (async { task :: spawn_local (async { println ! (\"task id: {}\" , task :: id ()) }) . await . unwrap () ; }) . await } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 1799863013880754873,
      "kind": "Function",
      "name": "task_id_nested_spawn_local",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_nested_spawn_local () { LocalSet :: new () . run_until (async { task :: spawn_local (async { let parent_id = task :: id () ; LocalSet :: new () . run_until (async { task :: spawn_local (async move { assert_ne ! (parent_id , task :: id ()) ; }) . await . unwrap () ; }) . await ; assert_eq ! (parent_id , task :: id ()) ; }) . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 3439621431795026406,
      "kind": "Function",
      "name": "task_id_block_in_place_block_on_spawn",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_block_in_place_block_on_spawn () { use tokio :: runtime :: Builder ; task :: spawn (async { let parent_id = task :: id () ; task :: block_in_place (move | | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (rt . spawn (async move { assert_ne ! (parent_id , task :: id ()) ; })) . unwrap () ; }) ; assert_eq ! (parent_id , task :: id ()) ; }) . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 423889870004274216,
      "kind": "Function",
      "name": "task_id_outside_task_panic_caller",
      "signature": "fn # [test] # [cfg_attr (not (panic = \"unwind\") , ignore)] fn task_id_outside_task_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = task :: id () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 17746559157996494071,
      "kind": "Function",
      "name": "task_id_inside_block_on_panic_caller",
      "signature": "fn # [test] # [cfg_attr (not (panic = \"unwind\") , ignore)] fn task_id_inside_block_on_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Runtime :: new () . unwrap () ; rt . block_on (async { task :: id () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_id.rs",
      "line": 0
    },
    {
      "hash": 5891707486288276690,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 15256175146594665249,
      "kind": "Function",
      "name": "test_with_sleep",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_with_sleep () { let mut set = JoinSet :: new () ; for i in 0 .. 10 { set . spawn (async move { i }) ; assert_eq ! (set . len () , 1 + i) ; } set . detach_all () ; assert_eq ! (set . len () , 0) ; assert ! (set . join_next () . await . is_none ()) ; for i in 0 .. 10 { set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; assert_eq ! (set . len () , 1 + i) ; } let mut seen = [false ; 10] ; while let Some (res) = set . join_next () . await . transpose () . unwrap () { seen [res] = true ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (set . join_next () . await . is_none ()) ; for i in 0 .. 10 { set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; } let mut seen = [false ; 10] ; while let Some (res) = set . join_next () . await . transpose () . unwrap () { seen [res] = true ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (set . join_next () . await . is_none ()) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 10048830300709954705,
      "kind": "Function",
      "name": "test_abort_on_drop",
      "signature": "fn # [tokio :: test] async fn test_abort_on_drop () { let mut set = JoinSet :: new () ; let mut recvs = Vec :: new () ; for _ in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; set . spawn (async { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (set) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 6410102816910256757,
      "kind": "Function",
      "name": "alternating",
      "signature": "fn # [tokio :: test] async fn alternating () { let mut set = JoinSet :: new () ; assert_eq ! (set . len () , 0) ; set . spawn (async { }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { }) ; assert_eq ! (set . len () , 2) ; for _ in 0 .. 16 { let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; set . spawn (async { }) ; assert_eq ! (set . len () , 2) ; } } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 7187591997502217986,
      "kind": "Function",
      "name": "abort_tasks",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_tasks () { let mut set = JoinSet :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { let abort = set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; if i % 2 != 0 { abort . abort () ; } } loop { match set . join_next () . await { Some (Ok (res)) => { num_completed += 1 ; assert_eq ! (res % 2 , 0) ; } Some (Err (e)) => { assert ! (e . is_cancelled ()) ; num_canceled += 1 ; } None => break , } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 8858037829613475501,
      "kind": "Function",
      "name": "runtime_gone",
      "signature": "fn # [test] fn runtime_gone () { let mut set = JoinSet :: new () ; { let rt = rt () ; set . spawn_on (async { 1 } , rt . handle ()) ; drop (rt) ; } assert ! (rt () . block_on (set . join_next ()) . unwrap () . unwrap_err () . is_cancelled ()) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 1880040534497742791,
      "kind": "Function",
      "name": "join_all",
      "signature": "fn # [tokio :: test] async fn join_all () { let mut set : JoinSet < i32 > = JoinSet :: new () ; for _ in 0 .. 5 { set . spawn (async { 1 }) ; } let res : Vec < i32 > = set . join_all () . await ; assert_eq ! (res . len () , 5) ; for itm in res . into_iter () { assert_eq ! (itm , 1) } } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 4513196968393296261,
      "kind": "Function",
      "name": "task_panics",
      "signature": "fn # [cfg (panic = \"unwind\")] # [tokio :: test (start_paused = true)] async fn task_panics () { let mut set : JoinSet < () > = JoinSet :: new () ; let (tx , mut rx) = oneshot :: channel () ; assert_eq ! (set . len () , 0) ; set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (2)) . await ; tx . send (()) . unwrap () ; }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; panic ! () ; }) ; assert_eq ! (set . len () , 2) ; let panic = tokio :: spawn (set . join_all ()) . await . unwrap_err () ; assert ! (rx . try_recv () . is_err ()) ; assert ! (panic . is_panic ()) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 13889614782080215340,
      "kind": "Function",
      "name": "abort_all",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_all () { let mut set : JoinSet < () > = JoinSet :: new () ; for _ in 0 .. 5 { set . spawn (futures :: future :: pending ()) ; } for _ in 0 .. 5 { set . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; set . abort_all () ; assert_eq ! (set . len () , 10) ; let mut count = 0 ; while let Some (res) = set . join_next () . await { if let Err (err) = res { assert ! (err . is_cancelled ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert_eq ! (set . len () , 0) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 993391392224163574,
      "kind": "Function",
      "name": "join_set_coop",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn join_set_coop () { const TASK_NUM : u32 = 1000 ; static SEM : tokio :: sync :: Semaphore = tokio :: sync :: Semaphore :: const_new (0) ; let mut set = JoinSet :: new () ; for _ in 0 .. TASK_NUM { set . spawn (async { SEM . add_permits (1) ; }) ; } let _ = SEM . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; loop { match set . join_next () . now_or_never () { Some (Some (Ok (()))) => { } Some (Some (Err (err))) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; continue ; } Some (None) => break , } count += 1 ; } assert ! (coop_count >= 1) ; assert_eq ! (count , TASK_NUM) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 5184405831751534577,
      "kind": "Function",
      "name": "try_join_next",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn try_join_next () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut set = JoinSet :: new () ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; set . spawn (async move { recv . changed () . await . unwrap () }) ; } drop (recv) ; assert ! (set . try_join_next () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; loop { match set . try_join_next () { Some (Ok (())) => { count += 1 ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { break ; } } } assert_eq ! (count , TASK_NUM) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 12732859433062740611,
      "kind": "Function",
      "name": "try_join_next_with_id",
      "signature": "fn # [cfg (tokio_unstable)] # [tokio :: test (flavor = \"current_thread\")] async fn try_join_next_with_id () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut set = JoinSet :: new () ; let mut spawned = std :: collections :: HashSet :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = set . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . insert (handle . id ()) ; } drop (recv) ; assert ! (set . try_join_next_with_id () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut joined = std :: collections :: HashSet :: with_capacity (TASK_NUM as usize) ; loop { match set . try_join_next_with_id () { Some (Ok ((id , ()))) => { count += 1 ; joined . insert (id) ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { break ; } } } assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
      "file_path": "tokio/tests/task_join_set.rs",
      "line": 0
    },
    {
      "hash": 17336033494733351450,
      "kind": "Function",
      "name": "local",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn local () { tokio :: task_local ! { static REQ_ID : u32 ; pub static FOO : bool ; } let j1 = tokio :: spawn (REQ_ID . scope (1 , async move { assert_eq ! (REQ_ID . get () , 1) ; assert_eq ! (REQ_ID . get () , 1) ; })) ; let j2 = tokio :: spawn (REQ_ID . scope (2 , async move { REQ_ID . with (| v | { assert_eq ! (REQ_ID . get () , 2) ; assert_eq ! (* v , 2) ; }) ; tokio :: time :: sleep (std :: time :: Duration :: from_millis (10)) . await ; assert_eq ! (REQ_ID . get () , 2) ; })) ; let j3 = tokio :: spawn (FOO . scope (true , async move { assert ! (FOO . get ()) ; })) ; j1 . await . unwrap () ; j2 . await . unwrap () ; j3 . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_local.rs",
      "line": 0
    },
    {
      "hash": 14719074099648443943,
      "kind": "Function",
      "name": "task_local_available_on_abort",
      "signature": "fn # [tokio :: test] async fn task_local_available_on_abort () { tokio :: task_local ! { static KEY : u32 ; } struct MyFuture { tx_poll : Option < oneshot :: Sender < () > > , tx_drop : Option < oneshot :: Sender < u32 > > , } impl Future for MyFuture { type Output = () ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { if let Some (tx_poll) = self . tx_poll . take () { let _ = tx_poll . send (()) ; } Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx_drop . take () . unwrap () . send (KEY . get ()) ; } } let (tx_drop , rx_drop) = oneshot :: channel () ; let (tx_poll , rx_poll) = oneshot :: channel () ; let h = tokio :: spawn (KEY . scope (42 , MyFuture { tx_poll : Some (tx_poll) , tx_drop : Some (tx_drop) , } ,)) ; rx_poll . await . unwrap () ; h . abort () ; assert_eq ! (rx_drop . await . unwrap () , 42) ; let err = h . await . unwrap_err () ; if ! err . is_cancelled () { if let Ok (panic) = err . try_into_panic () { std :: panic :: resume_unwind (panic) ; } else { panic ! () ; } } } . sig",
      "file_path": "tokio/tests/task_local.rs",
      "line": 0
    },
    {
      "hash": 16156986260793863957,
      "kind": "Function",
      "name": "task_local_available_on_completion_drop",
      "signature": "fn # [tokio :: test] async fn task_local_available_on_completion_drop () { tokio :: task_local ! { static KEY : u32 ; } struct MyFuture { tx : Option < oneshot :: Sender < u32 > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Ready (()) } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (KEY . get ()) ; } } let (tx , rx) = oneshot :: channel () ; let h = tokio :: spawn (KEY . scope (42 , MyFuture { tx : Some (tx) })) ; assert_eq ! (rx . await . unwrap () , 42) ; h . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_local.rs",
      "line": 0
    },
    {
      "hash": 15844592712379918090,
      "kind": "Function",
      "name": "take_value",
      "signature": "fn # [tokio :: test] async fn take_value () { tokio :: task_local ! { static KEY : u32 } let fut = KEY . scope (1 , async { }) ; let mut pinned = Box :: pin (fut) ; assert_eq ! (pinned . as_mut () . take_value () , Some (1)) ; assert_eq ! (pinned . as_mut () . take_value () , None) ; } . sig",
      "file_path": "tokio/tests/task_local.rs",
      "line": 0
    },
    {
      "hash": 6446032468398531633,
      "kind": "Function",
      "name": "poll_after_take_value_should_fail",
      "signature": "fn # [tokio :: test] async fn poll_after_take_value_should_fail () { tokio :: task_local ! { static KEY : u32 } let fut = KEY . scope (1 , async { let result = KEY . try_with (| _ | { }) ; assert ! (result . is_err ()) ; }) ; let mut fut = Box :: pin (fut) ; fut . as_mut () . take_value () ; fut . await ; } . sig",
      "file_path": "tokio/tests/task_local.rs",
      "line": 0
    },
    {
      "hash": 13500464484131334586,
      "kind": "Function",
      "name": "local_current_thread_scheduler",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn local_current_thread_scheduler () { LocalSet :: new () . run_until (async { task :: spawn_local (async { }) . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12145999199811359993,
      "kind": "Function",
      "name": "local_threadpool",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12105311336746641597,
      "kind": "Function",
      "name": "localset_future_threadpool",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_future_threadpool () { thread_local ! { static ON_LOCAL_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_LOCAL_THREAD . with (| cell | cell . set (true)) ; let local = LocalSet :: new () ; local . spawn_local (async move { assert ! (ON_LOCAL_THREAD . with (| cell | cell . get ())) ; }) ; local . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 3614263767005676208,
      "kind": "Function",
      "name": "localset_future_timers",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_future_timers () { static RAN1 : AtomicBool = AtomicBool :: new (false) ; static RAN2 : AtomicBool = AtomicBool :: new (false) ; let local = LocalSet :: new () ; local . spawn_local (async move { time :: sleep (Duration :: from_millis (5)) . await ; RAN1 . store (true , Ordering :: SeqCst) ; }) ; local . spawn_local (async move { time :: sleep (Duration :: from_millis (10)) . await ; RAN2 . store (true , Ordering :: SeqCst) ; }) ; local . await ; assert ! (RAN1 . load (Ordering :: SeqCst)) ; assert ! (RAN2 . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 17547399741605069003,
      "kind": "Function",
      "name": "localset_future_drives_all_local_futs",
      "signature": "fn # [tokio :: test] async fn localset_future_drives_all_local_futs () { static RAN1 : AtomicBool = AtomicBool :: new (false) ; static RAN2 : AtomicBool = AtomicBool :: new (false) ; static RAN3 : AtomicBool = AtomicBool :: new (false) ; let local = LocalSet :: new () ; local . spawn_local (async move { task :: spawn_local (async { task :: yield_now () . await ; RAN3 . store (true , Ordering :: SeqCst) ; }) ; task :: yield_now () . await ; RAN1 . store (true , Ordering :: SeqCst) ; }) ; local . spawn_local (async move { task :: yield_now () . await ; RAN2 . store (true , Ordering :: SeqCst) ; }) ; local . await ; assert ! (RAN1 . load (Ordering :: SeqCst)) ; assert ! (RAN2 . load (Ordering :: SeqCst)) ; assert ! (RAN3 . load (Ordering :: SeqCst)) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12909729819351612380,
      "kind": "Function",
      "name": "local_threadpool_timer",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool_timer () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; time :: sleep (Duration :: from_millis (10)) . await ; assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) ; join . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 5708105121867876287,
      "kind": "Function",
      "name": "enter_guard_spawn",
      "signature": "fn # [test] fn enter_guard_spawn () { let local = LocalSet :: new () ; let _guard = local . enter () ; let join = task :: spawn_local (async { true }) ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; local . block_on (& rt , async move { assert ! (join . await . unwrap ()) ; }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 16122979617832062297,
      "kind": "Function",
      "name": "local_threadpool_blocking_run",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool_blocking_run () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_blocking (| | { assert ! (! ON_RT_THREAD . with (| cell | cell . get ()) , \"blocking must not run on the local task set's thread\") ; }) . await . unwrap () ; assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) ; join . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 10489335907707987220,
      "kind": "Function",
      "name": "all_spawns_are_local",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn all_spawns_are_local () { use futures :: future ; thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let handles = (0 .. 128) . map (| _ | { task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) }) . collect :: < Vec < _ > > () ; for joined in future :: join_all (handles) . await { joined . unwrap () ; } }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12076316885531027335,
      "kind": "Function",
      "name": "nested_spawn_is_local",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn nested_spawn_is_local () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 14351076794983877489,
      "kind": "Function",
      "name": "join_local_future_elsewhere",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn join_local_future_elsewhere () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; let rt = runtime :: Runtime :: new () . unwrap () ; let local = LocalSet :: new () ; local . block_on (& rt , async move { let (tx , rx) = oneshot :: channel () ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ()) , \"local task must run on local thread, no matter where it is awaited\") ; rx . await . unwrap () ; \"hello world\" }) ; let join2 = task :: spawn (async move { assert ! (! ON_RT_THREAD . with (| cell | cell . get ()) , \"spawned task should be on a worker\") ; tx . send (()) . expect (\"task shouldn't have ended yet\") ; join . await . expect (\"task should complete successfully\") ; }) ; join2 . await . unwrap () }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 3869203324620747300,
      "kind": "Function",
      "name": "localset_in_thread_local",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_in_thread_local () { thread_local ! { static LOCAL_SET : LocalSet = LocalSet :: new () ; } let (_tx , rx) = oneshot :: channel :: < () > () ; let handle = tokio :: runtime :: Handle :: current () ; std :: thread :: spawn (move | | { LOCAL_SET . with (| local_set | { handle . block_on (local_set . run_until (async move { let _ = rx . await ; })) }) ; }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 14075706687756401115,
      "kind": "Function",
      "name": "drop_cancels_tasks",
      "signature": "fn # [test] fn drop_cancels_tasks () { use std :: rc :: Rc ; let rt = rt () ; let rc1 = Rc :: new (()) ; let rc2 = rc1 . clone () ; let (started_tx , started_rx) = oneshot :: channel () ; let local = LocalSet :: new () ; local . spawn_local (async move { let _rc2 = rc2 ; started_tx . send (()) . unwrap () ; futures :: future :: pending :: < () > () . await ; }) ; local . block_on (& rt , async { started_rx . await . unwrap () ; }) ; drop (local) ; drop (rt) ; assert_eq ! (1 , Rc :: strong_count (& rc1)) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 2936842811479135920,
      "kind": "Function",
      "name": "with_timeout",
      "signature": "fn # [doc = \" Runs a test function in a separate thread, and panics if the test does not\"] # [doc = \" complete within the specified timeout, or if the test function panics.\"] # [doc = \"\"] # [doc = \" This is intended for running tests whose failure mode is a hang or infinite\"] # [doc = \" loop that cannot be detected otherwise.\"] fn with_timeout (timeout : Duration , f : impl FnOnce () + Send + 'static) { use std :: sync :: mpsc :: RecvTimeoutError ; let (done_tx , done_rx) = std :: sync :: mpsc :: channel () ; let thread = std :: thread :: spawn (move | | { f () ; done_tx . send (()) . unwrap () ; }) ; match done_rx . recv_timeout (timeout) { Err (RecvTimeoutError :: Timeout) => panic ! (\"test did not complete within {timeout:?} seconds, \\\n             we have (probably) entered an infinite loop!\" ,) , Err (RecvTimeoutError :: Disconnected) => { } Ok (()) => { } } thread . join () . expect (\"test thread should not panic!\") } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 17789499978095845544,
      "kind": "Function",
      "name": "drop_cancels_remote_tasks",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"`unwrap()` in `with_timeout()` panics on Wasi\")] # [test] fn drop_cancels_remote_tasks () { with_timeout (Duration :: from_secs (60) , | | { let (tx , mut rx) = mpsc :: channel :: < () > (1024) ; let rt = rt () ; let local = LocalSet :: new () ; local . spawn_local (async move { while rx . recv () . await . is_some () { } }) ; local . block_on (& rt , async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (tx) ; drop (local) ; }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 3900082872281400824,
      "kind": "Function",
      "name": "local_tasks_wake_join_all",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: `task::spawn_local().await.unwrap()` panics on Wasi\")] # [test] fn local_tasks_wake_join_all () { with_timeout (Duration :: from_secs (60) , | | { use futures :: future :: join_all ; use tokio :: task :: LocalSet ; let rt = rt () ; let set = LocalSet :: new () ; let mut handles = Vec :: new () ; for _ in 1 ..= 128 { handles . push (set . spawn_local (async move { tokio :: task :: spawn_local (async move { }) . await . unwrap () ; })) ; } rt . block_on (set . run_until (join_all (handles))) ; }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 5439939281246621427,
      "kind": "Function",
      "name": "local_tasks_are_polled_after_tick",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn local_tasks_are_polled_after_tick () { for _ in 0 .. 4 { let res = std :: panic :: catch_unwind (local_tasks_are_polled_after_tick_inner) ; if res . is_ok () { return ; } } local_tasks_are_polled_after_tick_inner () ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12453918004047818570,
      "kind": "Function",
      "name": "local_tasks_are_polled_after_tick_inner",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: main (flavor = \"current_thread\")] async fn local_tasks_are_polled_after_tick_inner () { static RX1 : AtomicUsize = AtomicUsize :: new (0) ; static RX2 : AtomicUsize = AtomicUsize :: new (0) ; const EXPECTED : usize = 500 ; RX1 . store (0 , SeqCst) ; RX2 . store (0 , SeqCst) ; let (tx , mut rx) = mpsc :: unbounded_channel () ; let local = LocalSet :: new () ; local . run_until (async { let task2 = task :: spawn (async move { time :: sleep (Duration :: from_millis (10)) . await ; let mut oneshots = Vec :: with_capacity (EXPECTED) ; for _ in 0 .. EXPECTED { let (oneshot_tx , oneshot_rx) = oneshot :: channel () ; oneshots . push (oneshot_tx) ; tx . send (oneshot_rx) . unwrap () ; } time :: sleep (Duration :: from_millis (10)) . await ; for tx in oneshots . drain (..) { tx . send (()) . unwrap () ; } loop { time :: sleep (Duration :: from_millis (20)) . await ; let rx1 = RX1 . load (SeqCst) ; let rx2 = RX2 . load (SeqCst) ; if rx1 == EXPECTED && rx2 == EXPECTED { break ; } } }) ; while let Some (oneshot) = rx . recv () . await { RX1 . fetch_add (1 , SeqCst) ; task :: spawn_local (async move { oneshot . await . unwrap () ; RX2 . fetch_add (1 , SeqCst) ; }) ; } task2 . await . unwrap () ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 17699983678920565413,
      "kind": "Function",
      "name": "acquire_mutex_in_drop",
      "signature": "fn # [tokio :: test] async fn acquire_mutex_in_drop () { use futures :: future :: pending ; let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; let local = LocalSet :: new () ; local . spawn_local (async move { let _ = rx2 . await ; unreachable ! () ; }) ; local . spawn_local (async move { let _ = rx1 . await ; tx2 . send (()) . unwrap () ; unreachable ! () ; }) ; local . spawn_local (async move { pending :: < () > () . await ; tx1 . send (()) . unwrap () ; }) ; local . run_until (async { task :: yield_now () . await ; }) . await ; drop (local) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 12430119516423602461,
      "kind": "Function",
      "name": "spawn_wakes_localset",
      "signature": "fn # [tokio :: test] async fn spawn_wakes_localset () { let local = LocalSet :: new () ; futures :: select ! { _ = local . run_until (pending ::< () > ()) . fuse () => unreachable ! () , ret = async { local . spawn_local (ready (())) . await . unwrap () } . fuse () => ret } } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 1247851543814686444,
      "kind": "Function",
      "name": "sleep_with_local_enter_guard",
      "signature": "fn # [doc = \" Checks that the task wakes up with `enter`.\"] # [doc = \" Reproduces <https://github.com/tokio-rs/tokio/issues/5020>.\"] # [tokio :: test] async fn sleep_with_local_enter_guard () { let local = LocalSet :: new () ; let _guard = local . enter () ; let (tx , rx) = oneshot :: channel () ; local . run_until (async move { tokio :: task :: spawn_local (async move { time :: sleep (Duration :: ZERO) . await ; tx . send (()) . expect (\"failed to send\") ; }) ; assert_eq ! (rx . await , Ok (())) ; }) . await ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 3445706533256759671,
      "kind": "Function",
      "name": "store_local_set_in_thread_local_with_runtime",
      "signature": "fn # [test] fn store_local_set_in_thread_local_with_runtime () { use tokio :: runtime :: Runtime ; thread_local ! { static CURRENT : RtAndLocalSet = RtAndLocalSet :: new () ; } struct RtAndLocalSet { rt : Runtime , local : LocalSet , } impl RtAndLocalSet { fn new () -> RtAndLocalSet { RtAndLocalSet { rt : tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () , local : LocalSet :: new () , } } async fn inner_method (& self) { self . local . run_until (async move { tokio :: task :: spawn_local (async { }) ; }) . await } fn method (& self) { self . rt . block_on (self . inner_method ()) ; } } CURRENT . with (| f | { f . method () ; }) ; } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 4742981732226510647,
      "kind": "Function",
      "name": "rt",
      "signature": "fn fn rt () -> runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio/tests/task_local_set.rs",
      "line": 0
    },
    {
      "hash": 13658414709980432071,
      "kind": "Function",
      "name": "block_in_place_panic_caller",
      "signature": "fn # [test] fn block_in_place_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; rt . block_on (async { block_in_place (| | { }) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 8638115515545428684,
      "kind": "Function",
      "name": "local_set_spawn_local_panic_caller",
      "signature": "fn # [test] fn local_set_spawn_local_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _local = task :: LocalSet :: new () ; task :: spawn_local (async { }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 18142138993157372241,
      "kind": "Function",
      "name": "local_set_block_on_panic_caller",
      "signature": "fn # [test] fn local_set_block_on_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let local = task :: LocalSet :: new () ; rt . block_on (async { local . block_on (& rt , future :: pending :: < () > ()) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 9614644034417080319,
      "kind": "Function",
      "name": "spawn_panic_caller",
      "signature": "fn # [test] fn spawn_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { tokio :: spawn (future :: pending :: < () > ()) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 1606672334178562648,
      "kind": "Function",
      "name": "local_key_sync_scope_panic_caller",
      "signature": "fn # [test] fn local_key_sync_scope_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . sync_scope (1 , | | { NUMBER . with (| _ | { NUMBER . sync_scope (1 , | | { }) ; }) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 18208396584709057138,
      "kind": "Function",
      "name": "local_key_with_panic_caller",
      "signature": "fn # [test] fn local_key_with_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . with (| _ | { }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 10557559242814655036,
      "kind": "Function",
      "name": "local_key_get_panic_caller",
      "signature": "fn # [test] fn local_key_get_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . get () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/task_panic.rs",
      "line": 0
    },
    {
      "hash": 6818367424075450758,
      "kind": "Function",
      "name": "task_trace_self",
      "signature": "fn # [tokio :: test] async fn task_trace_self () { let log = Arc :: new (Mutex :: new (vec ! [])) ; let log2 = Arc :: new (Mutex :: new (vec ! [])) ; let mut good_line = vec ! [] ; let mut bad_line = vec ! [] ; PrettyFuture :: pretty (PrettyFuture :: pretty (async { bad_line . push (line ! () + 1) ; tokio :: task :: yield_now () . await ; bad_line . push (line ! () + 1) ; tokio :: time :: sleep (Duration :: from_millis (1)) . await ; for _ in 0 .. 100 { good_line . push (line ! () + 1) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; } } , log . clone () ,) , log2 . clone () ,) . await ; for line in good_line { let s = format ! (\"{}:{}:\" , file ! () , line) ; assert ! (log . lock () . unwrap () . iter () . any (| x | { eprintln ! (\"{x}\") ; format ! (\"{x}\") . contains (& s) })) ; } for line in bad_line { let s = format ! (\"{}:{}:\" , file ! () , line) ; assert ! (! log . lock () . unwrap () . iter () . any (| x | format ! (\"{x}\") . contains (& s))) ; } } . sig",
      "file_path": "tokio/tests/task_trace_self.rs",
      "line": 0
    },
    {
      "hash": 18351928177755049456,
      "kind": "Function",
      "name": "yield_now_outside_of_runtime",
      "signature": "fn # [test] fn yield_now_outside_of_runtime () { let mut task = spawn (async { task :: yield_now () . await ; }) ; assert ! (task . poll () . is_pending ()) ; assert ! (task . is_woken ()) ; assert ! (task . poll () . is_ready ()) ; } . sig",
      "file_path": "tokio/tests/task_yield_now.rs",
      "line": 0
    },
    {
      "hash": 2146848887483674357,
      "kind": "Function",
      "name": "yield_now_external_executor_and_block_in_place",
      "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn yield_now_external_executor_and_block_in_place () { let j = tokio :: spawn (async { task :: block_in_place (| | futures :: executor :: block_on (task :: yield_now ())) ; }) ; j . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/task_yield_now.rs",
      "line": 0
    },
    {
      "hash": 2907691109215905519,
      "kind": "Struct",
      "name": "TrackPolls",
      "signature": "struct TrackPolls",
      "file_path": "tokio/tests/tcp_accept.rs",
      "line": 0
    },
    {
      "hash": 16132308536579423511,
      "kind": "Function",
      "name": "no_extra_poll",
      "signature": "fn # [tokio :: test] async fn no_extra_poll () { let mut listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = listener . local_addr () . unwrap () ; let (tx , rx) = oneshot :: channel () ; let (accepted_tx , mut accepted_rx) = mpsc :: unbounded_channel () ; tokio :: spawn (async move { let mut incoming = TrackPolls { npolls : Arc :: new (AtomicUsize :: new (0)) , listener : & mut listener , } ; assert_ok ! (tx . send (Arc :: clone (& incoming . npolls))) ; while incoming . next () . await . is_some () { accepted_tx . send (()) . unwrap () ; } }) ; let npolls = assert_ok ! (rx . await) ; tokio :: task :: yield_now () . await ; assert_eq ! (npolls . load (SeqCst) , 1) ; let _ = assert_ok ! (TcpStream :: connect (& addr) . await) ; accepted_rx . recv () . await . unwrap () ; assert_eq ! (npolls . load (SeqCst) , 1 + 2) ; } . sig",
      "file_path": "tokio/tests/tcp_accept.rs",
      "line": 0
    },
    {
      "hash": 3268112404409103513,
      "kind": "Function",
      "name": "accept_many",
      "signature": "fn # [tokio :: test] async fn accept_many () { use std :: future :: { poll_fn , Future } ; use std :: sync :: atomic :: AtomicBool ; const N : usize = 50 ; let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let listener = Arc :: new (listener) ; let addr = listener . local_addr () . unwrap () ; let connected = Arc :: new (AtomicBool :: new (false)) ; let (pending_tx , mut pending_rx) = mpsc :: unbounded_channel () ; let (notified_tx , mut notified_rx) = mpsc :: unbounded_channel () ; for _ in 0 .. N { let listener = listener . clone () ; let connected = connected . clone () ; let pending_tx = pending_tx . clone () ; let notified_tx = notified_tx . clone () ; tokio :: spawn (async move { let accept = listener . accept () ; tokio :: pin ! (accept) ; let mut polled = false ; poll_fn (| cx | { if ! polled { polled = true ; assert ! (Pin :: new (& mut accept) . poll (cx) . is_pending ()) ; pending_tx . send (()) . unwrap () ; Poll :: Pending } else if connected . load (SeqCst) { notified_tx . send (()) . unwrap () ; Poll :: Ready (()) } else { Poll :: Pending } }) . await ; pending_tx . send (()) . unwrap () ; }) ; } for _ in 0 .. N { pending_rx . recv () . await . unwrap () ; } connected . store (true , SeqCst) ; let _sock = TcpStream :: connect (addr) . await . unwrap () ; for _ in 0 .. N { notified_rx . recv () . await . unwrap () ; } } . sig",
      "file_path": "tokio/tests/tcp_accept.rs",
      "line": 0
    },
    {
      "hash": 6285562329153371530,
      "kind": "Function",
      "name": "connect_v4",
      "signature": "fn # [tokio :: test] async fn connect_v4 () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; assert ! (addr . is_ipv4 ()) ; let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { let (socket , addr) = assert_ok ! (srv . accept () . await) ; assert_eq ! (addr , assert_ok ! (socket . peer_addr ())) ; assert_ok ! (tx . send (socket)) ; }) ; let mine = assert_ok ! (TcpStream :: connect (& addr) . await) ; let theirs = assert_ok ! (rx . await) ; assert_eq ! (assert_ok ! (mine . local_addr ()) , assert_ok ! (theirs . peer_addr ())) ; assert_eq ! (assert_ok ! (theirs . local_addr ()) , assert_ok ! (mine . peer_addr ())) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 12286843665226565786,
      "kind": "Function",
      "name": "connect_v6",
      "signature": "fn # [tokio :: test] async fn connect_v6 () { let srv = assert_ok ! (TcpListener :: bind (\"[::1]:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; assert ! (addr . is_ipv6 ()) ; let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { let (socket , addr) = assert_ok ! (srv . accept () . await) ; assert_eq ! (addr , assert_ok ! (socket . peer_addr ())) ; assert_ok ! (tx . send (socket)) ; }) ; let mine = assert_ok ! (TcpStream :: connect (& addr) . await) ; let theirs = assert_ok ! (rx . await) ; assert_eq ! (assert_ok ! (mine . local_addr ()) , assert_ok ! (theirs . peer_addr ())) ; assert_eq ! (assert_ok ! (theirs . local_addr ()) , assert_ok ! (mine . peer_addr ())) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 16347606089939519771,
      "kind": "Function",
      "name": "connect_addr_ip_string",
      "signature": "fn # [tokio :: test] async fn connect_addr_ip_string () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"127.0.0.1:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (addr) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 14308479283964019519,
      "kind": "Function",
      "name": "connect_addr_ip_str_slice",
      "signature": "fn # [tokio :: test] async fn connect_addr_ip_str_slice () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"127.0.0.1:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr [..]) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 4212365875770991248,
      "kind": "Function",
      "name": "connect_addr_host_string",
      "signature": "fn # [tokio :: test] async fn connect_addr_host_string () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"localhost:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (addr) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 8585067286493205186,
      "kind": "Function",
      "name": "connect_addr_ip_port_tuple",
      "signature": "fn # [tokio :: test] async fn connect_addr_ip_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (addr . ip () , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 10199988946921493119,
      "kind": "Function",
      "name": "connect_addr_ip_str_port_tuple",
      "signature": "fn # [tokio :: test] async fn connect_addr_ip_str_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (\"127.0.0.1\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 1546865393789789689,
      "kind": "Function",
      "name": "connect_addr_host_str_port_tuple",
      "signature": "fn # [tokio :: test] async fn connect_addr_host_str_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (\"localhost\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
      "file_path": "tokio/tests/tcp_connect.rs",
      "line": 0
    },
    {
      "hash": 8229623887294833209,
      "kind": "Function",
      "name": "echo_server",
      "signature": "fn # [tokio :: test] async fn echo_server () { const ITER : usize = 1024 ; let (tx , rx) = oneshot :: channel () ; let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let msg = \"foo bar baz\" ; tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; for _ in 0 .. ITER { assert_ok ! (stream . write_all (msg . as_bytes ()) . await) ; let mut buf = [0 ; 11] ; assert_ok ! (stream . read_exact (& mut buf) . await) ; assert_eq ! (& buf [..] , msg . as_bytes ()) ; } assert_ok ! (tx . send (())) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; let (mut rd , mut wr) = stream . split () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , (ITER * msg . len ()) as u64) ; assert_ok ! (rx . await) ; } . sig",
      "file_path": "tokio/tests/tcp_echo.rs",
      "line": 0
    },
    {
      "hash": 11461053991914908494,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [tokio :: test] async fn split () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await ? ; let addr = listener . local_addr () ? ; let (stream1 , (mut stream2 , _)) = try_join ! { TcpStream :: connect (& addr) , listener . accept () , } ? ; let (mut read_half , mut write_half) = stream1 . into_split () ; let (() , () , ()) = try_join ! { async { let len = stream2 . write (MSG) . await ?; assert_eq ! (len , MSG . len ()) ; let mut read_buf = vec ! [0u8 ; 32] ; let read_len = stream2 . read (& mut read_buf) . await ?; assert_eq ! (& read_buf [.. read_len] , MSG) ; Result :: Ok (()) } , async { let len = write_half . write (MSG) . await ?; assert_eq ! (len , MSG . len ()) ; Ok (()) } , async { let mut read_buf = [0u8 ; 32] ; let peek_len1 = read_half . peek (& mut read_buf [..]) . await ?; let peek_len2 = read_half . peek (& mut read_buf [..]) . await ?; assert_eq ! (peek_len1 , peek_len2) ; let read_len = read_half . read (& mut read_buf [..]) . await ?; assert_eq ! (peek_len1 , read_len) ; assert_eq ! (& read_buf [.. read_len] , MSG) ; Ok (()) } , } ? ; Ok (()) } . sig",
      "file_path": "tokio/tests/tcp_into_split.rs",
      "line": 0
    },
    {
      "hash": 14249428768731095444,
      "kind": "Function",
      "name": "reunite",
      "signature": "fn # [tokio :: test] async fn reunite () -> Result < () > { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { drop (listener . accept () . unwrap ()) ; drop (listener . accept () . unwrap ()) ; }) ; let stream1 = TcpStream :: connect (& addr) . await ? ; let (read1 , write1) = stream1 . into_split () ; let stream2 = TcpStream :: connect (& addr) . await ? ; let (_ , write2) = stream2 . into_split () ; let read1 = match read1 . reunite (write2) { Ok (_) => panic ! (\"Reunite should not succeed\") , Err (err) => err . 0 , } ; read1 . reunite (write1) . expect (\"Reunite should succeed\") ; handle . join () . unwrap () ; Ok (()) } . sig",
      "file_path": "tokio/tests/tcp_into_split.rs",
      "line": 0
    },
    {
      "hash": 4821657888306862181,
      "kind": "Function",
      "name": "drop_write",
      "signature": "fn # [doc = \" Test that dropping the write half actually closes the stream.\"] # [tokio :: test] async fn drop_write () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { let (mut stream , _) = listener . accept () . unwrap () ; stream . write_all (MSG) . unwrap () ; let mut read_buf = [0u8 ; 32] ; let res = match stream . read (& mut read_buf) { Ok (0) => Ok (()) , Ok (len) => Err (Error :: new (ErrorKind :: Other , format ! (\"Unexpected read: {len} bytes.\") ,)) , Err (err) => Err (err) , } ; drop (stream) ; res }) ; let stream = TcpStream :: connect (& addr) . await ? ; let (mut read_half , write_half) = stream . into_split () ; let mut read_buf = [0u8 ; 32] ; let read_len = read_half . read (& mut read_buf [..]) . await ? ; assert_eq ! (& read_buf [.. read_len] , MSG) ; std :: thread :: spawn (move | | { thread :: sleep (std :: time :: Duration :: from_millis (10)) ; drop (write_half) ; }) ; match read_half . read (& mut read_buf [..]) . await { Ok (0) => { } Ok (len) => panic ! (\"Unexpected read: {len} bytes.\") , Err (err) => panic ! (\"Unexpected error: {err}.\") , } handle . join () . unwrap () . unwrap () ; Ok (()) } . sig",
      "file_path": "tokio/tests/tcp_into_split.rs",
      "line": 0
    },
    {
      "hash": 11769555157123763045,
      "kind": "Function",
      "name": "tcp_into_std",
      "signature": "fn # [tokio :: test] async fn tcp_into_std () -> Result < () > { let mut data = [0u8 ; 12] ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await ? ; let addr = listener . local_addr () . unwrap () . to_string () ; let handle = tokio :: spawn (async { let stream : TcpStream = TcpStream :: connect (addr) . await . unwrap () ; stream }) ; let (tokio_tcp_stream , _) = listener . accept () . await ? ; let mut std_tcp_stream = tokio_tcp_stream . into_std () ? ; std_tcp_stream . set_nonblocking (false) . expect (\"set_nonblocking call failed\") ; let mut client = handle . await . expect (\"The task being joined has panicked\") ; client . write_all (b\"Hello world!\") . await ? ; std_tcp_stream . read_exact (& mut data) . expect (\"std TcpStream read failed!\") ; assert_eq ! (b\"Hello world!\" , & data) ; std_tcp_stream . set_nonblocking (true) . expect (\"set_nonblocking call failed\") ; let mut tokio_tcp_stream = TcpStream :: from_std (std_tcp_stream) ? ; client . write_all (b\"Hello tokio!\") . await ? ; let _size = tokio_tcp_stream . read_exact (& mut data) . await ? ; assert_eq ! (b\"Hello tokio!\" , & data) ; Ok (()) } . sig",
      "file_path": "tokio/tests/tcp_into_std.rs",
      "line": 0
    },
    {
      "hash": 13315027886356170978,
      "kind": "Function",
      "name": "peek",
      "signature": "fn # [tokio :: test] async fn peek () { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let addr = listener . local_addr () . unwrap () ; let t = thread :: spawn (move | | assert_ok ! (listener . accept ()) . 0) ; let left = net :: TcpStream :: connect (addr) . unwrap () ; left . set_nonblocking (true) . unwrap () ; let mut right = t . join () . unwrap () ; right . set_nonblocking (true) . unwrap () ; let _ = right . write (& [1 , 2 , 3 , 4]) . unwrap () ; let mut left : TcpStream = left . try_into () . unwrap () ; let mut buf = [0u8 ; 16] ; let n = assert_ok ! (left . peek (& mut buf) . await) ; assert_eq ! ([1 , 2 , 3 , 4] , buf [.. n]) ; let n = assert_ok ! (left . read (& mut buf) . await) ; assert_eq ! ([1 , 2 , 3 , 4] , buf [.. n]) ; } . sig",
      "file_path": "tokio/tests/tcp_peek.rs",
      "line": 0
    },
    {
      "hash": 237406109026005133,
      "kind": "Function",
      "name": "shutdown",
      "signature": "fn # [tokio :: test] async fn shutdown () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; let mut buf = [0u8 ; 1] ; let n = assert_ok ! (stream . read (& mut buf) . await) ; assert_eq ! (n , 0) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; let (mut rd , mut wr) = stream . split () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , 0) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; handle . await . unwrap () } . sig",
      "file_path": "tokio/tests/tcp_shutdown.rs",
      "line": 0
    },
    {
      "hash": 7196183835724258657,
      "kind": "Function",
      "name": "shutdown_after_tcp_reset",
      "signature": "fn # [tokio :: test] async fn shutdown_after_tcp_reset () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let (connected_tx , connected_rx) = channel () ; let (dropped_tx , dropped_rx) = channel () ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; connected_tx . send (()) . unwrap () ; dropped_rx . await . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; }) ; let (stream , _) = assert_ok ! (srv . accept () . await) ; stream . set_linger (Some (Duration :: new (0 , 0))) . unwrap () ; connected_rx . await . unwrap () ; drop (stream) ; dropped_tx . send (()) . unwrap () ; handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/tcp_shutdown.rs",
      "line": 0
    },
    {
      "hash": 8189503234083983894,
      "kind": "Function",
      "name": "shutdown_multiple_calls",
      "signature": "fn # [tokio :: test] async fn shutdown_multiple_calls () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let (connected_tx , connected_rx) = channel () ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; connected_tx . send (()) . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; connected_rx . await . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; handle . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/tcp_shutdown.rs",
      "line": 0
    },
    {
      "hash": 9351385029360585271,
      "kind": "Function",
      "name": "basic_usage_v4",
      "signature": "fn # [tokio :: test] async fn basic_usage_v4 () { let addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v4 ()) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
      "file_path": "tokio/tests/tcp_socket.rs",
      "line": 0
    },
    {
      "hash": 16773665556725799232,
      "kind": "Function",
      "name": "basic_usage_v6",
      "signature": "fn # [tokio :: test] async fn basic_usage_v6 () { let addr = assert_ok ! (\"[::1]:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v6 ()) ; assert_ok ! (srv . bind (addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v6 ()) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
      "file_path": "tokio/tests/tcp_socket.rs",
      "line": 0
    },
    {
      "hash": 8314630506666878105,
      "kind": "Function",
      "name": "bind_before_connect",
      "signature": "fn # [tokio :: test] async fn bind_before_connect () { let any_addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (any_addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (cli . bind (any_addr)) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
      "file_path": "tokio/tests/tcp_socket.rs",
      "line": 0
    },
    {
      "hash": 549390208535029973,
      "kind": "Function",
      "name": "basic_linger",
      "signature": "fn # [tokio :: test] async fn basic_linger () { let addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (addr)) ; assert ! (srv . linger () . unwrap () . is_none ()) ; srv . set_linger (Some (Duration :: new (0 , 0))) . unwrap () ; assert_eq ! (srv . linger () . unwrap () , Some (Duration :: new (0 , 0))) ; } . sig",
      "file_path": "tokio/tests/tcp_socket.rs",
      "line": 0
    },
    {
      "hash": 10166157640558641942,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [tokio :: test] async fn split () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { let (mut stream , _) = listener . accept () . unwrap () ; stream . write_all (MSG) . unwrap () ; let mut read_buf = [0u8 ; 32] ; let read_len = stream . read (& mut read_buf) . unwrap () ; assert_eq ! (& read_buf [.. read_len] , MSG) ; }) ; let mut stream = TcpStream :: connect (& addr) . await ? ; let (mut read_half , mut write_half) = stream . split () ; let mut read_buf = [0u8 ; 32] ; let peek_len1 = read_half . peek (& mut read_buf [..]) . await ? ; let peek_len2 = read_half . peek (& mut read_buf [..]) . await ? ; assert_eq ! (peek_len1 , peek_len2) ; let read_len = read_half . read (& mut read_buf [..]) . await ? ; assert_eq ! (peek_len1 , read_len) ; assert_eq ! (& read_buf [.. read_len] , MSG) ; assert_eq ! (write_half . write (MSG) . await ?, MSG . len ()) ; handle . join () . unwrap () ; Ok (()) } . sig",
      "file_path": "tokio/tests/tcp_split.rs",
      "line": 0
    },
    {
      "hash": 6050233993492694940,
      "kind": "Function",
      "name": "set_linger",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn set_linger () { let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let stream = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; assert_ok ! (stream . set_linger (Some (Duration :: from_secs (1)))) ; assert_eq ! (stream . linger () . unwrap () . unwrap () . as_secs () , 1) ; assert_ok ! (stream . set_linger (None)) ; assert ! (stream . linger () . unwrap () . is_none ()) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 8779554509783857294,
      "kind": "Function",
      "name": "try_read_write",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write () { const DATA : & [u8] = b\"this is some data to write to the socket\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; let (server , _) = listener . accept () . await . unwrap () ; let mut written = DATA . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await . unwrap () ; assert_eq ! (DATA . len () , client . try_write (DATA) . unwrap ()) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (DATA) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await . unwrap () ; match server . try_read (& mut read [i ..]) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } written . clear () ; client . writable () . await . unwrap () ; let data_bufs : Vec < _ > = DATA . chunks (10) . map (io :: IoSlice :: new) . collect () ; loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write_vectored (& data_bufs) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await . unwrap () ; let mut bufs : Vec < _ > = read [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match server . try_read_vectored (& mut bufs) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await . unwrap () ; if ready . is_read_closed () { return ; } else { tokio :: task :: yield_now () . await ; } } } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 15893317146726912578,
      "kind": "Function",
      "name": "buffer_not_included_in_future",
      "signature": "fn # [test] fn buffer_not_included_in_future () { use std :: mem ; const N : usize = 4096 ; let fut = async { let stream = TcpStream :: connect (\"127.0.0.1:8080\") . await . unwrap () ; loop { stream . readable () . await . unwrap () ; let mut buf = [0 ; N] ; let n = stream . try_read (& mut buf [..]) . unwrap () ; if n == 0 { break ; } } } ; let n = mem :: size_of_val (& fut) ; assert ! (n < 1000) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 12097832971480232482,
      "kind": "Function",
      "name": "poll_read_ready",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_read_ready () { let (mut client , mut server) = create_pair () . await ; assert_not_readable_by_polling ! (server) ; assert_ok ! (client . write_all (b\"ping\") . await) ; assert_readable_by_polling ! (server) ; let mut buf = [0u8 ; 4] ; assert_ok ! (server . read_exact (& mut buf) . await) ; assert_readable_by_polling ! (server) ; read_until_pending (& mut server) ; assert_not_readable_by_polling ! (server) ; drop (client) ; assert_readable_by_polling ! (server) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 7118935975782544649,
      "kind": "Function",
      "name": "poll_write_ready",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_write_ready () { let (mut client , server) = create_pair () . await ; assert_writable_by_polling ! (client) ; write_until_pending (& mut client) ; assert_not_writable_by_polling ! (client) ; drop (server) ; assert_writable_by_polling ! (client) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 14347483167236628384,
      "kind": "Function",
      "name": "create_pair",
      "signature": "fn async fn create_pair () -> (TcpStream , TcpStream) { let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (listener . local_addr ()) ; let (client , (server , _)) = assert_ok ! (try_join ! (TcpStream :: connect (& addr) , listener . accept ())) ; (client , server) } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 11585208725867467199,
      "kind": "Function",
      "name": "read_until_pending",
      "signature": "fn fn read_until_pending (stream : & mut TcpStream) -> usize { let mut buf = vec ! [0u8 ; 1024 * 1024] ; let mut total = 0 ; loop { match stream . try_read (& mut buf) { Ok (n) => total += n , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } total } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 278982145162096079,
      "kind": "Function",
      "name": "write_until_pending",
      "signature": "fn fn write_until_pending (stream : & mut TcpStream) -> usize { let buf = vec ! [0u8 ; 1024 * 1024] ; let mut total = 0 ; loop { match stream . try_write (& buf) { Ok (n) => total += n , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } total } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 17148907589797839531,
      "kind": "Function",
      "name": "try_read_buf",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_buf () { const DATA : & [u8] = b\"this is some data to write to the socket\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; let (server , _) = listener . accept () . await . unwrap () ; let mut written = DATA . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await . unwrap () ; assert_eq ! (DATA . len () , client . try_write (DATA) . unwrap ()) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (DATA) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = Vec :: with_capacity (written . len ()) ; let mut i = 0 ; while i < read . capacity () { server . readable () . await . unwrap () ; match server . try_read_buf (& mut read) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await . unwrap () ; if ready . is_read_closed () { return ; } else { tokio :: task :: yield_now () . await ; } } } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 18405009261076289202,
      "kind": "Function",
      "name": "read_closed",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn read_closed () { let (client , mut server) = create_pair () . await ; let mut ready_fut = task :: spawn (client . ready (Interest :: READABLE)) ; assert_pending ! (ready_fut . poll ()) ; assert_ok ! (server . write_all (b\"ping\") . await) ; let ready_event = assert_ok ! (ready_fut . await) ; assert ! (! ready_event . is_read_closed ()) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 4103933583012787218,
      "kind": "Function",
      "name": "write_closed",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn write_closed () { let (mut client , mut server) = create_pair () . await ; let write_size = write_until_pending (& mut client) ; let mut ready_fut = task :: spawn (client . ready (Interest :: WRITABLE)) ; assert_pending ! (ready_fut . poll ()) ; let mut read_size = 0 ; while read_size < write_size { server . readable () . await . unwrap () ; read_size += read_until_pending (& mut server) ; } let ready_event = assert_ok ! (ready_fut . await) ; assert ! (! ready_event . is_write_closed ()) ; } . sig",
      "file_path": "tokio/tests/tcp_stream.rs",
      "line": 0
    },
    {
      "hash": 7464493637730358400,
      "kind": "Function",
      "name": "resume_lets_time_move_forward_instead_of_resetting_it",
      "signature": "fn # [tokio :: test] async fn resume_lets_time_move_forward_instead_of_resetting_it () { let start = Instant :: now () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; let advanced_by_ten_secs = Instant :: now () ; assert ! (advanced_by_ten_secs - start > Duration :: from_secs (10)) ; assert ! (advanced_by_ten_secs - start < Duration :: from_secs (11)) ; time :: resume () ; assert ! (advanced_by_ten_secs < Instant :: now ()) ; assert ! (Instant :: now () - advanced_by_ten_secs < Duration :: from_secs (1)) ; } . sig",
      "file_path": "tokio/tests/test_clock.rs",
      "line": 0
    },
    {
      "hash": 1806080185318447752,
      "kind": "Function",
      "name": "can_pause_after_resume",
      "signature": "fn # [tokio :: test] async fn can_pause_after_resume () { let start = Instant :: now () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; time :: resume () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; assert ! (Instant :: now () - start > Duration :: from_secs (20)) ; assert ! (Instant :: now () - start < Duration :: from_secs (21)) ; } . sig",
      "file_path": "tokio/tests/test_clock.rs",
      "line": 0
    },
    {
      "hash": 16487177544525781415,
      "kind": "Function",
      "name": "freezing_time_while_frozen_panics",
      "signature": "fn # [tokio :: test] # [should_panic] async fn freezing_time_while_frozen_panics () { time :: pause () ; time :: pause () ; } . sig",
      "file_path": "tokio/tests/test_clock.rs",
      "line": 0
    },
    {
      "hash": 13838613240124471778,
      "kind": "Function",
      "name": "advancing_time_when_time_is_not_frozen_panics",
      "signature": "fn # [tokio :: test] # [should_panic] async fn advancing_time_when_time_is_not_frozen_panics () { time :: advance (Duration :: from_secs (1)) . await ; } . sig",
      "file_path": "tokio/tests/test_clock.rs",
      "line": 0
    },
    {
      "hash": 17553776472009669899,
      "kind": "Function",
      "name": "resuming_time_when_not_frozen_panics",
      "signature": "fn # [tokio :: test] # [should_panic] async fn resuming_time_when_not_frozen_panics () { time :: pause () ; time :: resume () ; time :: resume () ; } . sig",
      "file_path": "tokio/tests/test_clock.rs",
      "line": 0
    },
    {
      "hash": 3292221589072571808,
      "kind": "Function",
      "name": "interval_zero_duration",
      "signature": "fn # [tokio :: test] # [should_panic] async fn interval_zero_duration () { let _ = time :: interval_at (Instant :: now () , ms (0)) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 5675224188737702048,
      "kind": "Function",
      "name": "burst",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn burst () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600 , 900) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start , 1200) ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start , 1500) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1800) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 11350763967871193761,
      "kind": "Function",
      "name": "delay",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn delay () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; i . set_missed_tick_behavior (MissedTickBehavior :: Delay) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (201)) . await ; check_interval_poll ! (i , start , 1251) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1551) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1851) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 6579098078030289429,
      "kind": "Function",
      "name": "skip",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn skip () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; i . set_missed_tick_behavior (MissedTickBehavior :: Skip) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600) ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start , 1200) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1500) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1800) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 12919482903994539932,
      "kind": "Function",
      "name": "reset",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn reset () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset () ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (50)) . await ; check_interval_poll ! (i , start , 701) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1001) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 12652708015789189733,
      "kind": "Function",
      "name": "reset_immediately",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_immediately () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_immediately () ; check_interval_poll ! (i , start , 401) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 701) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 16409875093155431442,
      "kind": "Function",
      "name": "reset_after",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_after () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_after (Duration :: from_millis (20)) ; time :: advance (ms (20)) . await ; check_interval_poll ! (i , start , 421) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 721) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 7663685004216544889,
      "kind": "Function",
      "name": "reset_at",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_at () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_at (Instant :: now () + Duration :: from_millis (40)) ; time :: advance (ms (40)) . await ; check_interval_poll ! (i , start , 441) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 741) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 16833704921005821631,
      "kind": "Function",
      "name": "reset_at_bigger_than_interval",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_at_bigger_than_interval () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_at (Instant :: now () + Duration :: from_millis (1000)) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start , 1401) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1701) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 17051664951137796663,
      "kind": "Function",
      "name": "poll_next",
      "signature": "fn fn poll_next (interval : & mut task :: Spawn < time :: Interval >) -> Poll < Instant > { interval . enter (| cx , mut interval | interval . poll_tick (cx)) } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 5273260105930487112,
      "kind": "Function",
      "name": "ms",
      "signature": "fn fn ms (n : u64) -> Duration { Duration :: from_millis (n) } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 9815431222321258081,
      "kind": "Struct",
      "name": "IntervalStreamer",
      "signature": "struct IntervalStreamer",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 17608579816839377559,
      "kind": "Function",
      "name": "stream_with_interval_poll_tick_self_waking",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn stream_with_interval_poll_tick_self_waking () { let stream = IntervalStreamer { counter : 0 , timer : tokio :: time :: interval (tokio :: time :: Duration :: from_millis (10)) , wake_on_pending : true , } ; let (res_tx , mut res_rx) = tokio :: sync :: mpsc :: channel (12) ; tokio :: spawn (tokio :: time :: timeout (tokio :: time :: Duration :: from_millis (150) , async move { tokio :: pin ! (stream) ; while let Some (item) = stream . next () . await { res_tx . send (item) . await . ok () ; } } ,)) ; let mut items = Vec :: with_capacity (3) ; while let Some (result) = res_rx . recv () . await { items . push (result) ; } assert_eq ! (items , vec ! [4 , 8 , 12]) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 12923858013402475224,
      "kind": "Function",
      "name": "stream_with_interval_poll_tick_no_waking",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn stream_with_interval_poll_tick_no_waking () { let stream = IntervalStreamer { counter : 0 , timer : tokio :: time :: interval (tokio :: time :: Duration :: from_millis (10)) , wake_on_pending : false , } ; let (res_tx , mut res_rx) = tokio :: sync :: mpsc :: channel (12) ; tokio :: spawn (tokio :: time :: timeout (tokio :: time :: Duration :: from_millis (150) , async move { tokio :: pin ! (stream) ; while let Some (item) = stream . next () . await { res_tx . send (item) . await . ok () ; } } ,)) ; let mut items = Vec :: with_capacity (0) ; while let Some (result) = res_rx . recv () . await { items . push (result) ; } assert_eq ! (items , vec ! []) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 18158133301776984451,
      "kind": "Function",
      "name": "interval_doesnt_panic_max_duration_when_polling",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn interval_doesnt_panic_max_duration_when_polling () { let mut timer = task :: spawn (time :: interval (Duration :: MAX)) ; assert_ready ! (timer . enter (| cx , mut timer | timer . poll_tick (cx))) ; } . sig",
      "file_path": "tokio/tests/time_interval.rs",
      "line": 0
    },
    {
      "hash": 6028549443957926040,
      "kind": "Function",
      "name": "pause_panic_caller",
      "signature": "fn # [test] fn pause_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { time :: pause () ; time :: pause () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 16643472906960169805,
      "kind": "Function",
      "name": "resume_panic_caller",
      "signature": "fn # [test] fn resume_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { time :: resume () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 5304256689461051920,
      "kind": "Function",
      "name": "interval_panic_caller",
      "signature": "fn # [test] fn interval_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = interval (Duration :: from_millis (0)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 997617322953806119,
      "kind": "Function",
      "name": "interval_at_panic_caller",
      "signature": "fn # [test] fn interval_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = interval_at (Instant :: now () , Duration :: from_millis (0)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 4836144800531166992,
      "kind": "Function",
      "name": "timeout_panic_caller",
      "signature": "fn # [test] fn timeout_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let _timeout = timeout (Duration :: from_millis (5) , future :: pending :: < () > ()) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio/tests/time_panic.rs",
      "line": 0
    },
    {
      "hash": 13335307212058268938,
      "kind": "Function",
      "name": "pause_time_in_main",
      "signature": "fn # [tokio :: test] async fn pause_time_in_main () { tokio :: time :: pause () ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 2438201265171502833,
      "kind": "Function",
      "name": "pause_time_in_task",
      "signature": "fn # [tokio :: test] async fn pause_time_in_task () { let t = tokio :: spawn (async { tokio :: time :: pause () ; }) ; t . await . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 10272745241602583328,
      "kind": "Function",
      "name": "pause_time_in_main_threads",
      "signature": "fn # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 1)] # [should_panic] async fn pause_time_in_main_threads () { tokio :: time :: pause () ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 4145027474497733808,
      "kind": "Function",
      "name": "pause_time_in_spawn_threads",
      "signature": "fn # [cfg_attr (panic = \"abort\" , ignore)] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 1)] async fn pause_time_in_spawn_threads () { let t = tokio :: spawn (async { tokio :: time :: pause () ; }) ; assert_err ! (t . await) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 16057397863661202878,
      "kind": "Function",
      "name": "paused_time_is_deterministic",
      "signature": "fn # [test] fn paused_time_is_deterministic () { let run_1 = paused_time_stress_run () ; let run_2 = paused_time_stress_run () ; assert_eq ! (run_1 , run_2) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 2006813069490861322,
      "kind": "Function",
      "name": "paused_time_stress_run",
      "signature": "fn # [tokio :: main (flavor = \"current_thread\" , start_paused = true)] async fn paused_time_stress_run () -> Vec < Duration > { let mut rng = StdRng :: seed_from_u64 (1) ; let mut times = vec ! [] ; let start = Instant :: now () ; for _ in 0 .. 10_000 { let sleep = rng . random_range (Duration :: from_secs (0) .. Duration :: from_secs (1)) ; time :: sleep (sleep) . await ; times . push (start . elapsed ()) ; } times } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 6452557413975794773,
      "kind": "Function",
      "name": "advance_after_poll",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_after_poll () { time :: sleep (ms (1)) . await ; let start = Instant :: now () ; let mut sleep = task :: spawn (time :: sleep_until (start + ms (300))) ; assert_pending ! (sleep . poll ()) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 1118407945561876410,
      "kind": "Function",
      "name": "sleep_no_poll",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_no_poll () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut sleep = task :: spawn (time :: sleep_until (start + ms (300))) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 13233596372250595864,
      "kind": "Struct",
      "name": "Tester",
      "signature": "struct Tester",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 2751722777108731986,
      "kind": "Function",
      "name": "sleep_same_task",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_same_task () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let sleep = Box :: pin (time :: sleep_until (start + ms (300))) ; Tester { sleep , state : State :: Begin , before : None , poll : true , } . await ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 9745437062007518475,
      "kind": "Function",
      "name": "sleep_same_task_no_poll",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_same_task_no_poll () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let sleep = Box :: pin (time :: sleep_until (start + ms (300))) ; Tester { sleep , state : State :: Begin , before : None , poll : false , } . await ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 2450165348720664183,
      "kind": "Function",
      "name": "interval",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn interval () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; assert_ready_eq ! (poll_next (& mut i) , start) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (200)) . await ; assert_elapsed ! (before , ms (200)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (300)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (400)) . await ; assert_elapsed ! (before , ms (400)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (600)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (500)) . await ; assert_elapsed ! (before , ms (500)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (900)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (1200)) ; assert_pending ! (poll_next (& mut i)) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 12210722897218600946,
      "kind": "Function",
      "name": "test_time_advance_sub_ms",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_time_advance_sub_ms () { let now = Instant :: now () ; let dur = Duration :: from_micros (51_592) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_micros (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 16309992586076885430,
      "kind": "Function",
      "name": "test_time_advance_3ms_and_change",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_time_advance_3ms_and_change () { let now = Instant :: now () ; let dur = Duration :: from_micros (3_141_592) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_micros (3_123_456) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 15046896651063204724,
      "kind": "Function",
      "name": "regression_3710_with_submillis_advance",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn regression_3710_with_submillis_advance () { let start = Instant :: now () ; time :: advance (Duration :: from_millis (1)) . await ; let mut sleep = task :: spawn (time :: sleep_until (start + Duration :: from_secs (60))) ; assert_pending ! (sleep . poll ()) ; let before = Instant :: now () ; let dur = Duration :: from_micros (51_592) ; time :: advance (dur) . await ; assert_eq ! (before . elapsed () , dur) ; assert_pending ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 6428807695027310811,
      "kind": "Function",
      "name": "exact_1ms_advance",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn exact_1ms_advance () { let now = Instant :: now () ; let dur = Duration :: from_millis (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_millis (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 8087493542603296200,
      "kind": "Function",
      "name": "advance_once_with_timer",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_once_with_timer () { let mut sleep = task :: spawn (time :: sleep (Duration :: from_millis (1))) ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (1500)) . await ; assert ! (sleep . is_woken ()) ; assert_ready ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 16347113837256147825,
      "kind": "Function",
      "name": "advance_multi_with_timer",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_multi_with_timer () { let mut sleep = task :: spawn (time :: sleep (Duration :: from_millis (1))) ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert ! (sleep . is_woken ()) ; assert_ready ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_pause.rs",
      "line": 0
    },
    {
      "hash": 2790508315446745312,
      "kind": "Function",
      "name": "timer_with_threaded_runtime",
      "signature": "fn # [cfg (all (feature = \"rt-multi-thread\" , not (target_os = \"wasi\")))] # [test] fn timer_with_threaded_runtime () { use tokio :: runtime :: Runtime ; let rt = Runtime :: new () . unwrap () ; let (tx , rx) = mpsc :: channel () ; rt . spawn (async move { let when = Instant :: now () + Duration :: from_millis (10) ; sleep_until (when) . await ; assert ! (Instant :: now () >= when) ; tx . send (()) . unwrap () ; }) ; rx . recv () . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_rt.rs",
      "line": 0
    },
    {
      "hash": 4947261958698855264,
      "kind": "Function",
      "name": "timer_with_current_thread_scheduler",
      "signature": "fn # [test] fn timer_with_current_thread_scheduler () { use tokio :: runtime :: Builder ; let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let (tx , rx) = mpsc :: channel () ; rt . block_on (async move { let when = Instant :: now () + Duration :: from_millis (10) ; sleep_until (when) . await ; assert ! (Instant :: now () >= when) ; tx . send (()) . unwrap () ; }) ; rx . recv () . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_rt.rs",
      "line": 0
    },
    {
      "hash": 12463633195118809487,
      "kind": "Function",
      "name": "starving",
      "signature": "fn # [tokio :: test] async fn starving () { use std :: future :: Future ; use std :: pin :: Pin ; use std :: task :: { Context , Poll } ; struct Starve < T : Future < Output = () > + Unpin > (T , u64) ; impl < T : Future < Output = () > + Unpin > Future for Starve < T > { type Output = u64 ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < u64 > { if Pin :: new (& mut self . 0) . poll (cx) . is_ready () { return Poll :: Ready (self . 1) ; } self . 1 += 1 ; cx . waker () . wake_by_ref () ; Poll :: Pending } } let when = Instant :: now () + Duration :: from_millis (10) ; let starve = Starve (Box :: pin (sleep_until (when)) , 0) ; starve . await ; assert ! (Instant :: now () >= when) ; } . sig",
      "file_path": "tokio/tests/time_rt.rs",
      "line": 0
    },
    {
      "hash": 6397740139640568900,
      "kind": "Function",
      "name": "timeout_value",
      "signature": "fn # [tokio :: test] async fn timeout_value () { use tokio :: sync :: oneshot ; let (_tx , rx) = oneshot :: channel :: < () > () ; let now = Instant :: now () ; let dur = Duration :: from_millis (10) ; let res = timeout (dur , rx) . await ; assert ! (res . is_err ()) ; assert ! (Instant :: now () >= now + dur) ; } . sig",
      "file_path": "tokio/tests/time_rt.rs",
      "line": 0
    },
    {
      "hash": 7359107358270395442,
      "kind": "Function",
      "name": "immediate_sleep",
      "signature": "fn # [tokio :: test] async fn immediate_sleep () { time :: pause () ; let now = Instant :: now () ; time :: sleep_until (now) . await ; assert_elapsed ! (now , ms (1)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 6519660067513284447,
      "kind": "Function",
      "name": "is_elapsed",
      "signature": "fn # [tokio :: test] async fn is_elapsed () { time :: pause () ; let sleep = time :: sleep (Duration :: from_millis (10)) ; tokio :: pin ! (sleep) ; assert ! (! sleep . is_elapsed ()) ; assert ! (futures :: poll ! (sleep . as_mut ()) . is_pending ()) ; assert ! (! sleep . is_elapsed ()) ; sleep . as_mut () . await ; assert ! (sleep . is_elapsed ()) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 16432072789093368869,
      "kind": "Function",
      "name": "delayed_sleep_level_0",
      "signature": "fn # [tokio :: test] async fn delayed_sleep_level_0 () { time :: pause () ; for & i in & [1 , 10 , 60] { let now = Instant :: now () ; let dur = ms (i) ; time :: sleep_until (now + dur) . await ; assert_elapsed ! (now , dur) ; } } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 8688936396496440382,
      "kind": "Function",
      "name": "sub_ms_delayed_sleep",
      "signature": "fn # [tokio :: test] async fn sub_ms_delayed_sleep () { time :: pause () ; for _ in 0 .. 5 { let now = Instant :: now () ; let deadline = now + ms (1) + Duration :: new (0 , 1) ; time :: sleep_until (deadline) . await ; assert_elapsed ! (now , ms (1)) ; } } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 15158349420016459627,
      "kind": "Function",
      "name": "delayed_sleep_wrapping_level_0",
      "signature": "fn # [tokio :: test] async fn delayed_sleep_wrapping_level_0 () { time :: pause () ; time :: sleep (ms (5)) . await ; let now = Instant :: now () ; time :: sleep_until (now + ms (60)) . await ; assert_elapsed ! (now , ms (60)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 10014343437151432946,
      "kind": "Function",
      "name": "reset_future_sleep_before_fire",
      "signature": "fn # [tokio :: test] async fn reset_future_sleep_before_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; sleep . as_mut () . reset (Instant :: now () + ms (200)) ; sleep . await ; assert_elapsed ! (now , ms (200)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 3695713995988554843,
      "kind": "Function",
      "name": "reset_past_sleep_before_turn",
      "signature": "fn # [tokio :: test] async fn reset_past_sleep_before_turn () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; sleep . as_mut () . reset (now + ms (80)) ; sleep . await ; assert_elapsed ! (now , ms (80)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 12406037778425726146,
      "kind": "Function",
      "name": "reset_past_sleep_before_fire",
      "signature": "fn # [tokio :: test] async fn reset_past_sleep_before_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; time :: sleep (ms (10)) . await ; sleep . as_mut () . reset (now + ms (80)) ; sleep . await ; assert_elapsed ! (now , ms (80)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 9995467377485374901,
      "kind": "Function",
      "name": "reset_future_sleep_after_fire",
      "signature": "fn # [tokio :: test] async fn reset_future_sleep_after_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = Box :: pin (time :: sleep_until (now + ms (100))) ; sleep . as_mut () . await ; assert_elapsed ! (now , ms (100)) ; sleep . as_mut () . reset (now + ms (110)) ; sleep . await ; assert_elapsed ! (now , ms (110)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 6039610965555478624,
      "kind": "Function",
      "name": "reset_sleep_to_past",
      "signature": "fn # [tokio :: test] async fn reset_sleep_to_past () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; time :: sleep (ms (50)) . await ; assert ! (! sleep . is_woken ()) ; sleep . as_mut () . reset (now + ms (40)) ; assert_ready ! (sleep . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 15868922631312579220,
      "kind": "Function",
      "name": "creating_sleep_outside_of_context",
      "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] # [should_panic] fn creating_sleep_outside_of_context () { let now = Instant :: now () ; let _fut = time :: sleep_until (now + ms (500)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 4229647546835059279,
      "kind": "Function",
      "name": "greater_than_max",
      "signature": "fn # [tokio :: test] async fn greater_than_max () { const YR_5 : u64 = 5 * 365 * 24 * 60 * 60 * 1000 ; time :: pause () ; time :: sleep_until (Instant :: now () + ms (YR_5)) . await ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 377951968826310128,
      "kind": "Function",
      "name": "short_sleeps",
      "signature": "fn # [tokio :: test] async fn short_sleeps () { for _ in 0 .. 1000 { tokio :: time :: sleep (std :: time :: Duration :: from_millis (0)) . await ; } } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 8611487128698090204,
      "kind": "Function",
      "name": "multi_long_sleeps",
      "signature": "fn # [tokio :: test] async fn multi_long_sleeps () { tokio :: time :: pause () ; for _ in 0 .. 5u32 { tokio :: time :: sleep (Duration :: from_secs (365 * 24 * 3600 ,)) . await ; } let deadline = tokio :: time :: Instant :: now () + Duration :: from_secs (10 * 365 * 24 * 3600 ,) ; tokio :: time :: sleep_until (deadline) . await ; assert ! (tokio :: time :: Instant :: now () >= deadline) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 11326870601739329589,
      "kind": "Function",
      "name": "long_sleeps",
      "signature": "fn # [tokio :: test] async fn long_sleeps () { tokio :: time :: pause () ; let deadline = tokio :: time :: Instant :: now () + Duration :: from_secs (10 * 365 * 24 * 3600 ,) ; tokio :: time :: sleep_until (deadline) . await ; assert ! (tokio :: time :: Instant :: now () >= deadline) ; assert ! (tokio :: time :: Instant :: now () <= deadline + Duration :: from_millis (1)) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 17962852877602057520,
      "kind": "Function",
      "name": "reset_after_firing",
      "signature": "fn # [tokio :: test] async fn reset_after_firing () { let timer = tokio :: time :: sleep (std :: time :: Duration :: from_millis (1)) ; tokio :: pin ! (timer) ; let deadline = timer . deadline () ; timer . as_mut () . await ; assert_ready ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; timer . as_mut () . reset (tokio :: time :: Instant :: now () + std :: time :: Duration :: from_secs (600)) ; assert_ne ! (deadline , timer . deadline ()) ; assert_pending ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; assert_pending ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 9824148302560820802,
      "kind": "Function",
      "name": "exactly_max",
      "signature": "fn # [tokio :: test] async fn exactly_max () { time :: pause () ; time :: sleep (Duration :: MAX) . await ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 18385173381051327685,
      "kind": "Function",
      "name": "issue_5183",
      "signature": "fn # [tokio :: test] async fn issue_5183 () { time :: pause () ; let big = std :: time :: Duration :: from_secs (u64 :: MAX / 10) ; # [rustfmt :: skip] tokio :: select ! { biased ; _ = tokio :: time :: sleep (big) => { } _ = tokio :: time :: sleep (std :: time :: Duration :: from_nanos (1)) => { } } } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 17705694971914413768,
      "kind": "Function",
      "name": "no_out_of_bounds_close_to_max",
      "signature": "fn # [tokio :: test] async fn no_out_of_bounds_close_to_max () { time :: pause () ; time :: sleep (Duration :: MAX - Duration :: from_millis (1)) . await ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 2981754440723066063,
      "kind": "Function",
      "name": "drop_after_reschedule_at_new_scheduled_time",
      "signature": "fn # [tokio :: test] async fn drop_after_reschedule_at_new_scheduled_time () { use futures :: poll ; tokio :: time :: pause () ; let start = tokio :: time :: Instant :: now () ; let mut a = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (5))) ; let mut b = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (5))) ; let mut c = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (10))) ; let _ = poll ! (& mut a) ; let _ = poll ! (& mut b) ; let _ = poll ! (& mut c) ; b . as_mut () . reset (start + Duration :: from_millis (10)) ; a . await ; drop (b) ; } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 5542233035389465708,
      "kind": "Function",
      "name": "drop_from_wake",
      "signature": "fn # [tokio :: test] async fn drop_from_wake () { use std :: future :: Future ; use std :: pin :: Pin ; use std :: sync :: atomic :: { AtomicBool , Ordering } ; use std :: sync :: { Arc , Mutex } ; use std :: task :: Context ; let panicked = Arc :: new (AtomicBool :: new (false)) ; let list : Arc < Mutex < Vec < Pin < Box < tokio :: time :: Sleep > > > > > = Arc :: new (Mutex :: new (Vec :: new ())) ; let arc_wake = Arc :: new (DropWaker (panicked . clone () , list . clone ())) ; let arc_wake = futures :: task :: waker (arc_wake) ; tokio :: time :: pause () ; { let mut lock = list . lock () . unwrap () ; for _ in 0 .. 100 { let mut timer = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (10))) ; let _ = timer . as_mut () . poll (& mut Context :: from_waker (& arc_wake)) ; lock . push (timer) ; } } tokio :: time :: sleep (Duration :: from_millis (11)) . await ; assert ! (! panicked . load (Ordering :: SeqCst) , \"panicked when dropping timers\") ; # [derive (Clone)] struct DropWaker (Arc < AtomicBool > , Arc < Mutex < Vec < Pin < Box < tokio :: time :: Sleep > > > > > ,) ; impl futures :: task :: ArcWake for DropWaker { fn wake_by_ref (arc_self : & Arc < Self >) { let result = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { * arc_self . 1 . lock () . expect (\"panic in lock\") = Vec :: new () })) ; if result . is_err () { arc_self . 0 . store (true , Ordering :: SeqCst) ; } } } } . sig",
      "file_path": "tokio/tests/time_sleep.rs",
      "line": 0
    },
    {
      "hash": 7140743850924316512,
      "kind": "Function",
      "name": "simultaneous_deadline_future_completion",
      "signature": "fn # [tokio :: test] async fn simultaneous_deadline_future_completion () { let mut fut = task :: spawn (timeout_at (Instant :: now () , async { })) ; assert_ready_ok ! (fut . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 6440562551639284878,
      "kind": "Function",
      "name": "completed_future_past_deadline",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: `fut.poll()` panics on Wasi\")] # [tokio :: test] async fn completed_future_past_deadline () { let mut fut = task :: spawn (timeout_at (Instant :: now () - ms (1000) , async { })) ; assert_ready_ok ! (fut . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 7103429868004413014,
      "kind": "Function",
      "name": "future_and_deadline_in_future",
      "signature": "fn # [tokio :: test] async fn future_and_deadline_in_future () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let mut fut = task :: spawn (timeout_at (Instant :: now () + ms (100) , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (90)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 12893431416513142248,
      "kind": "Function",
      "name": "future_and_timeout_in_future",
      "signature": "fn # [tokio :: test] async fn future_and_timeout_in_future () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let mut fut = task :: spawn (timeout (ms (100) , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (90)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 6643986047018017324,
      "kind": "Function",
      "name": "very_large_timeout",
      "signature": "fn # [tokio :: test] async fn very_large_timeout () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let duration_max = Duration :: from_secs (u64 :: MAX) + Duration :: from_nanos (999_999_999) ; let mut fut = task :: spawn (timeout (duration_max , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (Duration :: from_secs (86400 * 365 * 10)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 11645147948539693242,
      "kind": "Function",
      "name": "deadline_now_elapses",
      "signature": "fn # [tokio :: test] async fn deadline_now_elapses () { use futures :: future :: pending ; time :: pause () ; let mut fut = task :: spawn (timeout_at (Instant :: now () , pending :: < () > ())) ; time :: advance (ms (1)) . await ; assert_ready_err ! (fut . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 15190235824646772652,
      "kind": "Function",
      "name": "deadline_future_elapses",
      "signature": "fn # [tokio :: test] async fn deadline_future_elapses () { time :: pause () ; let mut fut = task :: spawn (timeout_at (Instant :: now () + ms (300) , pending :: < () > ())) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (301)) . await ; assert ! (fut . is_woken ()) ; assert_ready_err ! (fut . poll ()) ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 12303020680250475792,
      "kind": "Function",
      "name": "timeout_is_not_exhausted_by_future",
      "signature": "fn # [tokio :: test] async fn timeout_is_not_exhausted_by_future () { let fut = timeout (ms (1) , async { let mut buffer = [0u8 ; 1] ; loop { use tokio :: io :: AsyncReadExt ; let _ = tokio :: io :: empty () . read (& mut buffer) . await ; } }) ; assert ! (fut . await . is_err ()) ; } . sig",
      "file_path": "tokio/tests/time_timeout.rs",
      "line": 0
    },
    {
      "hash": 7631336338655827543,
      "kind": "Function",
      "name": "instant_now_panics",
      "signature": "fn # [wasm_bindgen_test] # [should_panic] fn instant_now_panics () { let _ = tokio :: time :: Instant :: now () ; } . sig",
      "file_path": "tokio/tests/time_wasm.rs",
      "line": 0
    },
    {
      "hash": 2289131911181193709,
      "kind": "Function",
      "name": "runtime_without_time_does_not_panic",
      "signature": "fn # [cfg (all (feature = \"rt\" , not (feature = \"time\")))] # [wasm_bindgen_test] fn runtime_without_time_does_not_panic () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; } . sig",
      "file_path": "tokio/tests/time_wasm.rs",
      "line": 0
    },
    {
      "hash": 2211691530807067898,
      "kind": "Function",
      "name": "runtime_with_time_does_not_panic",
      "signature": "fn # [cfg (all (feature = \"rt\" , feature = \"time\"))] # [wasm_bindgen_test] # [should_panic] fn runtime_with_time_does_not_panic () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; } . sig",
      "file_path": "tokio/tests/time_wasm.rs",
      "line": 0
    },
    {
      "hash": 704088674927481901,
      "kind": "Function",
      "name": "sleep_panics_on_unknown_unknown",
      "signature": "fn # [cfg (all (feature = \"rt\" , feature = \"time\"))] # [wasm_bindgen_test] # [should_panic] fn sleep_panics_on_unknown_unknown () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async { tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await }) ; } . sig",
      "file_path": "tokio/tests/time_wasm.rs",
      "line": 0
    },
    {
      "hash": 18078776703006142823,
      "kind": "Function",
      "name": "test_barrier_creates_span",
      "signature": "fn # [tokio :: test] async fn test_barrier_creates_span () { let barrier_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::barrier\") ; let size_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"size\") . with_value (& 1_u64)) ; let arrived_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"arrived\") . with_value (& 0_i64)) ; let (subscriber , handle) = subscriber :: mock () . new_span (barrier_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& barrier_span) . event (size_event) . event (arrived_event) . exit (& barrier_span) . drop_span (& barrier_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Barrier :: new (1) ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_sync.rs",
      "line": 0
    },
    {
      "hash": 16672361397080569425,
      "kind": "Function",
      "name": "test_mutex_creates_span",
      "signature": "fn # [tokio :: test] async fn test_mutex_creates_span () { let mutex_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::mutex\") ; let locked_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"locked\") . with_value (& false)) ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (mutex_span . clone () . with_ancestry (expect :: is_explicit_root ())) . enter (& mutex_span) . event (locked_event) . new_span (batch_semaphore_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& batch_semaphore_span) . event (batch_semaphore_permits_event) . exit (& batch_semaphore_span) . exit (& mutex_span) . drop_span (& mutex_span) . drop_span (& batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Mutex :: new (true) ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_sync.rs",
      "line": 0
    },
    {
      "hash": 6286702950426174491,
      "kind": "Function",
      "name": "test_oneshot_creates_span",
      "signature": "fn # [tokio :: test] async fn test_oneshot_creates_span () { let oneshot_span_id = expect :: id () ; let oneshot_span = expect :: span () . with_id (oneshot_span_id . clone ()) . named (\"runtime.resource\") . with_target (\"tokio::sync::oneshot\") ; let initial_tx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"tx_dropped\") . with_value (& false)) . with_fields (expect :: field (\"tx_dropped.op\") . with_value (& \"override\")) ; let final_tx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"tx_dropped\") . with_value (& true)) . with_fields (expect :: field (\"tx_dropped.op\") . with_value (& \"override\")) ; let initial_rx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"rx_dropped\") . with_value (& false)) . with_fields (expect :: field (\"rx_dropped.op\") . with_value (& \"override\")) ; let final_rx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"rx_dropped\") . with_value (& true)) . with_fields (expect :: field (\"rx_dropped.op\") . with_value (& \"override\")) ; let value_sent_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"value_sent\") . with_value (& false)) . with_fields (expect :: field (\"value_sent.op\") . with_value (& \"override\")) ; let value_received_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"value_received\") . with_value (& false)) . with_fields (expect :: field (\"value_received.op\") . with_value (& \"override\")) ; let async_op_span_id = expect :: id () ; let async_op_span = expect :: span () . with_id (async_op_span_id . clone ()) . named (\"runtime.resource.async_op\") . with_target (\"tokio::sync::oneshot\") ; let async_op_poll_span = expect :: span () . named (\"runtime.resource.async_op.poll\") . with_target (\"tokio::sync::oneshot\") ; let (subscriber , handle) = subscriber :: mock () . new_span (oneshot_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& oneshot_span) . event (initial_tx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (initial_rx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (value_sent_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (value_received_event) . exit (& oneshot_span) . enter (& oneshot_span) . new_span (async_op_span . clone () . with_ancestry (expect :: has_contextual_parent (& oneshot_span_id)) ,) . exit (& oneshot_span) . enter (& async_op_span) . new_span (async_op_poll_span . clone () . with_ancestry (expect :: has_contextual_parent (& async_op_span_id)) ,) . exit (& async_op_span) . enter (& oneshot_span) . event (final_tx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (final_rx_dropped_event) . exit (& oneshot_span) . drop_span (oneshot_span) . drop_span (async_op_span) . drop_span (& async_op_poll_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: oneshot :: channel :: < bool > () ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_sync.rs",
      "line": 0
    },
    {
      "hash": 13621841249499378623,
      "kind": "Function",
      "name": "test_rwlock_creates_span",
      "signature": "fn # [tokio :: test] async fn test_rwlock_creates_span () { let rwlock_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::rwlock\") ; let max_readers_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"max_readers\") . with_value (& 0x1FFFFFFF_u64)) ; let write_locked_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"write_locked\") . with_value (& false)) ; let current_readers_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"current_readers\") . with_value (& 0_i64)) ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (rwlock_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (rwlock_span . clone ()) . event (max_readers_event) . event (write_locked_event) . event (current_readers_event) . exit (rwlock_span . clone ()) . enter (rwlock_span . clone ()) . new_span (batch_semaphore_span . clone ()) . enter (batch_semaphore_span . clone ()) . event (batch_semaphore_permits_event) . exit (batch_semaphore_span . clone ()) . exit (rwlock_span . clone ()) . drop_span (rwlock_span) . drop_span (batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: RwLock :: new (true) ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_sync.rs",
      "line": 0
    },
    {
      "hash": 1568215814150226245,
      "kind": "Function",
      "name": "test_semaphore_creates_span",
      "signature": "fn # [tokio :: test] async fn test_semaphore_creates_span () { let semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::semaphore\") ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (semaphore_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (semaphore_span . clone ()) . new_span (batch_semaphore_span . clone ()) . enter (batch_semaphore_span . clone ()) . event (batch_semaphore_permits_event) . exit (batch_semaphore_span . clone ()) . exit (semaphore_span . clone ()) . drop_span (semaphore_span) . drop_span (batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Semaphore :: new (1) ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_sync.rs",
      "line": 0
    },
    {
      "hash": 10819587538809965575,
      "kind": "Function",
      "name": "task_spawn_creates_span",
      "signature": "fn # [tokio :: test] async fn task_spawn_creates_span () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") ; let (subscriber , handle) = subscriber :: mock () . new_span (& task_span) . enter (& task_span) . exit (& task_span) . enter (& task_span) . exit (& task_span) . drop_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; tokio :: spawn (futures :: future :: ready (())) . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 2797130249417426576,
      "kind": "Function",
      "name": "task_spawn_loc_file_recorded",
      "signature": "fn # [tokio :: test] async fn task_spawn_loc_file_recorded () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"loc.file\") . with_value (& file ! ())) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; tokio :: spawn (futures :: future :: ready (())) . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 5125537741955295612,
      "kind": "Function",
      "name": "task_builder_name_recorded",
      "signature": "fn # [tokio :: test] async fn task_builder_name_recorded () { let task_span = expect_task_named (\"test-task\") ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . name (\"test-task\") . spawn (futures :: future :: ready (())) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 2873975374677393109,
      "kind": "Function",
      "name": "task_builder_loc_file_recorded",
      "signature": "fn # [tokio :: test] async fn task_builder_loc_file_recorded () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"loc.file\") . with_value (& file ! ())) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (futures :: future :: ready (())) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 1677100254768287194,
      "kind": "Function",
      "name": "task_spawn_sizes_recorded",
      "signature": "fn # [tokio :: test] async fn task_spawn_sizes_recorded () { let future = futures :: future :: ready (()) ; let size = mem :: size_of_val (& future) as u64 ; let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"size.bytes\") . with_value (& size)) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (future) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 7025894387847570509,
      "kind": "Function",
      "name": "task_big_spawn_sizes_recorded",
      "signature": "fn # [tokio :: test] async fn task_big_spawn_sizes_recorded () { let future = { async fn big < const N : usize > () { let mut a = [0_u8 ; N] ; for (idx , item) in a . iter_mut () . enumerate () { * item = (idx % 256) as u8 ; } tokio :: time :: sleep (Duration :: from_millis (10)) . await ; for (idx , item) in a . iter_mut () . enumerate () { assert_eq ! (* item , (idx % 256) as u8) ; } } big :: < 20_000 > () } ; fn boxed_size < T > (_ : & T) -> usize { mem :: size_of :: < Box < T > > () } let size = mem :: size_of_val (& future) as u64 ; let boxed_size = boxed_size (& future) ; let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"size.bytes\") . with_value (& boxed_size) . and (expect :: field (\"original_size.bytes\") . with_value (& size)) ,) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (future) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 16142013262249867711,
      "kind": "Function",
      "name": "expect_task_named",
      "signature": "fn # [doc = \" Expect a task with name\"] # [doc = \"\"] # [doc = \" This is a convenience function to create the expectation for a new task\"] # [doc = \" with the `task.name` field set to the provided name.\"] fn expect_task_named (name : & str) -> NewSpan { expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"task.name\") . with_value (& tracing :: field :: debug (format_args ! (\"{name}\"))) ,) } . sig",
      "file_path": "tokio/tests/tracing_task.rs",
      "line": 0
    },
    {
      "hash": 40682984557685349,
      "kind": "Function",
      "name": "test_sleep_creates_span",
      "signature": "fn # [tokio :: test] async fn test_sleep_creates_span () { let sleep_span_id = expect :: id () ; let sleep_span = expect :: span () . with_id (sleep_span_id . clone ()) . named (\"runtime.resource\") . with_target (\"tokio::time::sleep\") ; let state_update = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"duration\") . and (expect :: field (\"duration.op\") . with_value (& \"override\")) ,) ; let async_op_span_id = expect :: id () ; let async_op_span = expect :: span () . with_id (async_op_span_id . clone ()) . named (\"runtime.resource.async_op\") . with_target (\"tokio::time::sleep\") ; let async_op_poll_span = expect :: span () . named (\"runtime.resource.async_op.poll\") . with_target (\"tokio::time::sleep\") ; let (subscriber , handle) = subscriber :: mock () . new_span (sleep_span . clone () . with_ancestry (expect :: is_explicit_root ())) . enter (sleep_span . clone ()) . event (state_update) . new_span (async_op_span . clone () . with_ancestry (expect :: has_contextual_parent (& sleep_span_id)) . with_fields (expect :: field (\"source\") . with_value (& \"Sleep::new_timeout\")) ,) . exit (sleep_span . clone ()) . enter (async_op_span . clone ()) . new_span (async_op_poll_span . clone () . with_ancestry (expect :: has_contextual_parent (& async_op_span_id)) ,) . exit (async_op_span . clone ()) . drop_span (async_op_span) . drop_span (async_op_poll_span) . drop_span (sleep_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; _ = tokio :: time :: sleep (Duration :: from_millis (7)) ; } handle . assert_finished () ; } . sig",
      "file_path": "tokio/tests/tracing_time.rs",
      "line": 0
    },
    {
      "hash": 15990926015921621107,
      "kind": "Function",
      "name": "send_recv",
      "signature": "fn # [tokio :: test] async fn send_recv () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = [0u8 ; 32] ; let len = receiver . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 3947734430250691269,
      "kind": "Function",
      "name": "send_recv_poll",
      "signature": "fn # [tokio :: test] async fn send_recv_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; poll_fn (| cx | sender . poll_send (cx , MSG)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 10189307668364881783,
      "kind": "Function",
      "name": "send_to_recv_from",
      "signature": "fn # [tokio :: test] async fn send_to_recv_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; sender . send_to (MSG , & receiver_addr) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (len , addr) = receiver . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 15837443845183825305,
      "kind": "Function",
      "name": "send_to_recv_from_poll",
      "signature": "fn # [tokio :: test] async fn send_to_recv_from_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 12372509007605050528,
      "kind": "Function",
      "name": "send_to_peek_from",
      "signature": "fn # [tokio :: test] async fn send_to_peek_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 17150894327475610370,
      "kind": "Function",
      "name": "send_to_try_peek_from",
      "signature": "fn # [tokio :: test] async fn send_to_try_peek_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; loop { match receiver . try_peek_from (& mut recv_buf) { Ok ((n , addr)) => { assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; break ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { receiver . readable () . await ? ; } Err (e) => return Err (e) , } } let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 3341815392935521032,
      "kind": "Function",
      "name": "send_to_peek_from_poll",
      "signature": "fn # [tokio :: test] async fn send_to_peek_from_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_peek_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_peek_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 14848788133775985616,
      "kind": "Function",
      "name": "peek_sender",
      "signature": "fn # [tokio :: test] async fn peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; sender . send_to (msg , receiver_addr) . await ? ; let peeked_sender = receiver . peek_sender () . await ? ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let (read , received_sender) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. read] , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 1837048937739421125,
      "kind": "Function",
      "name": "poll_peek_sender",
      "signature": "fn # [tokio :: test] async fn poll_peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; poll_fn (| cx | sender . poll_send_to (cx , msg , receiver_addr)) . await ? ; let peeked_sender = poll_fn (| cx | receiver . poll_peek_sender (cx)) . await ? ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let received_sender = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 8287940780566377365,
      "kind": "Function",
      "name": "try_peek_sender",
      "signature": "fn # [tokio :: test] async fn try_peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; sender . send_to (msg , receiver_addr) . await ? ; let peeked_sender = loop { match receiver . try_peek_sender () { Ok (peeked_sender) => break peeked_sender , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { receiver . readable () . await ? ; } Err (e) => return Err (e) , } } ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let (read , received_sender) = receiver . try_recv_from (& mut recv_buf) . unwrap () ; assert_eq ! (& recv_buf [.. read] , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 13107959387732982504,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [tokio :: test] async fn split () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let s = Arc :: new (socket) ; let r = s . clone () ; let addr = s . local_addr () ? ; tokio :: spawn (async move { s . send_to (MSG , & addr) . await . unwrap () ; }) ; let mut recv_buf = [0u8 ; 32] ; let (len , _) = r . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 9515058605979048138,
      "kind": "Function",
      "name": "split_chan",
      "signature": "fn # [tokio :: test] async fn split_chan () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let addr = socket . local_addr () . unwrap () ; let s = Arc :: new (socket) ; let r = s . clone () ; let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < (Vec < u8 > , std :: net :: SocketAddr) > (1_000) ; tokio :: spawn (async move { while let Some ((bytes , addr)) = rx . recv () . await { s . send_to (& bytes , & addr) . await . unwrap () ; } }) ; tokio :: spawn (async move { let mut buf = [0u8 ; 32] ; loop { let (len , addr) = r . recv_from (& mut buf) . await . unwrap () ; tx . send ((buf [.. len] . to_vec () , addr)) . await . unwrap () ; } }) ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . send_to (MSG , addr) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (len , _) = sender . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 17570125371002267355,
      "kind": "Function",
      "name": "split_chan_poll",
      "signature": "fn # [tokio :: test] async fn split_chan_poll () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let addr = socket . local_addr () . unwrap () ; let s = Arc :: new (socket) ; let r = s . clone () ; let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < (Vec < u8 > , std :: net :: SocketAddr) > (1_000) ; tokio :: spawn (async move { while let Some ((bytes , addr)) = rx . recv () . await { poll_fn (| cx | s . poll_send_to (cx , & bytes , addr)) . await . unwrap () ; } }) ; tokio :: spawn (async move { let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; loop { let addr = poll_fn (| cx | r . poll_recv_from (cx , & mut read)) . await . unwrap () ; tx . send ((read . filled () . to_vec () , addr)) . await . unwrap () ; } }) ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let _ = poll_fn (| cx | sender . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 933051742337107336,
      "kind": "Function",
      "name": "try_send_spawn",
      "signature": "fn # [tokio :: test] async fn try_send_spawn () { const MSG2 : & [u8] = b\"world!\" ; const MSG2_LEN : usize = MSG2 . len () ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; receiver . connect (sender . local_addr () . unwrap ()) . await . unwrap () ; sender . writable () . await . unwrap () ; let sent = & sender . try_send_to (MSG , receiver . local_addr () . unwrap ()) . unwrap () ; assert_eq ! (sent , & MSG_LEN) ; let mut buf = [0u8 ; 32] ; let mut received = receiver . recv (& mut buf [..]) . await . unwrap () ; sender . connect (receiver . local_addr () . unwrap ()) . await . unwrap () ; let sent = & sender . try_send (MSG2) . unwrap () ; assert_eq ! (sent , & MSG2_LEN) ; received += receiver . recv (& mut buf [..]) . await . unwrap () ; std :: thread :: spawn (move | | { let sent = & sender . try_send (MSG) . unwrap () ; assert_eq ! (sent , & MSG_LEN) ; }) . join () . unwrap () ; received += receiver . recv (& mut buf [..]) . await . unwrap () ; assert_eq ! (received , MSG_LEN * 2 + MSG2_LEN) ; } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 14524543317576226915,
      "kind": "Function",
      "name": "try_send_recv",
      "signature": "fn # [tokio :: test] async fn try_send_recv () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; client . connect (server . local_addr () . unwrap ()) . await . unwrap () ; server . connect (client . local_addr () . unwrap ()) . await . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send (b\"hello world\") { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = [0 ; 512] ; match server . try_recv (& mut buf) { Ok (n) => { assert_eq ! (n , 11) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 5513762274095500128,
      "kind": "Function",
      "name": "try_send_to_recv_from",
      "signature": "fn # [tokio :: test] async fn try_send_to_recv_from () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = [0 ; 512] ; match server . try_recv_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 4591965134496752408,
      "kind": "Function",
      "name": "try_recv_buf",
      "signature": "fn # [tokio :: test] async fn try_recv_buf () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; client . connect (server . local_addr () . unwrap ()) . await . unwrap () ; server . connect (client . local_addr () . unwrap ()) . await . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send (b\"hello world\") { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf (& mut buf) { Ok (n) => { assert_eq ! (n , 11) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 6346538850868366875,
      "kind": "Function",
      "name": "recv_buf",
      "signature": "fn # [tokio :: test] async fn recv_buf () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = Vec :: with_capacity (32) ; let len = receiver . recv_buf (& mut recv_buf) . await ? ; assert_eq ! (len , MSG_LEN) ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 10622163246005626179,
      "kind": "Function",
      "name": "try_recv_buf_from",
      "signature": "fn # [tokio :: test] async fn try_recv_buf_from () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 17875709597171268174,
      "kind": "Function",
      "name": "recv_buf_from",
      "signature": "fn # [tokio :: test] async fn recv_buf_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = Vec :: with_capacity (32) ; let (len , caddr) = receiver . recv_buf_from (& mut recv_buf) . await ? ; assert_eq ! (len , MSG_LEN) ; assert_eq ! (& recv_buf [.. len] , MSG) ; assert_eq ! (caddr , sender . local_addr () ?) ; Ok (()) } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 17274140445583081252,
      "kind": "Function",
      "name": "poll_ready",
      "signature": "fn # [tokio :: test] async fn poll_ready () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { assert_ok ! (poll_fn (| cx | client . poll_send_ready (cx)) . await) ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { assert_ok ! (poll_fn (| cx | server . poll_recv_ready (cx)) . await) ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
      "file_path": "tokio/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 1114912521070385605,
      "kind": "Function",
      "name": "test_socket_pair",
      "signature": "fn # [tokio :: test] # [cfg_attr (target_os = \"netbsd\" , ignore = \"NetBSD does not support getpeereid() for sockets created by socketpair()\")] async fn test_socket_pair () { let (a , b) = UnixStream :: pair () . unwrap () ; let cred_a = a . peer_cred () . unwrap () ; let cred_b = b . peer_cred () . unwrap () ; assert_eq ! (cred_a , cred_b) ; let uid = unsafe { geteuid () } ; let gid = unsafe { getegid () } ; assert_eq ! (cred_a . uid () , uid) ; assert_eq ! (cred_a . gid () , gid) ; } . sig",
      "file_path": "tokio/tests/uds_cred.rs",
      "line": 0
    },
    {
      "hash": 1555390787199927726,
      "kind": "Function",
      "name": "echo_server",
      "signature": "fn async fn echo_server (socket : UnixDatagram) -> io :: Result < () > { let mut recv_buf = vec ! [0u8 ; 1024] ; loop { let (len , peer_addr) = socket . recv_from (& mut recv_buf [..]) . await ? ; if let Some (path) = peer_addr . as_pathname () { socket . send_to (& recv_buf [.. len] , path) . await ? ; } } } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 14005126086123643700,
      "kind": "Function",
      "name": "echo",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = UnixDatagram :: bind (server_path . clone ()) ? ; tokio :: spawn (async move { let _ = echo_server (server_socket) . await ; }) ; { let socket = UnixDatagram :: bind (& client_path) . unwrap () ; socket . connect (server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let len = socket . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 8219894356913371063,
      "kind": "Function",
      "name": "echo_from",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo_from () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = UnixDatagram :: bind (server_path . clone ()) ? ; tokio :: spawn (async move { let _ = echo_server (server_socket) . await ; }) ; { let socket = UnixDatagram :: bind (& client_path) . unwrap () ; socket . connect (& server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let (len , addr) = socket . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; assert_eq ! (addr . as_pathname () , Some (server_path . as_path ())) ; } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 17901932871879184204,
      "kind": "Function",
      "name": "try_send_recv_never_block",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_send_recv_never_block () -> io :: Result < () > { let mut recv_buf = [0u8 ; 16] ; let payload = b\"PAYLOAD\" ; let mut count = 0 ; let (dgram1 , dgram2) = UnixDatagram :: pair () ? ; loop { dgram1 . writable () . await . unwrap () ; match dgram1 . try_send (payload) { Err (err) => match (err . kind () , err . raw_os_error ()) { (io :: ErrorKind :: WouldBlock , _) => break , (_ , Some (libc :: ENOBUFS)) => break , _ => { panic ! (\"unexpected error {err:?}\") ; } } , Ok (len) => { assert_eq ! (len , payload . len ()) ; } } count += 1 ; } while count > 0 { dgram2 . readable () . await . unwrap () ; let len = dgram2 . try_recv (& mut recv_buf [..]) ? ; assert_eq ! (len , payload . len ()) ; assert_eq ! (payload , & recv_buf [.. len]) ; count -= 1 ; } let err = dgram2 . try_recv (& mut recv_buf [..]) . unwrap_err () ; match err . kind () { io :: ErrorKind :: WouldBlock => () , _ => unreachable ! (\"unexpected error {:?}\" , err) , } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 9529497930909301000,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn split () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let path = dir . path () . join (\"split.sock\") ; let s = Arc :: new (UnixDatagram :: bind (path . clone ()) ?) ; let r = s . clone () ; let msg = b\"hello\" ; let (() , ()) = try_join ! { async { s . send_to (msg , path) . await ?; io :: Result :: Ok (()) } , async { let mut recv_buf = [0u8 ; 32] ; let (len , _) = r . recv_from (& mut recv_buf [..]) . await ?; assert_eq ! (& recv_buf [.. len] , msg) ; Ok (()) } , } ? ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 16342550129195275527,
      "kind": "Function",
      "name": "send_to_recv_from_poll",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn send_to_recv_from_poll () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let sender_path = dir . path () . join (\"sender.sock\") ; let receiver_path = dir . path () . join (\"receiver.sock\") ; let sender = UnixDatagram :: bind (& sender_path) ? ; let receiver = UnixDatagram :: bind (& receiver_path) ? ; let msg = b\"hello\" ; poll_fn (| cx | sender . poll_send_to (cx , msg , & receiver_path)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; assert_eq ! (addr . as_pathname () , Some (sender_path . as_ref ())) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 8771947019519728347,
      "kind": "Function",
      "name": "send_recv_poll",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn send_recv_poll () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let sender_path = dir . path () . join (\"sender.sock\") ; let receiver_path = dir . path () . join (\"receiver.sock\") ; let sender = UnixDatagram :: bind (& sender_path) ? ; let receiver = UnixDatagram :: bind (& receiver_path) ? ; sender . connect (& receiver_path) ? ; receiver . connect (& sender_path) ? ; let msg = b\"hello\" ; poll_fn (| cx | sender . poll_send (cx , msg)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 6071337032967911164,
      "kind": "Function",
      "name": "try_send_to_recv_from",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_send_to_recv_from () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { client . writable () . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await ? ; let mut buf = [0 ; 512] ; match server . try_recv_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 7192461653641344779,
      "kind": "Function",
      "name": "try_recv_buf_from",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_recv_buf_from () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { client . writable () . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await ? ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 3747352085505991852,
      "kind": "Function",
      "name": "recv_buf_from",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn recv_buf_from () -> std :: io :: Result < () > { let tmp = tempfile :: tempdir () ? ; let tx_path = tmp . path () . join (\"tx\") ; let tx = UnixDatagram :: bind (& tx_path) ? ; let rx_path = tmp . path () . join (\"rx\") ; let rx = UnixDatagram :: bind (& rx_path) ? ; let bytes = b\"hello world\" ; tx . send_to (bytes , & rx_path) . await ? ; let mut buf = Vec :: with_capacity (24) ; let (size , addr) = rx . recv_buf_from (& mut buf) . await ? ; let dgram = & buf [.. size] ; assert_eq ! (dgram , bytes) ; assert_eq ! (addr . as_pathname () . unwrap () , & tx_path) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 2909643482269669358,
      "kind": "Function",
      "name": "try_recv_buf_never_block",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_recv_buf_never_block () -> io :: Result < () > { let payload = b\"PAYLOAD\" ; let mut count = 0 ; let (dgram1 , dgram2) = UnixDatagram :: pair () ? ; loop { dgram1 . writable () . await . unwrap () ; match dgram1 . try_send (payload) { Err (err) => match (err . kind () , err . raw_os_error ()) { (io :: ErrorKind :: WouldBlock , _) => break , (_ , Some (libc :: ENOBUFS)) => break , _ => { panic ! (\"unexpected error {err:?}\") ; } } , Ok (len) => { assert_eq ! (len , payload . len ()) ; } } count += 1 ; } while count > 0 { let mut recv_buf = Vec :: with_capacity (16) ; dgram2 . readable () . await . unwrap () ; let len = dgram2 . try_recv_buf (& mut recv_buf) ? ; assert_eq ! (len , payload . len ()) ; assert_eq ! (payload , & recv_buf [.. len]) ; count -= 1 ; } let mut recv_buf = vec ! [0 ; 16] ; let err = dgram2 . try_recv_from (& mut recv_buf) . unwrap_err () ; match err . kind () { io :: ErrorKind :: WouldBlock => () , _ => unreachable ! (\"unexpected error {:?}\" , err) , } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 11721599243036260709,
      "kind": "Function",
      "name": "recv_buf",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn recv_buf () -> std :: io :: Result < () > { let (sock1 , sock2) = UnixDatagram :: pair () ? ; let bytes = b\"hello world\" ; sock1 . send (bytes) . await ? ; let mut buff = Vec :: with_capacity (24) ; let size = sock2 . recv_buf (& mut buff) . await ? ; let dgram = & buff [.. size] ; assert_eq ! (dgram , bytes) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 2321604500489333,
      "kind": "Function",
      "name": "poll_ready",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_ready () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { poll_fn (| cx | client . poll_send_ready (cx)) . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { poll_fn (| cx | server . poll_recv_ready (cx)) . await ? ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_datagram.rs",
      "line": 0
    },
    {
      "hash": 316374478794523764,
      "kind": "Function",
      "name": "datagram_echo_server",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn datagram_echo_server () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = { let socket = UnixSocket :: new_datagram () ? ; socket . bind (& server_path) ? ; socket . datagram () ? } ; tokio :: spawn (async move { let mut recv_buf = vec ! [0u8 ; 1024] ; loop { let (len , peer_addr) = server_socket . recv_from (& mut recv_buf [..]) . await ? ; if let Some (path) = peer_addr . as_pathname () { server_socket . send_to (& recv_buf [.. len] , path) . await ? ; } } # [allow (unreachable_code)] Ok :: < () , io :: Error > (()) }) ; { let socket = UnixSocket :: new_datagram () ? ; socket . bind (& client_path) . unwrap () ; let socket = socket . datagram () ? ; socket . connect (server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let len = socket . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_socket.rs",
      "line": 0
    },
    {
      "hash": 10549232126598640537,
      "kind": "Function",
      "name": "listen_and_stream",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn listen_and_stream () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let peer_path = dir . path () . join (\"peer.sock\") ; let listener = { let sock = UnixSocket :: new_stream () ? ; sock . bind (& sock_path) ? ; sock . listen (1024) ? } ; let accept = listener . accept () ; let connect = { let sock = UnixSocket :: new_stream () ? ; sock . bind (& peer_path) ? ; sock . connect (& sock_path) } ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; assert_eq ! (server . peer_addr () . unwrap () . as_pathname () . unwrap () , & peer_path) ; client . write_all (b\"hello\") . await ? ; drop (client) ; let mut buf = vec ! [] ; server . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf , b\"hello\") ; let len = server . read (& mut buf) . await ? ; assert_eq ! (len , 0) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_socket.rs",
      "line": 0
    },
    {
      "hash": 11662887303097919846,
      "kind": "Function",
      "name": "assert_usage",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn assert_usage () -> std :: io :: Result < () > { let datagram_socket = UnixSocket :: new_datagram () ? ; let result = datagram_socket . connect (std :: path :: PathBuf :: new () . join (\"invalid.sock\")) . await ; assert_eq ! (result . unwrap_err () . to_string () , \"connect cannot be called on a datagram socket\") ; let datagram_socket = UnixSocket :: new_datagram () ? ; let result = datagram_socket . listen (1024) ; assert_eq ! (result . unwrap_err () . to_string () , \"listen cannot be called on a datagram socket\") ; let stream_socket = UnixSocket :: new_stream () ? ; let result = stream_socket . datagram () ; assert_eq ! (result . unwrap_err () . to_string () , \"datagram cannot be called on a stream socket\") ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_socket.rs",
      "line": 0
    },
    {
      "hash": 6215840268094662238,
      "kind": "Function",
      "name": "split",
      "signature": "fn # [doc = \" Checks that `UnixStream` can be split into a read half and a write half using\"] # [doc = \" `UnixStream::split` and `UnixStream::split_mut`.\"] # [doc = \"\"] # [doc = \" Verifies that the implementation of `AsyncWrite::poll_shutdown` shutdowns the stream for\"] # [doc = \" writing by reading to the end of stream on the other side of the connection.\"] # [tokio :: test] async fn split () -> std :: io :: Result < () > { let (mut a , mut b) = UnixStream :: pair () ? ; let (mut a_read , mut a_write) = a . split () ; let (mut b_read , mut b_write) = b . split () ; let (a_response , b_response) = futures :: future :: try_join (send_recv_all (& mut a_read , & mut a_write , b\"A\") , send_recv_all (& mut b_read , & mut b_write , b\"B\") ,) . await ? ; assert_eq ! (a_response , b\"B\") ; assert_eq ! (b_response , b\"A\") ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_split.rs",
      "line": 0
    },
    {
      "hash": 14034311364652386265,
      "kind": "Function",
      "name": "send_recv_all",
      "signature": "fn async fn send_recv_all (read : & mut (dyn AsyncRead + Unpin) , write : & mut (dyn AsyncWrite + Unpin) , input : & [u8] ,) -> std :: io :: Result < Vec < u8 > > { write . write_all (input) . await ? ; write . shutdown () . await ? ; let mut output = Vec :: new () ; read . read_to_end (& mut output) . await ? ; Ok (output) } . sig",
      "file_path": "tokio/tests/uds_split.rs",
      "line": 0
    },
    {
      "hash": 11674819219622184977,
      "kind": "Function",
      "name": "accept_read_write",
      "signature": "fn # [tokio :: test] async fn accept_read_write () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let accept = listener . accept () ; let connect = UnixStream :: connect (& sock_path) ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; client . write_all (b\"hello\") . await ? ; drop (client) ; let mut buf = vec ! [] ; server . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf , b\"hello\") ; let len = server . read (& mut buf) . await ? ; assert_eq ! (len , 0) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 4461038161007392716,
      "kind": "Function",
      "name": "shutdown",
      "signature": "fn # [tokio :: test] async fn shutdown () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let accept = listener . accept () ; let connect = UnixStream :: connect (& sock_path) ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; AsyncWriteExt :: shutdown (& mut client) . await ? ; let mut buf = [0u8 ; 1] ; let n = server . read (& mut buf) . await ? ; assert_eq ! (n , 0) ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 15607180967848062382,
      "kind": "Function",
      "name": "try_read_write",
      "signature": "fn # [tokio :: test] async fn try_read_write () -> std :: io :: Result < () > { let msg = b\"hello world\" ; let dir = tempfile :: tempdir () ? ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = UnixListener :: bind (& bind_path) ? ; let client = UnixStream :: connect (& bind_path) . await ? ; let (server , _) = listener . accept () . await ? ; let mut written = msg . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await ? ; assert_eq ! (msg . len () , client . try_write (msg) ?) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (msg) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await ? ; match server . try_read (& mut read [i ..]) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } written . clear () ; client . writable () . await . unwrap () ; let msg_bufs : Vec < _ > = msg . chunks (3) . map (io :: IoSlice :: new) . collect () ; loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write_vectored (& msg_bufs) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await ? ; let mut bufs : Vec < _ > = read [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match server . try_read_vectored (& mut bufs) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await ? ; if ready . is_read_closed () { break ; } else { tokio :: task :: yield_now () . await ; } } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 14496488698235427490,
      "kind": "Function",
      "name": "create_pair",
      "signature": "fn async fn create_pair () -> (UnixStream , UnixStream) { let dir = assert_ok ! (tempfile :: tempdir ()) ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = assert_ok ! (UnixListener :: bind (& bind_path)) ; let accept = listener . accept () ; let connect = UnixStream :: connect (& bind_path) ; let ((server , _) , client) = assert_ok ! (try_join (accept , connect) . await) ; (client , server) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 3528477811311015606,
      "kind": "Function",
      "name": "poll_read_ready",
      "signature": "fn # [tokio :: test] async fn poll_read_ready () { let (mut client , mut server) = create_pair () . await ; assert_not_readable_by_polling ! (server) ; assert_ok ! (client . write_all (b\"ping\") . await) ; assert_readable_by_polling ! (server) ; let mut buf = [0u8 ; 4] ; assert_ok ! (server . read_exact (& mut buf) . await) ; assert_readable_by_polling ! (server) ; read_until_pending (& mut server) ; assert_not_readable_by_polling ! (server) ; drop (client) ; assert_readable_by_polling ! (server) ; } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 1057393577227173347,
      "kind": "Function",
      "name": "poll_write_ready",
      "signature": "fn # [tokio :: test] async fn poll_write_ready () { let (mut client , server) = create_pair () . await ; assert_writable_by_polling ! (client) ; write_until_pending (& mut client) ; assert_not_writable_by_polling ! (client) ; drop (server) ; assert_writable_by_polling ! (client) ; } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 16746251706377824707,
      "kind": "Function",
      "name": "read_until_pending",
      "signature": "fn fn read_until_pending (stream : & mut UnixStream) { let mut buf = vec ! [0u8 ; 1024 * 1024] ; loop { match stream . try_read (& mut buf) { Ok (_) => () , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 3294226047057937077,
      "kind": "Function",
      "name": "write_until_pending",
      "signature": "fn fn write_until_pending (stream : & mut UnixStream) { let buf = vec ! [0u8 ; 1024 * 1024] ; loop { match stream . try_write (& buf) { Ok (_) => () , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 526306796881648488,
      "kind": "Function",
      "name": "try_read_buf",
      "signature": "fn # [tokio :: test] async fn try_read_buf () -> std :: io :: Result < () > { let msg = b\"hello world\" ; let dir = tempfile :: tempdir () ? ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = UnixListener :: bind (& bind_path) ? ; let client = UnixStream :: connect (& bind_path) . await ? ; let (server , _) = listener . accept () . await ? ; let mut written = msg . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await ? ; assert_eq ! (msg . len () , client . try_write (msg) ?) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (msg) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = Vec :: with_capacity (written . len ()) ; let mut i = 0 ; while i < read . capacity () { server . readable () . await ? ; match server . try_read_buf (& mut read) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await ? ; if ready . is_read_closed () { break ; } else { tokio :: task :: yield_now () . await ; } } Ok (()) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 5617647862112431623,
      "kind": "Function",
      "name": "epollhup",
      "signature": "fn # [tokio :: test] # [cfg (not (target_os = \"macos\"))] async fn epollhup () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let connect = UnixStream :: connect (& sock_path) ; tokio :: pin ! (connect) ; poll_fn (| cx | { use std :: future :: Future ; assert_pending ! (connect . as_mut () . poll (cx)) ; Poll :: Ready (()) }) . await ; drop (listener) ; let err = connect . await . unwrap_err () ; let errno = err . kind () ; assert ! (matches ! (errno , io :: ErrorKind :: ConnectionRefused | io :: ErrorKind :: ConnectionReset) , \"unexpected error kind: {errno:?} (expected ConnectionRefused or ConnectionReset)\") ; Ok (()) } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 6640830912395551450,
      "kind": "Function",
      "name": "abstract_socket_name",
      "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] async fn abstract_socket_name () { let socket_path = \"\\0aaa\" ; let listener = UnixListener :: bind (socket_path) . unwrap () ; let accept = listener . accept () ; let connect = UnixStream :: connect (& socket_path) ; let ((stream , _) , _) = try_join (accept , connect) . await . unwrap () ; let local_addr = stream . into_std () . unwrap () . local_addr () . unwrap () ; let abstract_path_name = local_addr . as_abstract_name () . unwrap () ; assert_eq ! (abstract_path_name , b\"aaa\") ; } . sig",
      "file_path": "tokio/tests/uds_stream.rs",
      "line": 0
    },
    {
      "hash": 11968951795951961663,
      "kind": "Function",
      "name": "notify_is_unwind_safe",
      "signature": "fn # [test] fn notify_is_unwind_safe () { is_unwind_safe :: < tokio :: sync :: Notify > () ; } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 604508968159707601,
      "kind": "Function",
      "name": "join_handle_is_unwind_safe",
      "signature": "fn # [test] fn join_handle_is_unwind_safe () { is_unwind_safe :: < tokio :: task :: JoinHandle < () > > () ; } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 10255663779264964703,
      "kind": "Function",
      "name": "net_types_are_unwind_safe",
      "signature": "fn # [test] fn net_types_are_unwind_safe () { is_unwind_safe :: < tokio :: net :: TcpListener > () ; is_unwind_safe :: < tokio :: net :: TcpSocket > () ; is_unwind_safe :: < tokio :: net :: TcpStream > () ; is_unwind_safe :: < tokio :: net :: UdpSocket > () ; } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 9355014195375293744,
      "kind": "Function",
      "name": "unix_net_types_are_unwind_safe",
      "signature": "fn # [test] # [cfg (unix)] fn unix_net_types_are_unwind_safe () { is_unwind_safe :: < tokio :: net :: UnixDatagram > () ; is_unwind_safe :: < tokio :: net :: UnixListener > () ; is_unwind_safe :: < tokio :: net :: UnixStream > () ; } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 5084277325042152232,
      "kind": "Function",
      "name": "windows_net_types_are_unwind_safe",
      "signature": "fn # [test] # [cfg (windows)] fn windows_net_types_are_unwind_safe () { use tokio :: net :: windows :: named_pipe :: NamedPipeClient ; use tokio :: net :: windows :: named_pipe :: NamedPipeServer ; is_unwind_safe :: < NamedPipeClient > () ; is_unwind_safe :: < NamedPipeServer > () ; } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 13819264992242774440,
      "kind": "Function",
      "name": "is_unwind_safe",
      "signature": "fn fn is_unwind_safe < T : UnwindSafe + RefUnwindSafe > () { } . sig",
      "file_path": "tokio/tests/unwindsafe.rs",
      "line": 0
    },
    {
      "hash": 9325488110271063966,
      "kind": "Struct",
      "name": "IoBufs",
      "signature": "struct IoBufs",
      "file_path": "tokio/tests/support/io_vec.rs",
      "line": 0
    },
    {
      "hash": 698980585982817360,
      "kind": "Struct",
      "name": "LeakedBuffers",
      "signature": "struct LeakedBuffers",
      "file_path": "tokio/tests/support/leaked_buffers.rs",
      "line": 0
    },
    {
      "hash": 2614818944277990658,
      "kind": "Struct",
      "name": "UnboundedStream",
      "signature": "struct UnboundedStream",
      "file_path": "tokio/tests/support/mpsc_stream.rs",
      "line": 0
    },
    {
      "hash": 14221341861680600639,
      "kind": "Function",
      "name": "unbounded_channel_stream",
      "signature": "fn pub fn unbounded_channel_stream < T : Unpin > () -> (UnboundedSender < T > , impl Stream < Item = T >) { let (tx , rx) = mpsc :: unbounded_channel () ; let stream = UnboundedStream { recv : rx } ; (tx , stream) } . sig",
      "file_path": "tokio/tests/support/mpsc_stream.rs",
      "line": 0
    },
    {
      "hash": 4422208106468360496,
      "kind": "Struct",
      "name": "BoundedStream",
      "signature": "struct BoundedStream",
      "file_path": "tokio/tests/support/mpsc_stream.rs",
      "line": 0
    },
    {
      "hash": 5939188393699268162,
      "kind": "Function",
      "name": "channel_stream",
      "signature": "fn pub fn channel_stream < T : Unpin > (size : usize) -> (Sender < T > , impl Stream < Item = T >) { let (tx , rx) = mpsc :: channel (size) ; let stream = BoundedStream { recv : rx } ; (tx , stream) } . sig",
      "file_path": "tokio/tests/support/mpsc_stream.rs",
      "line": 0
    },
    {
      "hash": 5661445706401669258,
      "kind": "Function",
      "name": "test_panic",
      "signature": "fn pub fn test_panic < Func : FnOnce () + panic :: UnwindSafe > (func : Func) -> Option < String > { static PANIC_MUTEX : Mutex < () > = Mutex :: new (()) ; { let _guard = PANIC_MUTEX . lock () ; let panic_file : Arc < Mutex < Option < String > > > = Arc :: new (Mutex :: new (None)) ; let prev_hook = panic :: take_hook () ; { let panic_file = panic_file . clone () ; panic :: set_hook (Box :: new (move | panic_info | { let panic_location = panic_info . location () . unwrap () ; panic_file . lock () . unwrap () . clone_from (& Some (panic_location . file () . to_string ())) ; })) ; } let result = panic :: catch_unwind (func) ; panic :: set_hook (prev_hook) ; if result . is_err () { panic_file . lock () . unwrap () . clone () } else { None } } } . sig",
      "file_path": "tokio/tests/support/panic.rs",
      "line": 0
    },
    {
      "hash": 10371666809508289839,
      "kind": "Function",
      "name": "send_signal",
      "signature": "fn pub fn send_signal (signal : libc :: c_int) { use libc :: { getpid , kill } ; unsafe { let pid = getpid () ; assert_eq ! (kill (pid , signal) , 0 , \"kill(pid = {}, {}) failed with error: {}\" , pid , signal , std :: io :: Error :: last_os_error () ,) ; } } . sig",
      "file_path": "tokio/tests/support/signal.rs",
      "line": 0
    },
    {
      "hash": 12921976271857894703,
      "kind": "Struct",
      "name": "FinalConfig",
      "signature": "struct FinalConfig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 2398938913571170268,
      "kind": "Struct",
      "name": "Configuration",
      "signature": "struct Configuration",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 13455036858706122811,
      "kind": "Function",
      "name": "parse_int",
      "signature": "fn fn parse_int (int : syn :: Lit , span : Span , field : & str) -> Result < usize , syn :: Error > { match int { syn :: Lit :: Int (lit) => match lit . base10_parse :: < usize > () { Ok (value) => Ok (value) , Err (e) => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as integer: {e}\") ,)) , } , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as integer.\") ,)) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 8347033944527597743,
      "kind": "Function",
      "name": "parse_string",
      "signature": "fn fn parse_string (int : syn :: Lit , span : Span , field : & str) -> Result < String , syn :: Error > { match int { syn :: Lit :: Str (s) => Ok (s . value ()) , syn :: Lit :: Verbatim (s) => Ok (s . to_string ()) , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as string.\") ,)) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 4994417623242020217,
      "kind": "Function",
      "name": "parse_path",
      "signature": "fn fn parse_path (lit : syn :: Lit , span : Span , field : & str) -> Result < Path , syn :: Error > { match lit { syn :: Lit :: Str (s) => { let err = syn :: Error :: new (span , format ! (\"Failed to parse value of `{}` as path: \\\"{}\\\"\" , field , s . value ()) ,) ; s . parse :: < syn :: Path > () . map_err (| _ | err . clone ()) } _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as path.\") ,)) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 8273796900689350714,
      "kind": "Function",
      "name": "parse_bool",
      "signature": "fn fn parse_bool (bool : syn :: Lit , span : Span , field : & str) -> Result < bool , syn :: Error > { match bool { syn :: Lit :: Bool (b) => Ok (b . value) , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as bool.\") ,)) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 16969277124423796390,
      "kind": "Function",
      "name": "build_config",
      "signature": "fn fn build_config (input : & ItemFn , args : AttributeArgs , is_test : bool , rt_multi_thread : bool ,) -> Result < FinalConfig , syn :: Error > { if input . sig . asyncness . is_none () { let msg = \"the `async` keyword is missing from the function declaration\" ; return Err (syn :: Error :: new_spanned (input . sig . fn_token , msg)) ; } let mut config = Configuration :: new (is_test , rt_multi_thread) ; let macro_name = config . macro_name () ; for arg in args { match arg { syn :: Meta :: NameValue (namevalue) => { let ident = namevalue . path . get_ident () . ok_or_else (| | { syn :: Error :: new_spanned (& namevalue , \"Must have specified ident\") }) ? . to_string () . to_lowercase () ; let lit = match & namevalue . value { syn :: Expr :: Lit (syn :: ExprLit { lit , .. }) => lit , expr => return Err (syn :: Error :: new_spanned (expr , \"Must be a literal\")) , } ; match ident . as_str () { \"worker_threads\" => { config . set_worker_threads (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"flavor\" => { config . set_flavor (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"start_paused\" => { config . set_start_paused (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"core_threads\" => { let msg = \"Attribute `core_threads` is renamed to `worker_threads`\" ; return Err (syn :: Error :: new_spanned (namevalue , msg)) ; } \"crate\" => { config . set_crate_name (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"unhandled_panic\" => { config . set_unhandled_panic (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } name => { let msg = format ! (\"Unknown attribute {name} is specified; expected one of: `flavor`, `worker_threads`, `start_paused`, `crate`, `unhandled_panic`\" ,) ; return Err (syn :: Error :: new_spanned (namevalue , msg)) ; } } } syn :: Meta :: Path (path) => { let name = path . get_ident () . ok_or_else (| | syn :: Error :: new_spanned (& path , \"Must have specified ident\")) ? . to_string () . to_lowercase () ; let msg = match name . as_str () { \"threaded_scheduler\" | \"multi_thread\" => { format ! (\"Set the runtime flavor with #[{macro_name}(flavor = \\\"multi_thread\\\")].\") } \"basic_scheduler\" | \"current_thread\" | \"single_threaded\" => { format ! (\"Set the runtime flavor with #[{macro_name}(flavor = \\\"current_thread\\\")].\") } \"flavor\" | \"worker_threads\" | \"start_paused\" | \"crate\" | \"unhandled_panic\" => { format ! (\"The `{name}` attribute requires an argument.\") } name => { format ! (\"Unknown attribute {name} is specified; expected one of: `flavor`, `worker_threads`, `start_paused`, `crate`, `unhandled_panic`.\") } } ; return Err (syn :: Error :: new_spanned (path , msg)) ; } other => { return Err (syn :: Error :: new_spanned (other , \"Unknown attribute inside the macro\" ,)) ; } } } config . build () } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 8587248811732642048,
      "kind": "Function",
      "name": "parse_knobs",
      "signature": "fn fn parse_knobs (mut input : ItemFn , is_test : bool , config : FinalConfig) -> TokenStream { input . sig . asyncness = None ; let (last_stmt_start_span , last_stmt_end_span) = { let mut last_stmt = input . stmts . last () . cloned () . unwrap_or_default () . into_iter () ; let start = last_stmt . next () . map_or_else (Span :: call_site , | t | t . span ()) ; let end = last_stmt . last () . map_or (start , | t | t . span ()) ; (start , end) } ; let crate_path = config . crate_name . map (ToTokens :: into_token_stream) . unwrap_or_else (| | Ident :: new (\"tokio\" , last_stmt_start_span) . into_token_stream ()) ; let mut rt = match config . flavor { RuntimeFlavor :: CurrentThread | RuntimeFlavor :: Local => { quote_spanned ! { last_stmt_start_span => # crate_path :: runtime :: Builder :: new_current_thread () } } RuntimeFlavor :: Threaded => quote_spanned ! { last_stmt_start_span => # crate_path :: runtime :: Builder :: new_multi_thread () } , } ; let mut checks = vec ! [] ; let mut errors = vec ! [] ; let build = if let RuntimeFlavor :: Local = config . flavor { checks . push (quote ! { tokio_unstable }) ; errors . push (\"The local runtime flavor is only available when `tokio_unstable` is set.\") ; quote_spanned ! { last_stmt_start_span => build_local (Default :: default ()) } } else { quote_spanned ! { last_stmt_start_span => build () } } ; if let Some (v) = config . worker_threads { rt = quote_spanned ! { last_stmt_start_span => # rt . worker_threads (# v) } ; } if let Some (v) = config . start_paused { rt = quote_spanned ! { last_stmt_start_span => # rt . start_paused (# v) } ; } if let Some (v) = config . unhandled_panic { let unhandled_panic = v . into_tokens (& crate_path) ; rt = quote_spanned ! { last_stmt_start_span => # rt . unhandled_panic (# unhandled_panic) } ; } let generated_attrs = if is_test { quote ! { # [:: core :: prelude :: v1 :: test] } } else { quote ! { } } ; let do_checks : TokenStream = checks . iter () . zip (& errors) . map (| (check , error) | { quote ! { # [cfg (not (# check))] compile_error ! (# error) ; } }) . collect () ; let body_ident = quote ! { body } ; let last_block = quote_spanned ! { last_stmt_end_span => # do_checks # [cfg (all (# (# checks) ,*))] # [allow (clippy :: expect_used , clippy :: diverging_sub_expression , clippy :: needless_return , clippy :: unwrap_in_result)] { return # rt . enable_all () .# build . expect (\"Failed building the Runtime\") . block_on (# body_ident) ; } # [cfg (not (all (# (# checks) ,*)))] { panic ! (\"fell through checks\") } } ; let body = input . body () ; let body = if is_test { let output_type = match & input . sig . output { syn :: ReturnType :: Default => quote ! { () } , syn :: ReturnType :: Type (_ , ret_type) => quote ! { # ret_type } , } ; quote ! { let body = async # body ; # crate_path :: pin ! (body) ; let body : :: core :: pin :: Pin <& mut dyn :: core :: future :: Future < Output = # output_type >> = body ; } } else { quote ! { let body = async # body ; } } ; input . into_tokens (generated_attrs , body , last_block) } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 14860720404121255863,
      "kind": "Function",
      "name": "token_stream_with_error",
      "signature": "fn fn token_stream_with_error (mut tokens : TokenStream , error : syn :: Error) -> TokenStream { tokens . extend (error . into_compile_error ()) ; tokens } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 3324333242043889655,
      "kind": "Function",
      "name": "main",
      "signature": "fn pub (crate) fn main (args : TokenStream , item : TokenStream , rt_multi_thread : bool) -> TokenStream { let input : ItemFn = match syn :: parse2 (item . clone ()) { Ok (it) => it , Err (e) => return token_stream_with_error (item , e) , } ; let config = if input . sig . ident == \"main\" && ! input . sig . inputs . is_empty () { let msg = \"the main function cannot accept arguments\" ; Err (syn :: Error :: new_spanned (& input . sig . ident , msg)) } else { AttributeArgs :: parse_terminated . parse2 (args) . and_then (| args | build_config (& input , args , false , rt_multi_thread)) } ; match config { Ok (config) => parse_knobs (input , false , config) , Err (e) => token_stream_with_error (parse_knobs (input , false , DEFAULT_ERROR_CONFIG) , e) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 3019973558400804781,
      "kind": "Function",
      "name": "is_test_attribute",
      "signature": "fn fn is_test_attribute (attr : & Attribute) -> bool { let path = match & attr . meta { syn :: Meta :: Path (path) => path , _ => return false , } ; let candidates = [[\"core\" , \"prelude\" , \"*\" , \"test\"] , [\"std\" , \"prelude\" , \"*\" , \"test\"] ,] ; if path . leading_colon . is_none () && path . segments . len () == 1 && path . segments [0] . arguments . is_none () && path . segments [0] . ident == \"test\" { return true ; } else if path . segments . len () != candidates [0] . len () { return false ; } candidates . into_iter () . any (| segments | { path . segments . iter () . zip (segments) . all (| (segment , path) | { segment . arguments . is_none () && (path == \"*\" || segment . ident == path) }) }) } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 10127998942489457128,
      "kind": "Function",
      "name": "test",
      "signature": "fn pub (crate) fn test (args : TokenStream , item : TokenStream , rt_multi_thread : bool) -> TokenStream { let input : ItemFn = match syn :: parse2 (item . clone ()) { Ok (it) => it , Err (e) => return token_stream_with_error (item , e) , } ; let config = if let Some (attr) = input . attrs () . find (| attr | is_test_attribute (attr)) { let msg = \"second test attribute is supplied, consider removing or changing the order of your test attributes\" ; Err (syn :: Error :: new_spanned (attr , msg)) } else { AttributeArgs :: parse_terminated . parse2 (args) . and_then (| args | build_config (& input , args , true , rt_multi_thread)) } ; match config { Ok (config) => parse_knobs (input , true , config) , Err (e) => token_stream_with_error (parse_knobs (input , true , DEFAULT_ERROR_CONFIG) , e) , } } . sig",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 5308382748740698763,
      "kind": "Struct",
      "name": "ItemFn",
      "signature": "struct ItemFn",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 5876041598109077416,
      "kind": "Struct",
      "name": "Body",
      "signature": "struct Body",
      "file_path": "tokio-macros/src/entry.rs",
      "line": 0
    },
    {
      "hash": 6948727309438387637,
      "kind": "Function",
      "name": "main",
      "signature": "fn # [doc = \" Marks async function to be executed by the selected runtime. This macro\"] # [doc = \" helps set up a `Runtime` without requiring the user to use\"] # [doc = \" [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" Note: This macro is designed to be simplistic and targets applications that\"] # [doc = \" do not require a complex setup. If the provided functionality is not\"] # [doc = \" sufficient, you may be interested in using\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html), which provides a more\"] # [doc = \" powerful interface.\"] # [doc = \"\"] # [doc = \" Note: This macro can be used on any function and not just the `main`\"] # [doc = \" function. Using it on a non-main function makes the function behave as if it\"] # [doc = \" was synchronous by starting a new runtime each time it is called. If the\"] # [doc = \" function is called often, it is preferable to create the runtime using the\"] # [doc = \" runtime builder so the runtime can be reused across calls.\"] # [doc = \"\"] # [doc = \" # Non-worker async function\"] # [doc = \"\"] # [doc = \" Note that the async function marked with this macro does not run as a\"] # [doc = \" worker. The expectation is that other tasks are spawned by the function here.\"] # [doc = \" Awaiting on other futures from the function provided here will not\"] # [doc = \" perform as fast as those spawned as workers.\"] # [doc = \"\"] # [doc = \" # Runtime flavors\"] # [doc = \"\"] # [doc = \" The macro can be configured with a `flavor` parameter to select\"] # [doc = \" different runtime configurations.\"] # [doc = \"\"] # [doc = \" ## Multi-threaded\"] # [doc = \"\"] # [doc = \" To use the multi-threaded runtime, the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" #[tokio::main(flavor = \\\"multi_thread\\\", worker_threads = 10)]\"] # [doc = \" # async fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" The `worker_threads` option configures the number of worker threads, and\"] # [doc = \" defaults to the number of cpus on the system. This is the default flavor.\"] # [doc = \"\"] # [doc = \" Note: The multi-threaded runtime requires the `rt-multi-thread` feature\"] # [doc = \" flag.\"] # [doc = \"\"] # [doc = \" ## Current-thread\"] # [doc = \"\"] # [doc = \" To use the single-threaded runtime known as the `current_thread` runtime,\"] # [doc = \" the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Local\"] # [doc = \"\"] # [doc = \" [Unstable API][unstable] only.\"] # [doc = \"\"] # [doc = \" To use the [local runtime], the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"local\\\")]\"] # [doc = \" # async fn main() {}\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" # Function arguments\"] # [doc = \"\"] # [doc = \" Arguments are allowed for any functions, aside from `main` which is special.\"] # [doc = \"\"] # [doc = \" # Usage\"] # [doc = \"\"] # [doc = \" ## Using the multi-threaded runtime\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Using the current-thread runtime\"] # [doc = \"\"] # [doc = \" The basic scheduler is single-threaded.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Using the local runtime\"] # [doc = \"\"] # [doc = \" Available in the [unstable API][unstable] only.\"] # [doc = \"\"] # [doc = \" The [local runtime] is similar to the current-thread runtime but\"] # [doc = \" supports [`task::spawn_local`](../tokio/task/fn.spawn_local.html).\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"local\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build_local(tokio::runtime::LocalOptions::default())\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \"\"] # [doc = \" ## Set number of worker threads\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(worker_threads = 2)]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .worker_threads(2)\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Configure the runtime to start with time paused\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\", start_paused = true)]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .start_paused(true)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Note that `start_paused` requires the `test-util` feature to be enabled.\"] # [doc = \"\"] # [doc = \" ## Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::main(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" fn main() {\"] # [doc = \"     tokio1::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Configure unhandled panic behavior\"] # [doc = \"\"] # [doc = \" Available options are `shutdown_runtime` and `ignore`. For more details, see\"] # [doc = \" [`Builder::unhandled_panic`].\"] # [doc = \"\"] # [doc = \" This option is only compatible with the `current_thread` runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\", unhandled_panic = \\\"shutdown_runtime\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     let _ = tokio::spawn(async {\"] # [doc = \"         panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"     }).await;\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .unhandled_panic(tokio::runtime::UnhandledPanic::ShutdownRuntime)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             let _ = tokio::spawn(async {\"] # [doc = \"                 panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"             }).await;\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" **Note**: This option depends on Tokio's [unstable API][unstable]. See [the\"] # [doc = \" documentation on unstable features][unstable] for details on how to enable\"] # [doc = \" Tokio's unstable features.\"] # [doc = \"\"] # [doc = \" [`Builder::unhandled_panic`]: ../tokio/runtime/struct.Builder.html#method.unhandled_panic\"] # [doc = \" [unstable]: ../tokio/index.html#unstable-features\"] # [doc = \" [local runtime]: ../tokio/runtime/struct.LocalRuntime.html\"] # [proc_macro_attribute] pub fn main (args : TokenStream , item : TokenStream) -> TokenStream { entry :: main (args . into () , item . into () , true) . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 1878271190395791280,
      "kind": "Function",
      "name": "main_rt",
      "signature": "fn # [doc = \" Marks async function to be executed by selected runtime. This macro helps set up a `Runtime`\"] # [doc = \" without requiring the user to use [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" ## Function arguments:\"] # [doc = \"\"] # [doc = \" Arguments are allowed for any functions aside from `main` which is special\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ### Using default\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::main(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" fn main() {\"] # [doc = \"     tokio1::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn main_rt (args : TokenStream , item : TokenStream) -> TokenStream { entry :: main (args . into () , item . into () , false) . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 14325229354083954098,
      "kind": "Function",
      "name": "test",
      "signature": "fn # [doc = \" Marks async function to be executed by runtime, suitable to test environment.\"] # [doc = \" This macro helps set up a `Runtime` without requiring the user to use\"] # [doc = \" [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" Note: This macro is designed to be simplistic and targets applications that\"] # [doc = \" do not require a complex setup. If the provided functionality is not\"] # [doc = \" sufficient, you may be interested in using\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html), which provides a more\"] # [doc = \" powerful interface.\"] # [doc = \"\"] # [doc = \" # Multi-threaded runtime\"] # [doc = \"\"] # [doc = \" To use the multi-threaded runtime, the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\", worker_threads = 1)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" The `worker_threads` option configures the number of worker threads, and\"] # [doc = \" defaults to the number of cpus on the system.\"] # [doc = \"\"] # [doc = \" Note: The multi-threaded runtime requires the `rt-multi-thread` feature\"] # [doc = \" flag.\"] # [doc = \"\"] # [doc = \" # Current thread runtime\"] # [doc = \"\"] # [doc = \" The default test runtime is single-threaded. Each test gets a\"] # [doc = \" separate current-thread runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ### Using the multi-thread runtime\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Using current thread runtime\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Set number of worker threads\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\", worker_threads = 2)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .worker_threads(2)\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Configure the runtime to start with time paused\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(start_paused = true)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .start_paused(true)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Note that `start_paused` requires the `test-util` feature to be enabled.\"] # [doc = \"\"] # [doc = \" ### Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::test(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Configure unhandled panic behavior\"] # [doc = \"\"] # [doc = \" Available options are `shutdown_runtime` and `ignore`. For more details, see\"] # [doc = \" [`Builder::unhandled_panic`].\"] # [doc = \"\"] # [doc = \" This option is only compatible with the `current_thread` runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::test(flavor = \\\"current_thread\\\", unhandled_panic = \\\"shutdown_runtime\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     let _ = tokio::spawn(async {\"] # [doc = \"         panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"     }).await;\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .unhandled_panic(UnhandledPanic::ShutdownRuntime)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             let _ = tokio::spawn(async {\"] # [doc = \"                 panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"             }).await;\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" **Note**: This option depends on Tokio's [unstable API][unstable]. See [the\"] # [doc = \" documentation on unstable features][unstable] for details on how to enable\"] # [doc = \" Tokio's unstable features.\"] # [doc = \"\"] # [doc = \" [`Builder::unhandled_panic`]: ../tokio/runtime/struct.Builder.html#method.unhandled_panic\"] # [doc = \" [unstable]: ../tokio/index.html#unstable-features\"] # [proc_macro_attribute] pub fn test (args : TokenStream , item : TokenStream) -> TokenStream { entry :: test (args . into () , item . into () , true) . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 12385260807363020784,
      "kind": "Function",
      "name": "test_rt",
      "signature": "fn # [doc = \" Marks async function to be executed by runtime, suitable to test environment\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn test_rt (args : TokenStream , item : TokenStream) -> TokenStream { entry :: test (args . into () , item . into () , false) . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 10168602510014853632,
      "kind": "Function",
      "name": "main_fail",
      "signature": "fn # [doc = \" Always fails with the error message below.\"] # [doc = \" ```text\"] # [doc = \" The #[tokio::main] macro requires rt or rt-multi-thread.\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn main_fail (_args : TokenStream , _item : TokenStream) -> TokenStream { syn :: Error :: new (proc_macro2 :: Span :: call_site () , \"The #[tokio::main] macro requires rt or rt-multi-thread.\" ,) . to_compile_error () . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 12332684797418870744,
      "kind": "Function",
      "name": "test_fail",
      "signature": "fn # [doc = \" Always fails with the error message below.\"] # [doc = \" ```text\"] # [doc = \" The #[tokio::test] macro requires rt or rt-multi-thread.\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn test_fail (_args : TokenStream , _item : TokenStream) -> TokenStream { syn :: Error :: new (proc_macro2 :: Span :: call_site () , \"The #[tokio::test] macro requires rt or rt-multi-thread.\" ,) . to_compile_error () . into () } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 17535546294461575042,
      "kind": "Function",
      "name": "select_priv_declare_output_enum",
      "signature": "fn # [doc = \" Implementation detail of the `select!` macro. This macro is **not** intended\"] # [doc = \" to be used as part of the public API and is permitted to change.\"] # [proc_macro] # [doc (hidden)] pub fn select_priv_declare_output_enum (input : TokenStream) -> TokenStream { select :: declare_output_enum (input) } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 252782349054491927,
      "kind": "Function",
      "name": "select_priv_clean_pattern",
      "signature": "fn # [doc = \" Implementation detail of the `select!` macro. This macro is **not** intended\"] # [doc = \" to be used as part of the public API and is permitted to change.\"] # [proc_macro] # [doc (hidden)] pub fn select_priv_clean_pattern (input : TokenStream) -> TokenStream { select :: clean_pattern_macro (input) } . sig",
      "file_path": "tokio-macros/src/lib.rs",
      "line": 0
    },
    {
      "hash": 9660340985580333012,
      "kind": "Function",
      "name": "declare_output_enum",
      "signature": "fn pub (crate) fn declare_output_enum (input : TokenStream) -> TokenStream { let branches = match input . into_iter () . next () { Some (TokenTree :: Group (group)) => group . stream () . into_iter () . count () , _ => panic ! (\"unexpected macro input\") , } ; let variants = (0 .. branches) . map (| num | Ident :: new (& format ! (\"_{num}\") , Span :: call_site ())) . collect :: < Vec < _ > > () ; let mask = Ident :: new (if branches <= 8 { \"u8\" } else if branches <= 16 { \"u16\" } else if branches <= 32 { \"u32\" } else if branches <= 64 { \"u64\" } else { panic ! (\"up to 64 branches supported\") ; } , Span :: call_site () ,) ; TokenStream :: from (quote ! { pub (super) enum Out <# (# variants) ,*> { # (# variants (# variants) ,) * Disabled , } pub (super) type Mask = # mask ; }) } . sig",
      "file_path": "tokio-macros/src/select.rs",
      "line": 0
    },
    {
      "hash": 3251951374197802075,
      "kind": "Function",
      "name": "clean_pattern_macro",
      "signature": "fn pub (crate) fn clean_pattern_macro (input : TokenStream) -> TokenStream { let mut input : syn :: Pat = match syn :: Pat :: parse_single . parse (input . clone ()) { Ok (it) => it , Err (_) => return input , } ; clean_pattern (& mut input) ; quote :: ToTokens :: into_token_stream (input) . into () } . sig",
      "file_path": "tokio-macros/src/select.rs",
      "line": 0
    },
    {
      "hash": 8386618938863350030,
      "kind": "Function",
      "name": "clean_pattern",
      "signature": "fn fn clean_pattern (pat : & mut syn :: Pat) { match pat { syn :: Pat :: Lit (_literal) => { } syn :: Pat :: Macro (_macro) => { } syn :: Pat :: Path (_path) => { } syn :: Pat :: Range (_range) => { } syn :: Pat :: Rest (_rest) => { } syn :: Pat :: Verbatim (_tokens) => { } syn :: Pat :: Wild (_underscore) => { } syn :: Pat :: Ident (ident) => { ident . by_ref = None ; ident . mutability = None ; if let Some ((_at , pat)) = & mut ident . subpat { clean_pattern (& mut * pat) ; } } syn :: Pat :: Or (or) => { for case in & mut or . cases { clean_pattern (case) ; } } syn :: Pat :: Slice (slice) => { for elem in & mut slice . elems { clean_pattern (elem) ; } } syn :: Pat :: Struct (struct_pat) => { for field in & mut struct_pat . fields { clean_pattern (& mut field . pat) ; } } syn :: Pat :: Tuple (tuple) => { for elem in & mut tuple . elems { clean_pattern (elem) ; } } syn :: Pat :: TupleStruct (tuple) => { for elem in & mut tuple . elems { clean_pattern (elem) ; } } syn :: Pat :: Reference (reference) => { reference . mutability = None ; clean_pattern (& mut reference . pat) ; } syn :: Pat :: Type (type_pat) => { clean_pattern (& mut type_pat . pat) ; } _ => { } } } . sig",
      "file_path": "tokio-macros/src/select.rs",
      "line": 0
    },
    {
      "hash": 1798129191535934692,
      "kind": "Function",
      "name": "pin_box",
      "signature": "fn fn pin_box < T : Stream < Item = U > + 'static , U > (s : T) -> Pin < Box < dyn Stream < Item = U > > > { Box :: pin (s) } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 14601095377683866721,
      "kind": "Struct",
      "name": "Empty",
      "signature": "struct Empty",
      "file_path": "tokio-stream/src/empty.rs",
      "line": 0
    },
    {
      "hash": 7752186740801811835,
      "kind": "Function",
      "name": "empty",
      "signature": "fn # [doc = \" Creates a stream that yields nothing.\"] # [doc = \"\"] # [doc = \" The returned stream is immediately ready and returns `None`. Use\"] # [doc = \" [`stream::pending()`](super::pending()) to obtain a stream that is never\"] # [doc = \" ready.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Basic usage:\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut none = stream::empty::<i32>();\"] # [doc = \"\"] # [doc = \" assert_eq!(None, none.next().await);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub const fn empty < T > () -> Empty < T > { Empty (PhantomData) } . sig",
      "file_path": "tokio-stream/src/empty.rs",
      "line": 0
    },
    {
      "hash": 96831539408885743,
      "kind": "Struct",
      "name": "Iter",
      "signature": "struct Iter",
      "file_path": "tokio-stream/src/iter.rs",
      "line": 0
    },
    {
      "hash": 8377299276896689816,
      "kind": "Function",
      "name": "iter",
      "signature": "fn # [doc = \" Converts an `Iterator` into a `Stream` which is always ready\"] # [doc = \" to yield the next value.\"] # [doc = \"\"] # [doc = \" Iterators in Rust don't express the ability to block, so this adapter\"] # [doc = \" simply always calls `iter.next()` and returns that.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # async fn dox() {\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" let mut stream = stream::iter(vec![17, 19]);\"] # [doc = \"\"] # [doc = \" assert_eq!(stream.next().await, Some(17));\"] # [doc = \" assert_eq!(stream.next().await, Some(19));\"] # [doc = \" assert_eq!(stream.next().await, None);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn iter < I > (i : I) -> Iter < I :: IntoIter > where I : IntoIterator , { Iter { iter : i . into_iter () , yield_amt : 0 , } } . sig",
      "file_path": "tokio-stream/src/iter.rs",
      "line": 0
    },
    {
      "hash": 7537986284241991475,
      "kind": "Struct",
      "name": "Once",
      "signature": "struct Once",
      "file_path": "tokio-stream/src/once.rs",
      "line": 0
    },
    {
      "hash": 17206359381576002677,
      "kind": "Function",
      "name": "once",
      "signature": "fn # [doc = \" Creates a stream that emits an element exactly once.\"] # [doc = \"\"] # [doc = \" The returned stream is immediately ready and emits the provided value once.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" // one is the loneliest number\"] # [doc = \" let mut one = stream::once(1);\"] # [doc = \"\"] # [doc = \" assert_eq!(Some(1), one.next().await);\"] # [doc = \"\"] # [doc = \" // just one, that's all we get\"] # [doc = \" assert_eq!(None, one.next().await);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn once < T > (value : T) -> Once < T > { Once { iter : crate :: iter (Some (value)) , } } . sig",
      "file_path": "tokio-stream/src/once.rs",
      "line": 0
    },
    {
      "hash": 5989812951198768225,
      "kind": "Struct",
      "name": "Pending",
      "signature": "struct Pending",
      "file_path": "tokio-stream/src/pending.rs",
      "line": 0
    },
    {
      "hash": 5024631563576058912,
      "kind": "Function",
      "name": "pending",
      "signature": "fn # [doc = \" Creates a stream that is never ready\"] # [doc = \"\"] # [doc = \" The returned stream is never ready. Attempting to call\"] # [doc = \" [`next()`](crate::StreamExt::next) will never complete. Use\"] # [doc = \" [`stream::empty()`](super::empty()) to obtain a stream that is\"] # [doc = \" immediately empty but returns no values.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Basic usage:\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     let mut never = stream::pending::<i32>();\"] # [doc = \"\"] # [doc = \"     // This will never complete\"] # [doc = \"     never.next().await;\"] # [doc = \"\"] # [doc = \"     unreachable!();\"] # [doc = \" }\"] # [doc = \" ```\"] pub const fn pending < T > () -> Pending < T > { Pending (PhantomData) } . sig",
      "file_path": "tokio-stream/src/pending.rs",
      "line": 0
    },
    {
      "hash": 13981706762999774212,
      "kind": "Trait",
      "name": "StreamExt",
      "signature": "trait StreamExt",
      "file_path": "tokio-stream/src/stream_ext.rs",
      "line": 0
    },
    {
      "hash": 15263895093552405837,
      "kind": "Function",
      "name": "merge_size_hints",
      "signature": "fn # [doc = \" Merge the size hints from two streams.\"] fn merge_size_hints ((left_low , left_high) : (usize , Option < usize >) , (right_low , right_high) : (usize , Option < usize >) ,) -> (usize , Option < usize >) { let low = left_low . saturating_add (right_low) ; let high = match (left_high , right_high) { (Some (h1) , Some (h2)) => h1 . checked_add (h2) , _ => None , } ; (low , high) } . sig",
      "file_path": "tokio-stream/src/stream_ext.rs",
      "line": 0
    },
    {
      "hash": 2725882163391252087,
      "kind": "Struct",
      "name": "StreamMap",
      "signature": "struct StreamMap",
      "file_path": "tokio-stream/src/stream_map.rs",
      "line": 0
    },
    {
      "hash": 16441845326689775105,
      "kind": "Trait",
      "name": "FromStream",
      "signature": "trait FromStream",
      "file_path": "tokio-stream/src/stream_ext/collect.rs",
      "line": 0
    },
    {
      "hash": 14519208564827590194,
      "kind": "Function",
      "name": "poll_next",
      "signature": "fn fn poll_next < T , U > (first : Pin < & mut T > , second : Pin < & mut U > , cx : & mut Context < '_ > ,) -> Poll < Option < T :: Item > > where T : Stream , U : Stream < Item = T :: Item > , { let mut done = true ; match first . poll_next (cx) { Poll :: Ready (Some (val)) => return Poll :: Ready (Some (val)) , Poll :: Ready (None) => { } Poll :: Pending => done = false , } match second . poll_next (cx) { Poll :: Ready (Some (val)) => return Poll :: Ready (Some (val)) , Poll :: Ready (None) => { } Poll :: Pending => done = false , } if done { Poll :: Ready (None) } else { Poll :: Pending } } . sig",
      "file_path": "tokio-stream/src/stream_ext/merge.rs",
      "line": 0
    },
    {
      "hash": 2630300898476670977,
      "kind": "Function",
      "name": "throttle",
      "signature": "fn pub (super) fn throttle < T > (duration : Duration , stream : T) -> Throttle < T > where T : Stream , { Throttle { delay : tokio :: time :: sleep_until (Instant :: now () + duration) , duration , has_delayed : true , stream , } } . sig",
      "file_path": "tokio-stream/src/stream_ext/throttle.rs",
      "line": 0
    },
    {
      "hash": 13851171155067637812,
      "kind": "Function",
      "name": "is_zero",
      "signature": "fn fn is_zero (dur : Duration) -> bool { dur == Duration :: from_millis (0) } . sig",
      "file_path": "tokio-stream/src/stream_ext/throttle.rs",
      "line": 0
    },
    {
      "hash": 16378896784346748444,
      "kind": "Struct",
      "name": "BroadcastStream",
      "signature": "struct BroadcastStream",
      "file_path": "tokio-stream/src/wrappers/broadcast.rs",
      "line": 0
    },
    {
      "hash": 6264381666942977829,
      "kind": "Function",
      "name": "make_future",
      "signature": "fn async fn make_future < T : Clone > (mut rx : Receiver < T >) -> (Result < T , RecvError > , Receiver < T >) { let result = rx . recv () . await ; (result , rx) } . sig",
      "file_path": "tokio-stream/src/wrappers/broadcast.rs",
      "line": 0
    },
    {
      "hash": 12817604522318483808,
      "kind": "Struct",
      "name": "IntervalStream",
      "signature": "struct IntervalStream",
      "file_path": "tokio-stream/src/wrappers/interval.rs",
      "line": 0
    },
    {
      "hash": 15730499669155231013,
      "kind": "Struct",
      "name": "ReceiverStream",
      "signature": "struct ReceiverStream",
      "file_path": "tokio-stream/src/wrappers/mpsc_bounded.rs",
      "line": 0
    },
    {
      "hash": 8281535914251098542,
      "kind": "Struct",
      "name": "UnboundedReceiverStream",
      "signature": "struct UnboundedReceiverStream",
      "file_path": "tokio-stream/src/wrappers/mpsc_unbounded.rs",
      "line": 0
    },
    {
      "hash": 17918225791195414891,
      "kind": "Struct",
      "name": "ReadDirStream",
      "signature": "struct ReadDirStream",
      "file_path": "tokio-stream/src/wrappers/read_dir.rs",
      "line": 0
    },
    {
      "hash": 17378995512955763562,
      "kind": "Struct",
      "name": "SignalStream",
      "signature": "struct SignalStream",
      "file_path": "tokio-stream/src/wrappers/signal_unix.rs",
      "line": 0
    },
    {
      "hash": 9941345767854784784,
      "kind": "Struct",
      "name": "CtrlCStream",
      "signature": "struct CtrlCStream",
      "file_path": "tokio-stream/src/wrappers/signal_windows.rs",
      "line": 0
    },
    {
      "hash": 12508241415013654085,
      "kind": "Struct",
      "name": "CtrlBreakStream",
      "signature": "struct CtrlBreakStream",
      "file_path": "tokio-stream/src/wrappers/signal_windows.rs",
      "line": 0
    },
    {
      "hash": 2945768400722356957,
      "kind": "Struct",
      "name": "TcpListenerStream",
      "signature": "struct TcpListenerStream",
      "file_path": "tokio-stream/src/wrappers/tcp_listener.rs",
      "line": 0
    },
    {
      "hash": 18094523488262464753,
      "kind": "Struct",
      "name": "UnixListenerStream",
      "signature": "struct UnixListenerStream",
      "file_path": "tokio-stream/src/wrappers/unix_listener.rs",
      "line": 0
    },
    {
      "hash": 9554876667601881212,
      "kind": "Struct",
      "name": "WatchStream",
      "signature": "struct WatchStream",
      "file_path": "tokio-stream/src/wrappers/watch.rs",
      "line": 0
    },
    {
      "hash": 8955669123374011482,
      "kind": "Function",
      "name": "make_future",
      "signature": "fn async fn make_future < T : Clone + Send + Sync > (mut rx : Receiver < T > ,) -> (Result < () , RecvError > , Receiver < T >) { let result = rx . changed () . await ; (result , rx) } . sig",
      "file_path": "tokio-stream/src/wrappers/watch.rs",
      "line": 0
    },
    {
      "hash": 9572714093758092069,
      "kind": "Function",
      "name": "usage",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn usage () { let iter = vec ! [1 , 2 , 3] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [4] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (3)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chunks_timeout (4 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; } . sig",
      "file_path": "tokio-stream/tests/chunks_timeout.rs",
      "line": 0
    },
    {
      "hash": 9008059587179896571,
      "kind": "Function",
      "name": "full_chunk_with_timeout",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn full_chunk_with_timeout () { let iter = vec ! [1 , 2] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [3] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (1)) . map (move | _ | n)) ; let iter = vec ! [4] . into_iter () ; let stream2 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (3)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chain (stream2) . chunks_timeout (3 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; } . sig",
      "file_path": "tokio-stream/tests/chunks_timeout.rs",
      "line": 0
    },
    {
      "hash": 16055073875020328461,
      "kind": "Function",
      "name": "real_time",
      "signature": "fn # [tokio :: test] # [ignore] async fn real_time () { let iter = vec ! [1 , 2 , 3 , 4] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [5] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (5)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chunks_timeout (3 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [5])) ; } . sig",
      "file_path": "tokio-stream/tests/chunks_timeout.rs",
      "line": 0
    },
    {
      "hash": 5480684064921147187,
      "kind": "Function",
      "name": "size_hint_stream_open",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_open () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; assert_eq ! (stream . size_hint () , (2 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , None)) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 18215145207315102172,
      "kind": "Function",
      "name": "size_hint_stream_closed",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_closed () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 12517435002466276415,
      "kind": "Function",
      "name": "size_hint_sender_dropped",
      "signature": "fn # [tokio :: test] async fn size_hint_sender_dropped () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; drop (tx) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 12260352414434427731,
      "kind": "Function",
      "name": "size_hint_stream_instantly_closed",
      "signature": "fn # [test] fn size_hint_stream_instantly_closed () { let (_tx , rx) = mpsc :: channel :: < i32 > (4) ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 4167018162977709860,
      "kind": "Function",
      "name": "size_hint_stream_closed_permits_send",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_closed_permits_send () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; let permit1 = tx . reserve () . await . unwrap () ; let permit2 = tx . reserve () . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (1 , Some (3))) ; permit1 . send (2) ; assert_eq ! (stream . size_hint () , (2 , Some (3))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (1))) ; permit2 . send (3) ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 8447599376516152105,
      "kind": "Function",
      "name": "size_hint_stream_closed_permits_drop",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_closed_permits_drop () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; let permit1 = tx . reserve () . await . unwrap () ; let permit2 = tx . reserve () . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (1 , Some (3))) ; drop (permit1) ; assert_eq ! (stream . size_hint () , (1 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (1))) ; drop (permit2) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
      "line": 0
    },
    {
      "hash": 6308101080077843768,
      "kind": "Function",
      "name": "size_hint_stream_open",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_open () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; assert_eq ! (stream . size_hint () , (2 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , None)) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
      "line": 0
    },
    {
      "hash": 9333306922496415519,
      "kind": "Function",
      "name": "size_hint_stream_closed",
      "signature": "fn # [tokio :: test] async fn size_hint_stream_closed () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
      "line": 0
    },
    {
      "hash": 6857626347499432747,
      "kind": "Function",
      "name": "size_hint_sender_dropped",
      "signature": "fn # [tokio :: test] async fn size_hint_sender_dropped () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; drop (tx) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
      "line": 0
    },
    {
      "hash": 18270645733113113321,
      "kind": "Function",
      "name": "size_hint_stream_instantly_closed",
      "signature": "fn # [test] fn size_hint_stream_instantly_closed () { let (_tx , rx) = mpsc :: unbounded_channel :: < i32 > () ; let mut stream = UnboundedReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
      "line": 0
    },
    {
      "hash": 18079127461228446440,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let one = stream :: iter (vec ! [1 , 2 , 3]) ; let two = stream :: iter (vec ! [4 , 5 , 6]) ; let mut stream = visibility_test (one , two) ; assert_eq ! (stream . size_hint () , (6 , Some (6))) ; assert_eq ! (stream . next () . await , Some (1)) ; assert_eq ! (stream . size_hint () , (5 , Some (5))) ; assert_eq ! (stream . next () . await , Some (2)) ; assert_eq ! (stream . size_hint () , (4 , Some (4))) ; assert_eq ! (stream . next () . await , Some (3)) ; assert_eq ! (stream . size_hint () , (3 , Some (3))) ; assert_eq ! (stream . next () . await , Some (4)) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; assert_eq ! (stream . next () . await , Some (5)) ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; assert_eq ! (stream . next () . await , Some (6)) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
      "file_path": "tokio-stream/tests/stream_chain.rs",
      "line": 0
    },
    {
      "hash": 839090338047917144,
      "kind": "Function",
      "name": "visibility_test",
      "signature": "fn fn visibility_test < I , S1 , S2 > (s1 : S1 , s2 : S2) -> Chain < S1 , S2 > where S1 : Stream < Item = I > , S2 : Stream < Item = I > , { s1 . chain (s2) } . sig",
      "file_path": "tokio-stream/tests/stream_chain.rs",
      "line": 0
    },
    {
      "hash": 3230056811031541617,
      "kind": "Function",
      "name": "pending_first",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn pending_first () { let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let mut stream = task :: spawn (rx1 . chain (rx2)) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_pending ! (stream . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (! stream . is_woken ()) ; assert_pending ! (stream . poll_next ()) ; tx1 . send (1) . unwrap () ; assert ! (stream . is_woken ()) ; assert_eq ! (Some (1) , assert_ready ! (stream . poll_next ())) ; assert_pending ! (stream . poll_next ()) ; drop (tx1) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert ! (stream . is_woken ()) ; assert_eq ! (Some (2) , assert_ready ! (stream . poll_next ())) ; assert_eq ! (stream . size_hint () , (0 , None)) ; drop (tx2) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (None , assert_ready ! (stream . poll_next ())) ; } . sig",
      "file_path": "tokio-stream/tests/stream_chain.rs",
      "line": 0
    },
    {
      "hash": 15213858186038884074,
      "kind": "Function",
      "name": "size_overflow",
      "signature": "fn # [test] fn size_overflow () { struct Monster ; impl tokio_stream :: Stream for Monster { type Item = () ; fn poll_next (self : std :: pin :: Pin < & mut Self > , _cx : & mut std :: task :: Context < '_ > ,) -> std :: task :: Poll < Option < () > > { panic ! () } fn size_hint (& self) -> (usize , Option < usize >) { (usize :: MAX , Some (usize :: MAX)) } } let m1 = Monster ; let m2 = Monster ; let m = m1 . chain (m2) ; assert_eq ! (m . size_hint () , (usize :: MAX , None)) ; } . sig",
      "file_path": "tokio-stream/tests/stream_chain.rs",
      "line": 0
    },
    {
      "hash": 11358018739540129245,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = StreamNotifyClose :: new (tokio_stream :: iter (vec ! [0 , 1])) ; assert_eq ! (stream . next () . await , Some (Some (0))) ; assert_eq ! (stream . next () . await , Some (Some (1))) ; assert_eq ! (stream . next () . await , Some (None)) ; assert_eq ! (stream . next () . await , None) ; } . sig",
      "file_path": "tokio-stream/tests/stream_close.rs",
      "line": 0
    },
    {
      "hash": 7557469121166789416,
      "kind": "Function",
      "name": "empty_unit",
      "signature": "fn # [allow (clippy :: let_unit_value)] # [tokio :: test] async fn empty_unit () { let mut iter = vec ! [() , () , ()] . into_iter () ; let _ : () = stream :: iter (& mut iter) . collect () . await ; assert ! (iter . next () . is_none ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 9548864510005790553,
      "kind": "Function",
      "name": "empty_vec",
      "signature": "fn # [tokio :: test] async fn empty_vec () { let coll : Vec < u32 > = stream :: empty () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 1545306849964099786,
      "kind": "Function",
      "name": "empty_box_slice",
      "signature": "fn # [tokio :: test] async fn empty_box_slice () { let coll : Box < [u32] > = stream :: empty () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 8890468893417817794,
      "kind": "Function",
      "name": "empty_string",
      "signature": "fn # [tokio :: test] async fn empty_string () { let coll : String = stream :: empty :: < & str > () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 7209761153138741192,
      "kind": "Function",
      "name": "empty_result",
      "signature": "fn # [tokio :: test] async fn empty_result () { let coll : Result < Vec < u32 > , & str > = stream :: empty () . collect () . await ; assert_eq ! (Ok (vec ! []) , coll) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 12260042022172130322,
      "kind": "Function",
      "name": "collect_vec_items",
      "signature": "fn # [tokio :: test] async fn collect_vec_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Vec < i32 > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (1) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (2) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (vec ! [1 , 2] , coll) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 5926048845351970878,
      "kind": "Function",
      "name": "collect_string_items",
      "signature": "fn # [tokio :: test] async fn collect_string_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < String > ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"hello \" . to_string ()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"world\" . to_string ()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 9025887554055474408,
      "kind": "Function",
      "name": "collect_str_items",
      "signature": "fn # [tokio :: test] async fn collect_str_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < String > ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"hello \") . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"world\") . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 14062998840604700604,
      "kind": "Function",
      "name": "collect_results_ok",
      "signature": "fn # [tokio :: test] async fn collect_results_ok () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Result < String , & str > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"hello \")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"world\")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready_ok ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 748534831674131299,
      "kind": "Function",
      "name": "collect_results_err",
      "signature": "fn # [tokio :: test] async fn collect_results_err () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Result < String , & str > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"hello \")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (Err (\"oh no\")) . unwrap () ; assert ! (fut . is_woken ()) ; let err = assert_ready_err ! (fut . poll ()) ; assert_eq ! (\"oh no\" , err) ; } . sig",
      "file_path": "tokio-stream/tests/stream_collect.rs",
      "line": 0
    },
    {
      "hash": 10026795690280438817,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = stream :: empty :: < i32 > () ; for _ in 0 .. 2 { assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (None , stream . next () . await) ; } } . sig",
      "file_path": "tokio-stream/tests/stream_empty.rs",
      "line": 0
    },
    {
      "hash": 9202904525003713410,
      "kind": "Struct",
      "name": "Alternate",
      "signature": "struct Alternate",
      "file_path": "tokio-stream/tests/stream_fuse.rs",
      "line": 0
    },
    {
      "hash": 2382619524721179839,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = Alternate { state : 0 } ; assert_eq ! (stream . next () . await , Some (0)) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . next () . await , Some (2)) ; assert_eq ! (stream . next () . await , None) ; let mut stream = stream . fuse () ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (stream . next () . await , Some (4)) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_fuse.rs",
      "line": 0
    },
    {
      "hash": 10630030574738217135,
      "kind": "Function",
      "name": "coop",
      "signature": "fn # [tokio :: test] async fn coop () { let mut stream = task :: spawn (stream :: iter (iter :: repeat (1))) ; for _ in 0 .. 10_000 { if stream . poll_next () . is_pending () { assert ! (stream . is_woken ()) ; return ; } } panic ! (\"did not yield\") ; } . sig",
      "file_path": "tokio-stream/tests/stream_iter.rs",
      "line": 0
    },
    {
      "hash": 480618555469043780,
      "kind": "Function",
      "name": "merge_sync_streams",
      "signature": "fn # [tokio :: test] async fn merge_sync_streams () { let mut s = stream :: iter (vec ! [0 , 2 , 4 , 6]) . merge (stream :: iter (vec ! [1 , 3 , 5])) ; for i in 0 .. 7 { let rem = 7 - i ; assert_eq ! (s . size_hint () , (rem , Some (rem))) ; assert_eq ! (Some (i) , s . next () . await) ; } assert ! (s . next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_merge.rs",
      "line": 0
    },
    {
      "hash": 7679876217497685700,
      "kind": "Function",
      "name": "merge_async_streams",
      "signature": "fn # [tokio :: test] async fn merge_async_streams () { let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let mut rx = task :: spawn (rx1 . merge (rx2)) ; assert_eq ! (rx . size_hint () , (0 , None)) ; assert_pending ! (rx . poll_next ()) ; tx1 . send (1) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (1) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (2) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; drop (tx1) ; assert ! (rx . is_woken ()) ; assert_pending ! (rx . poll_next ()) ; tx2 . send (3) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (3) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; drop (tx2) ; assert ! (rx . is_woken ()) ; assert_eq ! (None , assert_ready ! (rx . poll_next ())) ; } . sig",
      "file_path": "tokio-stream/tests/stream_merge.rs",
      "line": 0
    },
    {
      "hash": 8286433593927674679,
      "kind": "Function",
      "name": "size_overflow",
      "signature": "fn # [test] fn size_overflow () { struct Monster ; impl tokio_stream :: Stream for Monster { type Item = () ; fn poll_next (self : std :: pin :: Pin < & mut Self > , _cx : & mut std :: task :: Context < '_ > ,) -> std :: task :: Poll < Option < () > > { panic ! () } fn size_hint (& self) -> (usize , Option < usize >) { (usize :: MAX , Some (usize :: MAX)) } } let m1 = Monster ; let m2 = Monster ; let m = m1 . merge (m2) ; assert_eq ! (m . size_hint () , (usize :: MAX , None)) ; } . sig",
      "file_path": "tokio-stream/tests/stream_merge.rs",
      "line": 0
    },
    {
      "hash": 3052551020315547559,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let mut one = stream :: once (1) ; assert_eq ! (one . size_hint () , (1 , Some (1))) ; assert_eq ! (Some (1) , one . next () . await) ; assert_eq ! (one . size_hint () , (0 , Some (0))) ; assert_eq ! (None , one . next () . await) ; } . sig",
      "file_path": "tokio-stream/tests/stream_once.rs",
      "line": 0
    },
    {
      "hash": 6295456691814020026,
      "kind": "Function",
      "name": "test_panic",
      "signature": "fn fn test_panic < Func : FnOnce () + panic :: UnwindSafe > (func : Func) -> Option < String > { static PANIC_MUTEX : Mutex < () > = const_mutex (()) ; { let _guard = PANIC_MUTEX . lock () ; let panic_file : Arc < Mutex < Option < String > > > = Arc :: new (Mutex :: new (None)) ; let prev_hook = panic :: take_hook () ; { let panic_file = panic_file . clone () ; panic :: set_hook (Box :: new (move | panic_info | { let panic_location = panic_info . location () . unwrap () ; panic_file . lock () . clone_from (& Some (panic_location . file () . to_string ())) ; })) ; } let result = panic :: catch_unwind (func) ; panic :: set_hook (prev_hook) ; if result . is_err () { panic_file . lock () . clone () } else { None } } } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 3595750387766983198,
      "kind": "Function",
      "name": "stream_chunks_timeout_panic_caller",
      "signature": "fn # [test] fn stream_chunks_timeout_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let iter = vec ! [1 , 2 , 3] . into_iter () ; let stream0 = stream :: iter (iter) ; let _chunk_stream = stream0 . chunks_timeout (0 , Duration :: from_secs (2)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-stream/tests/stream_panic.rs",
      "line": 0
    },
    {
      "hash": 14417115443548230575,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = stream :: pending :: < i32 > () ; for _ in 0 .. 2 { assert_eq ! (stream . size_hint () , (0 , None)) ; let mut next = task :: spawn (async { stream . next () . await }) ; assert_pending ! (next . poll ()) ; } } . sig",
      "file_path": "tokio-stream/tests/stream_pending.rs",
      "line": 0
    },
    {
      "hash": 11704455169583817145,
      "kind": "Function",
      "name": "empty",
      "signature": "fn # [tokio :: test] async fn empty () { let mut map = StreamMap :: < & str , stream :: Pending < () > > :: new () ; assert_eq ! (map . len () , 0) ; assert ! (map . is_empty ()) ; assert ! (map . next () . await . is_none ()) ; assert ! (map . next () . await . is_none ()) ; assert ! (map . remove (\"foo\") . is_none ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 5433857280874969226,
      "kind": "Function",
      "name": "single_entry",
      "signature": "fn # [tokio :: test] async fn single_entry () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx , rx) = mpsc :: unbounded_channel_stream () ; let rx = Box :: pin (rx) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"foo\" , rx) . is_none ()) ; assert ! (map . contains_key (\"foo\")) ; assert ! (! map . contains_key (\"bar\")) ; assert_eq ! (map . len () , 1) ; assert ! (! map . is_empty ()) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx . send (1)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 1) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx . send (2)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 2) ; assert_pending ! (map . poll_next ()) ; drop (tx) ; assert ! (map . is_woken ()) ; assert_ready_none ! (map . poll_next ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 9021176374420371794,
      "kind": "Function",
      "name": "multiple_entries",
      "signature": "fn # [tokio :: test] async fn multiple_entries () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let rx1 = Box :: pin (rx1) ; let rx2 = Box :: pin (rx2) ; map . insert (\"foo\" , rx1) ; map . insert (\"bar\" , rx2) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx1 . send (1)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 1) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx2 . send (2)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"bar\") ; assert_eq ! (v , 2) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx1 . send (3)) ; assert_ok ! (tx2 . send (4)) ; assert ! (map . is_woken ()) ; let mut v = (0 .. 2) . map (| _ | assert_ready_some ! (map . poll_next ())) . collect :: < Vec < _ > > () ; assert_pending ! (map . poll_next ()) ; v . sort_unstable () ; assert_eq ! (v [0] . 0 , \"bar\") ; assert_eq ! (v [0] . 1 , 4) ; assert_eq ! (v [1] . 0 , \"foo\") ; assert_eq ! (v [1] . 1 , 3) ; drop (tx1) ; assert ! (map . is_woken ()) ; assert_pending ! (map . poll_next ()) ; drop (tx2) ; assert_ready_none ! (map . poll_next ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 11460514703786235401,
      "kind": "Function",
      "name": "insert_remove",
      "signature": "fn # [tokio :: test] async fn insert_remove () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx , rx) = mpsc :: unbounded_channel_stream () ; let rx = Box :: pin (rx) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"foo\" , rx) . is_none ()) ; let rx = map . remove (\"foo\") . unwrap () ; assert_ok ! (tx . send (1)) ; assert ! (! map . is_woken ()) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"bar\" , rx) . is_none ()) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v . 0 , \"bar\") ; assert_eq ! (v . 1 , 1) ; assert ! (map . remove (\"bar\") . is_some ()) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . is_empty ()) ; assert_eq ! (0 , map . len ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 15579538677204735504,
      "kind": "Function",
      "name": "replace",
      "signature": "fn # [tokio :: test] async fn replace () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let rx1 = Box :: pin (rx1) ; let rx2 = Box :: pin (rx2) ; assert ! (map . insert (\"foo\" , rx1) . is_none ()) ; assert_pending ! (map . poll_next ()) ; let _rx1 = map . insert (\"foo\" , rx2) . unwrap () ; assert_pending ! (map . poll_next ()) ; tx1 . send (1) . unwrap () ; assert_pending ! (map . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (map . is_woken ()) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v . 0 , \"foo\") ; assert_eq ! (v . 1 , 2) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 14535495280003648049,
      "kind": "Function",
      "name": "size_hint_with_upper",
      "signature": "fn # [test] fn size_hint_with_upper () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; assert_eq ! (3 , map . len ()) ; assert ! (! map . is_empty ()) ; let size_hint = map . size_hint () ; assert_eq ! (size_hint , (6 , Some (6))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 17793033751090916809,
      "kind": "Function",
      "name": "size_hint_without_upper",
      "signature": "fn # [test] fn size_hint_without_upper () { let mut map = StreamMap :: new () ; map . insert (\"a\" , pin_box (stream :: iter (vec ! [1]))) ; map . insert (\"b\" , pin_box (stream :: iter (vec ! [1 , 2]))) ; map . insert (\"c\" , pin_box (pending ())) ; let size_hint = map . size_hint () ; assert_eq ! (size_hint , (3 , None)) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 6540252028486332558,
      "kind": "Function",
      "name": "new_capacity_zero",
      "signature": "fn # [test] fn new_capacity_zero () { let map = StreamMap :: < & str , stream :: Pending < () > > :: new () ; assert_eq ! (0 , map . capacity ()) ; assert ! (map . keys () . next () . is_none ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 11812770733054795940,
      "kind": "Function",
      "name": "with_capacity",
      "signature": "fn # [test] fn with_capacity () { let map = StreamMap :: < & str , stream :: Pending < () > > :: with_capacity (10) ; assert ! (10 <= map . capacity ()) ; assert ! (map . keys () . next () . is_none ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 14372590770166932684,
      "kind": "Function",
      "name": "iter_keys",
      "signature": "fn # [test] fn iter_keys () { let mut map = StreamMap :: new () ; map . insert (\"a\" , pending :: < i32 > ()) ; map . insert (\"b\" , pending ()) ; map . insert (\"c\" , pending ()) ; let mut keys = map . keys () . collect :: < Vec < _ > > () ; keys . sort_unstable () ; assert_eq ! (& keys [..] , & [& \"a\" , & \"b\" , & \"c\"]) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 17008670565866660775,
      "kind": "Function",
      "name": "iter_values",
      "signature": "fn # [test] fn iter_values () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; let mut size_hints = map . values () . map (| s | s . size_hint () . 0) . collect :: < Vec < _ > > () ; size_hints . sort_unstable () ; assert_eq ! (& size_hints [..] , & [1 , 2 , 3]) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 1129573001377935014,
      "kind": "Function",
      "name": "iter_values_mut",
      "signature": "fn # [test] fn iter_values_mut () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; let mut size_hints = map . values_mut () . map (| s : & mut _ | s . size_hint () . 0) . collect :: < Vec < _ > > () ; size_hints . sort_unstable () ; assert_eq ! (& size_hints [..] , & [1 , 2 , 3]) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 15683439118512346152,
      "kind": "Function",
      "name": "clear",
      "signature": "fn # [test] fn clear () { let mut map = task :: spawn (StreamMap :: new ()) ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; assert_ready_some ! (map . poll_next ()) ; map . clear () ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . is_empty ()) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 8104362785663594947,
      "kind": "Function",
      "name": "contains_key_borrow",
      "signature": "fn # [test] fn contains_key_borrow () { let mut map = StreamMap :: new () ; map . insert (\"foo\" . to_string () , pending :: < () > ()) ; assert ! (map . contains_key (\"foo\")) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 16999535169249036803,
      "kind": "Function",
      "name": "one_ready_many_none",
      "signature": "fn # [test] fn one_ready_many_none () { for _ in 0 .. 100 { let mut map = task :: spawn (StreamMap :: new ()) ; map . insert (0 , pin_box (stream :: empty ())) ; map . insert (1 , pin_box (stream :: empty ())) ; map . insert (2 , pin_box (stream :: once (\"hello\"))) ; map . insert (3 , pin_box (stream :: pending ())) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v , (2 , \"hello\")) ; } } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 15891498977564035697,
      "kind": "Function",
      "name": "poll_next_many_zero",
      "signature": "fn # [tokio :: test] async fn poll_next_many_zero () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut vec ! [] , 0)) . await ; assert_eq ! (n , 0) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 880101703819715235,
      "kind": "Function",
      "name": "poll_next_many_empty",
      "signature": "fn # [tokio :: test] async fn poll_next_many_empty () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut vec ! [] , 1)) . await ; assert_eq ! (n , 0) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 18175385229985648059,
      "kind": "Function",
      "name": "poll_next_many_pending",
      "signature": "fn # [tokio :: test] async fn poll_next_many_pending () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let mut is_pending = false ; poll_fn (| cx | { let poll = stream_map . poll_next_many (cx , & mut vec ! [] , 1) ; is_pending = poll . is_pending () ; Poll :: Ready (()) }) . await ; assert ! (is_pending) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 17396004440757568178,
      "kind": "Function",
      "name": "poll_next_many_not_enough",
      "signature": "fn # [tokio :: test] async fn poll_next_many_not_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 3)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 6136816749957547658,
      "kind": "Function",
      "name": "poll_next_many_enough",
      "signature": "fn # [tokio :: test] async fn poll_next_many_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 2)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 10596446678457884167,
      "kind": "Function",
      "name": "poll_next_many_correctly_loops_around",
      "signature": "fn # [tokio :: test] async fn poll_next_many_correctly_loops_around () { for _ in 0 .. 10 { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([0usize , 1] . into_iter ())) as UsizeStream) ; stream_map . insert (2 , Box :: pin (iter ([0usize , 1 , 2] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 3)) . await ; assert_eq ! (n , 3) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [0 , 0 , 0]) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 2)) . await ; assert_eq ! (n , 2) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [1 , 1]) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 1)) . await ; assert_eq ! (n , 1) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [2]) ; } } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 2517060165599630306,
      "kind": "Function",
      "name": "next_many_zero",
      "signature": "fn # [tokio :: test] async fn next_many_zero () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut vec ! [] , 0)) . poll (cx)) . await ; assert_eq ! (n , 0) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 751832055228362083,
      "kind": "Function",
      "name": "next_many_empty",
      "signature": "fn # [tokio :: test] async fn next_many_empty () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; let n = stream_map . next_many (& mut vec ! [] , 1) . await ; assert_eq ! (n , 0) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 13830218680935965076,
      "kind": "Function",
      "name": "next_many_pending",
      "signature": "fn # [tokio :: test] async fn next_many_pending () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let mut is_pending = false ; poll_fn (| cx | { let poll = pin ! (stream_map . next_many (& mut vec ! [] , 1)) . poll (cx) ; is_pending = poll . is_pending () ; Poll :: Ready (()) }) . await ; assert ! (is_pending) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 16449004875554932366,
      "kind": "Function",
      "name": "next_many_not_enough",
      "signature": "fn # [tokio :: test] async fn next_many_not_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 3)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 4164010953414184161,
      "kind": "Function",
      "name": "next_many_enough",
      "signature": "fn # [tokio :: test] async fn next_many_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 2)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 8023586049274451807,
      "kind": "Function",
      "name": "next_many_correctly_loops_around",
      "signature": "fn # [tokio :: test] async fn next_many_correctly_loops_around () { for _ in 0 .. 10 { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([0usize , 1] . into_iter ())) as UsizeStream) ; stream_map . insert (2 , Box :: pin (iter ([0usize , 1 , 2] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 3)) . poll (cx)) . await ; assert_eq ! (n , 3) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [0 , 0 , 0]) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 2)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [1 , 1]) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 1)) . poll (cx)) . await ; assert_eq ! (n , 1) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [2]) ; } } . sig",
      "file_path": "tokio-stream/tests/stream_stream_map.rs",
      "line": 0
    },
    {
      "hash": 761767131782090908,
      "kind": "Function",
      "name": "maybe_sleep",
      "signature": "fn async fn maybe_sleep (idx : i32) -> i32 { if idx % 2 == 0 { sleep (ms (200)) . await ; } idx } . sig",
      "file_path": "tokio-stream/tests/stream_timeout.rs",
      "line": 0
    },
    {
      "hash": 9571105106005963055,
      "kind": "Function",
      "name": "basic_usage",
      "signature": "fn # [tokio :: test] async fn basic_usage () { time :: pause () ; let stream = stream :: iter (1 ..= 4) . then (maybe_sleep) . timeout (ms (100)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (150)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (100)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (2))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (60)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (60)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; time :: advance (ms (120)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (4))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
      "file_path": "tokio-stream/tests/stream_timeout.rs",
      "line": 0
    },
    {
      "hash": 3050012793395894389,
      "kind": "Function",
      "name": "return_elapsed_errors_only_once",
      "signature": "fn # [tokio :: test] async fn return_elapsed_errors_only_once () { time :: pause () ; let stream = stream :: iter (1 ..= 3) . then (maybe_sleep) . timeout (ms (50)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (51)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; time :: advance (ms (50)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (100)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (2))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
      "file_path": "tokio-stream/tests/stream_timeout.rs",
      "line": 0
    },
    {
      "hash": 1009953955444704926,
      "kind": "Function",
      "name": "no_timeouts",
      "signature": "fn # [tokio :: test] async fn no_timeouts () { let stream = stream :: iter (vec ! [1 , 3 , 5]) . then (maybe_sleep) . timeout (ms (100)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (5))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
      "file_path": "tokio-stream/tests/stream_timeout.rs",
      "line": 0
    },
    {
      "hash": 15109653990795324632,
      "kind": "Function",
      "name": "usage",
      "signature": "fn # [tokio :: test] async fn usage () { time :: pause () ; let mut stream = task :: spawn (futures :: stream :: repeat (()) . throttle (Duration :: from_millis (100))) ; assert_ready ! (stream . poll_next ()) ; assert_pending ! (stream . poll_next ()) ; time :: advance (Duration :: from_millis (90)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (Duration :: from_millis (101)) . await ; assert ! (stream . is_woken ()) ; assert_ready ! (stream . poll_next ()) ; } . sig",
      "file_path": "tokio-stream/tests/time_throttle.rs",
      "line": 0
    },
    {
      "hash": 8180117421302817113,
      "kind": "Function",
      "name": "watch_stream_message_not_twice",
      "signature": "fn # [tokio :: test] async fn watch_stream_message_not_twice () { let (tx , rx) = watch :: channel (\"hello\") ; let mut counter = 0 ; let mut stream = WatchStream :: new (rx) . map (move | payload | { println ! (\"{payload}\") ; if payload == \"goodbye\" { counter += 1 ; } if counter >= 2 { panic ! (\"too many goodbyes\") ; } }) ; let task = tokio :: spawn (async move { while stream . next () . await . is_some () { } }) ; tx . send (\"goodbye\") . unwrap () ; drop (tx) ; task . await . unwrap () ; } . sig",
      "file_path": "tokio-stream/tests/watch.rs",
      "line": 0
    },
    {
      "hash": 8125978100350975167,
      "kind": "Function",
      "name": "watch_stream_from_rx",
      "signature": "fn # [tokio :: test] async fn watch_stream_from_rx () { let (tx , rx) = watch :: channel (\"hello\") ; let mut stream = WatchStream :: from (rx) ; assert_eq ! (stream . next () . await . unwrap () , \"hello\") ; tx . send (\"bye\") . unwrap () ; assert_eq ! (stream . next () . await . unwrap () , \"bye\") ; } . sig",
      "file_path": "tokio-stream/tests/watch.rs",
      "line": 0
    },
    {
      "hash": 18153476542137711138,
      "kind": "Function",
      "name": "watch_stream_from_changes",
      "signature": "fn # [tokio :: test] async fn watch_stream_from_changes () { let (tx , rx) = watch :: channel (\"hello\") ; let mut stream = WatchStream :: from_changes (rx) ; assert_pending ! (spawn (& mut stream) . poll_next ()) ; tx . send (\"bye\") . unwrap () ; assert_eq ! (stream . next () . await . unwrap () , \"bye\") ; } . sig",
      "file_path": "tokio-stream/tests/watch.rs",
      "line": 0
    },
    {
      "hash": 10619813041966081035,
      "kind": "Function",
      "name": "unbounded_channel_stream",
      "signature": "fn pub fn unbounded_channel_stream < T : Unpin > () -> (UnboundedSender < T > , impl Stream < Item = T >) { let (tx , mut rx) = mpsc :: unbounded_channel () ; let stream = stream ! { while let Some (item) = rx . recv () . await { yield item ; } } ; (tx , stream) } . sig",
      "file_path": "tokio-stream/tests/support/mpsc.rs",
      "line": 0
    },
    {
      "hash": 15628748977489461154,
      "kind": "Struct",
      "name": "Mock",
      "signature": "struct Mock",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 10954232615175509223,
      "kind": "Struct",
      "name": "PanicMsgSnippet",
      "signature": "struct PanicMsgSnippet",
      "file_path": "tokio-test/src/io.rs",
      "line": 0
    },
    {
      "hash": 1770437834743446644,
      "kind": "Function",
      "name": "block_on",
      "signature": "fn # [doc = \" Runs the provided future, blocking the current thread until the\"] # [doc = \" future completes.\"] # [doc = \"\"] # [doc = \" For more information, see the documentation for\"] # [doc = \" [`tokio::runtime::Runtime::block_on`][runtime-block-on].\"] # [doc = \"\"] # [doc = \" [runtime-block-on]: https://docs.rs/tokio/1.3.0/tokio/runtime/struct.Runtime.html#method.block_on\"] pub fn block_on < F : std :: future :: Future > (future : F) -> F :: Output { use tokio :: runtime ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; rt . block_on (future) } . sig",
      "file_path": "tokio-test/src/lib.rs",
      "line": 0
    },
    {
      "hash": 7380487821371987192,
      "kind": "Struct",
      "name": "StreamMockBuilder",
      "signature": "struct StreamMockBuilder",
      "file_path": "tokio-test/src/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 15443903689724768912,
      "kind": "Struct",
      "name": "StreamMock",
      "signature": "struct StreamMock",
      "file_path": "tokio-test/src/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 8183219064159489544,
      "kind": "Function",
      "name": "spawn",
      "signature": "fn # [doc = \" Spawn a future into a [`Spawn`] which wraps the future in a mocked executor.\"] # [doc = \"\"] # [doc = \" This can be used to spawn a [`Future`] or a [`Stream`].\"] # [doc = \"\"] # [doc = \" For more information, check the module docs.\"] pub fn spawn < T > (task : T) -> Spawn < T > { Spawn { task : MockTask :: new () , future : Box :: pin (task) , } } . sig",
      "file_path": "tokio-test/src/task.rs",
      "line": 0
    },
    {
      "hash": 18371542739716806154,
      "kind": "Struct",
      "name": "Spawn",
      "signature": "struct Spawn",
      "file_path": "tokio-test/src/task.rs",
      "line": 0
    },
    {
      "hash": 13614687261076771323,
      "kind": "Struct",
      "name": "MockTask",
      "signature": "struct MockTask",
      "file_path": "tokio-test/src/task.rs",
      "line": 0
    },
    {
      "hash": 1447017396600541179,
      "kind": "Struct",
      "name": "ThreadWaker",
      "signature": "struct ThreadWaker",
      "file_path": "tokio-test/src/task.rs",
      "line": 0
    },
    {
      "hash": 8516114034352641028,
      "kind": "Function",
      "name": "async_block",
      "signature": "fn # [test] fn async_block () { assert_eq ! (4 , block_on (async { 4 })) ; } . sig",
      "file_path": "tokio-test/tests/block_on.rs",
      "line": 0
    },
    {
      "hash": 12625731356812237179,
      "kind": "Function",
      "name": "five",
      "signature": "fn async fn five () -> u8 { 5 } . sig",
      "file_path": "tokio-test/tests/block_on.rs",
      "line": 0
    },
    {
      "hash": 1995949140243344991,
      "kind": "Function",
      "name": "async_fn",
      "signature": "fn # [test] fn async_fn () { assert_eq ! (5 , block_on (five ())) ; } . sig",
      "file_path": "tokio-test/tests/block_on.rs",
      "line": 0
    },
    {
      "hash": 16603982288069105945,
      "kind": "Function",
      "name": "test_sleep",
      "signature": "fn # [test] fn test_sleep () { let deadline = Instant :: now () + Duration :: from_millis (100) ; block_on (async { sleep_until (deadline) . await ; }) ; } . sig",
      "file_path": "tokio-test/tests/block_on.rs",
      "line": 0
    },
    {
      "hash": 9872484755468632947,
      "kind": "Function",
      "name": "read",
      "signature": "fn # [tokio :: test] async fn read () { let mut mock = Builder :: new () . read (b\"hello \") . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 1212996238751848717,
      "kind": "Function",
      "name": "read_error",
      "signature": "fn # [tokio :: test] async fn read_error () { let error = io :: Error :: new (io :: ErrorKind :: Other , \"cruel\") ; let mut mock = Builder :: new () . read (b\"hello \") . read_error (error) . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; match mock . read (& mut buf) . await { Err (error) => { assert_eq ! (error . kind () , io :: ErrorKind :: Other) ; assert_eq ! (\"cruel\" , format ! (\"{error}\")) ; } Ok (_) => panic ! (\"error not received\") , } let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 11804788367884360399,
      "kind": "Function",
      "name": "write",
      "signature": "fn # [tokio :: test] async fn write () { let mut mock = Builder :: new () . write (b\"hello \") . write (b\"world!\") . build () ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 3728533387515536401,
      "kind": "Function",
      "name": "write_with_handle",
      "signature": "fn # [tokio :: test] async fn write_with_handle () { let (mut mock , mut handle) = Builder :: new () . build_with_handle () ; handle . write (b\"hello \") ; handle . write (b\"world!\") ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 4752837519643504404,
      "kind": "Function",
      "name": "read_with_handle",
      "signature": "fn # [tokio :: test] async fn read_with_handle () { let (mut mock , mut handle) = Builder :: new () . build_with_handle () ; handle . read (b\"hello \") ; handle . read (b\"world!\") ; let mut buf = vec ! [0 ; 6] ; mock . read_exact (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [..] , b\"hello \") ; mock . read_exact (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [..] , b\"world!\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 13652862144743177409,
      "kind": "Function",
      "name": "write_error",
      "signature": "fn # [tokio :: test] async fn write_error () { let error = io :: Error :: new (io :: ErrorKind :: Other , \"cruel\") ; let mut mock = Builder :: new () . write (b\"hello \") . write_error (error) . write (b\"world!\") . build () ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; match mock . write_all (b\"whoa\") . await { Err (error) => { assert_eq ! (error . kind () , io :: ErrorKind :: Other) ; assert_eq ! (\"cruel\" , format ! (\"{error}\")) ; } Ok (_) => panic ! (\"error not received\") , } mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 11409456936713427870,
      "kind": "Function",
      "name": "mock_panics_read_data_left",
      "signature": "fn # [tokio :: test] # [should_panic] async fn mock_panics_read_data_left () { use tokio_test :: io :: Builder ; Builder :: new () . read (b\"read\") . build () ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 6500240785949758036,
      "kind": "Function",
      "name": "mock_panics_write_data_left",
      "signature": "fn # [tokio :: test] # [should_panic] async fn mock_panics_write_data_left () { use tokio_test :: io :: Builder ; Builder :: new () . write (b\"write\") . build () ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 16757590780248185068,
      "kind": "Function",
      "name": "wait",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn wait () { const FIRST_WAIT : Duration = Duration :: from_secs (1) ; let mut mock = Builder :: new () . wait (FIRST_WAIT) . read (b\"hello \") . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let start = Instant :: now () ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; println ! (\"time elapsed after first read {:?}\" , start . elapsed ()) ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; println ! (\"time elapsed after second read {:?}\" , start . elapsed ()) ; assert ! (start . elapsed () >= FIRST_WAIT , \"consuming the whole mock only took {}ms\" , start . elapsed () . as_millis ()) ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 18039463455499982262,
      "kind": "Function",
      "name": "multiple_wait",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn multiple_wait () { const FIRST_WAIT : Duration = Duration :: from_secs (1) ; const SECOND_WAIT : Duration = Duration :: from_secs (1) ; let mut mock = Builder :: new () . wait (FIRST_WAIT) . read (b\"hello \") . wait (SECOND_WAIT) . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let start = Instant :: now () ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; println ! (\"time elapsed after first read {:?}\" , start . elapsed ()) ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; println ! (\"time elapsed after second read {:?}\" , start . elapsed ()) ; assert ! (start . elapsed () >= FIRST_WAIT + SECOND_WAIT , \"consuming the whole mock only took {}ms\" , start . elapsed () . as_millis ()) ; } . sig",
      "file_path": "tokio-test/tests/io.rs",
      "line": 0
    },
    {
      "hash": 5733020531281912706,
      "kind": "Function",
      "name": "ready",
      "signature": "fn fn ready () -> Poll < () > { Poll :: Ready (()) } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 8449991898786961603,
      "kind": "Function",
      "name": "ready_ok",
      "signature": "fn fn ready_ok () -> Poll < Result < () , () > > { Poll :: Ready (Ok (())) } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 15539787299854411402,
      "kind": "Function",
      "name": "ready_err",
      "signature": "fn fn ready_err () -> Poll < Result < () , () > > { Poll :: Ready (Err (())) } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 8375369763518420555,
      "kind": "Function",
      "name": "pending",
      "signature": "fn fn pending () -> Poll < () > { Poll :: Pending } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 8864645533007578896,
      "kind": "Function",
      "name": "assert_ready",
      "signature": "fn # [test] fn assert_ready () { let poll = ready () ; assert_ready ! (poll) ; assert_ready ! (poll , \"some message\") ; assert_ready ! (poll , \"{:?}\" , ()) ; assert_ready ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 17465524711112509670,
      "kind": "Function",
      "name": "assert_ready_on_pending",
      "signature": "fn # [test] # [should_panic] fn assert_ready_on_pending () { let poll = pending () ; assert_ready ! (poll) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 7512589578564031912,
      "kind": "Function",
      "name": "assert_pending",
      "signature": "fn # [test] fn assert_pending () { let poll = pending () ; assert_pending ! (poll) ; assert_pending ! (poll , \"some message\") ; assert_pending ! (poll , \"{:?}\" , ()) ; assert_pending ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 15114755711212665691,
      "kind": "Function",
      "name": "assert_pending_on_ready",
      "signature": "fn # [test] # [should_panic] fn assert_pending_on_ready () { let poll = ready () ; assert_pending ! (poll) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 14233681465997105374,
      "kind": "Function",
      "name": "assert_ready_ok",
      "signature": "fn # [test] fn assert_ready_ok () { let poll = ready_ok () ; assert_ready_ok ! (poll) ; assert_ready_ok ! (poll , \"some message\") ; assert_ready_ok ! (poll , \"{:?}\" , ()) ; assert_ready_ok ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 18396851426553908566,
      "kind": "Function",
      "name": "assert_ok_on_err",
      "signature": "fn # [test] # [should_panic] fn assert_ok_on_err () { let poll = ready_err () ; assert_ready_ok ! (poll) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 13308807590390078914,
      "kind": "Function",
      "name": "assert_ready_err",
      "signature": "fn # [test] fn assert_ready_err () { let poll = ready_err () ; assert_ready_err ! (poll) ; assert_ready_err ! (poll , \"some message\") ; assert_ready_err ! (poll , \"{:?}\" , ()) ; assert_ready_err ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 5245796582676766244,
      "kind": "Function",
      "name": "assert_err_on_ok",
      "signature": "fn # [test] # [should_panic] fn assert_err_on_ok () { let poll = ready_ok () ; assert_ready_err ! (poll) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 8553607882631685027,
      "kind": "Function",
      "name": "assert_ready_eq",
      "signature": "fn # [test] fn assert_ready_eq () { let poll = ready () ; assert_ready_eq ! (poll , ()) ; assert_ready_eq ! (poll , () , \"some message\") ; assert_ready_eq ! (poll , () , \"{:?}\" , ()) ; assert_ready_eq ! (poll , () , \"{:?}\" , Test :: Data) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 10793255842870424362,
      "kind": "Function",
      "name": "assert_eq_on_not_eq",
      "signature": "fn # [test] # [should_panic] fn assert_eq_on_not_eq () { let poll = ready_err () ; assert_ready_eq ! (poll , Ok (())) ; } . sig",
      "file_path": "tokio-test/tests/macros.rs",
      "line": 0
    },
    {
      "hash": 1013493183104057256,
      "kind": "Function",
      "name": "test_stream_mock_empty",
      "signature": "fn # [tokio :: test] async fn test_stream_mock_empty () { let mut stream_mock = StreamMockBuilder :: < u32 > :: new () . build () ; assert_eq ! (stream_mock . next () . await , None) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
      "file_path": "tokio-test/tests/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 1616047486512883293,
      "kind": "Function",
      "name": "test_stream_mock_items",
      "signature": "fn # [tokio :: test] async fn test_stream_mock_items () { let mut stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; assert_eq ! (stream_mock . next () . await , Some (1)) ; assert_eq ! (stream_mock . next () . await , Some (2)) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
      "file_path": "tokio-test/tests/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 11115238063266370008,
      "kind": "Function",
      "name": "test_stream_mock_wait",
      "signature": "fn # [tokio :: test] async fn test_stream_mock_wait () { let mut stream_mock = StreamMockBuilder :: new () . next (1) . wait (Duration :: from_millis (300)) . next (2) . build () ; assert_eq ! (stream_mock . next () . await , Some (1)) ; let start = std :: time :: Instant :: now () ; assert_eq ! (stream_mock . next () . await , Some (2)) ; let elapsed = start . elapsed () ; assert ! (elapsed >= Duration :: from_millis (300)) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
      "file_path": "tokio-test/tests/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 10943448780784587554,
      "kind": "Function",
      "name": "test_stream_mock_drop_without_consuming_all",
      "signature": "fn # [tokio :: test] # [should_panic (expected = \"StreamMock was dropped before all actions were consumed\")] async fn test_stream_mock_drop_without_consuming_all () { let stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; drop (stream_mock) ; } . sig",
      "file_path": "tokio-test/tests/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 8900503775089562412,
      "kind": "Function",
      "name": "test_stream_mock_drop_during_panic_doesnt_mask_panic",
      "signature": "fn # [tokio :: test] # [should_panic (expected = \"test panic was not masked\")] async fn test_stream_mock_drop_during_panic_doesnt_mask_panic () { let _stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; panic ! (\"test panic was not masked\") ; } . sig",
      "file_path": "tokio-test/tests/stream_mock.rs",
      "line": 0
    },
    {
      "hash": 12062548693303374314,
      "kind": "Struct",
      "name": "SizedStream",
      "signature": "struct SizedStream",
      "file_path": "tokio-test/tests/task.rs",
      "line": 0
    },
    {
      "hash": 12965752945876355885,
      "kind": "Function",
      "name": "test_spawn_stream_size_hint",
      "signature": "fn # [test] fn test_spawn_stream_size_hint () { let spawn = task :: spawn (SizedStream) ; assert_eq ! (spawn . size_hint () , (100 , Some (200))) ; } . sig",
      "file_path": "tokio-test/tests/task.rs",
      "line": 0
    },
    {
      "hash": 53238793406063748,
      "kind": "Trait",
      "name": "FuturesAsyncReadCompatExt",
      "signature": "trait FuturesAsyncReadCompatExt",
      "file_path": "tokio-util/src/compat.rs",
      "line": 0
    },
    {
      "hash": 9356664185249883752,
      "kind": "Trait",
      "name": "FuturesAsyncWriteCompatExt",
      "signature": "trait FuturesAsyncWriteCompatExt",
      "file_path": "tokio-util/src/compat.rs",
      "line": 0
    },
    {
      "hash": 6786822151389328567,
      "kind": "Trait",
      "name": "TokioAsyncReadCompatExt",
      "signature": "trait TokioAsyncReadCompatExt",
      "file_path": "tokio-util/src/compat.rs",
      "line": 0
    },
    {
      "hash": 7479719922354955174,
      "kind": "Trait",
      "name": "TokioAsyncWriteCompatExt",
      "signature": "trait TokioAsyncWriteCompatExt",
      "file_path": "tokio-util/src/compat.rs",
      "line": 0
    },
    {
      "hash": 4583662498733049657,
      "kind": "Trait",
      "name": "RuntimeExt",
      "signature": "trait RuntimeExt",
      "file_path": "tokio-util/src/context.rs",
      "line": 0
    },
    {
      "hash": 8530516191303919582,
      "kind": "Trait",
      "name": "FutureExt",
      "signature": "trait FutureExt",
      "file_path": "tokio-util/src/future.rs",
      "line": 0
    },
    {
      "hash": 1208582932336799690,
      "kind": "Struct",
      "name": "AnyDelimiterCodec",
      "signature": "struct AnyDelimiterCodec",
      "file_path": "tokio-util/src/codec/any_delimiter_codec.rs",
      "line": 0
    },
    {
      "hash": 2547066757857937064,
      "kind": "Struct",
      "name": "BytesCodec",
      "signature": "struct BytesCodec",
      "file_path": "tokio-util/src/codec/bytes_codec.rs",
      "line": 0
    },
    {
      "hash": 9269026320751321410,
      "kind": "Trait",
      "name": "Decoder",
      "signature": "trait Decoder",
      "file_path": "tokio-util/src/codec/decoder.rs",
      "line": 0
    },
    {
      "hash": 14015416951282084374,
      "kind": "Trait",
      "name": "Encoder",
      "signature": "trait Encoder",
      "file_path": "tokio-util/src/codec/encoder.rs",
      "line": 0
    },
    {
      "hash": 17215661940608474401,
      "kind": "Struct",
      "name": "FramedParts",
      "signature": "struct FramedParts",
      "file_path": "tokio-util/src/codec/framed.rs",
      "line": 0
    },
    {
      "hash": 14925558845952402966,
      "kind": "Struct",
      "name": "ReadFrame",
      "signature": "struct ReadFrame",
      "file_path": "tokio-util/src/codec/framed_impl.rs",
      "line": 0
    },
    {
      "hash": 16668367953432929211,
      "kind": "Struct",
      "name": "WriteFrame",
      "signature": "struct WriteFrame",
      "file_path": "tokio-util/src/codec/framed_impl.rs",
      "line": 0
    },
    {
      "hash": 18133735254673652935,
      "kind": "Struct",
      "name": "RWFrames",
      "signature": "struct RWFrames",
      "file_path": "tokio-util/src/codec/framed_impl.rs",
      "line": 0
    },
    {
      "hash": 7809183884163288865,
      "kind": "Struct",
      "name": "LengthDelimitedCodecError",
      "signature": "struct LengthDelimitedCodecError",
      "file_path": "tokio-util/src/codec/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 6249419574316670895,
      "kind": "Struct",
      "name": "LengthDelimitedCodec",
      "signature": "struct LengthDelimitedCodec",
      "file_path": "tokio-util/src/codec/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 13473786022893396677,
      "kind": "Struct",
      "name": "LinesCodec",
      "signature": "struct LinesCodec",
      "file_path": "tokio-util/src/codec/lines_codec.rs",
      "line": 0
    },
    {
      "hash": 9544927874635750552,
      "kind": "Function",
      "name": "utf8",
      "signature": "fn fn utf8 (buf : & [u8]) -> Result < & str , io :: Error > { str :: from_utf8 (buf) . map_err (| _ | io :: Error :: new (io :: ErrorKind :: InvalidData , \"Unable to decode input as UTF8\")) } . sig",
      "file_path": "tokio-util/src/codec/lines_codec.rs",
      "line": 0
    },
    {
      "hash": 8709266107927357376,
      "kind": "Function",
      "name": "without_carriage_return",
      "signature": "fn fn without_carriage_return (s : & [u8]) -> & [u8] { if let Some (& b'\\r') = s . last () { & s [.. s . len () - 1] } else { s } } . sig",
      "file_path": "tokio-util/src/codec/lines_codec.rs",
      "line": 0
    },
    {
      "hash": 5050740604761904131,
      "kind": "Function",
      "name": "read_exact_arc",
      "signature": "fn # [doc = \" Read data from an `AsyncRead` into an `Arc`.\"] # [doc = \"\"] # [doc = \" This uses `Arc::new_uninit_slice` and reads into the resulting uninitialized `Arc`.\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \" use tokio_util::io::read_exact_arc;\"] # [doc = \"\"] # [doc = \" let read = tokio::io::repeat(42);\"] # [doc = \"\"] # [doc = \" let arc = read_exact_arc(read, 4).await?;\"] # [doc = \"\"] # [doc = \" assert_eq!(&arc[..], &[42; 4]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_exact_arc < R : AsyncRead > (read : R , len : usize) -> io :: Result < Arc < [u8] > > { tokio :: pin ! (read) ; let arc : Arc < [MaybeUninit < u8 >] > = (0 .. len) . map (| _ | MaybeUninit :: uninit ()) . collect () ; let mut buf = unsafe { & mut * (Arc :: as_ptr (& arc) as * mut [MaybeUninit < u8 >]) } ; while ! buf . is_empty () { if read . read_buf (& mut buf) . await ? == 0 { return Err (io :: Error :: new (io :: ErrorKind :: UnexpectedEof , \"early eof\")) ; } } Ok (unsafe { Arc :: from_raw (Arc :: into_raw (arc) as * const [u8]) }) } . sig",
      "file_path": "tokio-util/src/io/read_arc.rs",
      "line": 0
    },
    {
      "hash": 4936080736610531,
      "kind": "Function",
      "name": "read_buf",
      "signature": "fn # [doc = \" Read data from an `AsyncRead` into an implementer of the [`BufMut`] trait.\"] # [doc = \"\"] # [doc = \" [`BufMut`]: bytes::BufMut\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use bytes::{Bytes, BytesMut};\"] # [doc = \" use tokio_stream as stream;\"] # [doc = \" use tokio::io::Result;\"] # [doc = \" use tokio_util::io::{StreamReader, read_buf};\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \"\"] # [doc = \" // Create a reader from an iterator. This particular reader will always be\"] # [doc = \" // ready.\"] # [doc = \" let mut read = StreamReader::new(stream::iter(vec![Result::Ok(Bytes::from_static(&[0, 1, 2, 3]))]));\"] # [doc = \"\"] # [doc = \" let mut buf = BytesMut::new();\"] # [doc = \" let mut reads = 0;\"] # [doc = \"\"] # [doc = \" loop {\"] # [doc = \"     reads += 1;\"] # [doc = \"     let n = read_buf(&mut read, &mut buf).await?;\"] # [doc = \"\"] # [doc = \"     if n == 0 {\"] # [doc = \"         break;\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" // one or more reads might be necessary.\"] # [doc = \" assert!(reads >= 1);\"] # [doc = \" assert_eq!(&buf[..], &[0, 1, 2, 3]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_buf < R , B > (read : & mut R , buf : & mut B) -> io :: Result < usize > where R : AsyncRead + Unpin , B : BufMut , { return ReadBufFn (read , buf) . await ; struct ReadBufFn < 'a , R , B > (& 'a mut R , & 'a mut B) ; impl < 'a , R , B > Future for ReadBufFn < 'a , R , B > where R : AsyncRead + Unpin , B : BufMut , { type Output = io :: Result < usize > ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < Self :: Output > { let this = & mut * self ; crate :: util :: poll_read_buf (Pin :: new (this . 0) , cx , this . 1) } } } . sig",
      "file_path": "tokio-util/src/io/read_buf.rs",
      "line": 0
    },
    {
      "hash": 3396465101607277233,
      "kind": "Struct",
      "name": "StreamReader",
      "signature": "struct StreamReader",
      "file_path": "tokio-util/src/io/stream_reader.rs",
      "line": 0
    },
    {
      "hash": 2813041720278134311,
      "kind": "Struct",
      "name": "StreamReaderProject",
      "signature": "struct StreamReaderProject",
      "file_path": "tokio-util/src/io/stream_reader.rs",
      "line": 0
    },
    {
      "hash": 16034555387851045798,
      "kind": "Struct",
      "name": "SyncIoBridge",
      "signature": "struct SyncIoBridge",
      "file_path": "tokio-util/src/io/sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 18234956118423095191,
      "kind": "Trait",
      "name": "Listener",
      "signature": "trait Listener",
      "file_path": "tokio-util/src/net/mod.rs",
      "line": 0
    },
    {
      "hash": 15221952246756388111,
      "kind": "Struct",
      "name": "ListenerAcceptFut",
      "signature": "struct ListenerAcceptFut",
      "file_path": "tokio-util/src/net/mod.rs",
      "line": 0
    },
    {
      "hash": 8005424640642892308,
      "kind": "Struct",
      "name": "CancellationToken",
      "signature": "struct CancellationToken",
      "file_path": "tokio-util/src/sync/cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 7709800308507547629,
      "kind": "Struct",
      "name": "PollSendError",
      "signature": "struct PollSendError",
      "file_path": "tokio-util/src/sync/mpsc.rs",
      "line": 0
    },
    {
      "hash": 15742827294949741363,
      "kind": "Struct",
      "name": "PollSender",
      "signature": "struct PollSender",
      "file_path": "tokio-util/src/sync/mpsc.rs",
      "line": 0
    },
    {
      "hash": 8490927106010341968,
      "kind": "Function",
      "name": "make_acquire_future",
      "signature": "fn async fn make_acquire_future < T > (data : Option < Sender < T > > ,) -> Result < OwnedPermit < T > , PollSendError < T > > { match data { Some (sender) => sender . reserve_owned () . await . map_err (| _ | PollSendError (None)) , None => unreachable ! (\"this future should not be pollable in this state\") , } } . sig",
      "file_path": "tokio-util/src/sync/mpsc.rs",
      "line": 0
    },
    {
      "hash": 11361646283516337779,
      "kind": "Struct",
      "name": "PollSenderFuture",
      "signature": "struct PollSenderFuture",
      "file_path": "tokio-util/src/sync/mpsc.rs",
      "line": 0
    },
    {
      "hash": 13087630456052061735,
      "kind": "Struct",
      "name": "PollSemaphore",
      "signature": "struct PollSemaphore",
      "file_path": "tokio-util/src/sync/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 12262563105588015507,
      "kind": "Function",
      "name": "reuse_pin_box",
      "signature": "fn fn reuse_pin_box < T : ? Sized , U , O , F > (boxed : Pin < Box < T > > , new_value : U , callback : F) -> Result < O , U > where F : FnOnce (Box < U >) -> O , { let layout = Layout :: for_value :: < T > (& * boxed) ; if layout != Layout :: new :: < U > () { return Err (new_value) ; } let raw : * mut T = Box :: into_raw (unsafe { Pin :: into_inner_unchecked (boxed) }) ; let guard = CallOnDrop :: new (| | { let raw : * mut U = raw . cast :: < U > () ; unsafe { raw . write (new_value) } ; let boxed = unsafe { Box :: from_raw (raw) } ; callback (boxed) }) ; unsafe { ptr :: drop_in_place (raw) } ; Ok (guard . call ()) } . sig",
      "file_path": "tokio-util/src/sync/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 15691100392959217226,
      "kind": "Struct",
      "name": "CallOnDrop",
      "signature": "struct CallOnDrop",
      "file_path": "tokio-util/src/sync/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 4892242074305168175,
      "kind": "Struct",
      "name": "DropGuard",
      "signature": "struct DropGuard",
      "file_path": "tokio-util/src/sync/cancellation_token/guard.rs",
      "line": 0
    },
    {
      "hash": 15088173675318148975,
      "kind": "Struct",
      "name": "DropGuardRef",
      "signature": "struct DropGuardRef",
      "file_path": "tokio-util/src/sync/cancellation_token/guard_ref.rs",
      "line": 0
    },
    {
      "hash": 10719386184554660148,
      "kind": "Struct",
      "name": "TreeNode",
      "signature": "struct TreeNode",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 2874712867789823522,
      "kind": "Function",
      "name": "is_cancelled",
      "signature": "fn # [doc = \" Returns whether or not the node is cancelled\"] pub (crate) fn is_cancelled (node : & Arc < TreeNode >) -> bool { node . inner . lock () . unwrap () . is_cancelled } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 12086721811697063942,
      "kind": "Function",
      "name": "child_node",
      "signature": "fn # [doc = \" Creates a child node\"] pub (crate) fn child_node (parent : & Arc < TreeNode >) -> Arc < TreeNode > { let mut locked_parent = parent . inner . lock () . unwrap () ; if locked_parent . is_cancelled { return Arc :: new (TreeNode { inner : Mutex :: new (Inner { parent : None , parent_idx : 0 , children : vec ! [] , is_cancelled : true , num_handles : 1 , }) , waker : tokio :: sync :: Notify :: new () , }) ; } let child = Arc :: new (TreeNode { inner : Mutex :: new (Inner { parent : Some (parent . clone ()) , parent_idx : locked_parent . children . len () , children : vec ! [] , is_cancelled : false , num_handles : 1 , }) , waker : tokio :: sync :: Notify :: new () , }) ; locked_parent . children . push (child . clone ()) ; child } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 11607924431884572257,
      "kind": "Function",
      "name": "disconnect_children",
      "signature": "fn # [doc = \" Disconnects the given parent from all of its children.\"] # [doc = \"\"] # [doc = \" Takes a reference to [Inner] to make sure the parent is already locked.\"] fn disconnect_children (node : & mut Inner) { for child in std :: mem :: take (& mut node . children) { let mut locked_child = child . inner . lock () . unwrap () ; locked_child . parent_idx = 0 ; locked_child . parent = None ; } } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 18140988982963472159,
      "kind": "Function",
      "name": "with_locked_node_and_parent",
      "signature": "fn # [doc = \" Figures out the parent of the node and locks the node and its parent atomically.\"] # [doc = \"\"] # [doc = \" The basic principle of preventing deadlocks in the tree is\"] # [doc = \" that we always lock the parent first, and then the child.\"] # [doc = \" For more info look at *deadlock safety* and *invariant #2*.\"] # [doc = \"\"] # [doc = \" Sadly, it's impossible to figure out the parent of a node without\"] # [doc = \" locking it. To then achieve locking order consistency, the node\"] # [doc = \" has to be unlocked before the parent gets locked.\"] # [doc = \" This leaves a small window where we already assume that we know the parent,\"] # [doc = \" but neither the parent nor the node is locked. Therefore, the parent could change.\"] # [doc = \"\"] # [doc = \" To prevent that this problem leaks into the rest of the code, it is abstracted\"] # [doc = \" in this function.\"] # [doc = \"\"] # [doc = \" The locked child and optionally its locked parent, if a parent exists, get passed\"] # [doc = \" to the `func` argument via (node, None) or (node, Some(parent)).\"] fn with_locked_node_and_parent < F , Ret > (node : & Arc < TreeNode > , func : F) -> Ret where F : FnOnce (MutexGuard < '_ , Inner > , Option < MutexGuard < '_ , Inner > >) -> Ret , { use std :: sync :: TryLockError ; let mut locked_node = node . inner . lock () . unwrap () ; loop { let potential_parent = match locked_node . parent . as_ref () { Some (potential_parent) => potential_parent . clone () , None => return func (locked_node , None) , } ; let locked_parent = match potential_parent . inner . try_lock () { Ok (locked_parent) => locked_parent , Err (TryLockError :: WouldBlock) => { drop (locked_node) ; let locked_parent = potential_parent . inner . lock () . unwrap () ; locked_node = node . inner . lock () . unwrap () ; locked_parent } # [allow (clippy :: unnecessary_literal_unwrap)] Err (TryLockError :: Poisoned (err)) => Err (err) . unwrap () , } ; if let Some (actual_parent) = locked_node . parent . as_ref () { if Arc :: ptr_eq (actual_parent , & potential_parent) { return func (locked_node , Some (locked_parent)) ; } } } } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 4179823459050386992,
      "kind": "Function",
      "name": "move_children_to_parent",
      "signature": "fn # [doc = \" Moves all children from `node` to `parent`.\"] # [doc = \"\"] # [doc = \" `parent` MUST have been a parent of the node when they both got locked,\"] # [doc = \" otherwise there is a potential for a deadlock as invariant #2 would be violated.\"] # [doc = \"\"] # [doc = \" To acquire the locks for node and parent, use [`with_locked_node_and_parent`].\"] fn move_children_to_parent (node : & mut Inner , parent : & mut Inner) { parent . children . reserve (node . children . len ()) ; for child in std :: mem :: take (& mut node . children) { { let mut child_locked = child . inner . lock () . unwrap () ; child_locked . parent . clone_from (& node . parent) ; child_locked . parent_idx = parent . children . len () ; } parent . children . push (child) ; } } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 1452212815987128762,
      "kind": "Function",
      "name": "remove_child",
      "signature": "fn # [doc = \" Removes a child from the parent.\"] # [doc = \"\"] # [doc = \" `parent` MUST be the parent of `node`.\"] # [doc = \" To acquire the locks for node and parent, use [`with_locked_node_and_parent`].\"] fn remove_child (parent : & mut Inner , mut node : MutexGuard < '_ , Inner >) { let pos = node . parent_idx ; node . parent = None ; node . parent_idx = 0 ; drop (node) ; if parent . children . len () == pos + 1 { parent . children . pop () . unwrap () ; } else { let replacement_child = parent . children . pop () . unwrap () ; replacement_child . inner . lock () . unwrap () . parent_idx = pos ; parent . children [pos] = replacement_child ; } let len = parent . children . len () ; if 4 * len <= parent . children . capacity () { parent . children . shrink_to (2 * len) ; } } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 9172598687327472823,
      "kind": "Function",
      "name": "increase_handle_refcount",
      "signature": "fn # [doc = \" Increases the reference count of handles.\"] pub (crate) fn increase_handle_refcount (node : & Arc < TreeNode >) { let mut locked_node = node . inner . lock () . unwrap () ; assert ! (locked_node . num_handles > 0) ; locked_node . num_handles += 1 ; } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 2397359361360616579,
      "kind": "Function",
      "name": "decrease_handle_refcount",
      "signature": "fn # [doc = \" Decreases the reference count of handles.\"] # [doc = \"\"] # [doc = \" Once no handle is left, we can remove the node from the\"] # [doc = \" tree and connect its parent directly to its children.\"] pub (crate) fn decrease_handle_refcount (node : & Arc < TreeNode >) { let num_handles = { let mut locked_node = node . inner . lock () . unwrap () ; locked_node . num_handles -= 1 ; locked_node . num_handles } ; if num_handles == 0 { with_locked_node_and_parent (node , | mut node , parent | { match parent { Some (mut parent) => { move_children_to_parent (& mut node , & mut parent) ; remove_child (& mut parent , node) ; } None => { disconnect_children (& mut node) ; } } }) ; } } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 5716131504218789068,
      "kind": "Function",
      "name": "cancel",
      "signature": "fn # [doc = \" Cancels a node and its children.\"] pub (crate) fn cancel (node : & Arc < TreeNode >) { let mut locked_node = node . inner . lock () . unwrap () ; if locked_node . is_cancelled { return ; } while let Some (child) = locked_node . children . pop () { let mut locked_child = child . inner . lock () . unwrap () ; locked_child . parent = None ; locked_child . parent_idx = 0 ; if locked_child . is_cancelled { continue ; } while let Some (grandchild) = locked_child . children . pop () { let mut locked_grandchild = grandchild . inner . lock () . unwrap () ; locked_grandchild . parent = None ; locked_grandchild . parent_idx = 0 ; if locked_grandchild . is_cancelled { continue ; } if locked_grandchild . children . is_empty () { locked_grandchild . is_cancelled = true ; locked_grandchild . children = Vec :: new () ; drop (locked_grandchild) ; grandchild . waker . notify_waiters () ; } else { locked_grandchild . parent = Some (node . clone ()) ; locked_grandchild . parent_idx = locked_node . children . len () ; drop (locked_grandchild) ; locked_node . children . push (grandchild) ; } } locked_child . is_cancelled = true ; locked_child . children = Vec :: new () ; drop (locked_child) ; child . waker . notify_waiters () ; } locked_node . is_cancelled = true ; locked_node . children = Vec :: new () ; drop (locked_node) ; node . waker . notify_waiters () ; } . sig",
      "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
      "line": 0
    },
    {
      "hash": 4607825232996300208,
      "kind": "Function",
      "name": "cancel_token",
      "signature": "fn # [test] fn cancel_token () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 1541402824144470808,
      "kind": "Function",
      "name": "cancel_token_owned",
      "signature": "fn # [test] fn cancel_token_owned () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled_owned () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2686360498283216743,
      "kind": "Function",
      "name": "cancel_with_child",
      "signature": "fn # [test] fn cancel_with_child () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let token2 = token . clone () ; let child_token = token . child_token () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { block_on (async { child_token . cancelled () . await ; }) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 13936217811156939425,
      "kind": "Function",
      "name": "drop_token_no_child",
      "signature": "fn # [test] fn drop_token_no_child () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let token2 = token . clone () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { drop (token2) ; }) ; let th3 = thread :: spawn (move | | { drop (token) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 15459876799466943684,
      "kind": "Function",
      "name": "drop_token_with_children",
      "signature": "fn # [test] fn drop_token_with_children () { loom :: model (| | { let token1 = CancellationToken :: new () ; let child_token1 = token1 . child_token () ; let child_token2 = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { drop (child_token1) ; }) ; let th3 = thread :: spawn (move | | { drop (child_token2) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2971805719753081597,
      "kind": "Function",
      "name": "drop_and_cancel_token",
      "signature": "fn # [test] fn drop_and_cancel_token () { loom :: model (| | { let token1 = CancellationToken :: new () ; let token2 = token1 . clone () ; let child_token = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { drop (child_token) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 8836535614987973302,
      "kind": "Function",
      "name": "cancel_parent_and_child",
      "signature": "fn # [test] fn cancel_parent_and_child () { loom :: model (| | { let token1 = CancellationToken :: new () ; let token2 = token1 . clone () ; let child_token = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { child_token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
      "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2670944439876104389,
      "kind": "Struct",
      "name": "AbortOnDropHandle",
      "signature": "struct AbortOnDropHandle",
      "file_path": "tokio-util/src/task/abort_on_drop.rs",
      "line": 0
    },
    {
      "hash": 2346343903902237724,
      "kind": "Struct",
      "name": "JoinMap",
      "signature": "struct JoinMap",
      "file_path": "tokio-util/src/task/join_map.rs",
      "line": 0
    },
    {
      "hash": 4324919516633060514,
      "kind": "Struct",
      "name": "JoinMapKeys",
      "signature": "struct JoinMapKeys",
      "file_path": "tokio-util/src/task/join_map.rs",
      "line": 0
    },
    {
      "hash": 9555159375121040785,
      "kind": "Struct",
      "name": "JoinQueue",
      "signature": "struct JoinQueue",
      "file_path": "tokio-util/src/task/join_queue.rs",
      "line": 0
    },
    {
      "hash": 3971644780790372811,
      "kind": "Struct",
      "name": "LocalPoolHandle",
      "signature": "struct LocalPoolHandle",
      "file_path": "tokio-util/src/task/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 14198663157582992011,
      "kind": "Struct",
      "name": "LocalPool",
      "signature": "struct LocalPool",
      "file_path": "tokio-util/src/task/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 765946321543646912,
      "kind": "Struct",
      "name": "JobCountGuard",
      "signature": "struct JobCountGuard",
      "file_path": "tokio-util/src/task/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 15552720949973504882,
      "kind": "Struct",
      "name": "AbortGuard",
      "signature": "struct AbortGuard",
      "file_path": "tokio-util/src/task/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 4578844486860530951,
      "kind": "Struct",
      "name": "LocalWorkerHandle",
      "signature": "struct LocalWorkerHandle",
      "file_path": "tokio-util/src/task/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 11462370117272551471,
      "kind": "Struct",
      "name": "TaskTracker",
      "signature": "struct TaskTracker",
      "file_path": "tokio-util/src/task/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 8566858512300802097,
      "kind": "Struct",
      "name": "TaskTrackerToken",
      "signature": "struct TaskTrackerToken",
      "file_path": "tokio-util/src/task/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 11431101895735300419,
      "kind": "Struct",
      "name": "TaskTrackerInner",
      "signature": "struct TaskTrackerInner",
      "file_path": "tokio-util/src/task/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 13624611453831080855,
      "kind": "Function",
      "name": "debug_inner",
      "signature": "fn fn debug_inner (inner : & TaskTrackerInner , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { let state = inner . state . load (Ordering :: Acquire) ; let is_closed = (state & 1) != 0 ; let len = state >> 1 ; f . debug_struct (\"TaskTracker\") . field (\"len\" , & len) . field (\"is_closed\" , & is_closed) . field (\"inner\" , & (inner as * const TaskTrackerInner)) . finish () } . sig",
      "file_path": "tokio-util/src/task/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 9892766077253150117,
      "kind": "Struct",
      "name": "DelayQueue",
      "signature": "struct DelayQueue",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 6779090747403988215,
      "kind": "Struct",
      "name": "SlabStorage",
      "signature": "struct SlabStorage",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 5093898572901238100,
      "kind": "Struct",
      "name": "Expired",
      "signature": "struct Expired",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 1747907442717550694,
      "kind": "Struct",
      "name": "Key",
      "signature": "struct Key",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 14001043563973066854,
      "kind": "Struct",
      "name": "KeyInternal",
      "signature": "struct KeyInternal",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 15437219073951197017,
      "kind": "Struct",
      "name": "Stack",
      "signature": "struct Stack",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 15348156792858091534,
      "kind": "Struct",
      "name": "Data",
      "signature": "struct Data",
      "file_path": "tokio-util/src/time/delay_queue.rs",
      "line": 0
    },
    {
      "hash": 1723253144508478497,
      "kind": "Function",
      "name": "ms",
      "signature": "fn # [doc = \" Convert a `Duration` to milliseconds, rounding up and saturating at\"] # [doc = \" `u64::MAX`.\"] # [doc = \"\"] # [doc = \" The saturating is fine because `u64::MAX` milliseconds are still many\"] # [doc = \" million years.\"] # [inline] fn ms (duration : Duration , round : Round) -> u64 { const NANOS_PER_MILLI : u32 = 1_000_000 ; const MILLIS_PER_SEC : u64 = 1_000 ; let millis = match round { Round :: Up => (duration . subsec_nanos () + NANOS_PER_MILLI - 1) / NANOS_PER_MILLI , Round :: Down => duration . subsec_millis () , } ; duration . as_secs () . saturating_mul (MILLIS_PER_SEC) . saturating_add (u64 :: from (millis)) } . sig",
      "file_path": "tokio-util/src/time/mod.rs",
      "line": 0
    },
    {
      "hash": 2479875809132441216,
      "kind": "Function",
      "name": "slot_for",
      "signature": "fn # [doc = \" Convert a duration (milliseconds) and a level to a slot position\"] fn slot_for (duration : u64 , level : usize) -> usize { ((duration >> (level * 6)) % LEVEL_MULT as u64) as usize } . sig",
      "file_path": "tokio-util/src/time/wheel/level.rs",
      "line": 0
    },
    {
      "hash": 16500650131007905864,
      "kind": "Function",
      "name": "level_for",
      "signature": "fn fn level_for (elapsed : u64 , when : u64) -> usize { const SLOT_MASK : u64 = (1 << 6) - 1 ; let mut masked = elapsed ^ when | SLOT_MASK ; if masked >= MAX_DURATION { masked = MAX_DURATION - 1 ; } let leading_zeros = masked . leading_zeros () as usize ; let significant = 63 - leading_zeros ; significant / 6 } . sig",
      "file_path": "tokio-util/src/time/wheel/mod.rs",
      "line": 0
    },
    {
      "hash": 18224979900198386639,
      "kind": "Trait",
      "name": "Stack",
      "signature": "trait Stack",
      "file_path": "tokio-util/src/time/wheel/stack.rs",
      "line": 0
    },
    {
      "hash": 1709576025913585612,
      "kind": "Struct",
      "name": "UdpFramed",
      "signature": "struct UdpFramed",
      "file_path": "tokio-util/src/udp/frame.rs",
      "line": 0
    },
    {
      "hash": 1562480373971727098,
      "kind": "Struct",
      "name": "MaybeDangling",
      "signature": "struct MaybeDangling",
      "file_path": "tokio-util/src/util/maybe_dangling.rs",
      "line": 0
    },
    {
      "hash": 9217553823774612172,
      "kind": "Function",
      "name": "maybedangling_runs_drop",
      "signature": "fn # [test] fn maybedangling_runs_drop () { struct SetOnDrop < 'a > (& 'a mut bool) ; impl Drop for SetOnDrop < '_ > { fn drop (& mut self) { * self . 0 = true ; } } let mut success = false ; drop (MaybeDangling :: new (SetOnDrop (& mut success))) ; assert ! (success) ; } . sig",
      "file_path": "tokio-util/src/util/maybe_dangling.rs",
      "line": 0
    },
    {
      "hash": 10091701396550432438,
      "kind": "Function",
      "name": "poll_read_buf",
      "signature": "fn # [doc = \" Try to read data from an `AsyncRead` into an implementer of the [`BufMut`] trait.\"] # [doc = \"\"] # [doc = \" [`BufMut`]: bytes::Buf\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use bytes::{Bytes, BytesMut};\"] # [doc = \" use tokio_stream as stream;\"] # [doc = \" use tokio::io::Result;\"] # [doc = \" use tokio_util::io::{StreamReader, poll_read_buf};\"] # [doc = \" use std::future::poll_fn;\"] # [doc = \" use std::pin::Pin;\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \"\"] # [doc = \" // Create a reader from an iterator. This particular reader will always be\"] # [doc = \" // ready.\"] # [doc = \" let mut read = StreamReader::new(stream::iter(vec![Result::Ok(Bytes::from_static(&[0, 1, 2, 3]))]));\"] # [doc = \"\"] # [doc = \" let mut buf = BytesMut::new();\"] # [doc = \" let mut reads = 0;\"] # [doc = \"\"] # [doc = \" loop {\"] # [doc = \"     reads += 1;\"] # [doc = \"     let n = poll_fn(|cx| poll_read_buf(Pin::new(&mut read), cx, &mut buf)).await?;\"] # [doc = \"\"] # [doc = \"     if n == 0 {\"] # [doc = \"         break;\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" // one or more reads might be necessary.\"] # [doc = \" assert!(reads >= 1);\"] # [doc = \" assert_eq!(&buf[..], &[0, 1, 2, 3]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] # [cfg_attr (not (feature = \"io\") , allow (unreachable_pub))] pub fn poll_read_buf < T : AsyncRead + ? Sized , B : BufMut > (io : Pin < & mut T > , cx : & mut Context < '_ > , buf : & mut B ,) -> Poll < io :: Result < usize > > { if ! buf . has_remaining_mut () { return Poll :: Ready (Ok (0)) ; } let n = { let dst = buf . chunk_mut () ; let dst = unsafe { dst . as_uninit_slice_mut () } ; let mut buf = ReadBuf :: uninit (dst) ; let ptr = buf . filled () . as_ptr () ; ready ! (io . poll_read (cx , & mut buf) ?) ; assert_eq ! (ptr , buf . filled () . as_ptr ()) ; buf . filled () . len () } ; unsafe { buf . advance_mut (n) ; } Poll :: Ready (Ok (n)) } . sig",
      "file_path": "tokio-util/src/util/poll_buf.rs",
      "line": 0
    },
    {
      "hash": 18393643052114760840,
      "kind": "Function",
      "name": "poll_write_buf",
      "signature": "fn # [doc = \" Try to write data from an implementer of the [`Buf`] trait to an\"] # [doc = \" [`AsyncWrite`], advancing the buffer's internal cursor.\"] # [doc = \"\"] # [doc = \" This function will use [vectored writes] when the [`AsyncWrite`] supports\"] # [doc = \" vectored writes.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" [`File`] implements [`AsyncWrite`] and [`Cursor<&[u8]>`] implements\"] # [doc = \" [`Buf`]:\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio_util::io::poll_write_buf;\"] # [doc = \" use tokio::io;\"] # [doc = \" use tokio::fs::File;\"] # [doc = \"\"] # [doc = \" use bytes::Buf;\"] # [doc = \" use std::future::poll_fn;\"] # [doc = \" use std::io::Cursor;\"] # [doc = \" use std::pin::Pin;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     let mut file = File::create(\\\"foo.txt\\\").await?;\"] # [doc = \"     let mut buf = Cursor::new(b\\\"data to write\\\");\"] # [doc = \"\"] # [doc = \"     // Loop until the entire contents of the buffer are written to\"] # [doc = \"     // the file.\"] # [doc = \"     while buf.has_remaining() {\"] # [doc = \"         poll_fn(|cx| poll_write_buf(Pin::new(&mut file), cx, &mut buf)).await?;\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" [`Buf`]: bytes::Buf\"] # [doc = \" [`AsyncWrite`]: tokio::io::AsyncWrite\"] # [doc = \" [`File`]: tokio::fs::File\"] # [doc = \" [vectored writes]: tokio::io::AsyncWrite::poll_write_vectored\"] # [cfg_attr (not (feature = \"io\") , allow (unreachable_pub))] pub fn poll_write_buf < T : AsyncWrite + ? Sized , B : Buf > (io : Pin < & mut T > , cx : & mut Context < '_ > , buf : & mut B ,) -> Poll < io :: Result < usize > > { const MAX_BUFS : usize = 64 ; if ! buf . has_remaining () { return Poll :: Ready (Ok (0)) ; } let n = if io . is_write_vectored () { let mut slices = [IoSlice :: new (& []) ; MAX_BUFS] ; let cnt = buf . chunks_vectored (& mut slices) ; ready ! (io . poll_write_vectored (cx , & slices [.. cnt])) ? } else { ready ! (io . poll_write (cx , buf . chunk ())) ? } ; buf . advance (n) ; Poll :: Ready (Ok (n)) } . sig",
      "file_path": "tokio-util/src/util/poll_buf.rs",
      "line": 0
    },
    {
      "hash": 1166844252371340854,
      "kind": "Function",
      "name": "aborts_task_on_drop",
      "signature": "fn # [tokio :: test] async fn aborts_task_on_drop () { let (mut tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; drop (handle) ; tx . closed () . await ; assert ! (tx . is_closed ()) ; } . sig",
      "file_path": "tokio-util/tests/abort_on_drop.rs",
      "line": 0
    },
    {
      "hash": 7261030386932508365,
      "kind": "Function",
      "name": "aborts_task_directly",
      "signature": "fn # [tokio :: test] async fn aborts_task_directly () { let (mut tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; handle . abort () ; tx . closed () . await ; assert ! (tx . is_closed ()) ; assert ! (handle . is_finished ()) ; } . sig",
      "file_path": "tokio-util/tests/abort_on_drop.rs",
      "line": 0
    },
    {
      "hash": 11038824096243011158,
      "kind": "Function",
      "name": "does_not_abort_after_detach",
      "signature": "fn # [tokio :: test] async fn does_not_abort_after_detach () { let (tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; handle . detach () ; yield_now () . await ; assert ! (! tx . is_closed ()) ; } . sig",
      "file_path": "tokio-util/tests/abort_on_drop.rs",
      "line": 0
    },
    {
      "hash": 12154318875936032089,
      "kind": "Function",
      "name": "bytes_decoder",
      "signature": "fn # [test] fn bytes_decoder () { let mut codec = BytesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . put_slice (b\"abc\") ; assert_eq ! (\"abc\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"a\") ; assert_eq ! (\"a\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 18123057866948636123,
      "kind": "Function",
      "name": "bytes_encoder",
      "signature": "fn # [test] fn bytes_encoder () { let mut codec = BytesCodec :: new () ; # [cfg (target_pointer_width = \"64\")] const INLINE_CAP : usize = 4 * 8 - 1 ; # [cfg (target_pointer_width = \"32\")] const INLINE_CAP : usize = 4 * 4 - 1 ; let mut buf = BytesMut :: new () ; codec . encode (Bytes :: from_static (& [0 ; INLINE_CAP + 1]) , & mut buf) . unwrap () ; const INITIAL_CAPACITY : usize = 8 * 1024 ; let mut buf = BytesMut :: with_capacity (INITIAL_CAPACITY) ; codec . encode (Bytes :: from_static (& [0 ; INITIAL_CAPACITY + 1]) , & mut buf) . unwrap () ; codec . encode (BytesMut :: from (& b\"hello\" [..]) , & mut buf) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 11388656774055942319,
      "kind": "Function",
      "name": "lines_decoder",
      "signature": "fn # [test] fn lines_decoder () { let mut codec = LinesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1\\nline 2\\r\\nline 3\\n\\r\\n\\r\") ; assert_eq ! (\"line 1\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"line 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"line 3\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (\"\\rk\" , codec . decode_eof (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 9442432231463251422,
      "kind": "Function",
      "name": "lines_decoder_invalid_utf8",
      "signature": "fn # [test] fn lines_decoder_invalid_utf8 () { let mut codec = LinesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1\\xc3\\x28\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert ! (codec . decode_eof (buf) . is_err ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"line 22222222222222\\n\") ; assert_eq ! (\"line 22222222222222\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 7940743524320241885,
      "kind": "Function",
      "name": "lines_decoder_max_length",
      "signature": "fn # [test] fn lines_decoder_max_length () { const MAX_LENGTH : usize = 6 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1 is too long\\nline 2\\nline 3\\r\\nline 4\\n\\r\\n\\r\") ; assert ! (codec . decode (buf) . is_err ()) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"line 2\" , line) ; assert ! (codec . decode (buf) . is_err ()) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"line 4\" , line) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , line) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; let line = codec . decode_eof (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\\rk\" , line) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"aaabbbc\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 2514143795098064,
      "kind": "Function",
      "name": "lines_decoder_max_length_underrun",
      "signature": "fn # [test] fn lines_decoder_max_length_underrun () { const MAX_LENGTH : usize = 6 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"ong\\n\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"line 2\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"\\n\") ; assert_eq ! (\"line 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 13421245945755358786,
      "kind": "Function",
      "name": "lines_decoder_max_length_bursts",
      "signature": "fn # [test] fn lines_decoder_max_length_bursts () { const MAX_LENGTH : usize = 10 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 234731366912462514,
      "kind": "Function",
      "name": "lines_decoder_max_length_big_burst",
      "signature": "fn # [test] fn lines_decoder_max_length_big_burst () { const MAX_LENGTH : usize = 10 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too long!\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 18001888652368965137,
      "kind": "Function",
      "name": "lines_decoder_max_length_newline_between_decodes",
      "signature": "fn # [test] fn lines_decoder_max_length_newline_between_decodes () { const MAX_LENGTH : usize = 5 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"hello\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"\\nworld\") ; assert_eq ! (\"hello\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 2937633911298989203,
      "kind": "Function",
      "name": "lines_decoder_discard_repeat",
      "signature": "fn # [test] fn lines_decoder_discard_repeat () { const MAX_LENGTH : usize = 1 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"aa\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"a\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 705673657921707844,
      "kind": "Function",
      "name": "lines_decoder_max_length_underrun_twice",
      "signature": "fn # [test] fn lines_decoder_max_length_underrun_twice () { const MAX_LENGTH : usize = 11 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too very l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"aaaaaaaaaaaaaaaaaaaaaaa\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\nshort\\n\") ; assert_eq ! (\"short\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 16021786527262481487,
      "kind": "Function",
      "name": "lines_encoder",
      "signature": "fn # [test] fn lines_encoder () { let mut codec = LinesCodec :: new () ; let mut buf = BytesMut :: new () ; codec . encode (\"line 1\" , & mut buf) . unwrap () ; assert_eq ! (\"line 1\\n\" , buf) ; codec . encode (\"line 2\" , & mut buf) . unwrap () ; assert_eq ! (\"line 1\\nline 2\\n\" , buf) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 1735863879540817018,
      "kind": "Function",
      "name": "any_delimiters_decoder_any_character",
      "signature": "fn # [test] fn any_delimiters_decoder_any_character () { let mut codec = AnyDelimiterCodec :: new (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec ()) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk 1,chunk 2;chunk 3\\n\\r\") ; assert_eq ! (\"chunk 1\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"chunk 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"chunk 3\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (\"k\" , codec . decode_eof (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 6688255965887808888,
      "kind": "Function",
      "name": "any_delimiters_decoder_max_length",
      "signature": "fn # [test] fn any_delimiters_decoder_max_length () { const MAX_LENGTH : usize = 7 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk 1 is too long\\nchunk 2\\nchunk 3\\r\\nchunk 4\\n\\r\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 2\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 3\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 4\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; let chunk = codec . decode_eof (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"k\" , chunk) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"aaabbbcc\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 6668821297026198902,
      "kind": "Function",
      "name": "any_delimiter_decoder_max_length_underrun",
      "signature": "fn # [test] fn any_delimiter_decoder_max_length_underrun () { const MAX_LENGTH : usize = 7 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"ong\\n\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"chunk 2\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\",\") ; assert_eq ! (\"chunk 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 8556507789988893853,
      "kind": "Function",
      "name": "any_delimiter_decoder_max_length_underrun_twice",
      "signature": "fn # [test] fn any_delimiter_decoder_max_length_underrun_twice () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too very l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"aaaaaaaaaaaaaaaaaaaaaaa\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\nshort\\n\") ; assert_eq ! (\"short\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 16362661941313951855,
      "kind": "Function",
      "name": "any_delimiter_decoder_max_length_bursts",
      "signature": "fn # [test] fn any_delimiter_decoder_max_length_bursts () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 9291847705962603235,
      "kind": "Function",
      "name": "any_delimiter_decoder_max_length_big_burst",
      "signature": "fn # [test] fn any_delimiter_decoder_max_length_big_burst () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too long!\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 15165232243677060956,
      "kind": "Function",
      "name": "any_delimiter_decoder_max_length_delimiter_between_decodes",
      "signature": "fn # [test] fn any_delimiter_decoder_max_length_delimiter_between_decodes () { const MAX_LENGTH : usize = 5 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"hello\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\",world\") ; assert_eq ! (\"hello\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 17616513787351649231,
      "kind": "Function",
      "name": "any_delimiter_decoder_discard_repeat",
      "signature": "fn # [test] fn any_delimiter_decoder_discard_repeat () { const MAX_LENGTH : usize = 1 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"aa\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"a\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 9791284304882521785,
      "kind": "Function",
      "name": "any_delimiter_encoder",
      "signature": "fn # [test] fn any_delimiter_encoder () { let mut codec = AnyDelimiterCodec :: new (b\",\" . to_vec () , b\";--;\" . to_vec ()) ; let mut buf = BytesMut :: new () ; codec . encode (\"chunk 1\" , & mut buf) . unwrap () ; assert_eq ! (\"chunk 1;--;\" , buf) ; codec . encode (\"chunk 2\" , & mut buf) . unwrap () ; assert_eq ! (\"chunk 1;--;chunk 2;--;\" , buf) ; } . sig",
      "file_path": "tokio-util/tests/codecs.rs",
      "line": 0
    },
    {
      "hash": 3956886754033376298,
      "kind": "Function",
      "name": "compat_file_seek",
      "signature": "fn # [tokio :: test] async fn compat_file_seek () -> futures_util :: io :: Result < () > { let temp_file = NamedTempFile :: new () ? ; let mut file = OpenOptions :: new () . read (true) . write (true) . create (true) . truncate (true) . open (temp_file) . await ? . compat_write () ; file . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await ? ; file . write_all (& [6 , 7]) . await ? ; assert_eq ! (file . stream_position () . await ?, 8) ; assert_eq ! (file . seek (SeekFrom :: Start (2)) . await ?, 2) ; file . write_all (& [8 , 9]) . await ? ; file . flush () . await ? ; assert_eq ! (file . seek (SeekFrom :: End (0)) . await ?, 8) ; file . seek (SeekFrom :: Start (0)) . await ? ; let mut buf = Vec :: new () ; let num_bytes = file . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf [.. num_bytes] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/compat.rs",
      "line": 0
    },
    {
      "hash": 17427149582432931603,
      "kind": "Function",
      "name": "tokio_context_with_another_runtime",
      "signature": "fn # [test] fn tokio_context_with_another_runtime () { let rt1 = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; rt1 . block_on (rt2 . wrap (async move { sleep (Duration :: from_millis (2)) . await })) ; } . sig",
      "file_path": "tokio-util/tests/context.rs",
      "line": 0
    },
    {
      "hash": 14214983956587061919,
      "kind": "Struct",
      "name": "U32Codec",
      "signature": "struct U32Codec",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 461988978151432706,
      "kind": "Struct",
      "name": "U64Codec",
      "signature": "struct U64Codec",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 12136100923084413909,
      "kind": "Struct",
      "name": "DontReadIntoThis",
      "signature": "struct DontReadIntoThis",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 13027262434157279566,
      "kind": "Function",
      "name": "can_read_from_existing_buf",
      "signature": "fn # [tokio :: test] async fn can_read_from_existing_buf () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42] [..]) ; let mut framed = Framed :: from_parts (parts) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 42) ; assert_eq ! (framed . codec () . read_bytes , 4) ; } . sig",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 1036309227782387636,
      "kind": "Function",
      "name": "can_read_from_existing_buf_after_codec_changed",
      "signature": "fn # [tokio :: test] async fn can_read_from_existing_buf_after_codec_changed () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 84] [..]) ; let mut framed = Framed :: from_parts (parts) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 42) ; assert_eq ! (framed . codec () . read_bytes , 4) ; let mut framed = framed . map_codec (| codec | U64Codec { read_bytes : codec . read_bytes , }) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 84) ; assert_eq ! (framed . codec () . read_bytes , 12) ; } . sig",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 12274248035611071653,
      "kind": "Function",
      "name": "external_buf_grows_to_init",
      "signature": "fn # [test] fn external_buf_grows_to_init () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42] [..]) ; let framed = Framed :: from_parts (parts) ; let FramedParts { read_buf , .. } = framed . into_parts () ; assert_eq ! (read_buf . capacity () , INITIAL_CAPACITY) ; } . sig",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 13513030780439754212,
      "kind": "Function",
      "name": "external_buf_does_not_shrink",
      "signature": "fn # [test] fn external_buf_does_not_shrink () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& vec ! [0 ; INITIAL_CAPACITY * 2] [..]) ; let framed = Framed :: from_parts (parts) ; let FramedParts { read_buf , .. } = framed . into_parts () ; assert_eq ! (read_buf . capacity () , INITIAL_CAPACITY * 2) ; } . sig",
      "file_path": "tokio-util/tests/framed.rs",
      "line": 0
    },
    {
      "hash": 4058707972684022383,
      "kind": "Struct",
      "name": "U32Decoder",
      "signature": "struct U32Decoder",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 15668267960293596481,
      "kind": "Struct",
      "name": "U64Decoder",
      "signature": "struct U64Decoder",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 15161345919344753208,
      "kind": "Function",
      "name": "read_multi_frame_in_packet",
      "signature": "fn # [test] fn read_multi_frame_in_packet () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 8919339705795650412,
      "kind": "Function",
      "name": "read_multi_frame_across_packets",
      "signature": "fn # [test] fn read_multi_frame_across_packets () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 4793918787514161541,
      "kind": "Function",
      "name": "read_multi_frame_in_packet_after_codec_changed",
      "signature": "fn # [test] fn read_multi_frame_in_packet_after_codec_changed () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0x04) ; let mut framed = framed . map_decoder (| _ | U64Decoder) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0x08) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 11379974874962808984,
      "kind": "Function",
      "name": "read_not_ready",
      "signature": "fn # [test] fn read_not_ready () { let mut task = task :: spawn (()) ; let mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Ok (b\"\\x00\\x00\\x00\\x00\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 1119801434640775962,
      "kind": "Function",
      "name": "read_partial_then_not_ready",
      "signature": "fn # [test] fn read_partial_then_not_ready () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 17737962444365065543,
      "kind": "Function",
      "name": "read_err",
      "signature": "fn # [test] fn read_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 13900884606263567146,
      "kind": "Function",
      "name": "read_partial_then_err",
      "signature": "fn # [test] fn read_partial_then_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 11785115084208459800,
      "kind": "Function",
      "name": "read_partial_would_block_then_err",
      "signature": "fn # [test] fn read_partial_would_block_then_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 1505400025405390497,
      "kind": "Function",
      "name": "huge_size",
      "signature": "fn # [test] fn huge_size () { let mut task = task :: spawn (()) ; let data = & [0 ; 32 * 1024] [..] ; let mut framed = FramedRead :: new (data , BigDecoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; struct BigDecoder ; impl Decoder for BigDecoder { type Item = u32 ; type Error = io :: Error ; fn decode (& mut self , buf : & mut BytesMut) -> io :: Result < Option < u32 > > { if buf . len () < 32 * 1024 { return Ok (None) ; } buf . advance (32 * 1024) ; Ok (Some (0)) } } } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 3868038668609971769,
      "kind": "Function",
      "name": "data_remaining_is_error",
      "signature": "fn # [test] fn data_remaining_is_error () { let mut task = task :: spawn (()) ; let slice = & [0 ; 5] [..] ; let mut framed = FramedRead :: new (slice , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . is_err ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 15033596015351271192,
      "kind": "Function",
      "name": "multi_frames_on_eof",
      "signature": "fn # [test] fn multi_frames_on_eof () { let mut task = task :: spawn (()) ; struct MyDecoder (Vec < u32 >) ; impl Decoder for MyDecoder { type Item = u32 ; type Error = io :: Error ; fn decode (& mut self , _buf : & mut BytesMut) -> io :: Result < Option < u32 > > { unreachable ! () ; } fn decode_eof (& mut self , _buf : & mut BytesMut) -> io :: Result < Option < u32 > > { if self . 0 . is_empty () { return Ok (None) ; } Ok (Some (self . 0 . remove (0))) } } let mut framed = FramedRead :: new (mock ! () , MyDecoder (vec ! [0 , 1 , 2 , 3])) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert_read ! (pin ! (framed) . poll_next (cx) , 3) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 18226455662876778128,
      "kind": "Function",
      "name": "read_eof_then_resume",
      "signature": "fn # [test] fn read_eof_then_resume () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , Ok (b\"\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x02\" . to_vec ()) , Ok (b\"\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x03\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 3) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_read.rs",
      "line": 0
    },
    {
      "hash": 11303714689956993133,
      "kind": "Function",
      "name": "return_none_after_error",
      "signature": "fn # [tokio :: test] async fn return_none_after_error () { let mut io = FramedRead :: new (Builder :: new () . read (b\"abcdef\") . read_error (io :: Error :: new (io :: ErrorKind :: Other , \"Resource errored out\")) . read (b\"more data\") . build () , BytesCodec :: new () ,) ; let mut task = task :: spawn (()) ; task . enter (| cx , _ | { assert_read ! (pin ! (io) . poll_next (cx) , b\"abcdef\" . to_vec ()) ; assert ! (assert_ready ! (pin ! (io) . poll_next (cx)) . unwrap () . is_err ()) ; assert ! (assert_ready ! (pin ! (io) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (io) . poll_next (cx) , b\"more data\" . to_vec ()) ; }) } . sig",
      "file_path": "tokio-util/tests/framed_stream.rs",
      "line": 0
    },
    {
      "hash": 9459654359639709191,
      "kind": "Struct",
      "name": "U32Encoder",
      "signature": "struct U32Encoder",
      "file_path": "tokio-util/tests/framed_write.rs",
      "line": 0
    },
    {
      "hash": 17064158340746198906,
      "kind": "Struct",
      "name": "U64Encoder",
      "signature": "struct U64Encoder",
      "file_path": "tokio-util/tests/framed_write.rs",
      "line": 0
    },
    {
      "hash": 1006007237246353855,
      "kind": "Function",
      "name": "write_multi_frame_in_packet",
      "signature": "fn # [test] fn write_multi_frame_in_packet () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; task . enter (| cx , _ | { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (1) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (2) . is_ok ()) ; assert_eq ! (1 , framed . get_ref () . calls . len ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_write.rs",
      "line": 0
    },
    {
      "hash": 18055688159231673664,
      "kind": "Function",
      "name": "write_multi_frame_after_codec_changed",
      "signature": "fn # [test] fn write_multi_frame_after_codec_changed () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\" . to_vec ()) , } ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; task . enter (| cx , _ | { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0x04) . is_ok ()) ; let mut framed = framed . map_encoder (| _ | U64Encoder) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0x08) . is_ok ()) ; assert_eq ! (1 , framed . get_ref () . calls . len ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/framed_write.rs",
      "line": 0
    },
    {
      "hash": 10633669677796768658,
      "kind": "Function",
      "name": "write_hits_backpressure",
      "signature": "fn # [test] fn write_hits_backpressure () { const ITER : usize = 2 * 1024 ; let mut mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"not ready\")) , Ok (b\"\" . to_vec ()) , } ; for i in 0 ..= ITER * 2 { let mut b = BytesMut :: with_capacity (4) ; b . put_u32 (i as u32) ; match mock . calls . back_mut () . unwrap () { Ok (ref mut data) => { if data . len () < ITER { data . extend_from_slice (& b [..]) ; continue ; } } _ => unreachable ! () , } mock . calls . push_back (Ok (b [..] . to_vec ())) ; } assert_eq ! (mock . calls . len () , 10) ; let mut task = task :: spawn (()) ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; framed . set_backpressure_boundary (ITER * 8) ; task . enter (| cx , _ | { for i in 0 .. ITER * 2 { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (i as u32) . is_ok ()) ; } assert ! (pin ! (framed) . poll_ready (cx) . is_pending ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send ((ITER * 2) as u32) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) } . sig",
      "file_path": "tokio-util/tests/framed_write.rs",
      "line": 0
    },
    {
      "hash": 15966885430383313061,
      "kind": "Struct",
      "name": "ReadyOnTheSecondPollFuture",
      "signature": "struct ReadyOnTheSecondPollFuture",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 7705362372157334220,
      "kind": "Function",
      "name": "ready_fut_with_cancellation_token_test",
      "signature": "fn # [test] fn ready_fut_with_cancellation_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let ready_fut = ready (()) ; let ready_with_token_fut = ready_fut . with_cancellation_token (& token) ; pin ! (ready_with_token_fut) ; let res = ready_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 6180438783044041335,
      "kind": "Function",
      "name": "pending_fut_with_cancellation_token_test",
      "signature": "fn # [test] fn pending_fut_with_cancellation_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 10615718242617539118,
      "kind": "Function",
      "name": "ready_fut_with_already_cancelled_token_test",
      "signature": "fn # [test] fn ready_fut_with_already_cancelled_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let ready_fut = ready (()) ; let ready_fut_with_token_fut = ready_fut . with_cancellation_token (& token) ; pin ! (ready_fut_with_token_fut) ; let res = ready_fut_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 4320214173244444394,
      "kind": "Function",
      "name": "pending_fut_with_already_cancelled_token_test",
      "signature": "fn # [test] fn pending_fut_with_already_cancelled_token_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 0) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 10090821084188948990,
      "kind": "Function",
      "name": "pending_fut_with_token_cancelled_test",
      "signature": "fn # [test] fn pending_fut_with_token_cancelled_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 1) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 4437772855640321511,
      "kind": "Function",
      "name": "pending_only_on_first_poll_with_cancellation_token_test",
      "signature": "fn # [test] fn pending_only_on_first_poll_with_cancellation_token_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let fut = ReadyOnTheSecondPollFuture :: default () . with_cancellation_token (& token) ; pin ! (fut) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; assert_eq ! (wake_count , 1) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 5724398901115762529,
      "kind": "Function",
      "name": "ready_fut_with_cancellation_owned_token_test",
      "signature": "fn # [test] fn ready_fut_with_cancellation_owned_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let ready_fut = ready (()) ; let ready_with_token_fut = ready_fut . with_cancellation_token_owned (token) ; pin ! (ready_with_token_fut) ; let res = ready_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 13763621474889795721,
      "kind": "Function",
      "name": "pending_fut_with_cancellation_token_owned_test",
      "signature": "fn # [test] fn pending_fut_with_cancellation_token_owned_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 7425991354816186623,
      "kind": "Function",
      "name": "ready_fut_with_already_cancelled_token_owned_test",
      "signature": "fn # [test] fn ready_fut_with_already_cancelled_token_owned_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let ready_fut = ready (()) ; let ready_fut_with_token_fut = ready_fut . with_cancellation_token_owned (token) ; pin ! (ready_fut_with_token_fut) ; let res = ready_fut_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 3296694069051322066,
      "kind": "Function",
      "name": "pending_fut_with_already_cancelled_token_owned_test",
      "signature": "fn # [test] fn pending_fut_with_already_cancelled_token_owned_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 0) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 13448376060005790673,
      "kind": "Function",
      "name": "pending_fut_with_owned_token_cancelled_test",
      "signature": "fn # [test] fn pending_fut_with_owned_token_cancelled_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token . clone ()) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 1) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 3383670500781510908,
      "kind": "Function",
      "name": "pending_only_on_first_poll_with_cancellation_token_owned_test",
      "signature": "fn # [test] fn pending_only_on_first_poll_with_cancellation_token_owned_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let fut = ReadyOnTheSecondPollFuture :: default () . with_cancellation_token_owned (token . clone ()) ; pin ! (fut) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; assert_eq ! (wake_count , 1) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
      "file_path": "tokio-util/tests/future.rs",
      "line": 0
    },
    {
      "hash": 11331435548626667388,
      "kind": "Struct",
      "name": "SmallReader",
      "signature": "struct SmallReader",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 3326236877851002729,
      "kind": "Function",
      "name": "read_tee",
      "signature": "fn # [tokio :: test] async fn read_tee () { let contents = b\"This could be really long, you know\" . to_vec () ; let reader = SmallReader { contents : contents . clone () , } ; let mut altout : Vec < u8 > = Vec :: new () ; let mut teeout = Vec :: new () ; { let mut tee = InspectReader :: new (reader , | bytes | altout . extend (bytes)) ; tee . read_to_end (& mut teeout) . await . unwrap () ; } assert_eq ! (teeout , altout) ; assert_eq ! (altout . len () , contents . len ()) ; } . sig",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 8727601496051406043,
      "kind": "Struct",
      "name": "SmallWriter",
      "signature": "struct SmallWriter",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 6119924587319448089,
      "kind": "Function",
      "name": "write_tee",
      "signature": "fn # [tokio :: test] async fn write_tee () { let mut altout : Vec < u8 > = Vec :: new () ; let mut writeout = SmallWriter { contents : Vec :: new () , } ; { let mut tee = InspectWriter :: new (& mut writeout , | bytes | altout . extend (bytes)) ; tee . write_all (b\"A testing string, very testing\") . await . unwrap () ; } assert_eq ! (altout , writeout . contents) ; } . sig",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 18346226435514906454,
      "kind": "Function",
      "name": "write_all_vectored",
      "signature": "fn async fn write_all_vectored < W : AsyncWrite + Unpin > (mut writer : W , mut bufs : Vec < Vec < u8 > > ,) -> Result < usize , std :: io :: Error > { let mut res = 0 ; while ! bufs . is_empty () { let mut written = poll_fn (| cx | { let bufs : Vec < IoSlice > = bufs . iter () . map (| v | IoSlice :: new (v)) . collect () ; Pin :: new (& mut writer) . poll_write_vectored (cx , & bufs) }) . await ? ; res += written ; while written > 0 { let buf_len = bufs [0] . len () ; if buf_len <= written { bufs . remove (0) ; written -= buf_len ; } else { let buf = & mut bufs [0] ; let drain_len = written . min (buf . len ()) ; buf . drain (.. drain_len) ; written -= drain_len ; } } } Ok (res) } . sig",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 10138258154988886922,
      "kind": "Function",
      "name": "write_tee_vectored",
      "signature": "fn # [tokio :: test] async fn write_tee_vectored () { let mut altout : Vec < u8 > = Vec :: new () ; let mut writeout = SmallWriter { contents : Vec :: new () , } ; let original = b\"A very long string split up\" ; let bufs : Vec < Vec < u8 > > = original . split (| b | b . is_ascii_whitespace ()) . map (Vec :: from) . collect () ; assert ! (bufs . len () > 1) ; let expected : Vec < u8 > = { let mut out = Vec :: new () ; for item in & bufs { out . extend_from_slice (item) } out } ; { let mut bufcount = 0 ; let tee = InspectWriter :: new (& mut writeout , | bytes | { bufcount += 1 ; altout . extend (bytes) }) ; assert ! (tee . is_write_vectored ()) ; write_all_vectored (tee , bufs . clone ()) . await . unwrap () ; assert ! (bufcount >= bufs . len ()) ; } assert_eq ! (altout , writeout . contents) ; assert_eq ! (writeout . contents , expected) ; } . sig",
      "file_path": "tokio-util/tests/io_inspect.rs",
      "line": 0
    },
    {
      "hash": 6199343088895623251,
      "kind": "Struct",
      "name": "Reader",
      "signature": "struct Reader",
      "file_path": "tokio-util/tests/io_reader_stream.rs",
      "line": 0
    },
    {
      "hash": 10473988312528792982,
      "kind": "Function",
      "name": "correct_behavior_on_errors",
      "signature": "fn # [tokio :: test] async fn correct_behavior_on_errors () { let reader = Reader { remaining : 8000 } ; let mut stream = tokio_util :: io :: ReaderStream :: new (reader) ; let mut zeros_received = 0 ; let mut had_error = false ; loop { let item = stream . next () . await . unwrap () ; println ! (\"{item:?}\") ; match item { Ok (bytes) => { let bytes = & * bytes ; for byte in bytes { assert_eq ! (* byte , 0) ; zeros_received += 1 ; } } Err (_) => { assert ! (! had_error) ; had_error = true ; break ; } } } assert ! (had_error) ; assert_eq ! (zeros_received , 8000) ; assert ! (stream . next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/io_reader_stream.rs",
      "line": 0
    },
    {
      "hash": 18155884205913232921,
      "kind": "Function",
      "name": "test_copied_sink_writer",
      "signature": "fn # [tokio :: test] async fn test_copied_sink_writer () -> Result < () , Error > { let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < Bytes > (1) ; let mut writer = SinkWriter :: new (CopyToBytes :: new (PollSender :: new (tx) . sink_map_err (| _ | io :: Error :: from (ErrorKind :: BrokenPipe)) ,)) ; let data : [u8 ; 4] = [1 , 2 , 3 , 4] ; let _ = writer . write (& data) . await ; assert_eq ! (data . to_vec () , rx . recv () . await . unwrap () . to_vec ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sink_writer.rs",
      "line": 0
    },
    {
      "hash": 8560010311519652108,
      "kind": "Struct",
      "name": "SliceEncoder",
      "signature": "struct SliceEncoder",
      "file_path": "tokio-util/tests/io_sink_writer.rs",
      "line": 0
    },
    {
      "hash": 5619451006174683731,
      "kind": "Function",
      "name": "test_direct_sink_writer",
      "signature": "fn # [tokio :: test] async fn test_direct_sink_writer () -> Result < () , Error > { let framed_byte_lc = FramedWrite :: new (Vec :: new () , SliceEncoder :: new ()) ; let mut writer = SinkWriter :: new (framed_byte_lc) ; let _ = writer . write (& [1 , 2 , 3]) . await ; let _ = writer . write (& [4 , 5 , 6]) . await ; assert_eq ! (writer . into_inner () . write_buffer () . to_vec () . as_slice () , & [1 , 2 , 3 , 4 , 5 , 6]) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sink_writer.rs",
      "line": 0
    },
    {
      "hash": 3039806587180586678,
      "kind": "Function",
      "name": "test_stream_reader",
      "signature": "fn # [tokio :: test] async fn test_stream_reader () -> std :: io :: Result < () > { let stream = iter (vec ! [std :: io :: Result :: Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [0 , 1 , 2 , 3])) , Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [4 , 5 , 6 , 7])) , Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [8 , 9 , 10 , 11])) , Ok (Bytes :: from_static (& [])) ,]) ; let mut read = StreamReader :: new (stream) ; let mut buf = [0 ; 5] ; read . read_exact (& mut buf) . await ? ; assert_eq ! (buf , [0 , 1 , 2 , 3 , 4]) ; assert_eq ! (read . read (& mut buf) . await ?, 3) ; assert_eq ! (& buf [.. 3] , [5 , 6 , 7]) ; assert_eq ! (read . read (& mut buf) . await ?, 4) ; assert_eq ! (& buf [.. 4] , [8 , 9 , 10 , 11]) ; assert_eq ! (read . read (& mut buf) . await ?, 0) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_stream_reader.rs",
      "line": 0
    },
    {
      "hash": 11487206146343388237,
      "kind": "Function",
      "name": "test_reader_len",
      "signature": "fn async fn test_reader_len (r : impl AsyncRead + Unpin + Send + 'static , expected_len : usize ,) -> IoResult < () > { let mut r = SyncIoBridge :: new (r) ; let res = tokio :: task :: spawn_blocking (move | | { let mut buf = Vec :: new () ; r . read_to_end (& mut buf) ? ; Ok :: < _ , std :: io :: Error > (buf) }) . await ? ; assert_eq ! (res ?. len () , expected_len) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 14082470811138284459,
      "kind": "Function",
      "name": "test_async_read_to_sync",
      "signature": "fn # [tokio :: test] async fn test_async_read_to_sync () -> Result < () , Box < dyn Error > > { test_reader_len (tokio :: io :: empty () , 0) . await ? ; let buf = b\"hello world\" ; test_reader_len (Cursor :: new (buf) , buf . len ()) . await ? ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 13312092734742893989,
      "kind": "Function",
      "name": "test_async_write_to_sync",
      "signature": "fn # [tokio :: test] async fn test_async_write_to_sync () -> Result < () , Box < dyn Error > > { let mut dest = Vec :: new () ; let src = b\"hello world\" ; let dest = tokio :: task :: spawn_blocking (move | | -> Result < _ , String > { let mut w = SyncIoBridge :: new (Cursor :: new (& mut dest)) ; std :: io :: copy (& mut Cursor :: new (src) , & mut w) . map_err (| e | e . to_string ()) ? ; Ok (dest) }) . await ? ? ; assert_eq ! (dest . as_slice () , src) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 1198547869398556859,
      "kind": "Function",
      "name": "test_into_inner",
      "signature": "fn # [tokio :: test] async fn test_into_inner () -> Result < () , Box < dyn Error > > { let mut buf = Vec :: new () ; SyncIoBridge :: new (tokio :: io :: empty ()) . into_inner () . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf . len () , 0) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 11960277069723419833,
      "kind": "Function",
      "name": "test_shutdown",
      "signature": "fn # [tokio :: test] async fn test_shutdown () -> Result < () , Box < dyn Error > > { let (s1 , mut s2) = tokio :: io :: duplex (1024) ; let (_rh , wh) = tokio :: io :: split (s1) ; tokio :: task :: spawn_blocking (move | | -> std :: io :: Result < _ > { let mut wh = SyncIoBridge :: new (wh) ; wh . write_all (b\"hello\") ? ; wh . shutdown () ? ; assert ! (wh . write_all (b\" world\") . is_err ()) ; Ok (()) }) . await ? ? ; let mut buf = vec ! [] ; s2 . read_to_end (& mut buf) . await ? ; assert_eq ! (buf , b\"hello\") ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/io_sync_bridge.rs",
      "line": 0
    },
    {
      "hash": 17047317488167601804,
      "kind": "Function",
      "name": "read_empty_io_yields_nothing",
      "signature": "fn # [test] fn read_empty_io_yields_nothing () { let io = Box :: pin (FramedRead :: new (mock ! () , LengthDelimitedCodec :: new ())) ; pin_mut ! (io) ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 12534557020712289973,
      "kind": "Function",
      "name": "read_single_frame_one_packet",
      "signature": "fn # [test] fn read_single_frame_one_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 12214479667083804321,
      "kind": "Function",
      "name": "read_single_frame_one_packet_little_endian",
      "signature": "fn # [test] fn read_single_frame_one_packet_little_endian () { let io = length_delimited :: Builder :: new () . little_endian () . new_read (mock ! { data (b\"\\x09\\x00\\x00\\x00abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 9058361300199419123,
      "kind": "Function",
      "name": "read_single_frame_one_packet_native_endian",
      "signature": "fn # [test] fn read_single_frame_one_packet_native_endian () { let d = if cfg ! (target_endian = \"big\") { b\"\\x00\\x00\\x00\\x09abcdefghi\" } else { b\"\\x09\\x00\\x00\\x00abcdefghi\" } ; let io = length_delimited :: Builder :: new () . native_endian () . new_read (mock ! { data (d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 2785649154881242560,
      "kind": "Function",
      "name": "read_single_multi_frame_one_packet",
      "signature": "fn # [test] fn read_single_multi_frame_one_packet () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x09abcdefghi\") ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x03123\") ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x0bhello world\") ; let io = FramedRead :: new (mock ! { data (& d) , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 12916193297856147282,
      "kind": "Function",
      "name": "read_single_frame_multi_packet",
      "signature": "fn # [test] fn read_single_frame_multi_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , data (b\"\\x00\\x09abc\") , data (b\"defghi\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 15969074451819471160,
      "kind": "Function",
      "name": "read_multi_frame_multi_packet",
      "signature": "fn # [test] fn read_multi_frame_multi_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , data (b\"\\x00\\x09abc\") , data (b\"defghi\") , data (b\"\\x00\\x00\\x00\\x0312\") , data (b\"3\\x00\\x00\\x00\\x0bhello world\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 850605591703289568,
      "kind": "Function",
      "name": "read_single_frame_multi_packet_wait",
      "signature": "fn # [test] fn read_single_frame_multi_packet_wait () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09abc\") , Poll :: Pending , data (b\"defghi\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_pending ! (io) ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 9142304951091349333,
      "kind": "Function",
      "name": "read_multi_frame_multi_packet_wait",
      "signature": "fn # [test] fn read_multi_frame_multi_packet_wait () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09abc\") , Poll :: Pending , data (b\"defghi\") , Poll :: Pending , data (b\"\\x00\\x00\\x00\\x0312\") , Poll :: Pending , data (b\"3\\x00\\x00\\x00\\x0bhello world\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_next_pending ! (io) ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 14249276389337745064,
      "kind": "Function",
      "name": "read_incomplete_head",
      "signature": "fn # [test] fn read_incomplete_head () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 13019289292494900255,
      "kind": "Function",
      "name": "read_incomplete_head_multi",
      "signature": "fn # [test] fn read_incomplete_head_multi () { let io = FramedRead :: new (mock ! { Poll :: Pending , data (b\"\\x00\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 6908738014107124194,
      "kind": "Function",
      "name": "read_incomplete_payload",
      "signature": "fn # [test] fn read_incomplete_payload () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09ab\") , Poll :: Pending , data (b\"cd\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 10159570947348978885,
      "kind": "Function",
      "name": "read_max_frame_len",
      "signature": "fn # [test] fn read_max_frame_len () { let io = length_delimited :: Builder :: new () . max_frame_length (5) . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 5852706604463920133,
      "kind": "Function",
      "name": "read_update_max_frame_len_at_rest",
      "signature": "fn # [test] fn read_update_max_frame_len_at_rest () { let io = length_delimited :: Builder :: new () . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; io . decoder_mut () . set_max_frame_length (5) ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 7077233122647435547,
      "kind": "Function",
      "name": "read_update_max_frame_len_in_flight",
      "signature": "fn # [test] fn read_update_max_frame_len_in_flight () { let io = length_delimited :: Builder :: new () . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcd\") , Poll :: Pending , data (b\"efghi\") , data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_pending ! (io) ; io . decoder_mut () . set_max_frame_length (5) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_err ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 2556794560298110381,
      "kind": "Function",
      "name": "read_one_byte_length_field",
      "signature": "fn # [test] fn read_one_byte_length_field () { let io = length_delimited :: Builder :: new () . length_field_length (1) . new_read (mock ! { data (b\"\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 13128782725244081629,
      "kind": "Function",
      "name": "read_header_offset",
      "signature": "fn # [test] fn read_header_offset () { let io = length_delimited :: Builder :: new () . length_field_length (2) . length_field_offset (4) . new_read (mock ! { data (b\"zzzz\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 9875257187380586520,
      "kind": "Function",
      "name": "read_single_multi_frame_one_packet_skip_none_adjusted",
      "signature": "fn # [test] fn read_single_multi_frame_one_packet_skip_none_adjusted () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"xx\\x00\\x09abcdefghi\") ; d . extend_from_slice (b\"yy\\x00\\x03123\") ; d . extend_from_slice (b\"zz\\x00\\x0bhello world\") ; let io = length_delimited :: Builder :: new () . length_field_length (2) . length_field_offset (2) . num_skip (0) . length_adjustment (4) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"xx\\x00\\x09abcdefghi\") ; assert_next_eq ! (io , b\"yy\\x00\\x03123\") ; assert_next_eq ! (io , b\"zz\\x00\\x0bhello world\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 12372829054818352309,
      "kind": "Function",
      "name": "read_single_frame_length_adjusted",
      "signature": "fn # [test] fn read_single_frame_length_adjusted () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x00\\x0b\\x0cHello world\") ; let io = length_delimited :: Builder :: new () . length_field_offset (0) . length_field_length (3) . length_adjustment (0) . num_skip (4) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"Hello world\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 7380160368858674629,
      "kind": "Function",
      "name": "read_single_multi_frame_one_packet_length_includes_head",
      "signature": "fn # [test] fn read_single_multi_frame_one_packet_length_includes_head () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x0babcdefghi\") ; d . extend_from_slice (b\"\\x00\\x05123\") ; d . extend_from_slice (b\"\\x00\\x0dhello world\") ; let io = length_delimited :: Builder :: new () . length_field_length (2) . length_adjustment (- 2) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 7228422041309536157,
      "kind": "Function",
      "name": "write_single_frame_length_adjusted",
      "signature": "fn # [test] fn write_single_frame_length_adjusted () { let io = length_delimited :: Builder :: new () . length_adjustment (- 2) . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 652001128503029874,
      "kind": "Function",
      "name": "write_nothing_yields_nothing",
      "signature": "fn # [test] fn write_nothing_yields_nothing () { let io = FramedWrite :: new (mock ! () , LengthDelimitedCodec :: new ()) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . poll_flush (cx)) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 3247421729598069419,
      "kind": "Function",
      "name": "write_single_frame_one_packet",
      "signature": "fn # [test] fn write_single_frame_one_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 13648000146662256015,
      "kind": "Function",
      "name": "write_single_multi_frame_one_packet",
      "signature": "fn # [test] fn write_single_multi_frame_one_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , data (b\"\\x00\\x00\\x00\\x03\") , data (b\"123\") , data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"hello world\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"123\"))) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"hello world\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 5615057477144445030,
      "kind": "Function",
      "name": "write_single_multi_frame_multi_packet",
      "signature": "fn # [test] fn write_single_multi_frame_multi_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , flush () , data (b\"\\x00\\x00\\x00\\x03\") , data (b\"123\") , flush () , data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"hello world\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"123\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"hello world\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 17458464540735338618,
      "kind": "Function",
      "name": "write_single_frame_would_block",
      "signature": "fn # [test] fn write_single_frame_would_block () { let io = FramedWrite :: new (mock ! { Poll :: Pending , data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09\") , data (b\"abcdefghi\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 1085188346672587958,
      "kind": "Function",
      "name": "write_single_frame_little_endian",
      "signature": "fn # [test] fn write_single_frame_little_endian () { let io = length_delimited :: Builder :: new () . little_endian () . new_write (mock ! { data (b\"\\x09\\x00\\x00\\x00\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 14030438295416841531,
      "kind": "Function",
      "name": "write_single_frame_with_short_length_field",
      "signature": "fn # [test] fn write_single_frame_with_short_length_field () { let io = length_delimited :: Builder :: new () . length_field_length (1) . new_write (mock ! { data (b\"\\x09\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 1869635652477862107,
      "kind": "Function",
      "name": "write_max_frame_len",
      "signature": "fn # [test] fn write_max_frame_len () { let io = length_delimited :: Builder :: new () . max_frame_length (5) . new_write (mock ! { }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 7073388825390101681,
      "kind": "Function",
      "name": "write_update_max_frame_len_at_rest",
      "signature": "fn # [test] fn write_update_max_frame_len_at_rest () { let io = length_delimited :: Builder :: new () . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x06\") , data (b\"abcdef\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; io . encoder_mut () . set_max_frame_length (5) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 524050496143620529,
      "kind": "Function",
      "name": "write_update_max_frame_len_in_flight",
      "signature": "fn # [test] fn write_update_max_frame_len_in_flight () { let io = length_delimited :: Builder :: new () . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x06\") , data (b\"ab\") , Poll :: Pending , data (b\"cdef\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; io . encoder_mut () . set_max_frame_length (5) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 13311412013169471697,
      "kind": "Function",
      "name": "write_zero",
      "signature": "fn # [test] fn write_zero () { let io = length_delimited :: Builder :: new () . new_write (mock ! { }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_ready_err ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 11651212366536837362,
      "kind": "Function",
      "name": "encode_overflow",
      "signature": "fn # [test] fn encode_overflow () { let mut codec = length_delimited :: Builder :: new () . new_codec () ; let mut buf = BytesMut :: with_capacity (1024) ; let some_as = std :: iter :: repeat (b'a') . take (1024) . collect :: < Vec < _ > > () ; buf . put_slice (& some_as [..]) ; codec . encode (Bytes :: from (\"hello\") , & mut buf) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 774434936534385380,
      "kind": "Function",
      "name": "frame_does_not_fit",
      "signature": "fn # [test] fn frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . max_frame_length (256) . new_codec () ; assert_eq ! (codec . max_frame_length () , 255) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 9497355405193795943,
      "kind": "Function",
      "name": "neg_adjusted_frame_does_not_fit",
      "signature": "fn # [test] fn neg_adjusted_frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . length_adjustment (- 1) . new_codec () ; assert_eq ! (codec . max_frame_length () , 254) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 16850354866186332205,
      "kind": "Function",
      "name": "pos_adjusted_frame_does_not_fit",
      "signature": "fn # [test] fn pos_adjusted_frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . length_adjustment (1) . new_codec () ; assert_eq ! (codec . max_frame_length () , 256) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 10799929160902455633,
      "kind": "Function",
      "name": "max_allowed_frame_fits",
      "signature": "fn # [test] fn max_allowed_frame_fits () { let codec = LengthDelimitedCodec :: builder () . length_field_length (std :: mem :: size_of :: < usize > ()) . max_frame_length (usize :: MAX) . new_codec () ; assert_eq ! (codec . max_frame_length () , usize :: MAX) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 10576104332281890488,
      "kind": "Function",
      "name": "smaller_frame_len_not_adjusted",
      "signature": "fn # [test] fn smaller_frame_len_not_adjusted () { let codec = LengthDelimitedCodec :: builder () . max_frame_length (10) . length_field_length (std :: mem :: size_of :: < usize > ()) . new_codec () ; assert_eq ! (codec . max_frame_length () , 10) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 5799687680160231838,
      "kind": "Function",
      "name": "max_allowed_length_field",
      "signature": "fn # [test] fn max_allowed_length_field () { let codec = LengthDelimitedCodec :: builder () . length_field_length (8) . max_frame_length (usize :: MAX) . new_codec () ; assert_eq ! (codec . max_frame_length () , usize :: MAX) ; } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 15708417976827527164,
      "kind": "Function",
      "name": "data",
      "signature": "fn fn data (bytes : & [u8]) -> Poll < io :: Result < Op > > { Poll :: Ready (Ok (bytes . into ())) } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 17416146395641228098,
      "kind": "Function",
      "name": "flush",
      "signature": "fn fn flush () -> Poll < io :: Result < Op > > { Poll :: Ready (Ok (Op :: Flush)) } . sig",
      "file_path": "tokio-util/tests/length_delimited.rs",
      "line": 0
    },
    {
      "hash": 6689509973815690932,
      "kind": "Function",
      "name": "simple",
      "signature": "fn # [tokio :: test] async fn simple () { let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; for i in 1 ..= 3i32 { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (i) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; drop (recv) ; send . send_item (42) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 576338647311211214,
      "kind": "Function",
      "name": "simple_ref",
      "signature": "fn # [tokio :: test] async fn simple_ref () { let v = [1 , 2 , 3i32] ; let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; for vi in v . iter () { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (vi) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (* recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; drop (recv) ; send . send_item (& 42) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 5170370941987343456,
      "kind": "Function",
      "name": "repeated_poll_reserve",
      "signature": "fn # [tokio :: test] async fn repeated_poll_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 16113743016516275021,
      "kind": "Function",
      "name": "abort_send",
      "signature": "fn # [tokio :: test] async fn abort_send () { let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; let send2 = send . get_ref () . cloned () . unwrap () ; for i in 1 ..= 3i32 { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (i) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; let mut send2_send = spawn (send2 . send (5)) ; assert_pending ! (send2_send . poll ()) ; assert ! (send . abort_send ()) ; assert ! (send2_send . is_woken ()) ; assert_ready_ok ! (send2_send . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 2) ; assert_eq ! (recv . recv () . await . unwrap () , 3) ; assert_eq ! (recv . recv () . await . unwrap () , 5) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 3434879446692906515,
      "kind": "Function",
      "name": "close_sender_last",
      "signature": "fn # [tokio :: test] async fn close_sender_last () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 12519579115778541957,
      "kind": "Function",
      "name": "close_sender_not_last",
      "signature": "fn # [tokio :: test] async fn close_sender_not_last () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let send2 = send . get_ref () . cloned () . unwrap () ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (! recv_task . is_woken ()) ; assert_pending ! (recv_task . poll ()) ; drop (send2) ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 1300836657669239076,
      "kind": "Function",
      "name": "close_sender_before_reserve",
      "signature": "fn # [tokio :: test] async fn close_sender_before_reserve () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 18025709977003289550,
      "kind": "Function",
      "name": "close_sender_after_pending_reserve",
      "signature": "fn # [tokio :: test] async fn close_sender_after_pending_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert ! (recv_task . is_woken ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; drop (reserve) ; send . close () ; assert ! (send . is_closed ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 7586398771123111886,
      "kind": "Function",
      "name": "close_sender_after_successful_reserve",
      "signature": "fn # [tokio :: test] async fn close_sender_after_successful_reserve () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; drop (reserve) ; send . close () ; assert ! (send . is_closed ()) ; assert ! (! recv_task . is_woken ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 3885116132007410603,
      "kind": "Function",
      "name": "abort_send_after_pending_reserve",
      "signature": "fn # [tokio :: test] async fn abort_send_after_pending_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; assert ! (! send . abort_send ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert ! (send . abort_send ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 13998471343828696278,
      "kind": "Function",
      "name": "abort_send_after_successful_reserve",
      "signature": "fn # [tokio :: test] async fn abort_send_after_successful_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 1) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; assert ! (send . abort_send ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 1) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 15303838865579878112,
      "kind": "Function",
      "name": "closed_when_receiver_drops",
      "signature": "fn # [tokio :: test] async fn closed_when_receiver_drops () { let (send , _) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 14769261419963028944,
      "kind": "Function",
      "name": "start_send_panics_when_idle",
      "signature": "fn # [should_panic] # [test] fn start_send_panics_when_idle () { let (send , _) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; send . send_item (1) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 2878737543824998830,
      "kind": "Function",
      "name": "start_send_panics_when_acquiring",
      "signature": "fn # [should_panic] # [test] fn start_send_panics_when_acquiring () { let (send , _) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; send . send_item (2) . unwrap () ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 6139225313370036070,
      "kind": "Function",
      "name": "sink_send_then_flush",
      "signature": "fn # [test] fn sink_send_then_flush () { let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (())) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; let mut flush = spawn (poll_fn (| cx | send . poll_flush_unpin (cx))) ; assert_ready_ok ! (flush . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; assert_ready_eq ! (recv_task . poll () , Some (())) ; assert ! (ready . is_woken ()) ; assert_ready_ok ! (ready . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 12452462563510245717,
      "kind": "Function",
      "name": "sink_send_then_close",
      "signature": "fn # [test] fn sink_send_then_close () { let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (1)) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; assert ! (recv_task . is_woken ()) ; assert_ready_eq ! (recv_task . poll () , Some (1)) ; assert ! (ready . is_woken ()) ; assert_ready_ok ! (ready . poll ()) ; drop (recv_task) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; assert_ok ! (send . start_send_unpin (2)) ; let mut close = spawn (poll_fn (| cx | send . poll_close_unpin (cx))) ; assert_ready_ok ! (close . poll ()) ; assert ! (recv_task . is_woken ()) ; assert_ready_eq ! (recv_task . poll () , Some (2)) ; drop (recv_task) ; let mut recv_task = spawn (recv . recv ()) ; assert_ready_eq ! (recv_task . poll () , None) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 11582484778614674593,
      "kind": "Function",
      "name": "sink_send_ref",
      "signature": "fn # [test] fn sink_send_ref () { let data = \"data\" . to_owned () ; let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (data . as_str ())) ; let mut flush = spawn (poll_fn (| cx | send . poll_flush_unpin (cx))) ; assert_ready_ok ! (flush . poll ()) ; assert_ready_eq ! (recv_task . poll () , Some (\"data\")) ; } . sig",
      "file_path": "tokio-util/tests/mpsc.rs",
      "line": 0
    },
    {
      "hash": 15833093580329281100,
      "kind": "Function",
      "name": "sync_bridge_new_panic_caller",
      "signature": "fn # [test] fn sync_bridge_new_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = SyncIoBridge :: new (tokio :: io :: empty ()) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 9851258781701238509,
      "kind": "Function",
      "name": "poll_sender_send_item_panic_caller",
      "signature": "fn # [test] fn poll_sender_send_item_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (send , _) = channel :: < u32 > (3) ; let mut send = PollSender :: new (send) ; let _ = send . send_item (42) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 11531305800258458052,
      "kind": "Function",
      "name": "local_pool_handle_new_panic_caller",
      "signature": "fn # [test] fn local_pool_handle_new_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = LocalPoolHandle :: new (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 18433927505150177346,
      "kind": "Function",
      "name": "local_pool_handle_spawn_pinned_by_idx_panic_caller",
      "signature": "fn # [test] fn local_pool_handle_spawn_pinned_by_idx_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let handle = LocalPoolHandle :: new (2) ; handle . spawn_pinned_by_idx (| | async { \"test\" } , 3) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 15266388236970126283,
      "kind": "Function",
      "name": "delay_queue_insert_at_panic_caller",
      "signature": "fn # [test] fn delay_queue_insert_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let _k = queue . insert_at (\"1\" , Instant :: now () + Duration :: from_millis (MAX_DURATION_MS + 1) ,) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 8697601979912094996,
      "kind": "Function",
      "name": "delay_queue_insert_panic_caller",
      "signature": "fn # [test] fn delay_queue_insert_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let _k = queue . insert (\"1\" , Duration :: from_millis (MAX_DURATION_MS + 1)) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 17515117895397371362,
      "kind": "Function",
      "name": "delay_queue_remove_panic_caller",
      "signature": "fn # [test] fn delay_queue_remove_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . remove (& key) ; queue . remove (& key) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 16869351064765658083,
      "kind": "Function",
      "name": "delay_queue_reset_at_panic_caller",
      "signature": "fn # [test] fn delay_queue_reset_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . reset_at (& key , Instant :: now () + Duration :: from_millis (MAX_DURATION_MS + 1) ,) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 1271530874501264242,
      "kind": "Function",
      "name": "delay_queue_reset_panic_caller",
      "signature": "fn # [test] fn delay_queue_reset_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . reset (& key , Duration :: from_millis (MAX_DURATION_MS + 1)) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 16968969609162696644,
      "kind": "Function",
      "name": "delay_queue_reserve_panic_caller",
      "signature": "fn # [test] fn delay_queue_reserve_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: < u32 > :: with_capacity (3)) ; queue . reserve ((1 << 30) as usize) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 5058967208896016154,
      "kind": "Function",
      "name": "future_ext_to_panic_caller",
      "signature": "fn # [test] fn future_ext_to_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: { sync :: oneshot , time :: Duration } ; use tokio_util :: future :: FutureExt ; let panic_location_file = test_panic (| | { let (_tx , rx) = oneshot :: channel :: < () > () ; let _res = rx . timeout (Duration :: from_millis (10)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 6398950067593251897,
      "kind": "Function",
      "name": "basic",
      "signature": "fn fn basic () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
      "file_path": "tokio-util/tests/panic.rs",
      "line": 0
    },
    {
      "hash": 5734925266403152308,
      "kind": "Function",
      "name": "semaphore_poll",
      "signature": "fn fn semaphore_poll (sem : & mut PollSemaphore ,) -> tokio_test :: task :: Spawn < impl Future < Output = SemRet > + '_ > { let fut = std :: future :: poll_fn (move | cx | sem . poll_acquire (cx)) ; tokio_test :: task :: spawn (fut) } . sig",
      "file_path": "tokio-util/tests/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 17224370135186896294,
      "kind": "Function",
      "name": "semaphore_poll_many",
      "signature": "fn fn semaphore_poll_many (sem : & mut PollSemaphore , permits : u32 ,) -> tokio_test :: task :: Spawn < impl Future < Output = SemRet > + '_ > { let fut = std :: future :: poll_fn (move | cx | sem . poll_acquire_many (cx , permits)) ; tokio_test :: task :: spawn (fut) } . sig",
      "file_path": "tokio-util/tests/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 11048163459687684898,
      "kind": "Function",
      "name": "it_works",
      "signature": "fn # [tokio :: test] async fn it_works () { let sem = Arc :: new (Semaphore :: new (1)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; let permit = sem . acquire () . await . unwrap () ; let mut poll = semaphore_poll (& mut poll_sem) ; assert ! (poll . poll () . is_pending ()) ; drop (permit) ; assert ! (matches ! (poll . poll () , Poll :: Ready (Some (_)))) ; drop (poll) ; sem . close () ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 2982337070167663657,
      "kind": "Function",
      "name": "can_acquire_many_permits",
      "signature": "fn # [tokio :: test] async fn can_acquire_many_permits () { let sem = Arc :: new (Semaphore :: new (4)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; let permit1 = semaphore_poll (& mut poll_sem) . poll () ; assert ! (matches ! (permit1 , Poll :: Ready (Some (_)))) ; let permit2 = semaphore_poll_many (& mut poll_sem , 2) . poll () ; assert ! (matches ! (permit2 , Poll :: Ready (Some (_)))) ; assert_eq ! (sem . available_permits () , 1) ; drop (permit2) ; let mut permit4 = semaphore_poll_many (& mut poll_sem , 4) ; assert ! (permit4 . poll () . is_pending ()) ; drop (permit1) ; let permit4 = permit4 . poll () ; assert ! (matches ! (permit4 , Poll :: Ready (Some (_)))) ; assert_eq ! (sem . available_permits () , 0) ; } . sig",
      "file_path": "tokio-util/tests/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 17496093618473695212,
      "kind": "Function",
      "name": "can_poll_different_amounts_of_permits",
      "signature": "fn # [tokio :: test] async fn can_poll_different_amounts_of_permits () { let sem = Arc :: new (Semaphore :: new (4)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_ready ()) ; let permit = sem . acquire_many (4) . await . unwrap () ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_pending ()) ; drop (permit) ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_ready ()) ; } . sig",
      "file_path": "tokio-util/tests/poll_semaphore.rs",
      "line": 0
    },
    {
      "hash": 15805951774413836166,
      "kind": "Function",
      "name": "traits",
      "signature": "fn # [test] # [allow (clippy :: extra_unused_lifetimes)] fn traits < 'a > () { fn assert_traits < T : Send + Sync + Unpin > () { } assert_traits :: < ReusableBoxFuture < 'a , PhantomPinned > > () ; assert_traits :: < ReusableBoxFuture < 'a , Rc < () > > > () ; } . sig",
      "file_path": "tokio-util/tests/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 2634052638336478602,
      "kind": "Function",
      "name": "test_different_futures",
      "signature": "fn # [test] fn test_different_futures () { let fut = async move { 10 } ; assert_eq ! (Layout :: for_value (& fut) . size () , 1) ; let mut b = ReusableBoxFuture :: new (fut) ; assert_eq ! (b . get_pin () . now_or_never () , Some (10)) ; b . try_set (async move { 20 }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (20)) ; b . try_set (async move { 30 }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (30)) ; } . sig",
      "file_path": "tokio-util/tests/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 1747736808339008771,
      "kind": "Function",
      "name": "test_different_sizes",
      "signature": "fn # [test] fn test_different_sizes () { let fut1 = async move { 10 } ; let val = [0u32 ; 1000] ; let fut2 = async move { val [0] } ; let fut3 = ZeroSizedFuture { } ; assert_eq ! (Layout :: for_value (& fut1) . size () , 1) ; assert_eq ! (Layout :: for_value (& fut2) . size () , 4004) ; assert_eq ! (Layout :: for_value (& fut3) . size () , 0) ; let mut b = ReusableBoxFuture :: new (fut1) ; assert_eq ! (b . get_pin () . now_or_never () , Some (10)) ; b . set (fut2) ; assert_eq ! (b . get_pin () . now_or_never () , Some (0)) ; b . set (fut3) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; } . sig",
      "file_path": "tokio-util/tests/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 1541483917230004979,
      "kind": "Struct",
      "name": "ZeroSizedFuture",
      "signature": "struct ZeroSizedFuture",
      "file_path": "tokio-util/tests/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 10665542815931152619,
      "kind": "Function",
      "name": "test_zero_sized",
      "signature": "fn # [test] fn test_zero_sized () { let fut = ZeroSizedFuture { } ; assert_eq ! (Layout :: for_value (& fut) . size () , 0) ; let mut b = ReusableBoxFuture :: new (fut) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; b . try_set (ZeroSizedFuture { }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; } . sig",
      "file_path": "tokio-util/tests/reusable_box.rs",
      "line": 0
    },
    {
      "hash": 3019718061336029443,
      "kind": "Function",
      "name": "can_spawn_not_send_future",
      "signature": "fn # [doc = \" Simple test of running a !Send future via spawn_pinned\"] # [tokio :: test] async fn can_spawn_not_send_future () { let pool = task :: LocalPoolHandle :: new (1) ; let output = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test\") ; async move { local_data . to_string () } }) . await . unwrap () ; assert_eq ! (output , \"test\") ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 17477013507372483104,
      "kind": "Function",
      "name": "can_drop_future_and_still_get_output",
      "signature": "fn # [doc = \" Dropping the join handle still lets the task execute\"] # [test] fn can_drop_future_and_still_get_output () { let pool = task :: LocalPoolHandle :: new (1) ; let (sender , receiver) = std :: sync :: mpsc :: channel () ; pool . spawn_pinned (move | | { let local_data = Rc :: new (\"test\") ; async move { let _ = sender . send (local_data . to_string ()) ; } }) ; assert_eq ! (receiver . recv () , Ok (\"test\" . to_string ())) ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 8520910670796977508,
      "kind": "Function",
      "name": "cannot_create_zero_sized_pool",
      "signature": "fn # [test] # [should_panic (expected = \"assertion failed: pool_size > 0\")] fn cannot_create_zero_sized_pool () { let _pool = task :: LocalPoolHandle :: new (0) ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 591767881587000957,
      "kind": "Function",
      "name": "can_spawn_multiple_futures",
      "signature": "fn # [doc = \" We should be able to spawn multiple futures onto the pool at the same time.\"] # [tokio :: test] async fn can_spawn_multiple_futures () { let pool = task :: LocalPoolHandle :: new (2) ; let join_handle1 = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test1\") ; async move { local_data . to_string () } }) ; let join_handle2 = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test2\") ; async move { local_data . to_string () } }) ; assert_eq ! (join_handle1 . await . unwrap () , \"test1\") ; assert_eq ! (join_handle2 . await . unwrap () , \"test2\") ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 16517661797795361111,
      "kind": "Function",
      "name": "task_panic_propagates",
      "signature": "fn # [doc = \" A panic in the spawned task causes the join handle to return an error.\"] # [doc = \" But, you can continue to spawn tasks.\"] # [tokio :: test] # [cfg (panic = \"unwind\")] async fn task_panic_propagates () { let pool = task :: LocalPoolHandle :: new (1) ; let join_handle = pool . spawn_pinned (| | async { panic ! (\"Test panic\") ; }) ; let result = join_handle . await ; assert ! (result . is_err ()) ; let error = result . unwrap_err () ; assert ! (error . is_panic ()) ; let panic_str = error . into_panic () . downcast :: < & 'static str > () . unwrap () ; assert_eq ! (* panic_str , \"Test panic\") ; let join_handle = pool . spawn_pinned (| | async { \"test\" }) ; let result = join_handle . await ; assert ! (result . is_ok ()) ; assert_eq ! (result . unwrap () , \"test\") ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 15400170864612608759,
      "kind": "Function",
      "name": "callback_panic_does_not_kill_worker",
      "signature": "fn # [doc = \" A panic during task creation causes the join handle to return an error.\"] # [doc = \" But, you can continue to spawn tasks.\"] # [tokio :: test] # [cfg (panic = \"unwind\")] async fn callback_panic_does_not_kill_worker () { let pool = task :: LocalPoolHandle :: new (1) ; let join_handle = pool . spawn_pinned (| | { panic ! (\"Test panic\") ; # [allow (unreachable_code)] async { } }) ; let result = join_handle . await ; assert ! (result . is_err ()) ; let error = result . unwrap_err () ; assert ! (error . is_panic ()) ; let panic_str = error . into_panic () . downcast :: < & 'static str > () . unwrap () ; assert_eq ! (* panic_str , \"Test panic\") ; let join_handle = pool . spawn_pinned (| | async { \"test\" }) ; let result = join_handle . await ; assert ! (result . is_ok ()) ; assert_eq ! (result . unwrap () , \"test\") ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 8317426591883210341,
      "kind": "Function",
      "name": "task_cancellation_propagates",
      "signature": "fn # [doc = \" Canceling the task via the returned join handle cancels the spawned task\"] # [doc = \" (which has a different, internal join handle).\"] # [tokio :: test] async fn task_cancellation_propagates () { let pool = task :: LocalPoolHandle :: new (1) ; let notify_dropped = Arc :: new (()) ; let weak_notify_dropped = Arc :: downgrade (& notify_dropped) ; let (start_sender , start_receiver) = tokio :: sync :: oneshot :: channel () ; let (drop_sender , drop_receiver) = tokio :: sync :: oneshot :: channel :: < () > () ; let join_handle = pool . spawn_pinned (| | async move { let _drop_sender = drop_sender ; let _notify_dropped = notify_dropped ; let _ = start_sender . send (()) ; futures :: future :: pending :: < () > () . await ; }) ; let _ = start_receiver . await ; join_handle . abort () ; let _ = drop_receiver . await ; assert ! (weak_notify_dropped . upgrade () . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 12865231378806974333,
      "kind": "Function",
      "name": "tasks_are_balanced",
      "signature": "fn # [doc = \" Tasks should be given to the least burdened worker. When spawning two tasks\"] # [doc = \" on a pool with two empty workers the tasks should be spawned on separate\"] # [doc = \" workers.\"] # [tokio :: test] async fn tasks_are_balanced () { let pool = task :: LocalPoolHandle :: new (2) ; let (start_sender1 , start_receiver1) = tokio :: sync :: oneshot :: channel () ; let (end_sender1 , end_receiver1) = tokio :: sync :: oneshot :: channel () ; let join_handle1 = pool . spawn_pinned (| | async move { let _ = start_sender1 . send (()) ; let _ = end_receiver1 . await ; std :: thread :: current () . id () }) ; let _ = start_receiver1 . await ; let (start_sender2 , start_receiver2) = tokio :: sync :: oneshot :: channel () ; let join_handle2 = pool . spawn_pinned (| | async move { let _ = start_sender2 . send (()) ; std :: thread :: current () . id () }) ; let _ = start_receiver2 . await ; let _ = end_sender1 . send (()) ; let thread_id1 = join_handle1 . await . unwrap () ; let thread_id2 = join_handle2 . await . unwrap () ; assert_ne ! (thread_id1 , thread_id2) ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 4485661901535036689,
      "kind": "Function",
      "name": "spawn_by_idx",
      "signature": "fn # [tokio :: test] async fn spawn_by_idx () { let pool = task :: LocalPoolHandle :: new (3) ; let barrier = Arc :: new (Barrier :: new (4)) ; let barrier1 = barrier . clone () ; let barrier2 = barrier . clone () ; let barrier3 = barrier . clone () ; let handle1 = pool . spawn_pinned_by_idx (| | async move { barrier1 . wait () . await ; std :: thread :: current () . id () } , 0 ,) ; pool . spawn_pinned_by_idx (| | async move { barrier2 . wait () . await ; std :: thread :: current () . id () } , 0 ,) ; let handle2 = pool . spawn_pinned_by_idx (| | async move { barrier3 . wait () . await ; std :: thread :: current () . id () } , 1 ,) ; let loads = pool . get_task_loads_for_each_worker () ; barrier . wait () . await ; assert_eq ! (loads [0] , 2) ; assert_eq ! (loads [1] , 1) ; assert_eq ! (loads [2] , 0) ; let thread_id1 = handle1 . await . unwrap () ; let thread_id2 = handle2 . await . unwrap () ; assert_ne ! (thread_id1 , thread_id2) ; } . sig",
      "file_path": "tokio-util/tests/spawn_pinned.rs",
      "line": 0
    },
    {
      "hash": 13740541441778541677,
      "kind": "Function",
      "name": "cancel_token",
      "signature": "fn # [test] fn cancel_token () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; assert ! (! token . is_cancelled ()) ; let wait_fut = token . cancelled () ; pin ! (wait_fut) ; assert_eq ! (Poll :: Pending , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; let wait_fut_2 = token . cancelled () ; pin ! (wait_fut_2) ; token . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , wait_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 9960841214974890415,
      "kind": "Function",
      "name": "cancel_token_owned",
      "signature": "fn # [test] fn cancel_token_owned () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; assert ! (! token . is_cancelled ()) ; let wait_fut = token . clone () . cancelled_owned () ; pin ! (wait_fut) ; assert_eq ! (Poll :: Pending , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; let wait_fut_2 = token . clone () . cancelled_owned () ; pin ! (wait_fut_2) ; token . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , wait_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2721476079321842441,
      "kind": "Function",
      "name": "cancel_token_owned_drop_test",
      "signature": "fn # [test] fn cancel_token_owned_drop_test () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let future = token . cancelled_owned () ; pin ! (future) ; assert_eq ! (Poll :: Pending , future . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2825628056857927313,
      "kind": "Function",
      "name": "cancel_child_token_through_parent",
      "signature": "fn # [test] fn cancel_child_token_through_parent () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let child_token = token . child_token () ; assert ! (! child_token . is_cancelled ()) ; let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 2) ; assert ! (token . is_cancelled ()) ; assert ! (child_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 11727943331975437712,
      "kind": "Function",
      "name": "cancel_grandchild_token_through_parent_if_child_was_dropped",
      "signature": "fn # [test] fn cancel_grandchild_token_through_parent_if_child_was_dropped () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let intermediate_token = token . child_token () ; let child_token = intermediate_token . child_token () ; drop (intermediate_token) ; assert ! (! child_token . is_cancelled ()) ; let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 2) ; assert ! (token . is_cancelled ()) ; assert ! (child_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 5693242104875080821,
      "kind": "Function",
      "name": "cancel_child_token_without_parent",
      "signature": "fn # [test] fn cancel_child_token_without_parent () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let child_token_1 = token . child_token () ; let child_fut = child_token_1 . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; child_token_1 . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (! token . is_cancelled ()) ; assert ! (child_token_1 . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; let child_token_2 = token . child_token () ; let child_fut_2 = child_token_2 . cancelled () ; pin ! (child_fut_2) ; assert_eq ! (Poll :: Pending , child_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; token . cancel () ; assert_eq ! (wake_counter , 3) ; assert ! (token . is_cancelled ()) ; assert ! (child_token_2 . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 17622973880731657133,
      "kind": "Function",
      "name": "create_child_token_after_parent_was_cancelled",
      "signature": "fn # [test] fn create_child_token_after_parent_was_cancelled () { for drop_child_first in [true , false] . iter () . cloned () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let child_token = token . child_token () ; assert ! (child_token . is_cancelled ()) ; { let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; } if drop_child_first { drop (child_token) ; drop (token) ; } else { drop (token) ; drop (child_token) ; } } } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 12853203799542331007,
      "kind": "Function",
      "name": "drop_multiple_child_tokens",
      "signature": "fn # [test] fn drop_multiple_child_tokens () { for drop_first_child_first in & [true , false] { let token = CancellationToken :: new () ; let mut child_tokens = [None , None , None] ; for child in & mut child_tokens { * child = Some (token . child_token ()) ; } assert ! (! token . is_cancelled ()) ; assert ! (! child_tokens [0] . as_ref () . unwrap () . is_cancelled ()) ; for i in 0 .. child_tokens . len () { if * drop_first_child_first { child_tokens [i] = None ; } else { child_tokens [child_tokens . len () - 1 - i] = None ; } assert ! (! token . is_cancelled ()) ; } drop (token) ; } } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 13107161732158543986,
      "kind": "Function",
      "name": "cancel_only_all_descendants",
      "signature": "fn # [test] fn cancel_only_all_descendants () { let (waker , wake_counter) = new_count_waker () ; let parent_token = CancellationToken :: new () ; let token = parent_token . child_token () ; let sibling_token = parent_token . child_token () ; let child1_token = token . child_token () ; let child2_token = token . child_token () ; let grandchild_token = child1_token . child_token () ; let grandchild2_token = child1_token . child_token () ; let great_grandchild_token = grandchild_token . child_token () ; assert ! (! parent_token . is_cancelled ()) ; assert ! (! token . is_cancelled ()) ; assert ! (! sibling_token . is_cancelled ()) ; assert ! (! child1_token . is_cancelled ()) ; assert ! (! child2_token . is_cancelled ()) ; assert ! (! grandchild_token . is_cancelled ()) ; assert ! (! grandchild2_token . is_cancelled ()) ; assert ! (! great_grandchild_token . is_cancelled ()) ; let parent_fut = parent_token . cancelled () ; let fut = token . cancelled () ; let sibling_fut = sibling_token . cancelled () ; let child1_fut = child1_token . cancelled () ; let child2_fut = child2_token . cancelled () ; let grandchild_fut = grandchild_token . cancelled () ; let grandchild2_fut = grandchild2_token . cancelled () ; let great_grandchild_fut = great_grandchild_token . cancelled () ; pin ! (parent_fut) ; pin ! (fut) ; pin ! (sibling_fut) ; pin ! (child1_fut) ; pin ! (child2_fut) ; pin ! (grandchild_fut) ; pin ! (grandchild2_fut) ; pin ! (great_grandchild_fut) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , sibling_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , child1_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , child2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , grandchild2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , great_grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 6) ; assert ! (! parent_token . is_cancelled ()) ; assert ! (token . is_cancelled ()) ; assert ! (! sibling_token . is_cancelled ()) ; assert ! (child1_token . is_cancelled ()) ; assert ! (child2_token . is_cancelled ()) ; assert ! (grandchild_token . is_cancelled ()) ; assert ! (grandchild2_token . is_cancelled ()) ; assert ! (great_grandchild_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , child1_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , child2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , grandchild2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , great_grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 6) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 5848781694192752063,
      "kind": "Function",
      "name": "drop_parent_before_child_tokens",
      "signature": "fn # [test] fn drop_parent_before_child_tokens () { let token = CancellationToken :: new () ; let child1 = token . child_token () ; let child2 = token . child_token () ; drop (token) ; assert ! (! child1 . is_cancelled ()) ; drop (child1) ; drop (child2) ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2347691176088028624,
      "kind": "Function",
      "name": "derives_send_sync",
      "signature": "fn # [test] fn derives_send_sync () { fn assert_send < T : Send > () { } fn assert_sync < T : Sync > () { } assert_send :: < CancellationToken > () ; assert_sync :: < CancellationToken > () ; assert_send :: < WaitForCancellationFuture < 'static > > () ; assert_sync :: < WaitForCancellationFuture < 'static > > () ; } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 8833464231249503194,
      "kind": "Function",
      "name": "run_until_cancelled_test",
      "signature": "fn # [test] fn run_until_cancelled_test () { let (waker , _) = new_count_waker () ; { let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (std :: future :: pending :: < () > ()) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; token . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let (tx , rx) = oneshot :: channel :: < () > () ; let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (async move { rx . await . unwrap () ; 42 }) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; tx . send (()) . unwrap () ; assert_eq ! (Poll :: Ready (Some (42)) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (async { panic ! (\"fut polled after cancellation\") }) ; pin ! (fut) ; token . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 8779620695066840160,
      "kind": "Function",
      "name": "run_until_cancelled_owned_test",
      "signature": "fn # [test] fn run_until_cancelled_owned_test () { let (waker , _) = new_count_waker () ; { let token = CancellationToken :: new () ; let to_cancel = token . clone () ; let takes_ownership = move | token : CancellationToken | { token . run_until_cancelled_owned (std :: future :: pending :: < () > ()) } ; let fut = takes_ownership (token) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; to_cancel . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let (tx , rx) = oneshot :: channel :: < () > () ; let token = CancellationToken :: new () ; let takes_ownership = move | token : CancellationToken , rx : oneshot :: Receiver < () > | { token . run_until_cancelled_owned (async move { rx . await . unwrap () ; 42 }) } ; let fut = takes_ownership (token , rx) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; tx . send (()) . unwrap () ; assert_eq ! (Poll :: Ready (Some (42)) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } } . sig",
      "file_path": "tokio-util/tests/sync_cancellation_token.rs",
      "line": 0
    },
    {
      "hash": 2984088464906261936,
      "kind": "Function",
      "name": "test_with_sleep",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_with_sleep () { let mut map = JoinMap :: new () ; for i in 0 .. 10 { map . spawn (i , async move { i }) ; assert_eq ! (map . len () , 1 + i) ; } map . detach_all () ; assert_eq ! (map . len () , 0) ; assert ! (map . join_next () . await . is_none ()) ; for i in 0 .. 10 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; assert_eq ! (map . len () , 1 + i) ; } let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; assert_eq ! (res . expect (\"task should have completed successfully\") , k) ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (map . join_next () . await . is_none ()) ; for i in 0 .. 10 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; } let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; assert_eq ! (res . expect (\"task should have completed successfully\") , k) ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (map . join_next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 11467563380202098172,
      "kind": "Function",
      "name": "test_abort_on_drop",
      "signature": "fn # [tokio :: test] async fn test_abort_on_drop () { let mut map = JoinMap :: new () ; let mut recvs = Vec :: new () ; for i in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; map . spawn (i , async { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (map) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 16288833080653358089,
      "kind": "Function",
      "name": "alternating",
      "signature": "fn # [tokio :: test] async fn alternating () { let mut map = JoinMap :: new () ; assert_eq ! (map . len () , 0) ; map . spawn (1 , async { }) ; assert_eq ! (map . len () , 1) ; map . spawn (2 , async { }) ; assert_eq ! (map . len () , 2) ; for i in 0 .. 16 { let (_ , res) = map . join_next () . await . unwrap () ; assert ! (res . is_ok ()) ; assert_eq ! (map . len () , 1) ; map . spawn (i , async { }) ; assert_eq ! (map . len () , 2) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 8049692356652330741,
      "kind": "Function",
      "name": "test_keys",
      "signature": "fn # [tokio :: test] async fn test_keys () { use std :: collections :: HashSet ; let mut map = JoinMap :: new () ; assert_eq ! (map . len () , 0) ; map . spawn (1 , async { }) ; assert_eq ! (map . len () , 1) ; map . spawn (2 , async { }) ; assert_eq ! (map . len () , 2) ; let keys = map . keys () . collect :: < HashSet < & u32 > > () ; assert ! (keys . contains (& 1)) ; assert ! (keys . contains (& 2)) ; let _ = map . join_next () . await . unwrap () ; let _ = map . join_next () . await . unwrap () ; assert_eq ! (map . len () , 0) ; let keys = map . keys () . collect :: < HashSet < & u32 > > () ; assert ! (keys . is_empty ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 2868725815891088715,
      "kind": "Function",
      "name": "abort_by_key",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_by_key () { let mut map = JoinMap :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; }) ; } for i in 0 .. 16 { if i % 2 != 0 { map . abort (& i) ; } } while let Some ((key , res)) = map . join_next () . await { match res { Ok (()) => { num_completed += 1 ; assert_eq ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } Err (e) => { num_canceled += 1 ; assert ! (e . is_cancelled ()) ; assert_ne ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 13913837728603422490,
      "kind": "Function",
      "name": "abort_by_predicate",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_by_predicate () { let mut map = JoinMap :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; }) ; } map . abort_matching (| key | key % 2 != 0) ; while let Some ((key , res)) = map . join_next () . await { match res { Ok (()) => { num_completed += 1 ; assert_eq ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } Err (e) => { num_canceled += 1 ; assert ! (e . is_cancelled ()) ; assert_ne ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 2069367798330073644,
      "kind": "Function",
      "name": "runtime_gone",
      "signature": "fn # [test] fn runtime_gone () { let mut map = JoinMap :: new () ; { let rt = rt () ; map . spawn_on (\"key\" , async { 1 } , rt . handle ()) ; drop (rt) ; } let (key , res) = rt () . block_on (map . join_next ()) . unwrap () ; assert_eq ! (key , \"key\") ; assert ! (res . unwrap_err () . is_cancelled ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 3374250884377463788,
      "kind": "Function",
      "name": "join_map_coop",
      "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn join_map_coop () { const TASK_NUM : u32 = 1000 ; static SEM : tokio :: sync :: Semaphore = tokio :: sync :: Semaphore :: const_new (0) ; let mut map = JoinMap :: new () ; for i in 0 .. TASK_NUM { map . spawn (i , async move { SEM . add_permits (1) ; i }) ; } let _ = SEM . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; loop { match map . join_next () . now_or_never () { Some (Some ((key , Ok (i)))) => assert_eq ! (key , i) , Some (Some ((key , Err (err)))) => panic ! (\"failed[{key}]: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; continue ; } Some (None) => break , } count += 1 ; } assert ! (coop_count >= 1) ; assert_eq ! (count , TASK_NUM) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 14964291286725777912,
      "kind": "Function",
      "name": "abort_all",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_all () { let mut map : JoinMap < usize , () > = JoinMap :: new () ; for i in 0 .. 5 { map . spawn (i , futures :: future :: pending ()) ; } for i in 5 .. 10 { map . spawn (i , async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; map . abort_all () ; assert_eq ! (map . len () , 10) ; let mut count = 0 ; let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; if let Err (err) = res { assert ! (err . is_cancelled ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert_eq ! (map . len () , 0) ; for was_seen in & seen { assert ! (was_seen) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 15443909698393231324,
      "kind": "Function",
      "name": "duplicate_keys",
      "signature": "fn # [tokio :: test] async fn duplicate_keys () { let mut map = JoinMap :: new () ; map . spawn (1 , async { 1 }) ; map . spawn (1 , async { 2 }) ; assert_eq ! (map . len () , 1) ; let (key , res) = map . join_next () . await . unwrap () ; assert_eq ! (key , 1) ; assert_eq ! (res . unwrap () , 2) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 18078906276336933382,
      "kind": "Function",
      "name": "duplicate_keys2",
      "signature": "fn # [tokio :: test] async fn duplicate_keys2 () { let (send , recv) = oneshot :: channel :: < () > () ; let mut map = JoinMap :: new () ; map . spawn (1 , async { 1 }) ; map . spawn (1 , async { recv . await . unwrap () ; 2 }) ; assert_eq ! (map . len () , 1) ; tokio :: select ! { biased ; res = map . join_next () => match res { Some ((_key , res)) => panic ! (\"Task {res:?} exited.\") , None => panic ! (\"Phantom task completion.\") , } , () = tokio :: task :: yield_now () => { } , } send . send (()) . unwrap () ; let (key , res) = map . join_next () . await . unwrap () ; assert_eq ! (key , 1) ; assert_eq ! (res . unwrap () , 2) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 1572804101859931732,
      "kind": "Function",
      "name": "duplicate_keys_drop",
      "signature": "fn # [cfg_attr (not (panic = \"unwind\") , ignore)] # [tokio :: test] async fn duplicate_keys_drop () { # [derive (Hash , Debug , PartialEq , Eq)] struct Key ; impl Drop for Key { fn drop (& mut self) { panic ! (\"drop called for key\") ; } } let (send , recv) = oneshot :: channel :: < () > () ; let mut map = JoinMap :: new () ; map . spawn (Key , async { recv . await . unwrap () }) ; let _ = std :: panic :: catch_unwind (AssertUnwindSafe (| | map . spawn (Key , async { }))) . unwrap_err () ; let (key , _) = map . join_next () . await . unwrap () ; std :: mem :: forget (key) ; assert ! (send . is_closed ()) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_map.rs",
      "line": 0
    },
    {
      "hash": 14880211632005142186,
      "kind": "Function",
      "name": "test_join_queue_no_spurious_wakeups",
      "signature": "fn # [tokio :: test] async fn test_join_queue_no_spurious_wakeups () { let (tx , rx) = oneshot :: channel :: < () > () ; let mut join_queue = JoinQueue :: new () ; join_queue . spawn (async move { let _ = rx . await ; 42 }) ; let mut join_next = task :: spawn (join_queue . join_next ()) ; assert_pending ! (join_next . poll ()) ; assert ! (! join_next . is_woken ()) ; let _ = tx . send (()) ; yield_now () . await ; assert ! (join_next . is_woken ()) ; let output = assert_ready ! (join_next . poll ()) ; assert_eq ! (output . unwrap () . unwrap () , 42) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 16971691346089363355,
      "kind": "Function",
      "name": "test_join_queue_abort_on_drop",
      "signature": "fn # [tokio :: test] async fn test_join_queue_abort_on_drop () { let mut queue = JoinQueue :: new () ; let mut recvs = Vec :: new () ; for _ in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; queue . spawn (async move { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (queue) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 8754388306208419852,
      "kind": "Function",
      "name": "test_join_queue_alternating",
      "signature": "fn # [tokio :: test] async fn test_join_queue_alternating () { let mut queue = JoinQueue :: new () ; assert_eq ! (queue . len () , 0) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 1) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 2) ; for _ in 0 .. 16 { let res = queue . join_next () . await . unwrap () ; assert ! (res . is_ok ()) ; assert_eq ! (queue . len () , 1) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 2) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 22504495995970753,
      "kind": "Function",
      "name": "test_join_queue_abort_all",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn test_join_queue_abort_all () { let mut queue : JoinQueue < () > = JoinQueue :: new () ; for _ in 0 .. 5 { queue . spawn (futures :: future :: pending ()) ; } for _ in 0 .. 5 { queue . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; queue . abort_all () ; assert_eq ! (queue . len () , 10) ; let mut count = 0 ; while let Some (res) = queue . join_next () . await { if count < 5 { assert ! (res . unwrap_err () . is_cancelled ()) ; } else { assert ! (res . is_ok ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert ! (queue . is_empty ()) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 2054729976891755659,
      "kind": "Function",
      "name": "test_join_queue_join_all",
      "signature": "fn # [tokio :: test] async fn test_join_queue_join_all () { let mut queue = JoinQueue :: new () ; let mut senders = Vec :: new () ; for i in 0 .. 5 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; queue . spawn (async move { let _ = rx . await ; i }) ; } while let Some (tx) = senders . pop () { let _ = tx . send (()) ; } let results = queue . join_all () . await ; assert_eq ! (results , vec ! [0 , 1 , 2 , 3 , 4]) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 6341291088498511732,
      "kind": "Function",
      "name": "test_join_queue_shutdown",
      "signature": "fn # [tokio :: test] async fn test_join_queue_shutdown () { let mut queue = JoinQueue :: new () ; let mut senders = Vec :: new () ; for _ in 0 .. 5 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; queue . spawn (async move { let _ = rx . await ; }) ; } queue . shutdown () . await ; assert ! (queue . is_empty ()) ; while let Some (tx) = senders . pop () { assert ! (tx . is_closed ()) ; } } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 5470817545361875056,
      "kind": "Function",
      "name": "test_join_queue_with_manual_abort",
      "signature": "fn # [tokio :: test] async fn test_join_queue_with_manual_abort () { let mut queue = JoinQueue :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; let mut senders = Vec :: new () ; for i in 0 .. 16 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; let abort = queue . spawn (async move { let _ = rx . await ; i }) ; if i % 2 != 0 { abort . abort () ; } } while let Some (tx) = senders . pop () { let _ = tx . send (()) ; } while let Some (res) = queue . join_next () . await { match res { Ok (res) => { assert_eq ! (res , num_completed * 2) ; num_completed += 1 ; } Err (e) => { assert ! (e . is_cancelled ()) ; num_canceled += 1 ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 11155295947297341736,
      "kind": "Function",
      "name": "test_join_queue_join_next_with_id",
      "signature": "fn # [tokio :: test] async fn test_join_queue_join_next_with_id () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut queue = JoinQueue :: new () ; let mut spawned = Vec :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = queue . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . push (handle . id ()) ; } drop (recv) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut joined = Vec :: with_capacity (TASK_NUM as usize) ; while let Some (res) = queue . join_next_with_id () . await { match res { Ok ((id , ())) => { count += 1 ; joined . push (id) ; } Err (err) => panic ! (\"failed: {err}\") , } } assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 3142839635278110694,
      "kind": "Function",
      "name": "test_join_queue_try_join_next",
      "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next () { let mut queue = JoinQueue :: new () ; let (tx1 , rx1) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx1 . await ; }) ; let (tx2 , rx2) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx2 . await ; }) ; let (tx3 , rx3) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx3 . await ; }) ; fn check_try_join_next_is_noop (queue : & mut JoinQueue < () >) { let len = queue . len () ; for _ in 0 .. 5 { assert ! (queue . try_join_next () . is_none ()) ; assert_eq ! (queue . len () , len) ; } } assert_eq ! (queue . len () , 3) ; check_try_join_next_is_noop (& mut queue) ; tx1 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 3) ; assert ! (queue . try_join_next () . is_some ()) ; assert_eq ! (queue . len () , 2) ; check_try_join_next_is_noop (& mut queue) ; tx3 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 2) ; check_try_join_next_is_noop (& mut queue) ; tx2 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 2) ; assert ! (queue . try_join_next () . is_some ()) ; assert_eq ! (queue . len () , 1) ; assert ! (queue . try_join_next () . is_some ()) ; assert ! (queue . is_empty ()) ; check_try_join_next_is_noop (& mut queue) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 2895732191772017824,
      "kind": "Function",
      "name": "test_join_queue_try_join_next_disabled_coop",
      "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next_disabled_coop () { const TASK_NUM : u32 = 1000 ; let sem : std :: sync :: Arc < tokio :: sync :: Semaphore > = std :: sync :: Arc :: new (tokio :: sync :: Semaphore :: new (0)) ; let mut queue = JoinQueue :: new () ; for _ in 0 .. TASK_NUM { let sem = sem . clone () ; queue . spawn (async move { sem . add_permits (1) ; }) ; } let _ = sem . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; while ! queue . is_empty () { match queue . try_join_next () { Some (Ok (())) => count += 1 , Some (Err (err)) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; } } } assert_eq ! (coop_count , 0) ; assert_eq ! (count , TASK_NUM) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 10881294587467559441,
      "kind": "Function",
      "name": "test_join_queue_try_join_next_with_id_disabled_coop",
      "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next_with_id_disabled_coop () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut queue = JoinQueue :: new () ; let mut spawned = Vec :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = queue . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . push (handle . id ()) ; } drop (recv) ; assert ! (queue . try_join_next_with_id () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut coop_count = 0 ; let mut joined = Vec :: with_capacity (TASK_NUM as usize) ; while ! queue . is_empty () { match queue . try_join_next_with_id () { Some (Ok ((id , ()))) => { count += 1 ; joined . push (id) ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; } } } assert_eq ! (coop_count , 0) ; assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
      "file_path": "tokio-util/tests/task_join_queue.rs",
      "line": 0
    },
    {
      "hash": 17006919459487942171,
      "kind": "Function",
      "name": "open_close",
      "signature": "fn # [test] fn open_close () { let tracker = TaskTracker :: new () ; assert ! (! tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . close () ; assert ! (tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . reopen () ; assert ! (! tracker . is_closed ()) ; tracker . reopen () ; assert ! (! tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . close () ; assert ! (tracker . is_closed ()) ; tracker . close () ; assert ! (tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 12105278081255523146,
      "kind": "Function",
      "name": "token_len",
      "signature": "fn # [test] fn token_len () { let tracker = TaskTracker :: new () ; let mut tokens = Vec :: new () ; for i in 0 .. 10 { assert_eq ! (tracker . len () , i) ; tokens . push (tracker . token ()) ; } assert ! (! tracker . is_empty ()) ; assert_eq ! (tracker . len () , 10) ; for (i , token) in tokens . into_iter () . enumerate () { drop (token) ; assert_eq ! (tracker . len () , 9 - i) ; } } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 13763398442425713894,
      "kind": "Function",
      "name": "notify_immediately",
      "signature": "fn # [test] fn notify_immediately () { let tracker = TaskTracker :: new () ; tracker . close () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_ready ! (wait . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 11338728009097466500,
      "kind": "Function",
      "name": "notify_immediately_on_reopen",
      "signature": "fn # [test] fn notify_immediately_on_reopen () { let tracker = TaskTracker :: new () ; tracker . close () ; let mut wait = task :: spawn (tracker . wait ()) ; tracker . reopen () ; assert_ready ! (wait . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 2991193148852815262,
      "kind": "Function",
      "name": "notify_on_close",
      "signature": "fn # [test] fn notify_on_close () { let tracker = TaskTracker :: new () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; tracker . close () ; assert_ready ! (wait . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 6251274551568663229,
      "kind": "Function",
      "name": "notify_on_close_reopen",
      "signature": "fn # [test] fn notify_on_close_reopen () { let tracker = TaskTracker :: new () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; tracker . close () ; tracker . reopen () ; assert_ready ! (wait . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 4642457409362646848,
      "kind": "Function",
      "name": "notify_on_last_task",
      "signature": "fn # [test] fn notify_on_last_task () { let tracker = TaskTracker :: new () ; tracker . close () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; assert_ready ! (wait . poll ()) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 222884855734632170,
      "kind": "Function",
      "name": "notify_on_last_task_respawn",
      "signature": "fn # [test] fn notify_on_last_task_respawn () { let tracker = TaskTracker :: new () ; tracker . close () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; let token2 = tracker . token () ; assert_ready ! (wait . poll ()) ; drop (token2) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 16932612708473353549,
      "kind": "Function",
      "name": "no_notify_on_respawn_if_open",
      "signature": "fn # [test] fn no_notify_on_respawn_if_open () { let tracker = TaskTracker :: new () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; let token2 = tracker . token () ; assert_pending ! (wait . poll ()) ; drop (token2) ; } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 13390643435174371579,
      "kind": "Function",
      "name": "close_during_exit",
      "signature": "fn # [test] fn close_during_exit () { const ITERS : usize = 5 ; for close_spot in 0 ..= ITERS { let tracker = TaskTracker :: new () ; let tokens : Vec < _ > = (0 .. ITERS) . map (| _ | tracker . token ()) . collect () ; let mut wait = task :: spawn (tracker . wait ()) ; for (i , token) in tokens . into_iter () . enumerate () { assert_pending ! (wait . poll ()) ; if i == close_spot { tracker . close () ; assert_pending ! (wait . poll ()) ; } drop (token) ; } if close_spot == ITERS { assert_pending ! (wait . poll ()) ; tracker . close () ; } assert_ready ! (wait . poll ()) ; } } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 4025549435972607147,
      "kind": "Function",
      "name": "notify_many",
      "signature": "fn # [test] fn notify_many () { let tracker = TaskTracker :: new () ; let mut waits : Vec < _ > = (0 .. 10) . map (| _ | task :: spawn (tracker . wait ())) . collect () ; for wait in & mut waits { assert_pending ! (wait . poll ()) ; } tracker . close () ; for wait in & mut waits { assert_ready ! (wait . poll ()) ; } } . sig",
      "file_path": "tokio-util/tests/task_tracker.rs",
      "line": 0
    },
    {
      "hash": 9186722503665109612,
      "kind": "Function",
      "name": "single_immediate_delay",
      "signature": "fn # [tokio :: test] async fn single_immediate_delay () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _key = queue . insert_at (\"foo\" , Instant :: now ()) ; sleep (ms (1)) . await ; assert_ready_some ! (poll ! (queue)) ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 6536854930298246395,
      "kind": "Function",
      "name": "multi_immediate_delays",
      "signature": "fn # [tokio :: test] async fn multi_immediate_delays () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _k = queue . insert_at (\"1\" , Instant :: now ()) ; let _k = queue . insert_at (\"2\" , Instant :: now ()) ; let _k = queue . insert_at (\"3\" , Instant :: now ()) ; sleep (ms (1)) . await ; let mut res = vec ! [] ; while res . len () < 3 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; res . sort_unstable () ; assert_eq ! (\"1\" , res [0]) ; assert_eq ! (\"2\" , res [1]) ; assert_eq ! (\"3\" , res [2]) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 5878660869096222726,
      "kind": "Function",
      "name": "single_short_delay",
      "signature": "fn # [tokio :: test] async fn single_short_delay () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _key = queue . insert_at (\"foo\" , Instant :: now () + ms (5)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (5)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 16390953350958434252,
      "kind": "Function",
      "name": "multi_delay_at_start",
      "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn multi_delay_at_start () { time :: pause () ; let long = 262_144 + 9 * 4096 ; let delays = & [1000 , 2 , 234 , long , 60 , 10] ; let mut queue = task :: spawn (DelayQueue :: new ()) ; for & i in delays { let _key = queue . insert_at (i , Instant :: now () + ms (i)) ; } assert_pending ! (poll ! (queue)) ; assert ! (! queue . is_woken ()) ; let start = Instant :: now () ; for elapsed in 0 .. 1200 { println ! (\"elapsed: {elapsed:?}\") ; let elapsed = elapsed + 1 ; tokio :: time :: sleep_until (start + ms (elapsed)) . await ; if delays . contains (& elapsed) { assert ! (queue . is_woken ()) ; assert_ready ! (poll ! (queue)) ; assert_pending ! (poll ! (queue)) ; } else if queue . is_woken () { let cascade = & [192 , 960] ; assert ! (cascade . contains (& elapsed) , \"elapsed={} dt={:?}\" , elapsed , Instant :: now () - start) ; assert_pending ! (poll ! (queue)) ; } } println ! (\"finished multi_delay_start\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 18031507865760531101,
      "kind": "Function",
      "name": "insert_in_past_fires_immediately",
      "signature": "fn # [tokio :: test] async fn insert_in_past_fires_immediately () { println ! (\"running insert_in_past_fires_immediately\") ; time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (10)) . await ; queue . insert_at (\"foo\" , now) ; assert_ready ! (poll ! (queue)) ; println ! (\"finished insert_in_past_fires_immediately\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 14190326713953252248,
      "kind": "Function",
      "name": "remove_entry",
      "signature": "fn # [tokio :: test] async fn remove_entry () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let key = queue . insert_at (\"foo\" , Instant :: now () + ms (5)) ; assert_pending ! (poll ! (queue)) ; let entry = queue . remove (& key) ; assert_eq ! (entry . into_inner () , \"foo\") ; sleep (ms (10)) . await ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 8842848842281777653,
      "kind": "Function",
      "name": "reset_entry",
      "signature": "fn # [tokio :: test] async fn reset_entry () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now + ms (5)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; queue . reset_at (& key , now + ms (10)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (7)) . await ; assert ! (! queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 10722945538956442107,
      "kind": "Function",
      "name": "reset_much_later",
      "signature": "fn # [tokio :: test] async fn reset_much_later () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (1)) . await ; let key = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; queue . reset_at (& key , now + ms (10)) ; sleep (ms (20)) . await ; assert ! (queue . is_woken ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 16074030068970096773,
      "kind": "Function",
      "name": "reset_twice",
      "signature": "fn # [tokio :: test] async fn reset_twice () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (1)) . await ; let key = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; queue . reset_at (& key , now + ms (50)) ; sleep (ms (20)) . await ; queue . reset_at (& key , now + ms (40)) ; sleep (ms (20)) . await ; assert ! (queue . is_woken ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 883051950328691254,
      "kind": "Function",
      "name": "repeatedly_reset_entry_inserted_as_expired",
      "signature": "fn # [doc = \" Regression test: Given an entry inserted with a deadline in the past, so\"] # [doc = \" that it is placed directly on the expired queue, reset the entry to a\"] # [doc = \" deadline in the future. Validate that this leaves the entry and queue in an\"] # [doc = \" internally consistent state by running an additional reset on the entry\"] # [doc = \" before polling it to completion.\"] # [tokio :: test] async fn repeatedly_reset_entry_inserted_as_expired () { time :: pause () ; time :: sleep (ms (1000)) . await ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now - ms (100)) ; queue . reset_at (& key , now + ms (100)) ; queue . reset_at (& key , now + ms (50)) ; assert_pending ! (poll ! (queue)) ; time :: sleep_until (now + ms (60)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 5551396478493569975,
      "kind": "Function",
      "name": "remove_expired_item",
      "signature": "fn # [tokio :: test] async fn remove_expired_item () { time :: pause () ; let mut queue = DelayQueue :: new () ; let now = Instant :: now () ; sleep (ms (10)) . await ; let key = queue . insert_at (\"foo\" , now) ; let entry = queue . remove (& key) ; assert_eq ! (entry . into_inner () , \"foo\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 922312135329446774,
      "kind": "Function",
      "name": "remove_at_timer_wheel_threshold",
      "signature": "fn # [doc = \" Regression test: it should be possible to remove entries which fall in the\"] # [doc = \" 0th slot of the internal timer wheel — that is, entries whose expiration\"] # [doc = \" (a) falls at the beginning of one of the wheel's hierarchical levels and (b)\"] # [doc = \" is equal to the wheel's current elapsed time.\"] # [tokio :: test] async fn remove_at_timer_wheel_threshold () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key1 = queue . insert_at (\"foo\" , now + ms (64)) ; let key2 = queue . insert_at (\"bar\" , now + ms (64)) ; sleep (ms (80)) . await ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; match entry { \"foo\" => { let entry = queue . remove (& key2) . into_inner () ; assert_eq ! (entry , \"bar\") ; } \"bar\" => { let entry = queue . remove (& key1) . into_inner () ; assert_eq ! (entry , \"foo\") ; } other => panic ! (\"other: {other:?}\") , } } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 15245045846762137479,
      "kind": "Function",
      "name": "expires_before_last_insert",
      "signature": "fn # [tokio :: test] async fn expires_before_last_insert () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo\" , now + ms (10_000)) ; assert_pending ! (poll ! (queue)) ; queue . insert_at (\"bar\" , now + ms (600)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (600)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"bar\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 5417321708492575817,
      "kind": "Function",
      "name": "multi_reset",
      "signature": "fn # [tokio :: test] async fn multi_reset () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; let two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (300)) ; queue . reset_at (& two , now + ms (350)) ; queue . reset_at (& one , now + ms (400)) ; sleep (ms (310)) . await ; assert_pending ! (poll ! (queue)) ; sleep (ms (50)) . await ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"two\") ; assert_pending ! (poll ! (queue)) ; sleep (ms (50)) . await ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"one\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 95267264572993794,
      "kind": "Function",
      "name": "expire_first_key_when_reset_to_expire_earlier",
      "signature": "fn # [tokio :: test] async fn expire_first_key_when_reset_to_expire_earlier () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (100)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"one\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 9714949407897568409,
      "kind": "Function",
      "name": "expire_second_key_when_reset_to_expire_earlier",
      "signature": "fn # [tokio :: test] async fn expire_second_key_when_reset_to_expire_earlier () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"one\" , now + ms (200)) ; let two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& two , now + ms (100)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 10075998329159559717,
      "kind": "Function",
      "name": "reset_first_expiring_item_to_expire_later",
      "signature": "fn # [tokio :: test] async fn reset_first_expiring_item_to_expire_later () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; let _two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (300)) ; sleep (ms (250)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 7420945647776280555,
      "kind": "Function",
      "name": "insert_before_first_after_poll",
      "signature": "fn # [tokio :: test] async fn insert_before_first_after_poll () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let _one = queue . insert_at (\"one\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; let _two = queue . insert_at (\"two\" , now + ms (100)) ; sleep (ms (99)) . await ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 5306186285539111892,
      "kind": "Function",
      "name": "insert_after_ready_poll",
      "signature": "fn # [tokio :: test] async fn insert_after_ready_poll () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"1\" , now + ms (100)) ; queue . insert_at (\"2\" , now + ms (100)) ; queue . insert_at (\"3\" , now + ms (100)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let mut res = vec ! [] ; while res . len () < 3 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; queue . insert_at (\"foo\" , now + ms (500)) ; } res . sort_unstable () ; assert_eq ! (\"1\" , res [0]) ; assert_eq ! (\"2\" , res [1]) ; assert_eq ! (\"3\" , res [2]) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 11589166974284863177,
      "kind": "Function",
      "name": "reset_later_after_slot_starts",
      "signature": "fn # [tokio :: test] async fn reset_later_after_slot_starts () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let foo = queue . insert_at (\"foo\" , now + ms (100)) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (80)) . await ; assert ! (! queue . is_woken ()) ; queue . reset_at (& foo , now + ms (120)) ; assert ! (queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (119)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 7106351667524907676,
      "kind": "Function",
      "name": "reset_inserted_expired",
      "signature": "fn # [tokio :: test] async fn reset_inserted_expired () { time :: pause () ; time :: sleep (ms (1000)) . await ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now - ms (100)) ; queue . reset_at (& key , now + ms (100)) ; assert_eq ! (1 , queue . len ()) ; sleep (ms (200)) . await ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; assert_eq ! (queue . len () , 0) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 10137095281805950341,
      "kind": "Function",
      "name": "reset_earlier_after_slot_starts",
      "signature": "fn # [tokio :: test] async fn reset_earlier_after_slot_starts () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let foo = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (80)) . await ; assert ! (! queue . is_woken ()) ; queue . reset_at (& foo , now + ms (120)) ; assert ! (queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (119)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 2185395240335262104,
      "kind": "Function",
      "name": "insert_in_past_after_poll_fires_immediately",
      "signature": "fn # [tokio :: test] async fn insert_in_past_after_poll_fires_immediately () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (80)) . await ; assert ! (! queue . is_woken ()) ; queue . insert_at (\"bar\" , now + ms (40)) ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"bar\") ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 14765271693436731130,
      "kind": "Function",
      "name": "delay_queue_poll_expired_when_empty",
      "signature": "fn # [tokio :: test] async fn delay_queue_poll_expired_when_empty () { let mut delay_queue = task :: spawn (DelayQueue :: new ()) ; let key = delay_queue . insert (0 , std :: time :: Duration :: from_secs (10)) ; assert_pending ! (poll ! (delay_queue)) ; delay_queue . remove (& key) ; assert ! (assert_ready ! (poll ! (delay_queue)) . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 6922444666712319059,
      "kind": "Function",
      "name": "compact_expire_empty",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_expire_empty () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; assert_eq ! (queue . len () , 0) ; assert_eq ! (queue . capacity () , 0) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 12625983224878912981,
      "kind": "Function",
      "name": "compact_remove_empty",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_remove_empty () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key1 = queue . insert_at (\"foo1\" , now + ms (10)) ; let key2 = queue . insert_at (\"foo2\" , now + ms (10)) ; queue . remove (& key1) ; queue . remove (& key2) ; queue . compact () ; assert_eq ! (queue . len () , 0) ; assert_eq ! (queue . capacity () , 0) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 4411082991150415393,
      "kind": "Function",
      "name": "compact_remove_remapped_keys",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_remove_remapped_keys () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; let key3 = queue . insert_at (\"foo3\" , now + ms (20)) ; let key4 = queue . insert_at (\"foo4\" , now + ms (20)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; queue . insert_at (\"foo5\" , now + ms (10)) ; let expired3 = queue . remove (& key3) ; let expired4 = queue . remove (& key4) ; assert_eq ! (expired3 . into_inner () , \"foo3\") ; assert_eq ! (expired4 . into_inner () , \"foo4\") ; queue . compact () ; assert_eq ! (queue . len () , 1) ; assert_eq ! (queue . capacity () , 1) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 14434430269540016466,
      "kind": "Function",
      "name": "compact_change_deadline",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_change_deadline () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let mut now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; queue . insert_at (\"foo3\" , now + ms (20)) ; let key4 = queue . insert_at (\"foo4\" , now + ms (20)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; now = Instant :: now () ; queue . insert_at (\"foo5\" , now + ms (10)) ; let key6 = queue . insert_at (\"foo6\" , now + ms (10)) ; queue . reset_at (& key4 , now + ms (20)) ; queue . reset_at (& key6 , now + ms (20)) ; sleep (ms (10)) . await ; while res . len () < 4 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } sleep (ms (10)) . await ; while res . len () < 6 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 11784375157746252080,
      "kind": "Function",
      "name": "item_expiry_greater_than_wheel",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn item_expiry_greater_than_wheel () { let mut queue = DelayQueue :: new () ; for _ in 0 .. 2 { tokio :: time :: advance (Duration :: from_millis (1 << 35)) . await ; queue . insert (0 , Duration :: from_millis (0)) ; queue . next () . await ; } let no_panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . insert (1 , Duration :: from_millis (1)) ; })) ; assert ! (no_panic . is_ok ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 14868662149913210843,
      "kind": "Function",
      "name": "remove_after_compact",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: Does not seem to work with WASI\")] # [tokio :: test (start_paused = true)] # [cfg (panic = \"unwind\")] async fn remove_after_compact () { let now = Instant :: now () ; let mut queue = DelayQueue :: new () ; let foo_key = queue . insert_at (\"foo\" , now + ms (10)) ; queue . insert_at (\"bar\" , now + ms (20)) ; queue . remove (& foo_key) ; queue . compact () ; let panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . remove (& foo_key) ; })) ; assert ! (panic . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 12466861527122290260,
      "kind": "Function",
      "name": "remove_after_compact_poll",
      "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: Does not seem to work with WASI\")] # [tokio :: test (start_paused = true)] # [cfg (panic = \"unwind\")] async fn remove_after_compact_poll () { let now = Instant :: now () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let foo_key = queue . insert_at (\"foo\" , now + ms (10)) ; queue . insert_at (\"bar\" , now + ms (20)) ; sleep (ms (10)) . await ; assert_eq ! (assert_ready_some ! (poll ! (queue)) . key () , foo_key) ; queue . compact () ; let panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . remove (& foo_key) ; })) ; assert ! (panic . is_err ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 13961069047057238526,
      "kind": "Function",
      "name": "peek",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn peek () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now + ms (5)) ; let key2 = queue . insert_at (\"bar\" , now) ; let key3 = queue . insert_at (\"baz\" , now + ms (10)) ; assert_eq ! (queue . peek () , Some (key2)) ; sleep (ms (6)) . await ; assert_eq ! (queue . peek () , Some (key2)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"bar\") ; assert_eq ! (queue . peek () , Some (key)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"foo\") ; assert_eq ! (queue . peek () , Some (key3)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (5)) . await ; assert_eq ! (queue . peek () , Some (key3)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"baz\") ; assert ! (queue . peek () . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 8812956863828178693,
      "kind": "Function",
      "name": "wake_after_remove_last",
      "signature": "fn # [tokio :: test (start_paused = true)] async fn wake_after_remove_last () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let key = queue . insert (\"foo\" , ms (1000)) ; assert_pending ! (poll ! (queue)) ; queue . remove (& key) ; assert ! (queue . is_woken ()) ; assert ! (assert_ready ! (poll ! (queue)) . is_none ()) ; } . sig",
      "file_path": "tokio-util/tests/time_delay_queue.rs",
      "line": 0
    },
    {
      "hash": 15360622510947865001,
      "kind": "Function",
      "name": "send_framed_byte_codec",
      "signature": "fn # [cfg_attr (any (target_os = \"macos\" , target_os = \"ios\" , target_os = \"tvos\" , target_os = \"watchos\" , target_os = \"visionos\") , allow (unused_assignments))] # [tokio :: test] async fn send_framed_byte_codec () -> std :: io :: Result < () > { let mut a_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let mut b_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; { let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , ByteCodec) ; let msg = b\"4567\" ; let send = a . send ((msg , b_addr)) ; let recv = b . next () . map (| e | e . unwrap ()) ; let (_ , received) = try_join (send , recv) . await . unwrap () ; let (data , addr) = received ; assert_eq ! (msg , &* data) ; assert_eq ! (a_addr , addr) ; a_soc = a . into_inner () ; b_soc = b . into_inner () ; } # [cfg (not (any (target_os = \"macos\" , target_os = \"ios\" , target_os = \"tvos\" , target_os = \"watchos\" , target_os = \"visionos\")))] { let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , ByteCodec) ; let msg = b\"\" ; let send = a . send ((msg , b_addr)) ; let recv = b . next () . map (| e | e . unwrap ()) ; let (_ , received) = try_join (send , recv) . await . unwrap () ; let (data , addr) = received ; assert_eq ! (msg , &* data) ; assert_eq ! (a_addr , addr) ; } Ok (()) } . sig",
      "file_path": "tokio-util/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 12206940950795686408,
      "kind": "Struct",
      "name": "ByteCodec",
      "signature": "struct ByteCodec",
      "file_path": "tokio-util/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 12593945572045380227,
      "kind": "Function",
      "name": "send_framed_lines_codec",
      "signature": "fn # [tokio :: test] async fn send_framed_lines_codec () -> std :: io :: Result < () > { let a_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let b_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , LinesCodec :: new ()) ; let msg = b\"1\\r\\n2\\r\\n3\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"1\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"2\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"3\" . to_string () , a_addr)) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/udp.rs",
      "line": 0
    },
    {
      "hash": 8203948722569696493,
      "kind": "Function",
      "name": "framed_half",
      "signature": "fn # [tokio :: test] async fn framed_half () -> std :: io :: Result < () > { let a_soc = Arc :: new (UdpSocket :: bind (\"127.0.0.1:0\") . await ?) ; let b_soc = a_soc . clone () ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , LinesCodec :: new ()) ; let msg = b\"1\\r\\n2\\r\\n3\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; let msg = b\"4\\r\\n5\\r\\n6\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"1\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"2\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"3\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"4\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"5\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"6\" . to_string () , a_addr)) ; Ok (()) } . sig",
      "file_path": "tokio-util/tests/udp.rs",
      "line": 0
    }
  ],
  "edges": [
    [
      1754303143792833593,
      13375578519503559960,
      "Implements"
    ],
    [
      17915046734210526762,
      1167953265164851858,
      "Implements"
    ],
    [
      17915046734210526762,
      14879562979410301075,
      "Implements"
    ],
    [
      4864556232596093461,
      14879562979410301075,
      "Implements"
    ],
    [
      4673202845414328072,
      1167953265164851858,
      "Implements"
    ],
    [
      4673202845414328072,
      14879562979410301075,
      "Implements"
    ],
    [
      15745933203372030422,
      1167953265164851858,
      "Implements"
    ],
    [
      15745933203372030422,
      14879562979410301075,
      "Implements"
    ],
    [
      970187139602289372,
      13375578519503559960,
      "Implements"
    ],
    [
      17402285446407453362,
      13375578519503559960,
      "Implements"
    ],
    [
      15896343101583145333,
      13375578519503559960,
      "Implements"
    ],
    [
      13365453521122244993,
      5790051155030096730,
      "Implements"
    ],
    [
      2793446354954954618,
      5790051155030096730,
      "Implements"
    ],
    [
      6577844766864615769,
      1167953265164851858,
      "Implements"
    ],
    [
      6512766496802867014,
      14879562979410301075,
      "Implements"
    ],
    [
      10674279678464129910,
      13375578519503559960,
      "Implements"
    ],
    [
      14326435287121227,
      1167953265164851858,
      "Implements"
    ],
    [
      5562919265722378797,
      14879562979410301075,
      "Implements"
    ],
    [
      18168044383964444326,
      11849087384152744394,
      "Implements"
    ],
    [
      15400329673815263752,
      1167953265164851858,
      "Implements"
    ],
    [
      15400329673815263752,
      14879562979410301075,
      "Implements"
    ],
    [
      10128229422878960331,
      11849087384152744394,
      "Implements"
    ],
    [
      14254838026186164895,
      11849087384152744394,
      "Implements"
    ],
    [
      13039149255098101573,
      13375578519503559960,
      "Implements"
    ],
    [
      8239531028922241379,
      13375578519503559960,
      "Implements"
    ],
    [
      2867522172588991260,
      13375578519503559960,
      "Implements"
    ],
    [
      9414961859488016845,
      1177113876295277905,
      "Implements"
    ],
    [
      14994358408068206138,
      13375578519503559960,
      "Implements"
    ],
    [
      6124807426156870755,
      13375578519503559960,
      "Implements"
    ],
    [
      9382476031578584117,
      9230966580944554502,
      "Implements"
    ],
    [
      3020593632513718178,
      2155555586112145469,
      "Implements"
    ],
    [
      9930574543778187483,
      8033908629069695487,
      "Implements"
    ],
    [
      12753751648257178987,
      2155555586112145469,
      "Implements"
    ],
    [
      12753751648257178987,
      1476899036862037828,
      "Implements"
    ],
    [
      11037690642226759374,
      13375578519503559960,
      "Implements"
    ],
    [
      4831197805017781396,
      13375578519503559960,
      "Implements"
    ],
    [
      16882020342739871868,
      13375578519503559960,
      "Implements"
    ],
    [
      15179404085153225767,
      13375578519503559960,
      "Implements"
    ],
    [
      17867219859629974311,
      13375578519503559960,
      "Implements"
    ],
    [
      16517926799049916176,
      13375578519503559960,
      "Implements"
    ],
    [
      5670051415881967404,
      4282859715798227402,
      "Implements"
    ],
    [
      195233381880592766,
      13375578519503559960,
      "Implements"
    ],
    [
      15223354668242353363,
      13375578519503559960,
      "Implements"
    ],
    [
      10956851563449199782,
      13375578519503559960,
      "Implements"
    ],
    [
      9553687379687383683,
      13375578519503559960,
      "Implements"
    ],
    [
      15597723212883881259,
      13375578519503559960,
      "Implements"
    ],
    [
      7837141704646244853,
      13375578519503559960,
      "Implements"
    ],
    [
      14542899099915851850,
      13233862909537158735,
      "Implements"
    ],
    [
      14542899099915851850,
      12948692393582067867,
      "Implements"
    ],
    [
      14606729505894253697,
      13375578519503559960,
      "Implements"
    ],
    [
      5873623981022757307,
      13375578519503559960,
      "Implements"
    ],
    [
      3909859045206798157,
      13375578519503559960,
      "Implements"
    ],
    [
      15783196389732907094,
      1167953265164851858,
      "Implements"
    ],
    [
      15783196389732907094,
      6345512993515642476,
      "Implements"
    ],
    [
      15783196389732907094,
      14879562979410301075,
      "Implements"
    ],
    [
      1216213135963578216,
      14879562979410301075,
      "Implements"
    ],
    [
      4224420485998508068,
      1167953265164851858,
      "Implements"
    ],
    [
      742670182768673483,
      14879562979410301075,
      "Implements"
    ],
    [
      5691854271883518363,
      1167953265164851858,
      "Implements"
    ],
    [
      5691854271883518363,
      14879562979410301075,
      "Implements"
    ],
    [
      1727337242908034942,
      1167953265164851858,
      "Implements"
    ],
    [
      4753086605202827496,
      1167953265164851858,
      "Implements"
    ],
    [
      5641839105613328909,
      1167953265164851858,
      "Implements"
    ],
    [
      14973399440152806641,
      13233862909537158735,
      "Implements"
    ],
    [
      3393886809286872111,
      13233862909537158735,
      "Implements"
    ],
    [
      3393886809286872111,
      4965400430733254705,
      "Implements"
    ],
    [
      14973399440152806641,
      4965400430733254705,
      "Implements"
    ],
    [
      6775699799553248360,
      4965400430733254705,
      "Implements"
    ],
    [
      6385034665475837701,
      4965400430733254705,
      "Implements"
    ],
    [
      17324488208694218184,
      4965400430733254705,
      "Implements"
    ],
    [
      3393886809286872111,
      2445510119823751426,
      "Implements"
    ],
    [
      14973399440152806641,
      2445510119823751426,
      "Implements"
    ],
    [
      6775699799553248360,
      2445510119823751426,
      "Implements"
    ],
    [
      6385034665475837701,
      2445510119823751426,
      "Implements"
    ],
    [
      17324488208694218184,
      2445510119823751426,
      "Implements"
    ],
    [
      4403305803619190898,
      13233862909537158735,
      "Implements"
    ],
    [
      14973399440152806641,
      1969396240316671147,
      "Implements"
    ],
    [
      15628748977489461154,
      1167953265164851858,
      "Implements"
    ],
    [
      15628748977489461154,
      14879562979410301075,
      "Implements"
    ],
    [
      10954232615175509223,
      13375578519503559960,
      "Implements"
    ],
    [
      1447017396600541179,
      9871640248292113454,
      "Implements"
    ],
    [
      9382476031578584117,
      4583662498733049657,
      "Implements"
    ],
    [
      6249419574316670895,
      9269026320751321410,
      "Implements"
    ],
    [
      6249419574316670895,
      14015416951282084374,
      "Implements"
    ],
    [
      7809183884163288865,
      13375578519503559960,
      "Implements"
    ],
    [
      13473786022893396677,
      9269026320751321410,
      "Implements"
    ],
    [
      13473786022893396677,
      14015416951282084374,
      "Implements"
    ],
    [
      3396465101607277233,
      1167953265164851858,
      "Implements"
    ],
    [
      3396465101607277233,
      6345512993515642476,
      "Implements"
    ],
    [
      7709800308507547629,
      13375578519503559960,
      "Implements"
    ],
    [
      14214983956587061919,
      9269026320751321410,
      "Implements"
    ],
    [
      14214983956587061919,
      14015416951282084374,
      "Implements"
    ],
    [
      461988978151432706,
      9269026320751321410,
      "Implements"
    ],
    [
      461988978151432706,
      14015416951282084374,
      "Implements"
    ],
    [
      12136100923084413909,
      1167953265164851858,
      "Implements"
    ],
    [
      4058707972684022383,
      9269026320751321410,
      "Implements"
    ],
    [
      15668267960293596481,
      9269026320751321410,
      "Implements"
    ],
    [
      9459654359639709191,
      14015416951282084374,
      "Implements"
    ],
    [
      17064158340746198906,
      14015416951282084374,
      "Implements"
    ],
    [
      11331435548626667388,
      1167953265164851858,
      "Implements"
    ],
    [
      8727601496051406043,
      14879562979410301075,
      "Implements"
    ],
    [
      6199343088895623251,
      1167953265164851858,
      "Implements"
    ],
    [
      8560010311519652108,
      14015416951282084374,
      "Implements"
    ],
    [
      12206940950795686408,
      9269026320751321410,
      "Implements"
    ],
    [
      12206940950795686408,
      14015416951282084374,
      "Implements"
    ],
    [
      782495314061803544,
      14879562979410301075,
      "Implements"
    ],
    [
      7635645991916988893,
      1167953265164851858,
      "Implements"
    ],
    [
      8818354053333760888,
      14015416951282084374,
      "Implements"
    ],
    [
      8818354053333760888,
      9269026320751321410,
      "Implements"
    ],
    [
      14958692035605820931,
      1167953265164851858,
      "Implements"
    ],
    [
      14958692035605820931,
      5016206522292079398,
      "Implements"
    ],
    [
      14958692035605820931,
      14879562979410301075,
      "Implements"
    ],
    [
      6939176434371988369,
      16713037418574429162,
      "Implements"
    ],
    [
      6939176434371988369,
      8257726979326412286,
      "Implements"
    ],
    [
      15197901525454809434,
      16713037418574429162,
      "Implements"
    ],
    [
      15197901525454809434,
      8257726979326412286,
      "Implements"
    ],
    [
      14601095377683866721,
      1167953265164851858,
      "Implements"
    ],
    [
      14601095377683866721,
      6345512993515642476,
      "Implements"
    ],
    [
      14601095377683866721,
      14879562979410301075,
      "Implements"
    ],
    [
      14601095377683866721,
      5016206522292079398,
      "Implements"
    ],
    [
      7130976469513546441,
      2700627531662076923,
      "Implements"
    ],
    [
      1799632238248677187,
      11826005784536820338,
      "Implements"
    ],
    [
      2444012961140979343,
      9871640248292113454,
      "Implements"
    ],
    [
      17888422371133996900,
      9230966580944554502,
      "Implements"
    ],
    [
      9865831582146585299,
      777262590239786932,
      "Implements"
    ],
    [
      9414961859488016845,
      9871640248292113454,
      "Implements"
    ],
    [
      6741387803506043794,
      777262590239786932,
      "Implements"
    ],
    [
      6741387803506043794,
      9511322880922071441,
      "Implements"
    ],
    [
      3632473869751896843,
      777262590239786932,
      "Implements"
    ],
    [
      18105273027691498854,
      9871640248292113454,
      "Implements"
    ],
    [
      18105273027691498854,
      777262590239786932,
      "Implements"
    ],
    [
      1208582932336799690,
      9269026320751321410,
      "Implements"
    ],
    [
      1208582932336799690,
      14015416951282084374,
      "Implements"
    ],
    [
      2547066757857937064,
      9269026320751321410,
      "Implements"
    ],
    [
      2547066757857937064,
      14015416951282084374,
      "Implements"
    ],
    [
      15437219073951197017,
      18224979900198386639,
      "Implements"
    ]
  ]
}