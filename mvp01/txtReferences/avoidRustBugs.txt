# Comprehensive Guide to Avoiding Rust Bugs and Writing Idiomatic Code

## 1. Ownership and Borrowing

- Understand and respect Rust's ownership model
- Use references (`&` and `&mut`) to borrow values without taking ownership
- Be cautious with `move` semantics in closures
- Implement `Copy` trait only for types where it makes sense (small, stack-only data)

## 2. Lifetimes

- Use explicit lifetime annotations when the compiler can't infer them
- Understand the 'static lifetime and use it judiciously
- Be careful with lifetime elision in complex scenarios

## 3. Error Handling

- Use `Result<T, E>` for operations that can fail
- Create custom error types for more descriptive error handling
- Avoid using `.unwrap()` or `.expect()` in production code
- Use the `?` operator for concise error propagation

## 4. Type System

- Leverage Rust's strong type system to prevent errors at compile-time
- Use newtype pattern to create type-safe wrappers around primitive types
- Be explicit with type annotations when necessary for clarity

## 5. Concurrency and Parallelism

- Use `Arc<T>` for shared ownership across threads
- Prefer `Arc<Mutex<T>>` over `Rc<RefCell<T>>` for shared mutable state across threads
- Be aware of potential deadlocks when using multiple locks
- Use `rayon` for parallel iterators, but be mindful of the overhead for small datasets

## 6. API Design

- Follow the "easy to use correctly, hard to use incorrectly" principle
- Implement common traits like `Debug`, `Clone`, `PartialEq` when appropriate
- Use builder pattern for complex object construction

## 7. Testing and Debugging

- Write unit tests for all public functions
- Use `#[cfg(test)]` for test-only code
- Leverage `proptest` or `quickcheck` for property-based testing
- Use the `dbg!` macro for quick debugging

## 8. Performance Optimization

- Profile before optimizing
- Use `criterion` for benchmarking
- Be cautious with premature optimization
- Understand and use zero-cost abstractions

## 9. Memory Management

- Prefer stack allocation over heap allocation for small, fixed-size data
- Use `Vec::with_capacity()` when you know the size of a vector in advance
- Be mindful of memory leaks, especially with reference cycles

## 10. Unsafe Code

- Minimize the use of `unsafe` code
- Document safety invariants for `unsafe` functions
- Encapsulate `unsafe` code in safe abstractions

## 11. External Libraries

- Regularly update dependencies to get bug fixes and security patches
- Understand the API of external crates thoroughly before use
- Be cautious when implementing traits from external crates

## 12. GitHub API Specific

- Always include a User-Agent header in requests
- Handle rate limiting properly
- Use conditional requests with ETags to reduce API usage
- Implement proper pagination for endpoints that return multiple items

## 13. Reqwest Library

- Reuse `Client` instances for better performance
- Set appropriate timeouts to prevent hanging requests
- Use `query()` method for adding query parameters to avoid manual URL construction
- Handle different response status codes properly

## 14. Serde for Serialization/Deserialization

- Use `#[derive(Serialize, Deserialize)]` for structs that match JSON structure
- Implement custom serialization/deserialization for complex types
- Use `#[serde(rename = "field_name")]` for fields that don't match JSON keys
- Be cautious with `#[serde(flatten)]` as it can lead to naming conflicts

## 15. Tokio for Async Programming

- Use `#[tokio::main]` attribute for the main async function
- Avoid blocking operations in async code
- Use `tokio::spawn` for concurrent tasks
- Be aware of task cancellation and use `select!` for timeout handling

## 16. Error Propagation in Async Code

- Use `?` operator in async functions that return `Result`
- Be aware that `?` in async closures might not work as expected
- Consider using `.await?` for clarity in complex async operations

## 17. Type Consistency in API Calls

- Ensure query parameters have consistent types
- Use `.to_string()` or `String::from()` to convert string literals when necessary
- Pay attention to compiler errors about type mismatches in API calls

## 18. Handling Optional Fields

- Use `Option<T>` for fields that might be missing in API responses
- Implement `Default` trait for structs with optional fields

## 19. File I/O and Error Handling

- Use `BufReader` and `BufWriter` for efficient file I/O
- Handle all possible I/O errors, including partial writes and interrupted system calls
- Use `?` operator for concise error propagation in file operations

## 20. CLI Input Handling

- Validate user input thoroughly
- Provide clear error messages for invalid inputs
- Use a crate like `clap` for more complex CLI argument parsing

## 21. Avoid Common Pitfalls

- Don't use `String` when `&str` would suffice
- Avoid unnecessary cloning of data
- Be cautious with `mem::forget` and other memory-related functions
- Don't implement `Clone` for mutex-guarded types

## 22. Code Organization

- Use modules to organize related functionality
- Follow Rust naming conventions consistently
- Use `pub(crate)` for items that should be private to the crate

## 23. Documentation

- Write clear and concise documentation for public APIs
- Include examples in documentation comments
- Use `rustdoc` to generate and view documentation

## 24. Error Types and Logging

- Create custom error types that implement `std::error::Error`
- Use the `log` crate for consistent logging across your application
- Configure appropriate log levels for different environments

## 25. Continuous Integration and Tooling

- Use `rustfmt` to maintain consistent code formatting
- Run `clippy` regularly to catch common mistakes and non-idiomatic code
- Set up CI to run tests, clippy, and rustfmt on every pull request

## 26. Reqwest Query Parameters

- Ensure all query parameters have the same type when using the `query` method.
- When mixing string literals and `String` variables, convert all to `String`:  ```rust
  .query(&[
      ("q", &query),
      ("sort", &String::from("stars")),
      ("order", &String::from("desc"))
  ])  ```
- Alternatively, use a `Vec` of tuples for more flexibility:  ```rust
  let params = vec![
      ("q", query),
      ("sort", String::from("stars")),
      ("order", String::from("desc"))
  ];
  .query(&params)  ```

## 27. Compiler Warning Vigilance

- Address all compiler warnings, even those that seem minor.
- Remove unused imports to keep the code clean and avoid potential conflicts.
- Use `#[allow(unused_imports)]` only when absolutely necessary and document why.

## 28. Continuous Integration and Testing

- Implement a CI pipeline that compiles and tests the code on every commit.
- Include `cargo clippy` in the CI process to catch common mistakes.
- Regularly run `cargo test` locally before pushing changes.

## 29. Code Review Process

- Implement a thorough code review process, even for solo projects.
- Use a checklist that includes compiling and running the code before approving changes.
- Consider using tools like `cargo-review` for automated checks.

## 30. Error Cataloging

- Keep a log of encountered errors and their solutions.
- Regularly review and update this log to prevent recurring issues.
- Share this knowledge with team members or the community to help others avoid similar pitfalls.

## 31. Embedded Database Best Practices

- Use transactions for operations that need to be atomic.
- Handle potential errors when creating directories or writing to the database.
- Implement proper error handling for all database operations.
- Use appropriate serialization/deserialization for storing complex types.
- Be mindful of database size growth over time.
- Implement periodic compaction or cleanup of the database.
- Use separate trees for different types of data for better organization.
- Implement proper closing of the database to prevent data corruption.

## 32. Single File Organization for MVPs

- For Minimum Viable Products (MVPs) or small projects, it's acceptable to keep all code in a single file (e.g., `main.rs`).
- Organize the code within the file using clear separations between different components (e.g., structs, functions, implementations).
- Use comments to delineate different sections of the code for better readability.
- As the project grows, consider splitting the code into modules and separate files.

## 33. Error Handling in Asynchronous Code

- Use `anyhow::Result` for comprehensive error handling in async functions.
- Propagate errors using the `?` operator in async contexts.
- Provide context to errors using `.context()` method from `anyhow`.
- Handle errors from spawned tasks by checking the result of `.await` on the spawned future.

## 34. Progress Reporting

- Use crates like `indicatif` for progress reporting in CLI applications.
- Wrap long-running operations with progress bars to provide user feedback.
- Handle potential errors when setting up progress bars (e.g., `expect()` on `ProgressStyle::template()`).

## 35. Asynchronous Channel Usage

- Use `tokio::sync::mpsc` for asynchronous communication between tasks.
- Properly handle channel closure in receiver loops (e.g., `while let Some(item) = rx.recv().await { ... }`).
- Consider error handling when sending on a channel, as it can fail if the receiver has been dropped.

## 36. File I/O in Asynchronous Contexts

- Use synchronous file I/O operations (`std::fs`) when running in asynchronous contexts, as file I/O is typically not a bottleneck.
- If file I/O becomes a performance issue, consider using `tokio::fs` for asynchronous file operations.

## 37. Database Operations

- Use transactions for database operations that need to be atomic.
- Handle potential errors when creating directories or writing to the database.
- Implement proper error handling for all database operations.

## 38. ZIP File Processing

- Use streaming approaches for processing ZIP files to handle large archives efficiently.
- Implement error handling for each file in the ZIP archive.
- Use `anyhow::Context` to provide meaningful error messages for ZIP processing failures.

## 39. Language Detection

- Implement robust language detection logic, considering both file extensions and content analysis.
- Handle edge cases like files without extensions or with misleading extensions.

## 40. Summary Generation

- Ensure summary generation logic can handle large numbers of files efficiently.
- Use appropriate data structures (e.g., `HashMap`) for aggregating statistics.

## 41. Output Management

- Use buffered writers (`BufWriter`) for efficient file writing.
- Implement proper error handling for file creation and writing operations.
- Consider using atomic write operations for critical output files to prevent data corruption in case of crashes.

## 42. Trait Imports for Standard Library Types

- Remember to import traits for standard library types when using their methods.
- For example, import `std::io::Write` when using `flush()` on `BufWriter`.
- The Rust compiler often provides helpful suggestions for missing trait imports.

## 43. Mutable Variables Declaration

- Declare variables as mutable (`mut`) only when they need to be modified.
- Review your code to remove unnecessary `mut` keywords, improving code clarity and preventing accidental modifications.

## 44. Error Handling in Builder Patterns

- When using builder patterns (like with `ProgressStyle`), handle potential errors from intermediate steps.
- Use `expect()` or proper error handling for methods that return `Result`, even in seemingly infallible operations.

## 45. Asynchronous Error Propagation

- In asynchronous contexts, ensure proper error propagation through the `await` chain.
- Use `?` operator with `await` to propagate errors in async functions.

## 46. Consistent Error Handling Strategy

- Choose a consistent error handling strategy throughout your project (e.g., using `anyhow::Result` for flexibility).
- Provide context to errors using `.context()` or similar methods to enhance debugging.

## 47. Modular Code Organization

- Even in single-file projects, organize code into logical sections or pseudo-modules.
- Use clear separation and comments to delineate different components of your application.

## 48. Careful Type Inference

- Be explicit with types when Rust's type inference might be ambiguous.
- Pay attention to compiler warnings about type inference issues and address them promptly.

## 49. Import Verification

- Double-check all imports, especially for common types like `Arc`.
- Use an IDE with good Rust support that can suggest correct imports.
- Run `cargo check` after modifying imports to catch any issues immediately.

## 50. Dependency Management

- Always update `Cargo.toml` when adding new dependencies.
- Use `cargo add <crate-name>` to automatically add dependencies to `Cargo.toml`.
- Regularly review and clean up unused dependencies in `Cargo.toml`.

## 51. Async Rust Best Practices

- Stick to stable Rust features unless absolutely necessary.
- Use async blocks instead of async closures when possible.
- Be aware of the stability status of async features you're using.

## 52. Incremental Development and Testing

- Make smaller, incremental changes and test after each change.
- Run `cargo check` and `cargo clippy` frequently during development.
- Implement a self-review process before considering a change "done".

## 53. IDE and Tooling Usage

- Utilize IDE features that can automatically suggest and apply import corrections.
- Set up your IDE to run `cargo check` on save.
- Use `rust-analyzer` or a similar language server for real-time error checking.

## 54. Change Management Process

- Implement a checklist for code changes, including a step to verify all imports.
- Keep a "lessons learned" document to track issues and prevent them in the future.
- Consider implementing a more rigorous change management process, even for small projects.

## 55. Continuous Integration Practices

- Set up a CI pipeline that runs `cargo check`, `cargo clippy`, and `cargo test` on every commit.
- Include a step in your CI to verify that all used dependencies are declared in `Cargo.toml`.
- Use CI to catch issues that might be missed during local development.

## 56. Code Review Practices

- Implement a thorough code review process, even for solo projects.
- Use a checklist during code reviews that includes checking imports and dependencies.
- Pay special attention to changes in async code and error handling.

## 57. Error Handling in Async Contexts

- Be mindful of error propagation in async functions and closures.
- Use `.await?` for error propagation in async contexts.
- Ensure that errors from spawned tasks are properly handled and logged.

## 58. Dependency Versioning

- Use version ranges in `Cargo.toml` to allow for minor updates (e.g., `^1.0` instead of `1.0`).
- Regularly update dependencies to get bug fixes and security patches.
- Use `cargo update` to update dependencies within the specified version constraints.

## 59. Feature Flags and Conditional Compilation

- Use feature flags to manage optional dependencies and functionality.
- Be cautious when using unstable features and clearly document their usage.
- Use conditional compilation (`#[cfg(...)]`) to handle platform-specific code.

## 60. Documentation Practices

- Document any non-obvious import choices or dependency usage.
- Keep a changelog to track significant changes, including dependency updates.
- Use doc comments (`///`) to explain the purpose and usage of public items.

## 61. Ownership in Async Contexts

- Be cautious when moving values into async blocks or tasks.
- Ensure all types used in async contexts implement `Send` if they're to be used across await points.
- Use `Arc` for sharing ownership across threads, but remember that the original value is moved.

## 62. Working with External Crates in Async Contexts

- Check if types from external crates implement `Send` before using them in async tasks.
- Consider wrapping non-Send types in a mutex or creating a separate thread for blocking operations.
- Be aware that some operations (like file I/O) might not be async-friendly in all crates.

## 63. Tokio Task Spawning

- Ensure that futures passed to `tokio::spawn` are `Send`.
- Use `tokio::task::spawn_blocking` for operations that aren't `Send` or are CPU-intensive.
- Consider using `tokio::sync::Mutex` instead of `std::sync::Mutex` in async code.

## 64. Arc and Ownership

- Remember that wrapping a value in `Arc::new()` moves the value into the `Arc`.
- Use `Arc::clone()` to create new references to the same data.
- When passing an `Arc` to a function, consider passing a reference to the `Arc` instead of moving it.

## 65. Closure Ownership

- Be aware that closures capture their environment by default.
- Use the `move` keyword judiciously in closures to take ownership of captured variables.
- Consider using `Rc` or `Arc` for shared ownership in closures that outlive the current scope.

## 66. Unused Variables

- Prefix unused variables with an underscore to silence warnings.
- Remove unused parameters if they're not needed in the function implementation.
- Consider using `#[allow(unused_variables)]` attribute if the unused variable is intentional.

## 67. Error Logging in Async Contexts

- When logging errors in async contexts, ensure the logger is cloned or referenced properly.
- Consider using a thread-safe logging mechanism that can be easily shared across async tasks.

Remember to regularly review and update this guide as you encounter new challenges and learn from your Rust development experiences. Always compile and test your code after making changes, and pay close attention to compiler warnings and errors.
