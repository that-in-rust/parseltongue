Directory structure:
â””â”€â”€ tokio-rs-axum/
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ CHANGELOG.md
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ deny.toml
    â”œâ”€â”€ ECOSYSTEM.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ .clippy.toml
    â”œâ”€â”€ axum/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”œâ”€â”€ benches/
    â”‚   â”‚   â””â”€â”€ benches.rs
    â”‚   â”œâ”€â”€ LICENSE -> LICENSE
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ boxed.rs
    â”‚   â”‚   â”œâ”€â”€ extension.rs
    â”‚   â”‚   â”œâ”€â”€ form.rs
    â”‚   â”‚   â”œâ”€â”€ json.rs
    â”‚   â”‚   â”œâ”€â”€ lib.rs
    â”‚   â”‚   â”œâ”€â”€ macros.rs
    â”‚   â”‚   â”œâ”€â”€ service_ext.rs
    â”‚   â”‚   â”œâ”€â”€ util.rs
    â”‚   â”‚   â”œâ”€â”€ body/
    â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ docs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ debugging_handler_type_errors.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ error_handling.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ extract.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ handlers_intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ middleware.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ response.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ method_routing/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fallback.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ layer.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ merge.md
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route_layer.md
    â”‚   â”‚   â”‚   â””â”€â”€ routing/
    â”‚   â”‚   â”‚       â”œâ”€â”€ fallback.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ into_make_service_with_connect_info.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ layer.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ merge.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ method_not_allowed_fallback.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ nest.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ route.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ route_layer.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ route_service.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ with_state.md
    â”‚   â”‚   â”‚       â””â”€â”€ without_v07_checks.md
    â”‚   â”‚   â”œâ”€â”€ error_handling/
    â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ extract/
    â”‚   â”‚   â”‚   â”œâ”€â”€ connect_info.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ matched_path.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ multipart.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ nested_path.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ original_uri.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ query.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ raw_form.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ raw_query.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ rejection.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ state.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ ws.rs
    â”‚   â”‚   â”‚   â””â”€â”€ path/
    â”‚   â”‚   â”‚       â”œâ”€â”€ de.rs
    â”‚   â”‚   â”‚       â””â”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ handler/
    â”‚   â”‚   â”‚   â”œâ”€â”€ future.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â””â”€â”€ service.rs
    â”‚   â”‚   â”œâ”€â”€ middleware/
    â”‚   â”‚   â”‚   â”œâ”€â”€ from_extractor.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ from_fn.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ map_request.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ map_response.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â””â”€â”€ response_axum_body.rs
    â”‚   â”‚   â”œâ”€â”€ response/
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ redirect.rs
    â”‚   â”‚   â”‚   â””â”€â”€ sse.rs
    â”‚   â”‚   â”œâ”€â”€ routing/
    â”‚   â”‚   â”‚   â”œâ”€â”€ future.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ into_make_service.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ method_filter.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ method_routing.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ not_found.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ path_router.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ route.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ strip_prefix.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ url_params.rs
    â”‚   â”‚   â”‚   â””â”€â”€ tests/
    â”‚   â”‚   â”‚       â”œâ”€â”€ fallback.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ get_to_head.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ handle_error.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ merge.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚       â””â”€â”€ nest.rs
    â”‚   â”‚   â”œâ”€â”€ serve/
    â”‚   â”‚   â”‚   â”œâ”€â”€ listener.rs
    â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
    â”‚   â”‚   â””â”€â”€ test_helpers/
    â”‚   â”‚       â”œâ”€â”€ counting_cloneable_state.rs
    â”‚   â”‚       â”œâ”€â”€ mod.rs
    â”‚   â”‚       â”œâ”€â”€ test_client.rs
    â”‚   â”‚       â””â”€â”€ tracing_helpers.rs
    â”‚   â””â”€â”€ tests/
    â”‚       â””â”€â”€ panic_location.rs
    â”œâ”€â”€ axum-core/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”œâ”€â”€ LICENSE -> LICENSE
    â”‚   â””â”€â”€ src/
    â”‚       â”œâ”€â”€ body.rs
    â”‚       â”œâ”€â”€ error.rs
    â”‚       â”œâ”€â”€ lib.rs
    â”‚       â”œâ”€â”€ macros.rs
    â”‚       â”œâ”€â”€ ext_traits/
    â”‚       â”‚   â”œâ”€â”€ mod.rs
    â”‚       â”‚   â”œâ”€â”€ request.rs
    â”‚       â”‚   â””â”€â”€ request_parts.rs
    â”‚       â”œâ”€â”€ extract/
    â”‚       â”‚   â”œâ”€â”€ default_body_limit.rs
    â”‚       â”‚   â”œâ”€â”€ from_ref.rs
    â”‚       â”‚   â”œâ”€â”€ mod.rs
    â”‚       â”‚   â”œâ”€â”€ option.rs
    â”‚       â”‚   â”œâ”€â”€ rejection.rs
    â”‚       â”‚   â”œâ”€â”€ request_parts.rs
    â”‚       â”‚   â””â”€â”€ tuple.rs
    â”‚       â””â”€â”€ response/
    â”‚           â”œâ”€â”€ append_headers.rs
    â”‚           â”œâ”€â”€ into_response.rs
    â”‚           â”œâ”€â”€ into_response_parts.rs
    â”‚           â””â”€â”€ mod.rs
    â”œâ”€â”€ axum-extra/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”œâ”€â”€ LICENSE -> LICENSE
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ either.rs
    â”‚   â”‚   â”œâ”€â”€ json_lines.rs
    â”‚   â”‚   â”œâ”€â”€ lib.rs
    â”‚   â”‚   â”œâ”€â”€ middleware.rs
    â”‚   â”‚   â”œâ”€â”€ protobuf.rs
    â”‚   â”‚   â”œâ”€â”€ typed_header.rs
    â”‚   â”‚   â”œâ”€â”€ body/
    â”‚   â”‚   â”‚   â”œâ”€â”€ async_read_body.rs
    â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ extract/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cached.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ form.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ host.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ json_deserializer.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ multipart.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ optional_path.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ query.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ rejection.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ scheme.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ with_rejection.rs
    â”‚   â”‚   â”‚   â””â”€â”€ cookie/
    â”‚   â”‚   â”‚       â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ private.rs
    â”‚   â”‚   â”‚       â””â”€â”€ signed.rs
    â”‚   â”‚   â”œâ”€â”€ handler/
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â””â”€â”€ or.rs
    â”‚   â”‚   â”œâ”€â”€ response/
    â”‚   â”‚   â”‚   â”œâ”€â”€ attachment.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ erased_json.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ error_response.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ file_stream.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”‚   â””â”€â”€ multiple.rs
    â”‚   â”‚   â””â”€â”€ routing/
    â”‚   â”‚       â”œâ”€â”€ mod.rs
    â”‚   â”‚       â”œâ”€â”€ resource.rs
    â”‚   â”‚       â””â”€â”€ typed.rs
    â”‚   â””â”€â”€ test_files/
    â”‚       â”œâ”€â”€ index.html
    â”‚       â”œâ”€â”€ index_2.html
    â”‚       â””â”€â”€ script.js
    â”œâ”€â”€ axum-macros/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”œâ”€â”€ rust-toolchain
    â”‚   â”œâ”€â”€ LICENSE -> LICENSE
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ attr_parsing.rs
    â”‚   â”‚   â”œâ”€â”€ axum_test.rs
    â”‚   â”‚   â”œâ”€â”€ debug_handler.rs
    â”‚   â”‚   â”œâ”€â”€ from_ref.rs
    â”‚   â”‚   â”œâ”€â”€ lib.rs
    â”‚   â”‚   â”œâ”€â”€ typed_path.rs
    â”‚   â”‚   â”œâ”€â”€ with_position.rs
    â”‚   â”‚   â””â”€â”€ from_request/
    â”‚   â”‚       â”œâ”€â”€ attr.rs
    â”‚   â”‚       â””â”€â”€ mod.rs
    â”‚   â””â”€â”€ tests/
    â”‚       â”œâ”€â”€ debug_handler/
    â”‚       â”‚   â”œâ”€â”€ fail/
    â”‚       â”‚   â”‚   â”œâ”€â”€ argument_not_extractor.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ argument_not_extractor.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ duplicate_args.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ duplicate_args.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ extension_not_clone.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ extension_not_clone.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ extract_self_mut.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ extract_self_mut.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ extract_self_ref.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ extract_self_ref.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ generics.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ generics.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ invalid_attrs.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ invalid_attrs.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ json_not_deserialize.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ json_not_deserialize.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ multiple_paths.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ multiple_paths.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ multiple_request_consumers.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ multiple_request_consumers.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_a_function.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_a_function.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_async.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_async.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_send.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_send.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ output_tuple_too_many.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ output_tuple_too_many.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ returning_request_parts.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ returning_request_parts.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ single_wrong_return_tuple.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ single_wrong_return_tuple.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ too_many_extractors.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ too_many_extractors.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_order.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_order.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_return_tuple.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_return_tuple.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_return_type.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ wrong_return_type.stderr
    â”‚       â”‚   â”‚   â””â”€â”€ .gitkeep
    â”‚       â”‚   â””â”€â”€ pass/
    â”‚       â”‚       â”œâ”€â”€ associated_fn_without_self.rs
    â”‚       â”‚       â”œâ”€â”€ deny_unreachable_code.rs
    â”‚       â”‚       â”œâ”€â”€ impl_future.rs
    â”‚       â”‚       â”œâ”€â”€ impl_into_response.rs
    â”‚       â”‚       â”œâ”€â”€ infer_state.rs
    â”‚       â”‚       â”œâ”€â”€ multiple_extractors.rs
    â”‚       â”‚       â”œâ”€â”€ mut_extractor.rs
    â”‚       â”‚       â”œâ”€â”€ ready.rs
    â”‚       â”‚       â”œâ”€â”€ request_last.rs
    â”‚       â”‚       â”œâ”€â”€ result_impl_into_response.rs
    â”‚       â”‚       â”œâ”€â”€ returns_self.rs
    â”‚       â”‚       â”œâ”€â”€ self_receiver.rs
    â”‚       â”‚       â”œâ”€â”€ set_state.rs
    â”‚       â”‚       â””â”€â”€ state_and_body.rs
    â”‚       â”œâ”€â”€ debug_middleware/
    â”‚       â”‚   â”œâ”€â”€ fail/
    â”‚       â”‚   â”‚   â”œâ”€â”€ doesnt_take_next.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ doesnt_take_next.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ next_not_last.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ next_not_last.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ takes_next_twice.rs
    â”‚       â”‚   â”‚   â””â”€â”€ takes_next_twice.stderr
    â”‚       â”‚   â””â”€â”€ pass/
    â”‚       â”‚       â””â”€â”€ basic.rs
    â”‚       â”œâ”€â”€ from_ref/
    â”‚       â”‚   â”œâ”€â”€ fail/
    â”‚       â”‚   â”‚   â”œâ”€â”€ generics.rs
    â”‚       â”‚   â”‚   â””â”€â”€ generics.stderr
    â”‚       â”‚   â””â”€â”€ pass/
    â”‚       â”‚       â”œâ”€â”€ basic.rs
    â”‚       â”‚       â”œâ”€â”€ reference-types.rs
    â”‚       â”‚       â””â”€â”€ skip.rs
    â”‚       â”œâ”€â”€ from_request/
    â”‚       â”‚   â”œâ”€â”€ fail/
    â”‚       â”‚   â”‚   â”œâ”€â”€ double_via_attr.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ double_via_attr.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_from_request_ident_in_variant.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_from_request_ident_in_variant.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_from_request_on_variant.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_from_request_on_variant.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_no_via.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ enum_no_via.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic_without_via.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic_without_via.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic_without_via_rejection.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ generic_without_via_rejection.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_enum_or_struct.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ not_enum_or_struct.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ override_rejection_on_enum_without_via.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ override_rejection_on_enum_without_via.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ parts_extracting_body.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ parts_extracting_body.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ state_infer_multiple_different_types.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ state_infer_multiple_different_types.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ unknown_attr_container.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ unknown_attr_container.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ unknown_attr_field.rs
    â”‚       â”‚   â”‚   â”œâ”€â”€ unknown_attr_field.stderr
    â”‚       â”‚   â”‚   â”œâ”€â”€ via_on_container_and_field.rs
    â”‚       â”‚   â”‚   â””â”€â”€ via_on_container_and_field.stderr
    â”‚       â”‚   â””â”€â”€ pass/
    â”‚       â”‚       â”œâ”€â”€ container.rs
    â”‚       â”‚       â”œâ”€â”€ container_parts.rs
    â”‚       â”‚       â”œâ”€â”€ empty_named.rs
    â”‚       â”‚       â”œâ”€â”€ empty_named_parts.rs
    â”‚       â”‚       â”œâ”€â”€ empty_tuple.rs
    â”‚       â”‚       â”œâ”€â”€ empty_tuple_parts.rs
    â”‚       â”‚       â”œâ”€â”€ enum_via.rs
    â”‚       â”‚       â”œâ”€â”€ enum_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ named.rs
    â”‚       â”‚       â”œâ”€â”€ named_parts.rs
    â”‚       â”‚       â”œâ”€â”€ named_via.rs
    â”‚       â”‚       â”œâ”€â”€ named_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_non_generic.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_non_generic_parts.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_parts.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_with_via_on_enum.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_with_via_on_enum_parts.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_with_via_on_struct.rs
    â”‚       â”‚       â”œâ”€â”€ override_rejection_with_via_on_struct_parts.rs
    â”‚       â”‚       â”œâ”€â”€ state_cookie.rs
    â”‚       â”‚       â”œâ”€â”€ state_enum_via.rs
    â”‚       â”‚       â”œâ”€â”€ state_enum_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ state_explicit.rs
    â”‚       â”‚       â”œâ”€â”€ state_explicit_parts.rs
    â”‚       â”‚       â”œâ”€â”€ state_field_explicit.rs
    â”‚       â”‚       â”œâ”€â”€ state_field_infer.rs
    â”‚       â”‚       â”œâ”€â”€ state_infer.rs
    â”‚       â”‚       â”œâ”€â”€ state_infer_multiple.rs
    â”‚       â”‚       â”œâ”€â”€ state_infer_parts.rs
    â”‚       â”‚       â”œâ”€â”€ state_via.rs
    â”‚       â”‚       â”œâ”€â”€ state_via_infer.rs
    â”‚       â”‚       â”œâ”€â”€ state_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ state_with_rejection.rs
    â”‚       â”‚       â”œâ”€â”€ tuple.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_parts.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_same_type_twice.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_same_type_twice_parts.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_same_type_twice_via.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_same_type_twice_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_via.rs
    â”‚       â”‚       â”œâ”€â”€ tuple_via_parts.rs
    â”‚       â”‚       â”œâ”€â”€ unit.rs
    â”‚       â”‚       â””â”€â”€ unit_parts.rs
    â”‚       â””â”€â”€ typed_path/
    â”‚           â”œâ”€â”€ fail/
    â”‚           â”‚   â”œâ”€â”€ missing_capture.rs
    â”‚           â”‚   â”œâ”€â”€ missing_capture.stderr
    â”‚           â”‚   â”œâ”€â”€ missing_field.rs
    â”‚           â”‚   â”œâ”€â”€ missing_field.stderr
    â”‚           â”‚   â”œâ”€â”€ not_deserialize.rs
    â”‚           â”‚   â”œâ”€â”€ not_deserialize.stderr
    â”‚           â”‚   â”œâ”€â”€ route_not_starting_with_slash.rs
    â”‚           â”‚   â”œâ”€â”€ route_not_starting_with_slash.stderr
    â”‚           â”‚   â”œâ”€â”€ route_not_starting_with_slash_non_empty.rs
    â”‚           â”‚   â”œâ”€â”€ route_not_starting_with_slash_non_empty.stderr
    â”‚           â”‚   â”œâ”€â”€ unit_with_capture.rs
    â”‚           â”‚   â””â”€â”€ unit_with_capture.stderr
    â”‚           â””â”€â”€ pass/
    â”‚               â”œâ”€â”€ customize_rejection.rs
    â”‚               â”œâ”€â”€ into_uri.rs
    â”‚               â”œâ”€â”€ named_fields_struct.rs
    â”‚               â”œâ”€â”€ result_handler.rs
    â”‚               â”œâ”€â”€ tuple_struct.rs
    â”‚               â”œâ”€â”€ unit_struct.rs
    â”‚               â”œâ”€â”€ url_encoding.rs
    â”‚               â””â”€â”€ wildcards.rs
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ anyhow-error-response/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ async-graphql/
    â”‚   â”‚   â””â”€â”€ README.md
    â”‚   â”œâ”€â”€ auto-reload/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ chat/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ chat.html
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ compression/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ data/
    â”‚   â”‚   â”‚   â”œâ”€â”€ products.json
    â”‚   â”‚   â”‚   â””â”€â”€ products.json.gz
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ main.rs
    â”‚   â”‚       â””â”€â”€ tests.rs
    â”‚   â”œâ”€â”€ consume-body-in-extractor-or-middleware/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ cors/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ customize-extractor-error/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ custom_extractor.rs
    â”‚   â”‚       â”œâ”€â”€ derive_from_request.rs
    â”‚   â”‚       â”œâ”€â”€ main.rs
    â”‚   â”‚       â””â”€â”€ with_rejection.rs
    â”‚   â”œâ”€â”€ customize-path-rejection/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ dependency-injection/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ diesel-async-postgres/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ migrations/
    â”‚   â”‚   â”‚   â””â”€â”€ 2023-03-14-180127_add_users/
    â”‚   â”‚   â”‚       â”œâ”€â”€ down.sql
    â”‚   â”‚   â”‚       â””â”€â”€ up.sql
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ diesel-postgres/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ migrations/
    â”‚   â”‚   â”‚   â””â”€â”€ 2023-03-14-180127_add_users/
    â”‚   â”‚   â”‚       â”œâ”€â”€ down.sql
    â”‚   â”‚   â”‚       â””â”€â”€ up.sql
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ error-handling/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ form/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ global-404-handler/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ graceful-shutdown/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ handle-head-request/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ hello-world/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ http-proxy/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ jwt/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ key-value-store/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ low-level-native-tls/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ self_signed_certs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cert.pem
    â”‚   â”‚   â”‚   â””â”€â”€ key.pem
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ low-level-openssl/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ self_signed_certs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cert.pem
    â”‚   â”‚   â”‚   â””â”€â”€ key.pem
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ low-level-rustls/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ self_signed_certs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cert.pem
    â”‚   â”‚   â”‚   â””â”€â”€ key.pem
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ mongodb/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ multipart-form/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ oauth/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ parse-body-based-on-content-type/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ print-request-response/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ prometheus-metrics/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ query-params-with-empty-strings/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ readme/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ request-id/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ reqwest-response/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ reverse-proxy/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ routes-and-handlers-close-together/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ serve-with-hyper/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ simple-router-wasm/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ sqlx-postgres/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ sse/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
    â”‚   â”‚   â”‚   â””â”€â”€ script.js
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ static-file-server/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
    â”‚   â”‚   â”‚   â””â”€â”€ script.js
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ stream-to-file/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ templates/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”‚   â””â”€â”€ main.rs
    â”‚   â”‚   â””â”€â”€ templates/
    â”‚   â”‚       â””â”€â”€ hello.html
    â”‚   â”œâ”€â”€ templates-minijinja/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”‚   â””â”€â”€ main.rs
    â”‚   â”‚   â””â”€â”€ templates/
    â”‚   â”‚       â”œâ”€â”€ about.jinja
    â”‚   â”‚       â”œâ”€â”€ content.jinja
    â”‚   â”‚       â”œâ”€â”€ home.jinja
    â”‚   â”‚       â””â”€â”€ layout.jinja
    â”‚   â”œâ”€â”€ testing/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ testing-websockets/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ tls-graceful-shutdown/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ self_signed_certs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cert.pem
    â”‚   â”‚   â”‚   â””â”€â”€ key.pem
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ tls-rustls/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ self_signed_certs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cert.pem
    â”‚   â”‚   â”‚   â””â”€â”€ key.pem
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ todos/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ tokio-postgres/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ tokio-redis/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ tracing-aka-logging/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ unix-domain-socket/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ validator/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ versioning/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â”œâ”€â”€ websockets/
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
    â”‚   â”‚   â”‚   â””â”€â”€ script.js
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ client.rs
    â”‚   â”‚       â””â”€â”€ main.rs
    â”‚   â””â”€â”€ websockets-http2/
    â”‚       â”œâ”€â”€ Cargo.toml
    â”‚       â”œâ”€â”€ assets/
    â”‚       â”‚   â”œâ”€â”€ index.html
    â”‚       â”‚   â””â”€â”€ script.js
    â”‚       â”œâ”€â”€ self_signed_certs/
    â”‚       â”‚   â”œâ”€â”€ cert.pem
    â”‚       â”‚   â””â”€â”€ key.pem
    â”‚       â””â”€â”€ src/
    â”‚           â””â”€â”€ main.rs
    â”œâ”€â”€ README.md -> README.md
    â””â”€â”€ .github/
        â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md
        â”œâ”€â”€ DISCUSSION_TEMPLATE/
        â”‚   â””â”€â”€ q-a.yml
        â”œâ”€â”€ ISSUE_TEMPLATE/
        â”‚   â”œâ”€â”€ bug_report.md
        â”‚   â”œâ”€â”€ config.yml
        â”‚   â””â”€â”€ feature_request.md
        â””â”€â”€ workflows/
            â””â”€â”€ CI.yml

================================================
FILE: Cargo.toml
================================================
[workspace]
members = ["axum", "axum-*", "examples/*"]
# Only check / build main crates by default (check all with `--workspace`)
default-members = ["axum", "axum-*"]
# Example has been deleted, but README.md remains
exclude = ["examples/async-graphql"]
resolver = "2"

[workspace.package]
rust-version = "1.78"

[workspace.lints.rust]
unsafe_code = "forbid"

rust_2018_idioms = { level = "warn", priority = -1 }
missing_debug_implementations = "warn"
missing_docs = "warn"
unreachable_pub = "warn"

[workspace.lints.clippy]
type_complexity = "allow"

await_holding_lock = "warn"
dbg_macro = "warn"
empty_enum = "warn"
enum_glob_use = "warn"
equatable_if_let = "warn"
exit = "warn"
filter_map_next = "warn"
fn_params_excessive_bools = "warn"
if_let_mutex = "warn"
implicit_clone = "warn"
imprecise_flops = "warn"
inefficient_to_string = "warn"
linkedlist = "warn"
lossy_float_literal = "warn"
macro_use_imports = "warn"
manual_let_else = "warn"
match_same_arms = "warn"
match_wildcard_for_single_variants = "warn"
mem_forget = "warn"
must_use_candidate = "warn"
needless_borrow = "warn"
needless_continue = "warn"
needless_pass_by_ref_mut = "warn"
needless_pass_by_value = "warn"
option_option = "warn"
redundant_clone = "warn"
ref_option = "warn"
rest_pat_in_fully_bound_structs = "warn"
return_self_not_must_use = "warn"
single_match_else = "warn"
str_to_string = "warn"
suboptimal_flops = "warn"
todo = "warn"
trivially_copy_pass_by_ref = "warn"
uninlined_format_args = "warn"
unnested_or_patterns = "warn"
unused_self = "warn"
use_self = "warn"
verbose_file_reads = "warn"

# configuration for https://github.com/crate-ci/typos
[workspace.metadata.typos.default.extend-identifiers]
# These have been fixed in the past, but are still present in the changelog.
DefaultOnFailedUpdgrade = "DefaultOnFailedUpdgrade"
OnFailedUpdgrade = "OnFailedUpdgrade"



================================================
FILE: CHANGELOG.md
================================================
axum's changelog has moved and now lives [here](https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md).



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to axum

ðŸŽˆ Thanks for your help improving the project! We are so happy to have
you!

There are opportunities to contribute to `axum` at any level. It doesn't
matter if you are just getting started with Rust or are the most weathered
expert, we can use your help.

**No contribution is too small and all contributions are valued.**

This guide will help you get started. **Do not let this guide intimidate you**.
It should be considered a map to help you navigate the process.

Don't know where to start? Check [issues labeled with "E-help-wanted"](https://github.com/tokio-rs/axum/issues?q=is%3Aopen+is%3Aissue+label%3AE-help-wanted) or ["E-easy"](https://github.com/tokio-rs/axum/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy).

You may also get help with contributing in the [`axum` Discord
channel][discord], please join us!

[discord]: https://discord.gg/tokio

## Conduct

The `axum` project adheres to the [Rust Code of Conduct][coc]. This
describes the _minimum_ behavior expected from all contributors.

[coc]: https://github.com/rust-lang/rust/blob/master/CODE_OF_CONDUCT.md

## Contributing in Issues

For any issue, there are fundamentally three ways an individual can contribute:

1. By opening the issue for discussion: For instance, if you believe that you
   have uncovered a bug in a `axum` crate, creating a new issue in the
   tokio-rs/axum [issue tracker][issues] is the way to report it.

2. By helping to triage the issue: This can be done by providing
   supporting details (a test case that demonstrates a bug), providing
   suggestions on how to address the issue, or ensuring that the issue is tagged
   correctly.

3. By helping to resolve the issue: Typically this is done either in the form of
   demonstrating that the issue reported is not a problem after all, or more
   often, by opening a Pull Request that changes some bit of something in
   axum in a concrete and reviewable manner.

**Anybody can participate in any stage of contribution**. We urge you to
participate in the discussion around bugs and participate in reviewing PRs.

[issues]: https://github.com/tokio-rs/axum/issues

### Asking for General Help

If you have reviewed existing documentation and still have questions or are
having problems, you can open an issue asking for help.

In exchange for receiving help, we ask that you contribute back a documentation
PR that helps others avoid the problems that you encountered.

### Submitting a Bug Report

When opening a new issue in the `axum` issue tracker, users will
be presented with a [basic template][template] that should be filled in. If you
believe that you have uncovered a bug, please fill out this form, following the
template to the best of your ability. Do not worry if you cannot answer every
detail, just fill in what you can.

The two most important pieces of information we need in order to properly
evaluate the report is a description of the behavior you are seeing and a simple
test case we can use to recreate the problem on our own. If we cannot recreate
the issue, it becomes harder for us to fix.

See [How to create a Minimal, Complete, and Verifiable example][mcve].

[mcve]: https://stackoverflow.com/help/mcve
[template]: .github/ISSUE_TEMPLATE/bug_report.md

### Triaging a Bug Report

Once an issue has been opened, it is not uncommon for there to be discussion
around it. Some contributors may have differing opinions about the issue,
including whether the behavior being seen is a bug or a feature. This discussion
is part of the process and should be kept focused, helpful, and professional.

Short, clipped responsesâ€”that provide neither additional context nor supporting
detailâ€”are not helpful or professional. To many, such responses are simply
annoying and unfriendly.

Contributors are encouraged to help one another make forward progress as much as
possible, empowering one another to solve issues collaboratively. If you choose
to comment on an issue that you feel either is not a problem that needs to be
fixed, or if you encounter information in an issue that you feel is incorrect,
explain why you feel that way with additional supporting context, and be willing
to be convinced that you may be wrong. By doing so, we can often reach the
correct outcome much faster.

### Resolving a Bug Report

In the majority of cases, issues are resolved by opening a Pull Request. The
process for opening and reviewing a Pull Request is similar to that of opening
and triaging issues, but carries with it a necessary review and approval
workflow that ensures that the proposed changes meet the minimal quality.

## Pull Requests

Pull Requests are the way concrete changes are made to the code, documentation,
and dependencies in the `axum` repository.

Even tiny pull requests (e.g., one character pull request fixing a typo in API
documentation) are greatly appreciated. Before making a large change, it is
usually a good idea to first open an issue describing the change to solicit
feedback and guidance. This will increase the likelihood of the PR getting
merged.

### Tests

If the change being proposed alters code (as opposed to only documentation for
example), it is either adding new functionality to a crate or it is fixing
existing, broken functionality. In both of these cases, the pull request should
include one or more tests to ensure that the crate does not regress in the future.

#### Documentation tests

Ideally, every API has at least one [documentation test] that demonstrates how to
use the API. Documentation tests are run with `cargo test --doc`. This ensures
that the example is correct and provides additional test coverage.

The trick to documentation tests is striking a balance between being succinct
for a reader to understand and actually testing the API.

In Rust documentation, lines that start with `/// #` are removed when the
documentation is generated. They are only there to get the test to run.

### Commits

It is a recommended best practice to keep your changes as logically grouped as
possible within individual commits. There is no limit to the number of commits
any single Pull Request may have, and many contributors find it easier to review
changes that are split across multiple commits.

Note that multiple commits often get squashed when they are landed (see the
notes about [commit squashing]).

#### Commit message guidelines

A good commit message should describe what changed and why.

1. The first line should:

  * Contain a short description of the change (preferably 50 characters or less,
    and no more than 72 characters)

2. Keep the second line blank.
3. Wrap all other lines at 72 columns (except for long URLs).
4. If your patch fixes an open issue, you can add a reference to it at the end
   of the log. Use the `Fixes: #` prefix and the issue number. For other
   references use `Refs: #`. `Refs` may include multiple issues, separated by a
   comma.

   Examples:

   - `Fixes: #1337`
   - `Refs: #1234, #42`

### Opening the Pull Request

From within GitHub, opening a new Pull Request will present you with a
[template] that should be filled out. Please try to do your best at filling out
the details, but feel free to skip parts if you're not sure what to put.

[template]: .github/PULL_REQUEST_TEMPLATE.md

### Discuss and update

You will probably get feedback or requests for changes to your Pull Request.
This is a big part of the submission process so don't be discouraged! Some
contributors may sign off on the Pull Request right away, others may have
more detailed comments or feedback. This is a necessary part of the process
in order to evaluate whether the changes are correct and necessary.

**Any community member can review a PR and you might get conflicting feedback**.
Keep an eye out for comments from code owners to provide guidance on conflicting
feedback.

**Once the PR is open, do not rebase the commits**. See [Commit Squashing] for
more details.

### Commit Squashing

In most cases, **do not squash commits that you add to your Pull Request during
the review process**. When the commits in your Pull Request land, they may be
squashed into one commit per logical change. Metadata will be added to the
commit message (including links to the Pull Request, links to relevant issues,
and the names of the reviewers). The commit history of your Pull Request,
however, will stay intact on the Pull Request page.

## Reviewing Pull Requests

**Any Tokio, Hyperium, and Tower, axum community member is welcome to review any pull request**.

All contributors who choose to review and provide feedback on Pull Requests have
a responsibility to both the project and the individual making the contribution.
Reviews and feedback must be helpful, insightful, and geared towards improving
the contribution as opposed to simply blocking it. If there are reasons why you
feel the PR should not land, explain what those are. Do not expect to be able to
block a Pull Request from advancing simply because you say "No" without giving
an explanation. Be open to having your mind changed. Be open to working with the
contributor to make the Pull Request better.

Reviews that are dismissive or disrespectful of the contributor or any other
reviewers are strictly counter to the Code of Conduct.

When reviewing a Pull Request, the primary goals are for the codebase to improve
and for the person submitting the request to succeed. **Even if a Pull Request
does not land, the submitters should come away from the experience feeling like
their effort was not wasted or unappreciated**. Every Pull Request from a new
contributor is an opportunity to grow the community.

### Review a bit at a time.

Do not overwhelm new contributors.

It is tempting to micro-optimize and make everything about relative performance,
perfect grammar, or exact style matches. Do not succumb to that temptation.

Focus first on the most significant aspects of the change:

1. Does this change make sense for axum?
2. Does this change make axum better, even if only incrementally?
3. Are there clear bugs or larger scale issues that need attending to?
4. Is the commit message readable and correct? If it contains a breaking change
   is it clear enough?

Note that only **incremental** improvement is needed to land a PR. This means
that the PR does not need to be perfect, only better than the status quo. Follow
up PRs may be opened to continue iterating.

When changes are necessary, *request* them, do not *demand* them, and **do not
assume that the submitter already knows how to add a test or run a benchmark**.

Specific performance optimization techniques, coding styles and conventions
change over time. The first impression you give to a new contributor never does.

Nits (requests for small changes that are not essential) are fine, but try to
avoid stalling the Pull Request. Most nits can typically be fixed by the axum
Collaborator landing the Pull Request but they can also be an opportunity for
the contributor to learn a bit more about the project.

It is always good to clearly indicate nits when you comment: e.g.
`Nit: change foo() to bar(). But this is not blocking.`

If your comments were addressed but were not folded automatically after new
commits or if they proved to be mistaken, please, [hide them][hiding-a-comment]
with the appropriate reason to keep the conversation flow concise and relevant.

### Be aware of the person behind the code

Be aware that *how* you communicate requests and reviews in your feedback can
have a significant impact on the success of the Pull Request. Yes, we may land a
particular change that makes `axum` better, but the individual might just
not want to have anything to do with `axum` ever again. The goal is not
just having good code.

### Abandoned or Stalled Pull Requests

If a Pull Request appears to be abandoned or stalled, it is polite to first
check with the contributor to see if they intend to continue the work before
checking if they would mind if you took it over (especially if it just has nits
left). When doing so, it is courteous to give the original contributor credit
for the work they started, either by preserving their name and email address in
the commit log, or by using an `Author: ` meta-data tag in the commit.

[hiding-a-comment]: https://help.github.com/articles/managing-disruptive-comments/#hiding-a-comment
[documentation test]: https://doc.rust-lang.org/rustdoc/documentation-tests.html
[keep-a-changelog]: https://github.com/olivierlacan/keep-a-changelog/blob/master/CHANGELOG.md



================================================
FILE: deny.toml
================================================
[graph]
exclude-unpublished = true

[advisories]
unmaintained = "none"
ignore = []

[licenses]
confidence-threshold = 0.8
allow = [
    "Apache-2.0",
    "BSD-3-Clause",
    "MIT",
    "Unicode-3.0",
]

[bans]
multiple-versions = "deny"
highlight = "all"
skip-tree = [
    # currently duplicated through header, reqwest, tower-http and cookie
    # C.f. https://github.com/tokio-rs/axum/pull/1641
    { name = "base64" },
    # parking_lot pulls in old versions of windows-sys
    { name = "windows-sys" },
    # pulled in by quickcheck and cookie
    { name = "rand" },
]

[sources]
unknown-registry = "warn"
unknown-git = "warn"
allow-git = []



================================================
FILE: ECOSYSTEM.md
================================================
# Community Projects

If your project isn't listed here and you would like it to be, please feel free to create a PR.

## Community maintained axum ecosystem

- [axum-server](https://crates.io/crates/axum-server): axum-server is a hyper server implementation designed to be used with axum.
- [axum-typed-websockets](https://crates.io/crates/axum-typed-websockets): `axum::extract::ws` with type safe messages.
- [tower-cookies](https://crates.io/crates/tower-cookies): Cookie manager middleware
- [axum-flash](https://crates.io/crates/axum-flash): One-time notifications (aka flash messages) for axum.
- [axum-msgpack](https://crates.io/crates/axum-msgpack): MessagePack Extractors for axum.
- [axum-sqlx-tx](https://crates.io/crates/axum-sqlx-tx): Request-bound [SQLx](https://github.com/launchbadge/sqlx#readme) transactions with automatic commit/rollback based on response.
- [aliri_axum](https://docs.rs/aliri_axum) and [aliri_tower](https://docs.rs/aliri_tower): JWT validation middleware and OAuth2 scopes enforcing extractors.
- [ezsockets](https://github.com/gbaranski/ezsockets): Easy to use WebSocket library that integrates with axum.
- [axum_session](https://github.com/AscendingCreations/AxumSessions): Database persistent sessions like pythons flask_sessionstore for axum.
- [axum_session_auth](https://github.com/AscendingCreations/AxumSessionsAuth): Persistent session based user login with rights management for axum.
- [axum-auth](https://crates.io/crates/axum-auth): High-level http auth extractors for axum.
- [axum-keycloak-auth](https://github.com/lpotthast/axum-keycloak-auth): Protect axum routes with a JWT emitted by Keycloak.
- [axum-tungstenite](https://github.com/davidpdrsn/axum-tungstenite): WebSocket connections for axum directly using tungstenite
- [axum-jrpc](https://github.com/0xdeafbeef/axum-jrpc): Json-rpc extractor for axum
- [axum-tracing-opentelemetry](https://crates.io/crates/axum-tracing-opentelemetry): Middlewares and tools to integrate axum + tracing + opentelemetry
- [svelte-axum-project](https://github.com/jbertovic/svelte-axum-project): Template and example for Svelte frontend app with axum as backend
- [axum-streams](https://github.com/abdolence/axum-streams-rs): Streaming HTTP body with different formats: JSON, CSV, Protobuf.
- [axum-template](https://github.com/Altair-Bueno/axum-template): Layers, extractors and template engine wrappers for axum based Web MVC applications
- [axum-template](https://github.com/janos-r/axum-template): GraphQL and REST API, SurrealDb, JWT auth, direct error handling, request logs
- [axum-guard-logic](https://github.com/sjud/axum_guard_logic): Use AND/OR logic to extract types and check their values against `Service` inputs.
- [axum-casbin-auth](https://github.com/casbin-rs/axum-casbin-auth): Casbin access control middleware for axum framework
- [aide](https://docs.rs/aide): Code-first Open API documentation generator with [axum integration](https://docs.rs/aide/latest/aide/axum/index.html).
- [axum-typed-routing](https://docs.rs/axum-typed-routing/latest/axum_typed_routing/): Statically typed routing macros with OpenAPI generation using aide.
- [axum-jsonschema](https://docs.rs/axum-jsonschema/): A `Json<T>` extractor that does JSON schema validation of requests.
- [axum-login](https://docs.rs/axum-login): Session-based user authentication for axum.
- [axum-csrf-sync-pattern](https://crates.io/crates/axum-csrf-sync-pattern): A middleware implementing CSRF STP for AJAX backends and API endpoints.
- [axum-otel-metrics](https://github.com/ttys3/axum-otel-metrics/): A axum OpenTelemetry Metrics middleware with prometheus exporter supported.
- [tower-otel](https://github.com/mattiapenati/tower-otel): OpenTelemetry layer for HTTP/gRPC services with optional axum integration.
- [jwt-authorizer](https://crates.io/crates/jwt-authorizer): JWT authorization layer for axum (oidc discovery, validation options, claims extraction, etc.)
- [axum-typed-multipart](https://crates.io/crates/axum_typed_multipart): Type safe wrapper for `axum::extract::Multipart`.
- [tower-governor](https://crates.io/crates/tower_governor): A Tower service and layer that provides a rate-limiting backend by [governor](https://crates.io/crates/governor)
- [axum-restful](https://github.com/gongzhengyang/axum-restful): A restful framework based on axum and sea-orm, inspired by django-rest-framework.
- [springtime-web-axum](https://crates.io/crates/springtime-web-axum): A web framework built on Springtime and axum, leveraging dependency injection for easy app development.
- [rust-axum-with-google-oauth](https://github.com/randommm/rust-axum-with-google-oauth): website template for Google OAuth authentication on axum, using SQLite with SQLx or MongoDB and MiniJinja.
- [axum-htmx](https://github.com/robertwayne/axum-htmx): Htmx extractors and request guards for axum.
- [axum-prometheus](https://github.com/ptrskay3/axum-prometheus): A middleware library to collect HTTP metrics for axum applications, compatible with all [metrics.rs](https://metrics.rs) exporters.
- [axum-valid](https://github.com/gengteng/axum-valid): Extractors for data validation using validator, garde, and validify.
- [tower-sessions](https://github.com/maxcountryman/tower-sessions): Sessions as a `tower` and `axum` middleware.
- [shuttle](https://github.com/shuttle-hq/shuttle): Build & ship backends without writing any infrastructure files. Now with axum support.
- [socketioxide](https://github.com/totodore/socketioxide): An easy to use socket.io server implementation working as a `tower` layer/service.
- [axum-serde](https://github.com/gengteng/axum-serde): Provides multiple serde-based extractors / responses, also offers a macro to easily customize serde-based extractors / responses.
- [loco.rs](https://github.com/loco-rs/loco): A full stack Web and API productivity framework similar to Rails, based on axum.
- [axum-test](https://crates.io/crates/axum-test): High level library for writing Cargo tests that run against axum.
- [axum-messages](https://github.com/maxcountryman/axum-messages): One-time notification messages for axum.
- [spring-rs](https://github.com/spring-rs/spring-rs): spring-rs is a microservice framework written in rust inspired by java's spring-boot, based on axum
- [zino](https://github.com/zino-rs/zino): Zino is a next-generation framework for composable applications which provides full integrations with axum.
- [axum-rails-cookie](https://github.com/endoze/axum-rails-cookie): Extract rails session cookies in axum based apps.
- [axum-ws-broadcaster](https://github.com/Necoo33/axum-ws-broadcaster): A broadcasting liblary for both [axum-typed-websockets](https://crates.io/crates/axum-typed-websockets) and `axum::extract::ws`.
- [axum-negotiate-layer](https://github.com/2ndDerivative/axum-negotiate-layer): Middleware/Layer for Kerberos/NTLM "Negotiate" authentication.
- [axum-kit](https://github.com/4lkaid/axum-kit): Streamline the integration and usage of axum with SQLx and Redis.
- [tower_allowed_hosts](https://crates.io/crates/tower_allowed_hosts): Allowed hosts middleware which limits request from only allowed hosts.
- [baxe](https://github.com/zyphelabs/baxe): Simple macro for defining backend errors once and automatically generate standardized JSON error responses, saving time and reducing complexity
- [axum-html-minifier](https://crates.io/crates/axum_html_minifier): This middleware minify the html body content of a axum response.
- [static-serve](https://crates.io/crates/static-serve): A helper macro for compressing and embedding static assets in an axum webserver.
- [datastar](https://crates.io/crates/datastar): Rust implementation of the Datastar SDK specification with Axum support
- [axum-governor](https://crates.io/crates/axum-governor): An independent Axum middleware for rate limiting, powered by [lazy-limit](https://github.com/canmi21/lazy-limit) (not related to tower-governor).

## Project showcase

- [HomeDisk](https://github.com/MedzikUser/HomeDisk): â˜ï¸ Fast, lightweight and Open Source local cloud for your data.
- [Houseflow](https://github.com/gbaranski/houseflow): House automation platform written in Rust.
- [JWT Auth](https://github.com/Z4RX/axum_jwt_example): JWT auth service for educational purposes.
- [ROAPI](https://github.com/roapi/roapi): Create full-fledged APIs for static datasets without writing a single line of code.
- [notify.run](https://github.com/notify-run/notify-run-rs): HTTP-to-WebPush relay for sending desktop/mobile notifications to yourself, written in Rust.
- [turbo.fish](https://turbo.fish/) ([repository](https://github.com/jplatte/turbo.fish)): Find out for yourself ðŸ˜‰
- [Book Management](https://github.com/lz1998/axum-book-management): CRUD system of book-management with ORM and JWT for educational purposes.
- [realworld-axum-sqlx](https://github.com/launchbadge/realworld-axum-sqlx): A Rust implementation of the [Realworld] demo app spec using axum and [SQLx].
  See https://github.com/davidpdrsn/realworld-axum-sqlx for a fork with up to date dependencies.
- [Rustapi](https://github.com/ndelvalle/rustapi): RESTful API template using MongoDB
- [axum-postgres-template](https://github.com/koskeller/axum-postgres-template): Production-ready axum + PostgreSQL application template
- [RUSTfulapi](https://github.com/robatipoor/rustfulapi): Reusable template for building REST Web Services in Rust. Uses axum and SeaORM.
- [Jotsy](https://github.com/ohsayan/jotsy): Self-hosted notes app powered by Skytable, axum and Tokio
- [Svix](https://www.svix.com) ([repository](https://github.com/svix/svix-webhooks)): Enterprise-ready webhook service
- [emojied](https://emojied.net) ([repository](https://github.com/sekunho/emojied)): Shorten URLs to emojis!
- [CLOMonitor](https://clomonitor.io) ([repository](https://github.com/cncf/clomonitor)): Checks open source projects repositories to verify they meet certain best practices.
- [Pinging.net](https://www.pinging.net) ([repository](https://github.com/benhansenslc/pinging)): A new way to check and monitor your internet connection.
- [wastebin](https://github.com/matze/wastebin): A minimalist pastebin service.
- [sandbox_axum_observability](https://github.com/davidB/sandbox_axum_observability) A Sandbox/showcase project to experiment axum and observability (tracing, opentelemetry, jaeger, grafana tempo,...)
- [axum_admin](https://github.com/lingdu1234/axum_admin): An admin panel built with **axum**, Sea-orm and Vue 3.
- [rgit](https://git.inept.dev/~doyle/rgit.git/about): A blazingly fast Git repository browser, compatible with- and heavily inspired by cgit.
- [Petclinic](https://github.com/danipardo/petclinic): A port of Spring Framework's Petclinic showcase project to axum
- [axum-middleware-example](https://github.com/casbin-rs/axum-middleware-example): A authorization application using axum, Casbin and Diesel, with JWT support.
- [circleci-hook](https://github.com/DavidS/circleci-hook): Translate CircleCI WebHooks to OpenTelemetry traces to improve your test insights. Add detail with otel-cli to capture individual commands. Use the TRACEPARENT integration to add details from your tests.
- [lishuuro.org](https://github.com/uros-5/backend-lishuuro): Small chess variant server that uses axum for the backend.
- [freedit](https://github.com/freedit-org/freedit): A forum powered by rust.
- [axum-http-auth-example](https://github.com/i0n/axum-http-auth-example): axum http auth example using postgres and redis.
- [Deaftone](https://github.com/Deaftone/Deaftone): Lightweight music server. With a clean and simple API
- [dropit](https://github.com/scotow/dropit): Temporary file hosting.
- [cobrust](https://github.com/scotow/cobrust): Multiplayer web based snake game.
- [meta-cross](https://github.com/scotow/meta-cross): Tweaked version of Tic-Tac-Toe.
- [httq](https://github.com/scotow/httq) HTTP to MQTT trivial proxy.
- [Pods-Blitz](https://pods-blitz.org) Self-hosted podcast publisher. Uses the crates axum-login, password-auth, sqlx and handlebars (for HTML templates).
- [ReductStore](https://github.com/reductstore/reductstore): A time series database for storing and managing large amounts of blob data
- [randoku](https://github.com/stchris/randoku): A tiny web service which generates random numbers and shuffles lists randomly
- [sero](https://github.com/clowzed/sero): Host static sites with custom subdomains as surge.sh does. But with full control and cool new features. (axum, sea-orm, postgresql)
- [Hatsu](https://github.com/importantimport/hatsu): ðŸ©µ Self-hosted & Fully-automated ActivityPub Bridge for Static Sites.
- [Mini RPS](https://github.com/marcodpt/minirps): Mini reverse proxy server, HTTPS, CORS, static file hosting and template engine (minijinja).
- [fx](https://github.com/rikhuijzer/fx): A (micro)blogging server that you can self-host.
- [clean_axum_demo](https://github.com/sukjaelee/clean_axum_demo): A modern, clean-architecture Rust API server template built with Axum and SQLx. It incorporates domain-driven design, repository patterns, JWT authentication, file uploads, Swagger documentation, OpenTelemetry.
- [qiluo-admin](https://github.com/chelunfu/qiluo_admin) | Axum + SeaORM + JWT + Scheduled + Tasks + SnowId + Redis + Memory + VUE3 | DB: MySQL, Postgres, SQLite
- [openapi-rs](https://github.com/baerwang/openapi-rs/tree/main/examples/axum) | This project adds a middleware layer to axum using openapi-rs, enabling automatic request validation and processing based on OpenAPI 3.1 specifications. It helps ensure that the server behavior strictly follows the OpenAPI contract.

[Realworld]: https://github.com/gothinkster/realworld
[SQLx]: https://github.com/launchbadge/sqlx

## Tutorials

- [Rust on Nails](https://rust-on-nails.com/): A full stack architecture for Rust web applications
- [axum-tutorial] ([website][axum-tutorial-website]): axum tutorial for beginners
- [demo-rust-axum]: Demo of Rust and axum web framework
- [Introduction to axum (talk)]: Talk about axum from the Copenhagen Rust Meetup
- [Getting Started with Axum]: axum tutorial, GET, POST endpoints and serving files
- [Using Rust, Axum, PostgreSQL, and Tokio to build a Blog]
- [Introduction to axum]: YouTube playlist
- [Rust Axum Full Course]: YouTube video
- [Deploying Axum projects with Shuttle]
- [API Development with Rust](https://rust-api.dev/docs/front-matter/preface/): REST APIs based on axum

[axum-tutorial]: https://github.com/programatik29/axum-tutorial
[axum-tutorial-website]: https://programatik29.github.io/axum-tutorial/
[demo-rust-axum]: https://github.com/joelparkerhenderson/demo-rust-axum
[Introduction to axum (talk)]: https://www.youtube.com/watch?v=ETdmhh7OQpA
[Getting Started with Axum]: https://carlosmv.hashnode.dev/getting-started-with-axum-rust
[Using Rust, Axum, PostgreSQL, and Tokio to build a Blog]: https://spacedimp.com/blog/using-rust-axum-postgresql-and-tokio-to-build-a-blog/
[Introduction to axum]: https://www.youtube.com/playlist?list=PLrmY5pVcnuE-_CP7XZ_44HN-mDrLQV4nS
[Rust Axum Full Course]: https://www.youtube.com/watch?v=XZtlD_m59sM
[Deploying Axum projects with Shuttle]: https://docs.shuttle.rs/examples/axum

[Building a SaaS with Rust & Next.js](https://joshmo.bearblog.dev/lets-build-a-saas-with-rust/) A tutorial for combining Next.js with Rust via axum to make a SaaS.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2019â€“2025 axum Contributors

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


================================================
FILE: .clippy.toml
================================================
allow-mixed-uninlined-format-args = false
disallowed-types = [
    { path = "tower::util::BoxCloneService", reason = "Use tower::util::BoxCloneSyncService instead" },
]



================================================
FILE: axum/README.md
================================================
# axum

`axum` is a web application framework that focuses on ergonomics and modularity.

[![Build status](https://github.com/tokio-rs/axum/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/tokio-rs/axum/actions/workflows/CI.yml)
[![Crates.io](https://img.shields.io/crates/v/axum)](https://crates.io/crates/axum)
[![Documentation](https://docs.rs/axum/badge.svg)][docs]

More information about this crate can be found in the [crate documentation][docs].

## High level features

- Route requests to handlers with a macro free API.
- Declaratively parse requests using extractors.
- Simple and predictable error handling model.
- Generate responses with minimal boilerplate.
- Take full advantage of the [`tower`] and [`tower-http`] ecosystem of
  middleware, services, and utilities.

In particular the last point is what sets `axum` apart from other frameworks.
`axum` doesn't have its own middleware system but instead uses
[`tower::Service`]. This means `axum` gets timeouts, tracing, compression,
authorization, and more, for free. It also enables you to share middleware with
applications written using [`hyper`] or [`tonic`].

## âš  Breaking changes âš 

We are currently working towards axum 0.9 so the `main` branch contains breaking
changes. See the [`0.8.x`] branch for what's released to crates.io.

[`0.8.x`]: https://github.com/tokio-rs/axum/tree/v0.8.x

## Usage example

```rust
use axum::{
    routing::{get, post},
    http::StatusCode,
    Json, Router,
};
use serde::{Deserialize, Serialize};

#[tokio::main]
async fn main() {
    // initialize tracing
    tracing_subscriber::fmt::init();

    // build our application with a route
    let app = Router::new()
        // `GET /` goes to `root`
        .route("/", get(root))
        // `POST /users` goes to `create_user`
        .route("/users", post(create_user));

    // run our app with hyper, listening globally on port 3000
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// basic handler that responds with a static string
async fn root() -> &'static str {
    "Hello, World!"
}

async fn create_user(
    // this argument tells axum to parse the request body
    // as JSON into a `CreateUser` type
    Json(payload): Json<CreateUser>,
) -> (StatusCode, Json<User>) {
    // insert your application logic here
    let user = User {
        id: 1337,
        username: payload.username,
    };

    // this will be converted into a JSON response
    // with a status code of `201 Created`
    (StatusCode::CREATED, Json(user))
}

// the input to our `create_user` handler
#[derive(Deserialize)]
struct CreateUser {
    username: String,
}

// the output to our `create_user` handler
#[derive(Serialize)]
struct User {
    id: u64,
    username: String,
}
```

You can find this [example][readme-example] as well as other example projects in
the [example directory][examples].

See the [crate documentation][docs] for way more examples.

## Performance

`axum` is a relatively thin layer on top of [`hyper`] and adds very little
overhead. So `axum`'s performance is comparable to [`hyper`]. You can find
benchmarks [here](https://github.com/programatik29/rust-web-benchmarks) and
[here](https://web-frameworks-benchmark.netlify.app/result?l=rust).

## Safety

This crate uses `#![forbid(unsafe_code)]` to ensure everything is implemented in
100% safe Rust.

## Minimum supported Rust version

axum's MSRV is 1.78.

## Examples

The [examples] folder contains various examples of how to use `axum`. The
[docs] also provide lots of code snippets and examples. For full-fledged examples, check out community-maintained [showcases] or [tutorials].

## Getting Help

In the `axum`'s repo we also have a [number of examples][examples] showing how
to put everything together. Community-maintained [showcases] and [tutorials] also demonstrate how to use `axum` for real-world applications. You're also welcome to ask in the [Discord channel][chat] or open a [discussion] with your question.

## Community projects

See [here][ecosystem] for a list of community maintained crates and projects
built with `axum`.

## Contributing

ðŸŽˆ Thanks for your help improving the project! We are so happy to have
you! We have a [contributing guide][contributing] to help you get involved in the
`axum` project.

## License

This project is licensed under the [MIT license][license].

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in `axum` by you, shall be licensed as MIT, without any
additional terms or conditions.

[readme-example]: https://github.com/tokio-rs/axum/tree/main/examples/readme
[examples]: https://github.com/tokio-rs/axum/tree/main/examples
[docs]: https://docs.rs/axum
[`tower`]: https://crates.io/crates/tower
[`hyper`]: https://crates.io/crates/hyper
[`tower-http`]: https://crates.io/crates/tower-http
[`tonic`]: https://crates.io/crates/tonic
[contributing]: https://github.com/tokio-rs/axum/blob/main/CONTRIBUTING.md
[chat]: https://discord.gg/tokio
[discussion]: https://github.com/tokio-rs/axum/discussions/new?category=q-a
[`tower::Service`]: https://docs.rs/tower/latest/tower/trait.Service.html
[ecosystem]: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md
[showcases]: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#project-showcase
[tutorials]: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#tutorials
[license]: https://github.com/tokio-rs/axum/blob/main/axum/LICENSE



================================================
FILE: axum/Cargo.toml
================================================
[package]
name = "axum"
version = "0.8.4" # remember to bump the version that axum-extra depends on
categories = ["asynchronous", "network-programming", "web-programming::http-server"]
description = "Web framework that focuses on ergonomics and modularity"
edition = "2021"
rust-version = { workspace = true }
homepage = "https://github.com/tokio-rs/axum"
keywords = ["http", "web", "framework"]
license = "MIT"
readme = "README.md"
repository = "https://github.com/tokio-rs/axum"

[package.metadata.docs.rs]
all-features = true

[package.metadata.playground]
features = ["http1", "http2", "json", "multipart", "ws"]

[package.metadata.cargo-public-api-crates]
allowed = [
    # our crates
    "axum_core",
    "axum_macros",
    # not 1.0
    "futures_core",
    "futures_sink",
    "futures_util",
    "pin_project_lite",
    "tower_layer",
    "tower_service",
    # >=1.0
    "bytes",
    "http",
    "http_body",
    "serde_core",
    "tokio",
    # for the `__private` feature
    "reqwest",
]

[features]
default = [
    "form",
    "http1",
    "json",
    "matched-path",
    "original-uri",
    "query",
    "tokio",
    "tower-log",
    "tracing",
]
form = ["dep:form_urlencoded", "dep:serde_urlencoded", "dep:serde_path_to_error"]
http1 = ["dep:hyper", "hyper?/http1", "hyper-util?/http1"]
http2 = ["dep:hyper", "hyper?/http2", "hyper-util?/http2"]
json = ["dep:serde_json", "dep:serde_path_to_error"]
macros = ["dep:axum-macros"]
matched-path = []
multipart = ["dep:multer"]
original-uri = []
query = ["dep:form_urlencoded", "dep:serde_urlencoded", "dep:serde_path_to_error"]
tokio = [
    "dep:hyper-util",
    "dep:tokio",
    "tokio/net",
    "tokio/rt",
    "tower/make",
    "tokio/macros",
]
tower-log = ["tower/log"]
tracing = ["dep:tracing", "axum-core/tracing"]
ws = ["dep:hyper", "tokio", "dep:tokio-tungstenite", "dep:sha1", "dep:base64"]

__private_docs = [
    # We re-export some docs from axum-core via #[doc(inline)],
    # but they need the same sort of treatment as below to be complete
    "axum-core/__private_docs",
    # Enables upstream things linked to in docs
    "tower/full",
    "dep:serde",
    "dep:tower-http",
]

# This feature is used to enable private test helper usage
# in `axum-core` and `axum-extra`.
__private = ["tokio", "http1", "dep:reqwest"]

[dependencies]
axum-core = { path = "../axum-core", version = "0.5.2" }
bytes = "1.0"
futures-core = "0.3"
futures-sink = "0.3"
futures-util = { version = "0.3", default-features = false, features = ["alloc"] }
http = "1.0.0"
http-body = "1.0.0"
http-body-util = "0.1.0"
itoa = "1.0.5"
matchit = "=0.8.4"
memchr = "2.4.1"
mime = "0.3.16"
percent-encoding = "2.1"
pin-project-lite = "0.2.7"
serde_core = "1.0.221"
sync_wrapper = "1.0.0"
tower = { version = "0.5.2", default-features = false, features = ["util"] }
tower-layer = "0.3.2"
tower-service = "0.3"

# optional dependencies
axum-macros = { path = "../axum-macros", version = "0.5.0", optional = true }
base64 = { version = "0.22.1", optional = true }
form_urlencoded = { version = "1.1.0", optional = true }
hyper = { version = "1.1.0", optional = true }
hyper-util = { version = "0.1.3", features = ["tokio", "server", "service"], optional = true }
multer = { version = "3.0.0", optional = true }
reqwest = { version = "0.12", optional = true, default-features = false, features = ["json", "stream", "multipart"] }
serde_json = { version = "1.0", features = ["raw_value"], optional = true }
serde_path_to_error = { version = "0.1.8", optional = true }
serde_urlencoded = { version = "0.7", optional = true }
sha1 = { version = "0.10", optional = true }
tokio = { package = "tokio", version = "1.44", features = ["time"], optional = true }
tokio-tungstenite = { version = "0.27.0", optional = true }
tracing = { version = "0.1", default-features = false, optional = true }

# doc dependencies
serde = { version = "1.0.211", optional = true }

[dependencies.tower-http]
version = "0.6.0"
optional = true
features = [
    # all tower-http features except (de)?compression-zstd which doesn't
    # build on `--target armv5te-unknown-linux-musleabi`
    "add-extension",
    "auth",
    "catch-panic",
    "compression-br",
    "compression-deflate",
    "compression-gzip",
    "cors",
    "decompression-br",
    "decompression-deflate",
    "decompression-gzip",
    "follow-redirect",
    "fs",
    "limit",
    "map-request-body",
    "map-response-body",
    "metrics",
    "normalize-path",
    "propagate-header",
    "redirect",
    "request-id",
    "sensitive-headers",
    "set-header",
    "set-status",
    "timeout",
    "trace",
    "util",
    "validate-request",
]

[dev-dependencies]
anyhow = "1.0"
axum-extra = { path = "../axum-extra", features = ["typed-header"] }
axum-macros = { path = "../axum-macros", features = ["__private"] }
hyper = { version = "1.1.0", features = ["client"] }
quickcheck = "1.0"
quickcheck_macros = "1.0"
reqwest = { version = "0.12", default-features = false, features = ["json", "stream", "multipart"] }
serde = { version = "1.0.221", features = ["derive"] }
serde_json = { version = "1.0", features = ["raw_value"] }
time = { version = "0.3", features = ["serde-human-readable"] }
tokio = { package = "tokio", version = "1.44.2", features = ["macros", "rt", "rt-multi-thread", "net", "test-util"] }
tokio-stream = "0.1"
tokio-tungstenite = "0.27.0"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json"] }
uuid = { version = "1.0", features = ["serde", "v4"] }

[dev-dependencies.tower]
package = "tower"
version = "0.5.2"
features = [
    "util",
    "timeout",
    "limit",
    "load-shed",
    "steer",
    "filter",
]

[dev-dependencies.tower-http]
version = "0.6.0"
features = [
    # all tower-http features except (de)?compression-zstd which doesn't
    # build on `--target armv5te-unknown-linux-musleabi`
    "add-extension",
    "auth",
    "catch-panic",
    "compression-br",
    "compression-deflate",
    "compression-gzip",
    "cors",
    "decompression-br",
    "decompression-deflate",
    "decompression-gzip",
    "follow-redirect",
    "fs",
    "limit",
    "map-request-body",
    "map-response-body",
    "metrics",
    "normalize-path",
    "propagate-header",
    "redirect",
    "request-id",
    "sensitive-headers",
    "set-header",
    "set-status",
    "timeout",
    "trace",
    "util",
    "validate-request",
]

[lints]
workspace = true

[[bench]]
name = "benches"
harness = false



================================================
FILE: axum/benches/benches.rs
================================================
#![allow(missing_docs)]

use axum::{
    extract::State,
    routing::{get, post},
    Extension, Json, Router,
};
use serde::{Deserialize, Serialize};
use std::{
    future::IntoFuture,
    io::BufRead,
    process::{Command, Stdio},
};

fn main() {
    if on_ci() {
        install_rewrk();
    } else {
        ensure_rewrk_is_installed();
    }

    benchmark("minimal").run(Router::new);

    benchmark("basic")
        .path("/a/b/c")
        .run(|| Router::new().route("/a/b/c", get(|| async { "Hello, World!" })));

    benchmark("basic-merge").path("/a/b/c").run(|| {
        let inner = Router::new().route("/a/b/c", get(|| async { "Hello, World!" }));
        Router::new().merge(inner)
    });

    benchmark("basic-nest").path("/a/b/c").run(|| {
        let c = Router::new().route("/c", get(|| async { "Hello, World!" }));
        let b = Router::new().nest("/b", c);
        Router::new().nest("/a", b)
    });

    benchmark("routing").path("/foo/bar/baz").run(|| {
        let mut app = Router::new();
        for a in 0..10 {
            for b in 0..10 {
                for c in 0..10 {
                    app = app.route(&format!("/foo-{a}/bar-{b}/baz-{c}"), get(|| async {}));
                }
            }
        }
        app.route("/foo/bar/baz", get(|| async {}))
    });

    benchmark("receive-json")
        .method("post")
        .headers(&[("content-type", "application/json")])
        .body(r#"{"n": 123, "s": "hi there", "b": false}"#)
        .run(|| Router::new().route("/", post(|_: Json<Payload>| async {})));

    benchmark("send-json").run(|| {
        Router::new().route(
            "/",
            get(|| async {
                Json(Payload {
                    n: 123,
                    s: "hi there".to_owned(),
                    b: false,
                })
            }),
        )
    });

    let state = AppState {
        _string: "aaaaaaaaaaaaaaaaaa".to_owned(),
        _vec: Vec::from([
            "aaaaaaaaaaaaaaaaaa".to_owned(),
            "bbbbbbbbbbbbbbbbbb".to_owned(),
            "cccccccccccccccccc".to_owned(),
        ]),
    };

    benchmark("extension").run(|| {
        Router::new()
            .route("/", get(|_: Extension<AppState>| async {}))
            .layer(Extension(state.clone()))
    });

    benchmark("state").run(|| {
        Router::new()
            .route("/", get(|_: State<AppState>| async {}))
            .with_state(state.clone())
    });
}

#[derive(Clone)]
struct AppState {
    _string: String,
    _vec: Vec<String>,
}

#[derive(Deserialize, Serialize)]
struct Payload {
    n: u32,
    s: String,
    b: bool,
}

fn benchmark(name: &'static str) -> BenchmarkBuilder {
    BenchmarkBuilder {
        name,
        path: None,
        method: None,
        headers: None,
        body: None,
    }
}

struct BenchmarkBuilder {
    name: &'static str,
    path: Option<&'static str>,
    method: Option<&'static str>,
    headers: Option<&'static [(&'static str, &'static str)]>,
    body: Option<&'static str>,
}

macro_rules! config_method {
    ($name:ident, $ty:ty) => {
        fn $name(mut self, $name: $ty) -> Self {
            self.$name = Some($name);
            self
        }
    };
}

impl BenchmarkBuilder {
    config_method!(path, &'static str);
    config_method!(method, &'static str);
    config_method!(headers, &'static [(&'static str, &'static str)]);
    config_method!(body, &'static str);

    fn run<F>(self, f: F)
    where
        F: FnOnce() -> Router<()>,
    {
        // support only running some benchmarks with
        // ```
        // cargo bench -- routing send-json
        // ```
        let args = std::env::args().collect::<Vec<_>>();
        if args.len() != 1 {
            let names = &args[1..args.len() - 1];
            if !names.is_empty() && !names.contains(&self.name.to_owned()) {
                return;
            }
        }

        let app = f();

        let rt = tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .unwrap();

        let listener = rt
            .block_on(tokio::net::TcpListener::bind("0.0.0.0:0"))
            .unwrap();
        let addr = listener.local_addr().unwrap();

        std::thread::spawn(move || {
            rt.block_on(axum::serve(listener, app).into_future())
                .unwrap();
        });

        let mut cmd = Command::new("rewrk");
        cmd.stdout(Stdio::piped());

        cmd.arg("--host");
        cmd.arg(format!("http://{addr}{}", self.path.unwrap_or("")));

        cmd.args(["--connections", "10"]);
        cmd.args(["--threads", "10"]);

        if on_ci() {
            // don't slow down CI by running the benchmarks for too long
            // but do run them for a bit
            cmd.args(["--duration", "1s"]);
        } else {
            cmd.args(["--duration", "10s"]);
        }

        if let Some(method) = self.method {
            cmd.args(["--method", method]);
        }

        for (key, value) in self.headers.into_iter().flatten() {
            cmd.arg("--header");
            cmd.arg(format!("{key}: {value}"));
        }

        if let Some(body) = self.body {
            cmd.args(["--body", body]);
        }

        eprintln!("Running {:?} benchmark", self.name);

        // indent output from `rewrk` so it's easier to read when running multiple benchmarks
        let mut child = cmd.spawn().unwrap();
        let stdout = child.stdout.take().unwrap();
        let stdout = std::io::BufReader::new(stdout);
        for line in stdout.lines() {
            let line = line.unwrap();
            println!("  {line}");
        }

        let status = child.wait().unwrap();

        if !status.success() {
            eprintln!("`rewrk` command failed");
            std::process::exit(status.code().unwrap());
        }
    }
}

fn install_rewrk() {
    println!("installing rewrk");
    let mut cmd = Command::new("cargo");
    cmd.args([
        "install",
        "rewrk",
        "--git",
        "https://github.com/ChillFish8/rewrk.git",
    ]);
    let status = cmd
        .status()
        .unwrap_or_else(|_| panic!("failed to install rewrk"));
    if !status.success() {
        panic!("failed to install rewrk");
    }
}

fn ensure_rewrk_is_installed() {
    let mut cmd = Command::new("rewrk");
    cmd.arg("--help");
    cmd.stdout(Stdio::null());
    cmd.stderr(Stdio::null());
    cmd.status().unwrap_or_else(|_| {
        panic!("rewrk is not installed. See https://github.com/lnx-search/rewrk")
    });
}

fn on_ci() -> bool {
    std::env::var("GITHUB_ACTIONS").is_ok()
}



================================================
SYMLINK: axum/LICENSE -> LICENSE
================================================



================================================
FILE: axum/src/boxed.rs
================================================
use std::{convert::Infallible, fmt};

use crate::extract::Request;
use tower::Service;

use crate::{
    handler::Handler,
    routing::{future::RouteFuture, Route},
    Router,
};

pub(crate) struct BoxedIntoRoute<S, E>(Box<dyn ErasedIntoRoute<S, E>>);

impl<S> BoxedIntoRoute<S, Infallible>
where
    S: Clone + Send + Sync + 'static,
{
    pub(crate) fn from_handler<H, T>(handler: H) -> Self
    where
        H: Handler<T, S>,
        T: 'static,
    {
        Self(Box::new(MakeErasedHandler {
            handler,
            into_route: |handler, state| Route::new(Handler::with_state(handler, state)),
        }))
    }
}

impl<S, E> BoxedIntoRoute<S, E> {
    pub(crate) fn map<F, E2>(self, f: F) -> BoxedIntoRoute<S, E2>
    where
        S: 'static,
        E: 'static,
        F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + Sync + 'static,
        E2: 'static,
    {
        BoxedIntoRoute(Box::new(Map {
            inner: self.0,
            layer: Box::new(f),
        }))
    }

    pub(crate) fn into_route(self, state: S) -> Route<E> {
        self.0.into_route(state)
    }
}

impl<S, E> Clone for BoxedIntoRoute<S, E> {
    fn clone(&self) -> Self {
        Self(self.0.clone_box())
    }
}

impl<S, E> fmt::Debug for BoxedIntoRoute<S, E> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("BoxedIntoRoute").finish()
    }
}

pub(crate) trait ErasedIntoRoute<S, E>: Send + Sync {
    fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, E>>;

    fn into_route(self: Box<Self>, state: S) -> Route<E>;

    #[allow(dead_code)]
    fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<E>;
}

pub(crate) struct MakeErasedHandler<H, S> {
    pub(crate) handler: H,
    pub(crate) into_route: fn(H, S) -> Route,
}

impl<H, S> ErasedIntoRoute<S, Infallible> for MakeErasedHandler<H, S>
where
    H: Clone + Send + Sync + 'static,
    S: 'static,
{
    fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
        Box::new(self.clone())
    }

    fn into_route(self: Box<Self>, state: S) -> Route {
        (self.into_route)(self.handler, state)
    }

    fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
        self.into_route(state).call(request)
    }
}

impl<H, S> Clone for MakeErasedHandler<H, S>
where
    H: Clone,
{
    fn clone(&self) -> Self {
        Self {
            handler: self.handler.clone(),
            into_route: self.into_route,
        }
    }
}

#[allow(dead_code)]
pub(crate) struct MakeErasedRouter<S> {
    pub(crate) router: Router<S>,
    pub(crate) into_route: fn(Router<S>, S) -> Route,
}

impl<S> ErasedIntoRoute<S, Infallible> for MakeErasedRouter<S>
where
    S: Clone + Send + Sync + 'static,
{
    fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
        Box::new(self.clone())
    }

    fn into_route(self: Box<Self>, state: S) -> Route {
        (self.into_route)(self.router, state)
    }

    fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
        self.router.call_with_state(request, state)
    }
}

impl<S> Clone for MakeErasedRouter<S>
where
    S: Clone,
{
    fn clone(&self) -> Self {
        Self {
            router: self.router.clone(),
            into_route: self.into_route,
        }
    }
}

pub(crate) struct Map<S, E, E2> {
    pub(crate) inner: Box<dyn ErasedIntoRoute<S, E>>,
    pub(crate) layer: Box<dyn LayerFn<E, E2>>,
}

impl<S, E, E2> ErasedIntoRoute<S, E2> for Map<S, E, E2>
where
    S: 'static,
    E: 'static,
    E2: 'static,
{
    fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, E2>> {
        Box::new(Self {
            inner: self.inner.clone_box(),
            layer: self.layer.clone_box(),
        })
    }

    fn into_route(self: Box<Self>, state: S) -> Route<E2> {
        (self.layer)(self.inner.into_route(state))
    }

    fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<E2> {
        (self.layer)(self.inner.into_route(state)).call(request)
    }
}

pub(crate) trait LayerFn<E, E2>: FnOnce(Route<E>) -> Route<E2> + Send + Sync {
    fn clone_box(&self) -> Box<dyn LayerFn<E, E2>>;
}

impl<F, E, E2> LayerFn<E, E2> for F
where
    F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + Sync + 'static,
{
    fn clone_box(&self) -> Box<dyn LayerFn<E, E2>> {
        Box::new(self.clone())
    }
}



================================================
FILE: axum/src/extension.rs
================================================
use crate::{extract::rejection::*, response::IntoResponseParts};
use axum_core::extract::OptionalFromRequestParts;
use axum_core::{
    extract::FromRequestParts,
    response::{IntoResponse, Response, ResponseParts},
};
use http::{request::Parts, Extensions, Request};
use std::{
    convert::Infallible,
    task::{Context, Poll},
};
use tower_service::Service;

/// Extractor and response for extensions.
///
/// # As extractor
///
/// This is commonly used to share state across handlers.
///
/// ```rust,no_run
/// use axum::{
///     Router,
///     Extension,
///     routing::get,
/// };
/// use std::sync::Arc;
///
/// // Some shared state used throughout our application
/// struct State {
///     // ...
/// }
///
/// async fn handler(state: Extension<Arc<State>>) {
///     // ...
/// }
///
/// let state = Arc::new(State { /* ... */ });
///
/// let app = Router::new().route("/", get(handler))
///     // Add middleware that inserts the state into all incoming request's
///     // extensions.
///     .layer(Extension(state));
/// # let _: Router = app;
/// ```
///
/// If the extension is missing it will reject the request with a `500 Internal
/// Server Error` response. Alternatively, you can use `Option<Extension<T>>` to
/// make the extension extractor optional.
///
/// # As response
///
/// Response extensions can be used to share state with middleware.
///
/// ```rust
/// use axum::{
///     Extension,
///     response::IntoResponse,
/// };
///
/// async fn handler() -> (Extension<Foo>, &'static str) {
///     (
///         Extension(Foo("foo")),
///         "Hello, World!"
///     )
/// }
///
/// #[derive(Clone)]
/// struct Foo(&'static str);
/// ```
#[derive(Debug, Clone, Copy, Default)]
#[must_use]
pub struct Extension<T>(pub T);

impl<T> Extension<T>
where
    T: Clone + Send + Sync + 'static,
{
    fn from_extensions(extensions: &Extensions) -> Option<Self> {
        extensions.get::<T>().cloned().map(Extension)
    }
}

impl<T, S> FromRequestParts<S> for Extension<T>
where
    T: Clone + Send + Sync + 'static,
    S: Send + Sync,
{
    type Rejection = ExtensionRejection;

    async fn from_request_parts(req: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        Ok(Self::from_extensions(&req.extensions).ok_or_else(|| {
            MissingExtension::from_err(format!(
                "Extension of type `{}` was not found. Perhaps you forgot to add it? See `axum::Extension`.",
                std::any::type_name::<T>()
            ))
        })?)
    }
}

impl<T, S> OptionalFromRequestParts<S> for Extension<T>
where
    T: Clone + Send + Sync + 'static,
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request_parts(
        req: &mut Parts,
        _state: &S,
    ) -> Result<Option<Self>, Self::Rejection> {
        Ok(Self::from_extensions(&req.extensions))
    }
}

axum_core::__impl_deref!(Extension);

impl<T> IntoResponseParts for Extension<T>
where
    T: Clone + Send + Sync + 'static,
{
    type Error = Infallible;

    fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
        res.extensions_mut().insert(self.0);
        Ok(res)
    }
}

impl<T> IntoResponse for Extension<T>
where
    T: Clone + Send + Sync + 'static,
{
    fn into_response(self) -> Response {
        let mut res = ().into_response();
        res.extensions_mut().insert(self.0);
        res
    }
}

impl<S, T> tower_layer::Layer<S> for Extension<T>
where
    T: Clone + Send + Sync + 'static,
{
    type Service = AddExtension<S, T>;

    fn layer(&self, inner: S) -> Self::Service {
        AddExtension {
            inner,
            value: self.0.clone(),
        }
    }
}

/// Middleware for adding some shareable value to [request extensions].
///
/// See [Passing state from middleware to handlers](index.html#passing-state-from-middleware-to-handlers)
/// for more details.
///
/// [request extensions]: https://docs.rs/http/latest/http/struct.Extensions.html
///
/// If you need a layer to add an extension to every request,
/// use the [Layer](tower::Layer) implementation of [Extension].
#[derive(Clone, Copy, Debug)]
pub struct AddExtension<S, T> {
    pub(crate) inner: S,
    pub(crate) value: T,
}

impl<ResBody, S, T> Service<Request<ResBody>> for AddExtension<S, T>
where
    S: Service<Request<ResBody>>,
    T: Clone + Send + Sync + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;

    #[inline]
    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request<ResBody>) -> Self::Future {
        req.extensions_mut().insert(self.value.clone());
        self.inner.call(req)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::routing::get;
    use crate::test_helpers::TestClient;
    use crate::Router;
    use http::StatusCode;

    #[derive(Clone)]
    struct Foo(String);

    #[derive(Clone)]
    struct Bar(String);

    #[crate::test]
    async fn extension_extractor() {
        async fn requires_foo(Extension(foo): Extension<Foo>) -> String {
            foo.0
        }

        async fn optional_foo(extension: Option<Extension<Foo>>) -> String {
            extension.map(|foo| foo.0 .0).unwrap_or("none".to_owned())
        }

        async fn requires_bar(Extension(bar): Extension<Bar>) -> String {
            bar.0
        }

        async fn optional_bar(extension: Option<Extension<Bar>>) -> String {
            extension.map(|bar| bar.0 .0).unwrap_or("none".to_owned())
        }

        let app = Router::new()
            .route("/requires_foo", get(requires_foo))
            .route("/optional_foo", get(optional_foo))
            .route("/requires_bar", get(requires_bar))
            .route("/optional_bar", get(optional_bar))
            .layer(Extension(Foo("foo".to_owned())));

        let client = TestClient::new(app);

        let response = client.get("/requires_foo").await;
        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(response.text().await, "foo");

        let response = client.get("/optional_foo").await;
        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(response.text().await, "foo");

        let response = client.get("/requires_bar").await;
        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);
        assert_eq!(response.text().await, "Missing request extension: Extension of type `axum::extension::tests::Bar` was not found. Perhaps you forgot to add it? See `axum::Extension`.");

        let response = client.get("/optional_bar").await;
        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(response.text().await, "none");
    }
}



================================================
FILE: axum/src/form.rs
================================================
use crate::extract::Request;
use crate::extract::{rejection::*, FromRequest, RawForm};
use axum_core::response::{IntoResponse, Response};
use axum_core::RequestExt;
use http::header::CONTENT_TYPE;
use http::StatusCode;
use serde_core::{de::DeserializeOwned, Serialize};

/// URL encoded extractor and response.
///
/// # As extractor
///
/// If used as an extractor, `Form` will deserialize form data from the request,
/// specifically:
///
/// - If the request has a method of `GET` or `HEAD`, the form data will be read
///   from the query string (same as with [`Query`])
/// - If the request has a different method, the form will be read from the body
///   of the request. It must have a `content-type` of
///   `application/x-www-form-urlencoded` for this to work. If you want to parse
///   `multipart/form-data` request bodies, use [`Multipart`] instead.
///
/// This matches how HTML forms are sent by browsers by default.
/// In both cases, the inner type `T` must implement [`serde::Deserialize`].
///
/// âš ï¸ Since parsing form data might require consuming the request body, the `Form` extractor must be
/// *last* if there are multiple extractors in a handler. See ["the order of
/// extractors"][order-of-extractors]
///
/// [order-of-extractors]: crate::extract#the-order-of-extractors
///
/// ```rust
/// use axum::Form;
/// use serde::Deserialize;
///
/// #[derive(Deserialize)]
/// struct SignUp {
///     username: String,
///     password: String,
/// }
///
/// async fn accept_form(Form(sign_up): Form<SignUp>) {
///     // ...
/// }
/// ```
///
/// # As response
///
/// `Form` can also be used to encode any type that implements
/// [`serde::Serialize`] as `application/x-www-form-urlencoded`
///
/// ```rust
/// use axum::Form;
/// use serde::Serialize;
///
/// #[derive(Serialize)]
/// struct Payload {
///     value: String,
/// }
///
/// async fn handler() -> Form<Payload> {
///     Form(Payload { value: "foo".to_owned() })
/// }
/// ```
///
/// [`Query`]: crate::extract::Query
/// [`Multipart`]: crate::extract::Multipart
#[cfg_attr(docsrs, doc(cfg(feature = "form")))]
#[derive(Debug, Clone, Copy, Default)]
#[must_use]
pub struct Form<T>(pub T);

impl<T, S> FromRequest<S> for Form<T>
where
    T: DeserializeOwned,
    S: Send + Sync,
{
    type Rejection = FormRejection;

    async fn from_request(req: Request, _state: &S) -> Result<Self, Self::Rejection> {
        let is_get_or_head =
            req.method() == http::Method::GET || req.method() == http::Method::HEAD;

        match req.extract().await {
            Ok(RawForm(bytes)) => {
                let deserializer =
                    serde_urlencoded::Deserializer::new(form_urlencoded::parse(&bytes));
                let value = serde_path_to_error::deserialize(deserializer).map_err(
                    |err| -> FormRejection {
                        if is_get_or_head {
                            FailedToDeserializeForm::from_err(err).into()
                        } else {
                            FailedToDeserializeFormBody::from_err(err).into()
                        }
                    },
                )?;
                Ok(Self(value))
            }
            Err(RawFormRejection::BytesRejection(r)) => Err(FormRejection::BytesRejection(r)),
            Err(RawFormRejection::InvalidFormContentType(r)) => {
                Err(FormRejection::InvalidFormContentType(r))
            }
        }
    }
}

impl<T> IntoResponse for Form<T>
where
    T: Serialize,
{
    fn into_response(self) -> Response {
        // Extracted into separate fn so it's only compiled once for all T.
        fn make_response(ser_result: Result<String, serde_urlencoded::ser::Error>) -> Response {
            match ser_result {
                Ok(body) => (
                    [(CONTENT_TYPE, mime::APPLICATION_WWW_FORM_URLENCODED.as_ref())],
                    body,
                )
                    .into_response(),
                Err(err) => (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response(),
            }
        }

        make_response(serde_urlencoded::to_string(&self.0))
    }
}
axum_core::__impl_deref!(Form);

#[cfg(test)]
mod tests {
    use crate::{
        routing::{on, MethodFilter},
        test_helpers::TestClient,
        Router,
    };

    use super::*;
    use axum_core::body::Body;
    use http::{Method, Request};
    use mime::APPLICATION_WWW_FORM_URLENCODED;
    use serde::{Deserialize, Serialize};
    use std::fmt::Debug;

    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    struct Pagination {
        size: Option<u64>,
        page: Option<u64>,
    }

    async fn check_query<T: DeserializeOwned + PartialEq + Debug>(uri: impl AsRef<str>, value: T) {
        let req = Request::builder()
            .uri(uri.as_ref())
            .body(Body::empty())
            .unwrap();
        assert_eq!(Form::<T>::from_request(req, &()).await.unwrap().0, value);
    }

    async fn check_body<T: Serialize + DeserializeOwned + PartialEq + Debug>(value: T) {
        let req = Request::builder()
            .uri("http://example.com/test")
            .method(Method::POST)
            .header(CONTENT_TYPE, APPLICATION_WWW_FORM_URLENCODED.as_ref())
            .body(Body::from(serde_urlencoded::to_string(&value).unwrap()))
            .unwrap();
        assert_eq!(Form::<T>::from_request(req, &()).await.unwrap().0, value);
    }

    #[crate::test]
    async fn test_form_query() {
        check_query(
            "http://example.com/test",
            Pagination {
                size: None,
                page: None,
            },
        )
        .await;

        check_query(
            "http://example.com/test?size=10",
            Pagination {
                size: Some(10),
                page: None,
            },
        )
        .await;

        check_query(
            "http://example.com/test?size=10&page=20",
            Pagination {
                size: Some(10),
                page: Some(20),
            },
        )
        .await;
    }

    #[crate::test]
    async fn test_form_body() {
        check_body(Pagination {
            size: None,
            page: None,
        })
        .await;

        check_body(Pagination {
            size: Some(10),
            page: None,
        })
        .await;

        check_body(Pagination {
            size: Some(10),
            page: Some(20),
        })
        .await;
    }

    #[crate::test]
    async fn test_incorrect_content_type() {
        let req = Request::builder()
            .uri("http://example.com/test")
            .method(Method::POST)
            .header(CONTENT_TYPE, mime::APPLICATION_JSON.as_ref())
            .body(Body::from(
                serde_urlencoded::to_string(&Pagination {
                    size: Some(10),
                    page: None,
                })
                .unwrap(),
            ))
            .unwrap();
        assert!(matches!(
            Form::<Pagination>::from_request(req, &())
                .await
                .unwrap_err(),
            FormRejection::InvalidFormContentType(InvalidFormContentType)
        ));
    }

    #[tokio::test]
    async fn deserialize_error_status_codes() {
        #[allow(dead_code)]
        #[derive(Deserialize)]
        struct Payload {
            a: i32,
        }

        let app = Router::new().route(
            "/",
            on(
                MethodFilter::GET.or(MethodFilter::POST),
                |_: Form<Payload>| async {},
            ),
        );

        let client = TestClient::new(app);

        let res = client.get("/?a=false").await;
        assert_eq!(res.status(), StatusCode::BAD_REQUEST);
        assert_eq!(
            res.text().await,
            "Failed to deserialize form: a: invalid digit found in string"
        );

        let res = client
            .post("/")
            .header(CONTENT_TYPE, APPLICATION_WWW_FORM_URLENCODED.as_ref())
            .body("a=false")
            .await;
        assert_eq!(res.status(), StatusCode::UNPROCESSABLE_ENTITY);
        assert_eq!(
            res.text().await,
            "Failed to deserialize form body: a: invalid digit found in string"
        );
    }
}



================================================
FILE: axum/src/json.rs
================================================
use crate::extract::Request;
use crate::extract::{rejection::*, FromRequest};
use axum_core::extract::OptionalFromRequest;
use axum_core::response::{IntoResponse, Response};
use bytes::{BufMut, Bytes, BytesMut};
use http::{
    header::{self, HeaderMap, HeaderValue},
    StatusCode,
};
use serde_core::{de::DeserializeOwned, Serialize};

/// JSON Extractor / Response.
///
/// When used as an extractor, it can deserialize request bodies into some type that
/// implements [`serde::de::DeserializeOwned`]. The request will be rejected (and a [`JsonRejection`] will
/// be returned) if:
///
/// - The request doesn't have a `Content-Type: application/json` (or similar) header.
/// - The body doesn't contain syntactically valid JSON.
/// - The body contains syntactically valid JSON, but it couldn't be deserialized into the target type.
/// - Buffering the request body fails.
///
/// âš ï¸ Since parsing JSON requires consuming the request body, the `Json` extractor must be
/// *last* if there are multiple extractors in a handler.
/// See ["the order of extractors"][order-of-extractors]
///
/// [order-of-extractors]: crate::extract#the-order-of-extractors
///
/// See [`JsonRejection`] for more details.
///
/// # Extractor example
///
/// ```rust,no_run
/// use axum::{
///     extract,
///     routing::post,
///     Router,
/// };
/// use serde::Deserialize;
///
/// #[derive(Deserialize)]
/// struct CreateUser {
///     email: String,
///     password: String,
/// }
///
/// async fn create_user(extract::Json(payload): extract::Json<CreateUser>) {
///     // payload is a `CreateUser`
/// }
///
/// let app = Router::new().route("/users", post(create_user));
/// # let _: Router = app;
/// ```
///
/// When used as a response, it can serialize any type that implements [`serde::Serialize`] to
/// `JSON`, and will automatically set `Content-Type: application/json` header.
///
/// If the [`Serialize`] implementation decides to fail
/// or if a map with non-string keys is used,
/// a 500 response will be issued
/// whose body is the error message in UTF-8.
///
/// # Response example
///
/// ```
/// use axum::{
///     extract::Path,
///     routing::get,
///     Router,
///     Json,
/// };
/// use serde::Serialize;
/// use uuid::Uuid;
///
/// #[derive(Serialize)]
/// struct User {
///     id: Uuid,
///     username: String,
/// }
///
/// async fn get_user(Path(user_id) : Path<Uuid>) -> Json<User> {
///     let user = find_user(user_id).await;
///     Json(user)
/// }
///
/// async fn find_user(user_id: Uuid) -> User {
///     // ...
///     # unimplemented!()
/// }
///
/// let app = Router::new().route("/users/{id}", get(get_user));
/// # let _: Router = app;
/// ```
#[derive(Debug, Clone, Copy, Default)]
#[cfg_attr(docsrs, doc(cfg(feature = "json")))]
#[must_use]
pub struct Json<T>(pub T);

impl<T, S> FromRequest<S> for Json<T>
where
    T: DeserializeOwned,
    S: Send + Sync,
{
    type Rejection = JsonRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        if !json_content_type(req.headers()) {
            return Err(MissingJsonContentType.into());
        }

        let bytes = Bytes::from_request(req, state).await?;
        Self::from_bytes(&bytes)
    }
}

impl<T, S> OptionalFromRequest<S> for Json<T>
where
    T: DeserializeOwned,
    S: Send + Sync,
{
    type Rejection = JsonRejection;

    async fn from_request(req: Request, state: &S) -> Result<Option<Self>, Self::Rejection> {
        let headers = req.headers();
        if headers.get(header::CONTENT_TYPE).is_some() {
            if json_content_type(headers) {
                let bytes = Bytes::from_request(req, state).await?;
                Ok(Some(Self::from_bytes(&bytes)?))
            } else {
                Err(MissingJsonContentType.into())
            }
        } else {
            Ok(None)
        }
    }
}

fn json_content_type(headers: &HeaderMap) -> bool {
    headers
        .get(header::CONTENT_TYPE)
        .and_then(|content_type| content_type.to_str().ok())
        .and_then(|content_type| content_type.parse::<mime::Mime>().ok())
        .is_some_and(|mime| {
            mime.type_() == "application"
                && (mime.subtype() == "json" || mime.suffix().is_some_and(|name| name == "json"))
        })
}

axum_core::__impl_deref!(Json);

impl<T> From<T> for Json<T> {
    fn from(inner: T) -> Self {
        Self(inner)
    }
}

impl<T> Json<T>
where
    T: DeserializeOwned,
{
    /// Construct a `Json<T>` from a byte slice. Most users should prefer to use the `FromRequest` impl
    /// but special cases may require first extracting a `Request` into `Bytes` then optionally
    /// constructing a `Json<T>`.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, JsonRejection> {
        // Extracted into separate fn so it's only compiled once for all T.
        fn make_rejection(err: serde_path_to_error::Error<serde_json::Error>) -> JsonRejection {
            match err.inner().classify() {
                serde_json::error::Category::Data => JsonDataError::from_err(err).into(),
                serde_json::error::Category::Syntax | serde_json::error::Category::Eof => {
                    JsonSyntaxError::from_err(err).into()
                }
                serde_json::error::Category::Io => {
                    if cfg!(debug_assertions) {
                        // we don't use `serde_json::from_reader` and instead always buffer
                        // bodies first, so we shouldn't encounter any IO errors
                        unreachable!()
                    } else {
                        JsonSyntaxError::from_err(err).into()
                    }
                }
            }
        }

        let mut deserializer = serde_json::Deserializer::from_slice(bytes);

        serde_path_to_error::deserialize(&mut deserializer)
            .map_err(make_rejection)
            .and_then(|value| {
                deserializer
                    .end()
                    .map(|()| Self(value))
                    .map_err(|err| JsonSyntaxError::from_err(err).into())
            })
    }
}

impl<T> IntoResponse for Json<T>
where
    T: Serialize,
{
    fn into_response(self) -> Response {
        // Extracted into separate fn so it's only compiled once for all T.
        fn make_response(buf: BytesMut, ser_result: serde_json::Result<()>) -> Response {
            match ser_result {
                Ok(()) => (
                    [(
                        header::CONTENT_TYPE,
                        HeaderValue::from_static(mime::APPLICATION_JSON.as_ref()),
                    )],
                    buf.freeze(),
                )
                    .into_response(),
                Err(err) => (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    [(
                        header::CONTENT_TYPE,
                        HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
                    )],
                    err.to_string(),
                )
                    .into_response(),
            }
        }

        // Use a small initial capacity of 128 bytes like serde_json::to_vec
        // https://docs.rs/serde_json/1.0.82/src/serde_json/ser.rs.html#2189
        let mut buf = BytesMut::with_capacity(128).writer();
        let res = serde_json::to_writer(&mut buf, &self.0);
        make_response(buf.into_inner(), res)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{routing::post, test_helpers::*, Router};
    use serde::Deserialize;
    use serde_json::{json, Value};

    #[crate::test]
    async fn deserialize_body() {
        #[derive(Debug, Deserialize)]
        struct Input {
            foo: String,
        }

        let app = Router::new().route("/", post(|input: Json<Input>| async { input.0.foo }));

        let client = TestClient::new(app);
        let res = client.post("/").json(&json!({ "foo": "bar" })).await;
        let body = res.text().await;

        assert_eq!(body, "bar");
    }

    #[crate::test]
    async fn consume_body_to_json_requires_json_content_type() {
        #[derive(Debug, Deserialize)]
        struct Input {
            foo: String,
        }

        let app = Router::new().route("/", post(|input: Json<Input>| async { input.0.foo }));

        let client = TestClient::new(app);
        let res = client.post("/").body(r#"{ "foo": "bar" }"#).await;

        let status = res.status();

        assert_eq!(status, StatusCode::UNSUPPORTED_MEDIA_TYPE);
    }

    #[crate::test]
    async fn json_content_types() {
        async fn valid_json_content_type(content_type: &str) -> bool {
            println!("testing {content_type:?}");

            let app = Router::new().route("/", post(|Json(_): Json<Value>| async {}));

            let res = TestClient::new(app)
                .post("/")
                .header("content-type", content_type)
                .body("{}")
                .await;

            res.status() == StatusCode::OK
        }

        assert!(valid_json_content_type("application/json").await);
        assert!(valid_json_content_type("application/json; charset=utf-8").await);
        assert!(valid_json_content_type("application/json;charset=utf-8").await);
        assert!(valid_json_content_type("application/cloudevents+json").await);
        assert!(!valid_json_content_type("text/json").await);
    }

    #[crate::test]
    async fn invalid_json_syntax() {
        let app = Router::new().route("/", post(|_: Json<serde_json::Value>| async {}));

        let client = TestClient::new(app);
        let res = client
            .post("/")
            .body("{")
            .header("content-type", "application/json")
            .await;

        assert_eq!(res.status(), StatusCode::BAD_REQUEST);
    }

    #[crate::test]
    async fn extra_chars_after_valid_json_syntax() {
        #[derive(Debug, Deserialize)]
        struct Input {
            foo: String,
        }

        let app = Router::new().route("/", post(|input: Json<Input>| async { input.0.foo }));

        let client = TestClient::new(app);
        let res = client
            .post("/")
            .body(r#"{ "foo": "bar" } baz "#)
            .header("content-type", "application/json")
            .await;

        assert_eq!(res.status(), StatusCode::BAD_REQUEST);
        let body_text = res.text().await;
        assert_eq!(
            body_text,
            "Failed to parse the request body as JSON: trailing characters at line 1 column 18"
        );
    }

    #[derive(Deserialize)]
    struct Foo {
        #[allow(dead_code)]
        a: i32,
        #[allow(dead_code)]
        b: Vec<Bar>,
    }

    #[derive(Deserialize)]
    struct Bar {
        #[allow(dead_code)]
        x: i32,
        #[allow(dead_code)]
        y: i32,
    }

    #[crate::test]
    async fn invalid_json_data() {
        let app = Router::new().route("/", post(|_: Json<Foo>| async {}));

        let client = TestClient::new(app);
        let res = client
            .post("/")
            .body("{\"a\": 1, \"b\": [{\"x\": 2}]}")
            .header("content-type", "application/json")
            .await;

        assert_eq!(res.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body_text = res.text().await;
        assert_eq!(
            body_text,
            "Failed to deserialize the JSON body into the target type: b[0]: missing field `y` at line 1 column 23"
        );
    }
}



================================================
FILE: axum/src/lib.rs
================================================
//! axum is a web application framework that focuses on ergonomics and modularity.
//!
//! # High-level features
//!
//! - Route requests to handlers with a macro-free API.
//! - Declaratively parse requests using extractors.
//! - Simple and predictable error handling model.
//! - Generate responses with minimal boilerplate.
//! - Take full advantage of the [`tower`] and [`tower-http`] ecosystem of
//!   middleware, services, and utilities.
//!
//! In particular, the last point is what sets `axum` apart from other frameworks.
//! `axum` doesn't have its own middleware system but instead uses
//! [`tower::Service`]. This means `axum` gets timeouts, tracing, compression,
//! authorization, and more, for free. It also enables you to share middleware with
//! applications written using [`hyper`] or [`tonic`].
//!
//! # Compatibility
//!
//! axum is designed to work with [tokio] and [hyper]. Runtime and
//! transport layer independence is not a goal, at least for the time being.
//!
//! # Example
//!
//! The "Hello, World!" of axum is:
//!
//! ```rust,no_run
//! use axum::{
//!     routing::get,
//!     Router,
//! };
//!
//! #[tokio::main]
//! async fn main() {
//!     // build our application with a single route
//!     let app = Router::new().route("/", get(|| async { "Hello, World!" }));
//!
//!     // run our app with hyper, listening globally on port 3000
//!     let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
//!     axum::serve(listener, app).await.unwrap();
//! }
//! ```
//!
//! Note using `#[tokio::main]` requires you enable tokio's `macros` and `rt-multi-thread` features
//! or just `full` to enable all features (`cargo add tokio --features macros,rt-multi-thread`).
//!
//! # Routing
//!
//! [`Router`] is used to set up which paths go to which services:
//!
//! ```rust
//! use axum::{Router, routing::get};
//!
//! // our router
//! let app = Router::new()
//!     .route("/", get(root))
//!     .route("/foo", get(get_foo).post(post_foo))
//!     .route("/foo/bar", get(foo_bar));
//!
//! // which calls one of these handlers
//! async fn root() {}
//! async fn get_foo() {}
//! async fn post_foo() {}
//! async fn foo_bar() {}
//! # let _: Router = app;
//! ```
//!
//! See [`Router`] for more details on routing.
//!
//! # Handlers
//!
#![doc = include_str!("docs/handlers_intro.md")]
//!
//! See [`handler`](crate::handler) for more details on handlers.
//!
//! # Extractors
//!
//! An extractor is a type that implements [`FromRequest`] or [`FromRequestParts`]. Extractors are
//! how you pick apart the incoming request to get the parts your handler needs.
//!
//! ```rust
//! use axum::extract::{Path, Query, Json};
//! use std::collections::HashMap;
//!
//! // `Path` gives you the path parameters and deserializes them.
//! async fn path(Path(user_id): Path<u32>) {}
//!
//! // `Query` gives you the query parameters and deserializes them.
//! async fn query(Query(params): Query<HashMap<String, String>>) {}
//!
//! // Buffer the request body and deserialize it as JSON into a
//! // `serde_json::Value`. `Json` supports any type that implements
//! // `serde::Deserialize`.
//! async fn json(Json(payload): Json<serde_json::Value>) {}
//! ```
//!
//! See [`extract`](crate::extract) for more details on extractors.
//!
//! # Responses
//!
//! Anything that implements [`IntoResponse`] can be returned from handlers.
//!
//! ```rust,no_run
//! use axum::{
//!     body::Body,
//!     routing::get,
//!     response::Json,
//!     Router,
//! };
//! use serde_json::{Value, json};
//!
//! // `&'static str` becomes a `200 OK` with `content-type: text/plain; charset=utf-8`
//! async fn plain_text() -> &'static str {
//!     "foo"
//! }
//!
//! // `Json` gives a content-type of `application/json` and works with any type
//! // that implements `serde::Serialize`
//! async fn json() -> Json<Value> {
//!     Json(json!({ "data": 42 }))
//! }
//!
//! let app = Router::new()
//!     .route("/plain_text", get(plain_text))
//!     .route("/json", get(json));
//! # let _: Router = app;
//! ```
//!
//! See [`response`](crate::response) for more details on building responses.
//!
//! # Error handling
//!
//! axum aims to have a simple and predictable error handling model. That means
//! it is simple to convert errors into responses and you are guaranteed that
//! all errors are handled.
//!
//! See [`error_handling`] for more details on axum's
//! error handling model and how to handle errors gracefully.
//!
//! # Middleware
//!
//! There are several different ways to write middleware for axum. See
//! [`middleware`] for more details.
//!
//! # Sharing state with handlers
//!
//! It is common to share some state between handlers. For example, a
//! pool of database connections or clients to other services may need to
//! be shared.
//!
//! The four most common ways of doing that are:
//!
//! - Using the [`State`] extractor
//! - Using request extensions
//! - Using closure captures
//! - Using task-local variables
//!
//! ## Using the [`State`] extractor
//!
//! ```rust,no_run
//! use axum::{
//!     extract::State,
//!     routing::get,
//!     Router,
//! };
//! use std::sync::Arc;
//!
//! struct AppState {
//!     // ...
//! }
//!
//! let shared_state = Arc::new(AppState { /* ... */ });
//!
//! let app = Router::new()
//!     .route("/", get(handler))
//!     .with_state(shared_state);
//!
//! async fn handler(
//!     State(state): State<Arc<AppState>>,
//! ) {
//!     // ...
//! }
//! # let _: Router = app;
//! ```
//!
//! You should prefer using [`State`] if possible since it's more type safe. The downside is that
//! it's less dynamic than task-local variables and request extensions.
//!
//! See [`State`] for more details about accessing state.
//!
//! ## Using request extensions
//!
//! Another way to share state with handlers is using [`Extension`] as
//! layer and extractor:
//!
//! ```rust,no_run
//! use axum::{
//!     extract::Extension,
//!     routing::get,
//!     Router,
//! };
//! use std::sync::Arc;
//!
//! struct AppState {
//!     // ...
//! }
//!
//! let shared_state = Arc::new(AppState { /* ... */ });
//!
//! let app = Router::new()
//!     .route("/", get(handler))
//!     .layer(Extension(shared_state));
//!
//! async fn handler(
//!     Extension(state): Extension<Arc<AppState>>,
//! ) {
//!     // ...
//! }
//! # let _: Router = app;
//! ```
//!
//! The downside to this approach is that you'll get runtime errors
//! (specifically a `500 Internal Server Error` response) if you try and extract
//! an extension that doesn't exist, perhaps because you forgot to add the
//! middleware or because you're extracting the wrong type.
//!
//! ## Using closure captures
//!
//! State can also be passed directly to handlers using closure captures:
//!
//! ```rust,no_run
//! use axum::{
//!     Json,
//!     extract::{Extension, Path},
//!     routing::{get, post},
//!     Router,
//! };
//! use std::sync::Arc;
//! use serde::Deserialize;
//!
//! struct AppState {
//!     // ...
//! }
//!
//! let shared_state = Arc::new(AppState { /* ... */ });
//!
//! let app = Router::new()
//!     .route(
//!         "/users",
//!         post({
//!             let shared_state = Arc::clone(&shared_state);
//!             move |body| create_user(body, shared_state)
//!         }),
//!     )
//!     .route(
//!         "/users/{id}",
//!         get({
//!             let shared_state = Arc::clone(&shared_state);
//!             move |path| get_user(path, shared_state)
//!         }),
//!     );
//!
//! async fn get_user(Path(user_id): Path<String>, state: Arc<AppState>) {
//!     // ...
//! }
//!
//! async fn create_user(Json(payload): Json<CreateUserPayload>, state: Arc<AppState>) {
//!     // ...
//! }
//!
//! #[derive(Deserialize)]
//! struct CreateUserPayload {
//!     // ...
//! }
//! # let _: Router = app;
//! ```
//!
//! The downside to this approach is that it's the most verbose approach.
//!
//! ## Using task-local variables
//!
//! This also allows to share state with `IntoResponse` implementations:
//!
//! ```rust,no_run
//! use axum::{
//!     extract::Request,
//!     http::{header, StatusCode},
//!     middleware::{self, Next},
//!     response::{IntoResponse, Response},
//!     routing::get,
//!     Router,
//! };
//! use tokio::task_local;
//!
//! #[derive(Clone)]
//! struct CurrentUser {
//!     name: String,
//! }
//! task_local! {
//!     pub static USER: CurrentUser;
//! }
//!
//! async fn auth(req: Request, next: Next) -> Result<Response, StatusCode> {
//!     let auth_header = req
//!         .headers()
//!         .get(header::AUTHORIZATION)
//!         .and_then(|header| header.to_str().ok())
//!         .ok_or(StatusCode::UNAUTHORIZED)?;
//!     if let Some(current_user) = authorize_current_user(auth_header).await {
//!         // State is setup here in the middleware
//!         Ok(USER.scope(current_user, next.run(req)).await)
//!     } else {
//!         Err(StatusCode::UNAUTHORIZED)
//!     }
//! }
//! async fn authorize_current_user(auth_token: &str) -> Option<CurrentUser> {
//!     Some(CurrentUser {
//!         name: auth_token.to_string(),
//!     })
//! }
//!
//! struct UserResponse;
//!
//! impl IntoResponse for UserResponse {
//!     fn into_response(self) -> Response {
//!         // State is accessed here in the IntoResponse implementation
//!         let current_user = USER.with(|u| u.clone());
//!         (StatusCode::OK, current_user.name).into_response()
//!     }
//! }
//!
//! async fn handler() -> UserResponse {
//!     UserResponse
//! }
//!
//! let app: Router = Router::new()
//!     .route("/", get(handler))
//!     .route_layer(middleware::from_fn(auth));
//! ```
//!
//! The main downside to this approach is that it only works when the async executor being used
//! has the concept of task-local variables. The example above uses
//! [tokio's `task_local` macro](https://docs.rs/tokio/1/tokio/macro.task_local.html).
//! smol does not yet offer equivalent functionality at the time of writing (see
//! [this GitHub issue](https://github.com/smol-rs/async-executor/issues/139)).
//!
//! # Building integrations for axum
//!
//! Libraries authors that want to provide [`FromRequest`], [`FromRequestParts`], or
//! [`IntoResponse`] implementations should depend on the [`axum-core`] crate, instead of `axum` if
//! possible. [`axum-core`] contains core types and traits and is less likely to receive breaking
//! changes.
//!
//! # Required dependencies
//!
//! To use axum there are a few dependencies you have to pull in as well:
//!
//! ```toml
//! [dependencies]
//! axum = "<latest-version>"
//! tokio = { version = "<latest-version>", features = ["full"] }
//! tower = "<latest-version>"
//! ```
//!
//! The `"full"` feature for tokio isn't necessary but it's the easiest way to get started.
//!
//! Tower isn't strictly necessary either but helpful for testing. See the
//! testing example in the repo to learn more about testing axum apps.
//!
//! # Examples
//!
//! The axum repo contains [a number of examples][examples] that show how to put all the
//! pieces together.
//!
//! # Feature flags
//!
//! axum uses a set of [feature flags] to reduce the amount of compiled and
//! optional dependencies.
//!
//! The following optional features are available:
//!
//! Name | Description | Default?
//! ---|---|---
//! `http1` | Enables hyper's `http1` feature | Yes
//! `http2` | Enables hyper's `http2` feature | No
//! `json` | Enables the [`Json`] type and some similar convenience functionality | Yes
//! `macros` | Enables optional utility macros | No
//! `matched-path` | Enables capturing of every request's router path and the [`MatchedPath`] extractor | Yes
//! `multipart` | Enables parsing `multipart/form-data` requests with [`Multipart`] | No
//! `original-uri` | Enables capturing of every request's original URI and the [`OriginalUri`] extractor | Yes
//! `tokio` | Enables `tokio` as a dependency and `axum::serve`, `SSE` and `extract::connect_info` types. | Yes
//! `tower-log` | Enables `tower`'s `log` feature | Yes
//! `tracing` | Log rejections from built-in extractors | Yes
//! `ws` | Enables WebSockets support via [`extract::ws`] | No
//! `form` | Enables the `Form` extractor | Yes
//! `query` | Enables the `Query` extractor | Yes
//!
//! [`MatchedPath`]: crate::extract::MatchedPath
//! [`Multipart`]: crate::extract::Multipart
//! [`OriginalUri`]: crate::extract::OriginalUri
//! [`tower`]: https://crates.io/crates/tower
//! [`tower-http`]: https://crates.io/crates/tower-http
//! [`tokio`]: http://crates.io/crates/tokio
//! [`hyper`]: http://crates.io/crates/hyper
//! [`tonic`]: http://crates.io/crates/tonic
//! [feature flags]: https://doc.rust-lang.org/cargo/reference/features.html#the-features-section
//! [`IntoResponse`]: crate::response::IntoResponse
//! [`Timeout`]: tower::timeout::Timeout
//! [examples]: https://github.com/tokio-rs/axum/tree/main/examples
//! [`Router::merge`]: crate::routing::Router::merge
//! [`Service`]: tower::Service
//! [`Service::poll_ready`]: tower::Service::poll_ready
//! [`Service`'s]: tower::Service
//! [`tower::Service`]: tower::Service
//! [tower-guides]: https://github.com/tower-rs/tower/tree/master/guides
//! [`Uuid`]: https://docs.rs/uuid/latest/uuid/
//! [`FromRequest`]: crate::extract::FromRequest
//! [`FromRequestParts`]: crate::extract::FromRequestParts
//! [`HeaderMap`]: http::header::HeaderMap
//! [`Request`]: http::Request
//! [customize-extractor-error]: https://github.com/tokio-rs/axum/blob/main/examples/customize-extractor-error/src/main.rs
//! [axum-macros]: https://docs.rs/axum-macros
//! [`debug_handler`]: https://docs.rs/axum-macros/latest/axum_macros/attr.debug_handler.html
//! [`Handler`]: crate::handler::Handler
//! [`Infallible`]: std::convert::Infallible
//! [load shed]: tower::load_shed
//! [`axum-core`]: http://crates.io/crates/axum-core
//! [`State`]: crate::extract::State

#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg))]
#![cfg_attr(test, allow(clippy::float_cmp))]
#![cfg_attr(not(test), warn(clippy::print_stdout, clippy::dbg_macro))]

#[macro_use]
pub(crate) mod macros;

mod boxed;
mod extension;
#[cfg(feature = "form")]
mod form;
#[cfg(feature = "json")]
mod json;
mod service_ext;
mod util;

pub mod body;
pub mod error_handling;
pub mod extract;
pub mod handler;
pub mod middleware;
pub mod response;
pub mod routing;
#[cfg(all(feature = "tokio", any(feature = "http1", feature = "http2")))]
pub mod serve;

#[cfg(any(test, feature = "__private"))]
#[allow(missing_docs, missing_debug_implementations, clippy::print_stdout)]
pub mod test_helpers;

#[doc(no_inline)]
pub use http;

#[doc(inline)]
pub use self::extension::Extension;
#[doc(inline)]
#[cfg(feature = "json")]
pub use self::json::Json;
#[doc(inline)]
pub use self::routing::Router;

#[doc(inline)]
#[cfg(feature = "form")]
pub use self::form::Form;

#[doc(inline)]
pub use axum_core::{BoxError, Error, RequestExt, RequestPartsExt};

#[cfg(feature = "macros")]
pub use axum_macros::{debug_handler, debug_middleware};

#[cfg(all(feature = "tokio", any(feature = "http1", feature = "http2")))]
#[doc(inline)]
pub use self::serve::serve;

pub use self::service_ext::ServiceExt;

#[cfg(test)]
use axum_macros::__private_axum_test as test;



================================================
FILE: axum/src/macros.rs
================================================
//! Internal macros

macro_rules! opaque_future {
    ($(#[$m:meta])* pub type $name:ident = $actual:ty;) => {
        opaque_future! {
            $(#[$m])*
            pub type $name<> = $actual;
        }
    };

    ($(#[$m:meta])* pub type $name:ident<$($param:ident),*> = $actual:ty;) => {
        pin_project_lite::pin_project! {
            $(#[$m])*
            pub struct $name<$($param),*> {
                #[pin] future: $actual,
            }
        }

        impl<$($param),*> $name<$($param),*> {
            pub(crate) fn new(future: $actual) -> Self {
                Self { future }
            }
        }

        impl<$($param),*> std::fmt::Debug for $name<$($param),*> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_struct(stringify!($name)).finish_non_exhaustive()
            }
        }

        impl<$($param),*> std::future::Future for $name<$($param),*>
        where
            $actual: std::future::Future,
        {
            type Output = <$actual as std::future::Future>::Output;

            #[inline]
            fn poll(
                self: std::pin::Pin<&mut Self>,
                cx: &mut std::task::Context<'_>,
            ) -> std::task::Poll<Self::Output> {
                self.project().future.poll(cx)
            }
        }
    };
}

#[rustfmt::skip]
macro_rules! all_the_tuples {
    ($name:ident) => {
        $name!([], T1);
        $name!([T1], T2);
        $name!([T1, T2], T3);
        $name!([T1, T2, T3], T4);
        $name!([T1, T2, T3, T4], T5);
        $name!([T1, T2, T3, T4, T5], T6);
        $name!([T1, T2, T3, T4, T5, T6], T7);
        $name!([T1, T2, T3, T4, T5, T6, T7], T8);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8], T9);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9], T10);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], T11);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11], T12);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12], T13);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13], T14);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14], T15);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15], T16);
    };
}

#[cfg(feature = "tracing")]
#[allow(unused_macros)]
macro_rules! trace {
    ($($tt:tt)*) => {
        tracing::trace!($($tt)*)
    }
}

#[cfg(feature = "tracing")]
#[allow(unused_macros)]
macro_rules! error {
    ($($tt:tt)*) => {
        tracing::error!($($tt)*)
    };
}

#[cfg(not(feature = "tracing"))]
#[allow(unused_macros)]
macro_rules! trace {
    ($($tt:tt)*) => {};
}

#[cfg(not(feature = "tracing"))]
#[allow(unused_macros)]
macro_rules! error {
    ($($tt:tt)*) => {};
}



================================================
FILE: axum/src/service_ext.rs
================================================
use crate::error_handling::HandleError;
#[cfg(feature = "tokio")]
use crate::extract::connect_info::IntoMakeServiceWithConnectInfo;
use crate::routing::IntoMakeService;
use tower_service::Service;

/// Extension trait that adds additional methods to any [`Service`].
pub trait ServiceExt<R>: Service<R> + Sized {
    /// Convert this service into a [`MakeService`], that is a [`Service`] whose
    /// response is another service.
    ///
    /// This is commonly used when applying middleware around an entire [`Router`]. See ["Rewriting
    /// request URI in middleware"] for more details.
    ///
    /// [`MakeService`]: tower::make::MakeService
    /// ["Rewriting request URI in middleware"]: crate::middleware#rewriting-request-uri-in-middleware
    /// [`Router`]: crate::Router
    fn into_make_service(self) -> IntoMakeService<Self>;

    /// Convert this service into a [`MakeService`], that will store `C`'s
    /// associated `ConnectInfo` in a request extension such that [`ConnectInfo`]
    /// can extract it.
    ///
    /// This enables extracting things like the client's remote address.
    /// This is commonly used when applying middleware around an entire [`Router`]. See ["Rewriting
    /// request URI in middleware"] for more details.
    ///
    /// [`MakeService`]: tower::make::MakeService
    /// ["Rewriting request URI in middleware"]: crate::middleware#rewriting-request-uri-in-middleware
    /// [`Router`]: crate::Router
    /// [`ConnectInfo`]: crate::extract::connect_info::ConnectInfo
    #[cfg(feature = "tokio")]
    fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C>;

    /// Convert this service into a [`HandleError`], that will handle errors
    /// by converting them into responses.
    ///
    ///  See ["error handling model"] for more details.
    ///
    /// [`HandleError`]: crate::error_handling::HandleError
    /// ["error handling model"]: crate::error_handling#axums-error-handling-model
    fn handle_error<F, T>(self, f: F) -> HandleError<Self, F, T> {
        HandleError::new(self, f)
    }
}

impl<S, R> ServiceExt<R> for S
where
    S: Service<R> + Sized,
{
    fn into_make_service(self) -> IntoMakeService<Self> {
        IntoMakeService::new(self)
    }

    #[cfg(feature = "tokio")]
    fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
        IntoMakeServiceWithConnectInfo::new(self)
    }
}



================================================
FILE: axum/src/util.rs
================================================
use axum_core::response::{IntoResponse, Response};
use pin_project_lite::pin_project;
use std::{
    future::Future,
    ops::Deref,
    pin::Pin,
    sync::Arc,
    task::{ready, Context, Poll},
};
use tower::Service;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub(crate) struct PercentDecodedStr(Arc<str>);

impl PercentDecodedStr {
    pub(crate) fn new<S>(s: S) -> Option<Self>
    where
        S: AsRef<str>,
    {
        percent_encoding::percent_decode(s.as_ref().as_bytes())
            .decode_utf8()
            .ok()
            .map(|decoded| Self(decoded.as_ref().into()))
    }

    pub(crate) fn as_str(&self) -> &str {
        &self.0
    }
}

impl Deref for PercentDecodedStr {
    type Target = str;

    #[inline]
    fn deref(&self) -> &Self::Target {
        self.as_str()
    }
}

pin_project! {
    #[project = EitherProj]
    pub(crate) enum Either<A, B> {
        A { #[pin] inner: A },
        B { #[pin] inner: B },
    }
}

#[derive(Clone)]
pub(crate) struct MapIntoResponse<S> {
    inner: S,
}

impl<S> MapIntoResponse<S> {
    pub(crate) fn new(inner: S) -> Self {
        Self { inner }
    }
}

impl<B, S> Service<http::Request<B>> for MapIntoResponse<S>
where
    S: Service<http::Request<B>>,
    S::Response: IntoResponse,
{
    type Response = Response;
    type Error = S::Error;
    type Future = MapIntoResponseFuture<S::Future>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: http::Request<B>) -> Self::Future {
        MapIntoResponseFuture {
            inner: self.inner.call(req),
        }
    }
}

pin_project! {
    pub(crate) struct MapIntoResponseFuture<F> {
        #[pin]
        inner: F,
    }
}

impl<F, T, E> Future for MapIntoResponseFuture<F>
where
    F: Future<Output = Result<T, E>>,
    T: IntoResponse,
{
    type Output = Result<Response, E>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let res = ready!(self.project().inner.poll(cx)?);
        Poll::Ready(Ok(res.into_response()))
    }
}

pub(crate) fn try_downcast<T, K>(k: K) -> Result<T, K>
where
    T: 'static,
    K: Send + 'static,
{
    let mut k = Some(k);
    if let Some(k) = <dyn std::any::Any>::downcast_mut::<Option<T>>(&mut k) {
        Ok(k.take().unwrap())
    } else {
        Err(k.unwrap())
    }
}

#[test]
fn test_try_downcast() {
    assert_eq!(try_downcast::<i32, _>(5_u32), Err(5_u32));
    assert_eq!(try_downcast::<i32, _>(5_i32), Ok(5_i32));
}



================================================
FILE: axum/src/body/mod.rs
================================================
//! HTTP body utilities.

#[doc(no_inline)]
pub use http_body::Body as HttpBody;

#[doc(no_inline)]
pub use bytes::Bytes;

#[doc(inline)]
pub use axum_core::body::{Body, BodyDataStream};

use http_body_util::{BodyExt, Limited};

/// Converts [`Body`] into [`Bytes`] and limits the maximum size of the body.
///
/// # Example
///
/// ```rust
/// use axum::body::{to_bytes, Body};
///
/// # async fn foo() -> Result<(), axum_core::Error> {
/// let body = Body::from(vec![1, 2, 3]);
/// // Use `usize::MAX` if you don't care about the maximum size.
/// let bytes = to_bytes(body, usize::MAX).await?;
/// assert_eq!(&bytes[..], &[1, 2, 3]);
/// # Ok(())
/// # }
/// ```
///
/// You can detect if the limit was hit by checking the source of the error:
///
/// ```rust
/// use axum::body::{to_bytes, Body};
/// use http_body_util::LengthLimitError;
///
/// # #[tokio::main]
/// # async fn main() {
/// let body = Body::from(vec![1, 2, 3]);
/// match to_bytes(body, 1).await {
///     Ok(_bytes) => panic!("should have hit the limit"),
///     Err(err) => {
///         let source = std::error::Error::source(&err).unwrap();
///         assert!(source.is::<LengthLimitError>());
///     }
/// }
/// # }
/// ```
pub async fn to_bytes(body: Body, limit: usize) -> Result<Bytes, axum_core::Error> {
    Limited::new(body, limit)
        .collect()
        .await
        .map(|col| col.to_bytes())
        .map_err(axum_core::Error::new)
}



================================================
FILE: axum/src/docs/debugging_handler_type_errors.md
================================================
## Debugging handler type errors

For a function to be used as a handler it must implement the [`Handler`] trait.
axum provides blanket implementations for functions that:

- Are `async fn`s.
- Take no more than 16 arguments that all implement `Send`.
  - All except the last argument implement [`FromRequestParts`].
  - The last argument implements [`FromRequest`].
- Returns something that implements [`IntoResponse`].
- If a closure is used it must implement `Clone + Send` and be
`'static`.
- Returns a future that is `Send`. The most common way to accidentally make a
future `!Send` is to hold a `!Send` type across an await.

Unfortunately Rust gives poor error messages if you try to use a function
that doesn't quite match what's required by [`Handler`].

You might get an error like this:

```not_rust
error[E0277]: the trait bound `fn(bool) -> impl Future {handler}: Handler<_, _>` is not satisfied
   --> src/main.rs:13:44
    |
13  |     let app = Router::new().route("/", get(handler));
    |                                            ^^^^^^^ the trait `Handler<_, _>` is not implemented for `fn(bool) -> impl Future {handler}`
    |
   ::: axum/src/handler/mod.rs:116:8
    |
116 |     H: Handler<T, B>,
    |        ------------- required by this bound in `axum::routing::get`
```

This error doesn't tell you _why_ your function doesn't implement
[`Handler`]. It's possible to improve the error with the [`debug_handler`]
proc-macro from the [axum-macros] crate.

[axum-macros]: https://docs.rs/axum-macros
[`debug_handler`]: https://docs.rs/axum-macros/latest/axum_macros/attr.debug_handler.html



