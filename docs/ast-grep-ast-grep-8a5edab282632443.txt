Directory structure:
└── ast-grep-ast-grep/
    ├── README.md
    ├── Cargo.toml
    ├── clippy.toml
    ├── LICENSE
    ├── pyproject.toml
    ├── renovate.json
    ├── rust-toolchain.toml
    ├── rustfmt.toml
    ├── .editorconfig
    ├── .pre-commit-config.yaml
    ├── crates/
    │   ├── cli/
    │   │   ├── Cargo.toml
    │   │   ├── src/
    │   │   │   ├── completions.rs
    │   │   │   ├── config.rs
    │   │   │   ├── lib.rs
    │   │   │   ├── lsp.rs
    │   │   │   ├── main.rs
    │   │   │   ├── new.rs
    │   │   │   ├── run.rs
    │   │   │   ├── scan.rs
    │   │   │   ├── verify.rs
    │   │   │   ├── lang/
    │   │   │   │   ├── injection.rs
    │   │   │   │   ├── lang_globs.rs
    │   │   │   │   └── mod.rs
    │   │   │   ├── print/
    │   │   │   │   ├── cloud_print.rs
    │   │   │   │   ├── colored_print.rs
    │   │   │   │   ├── interactive_print.rs
    │   │   │   │   ├── json_print.rs
    │   │   │   │   ├── mod.rs
    │   │   │   │   └── colored_print/
    │   │   │   │       ├── markdown.rs
    │   │   │   │       ├── match_merger.rs
    │   │   │   │       ├── styles.rs
    │   │   │   │       └── test.rs
    │   │   │   ├── utils/
    │   │   │   │   ├── args.rs
    │   │   │   │   ├── debug_query.rs
    │   │   │   │   ├── error_context.rs
    │   │   │   │   ├── inspect.rs
    │   │   │   │   ├── mod.rs
    │   │   │   │   ├── print_diff.rs
    │   │   │   │   ├── rule_overwrite.rs
    │   │   │   │   └── worker.rs
    │   │   │   └── verify/
    │   │   │       ├── case_result.rs
    │   │   │       ├── find_file.rs
    │   │   │       ├── reporter.rs
    │   │   │       ├── snapshot.rs
    │   │   │       └── test_case.rs
    │   │   └── tests/
    │   │       ├── help_test.rs
    │   │       ├── run_test.rs
    │   │       ├── scan_test.rs
    │   │       ├── verify_test.rs
    │   │       └── common/
    │   │           └── mod.rs
    │   ├── config/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── check_var.rs
    │   │       ├── combined.rs
    │   │       ├── fixer.rs
    │   │       ├── label.rs
    │   │       ├── lib.rs
    │   │       ├── maybe.rs
    │   │       ├── rule_collection.rs
    │   │       ├── rule_config.rs
    │   │       ├── rule_core.rs
    │   │       ├── rule/
    │   │       │   ├── deserialize_env.rs
    │   │       │   ├── mod.rs
    │   │       │   ├── nth_child.rs
    │   │       │   ├── range.rs
    │   │       │   ├── referent_rule.rs
    │   │       │   ├── relational_rule.rs
    │   │       │   ├── selector.rs
    │   │       │   └── stop_by.rs
    │   │       └── transform/
    │   │           ├── mod.rs
    │   │           ├── parse.rs
    │   │           ├── rewrite.rs
    │   │           ├── string_case.rs
    │   │           └── trans.rs
    │   ├── core/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── language.rs
    │   │       ├── lib.rs
    │   │       ├── matcher.rs
    │   │       ├── meta_var.rs
    │   │       ├── node.rs
    │   │       ├── ops.rs
    │   │       ├── pinned.rs
    │   │       ├── replacer.rs
    │   │       ├── source.rs
    │   │       ├── match_tree/
    │   │       │   ├── match_node.rs
    │   │       │   ├── mod.rs
    │   │       │   └── strictness.rs
    │   │       ├── matcher/
    │   │       │   ├── kind.rs
    │   │       │   ├── node_match.rs
    │   │       │   ├── pattern.rs
    │   │       │   └── text.rs
    │   │       ├── replacer/
    │   │       │   ├── indent.rs
    │   │       │   ├── structural.rs
    │   │       │   └── template.rs
    │   │       └── tree_sitter/
    │   │           ├── mod.rs
    │   │           └── traversal.rs
    │   ├── dynamic/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── custom_lang.rs
    │   │       └── lib.rs
    │   ├── language/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── bash.rs
    │   │       ├── cpp.rs
    │   │       ├── csharp.rs
    │   │       ├── css.rs
    │   │       ├── elixir.rs
    │   │       ├── go.rs
    │   │       ├── haskell.rs
    │   │       ├── hcl.rs
    │   │       ├── html.rs
    │   │       ├── json.rs
    │   │       ├── kotlin.rs
    │   │       ├── lib.rs
    │   │       ├── lua.rs
    │   │       ├── nix.rs
    │   │       ├── parsers.rs
    │   │       ├── php.rs
    │   │       ├── python.rs
    │   │       ├── ruby.rs
    │   │       ├── rust.rs
    │   │       ├── scala.rs
    │   │       ├── solidity.rs
    │   │       ├── swift.rs
    │   │       └── yaml.rs
    │   ├── lsp/
    │   │   ├── Cargo.toml
    │   │   ├── src/
    │   │   │   ├── lib.rs
    │   │   │   └── utils.rs
    │   │   └── tests/
    │   │       └── basic.rs
    │   ├── napi/
    │   │   ├── README.md
    │   │   ├── build.rs
    │   │   ├── Cargo.toml
    │   │   ├── dprint.json
    │   │   ├── index.d.ts
    │   │   ├── index.js
    │   │   ├── LICENSE
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── .npmignore
    │   │   ├── .yarnrc.yml
    │   │   ├── __test__/
    │   │   │   ├── custom.spec.ts
    │   │   │   ├── index.spec.ts
    │   │   │   ├── test.vue
    │   │   │   └── type.spec.ts
    │   │   ├── lang/
    │   │   │   └── .gitkeep
    │   │   ├── npm/
    │   │   │   ├── darwin-arm64/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── darwin-x64/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── linux-arm64-gnu/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── linux-arm64-musl/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── linux-x64-gnu/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── linux-x64-musl/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── win32-arm64-msvc/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   ├── win32-ia32-msvc/
    │   │   │   │   ├── README.md
    │   │   │   │   └── package.json
    │   │   │   └── win32-x64-msvc/
    │   │   │       ├── README.md
    │   │   │       └── package.json
    │   │   ├── scripts/
    │   │   │   ├── constants.ts
    │   │   │   └── generateTypes.ts
    │   │   ├── src/
    │   │   │   ├── doc.rs
    │   │   │   ├── find_files.rs
    │   │   │   ├── lib.rs
    │   │   │   ├── napi_lang.rs
    │   │   │   └── sg_node.rs
    │   │   └── types/
    │   │       ├── api.d.ts
    │   │       ├── config.d.ts
    │   │       ├── deprecated.d.ts
    │   │       ├── lang.d.ts
    │   │       ├── registerDynamicLang.d.ts
    │   │       ├── rule.d.ts
    │   │       ├── sgnode.d.ts
    │   │       └── staticTypes.d.ts
    │   └── pyo3/
    │       ├── README.md
    │       ├── Cargo.toml
    │       ├── pyproject.toml
    │       ├── ast_grep_py/
    │       │   ├── __init__.py
    │       │   ├── ast_grep_py.pyi
    │       │   └── py.typed
    │       ├── src/
    │       │   ├── lib.rs
    │       │   ├── py_lang.rs
    │       │   ├── py_node.rs
    │       │   ├── range.rs
    │       │   └── unicode_position.rs
    │       └── tests/
    │           ├── test_fix.py
    │           ├── test_range.py
    │           ├── test_register_lang.py
    │           ├── test_rule.py
    │           ├── test_simple.py
    │           ├── test_traversal.py
    │           └── test_wrong_usage.py
    ├── npm/
    │   ├── README.md
    │   ├── ast-grep
    │   ├── package.json
    │   ├── postinstall.js
    │   ├── sg
    │   └── platforms/
    │       ├── darwin-arm64/
    │       │   ├── README.md
    │       │   └── package.json
    │       ├── darwin-x64/
    │       │   ├── README.md
    │       │   └── package.json
    │       ├── linux-arm64-gnu/
    │       │   ├── README.md
    │       │   └── package.json
    │       ├── linux-x64-gnu/
    │       │   ├── README.md
    │       │   └── package.json
    │       ├── win32-arm64-msvc/
    │       │   ├── README.md
    │       │   └── package.json
    │       ├── win32-ia32-msvc/
    │       │   ├── README.md
    │       │   └── package.json
    │       └── win32-x64-msvc/
    │           ├── README.md
    │           └── package.json
    ├── schemas/
    │   ├── bash_rule.json
    │   ├── c_rule.json
    │   ├── cpp_rule.json
    │   ├── csharp_rule.json
    │   ├── css_rule.json
    │   ├── elixir_rule.json
    │   ├── go_rule.json
    │   ├── haskell_rule.json
    │   ├── html_rule.json
    │   ├── java_rule.json
    │   ├── javascript_rule.json
    │   ├── json_rule.json
    │   ├── kotlin_rule.json
    │   ├── lua_rule.json
    │   ├── php_rule.json
    │   ├── project.json
    │   ├── python_rule.json
    │   ├── ruby_rule.json
    │   ├── rule.json
    │   ├── rust_rule.json
    │   ├── scala_rule.json
    │   ├── swift_rule.json
    │   ├── tsx_rule.json
    │   ├── typescript_rule.json
    │   └── yaml_rule.json
    ├── xtask/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── main.rs
    │       └── schema.rs
    ├── .cargo/
    │   └── config.toml
    └── .github/
        ├── CONTRIBUTING.md
        ├── copilot-instructions.md
        ├── FUNDING.yml
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.yml
        │   ├── config.yml
        │   └── feature_request.md
        └── workflows/
            ├── coverage.yaml
            ├── napi.yml
            ├── pyo3.yml
            ├── pypi.yml
            └── release.yml

================================================
FILE: README.md
================================================
<p align=center>
  <img src="https://ast-grep.github.io/logo.svg" alt="ast-grep"/>
</p>

<p align="center">
   <img src="https://github.com/ast-grep/ast-grep/actions/workflows/coverage.yaml/badge.svg" alt="coverage badge"/>
   <a href="https://app.codecov.io/gh/ast-grep/ast-grep"><img src="https://codecov.io/gh/ast-grep/ast-grep/branch/main/graph/badge.svg?token=37VX8H2EWV"/></a>
   <a href="https://discord.gg/4YZjf6htSQ" target="_blank"><img alt="Discord" src="https://img.shields.io/discord/1107749847722889217?label=Discord"></a>
   <a href="https://repology.org/project/ast-grep/versions" target="_blank"><img alt="Repology" src="https://repology.org/badge/tiny-repos/ast-grep.svg"></a>
   <img src="https://img.shields.io/github/stars/ast-grep/ast-grep?style=social" alt="Badge"/>
   <img src="https://img.shields.io/github/forks/ast-grep/ast-grep?style=social" alt="Badge"/>
   <img alt="GitHub Sponsors" src="https://img.shields.io/github/sponsors/HerringtonDarkholme?style=social">
   <a href="https://gurubase.io/g/ast-grep"><img alt="Gurubase" src="https://img.shields.io/badge/Gurubase-Ask%20ast--grep%20Guru-006BFF"></a>
</p>


## ast-grep(sg)

ast-grep(sg) is a CLI tool for code structural search, lint, and rewriting.

## Introduction
ast-grep is an [abstract syntax tree](https://dev.to/balapriya/abstract-syntax-tree-ast-explained-in-plain-english-1h38) based tool to search code by pattern code. Think of it as your old-friend [`grep`](https://en.wikipedia.org/wiki/Grep#:~:text=grep%20is%20a%20command%2Dline,which%20has%20the%20same%20effect.), but matching AST nodes instead of text.
You can write patterns as if you are writing ordinary code. It will match all code that has the same syntactical structure.
You can use `$` sign + upper case letters as a [wildcard](https://en.wikipedia.org/wiki/Wildcard_character), e.g. `$MATCH`, to match any single AST node. Think of it as [regular expression dot](https://regexone.com/lesson/wildcards_dot) `.`, except it is not textual.

Try the [online playground](https://ast-grep.github.io/playground.html) for a taste!

## Screenshot
![demo](https://ast-grep.github.io/image/search-replace.png)

See more screenshots on the [website](https://ast-grep.github.io/).

## Installation
You can install it from [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm), [pip](https://pypi.org/), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html),  [cargo-binstall](https://github.com/cargo-bins/cargo-binstall), [homebrew](https://brew.sh/), [scoop](https://scoop.sh/) or [MacPorts](https://www.macports.org)!

```bash
npm install --global @ast-grep/cli
pip install ast-grep-cli
brew install ast-grep
```


<details>
<summary>Click for more installation methods</summary>

```bash
cargo install ast-grep --locked
cargo binstall ast-grep

# install via scoop, thank @brian6932
scoop install main/ast-grep

# install via MacPorts
sudo port install ast-grep

# try ast-grep in nix-shell
nix-shell -p ast-grep
```
</details>

Or you can build ast-grep from source. You need to install rustup, clone the repository and then
```bash
cargo install --path ./crates/cli --locked
```
[Packages](https://repology.org/project/ast-grep/versions) are available on other platforms too.


## Command line usage example

ast-grep has following form.
```
ast-grep --pattern 'var code = $PATTERN' --rewrite 'let code = new $PATTERN' --lang ts
```

### Example

* [Rewrite code in null coalescing operator](https://twitter.com/Hchan_mgn/status/1547061516993699841?s=20&t=ldDoj4U2nq-FRKQkU5GWXA)

```bash
ast-grep -p '$A && $A()' -l ts -r '$A?.()'
```

* [Rewrite](https://twitter.com/Hchan_mgn/status/1561802312846278657) [Zodios](https://github.com/ecyrbe/zodios#migrate-to-v8)
```bash
ast-grep -p 'new Zodios($URL,  $CONF as const,)' -l ts -r 'new Zodios($URL, $CONF)' -i
```

* [Implement eslint rule using YAML.](https://twitter.com/Hchan_mgn/status/1560108625460355073)


## Sponsor
![Sponsors](https://raw.githubusercontent.com/HerringtonDarkholme/sponsors/main/sponsorkit/sponsors.svg)

If you find ast-grep interesting and useful for your work, please [buy me a coffee](https://github.com/sponsors/HerringtonDarkholme)
so I can spend more time on the project!

## Feature Highlight

ast-grep's core is an algorithm to search and replace code based on abstract syntax tree produced by tree-sitter.
It can help you to do lightweight static analysis and massive scale code manipulation in an intuitive way.

Key highlights:

* An intuitive pattern to find and replace AST.
ast-grep's pattern looks like ordinary code you would write every day (you could say the pattern is isomorphic to code).

* jQuery like API for AST traversal and manipulation.

* YAML configuration to write new linting rules or code modification.

* Written in compiled language, with tree-sitter based parsing and utilizing multiple cores.

* Beautiful command line interface :)

ast-grep's vision is to democratize abstract syntax tree magic and to liberate one from cumbersome AST programming!

* If you are an open-source library author, ast-grep can help your library users adopt breaking changes more easily.
* if you are a tech lead in your team, ast-grep can help you enforce code best practice tailored to your business need.
* If you are a security researcher, ast-grep can help you write rules much faster.


================================================
FILE: Cargo.toml
================================================
[workspace]
members = [
  "crates/*",
  "xtask"
]
default-members = ["crates/*"]
resolver = "2"

[profile.release]
lto = true

[workspace.package]
version = "0.39.5"
authors = ["Herrington Darkholme <2883231+HerringtonDarkholme@users.noreply.github.com>"]
edition = "2021"
license = "MIT"
documentation = "https://ast-grep.github.io/guide/introduction.html"
homepage = "https://ast-grep.github.io/"
repository = "https://github.com/ast-grep/ast-grep"
rust-version = "1.79"
readme = "README.md"

[workspace.dependencies]
ast-grep-core = { path = "crates/core", version = "0.39.5", default-features = false }
ast-grep-config = { path = "crates/config", version = "0.39.5" }
ast-grep-dynamic = { path = "crates/dynamic", version = "0.39.5" }
ast-grep-language = { path = "crates/language", version = "0.39.5" }
ast-grep-lsp = { path = "crates/lsp", version = "0.39.5" }

bit-set = { version = "0.8.0" }
ignore = { version = "0.4.22" }
regex = { version = "1.10.4" }
serde = { version = "1.0.200", features = ["derive"] }
serde_yaml = "0.9.33"
tree-sitter = { version = "0.25.4" }
thiserror = "2.0.0"
schemars = "1.0.0"
anyhow = "1.0.82"
dashmap = "6.0.0"



================================================
FILE: clippy.toml
================================================
ignore-interior-mutability = ["fluent_uri::Uri"]


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2022 Herrington Darkholme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["maturin>=1.1,<2.0"]
build-backend = "maturin"

[project]
name = "ast-grep-cli"
version = "0.39.5"
description = "Structural Search and Rewrite code at large scale using precise AST pattern."
authors = [{ name = "Herrington Darkholme", email = "2883231+HerringtonDarkholme@users.noreply.github.com" }]
maintainers = [{ name = "Herrington Darkholme", email = "2883231+HerringtonDarkholme@users.noreply.github.com" }]
readme = "README.md"
license = { file = "LICENSE" }
keywords = [
  "ast",
  "pattern",
  "codemod",
  "structural search",
  "rewrite"
]
classifiers = [
  "Development Status :: 3 - Alpha",
  "Environment :: Console",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Rust",
  "Topic :: Security",
  "Topic :: Software Development :: Quality Assurance",
  "Topic :: Software Development",
  "Topic :: Text Processing"
]


[project.urls]
Repository = "https://github.com/ast-grep/ast-grep"
Documentation = "https://ast-grep.github.io/"
Changelog = "https://github.com/ast-grep/ast-grep/blob/main/CHANGELOG.md"


[tool.maturin]
bindings = "bin"
manifest-path = "crates/cli/Cargo.toml"
strip = true



================================================
FILE: renovate.json
================================================
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:base"
  ],
  "packageRules": [
    {
      "matchUpdateTypes": ["patch", "pin", "digest"],
      "automerge": true
    }
  ]
}


================================================
FILE: rust-toolchain.toml
================================================
[toolchain]
channel = "stable"
components = ["rustfmt", "clippy"]


================================================
FILE: rustfmt.toml
================================================
tab_spaces = 2



================================================
FILE: .editorconfig
================================================
# EditorConfig helps developers define and maintain consistent
# coding styles between different editors or IDEs
# http://editorconfig.org
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = false

[*.md]
trim_trailing_whitespace = false

[*.{py,pyi}]
indent_size = 4


================================================
FILE: .pre-commit-config.yaml
================================================
repos:
-   repo: https://github.com/doublify/pre-commit-rust
    rev: v1.0
    hooks:
    -   id: fmt
    -   id: cargo-check
    -   id: clippy
        args: ["--all-targets", "--all-features", "--", "-D", "clippy::all"]



================================================
FILE: crates/cli/Cargo.toml
================================================
[package]
name = "ast-grep"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]
categories = ["command-line-utilities", "development-tools", "parsing"]
default-run = "ast-grep"
# use relative path because maturin does not recognize
readme = "../../README.md"

version.workspace = true
authors.workspace = true
edition.workspace = true
license.workspace = true
documentation.workspace = true
homepage.workspace = true
repository.workspace = true
rust-version.workspace = true

[[bin]]
name = "ast-grep"
path = "src/main.rs"

[[bin]]
name = "sg"
path = "src/bin/alias.rs"

[dependencies]
ast-grep-core.workspace = true
ast-grep-config.workspace = true
ast-grep-dynamic.workspace = true
ast-grep-language.workspace = true
ast-grep-lsp.workspace = true
tree-sitter.workspace = true

ansi_term = "0.12.1"
anyhow.workspace = true
atty = "0.2.14"
clap = { version = "4.5.4", features = ["derive"] }
codespan-reporting = "0.12.0"
crossterm = "0.29.0"
ignore.workspace = true
regex.workspace = true
dashmap.workspace = true
termimad = "0.34.0"
terminal-light = "1.8.0"
inquire = "0.9.0"
serde.workspace = true
serde_json = "1.0.116"
serde_yaml.workspace = true
similar = { version = "2.5.0", features = ["inline"] }
smallvec = "1.13.2"
tokio = { version = "1.37.0", features = ["rt-multi-thread", "io-std"] }
clap_complete = "4.5.2"

[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
tempfile = "3.10.1"

# Support cargo bininstall, https://github.com/ast-grep/ast-grep/issues/1742
[package.metadata.binstall]
pkg-url = "{ repo }/releases/download/{ version }/app-{ target }{ archive-suffix }"
pkg-fmt = "zip"
bin-dir = "{ bin }{ binary-ext }"
disabled-strategies = ["quick-install"]


================================================
FILE: crates/cli/src/completions.rs
================================================
//! How to use generate shell completions.
//! Usage with bash:
//! ```console
//! sg completions > ast_grep.bash
//! $ ./ast_grep.bash
//! $ sg <TAB>
//! $ sg run --<TAB>
//! ```
//! Usage with zsh, the completion scripts have to be in a path that belongs to `$fpath`:
//! ```console
//! $ sg completions zsh > $HOME/.zsh/completions/_ast_grep
//! $ echo "fpath=($HOME/.zsh/completions $fpath)" >> ~/.zshrc
//! $ compinit
//! $ sg <TAB>
//! $ sg run --<TAB>
//! ```
//! Usage with fish:
//! ```console
//! $ sg completions fish > ast_grep.fish
//! $ ./ast_grep.fish
//! $ sg <TAB>
//! $ sg run --<TAB>
//! ```

use anyhow::Result;
use clap::{CommandFactory, Parser};
use clap_complete::{generate, Shell};

use crate::utils::ErrorContext as EC;

use std::env;
use std::io;
use std::path::Path;

#[derive(Parser)]
pub struct CompletionsArg {
  /// Output the completion file for given shell.
  /// If not provided, shell flavor will be inferred from environment.
  #[arg(value_enum)]
  shell: Option<Shell>,
}

pub fn run_shell_completion<C: CommandFactory>(arg: CompletionsArg) -> Result<()> {
  run_shell_completion_impl::<C, _>(arg, &mut io::stdout())
}

fn run_shell_completion_impl<C: CommandFactory, W: io::Write>(
  arg: CompletionsArg,
  output: &mut W,
) -> Result<()> {
  let Some(shell) = arg.shell.or_else(Shell::from_env) else {
    return Err(anyhow::anyhow!(EC::CannotInferShell));
  };
  let mut cmd = C::command();
  let cmd_name = match get_bin_name() {
    Some(cmd) => cmd,
    None => cmd.get_name().to_string(),
  };
  generate(shell, &mut cmd, cmd_name, output);
  Ok(())
}

// https://github.com/clap-rs/clap/blob/063b1536289f72369bcd59d61449d355aa3a1d6b/clap_builder/src/builder/command.rs#L781
fn get_bin_name() -> Option<String> {
  let bin_path = env::args().next()?;
  let p = Path::new(&bin_path);
  let name = p.file_name()?;
  Some(name.to_str()?.to_string())
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::App;

  #[test]
  fn test_generate_command() {
    let mut output = vec![];
    let arg = CompletionsArg {
      shell: Some(Shell::Bash),
    };
    run_shell_completion_impl::<App, _>(arg, &mut output).expect("should succeed");
    let output = String::from_utf8(output).expect("should be valid");
    assert!(output.contains("ast_grep"));
  }
}



================================================
FILE: crates/cli/src/config.rs
================================================
use crate::lang::{CustomLang, LanguageGlobs, SerializableInjection, SgLang};
use crate::utils::{ErrorContext as EC, RuleOverwrite, RuleTrace};

use anyhow::{Context, Result};
use ast_grep_config::{
  from_str, from_yaml_string, DeserializeEnv, GlobalRules, RuleCollection, RuleConfig,
};
use ast_grep_language::config_file_type;
use ignore::WalkBuilder;
use serde::{Deserialize, Serialize};

use std::collections::HashMap;
use std::fs::read_to_string;
use std::path::{Path, PathBuf};

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TestConfig {
  pub test_dir: PathBuf,
  /// Specify the directory containing snapshots. The path is relative to `test_dir`
  #[serde(skip_serializing_if = "Option::is_none")]
  pub snapshot_dir: Option<PathBuf>,
}

impl From<PathBuf> for TestConfig {
  fn from(path: PathBuf) -> Self {
    TestConfig {
      test_dir: path,
      snapshot_dir: None,
    }
  }
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AstGrepConfig {
  /// YAML rule directories
  #[serde(default, skip_serializing_if = "Vec::is_empty")]
  pub rule_dirs: Vec<PathBuf>,
  /// test configurations
  #[serde(skip_serializing_if = "Option::is_none")]
  pub test_configs: Option<Vec<TestConfig>>,
  /// util rules directories
  #[serde(skip_serializing_if = "Option::is_none")]
  pub util_dirs: Option<Vec<PathBuf>>,
  /// configuration for custom languages
  #[serde(skip_serializing_if = "Option::is_none")]
  pub custom_languages: Option<HashMap<String, CustomLang>>,
  /// additional file globs for languages
  #[serde(skip_serializing_if = "Option::is_none")]
  pub language_globs: Option<LanguageGlobs>,
  /// injection config for embedded languages
  #[serde(default, skip_serializing_if = "Vec::is_empty")]
  pub language_injections: Vec<SerializableInjection>,
}

#[derive(Clone)]
pub struct ProjectConfig {
  pub project_dir: PathBuf,
  /// YAML rule directories
  pub rule_dirs: Vec<PathBuf>,
  /// test configurations
  pub test_configs: Option<Vec<TestConfig>>,
  /// util rules directories
  pub util_dirs: Option<Vec<PathBuf>>,
}

impl ProjectConfig {
  // return None if config file does not exist
  fn discover_project(config_path: Option<PathBuf>) -> Result<Option<(PathBuf, AstGrepConfig)>> {
    let config_path = find_config_path_with_default(config_path).context(EC::ProjectNotExist)?;
    // NOTE: if config file does not exist, return None
    let Some(config_path) = config_path else {
      return Ok(None);
    };
    let config_str = read_to_string(&config_path).context(EC::ReadConfiguration)?;
    let sg_config: AstGrepConfig = from_str(&config_str).context(EC::ParseConfiguration)?;
    let project_dir = config_path
      .parent()
      .expect("config file must have parent directory")
      .to_path_buf();
    Ok(Some((project_dir, sg_config)))
  }

  pub fn find_rules(
    &self,
    rule_overwrite: RuleOverwrite,
  ) -> Result<(RuleCollection<SgLang>, RuleTrace)> {
    let global_rules = find_util_rules(self)?;
    read_directory_yaml(self, global_rules, rule_overwrite)
  }

  /// returns a Result of Result.
  /// The inner Result is for configuration not found, or ProjectNotExist
  /// The outer Result is for definitely wrong config.
  pub fn setup(config_path: Option<PathBuf>) -> Result<Result<Self>> {
    let Some((project_dir, mut sg_config)) = Self::discover_project(config_path)? else {
      return Ok(Err(anyhow::anyhow!(EC::ProjectNotExist)));
    };
    let config = ProjectConfig {
      project_dir,
      rule_dirs: sg_config.rule_dirs.drain(..).collect(),
      test_configs: sg_config.test_configs.take(),
      util_dirs: sg_config.util_dirs.take(),
    };
    // sg_config will not use rule dirs and test configs anymore
    register_custom_language(&config.project_dir, sg_config)?;
    Ok(Ok(config))
  }
}

fn register_custom_language(project_dir: &Path, sg_config: AstGrepConfig) -> Result<()> {
  if let Some(custom_langs) = sg_config.custom_languages {
    SgLang::register_custom_language(project_dir, custom_langs)?;
  }
  if let Some(globs) = sg_config.language_globs {
    SgLang::register_globs(globs)?;
  }
  SgLang::register_injections(sg_config.language_injections)?;
  Ok(())
}

fn build_util_walker(base_dir: &Path, util_dirs: &Option<Vec<PathBuf>>) -> Option<WalkBuilder> {
  let mut util_dirs = util_dirs.as_ref()?.iter();
  let first = util_dirs.next()?;
  let mut walker = WalkBuilder::new(base_dir.join(first));
  for dir in util_dirs {
    walker.add(base_dir.join(dir));
  }
  Some(walker)
}

fn find_util_rules(config: &ProjectConfig) -> Result<GlobalRules> {
  let ProjectConfig {
    project_dir,
    util_dirs,
    ..
  } = config;
  let Some(mut walker) = build_util_walker(project_dir, util_dirs) else {
    return Ok(GlobalRules::default());
  };
  let mut utils = vec![];
  let walker = walker.types(config_file_type()).build();
  for dir in walker {
    let config_file = dir.with_context(|| EC::WalkRuleDir(PathBuf::new()))?;
    // file_type is None only if it is stdin, safe to panic here
    if !config_file
      .file_type()
      .expect("file type should be available for non-stdin")
      .is_file()
    {
      continue;
    }
    let path = config_file.path();
    let file = read_to_string(path)?;
    let new_configs = from_str(&file)?;
    utils.push(new_configs);
  }

  let ret = DeserializeEnv::<SgLang>::parse_global_utils(utils).context(EC::InvalidGlobalUtils)?;
  Ok(ret)
}

fn read_directory_yaml(
  config: &ProjectConfig,
  global_rules: GlobalRules,
  rule_overwrite: RuleOverwrite,
) -> Result<(RuleCollection<SgLang>, RuleTrace)> {
  let mut configs = vec![];
  let ProjectConfig {
    project_dir,
    rule_dirs,
    ..
  } = config;
  for dir in rule_dirs {
    let dir_path = project_dir.join(dir);
    let walker = WalkBuilder::new(&dir_path)
      .types(config_file_type())
      .build();
    for dir in walker {
      let config_file = dir.with_context(|| EC::WalkRuleDir(dir_path.clone()))?;
      // file_type is None only if it is stdin, safe to panic here
      if !config_file
        .file_type()
        .expect("file type should be available for non-stdin")
        .is_file()
      {
        continue;
      }
      let path = config_file.path();
      let new_configs = read_rule_file(path, Some(&global_rules))?;
      configs.extend(new_configs);
    }
  }
  let total_rule_count = configs.len();

  let configs = rule_overwrite.process_configs(configs)?;
  let collection = RuleCollection::try_new(configs).context(EC::GlobPattern)?;
  let effective_rule_count = collection.total_rule_count();
  let trace = RuleTrace {
    file_trace: Default::default(),
    effective_rule_count,
    skipped_rule_count: total_rule_count - effective_rule_count,
  };
  Ok((collection, trace))
}

pub fn with_rule_stats(
  configs: Vec<RuleConfig<SgLang>>,
) -> Result<(RuleCollection<SgLang>, RuleTrace)> {
  let total_rule_count = configs.len();
  let collection = RuleCollection::try_new(configs).context(EC::GlobPattern)?;
  let effective_rule_count = collection.total_rule_count();
  let trace = RuleTrace {
    file_trace: Default::default(),
    effective_rule_count,
    skipped_rule_count: total_rule_count - effective_rule_count,
  };
  Ok((collection, trace))
}

pub fn read_rule_file(
  path: &Path,
  global_rules: Option<&GlobalRules>,
) -> Result<Vec<RuleConfig<SgLang>>> {
  let yaml = read_to_string(path).with_context(|| EC::ReadRule(path.to_path_buf()))?;
  let parsed = if let Some(globals) = global_rules {
    from_yaml_string(&yaml, globals)
  } else {
    from_yaml_string(&yaml, &Default::default())
  };
  parsed.with_context(|| EC::ParseRule(path.to_path_buf()))
}

const CONFIG_FILE: &str = "sgconfig.yml";

/// return None if config file does not exist
fn find_config_path_with_default(config_path: Option<PathBuf>) -> Result<Option<PathBuf>> {
  if config_path.is_some() {
    return Ok(config_path);
  }
  let mut path = std::env::current_dir()?;
  loop {
    let maybe_config = path.join(CONFIG_FILE);
    if maybe_config.exists() {
      break Ok(Some(maybe_config));
    }
    if let Some(parent) = path.parent() {
      path = parent.to_path_buf();
    } else {
      break Ok(None);
    }
  }
}



================================================
FILE: crates/cli/src/lib.rs
================================================
mod completions;
mod config;
mod lang;
mod lsp;
mod new;
mod print;
mod run;
mod scan;
mod utils;
mod verify;

use anyhow::Result;
use clap::{Parser, Subcommand};
use std::path::PathBuf;

use completions::{run_shell_completion, CompletionsArg};
use config::ProjectConfig;
use lsp::{run_language_server, LspArg};
use new::{run_create_new, NewArg};
use run::{run_with_pattern, RunArg};
use scan::{run_with_config, ScanArg};
use utils::exit_with_error;
use verify::{run_test_rule, TestArg};

const LOGO: &str = r#"
Search and Rewrite code at large scale using AST pattern.
                    __
        ____ ______/ /_      ____ _________  ____
       / __ `/ ___/ __/_____/ __ `/ ___/ _ \/ __ \
      / /_/ (__  ) /_/_____/ /_/ / /  /  __/ /_/ /
      \__,_/____/\__/      \__, /_/   \___/ .___/
                          /____/         /_/
"#;
#[derive(Parser)]
#[clap(author, version, about, long_about = LOGO)]
/**
 * TODO: add some description for ast-grep: sg
 * Example:
 * sg -p "$PATTERN.to($MATCH)" -l ts --rewrite "use($MATCH)"
 */
struct App {
  #[clap(subcommand)]
  command: Commands,
  /// Path to ast-grep root config, default is sgconfig.yml.
  #[clap(short, long, global = true, value_name = "CONFIG_FILE")]
  config: Option<PathBuf>,
}

#[derive(Subcommand)]
enum Commands {
  /// Run one time search or rewrite in command line. (default command)
  Run(RunArg),
  /// Scan and rewrite code by configuration.
  Scan(ScanArg),
  /// Test ast-grep rules.
  Test(TestArg),
  /// Create new ast-grep project or items like rules/tests.
  New(NewArg),
  /// Start language server.
  Lsp(LspArg),
  /// Generate shell completion script.
  Completions(CompletionsArg),
  /// Generate rule docs for current configuration. (Not Implemented Yet)
  #[cfg(debug_assertions)]
  Docs,
}

pub fn execute_main() -> Result<()> {
  match main_with_args(std::env::args()) {
    Err(error) => exit_with_error(error),
    ok => ok,
  }
}

fn is_command(arg: &str, command: &str) -> bool {
  let arg = arg.split('=').next().unwrap_or(arg);
  if arg.starts_with("--") {
    let arg = arg.trim_start_matches("--");
    arg == command
  } else if arg.starts_with('-') {
    let arg = arg.trim_start_matches('-');
    arg == &command[..1]
  } else {
    false
  }
}

fn try_default_run(args: &[String]) -> Result<Option<RunArg>> {
  // use `run` if there is at lease one pattern arg with no user provided command
  let should_use_default_run_command =
    args.iter().skip(1).any(|p| is_command(p, "pattern")) && args[1].starts_with('-');
  if should_use_default_run_command {
    // handle no subcommand
    let arg = RunArg::try_parse_from(args)?;
    Ok(Some(arg))
  } else {
    Ok(None)
  }
}

/// finding project and setup custom language configuration
fn setup_project_is_possible(args: &[String]) -> Result<Result<ProjectConfig>> {
  let mut config = None;
  for i in 0..args.len() {
    let arg = &args[i];
    if !is_command(arg, "config") {
      continue;
    }
    // handle --config=config.yml, see ast-grep/ast-grep#1617
    if arg.contains('=') {
      let config_file = arg.split('=').nth(1).unwrap().into();
      config = Some(config_file);
      break;
    }
    // handle -c config.yml, arg value should be next
    if i + 1 >= args.len() || args[i + 1].starts_with('-') {
      return Err(anyhow::anyhow!("missing config file after -c"));
    }
    let config_file = (&args[i + 1]).into();
    config = Some(config_file);
  }
  ProjectConfig::setup(config)
}

// this wrapper function is for testing
pub fn main_with_args(args: impl Iterator<Item = String>) -> Result<()> {
  let args: Vec<_> = args.collect();
  // do not unwrap project before cmd parsing
  // sg help does not need a valid sgconfig.yml
  let project = setup_project_is_possible(&args);
  if let Some(arg) = try_default_run(&args)? {
    return run_with_pattern(arg, project?);
  }
  let app = App::try_parse_from(args)?;
  let project = project?; // unwrap here to report invalid project
  match app.command {
    Commands::Run(arg) => run_with_pattern(arg, project),
    Commands::Scan(arg) => run_with_config(arg, project),
    Commands::Test(arg) => run_test_rule(arg, project),
    Commands::New(arg) => run_create_new(arg, project),
    Commands::Lsp(arg) => run_language_server(arg, project),
    Commands::Completions(arg) => run_shell_completion::<App>(arg),
    #[cfg(debug_assertions)]
    Commands::Docs => todo!("todo, generate rule docs based on current config"),
  }
}

#[cfg(test)]
mod test_cli {
  use super::*;

  fn sg(args: &str) -> Result<App> {
    let app = App::try_parse_from(
      std::iter::once("sg".into()).chain(args.split(' ').map(|s| s.to_string())),
    )?;
    Ok(app)
  }

  fn ok(args: &str) -> App {
    sg(args).expect("should parse")
  }
  fn error(args: &str) -> clap::Error {
    let Err(err) = sg(args) else {
      panic!("app parsing should fail!")
    };
    err
      .downcast::<clap::Error>()
      .expect("should have clap::Error")
  }

  #[test]
  fn test_wrong_usage() {
    error("");
    error("Some($A) -l rs");
    error("-l rs");
  }

  #[test]
  fn test_version_and_help() {
    let version = error("--version");
    assert!(version.to_string().starts_with("ast-grep"));
    let version = error("-V");
    assert!(version.to_string().starts_with("ast-grep"));
    let help = error("--help");
    assert!(help.to_string().contains("Search and Rewrite code"));
  }

  fn default_run(args: &str) {
    let args: Vec<_> = std::iter::once("sg".into())
      .chain(args.split(' ').map(|s| s.to_string()))
      .collect();
    assert!(matches!(try_default_run(&args), Ok(Some(_))));
  }
  #[test]
  fn test_no_arg_run() {
    let ret = main_with_args(["sg".to_owned()].into_iter());
    let err = ret.unwrap_err();
    assert!(err.to_string().contains("sg [OPTIONS] <COMMAND>"));
  }
  #[test]
  fn test_default_subcommand() {
    default_run("-p Some($A) -l rs");
    default_run("-p Some($A)");
    default_run("-p Some($A) -l rs -r $A.unwrap()");
  }

  #[test]
  fn test_run() {
    ok("run -p test -i");
    ok("run -p test --interactive dir");
    ok("run -p test -r Test dir");
    ok("run -p test -l rs --debug-query");
    ok("run -p test -l rs --debug-query not");
    ok("run -p test -l rs --debug-query=ast");
    ok("run -p test -l rs --debug-query=cst");
    ok("run -p test -l rs --color always");
    ok("run -p test -l rs --heading always");
    ok("run -p test dir1 dir2 dir3"); // multiple paths
    ok("run -p testm -r restm -U"); // update all
    ok("run -p testm -r restm --update-all"); // update all
    ok("run -p test --json compact"); // argument after --json should not be parsed as JsonStyle
    ok("run -p test --json=pretty dir");
    ok("run -p test --json dir"); // arg after --json should not be parsed as JsonStyle
    ok("run -p test --strictness ast");
    ok("run -p test --strictness relaxed");
    ok("run -p test --selector identifier"); // pattern + selector
    ok("run -p test --selector identifier -l js");
    ok("run -p test --follow");
    ok("run -p test --globs '*.js'");
    ok("run -p test --globs '*.{js, ts}'");
    ok("run -p test --globs '*.js' --globs '*.ts'");
    ok("run -p fubuki -j8");
    ok("run -p test --threads 12");
    ok("run -p test -l rs -c config.yml"); // global config arg
    error("run test");
    error("run --debug-query test"); // missing lang
    error("run -r Test dir");
    error("run -p test -i --json dir"); // conflict
    error("run -p test -U");
    error("run -p test --update-all");
    error("run -p test --strictness not");
    error("run -p test -l rs --debug-query=not");
    error("run -p test --selector");
    error("run -p test --threads");
  }

  #[test]
  fn test_scan() {
    ok("scan");
    ok("scan dir");
    ok("scan -r test-rule.yml dir");
    ok("scan -c test-rule.yml dir");
    ok("scan -c test-rule.yml");
    ok("scan --report-style short"); // conflict
    ok("scan dir1 dir2 dir3"); // multiple paths
    ok("scan -r test.yml --format github");
    ok("scan --format github");
    ok("scan --interactive");
    ok("scan --follow");
    ok("scan --json --include-metadata");
    ok("scan -r test.yml -c test.yml --json dir"); // allow registering custom lang
    ok("scan --globs '*.js'");
    ok("scan --globs '*.{js, ts}'");
    ok("scan --globs '*.js' --globs '*.ts'");
    ok("scan -j 12");
    ok("scan --threads 12");
    ok("scan -A 12");
    ok("scan --after 12");
    ok("scan --context 1");
    error("scan -i --json dir"); // conflict
    error("scan --report-style rich --json dir"); // conflict
    error("scan -r test.yml --inline-rules '{}'"); // conflict
    error("scan --format gitlab");
    error("scan --format github -i");
    error("scan --format local");
    error("scan --json=dir"); // wrong json flag
    error("scan --json= not-pretty"); // wrong json flag
    error("scan -j");
    error("scan --include-metadata"); // requires json
    error("scan --threads");
  }

  #[test]
  fn test_test() {
    ok("test");
    ok("test -c sgconfig.yml");
    ok("test --skip-snapshot-tests");
    ok("test -U");
    ok("test --update-all");
    error("test --update-all --skip-snapshot-tests");
  }
  #[test]
  fn test_new() {
    ok("new");
    ok("new project");
    ok("new -c sgconfig.yml rule");
    ok("new rule -y");
    ok("new test -y");
    ok("new util -y");
    ok("new rule -c sgconfig.yml");
    error("new --base-dir");
  }

  #[test]
  fn test_shell() {
    ok("completions");
    ok("completions zsh");
    ok("completions fish");
    error("completions not-shell");
    error("completions --shell fish");
  }
}



================================================
FILE: crates/cli/src/lsp.rs
================================================
use crate::config::ProjectConfig;
use crate::utils::{ErrorContext as EC, RuleOverwrite};
use anyhow::{Context, Result};
use ast_grep_lsp::{Backend, LspService, Server};
use clap::Args;

#[derive(Args)]
pub struct LspArg {}

async fn run_language_server_impl(_arg: LspArg, project: Result<ProjectConfig>) -> Result<()> {
  // env_logger::init();
  // TODO: move this error to client
  let project_config = project?;
  let stdin = tokio::io::stdin();
  let stdout = tokio::io::stdout();

  let config_base = project_config.project_dir.clone();

  // Create a rule finder closure that uses the CLI logic
  let rule_finder = move || {
    let (collection, _trace) = project_config.find_rules(RuleOverwrite::default())?;
    Ok(collection)
  };

  let (service, socket) =
    LspService::build(|client| Backend::new(client, config_base, rule_finder)).finish();
  Server::new(stdin, stdout, socket).serve(service).await;
  Ok(())
}

pub fn run_language_server(arg: LspArg, project: Result<ProjectConfig>) -> Result<()> {
  tokio::runtime::Builder::new_multi_thread()
    .enable_all()
    .build()
    .context(EC::StartLanguageServer)?
    .block_on(async { run_language_server_impl(arg, project).await })
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  #[ignore = "test lsp later"]
  fn test_lsp_start() {
    let arg = LspArg {};
    assert!(run_language_server(arg, Err(anyhow::anyhow!("error"))).is_err())
  }
}



================================================
FILE: crates/cli/src/main.rs
================================================
use anyhow::Result;
use ast_grep::execute_main;

fn main() -> Result<()> {
  execute_main()
}



================================================
FILE: crates/cli/src/new.rs
================================================
use crate::config::{AstGrepConfig, ProjectConfig, TestConfig};
use crate::lang::SgLang;
use crate::utils::ErrorContext as EC;

use anyhow::Result;
use clap::{Parser, Subcommand};
use inquire::validator::ValueRequiredValidator;

use std::fmt::Display;
use std::fs::{self, File};
use std::path::{Path, PathBuf};

#[derive(Parser)]
pub struct NewArg {
  /// The ast-grep item type to create. Available options: project/rule/test/utils.
  #[clap(subcommand)]
  entity: Option<Entity>,
  /// The id of the item to create.
  #[arg(value_parser, global = true)]
  name: Option<String>,
  /// The language of the item to create.
  ///
  /// This option is only available when creating rule and util.
  #[arg(short, long, global = true)]
  lang: Option<SgLang>,
  /// Accept all default options without interactive input during creation.
  ///
  /// You need to provide all required arguments via command line if this flag is true.
  /// Please see the command description for the what arguments are required.
  #[arg(short, long, global = true)]
  yes: bool,
}

fn create_dir(project_dir: &Path, dir: &str) -> Result<PathBuf> {
  let path = project_dir.join(dir);
  fs::create_dir_all(&path)?;
  // create a .gitkeep file to keep the folder in git
  // https://github.com/ast-grep/ast-grep/issues/1273
  let gitkeep = path.join(".gitkeep");
  File::create(gitkeep)?;
  Ok(path)
}

impl NewArg {
  fn ask_dir(&self, prompt: &str, default: &str) -> Result<String> {
    let dir = if self.yes {
      default.to_owned()
    } else {
      inquire::Text::new(prompt).with_default(default).prompt()?
    };
    Ok(dir)
  }

  fn confirm(&self, prompt: &str) -> Result<bool> {
    if self.yes {
      return Ok(true);
    }
    Ok(inquire::Confirm::new(prompt).with_default(true).prompt()?)
  }

  fn ask_entity_type(&self) -> Result<Entity> {
    if self.yes {
      self
        .entity
        .clone()
        .map(Ok)
        .unwrap_or_else(|| Err(anyhow::anyhow!(EC::InsufficientCLIArgument("entity"))))
    } else {
      let entity = inquire::Select::new(
        "Select the item you want to create:",
        vec![Entity::Rule, Entity::Test, Entity::Util],
      )
      .prompt()?;
      Ok(entity)
    }
  }

  fn choose_language(&self) -> Result<SgLang> {
    if let Some(lang) = self.lang {
      Ok(lang)
    } else if self.yes {
      Err(anyhow::anyhow!(EC::InsufficientCLIArgument("lang")))
    } else {
      Ok(inquire::Select::new("Choose rule's language", SgLang::all_langs()).prompt()?)
    }
  }

  fn ask_name(&self, entity: &'static str) -> Result<String> {
    if let Some(name) = &self.name {
      Ok(name.to_string())
    } else if self.yes {
      Err(anyhow::anyhow!(EC::InsufficientCLIArgument("name")))
    } else {
      Ok(
        inquire::Text::new(&format!("What is your {entity}'s name?"))
          .with_validator(ValueRequiredValidator::default())
          .prompt()?,
      )
    }
  }
}

/// The ast-grep item type to create.
#[derive(Subcommand, Debug, PartialEq, Eq, Clone)]
enum Entity {
  /// Create an new project by scaffolding.
  ///
  /// By default, this command will create a root config file `sgconfig.yml`,
  /// a rule folder `rules`, a test case folder `rule-tests` and a utility rule folder `utils`.
  /// You can customize the folder names during the creation.
  Project,
  /// Create a new rule.
  ///
  /// This command will create a new rule in one of the `rule_dirs`.
  /// You need to provide `name` and `language` either by interactive input or via command line arguments.
  /// ast-grep will ask you which `rule_dir` to use if multiple ones are configured in the `sgconfig.yml`.
  /// If `-y, --yes` flag is true, ast-grep will choose the first `rule_dir` to create the new rule.
  Rule,
  /// Create a new test case.
  ///
  /// This command will create a new test in one of the `test_dirs`.
  /// You need to provide `name` either by interactive input or via command line arguments.
  /// ast-grep will ask you which `test_dir` to use if multiple ones are configured in the `sgconfig.yml`.
  /// If `-y, --yes` flag is true, ast-grep will choose the first `test_dir` to create the new test.
  Test,
  /// Create a new global utility rule.
  ///
  /// This command will create a new global utility rule in one of the `utils` folders.
  /// You need to provide `name` and `language` either by interactive input or via command line arguments.
  /// ast-grep will ask you which `util_dir` to use if multiple ones are configured in the `sgconfig.yml`.
  /// If `-y, --yes` flag is true, ast-grep will choose the first `util_dir` to create the new item.
  Util,
}

impl Display for Entity {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    use Entity::*;
    match self {
      Project => f.write_str("Project"),
      Rule => f.write_str("Rule"),
      Test => f.write_str("Test"),
      Util => f.write_str("Util"),
    }
  }
}

pub fn run_create_new(mut arg: NewArg, project: Result<ProjectConfig>) -> Result<()> {
  if let Some(entity) = arg.entity.take() {
    run_create_entity(entity, arg, project)
  } else {
    ask_entity_type(arg, project)
  }
}

fn run_create_entity(entity: Entity, arg: NewArg, project: Result<ProjectConfig>) -> Result<()> {
  // check if we are under a project dir
  if let Ok(found) = project {
    return do_create_entity(entity, found, arg);
  }
  // check if we creating a project
  if entity == Entity::Project {
    create_new_project(arg, std::env::current_dir()?.as_path())
  } else {
    // if not, return error
    Err(anyhow::anyhow!(EC::ProjectNotExist))
  }
}

fn do_create_entity(entity: Entity, found: ProjectConfig, arg: NewArg) -> Result<()> {
  // ask user what destination to create if multiple dirs exist
  match entity {
    Entity::Rule => create_new_rule(found, arg),
    Entity::Test => create_new_test(found.test_configs, arg.name),
    Entity::Util => create_new_util(found, arg),
    Entity::Project => Err(anyhow::anyhow!(EC::ProjectAlreadyExist)),
  }
}

fn ask_entity_type(arg: NewArg, project: Result<ProjectConfig>) -> Result<()> {
  // 1. check if we are under a sgconfig.yml
  if let Ok(found) = project {
    // 2. ask users what to create if yes
    let entity = arg.ask_entity_type()?;
    do_create_entity(entity, found, arg)
  } else {
    // 3. ask users to provide project info if no sgconfig found
    print!("No sgconfig.yml found. ");
    let current_dir = std::env::current_dir()?;
    create_new_project(arg, &current_dir)
  }
}

fn create_new_project(arg: NewArg, project_dir: &Path) -> Result<()> {
  println!("Creating a new ast-grep project...");
  let ask_dir_and_create = |prompt: &str, default: &str| -> Result<PathBuf> {
    let dir = arg.ask_dir(prompt, default)?;
    create_dir(project_dir, &dir)
  };
  let rule_dirs = ask_dir_and_create("Where do you want to have your rules?", "rules")?;
  let test_dirs = if arg.confirm("Do you want to create rule tests?")? {
    let test_dirs = ask_dir_and_create("Where do you want to have your tests?", "rule-tests")?;
    Some(TestConfig::from(test_dirs))
  } else {
    None
  };
  let utils = if arg.confirm("Do you want to create folder for utility rules?")? {
    let util_dirs = ask_dir_and_create("Where do you want to have your utilities?", "utils")?;
    Some(util_dirs)
  } else {
    None
  };
  let root_config = AstGrepConfig {
    rule_dirs: vec![rule_dirs],
    test_configs: test_dirs.map(|t| vec![t]),
    util_dirs: utils.map(|u| vec![u]),
    custom_languages: None,      // advanced feature, skip now
    language_globs: None,        // advanced feature, skip now
    language_injections: vec![], // advanced feature
  };
  let config_path = project_dir.join("sgconfig.yml");
  let f = File::create(config_path)?;
  serde_yaml::to_writer(f, &root_config)?;
  println!("Your new ast-grep project has been created!");
  Ok(())
}

fn default_rule(id: &str, lang: SgLang) -> String {
  format!(
    r#"# yaml-language-server: $schema=https://raw.githubusercontent.com/ast-grep/ast-grep/main/schemas/rule.json

id: {id}
message: Add your rule message here....
severity: error # error, warning, info, hint
language: {lang}
rule:
  pattern: Your Rule Pattern here...
# utils: Extract repeated rule as local utility here.
# note: Add detailed explanation for the rule."#
  )
}

fn create_new_rule(found: ProjectConfig, arg: NewArg) -> Result<()> {
  let ProjectConfig {
    project_dir,
    rule_dirs,
    test_configs,
    ..
  } = found;
  let name = arg.ask_name("rule")?;
  let rule_dir = if rule_dirs.len() > 1 {
    let dirs = rule_dirs.iter().map(|p| p.display()).collect();
    let display =
      inquire::Select::new("Which rule dir do you want to save your rule?", dirs).prompt()?;
    project_dir.join(display.to_string())
  } else {
    project_dir.join(&rule_dirs[0])
  };
  let path = rule_dir.join(format!("{name}.yml"));
  if path.exists() {
    return Err(anyhow::anyhow!(EC::FileAlreadyExist(path)));
  }
  let lang = arg.choose_language()?;
  fs::write(&path, default_rule(&name, lang))?;
  println!("Created rules at {}", path.display());
  let need_test = arg.confirm("Do you also need to create a test for the rule?")?;
  if need_test {
    create_new_test(test_configs, Some(name))?;
  }
  Ok(())
}

fn default_test(id: &str) -> String {
  format!(
    r#"id: {id}
valid:
- "valid code"
invalid:
- "invalid code"
"#
  )
}

fn create_new_test(test_configs: Option<Vec<TestConfig>>, name: Option<String>) -> Result<()> {
  let Some(tests) = test_configs else {
    return Err(anyhow::anyhow!(EC::NoTestDirConfigured));
  };
  if tests.is_empty() {
    return Err(anyhow::anyhow!(EC::NoTestDirConfigured));
  }
  let test_dir = if tests.len() > 1 {
    let dirs = tests.iter().map(|t| t.test_dir.display()).collect();
    let display = inquire::Select::new("Which test dir do you want to use?", dirs).prompt()?;
    PathBuf::from(display.to_string())
  } else {
    tests[0].test_dir.clone()
  };
  let name = if let Some(name) = name {
    name
  } else {
    inquire::Text::new("What is the rule's id that you want to test?")
      .with_validator(ValueRequiredValidator::default())
      .prompt()?
  };
  let path = test_dir.join(format!("{name}-test.yml"));
  if path.exists() {
    return Err(anyhow::anyhow!(EC::FileAlreadyExist(path)));
  }
  fs::write(&path, default_test(&name))?;
  println!("Created test at {}", path.display());
  Ok(())
}

fn default_util(id: &str, lang: SgLang) -> String {
  format!(
    r#"id: {id}
language: {lang}
rule:
  pattern: Your Rule Pattern here...
# utils: Extract repeated rule as local utility here."#
  )
}

fn create_new_util(found: ProjectConfig, arg: NewArg) -> Result<()> {
  let ProjectConfig {
    project_dir,
    util_dirs,
    ..
  } = found;
  let Some(utils) = util_dirs else {
    return Err(anyhow::anyhow!(EC::NoUtilDirConfigured));
  };
  if utils.is_empty() {
    return Err(anyhow::anyhow!(EC::NoUtilDirConfigured));
  }
  let util_dir = if utils.len() > 1 {
    let dirs = utils.iter().map(|p| p.display()).collect();
    let display =
      inquire::Select::new("Which util dir do you want to save your rule?", dirs).prompt()?;
    project_dir.join(display.to_string())
  } else {
    project_dir.join(&utils[0])
  };
  let name = arg.ask_name("util")?;
  let path = util_dir.join(format!("{name}.yml"));
  if path.exists() {
    return Err(anyhow::anyhow!(EC::FileAlreadyExist(path)));
  }
  let lang = arg.choose_language()?;
  fs::write(&path, default_util(&name, lang))?;
  println!("Created util at {}", path.display());
  Ok(())
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_language::SupportLang;
  use std::path::Path;
  use tempfile::TempDir;

  fn create_project(tempdir: &Path) -> Result<()> {
    let arg = NewArg {
      entity: None,
      name: None,
      lang: None,
      yes: true,
    };
    create_new_project(arg, tempdir)?;
    assert!(tempdir.join("sgconfig.yml").exists());
    Ok(())
  }

  fn create_rule(temp: &Path) -> Result<()> {
    let project = ProjectConfig::setup(Some(temp.join("sgconfig.yml")))?;
    let arg = NewArg {
      entity: Some(Entity::Rule),
      name: Some("test-rule".into()),
      lang: Some(SupportLang::Rust.into()),
      yes: true,
    };
    run_create_new(arg, project)?;
    assert!(temp.join("rules/test-rule.yml").exists());
    Ok(())
  }

  fn create_util(temp: &Path) -> Result<()> {
    let project = ProjectConfig::setup(Some(temp.join("sgconfig.yml")))?;
    let arg = NewArg {
      entity: Some(Entity::Util),
      name: Some("test-utils".into()),
      lang: Some(SupportLang::Rust.into()),
      yes: true,
    };
    run_create_new(arg, project)?;
    assert!(temp.join("utils/test-utils.yml").exists());
    Ok(())
  }

  #[test]
  fn test_create_new() -> Result<()> {
    let dir = TempDir::new()?;
    create_project(dir.path())?;
    create_rule(dir.path())?;
    drop(dir); // drop at the end since temp dir clean up is done in Drop
    Ok(())
  }

  #[test]
  fn test_create_util() -> Result<()> {
    let dir = TempDir::new()?;
    create_project(dir.path())?;
    create_util(dir.path())?;
    drop(dir); // drop at the end since temp dir clean up is done in Drop
    Ok(())
  }
}



================================================
FILE: crates/cli/src/run.rs
================================================
use std::path::Path;

use anyhow::{Context, Result};
use ast_grep_config::Fixer;
use ast_grep_core::{MatchStrictness, Matcher, Pattern};
use ast_grep_language::{Language, LanguageExt};
use clap::{builder::PossibleValue, Parser, ValueEnum};
use ignore::WalkParallel;

use crate::config::ProjectConfig;
use crate::lang::SgLang;
use crate::print::{
  ColoredPrinter, Diff, Heading, InteractivePrinter, JSONPrinter, PrintProcessor, Printer,
};
use crate::utils::ErrorContext as EC;
use crate::utils::{filter_file_pattern, ContextArgs, InputArgs, MatchUnit, OutputArgs};
use crate::utils::{DebugFormat, FileTrace, RunTrace};
use crate::utils::{Items, PathWorker, StdInWorker, Worker};

fn lang_help() -> String {
  format!(
    "The language of the pattern. Supported languages are:\n{:?}",
    SgLang::all_langs()
  )
}

const LANG_HELP_LONG: &str = "The language of the pattern. For full language list, visit https://ast-grep.github.io/reference/languages.html";

#[derive(Clone)]
struct Strictness(MatchStrictness);
impl ValueEnum for Strictness {
  fn value_variants<'a>() -> &'a [Self] {
    use MatchStrictness as M;
    &[
      Strictness(M::Cst),
      Strictness(M::Smart),
      Strictness(M::Ast),
      Strictness(M::Relaxed),
      Strictness(M::Signature),
      Strictness(M::Template),
    ]
  }
  fn to_possible_value(&self) -> Option<PossibleValue> {
    use MatchStrictness as M;
    Some(match &self.0 {
      M::Cst => PossibleValue::new("cst").help("Match exact all node"),
      M::Smart => PossibleValue::new("smart").help("Match all node except source trivial nodes"),
      M::Ast => PossibleValue::new("ast").help("Match only ast nodes"),
      M::Relaxed => PossibleValue::new("relaxed").help("Match ast node except comments"),
      M::Signature => {
        PossibleValue::new("signature").help("Match ast node except comments, without text")
      }
      M::Template => PossibleValue::new("template")
        .help("Similar to smart but match text only, node kinds are ignored"),
    })
  }
}

#[derive(Parser)]
pub struct RunArg {
  // search pattern related options
  /// AST pattern to match.
  #[clap(short, long)]
  pattern: String,

  /// AST kind to extract sub-part of pattern to match.
  ///
  /// selector defines the sub-syntax node kind that is the actual matcher of the pattern.
  /// See https://ast-grep.github.io/guide/rule-config/atomic-rule.html#pattern-object.
  #[clap(long, value_name = "KIND")]
  selector: Option<String>,

  /// String to replace the matched AST node.
  #[clap(short, long, value_name = "FIX", required_if_eq("update_all", "true"))]
  rewrite: Option<String>,

  /// The language of the pattern query.
  #[clap(short, long, help(lang_help()), long_help=LANG_HELP_LONG)]
  lang: Option<SgLang>,

  /// Print query pattern's tree-sitter AST. Requires lang be set explicitly.
  #[clap(
      long,
      requires = "lang",
      value_name="format",
      num_args(0..=1),
      require_equals = true,
      default_missing_value = "pattern"
  )]
  debug_query: Option<DebugFormat>,

  /// The strictness of the pattern.
  #[clap(long)]
  strictness: Option<Strictness>,

  /// input related options
  #[clap(flatten)]
  input: InputArgs,

  /// output related options
  #[clap(flatten)]
  output: OutputArgs,

  /// context related options
  #[clap(flatten)]
  context: ContextArgs,

  /// Controls whether to print the file name as heading.
  ///
  /// If heading is used, the file name will be printed as heading before all matches of that file.
  /// If heading is not used, ast-grep will print the file path before each match as prefix.
  /// The default value `auto` is to use heading when printing to a terminal
  /// and to disable heading when piping to another program or redirected to files.
  #[clap(long, default_value = "auto", value_name = "WHEN")]
  heading: Heading,
}

impl RunArg {
  fn build_pattern(&self, lang: SgLang) -> Result<Pattern> {
    let pattern = if let Some(sel) = &self.selector {
      Pattern::contextual(&self.pattern, sel, lang)
    } else {
      Pattern::try_new(&self.pattern, lang)
    }
    .context(EC::ParsePattern)?;
    if let Some(strictness) = &self.strictness {
      Ok(pattern.with_strictness(strictness.0.clone()))
    } else {
      Ok(pattern)
    }
  }

  // do not unwrap pattern here, we should allow non-pattern to be debugged as tree
  fn debug_pattern_if_needed(&self, pattern_ret: &Result<Pattern>, lang: SgLang) {
    let Some(debug_query) = &self.debug_query else {
      return;
    };
    let colored = self.output.color.should_use_color();
    if !matches!(debug_query, DebugFormat::Pattern) {
      debug_query.debug_tree(&self.pattern, lang, colored);
    } else if let Ok(pattern) = pattern_ret {
      debug_query.debug_pattern(pattern, lang, colored);
    }
  }
}

// Every run will include Search or Replace
// Search or Replace by arguments `pattern` and `rewrite` passed from CLI
pub fn run_with_pattern(arg: RunArg, project: Result<ProjectConfig>) -> Result<()> {
  let proj = arg.output.inspect.project_trace();
  proj.print_project(&project)?;
  let context = arg.context.get();
  if let Some(json) = arg.output.json {
    let printer = JSONPrinter::stdout(json).context(context);
    return run_pattern_with_printer(arg, printer);
  }
  let printer = ColoredPrinter::stdout(arg.output.color)
    .heading(arg.heading)
    .context(context);
  let interactive = arg.output.needs_interactive();
  if interactive {
    let from_stdin = arg.input.stdin;
    let printer = InteractivePrinter::new(printer, arg.output.update_all, from_stdin)?;
    run_pattern_with_printer(arg, printer)
  } else {
    run_pattern_with_printer(arg, printer)
  }
}

fn run_pattern_with_printer(arg: RunArg, printer: impl Printer + 'static) -> Result<()> {
  let trace = arg.output.inspect.run_trace();
  if arg.input.stdin {
    RunWithSpecificLang::new(arg, trace)?.run_std_in(printer)
  } else if arg.lang.is_some() {
    RunWithSpecificLang::new(arg, trace)?.run_path(printer)
  } else {
    RunWithInferredLang { arg, trace }.run_path(printer)
  }
}

struct RunWithInferredLang {
  arg: RunArg,
  trace: RunTrace,
}
impl Worker for RunWithInferredLang {
  fn consume_items<P: Printer>(&self, items: Items<P::Processed>, mut printer: P) -> Result<()> {
    let printer = &mut printer;
    printer.before_print()?;
    for item in items {
      printer.process(item)?;
    }
    printer.after_print()?;
    self.trace.print()?;
    Ok(())
  }
}

impl PathWorker for RunWithInferredLang {
  fn build_walk(&self) -> Result<WalkParallel> {
    self.arg.input.walk()
  }
  fn get_trace(&self) -> &FileTrace {
    &self.trace.inner
  }

  fn produce_item<P: Printer>(
    &self,
    path: &Path,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>> {
    let Some(lang) = SgLang::from_path(path) else {
      return Ok(vec![]);
    };
    self.trace.print_file(path, lang)?;
    let matcher = self.arg.build_pattern(lang)?;
    // match sub region
    let sub_langs = lang.injectable_sg_langs().into_iter().flatten();
    let sub_matchers = sub_langs
      .filter_map(|l| {
        let maybe_pattern = self.arg.build_pattern(l);
        maybe_pattern.ok().map(|pattern| (l, pattern))
      })
      .collect::<Vec<_>>();

    let items = filter_file_pattern(path, lang, Some(&matcher), &sub_matchers)?;
    let mut ret = Vec::with_capacity(items.len());
    let rewrite_str = self.arg.rewrite.as_ref();

    for unit in items {
      let i_lang = unit.grep.lang();
      let rewrite = rewrite_str
        .map(|s| Fixer::from_str(s, i_lang))
        .transpose()
        .unwrap_or_else(|e| {
          eprintln!("⚠️  Rewriting was skipped because pattern fails to parse. Error detail:");
          eprintln!("╰▻ {e}");
          None
        });
      let Some(processed) = match_one_file(processor, &unit, &rewrite)? else {
        continue;
      };
      ret.push(processed);
    }
    Ok(ret)
  }
}

struct RunWithSpecificLang {
  arg: RunArg,
  pattern: Pattern,
  rewrite: Option<Fixer>,
  stats: RunTrace,
}

impl RunWithSpecificLang {
  fn new(arg: RunArg, stats: RunTrace) -> Result<Self> {
    let lang = arg.lang.ok_or(anyhow::anyhow!(EC::LanguageNotSpecified))?;
    // do not unwrap result here
    let pattern_ret = arg.build_pattern(lang);
    arg.debug_pattern_if_needed(&pattern_ret, lang);
    let rewrite = if let Some(s) = &arg.rewrite {
      Some(Fixer::from_str(s, &lang).context(EC::ParsePattern)?)
    } else {
      None
    };
    Ok(Self {
      arg,
      pattern: pattern_ret?,
      rewrite,
      stats,
    })
  }
}

impl Worker for RunWithSpecificLang {
  fn consume_items<P: Printer>(&self, items: Items<P::Processed>, mut printer: P) -> Result<()> {
    printer.before_print()?;
    let mut has_matches = false;
    for item in items {
      printer.process(item)?;
      has_matches = true;
    }
    printer.after_print()?;
    self.stats.print()?;
    if !has_matches && self.pattern.has_error() {
      Err(anyhow::anyhow!(EC::PatternHasError))
    } else {
      Ok(())
    }
  }
}

impl PathWorker for RunWithSpecificLang {
  fn build_walk(&self) -> Result<WalkParallel> {
    let lang = self.arg.lang.expect("must present");
    self.arg.input.walk_lang(lang)
  }
  fn get_trace(&self) -> &FileTrace {
    &self.stats.inner
  }
  fn produce_item<P: Printer>(
    &self,
    path: &Path,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>> {
    let arg = &self.arg;
    let pattern = &self.pattern;
    let lang = arg.lang.expect("must present");
    let Some(path_lang) = SgLang::from_path(path) else {
      return Ok(vec![]);
    };
    self.stats.print_file(path, path_lang)?;
    let (root_matcher, sub_matchers) = if path_lang == lang {
      (Some(pattern), vec![])
    } else {
      (None, vec![(lang, pattern.clone())])
    };
    let filtered = filter_file_pattern(path, path_lang, root_matcher, &sub_matchers)?;
    let mut ret = Vec::with_capacity(filtered.len());
    for unit in filtered {
      let Some(processed) = match_one_file(processor, &unit, &self.rewrite)? else {
        continue;
      };
      ret.push(processed);
    }
    Ok(ret)
  }
}

impl StdInWorker for RunWithSpecificLang {
  fn parse_stdin<P: Printer>(
    &self,
    src: String,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>> {
    let lang = self.arg.lang.expect("must present");
    let grep = lang.ast_grep(src);
    let root = grep.root();
    let mut matches = root.find_all(&self.pattern).peekable();
    if matches.peek().is_none() {
      return Ok(vec![]);
    }
    let rewrite = &self.rewrite;
    let path = Path::new("STDIN");
    let processed = if let Some(rewrite) = rewrite {
      let diffs = matches.map(|m| Diff::generate(m, &self.pattern, rewrite));
      processor.print_diffs(diffs.collect(), path)?
    } else {
      processor.print_matches(matches.collect(), path)?
    };
    Ok(vec![processed])
  }
}
fn match_one_file<T, P: PrintProcessor<T>>(
  processor: &P,
  match_unit: &MatchUnit<impl Matcher>,
  rewrite: &Option<Fixer>,
) -> Result<Option<T>> {
  let MatchUnit {
    path,
    grep,
    matcher,
  } = match_unit;

  let root = grep.root();
  let mut matches = root.find_all(matcher).peekable();
  if matches.peek().is_none() {
    return Ok(None);
  }
  let ret = if let Some(rewrite) = rewrite {
    let diffs = matches.map(|m| Diff::generate(m, matcher, rewrite));
    processor.print_diffs(diffs.collect(), path)?
  } else {
    processor.print_matches(matches.collect(), path)?
  };
  Ok(Some(ret))
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::print::ColorArg;
  use ast_grep_language::SupportLang;
  use std::path::PathBuf;

  fn default_run_arg() -> RunArg {
    RunArg {
      pattern: String::new(),
      selector: None,
      rewrite: None,
      lang: None,
      heading: Heading::Never,
      debug_query: None,
      strictness: None,
      input: InputArgs {
        no_ignore: vec![],
        stdin: false,
        follow: false,
        paths: vec![PathBuf::from(".")],
        globs: vec![],
        threads: 0,
      },
      output: OutputArgs {
        color: ColorArg::Never,
        interactive: false,
        json: None,
        update_all: false,
        inspect: Default::default(),
      },
      context: ContextArgs {
        before: 0,
        after: 0,
        context: 0,
      },
    }
  }

  #[test]
  fn test_run_with_pattern() {
    let arg = RunArg {
      pattern: "console.log".to_string(),
      ..default_run_arg()
    };
    let proj = Err(anyhow::anyhow!("no project"));
    assert!(run_with_pattern(arg, proj).is_ok())
  }

  #[test]
  fn test_run_with_strictness() {
    let arg = RunArg {
      pattern: "console.log".to_string(),
      strictness: Some(Strictness(MatchStrictness::Ast)),
      ..default_run_arg()
    };
    let proj = Err(anyhow::anyhow!("no project"));
    assert!(run_with_pattern(arg, proj).is_ok())
  }

  #[test]
  fn test_run_with_specific_lang() {
    let arg = RunArg {
      pattern: "Some(result)".to_string(),
      lang: Some(SupportLang::Rust.into()),
      ..default_run_arg()
    };
    let proj = Err(anyhow::anyhow!("no project"));
    assert!(run_with_pattern(arg, proj).is_ok())
  }
}



================================================
FILE: crates/cli/src/scan.rs
================================================
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use ast_grep_config::{from_yaml_string, CombinedScan, RuleCollection, RuleConfig, Severity};
use ast_grep_core::{tree_sitter::StrDoc, NodeMatch};
use ast_grep_language::SupportLang;
use clap::Args;
use ignore::WalkParallel;

use crate::config::{read_rule_file, with_rule_stats, ProjectConfig};
use crate::lang::SgLang;
use crate::print::{
  CloudPrinter, ColoredPrinter, Diff, InteractivePrinter, JSONPrinter, Platform, PrintProcessor,
  Printer, ReportStyle, SimpleFile,
};
use crate::utils::ErrorContext as EC;
use crate::utils::RuleOverwrite;
use crate::utils::{filter_file_rule, ContextArgs, InputArgs, OutputArgs, OverwriteArgs};
use crate::utils::{FileTrace, ScanTrace};
use crate::utils::{Items, PathWorker, StdInWorker, Worker};

use std::collections::HashSet;
use std::sync::atomic::{AtomicUsize, Ordering};

#[derive(Args)]
pub struct ScanArg {
  /// Scan the codebase with the single rule located at the path RULE_FILE.
  ///
  /// It is useful to run single rule without project setup or sgconfig.yml.
  #[clap(short, long, value_name = "RULE_FILE")]
  rule: Option<PathBuf>,

  /// Scan the codebase with a rule defined by the provided RULE_TEXT.
  ///
  /// Use this argument if you want to test a rule without creating a YAML file on disk.
  /// You can run multiple rules by separating them with `---` in the RULE_TEXT.
  /// --inline-rules is incompatible with --rule.
  #[clap(long, conflicts_with = "rule", value_name = "RULE_TEXT")]
  inline_rules: Option<String>,

  /// Output warning/error messages in GitHub Action format.
  ///
  /// Currently, only GitHub is supported.
  #[clap(long, conflicts_with = "json", conflicts_with = "interactive")]
  format: Option<Platform>,

  #[clap(long, default_value = "rich", conflicts_with = "json")]
  report_style: ReportStyle,

  /// Include rule metadata in the json output.
  ///
  /// This flags requires --json output. Default is false.
  #[clap(long, requires = "json")]
  include_metadata: bool,

  /// severity related options
  #[clap(flatten)]
  overwrite: OverwriteArgs,

  /// input related options
  #[clap(flatten)]
  input: InputArgs,
  /// output related options
  #[clap(flatten)]
  output: OutputArgs,
  /// context related options
  #[clap(flatten)]
  context: ContextArgs,
}

impl ScanArg {
  // whether the scan includes all rules available in the project
  fn include_all_rules(&self) -> bool {
    self.overwrite.include_all_rules() && self.rule.is_none() && self.inline_rules.is_none()
  }
}

pub fn run_with_config(arg: ScanArg, project: Result<ProjectConfig>) -> Result<()> {
  let project_trace = arg.output.inspect.project_trace();
  project_trace.print_project(&project)?;
  let context = arg.context.get();
  if let Some(_format) = &arg.format {
    let printer = CloudPrinter::stdout();
    return run_scan(arg, printer, project);
  }
  if let Some(json) = arg.output.json {
    let printer = JSONPrinter::stdout(json).include_metadata(arg.include_metadata);
    return run_scan(arg, printer, project);
  }
  let printer = ColoredPrinter::stdout(arg.output.color)
    .style(arg.report_style)
    .context(context);
  let interactive = arg.output.needs_interactive();
  if interactive {
    let from_stdin = arg.input.stdin;
    let printer = InteractivePrinter::new(printer, arg.output.update_all, from_stdin)?;
    run_scan(arg, printer, project)
  } else {
    run_scan(arg, printer, project)
  }
}

fn run_scan<P: Printer + 'static>(
  arg: ScanArg,
  printer: P,
  project: Result<ProjectConfig>,
) -> Result<()> {
  if arg.input.stdin {
    let worker = ScanStdin::try_new(arg)?;
    // TODO: report a soft error if rules have different languages
    worker.run_std_in(printer)
  } else {
    let worker = ScanWithConfig::try_new(arg, project)?;
    worker.run_path(printer)
  }
}

struct ScanWithConfig {
  arg: ScanArg,
  configs: RuleCollection<SgLang>,
  unused_suppression_rule: RuleConfig<SgLang>,
  trace: ScanTrace,
  proj_dir: PathBuf,
  // TODO: remove this
  error_count: AtomicUsize,
}
impl ScanWithConfig {
  fn try_new(arg: ScanArg, project: Result<ProjectConfig>) -> Result<Self> {
    let overwrite = RuleOverwrite::new(&arg.overwrite)?;
    let unused_suppression_rule = unused_suppression_rule_config(&arg, &overwrite);
    let mut proj_dir = PathBuf::from(".");
    let (configs, rule_trace) = if let Some(path) = &arg.rule {
      let rules = read_rule_file(path, None)?;
      proj_dir = path.parent().unwrap_or(Path::new(".")).to_path_buf();
      with_rule_stats(rules)?
    } else if let Some(text) = &arg.inline_rules {
      let rules = from_yaml_string(text, &Default::default())
        .with_context(|| EC::ParseRule("INLINE_RULES".into()))?;
      with_rule_stats(rules)?
    } else {
      // NOTE: only query project here since -r does not need project
      let project_config = project?;
      proj_dir = project_config.project_dir.clone();
      project_config.find_rules(overwrite)?
    };
    let trace = arg.output.inspect.scan_trace(rule_trace);
    trace.print_rules(&configs)?;
    let absolute_proj_dir = proj_dir
      .canonicalize()
      .or_else(|_| std::env::current_dir())?;
    Ok(Self {
      arg,
      configs,
      unused_suppression_rule,
      trace,
      proj_dir: absolute_proj_dir,
      error_count: AtomicUsize::new(0),
    })
  }
}
impl Worker for ScanWithConfig {
  fn consume_items<P: Printer>(&self, items: Items<P::Processed>, mut printer: P) -> Result<()> {
    printer.before_print()?;
    for item in items {
      printer.process(item)?;
    }
    printer.after_print()?;
    self.trace.print()?;
    let error_count = self.error_count.load(Ordering::Acquire);
    if error_count > 0 {
      Err(anyhow::anyhow!(EC::DiagnosticError(error_count)))
    } else {
      Ok(())
    }
  }
}

// we should only suggest unused suppression if scan includes all rules
// otherwise, keep silent about unused suppressions because they may used by other rules
// this is a "smart" heuristic but user always can override it
fn default_unused_suppression_rule_severity(arg: &ScanArg) -> Severity {
  if arg.include_all_rules() {
    Severity::Hint
  } else {
    Severity::Off
  }
}

fn unused_suppression_rule_config(arg: &ScanArg, overwrite: &RuleOverwrite) -> RuleConfig<SgLang> {
  let severity = overwrite
    .find("unused-suppression")
    .severity
    .unwrap_or_else(|| default_unused_suppression_rule_severity(arg));
  CombinedScan::unused_config(severity, SupportLang::Rust.into())
}

impl PathWorker for ScanWithConfig {
  fn get_trace(&self) -> &FileTrace {
    &self.trace.inner.file_trace
  }
  fn build_walk(&self) -> Result<WalkParallel> {
    let mut langs = HashSet::new();
    self.configs.for_each_rule(|rule| {
      langs.insert(rule.language);
    });
    self.arg.input.walk_langs(langs.into_iter())
  }
  fn produce_item<P: Printer>(
    &self,
    path: &Path,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>> {
    let items = filter_file_rule(path, &self.configs, &self.trace)?;
    let mut error_count = 0usize;
    let mut ret = vec![];
    for grep in items {
      let file_content = grep.source();
      // use path relative to project director
      let abs_path = path.canonicalize()?;
      let normalized_path = abs_path.strip_prefix(&self.proj_dir).unwrap_or(path);
      let rules = self
        .configs
        .get_rule_from_lang(normalized_path, *grep.lang());
      let mut combined = CombinedScan::new(rules);
      combined.set_unused_suppression_rule(&self.unused_suppression_rule);
      let interactive = self.arg.output.needs_interactive();
      // exclude_fix rule because we already have diff inspection before
      let scanned = combined.scan(&grep, /* separate_fix*/ interactive);
      if interactive {
        let diffs = scanned.diffs;
        let processed = match_rule_diff_on_file(path, diffs, processor)?;
        ret.push(processed);
      }
      for (rule, matches) in scanned.matches {
        if matches!(rule.severity, Severity::Error) {
          error_count = error_count.saturating_add(matches.len());
        }
        let processed = match_rule_on_file(path, matches, rule, file_content, processor)?;
        ret.push(processed);
      }
    }
    self.error_count.fetch_add(error_count, Ordering::AcqRel);
    Ok(ret)
  }
}

struct ScanStdin {
  rules: Vec<RuleConfig<SgLang>>,
  // TODO: remove this
  error_count: AtomicUsize,
}
impl ScanStdin {
  fn try_new(arg: ScanArg) -> Result<Self> {
    let rules = if let Some(path) = &arg.rule {
      read_rule_file(path, None)?
    } else if let Some(text) = &arg.inline_rules {
      from_yaml_string(text, &Default::default())
        .with_context(|| EC::ParseRule("INLINE_RULES".into()))?
    } else {
      return Err(anyhow::anyhow!(EC::RuleNotSpecified));
    };
    Ok(Self {
      rules,
      error_count: AtomicUsize::new(0),
    })
  }
}

impl Worker for ScanStdin {
  fn consume_items<P: Printer>(&self, items: Items<P::Processed>, mut printer: P) -> Result<()> {
    printer.before_print()?;
    for item in items {
      printer.process(item)?;
    }
    printer.after_print()?;
    let error_count = self.error_count.load(Ordering::Acquire);
    if error_count > 0 {
      Err(anyhow::anyhow!(EC::DiagnosticError(error_count)))
    } else {
      Ok(())
    }
  }
}

impl StdInWorker for ScanStdin {
  fn parse_stdin<P: Printer>(
    &self,
    src: String,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>> {
    use ast_grep_core::tree_sitter::LanguageExt;
    let lang = self.rules[0].language;
    let combined = CombinedScan::new(self.rules.iter().collect());
    let grep = lang.ast_grep(src);
    let path = Path::new("STDIN");
    let file_content = grep.source();
    // do not separate_fix rule in stdin mode
    let scanned = combined.scan(&grep, false);
    let mut error_count = 0usize;
    let mut ret = vec![];
    for (rule, matches) in scanned.matches {
      if matches!(rule.severity, Severity::Error) {
        error_count = error_count.saturating_add(matches.len());
      }
      let processed = match_rule_on_file(path, matches, rule, file_content, processor)?;
      ret.push(processed);
    }
    self.error_count.fetch_add(error_count, Ordering::AcqRel);
    Ok(ret)
  }
}
fn match_rule_diff_on_file<T>(
  path: &Path,
  matches: Vec<(&RuleConfig<SgLang>, NodeMatch<StrDoc<SgLang>>)>,
  processor: &impl PrintProcessor<T>,
) -> Result<T> {
  let diffs = matches
    .into_iter()
    .filter_map(|(rule, m)| {
      let fixers = &rule.matcher.fixer;
      let diff = Diff::multiple(m, &rule.matcher, fixers)?;
      Some((diff, rule))
    })
    .collect();
  let processed = processor.print_rule_diffs(diffs, path)?;
  Ok(processed)
}

fn match_rule_on_file<T>(
  path: &Path,
  matches: Vec<NodeMatch<StrDoc<SgLang>>>,
  rule: &RuleConfig<SgLang>,
  file_content: &str,
  processor: &impl PrintProcessor<T>,
) -> Result<T> {
  let file = SimpleFile::new(path.to_string_lossy(), file_content);
  let processed = if let Some(fixer) = &rule.matcher.fixer.first() {
    let diffs = matches
      .into_iter()
      .map(|m| (Diff::generate(m, &rule.matcher, fixer), rule))
      .collect();
    processor.print_rule_diffs(diffs, path)?
  } else {
    processor.print_rule(matches, file, rule)?
  };
  Ok(processed)
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::print::ColorArg;
  use std::fs::File;
  use std::io::Write;
  use tempfile::TempDir;

  const RULE: &str = r#"
id: test
message: Add your rule message here....
severity: error # error, warning, hint, info
language: Rust
rule:
  pattern: Some(123)
"#;

  // TODO: unify with verify::test
  pub fn create_test_files<'a>(
    names_and_contents: impl IntoIterator<Item = (&'a str, &'a str)>,
  ) -> TempDir {
    let dir = TempDir::new().unwrap();
    for (name, contents) in names_and_contents {
      let path = dir.path().join(name);
      let mut file = File::create(path.clone()).unwrap();
      file.write_all(contents.as_bytes()).unwrap();
      file.sync_all().unwrap();
    }
    dir
  }

  fn default_scan_arg() -> ScanArg {
    ScanArg {
      rule: None,
      inline_rules: None,
      report_style: ReportStyle::Rich,
      include_metadata: false,
      input: InputArgs {
        no_ignore: vec![],
        paths: vec![PathBuf::from(".")],
        stdin: false,
        follow: false,
        globs: vec![],
        threads: 0,
      },
      overwrite: OverwriteArgs {
        filter: None,
        error: None,
        warning: None,
        info: None,
        hint: None,
        off: None,
      },
      output: OutputArgs {
        interactive: false,
        json: None,
        update_all: false,
        color: ColorArg::Never,
        inspect: Default::default(),
      },
      context: ContextArgs {
        before: 0,
        after: 0,
        context: 0,
      },
      format: None,
    }
  }

  #[test]
  fn test_run_with_config() {
    let dir = create_test_files([("sgconfig.yml", "ruleDirs: [rules]")]);
    std::fs::create_dir_all(dir.path().join("rules")).unwrap();
    let mut file = File::create(dir.path().join("rules/test.yml")).unwrap();
    file.write_all(RULE.as_bytes()).unwrap();
    let mut file = File::create(dir.path().join("test.rs")).unwrap();
    file
      .write_all("fn test() { Some(123) }".as_bytes())
      .unwrap();
    file.sync_all().unwrap();
    let project_config = ProjectConfig::setup(Some(dir.path().join("sgconfig.yml"))).unwrap();
    let arg = default_scan_arg();
    assert!(run_with_config(arg, project_config).is_ok());
  }

  #[test]
  fn test_scan_with_inline_rules() {
    let inline_rules = "{id: test, language: ts, rule: {pattern: readFileSync}}".to_string();
    let arg = ScanArg {
      inline_rules: Some(inline_rules),
      ..default_scan_arg()
    };
    assert!(run_with_config(arg, Err(anyhow::anyhow!("not found"))).is_ok());
  }

  #[test]
  fn test_scan_with_inline_rules_diff() {
    let inline_rules =
      "{id: test, language: ts, rule: {pattern: readFileSync}, fix: 'nnn'}".to_string();
    let arg = ScanArg {
      inline_rules: Some(inline_rules),
      ..default_scan_arg()
    };
    assert!(run_with_config(arg, Err(anyhow::anyhow!("not found"))).is_ok());
  }

  // baseline test for coverage
  #[test]
  fn test_scan_with_inline_rules_error() {
    let inline_rules = "nonsense".to_string();
    let arg = ScanArg {
      inline_rules: Some(inline_rules),
      ..default_scan_arg()
    };
    let err = run_with_config(arg, Err(anyhow::anyhow!("not found"))).expect_err("should error");
    assert!(err.is::<EC>());
    assert_eq!(err.to_string(), "Cannot parse rule INLINE_RULES");
  }
}



================================================
FILE: crates/cli/src/verify.rs
================================================
mod case_result;
mod find_file;
mod reporter;
mod snapshot;
mod test_case;

use crate::config::ProjectConfig;
use crate::lang::SgLang;
use crate::utils::{ErrorContext, RuleOverwrite};
use anyhow::{anyhow, Result};
use ast_grep_config::RuleCollection;
use clap::Args;
use regex::Regex;
use serde_yaml::to_string;

use std::collections::HashMap;
use std::io::Write;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::thread;

use case_result::{CaseResult, CaseStatus};
use find_file::TestHarness;
use reporter::{DefaultReporter, InteractiveReporter, Reporter};
use snapshot::{SnapshotAction, SnapshotCollection, TestSnapshots};
use test_case::TestCase;

fn parallel_collect<'a, T, R, F>(cases: &'a [T], filter_mapper: F) -> Vec<R>
where
  T: Sync,
  R: Send,
  F: FnMut(&'a T) -> Option<R> + Send + Copy,
{
  let threads = std::thread::available_parallelism()
    .map_or(1, |n| n.get())
    .min(12);
  let chunk_size = (cases.len() + threads) / threads;
  thread::scope(|s| {
    cases
      .chunks(chunk_size)
      .map(|chunk| {
        s.spawn(move || {
          chunk
            .iter()
            .filter_map(filter_mapper) // apply per case logic
            .collect::<Vec<_>>() // must collect here eagerly to consume iter in child threads
        })
      })
      .collect::<Vec<_>>() // must collect here eagerly to enable multi thread
      .into_iter()
      .flat_map(|sc| sc.join().unwrap())
      .collect()
  })
}

fn run_test_rule_impl<R: Reporter + Send>(
  arg: TestArg,
  reporter: R,
  project: ProjectConfig,
) -> Result<()> {
  let filter = arg.filter.as_ref();
  let overwrite = RuleOverwrite::new_for_verify(filter, arg.include_off);
  let collections = &project.find_rules(overwrite)?.0;
  let TestHarness {
    test_cases,
    snapshots,
    path_map,
  } = if let Some(test_dirname) = arg.test_dir {
    let snapshot_dirname = arg.snapshot_dir.as_deref();
    TestHarness::from_dir(&test_dirname, snapshot_dirname, filter)?
  } else {
    TestHarness::from_config(project, filter)?
  };
  let snapshots = (!arg.skip_snapshot_tests).then_some(snapshots);
  let reporter = &Arc::new(Mutex::new(reporter));
  {
    reporter.lock().unwrap().before_report(&test_cases)?;
  }

  let check_one_case = |case| {
    let result = verify_test_case_simple(case, collections, snapshots.as_ref());
    if result.is_none() {
      let mut reporter = reporter.lock().unwrap();
      let output = reporter.get_output();
      writeln!(output, "Configuration not found! {}", case.id).unwrap();
    }
    result
  };
  let mut results = parallel_collect(&test_cases, check_one_case);
  let mut reporter = reporter.lock().unwrap();

  reporter.report_failed_cases(&mut results)?;
  let action = reporter.collect_snapshot_action();
  apply_snapshot_action(action, &results, snapshots, path_map)?;
  reporter.report_summaries(&results)?;
  let test_result = reporter.after_report(&results)?;
  match test_result {
    reporter::TestResult::Success { message } => {
      writeln!(reporter.get_output(), "{message}")?;
      Ok(())
    }
    reporter::TestResult::RuleFail { message } => {
      let error_context = ErrorContext::TestFail(message);
      Err(anyhow!(error_context))
    }
    reporter::TestResult::MismatchSnapshotOnly { message } => {
      let error_context = ErrorContext::TestSnapshotMismatch(message);
      Err(anyhow!(error_context))
    }
  }
}

fn apply_snapshot_action(
  action: SnapshotAction,
  results: &[CaseResult],
  snapshots: Option<SnapshotCollection>,
  path_map: HashMap<String, PathBuf>,
) -> Result<()> {
  let Some(snapshots) = snapshots else {
    return Ok(());
  };
  let Some(merged) = action.update_snapshot_collection(snapshots, results) else {
    return Ok(());
  };
  write_merged_to_disk(merged, path_map)
}

fn write_merged_to_disk(
  merged: SnapshotCollection,
  path_map: HashMap<String, PathBuf>,
) -> Result<()> {
  for (id, snaps) in merged {
    let path = &path_map[&id];
    if !path.exists() {
      std::fs::create_dir(path)?;
    }
    let file = path.join(format!("{id}-snapshot.yml"));
    std::fs::write(file, to_string(&snaps)?)?;
  }
  Ok(())
}

fn verify_test_case_simple<'a>(
  test_case: &'a TestCase,
  rules: &RuleCollection<SgLang>,
  snapshots: Option<&SnapshotCollection>,
) -> Option<CaseResult<'a>> {
  let rule_config = rules.get_rule(&test_case.id)?;
  let test_case = if let Some(snapshots) = snapshots {
    let snaps = snapshots.get(&test_case.id);
    test_case.verify_with_snapshot(rule_config, snaps)
  } else {
    test_case.verify_rule(rule_config)
  };
  Some(test_case)
}

// for result in summary {
//   match result {
//     CaseStatus::Validated => print!("✅"),
//     CaseStatus::Reported => print!("⛳"),
//     CaseStatus::Wrong(_) => print!("❌"),
//     CaseStatus::Missing(_) => print!("❌"),
//     CaseStatus::Noisy(_) => print!("🔊"),
//   }
// }

#[derive(Args)]
pub struct TestArg {
  /// the directories to search test YAML files
  #[clap(short, long)]
  test_dir: Option<PathBuf>,
  /// Specify the directory name storing snapshots. Default to __snapshots__.
  #[clap(long)]
  snapshot_dir: Option<PathBuf>,
  /// Only check if the test code is valid, without checking rule output.
  /// Turn it on when you want to ignore the output of rules.
  /// Conflicts with --update-all.
  #[clap(long, conflicts_with = "update_all")]
  skip_snapshot_tests: bool,
  /// Update the content of all snapshots that have changed in test.
  /// Conflicts with --skip-snapshot-tests.
  #[clap(short = 'U', long)]
  update_all: bool,
  /// Start an interactive review to update snapshots selectively
  #[clap(short, long)]
  interactive: bool,
  /// Only run rule test cases that matches REGEX.
  #[clap(short, long, value_name = "REGEX")]
  filter: Option<Regex>,
  /// Include `severity:off` rules in test
  ///
  /// ast-grep will not run rules with `severity: off` by default.
  /// This option will include those rules in the test.
  #[clap(long)]
  include_off: bool,
}

pub fn run_test_rule(arg: TestArg, project: Result<ProjectConfig>) -> Result<()> {
  let project = project?;
  if arg.interactive {
    let reporter = InteractiveReporter {
      output: std::io::stdout(),
      should_accept_all: false,
    };
    run_test_rule_impl(arg, reporter, project)
  } else {
    let reporter = DefaultReporter {
      output: std::io::stdout(),
      update_all: arg.update_all,
    };
    run_test_rule_impl(arg, reporter, project)
  }
}

#[cfg(test)]
pub mod test {
  use super::*;
  use ast_grep_config::{from_str, GlobalRules, RuleConfig};

  pub const TEST_RULE: &str = "test-rule";

  fn get_rule_text(rule: &str) -> String {
    format!(
      "
id: {TEST_RULE}
message: test
severity: hint
language: TypeScript
rule:
  {rule}
"
    )
  }

  pub fn get_rule_config(rule: &str) -> RuleConfig<SgLang> {
    let globals = GlobalRules::default();
    let inner = from_str(&get_rule_text(rule)).unwrap();
    RuleConfig::try_from(inner, &globals).unwrap()
  }
  fn always_report_rule() -> RuleCollection<SgLang> {
    // empty all should mean always
    let rule = get_rule_config("all: [kind: number]");
    RuleCollection::try_new(vec![rule]).expect("RuleCollection must be valid")
  }
  fn never_report_rule() -> RuleCollection<SgLang> {
    // empty any should mean never
    let rule = get_rule_config("any: [kind: string]");
    RuleCollection::try_new(vec![rule]).expect("RuleCollection must be valid")
  }

  fn valid_case() -> TestCase {
    TestCase {
      id: TEST_RULE.into(),
      valid: vec!["123".into()],
      invalid: vec![],
    }
  }

  fn invalid_case() -> TestCase {
    TestCase {
      id: TEST_RULE.into(),
      valid: vec![],
      invalid: vec!["123".into()],
    }
  }

  fn test_case_result(status: CaseStatus) -> Option<CaseResult> {
    Some(CaseResult {
      id: TEST_RULE,
      cases: vec![status],
    })
  }

  #[test]
  fn test_validated() {
    let rule = never_report_rule();
    let case = valid_case();
    let ret = verify_test_case_simple(&case, &rule, None);
    assert_eq!(ret, test_case_result(CaseStatus::Validated),);
  }

  #[test]
  fn test_reported() {
    let case = invalid_case();
    let rule = always_report_rule();
    let ret = verify_test_case_simple(&case, &rule, None);
    assert_eq!(ret, test_case_result(CaseStatus::Reported),);
  }
  #[test]
  fn test_noisy() {
    let case = valid_case();
    let rule = always_report_rule();
    let ret = verify_test_case_simple(&case, &rule, None);
    assert_eq!(ret, test_case_result(CaseStatus::Noisy("123")),);
  }
  #[test]
  fn test_missing() {
    let case = invalid_case();
    let rule = never_report_rule();
    let ret = verify_test_case_simple(&case, &rule, None);
    assert_eq!(ret, test_case_result(CaseStatus::Missing("123")),);
  }

  #[test]
  fn test_no_such_rule() {
    let case = TestCase {
      id: "no-such-rule".into(),
      valid: vec![],
      invalid: vec![],
    };
    let rule = never_report_rule();
    let ret = verify_test_case_simple(&case, &rule, None);
    assert!(ret.is_none());
  }

  #[test]
  fn test_run_verify_error() {
    let arg = TestArg {
      interactive: false,
      skip_snapshot_tests: true,
      snapshot_dir: None,
      test_dir: None,
      update_all: false,
      filter: None,
      include_off: false,
    };
    assert!(run_test_rule(arg, Err(anyhow!("error"))).is_err());
  }
  const TRANSFORM_TEXT: &str = "
transform:
  B:
    substring:
      source: $A
      startChar: 1
      endChar: -1
fix: 'log($B)'";
  #[test]
  fn test_verify_transform() {
    let globals = GlobalRules::default();
    let inner = from_str(&get_rule_text(&format!(
      "pattern: console.log($A)\n{TRANSFORM_TEXT}"
    )))
    .unwrap();
    let rule = RuleConfig::try_from(inner, &globals).unwrap();
    let rule = RuleCollection::try_new(vec![rule]).expect("RuleCollection must be valid");
    let case = TestCase {
      id: TEST_RULE.into(),
      valid: vec![],
      invalid: vec!["console.log(123)".to_string()],
    };
    let snapshots = SnapshotCollection::new();
    let mut ret = verify_test_case_simple(&case, &rule, Some(&snapshots)).unwrap();
    let case = ret.cases.pop().unwrap();
    match case {
      CaseStatus::Wrong { actual, .. } => {
        assert_eq!(actual.fixed.unwrap(), "log(2)");
      }
      _ => {
        panic!("wrong case status");
      }
    }
  }
}



================================================
FILE: crates/cli/src/lang/injection.rs
================================================
use super::SgLang;
use crate::utils::ErrorContext as EC;
use ast_grep_config::{DeserializeEnv, RuleCore, SerializableRuleCore};
use ast_grep_core::{
  tree_sitter::{LanguageExt, StrDoc, TSRange},
  Doc, Node,
};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

use std::collections::{HashMap, HashSet};
use std::ptr::{addr_of, addr_of_mut};
use std::str::FromStr;

// NB, you should not use SgLang in the (de_serialize interface
// since Injected is used before lang registration in sgconfig.yml
#[derive(Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum Injected {
  Static(String),
  Dynamic(Vec<String>),
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SerializableInjection {
  #[serde(flatten)]
  core: SerializableRuleCore,
  /// The host language, e.g. html, contains other languages
  host_language: String,
  /// Injected language according to the rule
  /// It accepts either a string like js for single static language.
  /// or an array of string like [js, ts] for dynamic language detection.
  injected: Injected,
}

struct Injection {
  host: SgLang,
  rules: Vec<(RuleCore, Option<String>)>,
  injectable: HashSet<String>,
}

impl Injection {
  fn new(lang: SgLang) -> Self {
    Self {
      host: lang,
      rules: vec![],
      injectable: Default::default(),
    }
  }
}

pub unsafe fn register_injetables(injections: Vec<SerializableInjection>) -> Result<()> {
  let mut injectable = HashMap::new();
  for injection in injections {
    register_injetable(injection, &mut injectable)?;
  }
  merge_default_injecatable(&mut injectable);
  *addr_of_mut!(LANG_INJECTIONS) = injectable.into_values().collect();
  let injects = unsafe { &*addr_of!(LANG_INJECTIONS) as &'static Vec<Injection> };
  *addr_of_mut!(INJECTABLE_LANGS) = injects
    .iter()
    .map(|inj| {
      (
        inj.host,
        inj.injectable.iter().map(|s| s.as_str()).collect(),
      )
    })
    .collect();
  Ok(())
}

fn merge_default_injecatable(ret: &mut HashMap<SgLang, Injection>) {
  for (lang, injection) in ret {
    let langs = match lang {
      SgLang::Builtin(b) => b.injectable_languages(),
      SgLang::Custom(c) => c.injectable_languages(),
    };
    let Some(langs) = langs else {
      continue;
    };
    injection
      .injectable
      .extend(langs.iter().map(|s| s.to_string()));
  }
}

fn register_injetable(
  injection: SerializableInjection,
  injectable: &mut HashMap<SgLang, Injection>,
) -> Result<()> {
  let lang = SgLang::from_str(&injection.host_language)?;
  let env = DeserializeEnv::new(lang);
  let rule = injection.core.get_matcher(env).context(EC::LangInjection)?;
  let default_lang = match &injection.injected {
    Injected::Static(s) => Some(s.clone()),
    Injected::Dynamic(_) => None,
  };
  let entry = injectable
    .entry(lang)
    .or_insert_with(|| Injection::new(lang));
  match injection.injected {
    Injected::Static(s) => {
      entry.injectable.insert(s);
    }
    Injected::Dynamic(v) => entry.injectable.extend(v),
  }
  entry.rules.push((rule, default_lang));
  Ok(())
}

static mut LANG_INJECTIONS: Vec<Injection> = vec![];
static mut INJECTABLE_LANGS: Vec<(SgLang, Vec<&'static str>)> = vec![];

pub fn injectable_languages(lang: SgLang) -> Option<&'static [&'static str]> {
  // NB: custom injection and builtin injections are resolved in INJECTABLE_LANGS
  let injections =
    unsafe { &*addr_of!(INJECTABLE_LANGS) as &'static Vec<(SgLang, Vec<&'static str>)> };
  let Some(injection) = injections.iter().find(|i| i.0 == lang) else {
    return match lang {
      SgLang::Builtin(b) => b.injectable_languages(),
      SgLang::Custom(c) => c.injectable_languages(),
    };
  };
  Some(&injection.1)
}

pub fn extract_injections<L: LanguageExt>(
  lang: &SgLang,
  root: Node<StrDoc<L>>,
) -> HashMap<String, Vec<TSRange>> {
  let mut ret = match lang {
    SgLang::Custom(c) => c.extract_injections(root.clone()),
    SgLang::Builtin(b) => b.extract_injections(root.clone()),
  };
  let injections = unsafe { &*addr_of!(LANG_INJECTIONS) };
  extract_custom_inject(lang, injections, root, &mut ret);
  ret
}

fn extract_custom_inject<L: LanguageExt>(
  lang: &SgLang,
  injections: &[Injection],
  root: Node<StrDoc<L>>,
  ret: &mut HashMap<String, Vec<TSRange>>,
) {
  let Some(rules) = injections.iter().find(|n| n.host == *lang) else {
    return;
  };
  for (rule, default_lang) in &rules.rules {
    for m in root.find_all(rule) {
      let env = m.get_env();
      let Some(region) = env.get_match("CONTENT") else {
        continue;
      };
      let Some(lang) = env
        .get_match("LANG")
        .map(|n| n.text().to_string())
        .or_else(|| default_lang.clone())
      else {
        continue;
      };
      let range = node_to_range(region);
      ret.entry(lang).or_default().push(range);
    }
  }
}

fn node_to_range<D: Doc>(node: &Node<D>) -> TSRange {
  let r = node.range();
  let start = node.start_pos();
  let sp = start.byte_point();
  let sp = tree_sitter::Point::new(sp.0, sp.1);
  let end = node.end_pos();
  let ep = end.byte_point();
  let ep = tree_sitter::Point::new(ep.0, ep.1);
  TSRange {
    start_byte: r.start,
    end_byte: r.end,
    start_point: sp,
    end_point: ep,
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_config::from_str;
  use ast_grep_language::SupportLang;
  const DYNAMIC: &str = "
hostLanguage: js
rule:
  pattern: styled.$LANG`$CONTENT`
injected: [css]";
  const STATIC: &str = "
hostLanguage: js
rule:
  pattern: styled`$CONTENT`
injected: css";
  #[test]
  fn test_deserialize() {
    let inj: SerializableInjection = from_str(STATIC).expect("should ok");
    assert!(matches!(inj.injected, Injected::Static(_)));
    let inj: SerializableInjection = from_str(DYNAMIC).expect("should ok");
    assert!(matches!(inj.injected, Injected::Dynamic(_)));
  }

  const BAD: &str = "
hostLanguage: HTML
rule:
  kind: not_exist
injected: [js, ts, tsx]";

  #[test]
  fn test_bad_inject() {
    let mut map = HashMap::new();
    let inj: SerializableInjection = from_str(BAD).expect("should ok");
    let ret = register_injetable(inj, &mut map);
    assert!(ret.is_err());
    let ec = ret.unwrap_err().downcast::<EC>().expect("should ok");
    assert!(matches!(ec, EC::LangInjection));
  }

  #[test]
  fn test_good_injection() {
    let mut map = HashMap::new();
    let inj: SerializableInjection = from_str(STATIC).expect("should ok");
    let ret = register_injetable(inj, &mut map);
    assert!(ret.is_ok());
    let inj: SerializableInjection = from_str(DYNAMIC).expect("should ok");
    let ret = register_injetable(inj, &mut map);
    assert!(ret.is_ok());
    assert_eq!(map.len(), 1);
    let injections: Vec<_> = map.into_values().collect();
    let mut ret = HashMap::new();
    let lang = SgLang::from(SupportLang::JavaScript);
    let sg = lang.ast_grep("const a = styled`.btn { margin: 0; }`");
    let root = sg.root();
    extract_custom_inject(&lang, &injections, root, &mut ret);
    assert_eq!(ret.len(), 1);
    assert_eq!(ret["css"].len(), 1);
    assert!(!ret.contains_key("js"));
    ret.clear();
    let sg = lang.ast_grep("const a = styled.css`.btn { margin: 0; }`");
    let root = sg.root();
    extract_custom_inject(&lang, &injections, root, &mut ret);
    assert_eq!(ret.len(), 1);
    assert_eq!(ret["css"].len(), 1);
    assert!(!ret.contains_key("js"));
  }
}



================================================
FILE: crates/cli/src/lang/lang_globs.rs
================================================
use super::SgLang;
use ignore::types::{Types, TypesBuilder};
use std::collections::HashMap;
use std::path::Path;
use std::ptr::{addr_of, addr_of_mut};
use std::str::FromStr;

use crate::utils::ErrorContext as EC;
use anyhow::{Context, Result};

// both use vec since lang will be small
static mut LANG_GLOBS: Vec<(SgLang, Types)> = vec![];

pub type LanguageGlobs = HashMap<String, Vec<String>>;

pub unsafe fn register(regs: LanguageGlobs) -> Result<()> {
  debug_assert! {
    (*addr_of!(LANG_GLOBS)).is_empty()
  };
  let lang_globs = register_impl(regs)?;
  _ = std::mem::replace(&mut *addr_of_mut!(LANG_GLOBS), lang_globs);
  Ok(())
}

fn register_impl(regs: LanguageGlobs) -> Result<Vec<(SgLang, Types)>> {
  let mut lang_globs = vec![];
  for (lang, globs) in regs {
    let lang = SgLang::from_str(&lang).with_context(|| EC::UnrecognizableLanguage(lang))?;
    // Note: we have to use lang.to_string() for normalized language name
    // TODO: add test
    let lang_name = lang.to_string();
    let types = build_types(&lang_name, globs)?;
    lang_globs.push((lang, types));
  }
  Ok(lang_globs)
}

fn build_types(lang: &str, globs: Vec<String>) -> Result<Types> {
  let mut builder = TypesBuilder::new();
  for glob in globs {
    // builder add will only trigger error when lang name is `all`
    builder
      .add(lang, &glob)
      .with_context(|| EC::UnrecognizableLanguage(lang.into()))?;
  }
  builder.select(lang);
  builder.build().context(EC::ParseConfiguration)
}

fn add_types(builder: &mut TypesBuilder, types: &Types) {
  for def in types.definitions() {
    let name = def.name();
    for glob in def.globs() {
      builder.add(name, glob).expect(name);
    }
  }
}

fn get_types(lang: &SgLang) -> Option<&Types> {
  for (l, types) in unsafe { &*addr_of!(LANG_GLOBS) } {
    if l == lang {
      return Some(types);
    }
  }
  None
}

pub fn merge_types(types_vec: impl Iterator<Item = Types>) -> Types {
  let mut builder = TypesBuilder::new();
  for types in types_vec {
    for def in types.definitions() {
      let name = def.name();
      for glob in def.globs() {
        builder.add(name, glob).expect(name);
      }
      builder.select(name);
    }
  }
  builder.build().expect("file types must be valid")
}

pub fn merge_globs(lang: &SgLang, type1: Types) -> Types {
  let Some(type2) = get_types(lang) else {
    return type1;
  };
  let mut builder = TypesBuilder::new();
  add_types(&mut builder, &type1);
  add_types(&mut builder, type2);
  builder.select(&lang.to_string());
  builder.build().expect("file type must be valid")
}

pub fn from_path(p: &Path) -> Option<SgLang> {
  for (lang, types) in unsafe { &*addr_of!(LANG_GLOBS) } {
    if types.matched(p, false).is_whitelist() {
      return Some(*lang);
    }
  }
  None
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_language::SupportLang;
  use serde_yaml::from_str;

  const YAML: &str = r"
js: ['.eslintrc']
html: ['*.vue', '*.svelte']";

  fn get_globs() -> LanguageGlobs {
    from_str(YAML).expect("should parse")
  }
  #[test]
  fn test_parse_globs() {
    let globs = get_globs();
    assert_eq!(globs["js"], &[".eslintrc"]);
    assert_eq!(globs["html"], &["*.vue", "*.svelte"]);
  }

  #[test]
  fn test_register() -> Result<()> {
    let globs = get_globs();
    let lang_globs = register_impl(globs)?;
    assert_eq!(lang_globs.len(), 2);
    Ok(())
  }

  #[test]
  fn test_invalid_language() {
    let mut globs = get_globs();
    globs.insert("php-exp".into(), vec!["bestlang".into()]);
    let ret = register_impl(globs);
    let err = ret.expect_err("should wrong");
    assert!(matches!(
      err.downcast::<EC>(),
      Ok(EC::UnrecognizableLanguage(_))
    ));
  }

  #[test]
  fn test_merge_types() {
    let lang: SgLang = SupportLang::Rust.into();
    let default_types = lang.file_types();
    let rust_types = merge_globs(&lang, default_types);
    assert!(rust_types.matched("a.php", false).is_ignore());
    assert!(rust_types.matched("a.rs", false).is_whitelist());
  }

  #[test]
  fn test_merge_with_globs() -> Result<()> {
    let globs = get_globs();
    unsafe {
      // cleanup
      std::mem::take(&mut *addr_of_mut!(LANG_GLOBS));
      register(globs)?;
      assert_eq!((*addr_of!(LANG_GLOBS)).len(), 2);
    }
    let lang: SgLang = SupportLang::Html.into();
    let default_types = lang.file_types();
    let html_types = merge_globs(&lang, default_types);
    assert!(html_types.matched("a.php", false).is_ignore());
    assert!(html_types.matched("a.html", false).is_whitelist());
    assert!(html_types.matched("a.vue", false).is_whitelist());
    assert!(html_types.matched("a.svelte", false).is_whitelist());
    Ok(())
  }
}



================================================
FILE: crates/cli/src/lang/mod.rs
================================================
mod injection;
mod lang_globs;

use crate::utils::ErrorContext as EC;

use anyhow::{Context, Result};
use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ast_grep_core::{
  tree_sitter::{StrDoc, TSLanguage, TSRange},
  Node,
};
use ast_grep_dynamic::DynamicLang;
use ast_grep_language::{Language, LanguageExt, SupportLang};
use ignore::types::Types;
use serde::{Deserialize, Serialize};

use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Debug, Display, Formatter};
use std::path::Path;
use std::str::FromStr;

pub use ast_grep_dynamic::CustomLang;
pub use injection::SerializableInjection;
pub use lang_globs::LanguageGlobs;

#[derive(Copy, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
#[serde(untagged)]
pub enum SgLang {
  // inlined support lang expando char
  Builtin(SupportLang),
  Custom(DynamicLang),
}

impl SgLang {
  pub fn file_types(&self) -> Types {
    let default_types = match self {
      Builtin(b) => b.file_types(),
      Custom(c) => c.file_types(),
    };
    lang_globs::merge_globs(self, default_types)
  }

  // register_globs must be called after register_custom_language
  pub fn register_custom_language(base: &Path, langs: HashMap<String, CustomLang>) -> Result<()> {
    CustomLang::register(base, langs).context(EC::CustomLanguage)
  }

  // TODO: add tests
  // register_globs must be called after register_custom_language
  pub fn register_globs(langs: LanguageGlobs) -> Result<()> {
    unsafe {
      lang_globs::register(langs)?;
    }
    Ok(())
  }

  pub fn register_injections(injections: Vec<SerializableInjection>) -> Result<()> {
    unsafe { injection::register_injetables(injections) }
  }

  pub fn all_langs() -> Vec<Self> {
    let builtin = SupportLang::all_langs().iter().copied().map(Self::Builtin);
    let customs = DynamicLang::all_langs().into_iter().map(Self::Custom);
    builtin.chain(customs).collect()
  }

  pub fn injectable_sg_langs(&self) -> Option<impl Iterator<Item = Self>> {
    let langs = self.injectable_languages()?;
    // TODO: handle injected languages not found
    // e.g vue can inject scss which is not supported by sg
    // we should report an error here
    let iter = langs.iter().filter_map(|s| SgLang::from_str(s).ok());
    Some(iter)
  }

  pub fn augmented_file_type(&self) -> Types {
    let self_type = self.file_types();
    let injector = Self::all_langs().into_iter().filter_map(|lang| {
      lang
        .injectable_sg_langs()?
        .any(|l| l == *self)
        .then_some(lang)
    });
    let injector_types = injector.map(|lang| lang.file_types());
    let all_types = std::iter::once(self_type).chain(injector_types);
    lang_globs::merge_types(all_types)
  }

  pub fn file_types_for_langs(langs: impl Iterator<Item = Self>) -> Types {
    let types = langs.map(|lang| lang.augmented_file_type());
    lang_globs::merge_types(types)
  }
}

impl Display for SgLang {
  fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
    match self {
      Builtin(b) => write!(f, "{b}"),
      Custom(c) => write!(f, "{}", c.name()),
    }
  }
}

impl Debug for SgLang {
  fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
    match self {
      Builtin(b) => write!(f, "{b:?}"),
      Custom(c) => write!(f, "{:?}", c.name()),
    }
  }
}

#[derive(Debug)]
pub enum SgLangErr {
  LanguageNotSupported(String),
}

impl Display for SgLangErr {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    use SgLangErr::*;
    match self {
      LanguageNotSupported(lang) => write!(f, "{lang} is not supported!"),
    }
  }
}

impl std::error::Error for SgLangErr {}

impl FromStr for SgLang {
  type Err = SgLangErr;
  fn from_str(s: &str) -> Result<Self, Self::Err> {
    if let Ok(b) = SupportLang::from_str(s) {
      Ok(SgLang::Builtin(b))
    } else if let Ok(c) = DynamicLang::from_str(s) {
      Ok(SgLang::Custom(c))
    } else {
      Err(SgLangErr::LanguageNotSupported(s.into()))
    }
  }
}

impl From<SupportLang> for SgLang {
  fn from(value: SupportLang) -> Self {
    Self::Builtin(value)
  }
}
impl From<DynamicLang> for SgLang {
  fn from(value: DynamicLang) -> Self {
    Self::Custom(value)
  }
}

use SgLang::*;
impl Language for SgLang {
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    match self {
      Builtin(b) => b.pre_process_pattern(query),
      Custom(c) => c.pre_process_pattern(query),
    }
  }

  #[inline]
  fn meta_var_char(&self) -> char {
    match self {
      Builtin(b) => b.meta_var_char(),
      Custom(c) => c.meta_var_char(),
    }
  }

  #[inline]
  fn expando_char(&self) -> char {
    match self {
      Builtin(b) => b.expando_char(),
      Custom(c) => c.expando_char(),
    }
  }

  fn kind_to_id(&self, kind: &str) -> u16 {
    match self {
      Builtin(b) => b.kind_to_id(kind),
      Custom(c) => c.kind_to_id(kind),
    }
  }
  fn field_to_id(&self, field: &str) -> Option<u16> {
    match self {
      Builtin(b) => b.field_to_id(field),
      Custom(c) => c.field_to_id(field),
    }
  }
  fn from_path<P: AsRef<Path>>(path: P) -> Option<Self> {
    // respect user overriding like languageGlobs and custom lang
    // TODO: test this preference
    let path = path.as_ref();
    lang_globs::from_path(path)
      .or_else(|| DynamicLang::from_path(path).map(Custom))
      .or_else(|| SupportLang::from_path(path).map(Builtin))
  }
  fn build_pattern(&self, builder: &PatternBuilder) -> std::result::Result<Pattern, PatternError> {
    builder.build(|src| StrDoc::try_new(src, *self))
  }
}

impl LanguageExt for SgLang {
  fn get_ts_language(&self) -> TSLanguage {
    match self {
      Builtin(b) => b.get_ts_language(),
      Custom(c) => c.get_ts_language(),
    }
  }

  fn injectable_languages(&self) -> Option<&'static [&'static str]> {
    injection::injectable_languages(*self)
  }

  fn extract_injections<L: LanguageExt>(
    &self,
    root: Node<StrDoc<L>>,
  ) -> HashMap<String, Vec<TSRange>> {
    injection::extract_injections(self, root)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use std::mem::size_of;

  #[test]
  fn test_sg_lang_size() {
    assert_eq!(size_of::<SgLang>(), size_of::<DynamicLang>());
  }
}



================================================
FILE: crates/cli/src/print/cloud_print.rs
================================================
use super::{Diff, NodeMatch, PrintProcessor, Printer};
use crate::lang::SgLang;
use ast_grep_config::{RuleConfig, Severity};
use clap::ValueEnum;

use anyhow::Result;
use codespan_reporting::files::SimpleFile;
use std::io::{Stdout, Write};

use std::borrow::Cow;
use std::path::{Path, PathBuf};

#[derive(PartialEq, Eq, Clone, ValueEnum)]
#[clap(rename_all = "lower")]
pub enum Platform {
  GitHub,
}

pub struct CloudPrinter<W: Write> {
  writer: W,
}

impl<W: Write> CloudPrinter<W> {
  pub fn new(writer: W) -> Self {
    Self { writer }
  }
}

impl CloudPrinter<Stdout> {
  pub fn stdout() -> Self {
    Self::new(std::io::stdout())
  }
}
impl<W: Write> Printer for CloudPrinter<W> {
  type Processed = Vec<u8>;
  type Processor = CloudProcessor;

  fn get_processor(&self) -> Self::Processor {
    CloudProcessor
  }

  fn process(&mut self, processed: Self::Processed) -> Result<()> {
    self.writer.write_all(&processed)?;
    Ok(())
  }
}

pub struct CloudProcessor;

impl PrintProcessor<Vec<u8>> for CloudProcessor {
  fn print_rule(
    &self,
    matches: Vec<NodeMatch>,
    file: SimpleFile<Cow<str>, &str>,
    rule: &RuleConfig<SgLang>,
  ) -> Result<Vec<u8>> {
    let mut ret = vec![];
    let path = PathBuf::from(file.name().to_string());
    for m in matches {
      print_rule(&mut ret, m, &path, rule)?;
    }
    Ok(ret)
  }

  fn print_matches(&self, _m: Vec<NodeMatch>, _p: &Path) -> Result<Vec<u8>> {
    unreachable!("cloud printer does not support pattern search")
  }

  fn print_diffs(&self, _d: Vec<Diff>, _p: &Path) -> Result<Vec<u8>> {
    unreachable!("cloud printer does not support pattern rewrite")
  }

  fn print_rule_diffs(
    &self,
    diffs: Vec<(Diff<'_>, &RuleConfig<SgLang>)>,
    path: &Path,
  ) -> Result<Vec<u8>> {
    let mut ret = vec![];
    for (diff, rule) in diffs {
      print_rule(&mut ret, diff.node_match, path, rule)?;
    }
    Ok(ret)
  }
}

fn print_rule<W: Write>(
  writer: &mut W,
  m: NodeMatch,
  path: &Path,
  rule: &RuleConfig<SgLang>,
) -> Result<()> {
  let level = match rule.severity {
    Severity::Error => "error",
    Severity::Warning => "warning",
    Severity::Info => "notice",
    Severity::Hint => return Ok(()),
    Severity::Off => unreachable!("turned-off rule should not have match."),
  };
  let title = &rule.id;
  let name = path.display();
  let line = m.start_pos().line() + 1;
  let end_line = m.end_pos().line() + 1;
  let message = rule.get_message(&m);
  writeln!(
    writer,
    "::{level} file={name},line={line},endLine={end_line},title={title}::{message}"
  )?;
  Ok(())
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_config::{from_yaml_string, GlobalRules};
  use ast_grep_language::{LanguageExt, SupportLang};
  use codespan_reporting::term::termcolor::Buffer;

  fn make_test_printer() -> CloudPrinter<Buffer> {
    CloudPrinter::new(Buffer::no_color())
  }
  fn get_text(printer: &mut CloudPrinter<Buffer>) -> String {
    let buffer = &mut printer.writer;
    let bytes = buffer.as_slice();
    std::str::from_utf8(bytes)
      .expect("buffer should be valid utf8")
      .to_owned()
  }

  fn make_rule(rule: &str) -> RuleConfig<SgLang> {
    let globals = GlobalRules::default();
    from_yaml_string(
      &format!(
        r"
id: test
message: test rule
language: TypeScript
{rule}"
      ),
      &globals,
    )
    .unwrap()
    .pop()
    .unwrap()
  }

  fn test_output(src: &str, rule_str: &str, expect: &str) {
    let mut printer = make_test_printer();
    let grep = SgLang::from(SupportLang::Tsx).ast_grep(src);
    let rule = make_rule(rule_str);
    let matches = grep.root().find_all(&rule.matcher).collect();
    let file = SimpleFile::new(Cow::Borrowed("test.tsx"), src);
    let buffer = printer
      .get_processor()
      .print_rule(matches, file, &rule)
      .unwrap();
    printer.process(buffer).expect("should work");
    let actual = get_text(&mut printer);
    assert_eq!(actual, expect);
  }

  #[test]
  fn test_no_match_output() {
    test_output("let a = 123", "rule: { pattern: console }", "");
    test_output(
      "let a = 123",
      "
rule: { pattern: console }
severity: error",
      "",
    );
  }

  #[test]
  fn test_hint_output() {
    test_output(
      "console.log(123)",
      "
rule: { pattern: console }
severity: hint
",
      "",
    );
  }

  #[test]
  fn test_info_output() {
    test_output(
      "console.log(123)",
      "
rule: { pattern: console }
severity: info
",
      "::notice file=test.tsx,line=1,endLine=1,title=test::test rule\n",
    );
  }

  #[test]
  fn test_warning_output() {
    test_output(
      "console.log(123)",
      "
rule: { pattern: console }
severity: warning
",
      "::warning file=test.tsx,line=1,endLine=1,title=test::test rule\n",
    );
  }

  #[test]
  fn test_error_output() {
    test_output(
      "console.log(123)",
      "
rule: { pattern: console }
severity: error
",
      "::error file=test.tsx,line=1,endLine=1,title=test::test rule\n",
    );
  }
}



================================================
FILE: crates/cli/src/print/colored_print.rs
================================================
use super::{Diff, NodeMatch, PrintProcessor, Printer};
use crate::lang::SgLang;
use crate::utils::DiffStyles;
use anyhow::Result;
use ast_grep_config::{RuleConfig, Severity};
use ast_grep_core::Doc;
use clap::ValueEnum;
use codespan_reporting::diagnostic::{self, Diagnostic, Label};
use codespan_reporting::files::SimpleFile;
use codespan_reporting::term::termcolor::{Buffer, ColorChoice, StandardStream, WriteColor};
use codespan_reporting::term::{self, DisplayStyle};

use std::borrow::Cow;
use std::io::Write;
use std::path::Path;

mod markdown;
mod match_merger;
mod styles;
mod test;

use markdown::Markdown;
use match_merger::MatchMerger;
pub use styles::should_use_color;
use styles::{PrintStyles, RuleStyle};

#[derive(Clone, Copy, ValueEnum)]
pub enum ReportStyle {
  /// Output a richly formatted diagnostic, with source code previews.
  Rich,
  /// Output a condensed diagnostic, with a line number, severity, message and notes (if any).
  Medium,
  /// Output a short diagnostic, with a line number, severity, and message.
  Short,
}

#[derive(Clone, Copy, ValueEnum)]
pub enum Heading {
  /// Print heading for terminal tty but not for piped output
  Auto,
  /// Always print heading regardless of output type.
  Always,
  /// Never print heading regardless of output type.
  Never,
}

impl Heading {
  fn should_print(&self) -> bool {
    use Heading as H;
    match self {
      H::Always => true,
      H::Never => false,
      H::Auto => atty::is(atty::Stream::Stdout),
    }
  }
}

pub struct ColoredPrinter<W: WriteColor> {
  writer: W,
  config: term::Config,
  styles: PrintStyles,
  heading: Heading,
  context: (u16, u16),
}

impl<W: WriteColor> ColoredPrinter<W> {
  pub fn new(writer: W) -> Self {
    Self {
      writer,
      styles: PrintStyles::from(ColorChoice::Auto),
      config: term::Config::default(),
      heading: Heading::Auto,
      context: (0, 0),
    }
  }

  pub fn color<C: Into<ColorChoice>>(mut self, color: C) -> Self {
    let color = color.into();
    self.styles = PrintStyles::from(color);
    self
  }

  pub fn style(mut self, style: ReportStyle) -> Self {
    let display_style = match style {
      ReportStyle::Rich => DisplayStyle::Rich,
      ReportStyle::Medium => DisplayStyle::Medium,
      ReportStyle::Short => DisplayStyle::Short,
    };
    self.config.display_style = display_style;
    self
  }

  pub fn heading(mut self, heading: Heading) -> Self {
    self.heading = heading;
    self
  }

  pub fn context(mut self, context: (u16, u16)) -> Self {
    self.context = context;
    self.config.start_context_lines = context.0 as usize;
    self.config.end_context_lines = context.1 as usize;
    self
  }
}

impl<W: WriteColor> Printer for ColoredPrinter<W> {
  type Processed = Buffer;
  type Processor = ColoredProcessor;

  fn get_processor(&self) -> Self::Processor {
    let color = self.writer.supports_color();
    let markdown = Markdown::new(color);
    ColoredProcessor {
      color,
      config: self.config.clone(),
      styles: self.styles.clone(),
      heading: self.heading,
      context: self.context,
      markdown,
    }
  }

  fn process(&mut self, buffer: Buffer) -> Result<()> {
    self.writer.write_all(buffer.as_slice())?;
    Ok(())
  }
}

impl ColoredPrinter<StandardStream> {
  pub fn stdout<C: Into<ColorChoice>>(color: C) -> Self {
    let color = color.into();
    ColoredPrinter::new(StandardStream::stdout(color)).color(color)
  }

  /// Print the title of fixes
  pub fn print_diff_title(&mut self, diffs: &[Option<&str>], index: usize) -> Result<()> {
    if diffs.len() <= 1 {
      return Ok(());
    }
    let note_style = self.styles.rule.note;
    let hunk_style = self.styles.diff.hunk_header;
    let select_style = self.styles.diff.select_fix;
    writeln!(self.writer, "{}", note_style.paint("Switch fix by [tab]:"))?;
    for (i, title) in diffs.iter().enumerate() {
      let title = title.unwrap_or("No title");
      if i == index {
        let arrow = hunk_style.paint("⇥");
        let title = select_style.paint(title);
        writeln!(self.writer, "{arrow} {title}")?;
      } else {
        writeln!(self.writer, "  {title}")?;
      }
    }
    writeln!(self.writer)?;
    Ok(())
  }
}

fn create_buffer(color: bool) -> Buffer {
  if color {
    Buffer::ansi()
  } else {
    Buffer::no_color()
  }
}

pub struct ColoredProcessor {
  color: bool,
  config: term::Config,
  styles: PrintStyles,
  heading: Heading,
  markdown: Markdown,
  context: (u16, u16),
}

impl ColoredProcessor {
  fn context_span(&self) -> usize {
    (self.context.0 + self.context.1) as usize
  }

  fn diff_context(&self) -> usize {
    if self.context.0 == 0 {
      3
    } else {
      self.context.0 as usize
    }
  }
}

fn sg_label_to_code_span_label(label: ast_grep_config::Label<impl Doc>) -> Label<()> {
  let ret = match label.style {
    ast_grep_config::LabelStyle::Primary => Label::primary((), label.range()),
    ast_grep_config::LabelStyle::Secondary => Label::secondary((), label.range()),
  };
  if let Some(message) = label.message {
    ret.with_message(message)
  } else {
    ret
  }
}

impl PrintProcessor<Buffer> for ColoredProcessor {
  fn print_rule(
    &self,
    matches: Vec<NodeMatch>,
    file: SimpleFile<Cow<str>, &str>,
    rule: &RuleConfig<SgLang>,
  ) -> Result<Buffer> {
    let config = &self.config;
    let mut buffer = create_buffer(self.color);
    let writer = &mut buffer;
    let severity = match rule.severity {
      Severity::Error => diagnostic::Severity::Error,
      Severity::Warning => diagnostic::Severity::Warning,
      Severity::Info => diagnostic::Severity::Note,
      Severity::Hint => diagnostic::Severity::Help,
      Severity::Off => unreachable!("turned-off rule should not have match."),
    };
    let notes = self.markdown.render_note(rule);
    for m in matches {
      let labels = rule
        .get_labels(&m)
        .into_iter()
        .map(sg_label_to_code_span_label)
        .collect();
      let diagnostic = Diagnostic::new(severity)
        .with_code(&rule.id)
        .with_message(rule.get_message(&m))
        .with_notes(notes.clone().into_iter().collect())
        .with_labels(labels);
      term::emit(&mut *writer, config, &file, &diagnostic)?;
    }
    Ok(buffer)
  }

  fn print_matches(&self, matches: Vec<NodeMatch>, path: &Path) -> Result<Buffer> {
    if self.heading.should_print() {
      print_matches_with_heading(matches, path, self)
    } else {
      print_matches_with_prefix(matches, path, self)
    }
  }

  fn print_diffs(&self, diffs: Vec<Diff>, path: &Path) -> Result<Buffer> {
    let context = self.diff_context();
    let mut buffer = create_buffer(self.color);
    let writer = &mut buffer;
    print_diffs(diffs, path, &self.styles, writer, context)?;
    Ok(buffer)
  }
  fn print_rule_diffs(
    &self,
    diffs: Vec<(Diff<'_>, &RuleConfig<SgLang>)>,
    path: &Path,
  ) -> Result<Buffer> {
    let context = self.diff_context();
    let mut buffer = create_buffer(self.color);
    let writer = &mut buffer;
    let mut start = 0;
    let display_style = &self.config.display_style;
    for (diff, rule) in diffs {
      let range = &diff.range;
      // skip overlapping diff
      if range.start < start {
        continue;
      }
      start = range.end;
      if matches!(display_style, DisplayStyle::Rich) {
        self.styles.print_prelude(path, writer)?;
      } else {
        let pos = diff.node_match.start_pos();
        write!(
          writer,
          "{}:{}:{}: ",
          path.display(),
          pos.line() + 1,
          pos.column(&*diff.node_match) + 1
        )?;
      }
      print_rule_title(rule, &diff.node_match, &self.styles.rule, writer)?;
      if matches!(display_style, DisplayStyle::Rich) {
        let source = diff.get_root_text();
        let new_str = format!(
          "{}{}{}",
          &source[..range.start],
          diff.replacement,
          &source[start..],
        );
        self
          .styles
          .diff
          .print_diff(source, &new_str, writer, context)?;
      }
      if matches!(display_style, DisplayStyle::Medium | DisplayStyle::Rich) {
        let notes = self.markdown.render_note(rule);
        if let Some(note) = notes {
          writeln!(writer, "{}", self.styles.rule.note.paint("Note:"))?;
          writeln!(writer, "{note}")?;
        }
      }
    }
    Ok(buffer)
  }
}

fn print_rule_title<W: WriteColor>(
  rule: &RuleConfig<SgLang>,
  nm: &NodeMatch,
  style: &RuleStyle,
  writer: &mut W,
) -> Result<()> {
  let (level, level_style) = match rule.severity {
    Severity::Error => ("error", style.error),
    Severity::Warning => ("warning", style.warning),
    Severity::Info => ("note", style.info),
    Severity::Hint => ("help", style.hint),
    Severity::Off => unreachable!("turned-off rule should not have match."),
  };
  let header = format!("{level}[{}]:", &rule.id);
  let header = level_style.paint(header);
  let message = style.message.paint(rule.get_message(nm));
  writeln!(writer, "{header} {message}")?;
  Ok(())
}

fn print_matches_with_heading(
  matches: Vec<NodeMatch>,
  path: &Path,
  printer: &ColoredProcessor,
) -> Result<Buffer> {
  let mut matches = matches.into_iter();
  let styles = &printer.styles;
  let context_span = printer.context_span();
  let mut buffer = create_buffer(printer.color);
  let writer = &mut buffer;
  styles.print_prelude(path, writer)?;
  let Some(first_match) = matches.next() else {
    return Ok(buffer);
  };
  let source = first_match.root().get_text();

  let mut merger = MatchMerger::new(&first_match, printer.context);

  let display = merger.display(&first_match);
  let mut ret = display.leading.to_string();
  styles.push_matched_to_ret(&mut ret, &display.matched)?;

  for nm in matches {
    if merger.check_overlapping(&nm) {
      continue;
    }
    let display = merger.display(&nm);
    // merge adjacent matches
    if let Some(last_end_offset) = merger.merge_adjacent(&nm) {
      ret.push_str(&source[last_end_offset..nm.range().start]);
      styles.push_matched_to_ret(&mut ret, &display.matched)?;
      continue;
    }
    ret.push_str(merger.last_trailing);
    let num = merger.last_start_line;
    let width = styles.print_highlight(&ret, num, writer)?;
    if context_span > 0 {
      writeln!(writer, "{:╴>width$}┤", "")?; // make separation
    }
    merger.conclude_match(&nm);
    ret = display.leading.to_string();
    styles.push_matched_to_ret(&mut ret, &display.matched)?;
  }
  ret.push_str(merger.last_trailing);
  let num = merger.last_start_line;
  styles.print_highlight(&ret, num, writer)?;
  writeln!(writer)?; // end
  Ok(buffer)
}

fn print_matches_with_prefix(
  matches: Vec<NodeMatch>,
  path: &Path,
  printer: &ColoredProcessor,
) -> Result<Buffer> {
  let mut matches = matches.into_iter();
  let styles = &printer.styles;
  let context_span = printer.context_span();
  let mut buffer = create_buffer(printer.color);
  let writer = &mut buffer;
  let path = path.display();
  let Some(first_match) = matches.next() else {
    return Ok(buffer);
  };
  let source = first_match.root().get_text();

  let mut merger = MatchMerger::new(&first_match, printer.context);
  let display = merger.display(&first_match);
  let mut ret = display.leading.to_string();
  styles.push_matched_to_ret(&mut ret, &display.matched)?;
  for nm in matches {
    if merger.check_overlapping(&nm) {
      continue;
    }
    let display = merger.display(&nm);
    // merge adjacent matches
    if let Some(last_end_offset) = merger.merge_adjacent(&nm) {
      ret.push_str(&source[last_end_offset..nm.range().start]);
      styles.push_matched_to_ret(&mut ret, &display.matched)?;
      continue;
    }
    ret.push_str(merger.last_trailing);
    for (n, line) in ret.lines().enumerate() {
      let num = merger.last_start_line + n;
      writeln!(writer, "{path}:{num}:{line}")?;
    }
    if context_span > 0 {
      writeln!(writer, "--")?; // make separation
    }
    merger.conclude_match(&nm);
    ret = display.leading.to_string();
    styles.push_matched_to_ret(&mut ret, &display.matched)?;
  }
  ret.push_str(merger.last_trailing);
  for (n, line) in ret.lines().enumerate() {
    let num = merger.last_start_line + n;
    writeln!(writer, "{path}:{num}:{line}")?;
  }
  Ok(buffer)
}

fn print_diffs<W: WriteColor>(
  diffs: Vec<Diff>,
  path: &Path,
  styles: &PrintStyles,
  writer: &mut W,
  context: usize,
) -> Result<()> {
  let mut diffs = diffs.into_iter();
  styles.print_prelude(path, writer)?;
  let Some(first_diff) = diffs.next() else {
    return Ok(());
  };
  let source = first_diff.get_root_text();
  let range = first_diff.range;
  let mut start = range.end;
  let mut new_str = format!("{}{}", &source[..range.start], first_diff.replacement);
  for diff in diffs {
    let range = diff.range;
    // skip overlapping diff
    if range.start < start {
      continue;
    }
    new_str.push_str(&source[start..range.start]);
    new_str.push_str(&diff.replacement);
    start = range.end;
  }
  new_str.push_str(&source[start..]);
  styles.diff.print_diff(source, &new_str, writer, context)?;
  Ok(())
}



================================================
FILE: crates/cli/src/print/interactive_print.rs
================================================
use super::{ColoredPrinter, Diff, NodeMatch, PrintProcessor, Printer};
use crate::lang::SgLang;
use crate::utils::ErrorContext as EC;
use crate::utils::{self, clear};

use anyhow::{Context, Result};
use ast_grep_config::RuleConfig;
use codespan_reporting::files::SimpleFile;
use codespan_reporting::term::termcolor::{Buffer, StandardStream};
use smallvec::{smallvec, SmallVec};

use std::borrow::Cow;
use std::ops::Range;
use std::path::{Path, PathBuf};

type InnerPrinter = ColoredPrinter<StandardStream>;

pub struct InteractivePrinter {
  accept_all: bool,
  from_stdin: bool,
  committed_cnt: usize,
  inner: InnerPrinter,
}

impl InteractivePrinter {
  pub fn new(inner: InnerPrinter, accept_all: bool, from_stdin: bool) -> Result<Self> {
    if from_stdin && !accept_all {
      Err(anyhow::anyhow!(EC::StdInIsNotInteractive))
    } else {
      Ok(Self {
        accept_all,
        from_stdin,
        inner,
        committed_cnt: 0,
      })
    }
  }

  fn prompt_edit(&self) -> char {
    if self.accept_all {
      return 'a';
    }
    const EDIT_PROMPT: &str = "Accept? [y]es/[↵], [n]o, [a]ll, [q]uit, [e]dit";
    utils::prompt(EDIT_PROMPT, "ynaqe\t", Some('y')).expect("Error happened during prompt")
  }

  fn prompt_view(&self) -> char {
    if self.accept_all {
      return '\n';
    }
    const VIEW_PROMPT: &str = "Next[enter], Quit[q], Edit[e]";
    utils::prompt(VIEW_PROMPT, "qe", Some('\n')).expect("cannot fail")
  }

  fn rewrite_action(&self, diffs: Diffs<()>, path: &PathBuf) -> Result<()> {
    if diffs.contents.is_empty() {
      return Ok(());
    }
    let new_content = apply_rewrite(diffs);
    if self.from_stdin {
      println!("{new_content}");
      Ok(())
    } else {
      std::fs::write(path, new_content).with_context(|| EC::WriteFile(path.clone()))
    }
  }

  fn process_highlights(&mut self, highlights: Highlights<Buffer>) -> Result<()> {
    let Highlights {
      path,
      first_line,
      inner,
    } = highlights;
    utils::run_in_alternate_screen(|| {
      self.inner.process(inner)?;
      let resp = self.prompt_view();
      if resp == 'q' {
        Err(anyhow::anyhow!(EC::ExitInteractiveEditing))
      } else if resp == 'e' {
        open_in_editor(&path, first_line)?;
        Ok(())
      } else {
        Ok(())
      }
    })
  }

  fn process_diffs(&mut self, diffs: Diffs<Buffer>) -> Result<()> {
    let path = diffs.path.clone();
    let (confirmed, quit) = process_diffs_interactive(self, diffs)?;
    self.rewrite_action(confirmed, &path)?;
    if quit {
      Err(anyhow::anyhow!(EC::ExitInteractiveEditing))
    } else {
      Ok(())
    }
  }
}

impl Printer for InteractivePrinter {
  type Processed = Payload<InnerPrinter>;
  type Processor = InteractiveProcessor<InnerPrinter>;

  fn get_processor(&self) -> Self::Processor {
    InteractiveProcessor {
      inner: self.inner.get_processor(),
    }
  }

  fn process(&mut self, processed: Self::Processed) -> Result<()> {
    use InteractivePayload as IP;
    match processed {
      IP::Nothing => Ok(()),
      IP::Highlights(h) => self.process_highlights(h),
      IP::Diffs(d) => self.process_diffs(d),
    }
  }

  fn after_print(&mut self) -> Result<()> {
    if self.committed_cnt > 0 {
      eprintln!("Applied {} changes", self.committed_cnt);
    }
    self.inner.after_print()
  }
}

#[derive(Clone, Debug)]
pub struct InteractiveDiff<D> {
  /// string content for the replacement
  replacement: String,
  range: Range<usize>,
  first_line: usize,
  title: Option<String>,
  display: D,
}

impl<D> InteractiveDiff<D> {
  fn new(diff: Diff, display: D) -> Self {
    Self {
      first_line: diff.node_match.start_pos().line(),
      replacement: diff.replacement,
      range: diff.range,
      title: diff.title,
      display,
    }
  }

  fn split(self) -> (InteractiveDiff<()>, D) {
    let pure = InteractiveDiff {
      first_line: self.first_line,
      range: self.range,
      replacement: self.replacement,
      title: self.title,
      display: (),
    };
    (pure, self.display)
  }
}

pub struct Highlights<D> {
  path: PathBuf,
  first_line: usize,
  inner: D,
}

pub struct Diffs<D> {
  path: PathBuf,
  // TODO: this clone is slow
  old_source: String,
  contents: Vec<SmallVec<[InteractiveDiff<D>; 1]>>,
}

pub enum InteractivePayload<D> {
  Nothing,
  Highlights(Highlights<D>),
  Diffs(Diffs<D>),
}

pub struct InteractiveProcessor<P: Printer> {
  inner: P::Processor,
}

pub type Payload<P> = InteractivePayload<<P as Printer>::Processed>;

impl<P> PrintProcessor<Payload<P>> for InteractiveProcessor<P>
where
  P: Printer + 'static,
{
  fn print_rule(
    &self,
    matches: Vec<NodeMatch>,
    file: SimpleFile<Cow<str>, &str>,
    rule: &RuleConfig<SgLang>,
  ) -> Result<Payload<P>> {
    let Some(first_match) = matches.first() else {
      return Ok(InteractivePayload::Nothing);
    };
    let first_line = first_match.start_pos().line();
    let path = PathBuf::from(file.name().to_string());
    let inner = self.inner.print_rule(matches, file, rule)?;
    let highlights = Highlights {
      inner,
      first_line,
      path,
    };
    Ok(InteractivePayload::Highlights(highlights))
  }

  fn print_matches(&self, matches: Vec<NodeMatch>, path: &Path) -> Result<Payload<P>> {
    let Some(first_match) = matches.first() else {
      return Ok(InteractivePayload::Nothing);
    };
    let first_line = first_match.start_pos().line();
    let inner = self.inner.print_matches(matches, path)?;
    let highlights = Highlights {
      inner,
      first_line,
      path: path.to_path_buf(),
    };
    Ok(InteractivePayload::Highlights(highlights))
  }

  fn print_diffs(&self, diffs: Vec<Diff>, path: &Path) -> Result<Payload<P>> {
    let old_source = get_old_source(diffs.first());
    let mut contents = Vec::with_capacity(diffs.len());
    for diff in diffs {
      let display = self.inner.print_diffs(vec![diff.clone()], path)?;
      let content = InteractiveDiff::new(diff, display);
      contents.push(smallvec![content]);
    }
    Ok(InteractivePayload::Diffs(Diffs {
      path: path.to_path_buf(),
      old_source,
      contents,
    }))
  }
  fn print_rule_diffs(
    &self,
    diffs: Vec<(Diff<'_>, &RuleConfig<SgLang>)>,
    path: &Path,
  ) -> Result<Payload<P>> {
    let old_source = get_old_source(diffs.first().map(|d| &d.0));
    let mut contents = Vec::with_capacity(diffs.len());
    for (diff_list, rule) in diffs {
      let diffs = diff_list.into_list();
      let content: Result<_> = diffs
        .into_iter()
        .map(|diff| {
          let display = self
            .inner
            .print_rule_diffs(vec![(diff.clone(), rule)], path)?;
          let diff = InteractiveDiff::new(diff, display);
          Ok(diff)
        })
        .collect();
      contents.push(content?);
    }
    Ok(InteractivePayload::Diffs(Diffs {
      path: path.to_path_buf(),
      old_source,
      contents,
    }))
  }
}

fn get_old_source(diff: Option<&Diff>) -> String {
  let Some(node) = diff else {
    return String::new();
  };
  node.get_root_text().to_string()
}

fn process_diffs_interactive(
  interactive: &mut InteractivePrinter,
  diffs: Diffs<Buffer>,
) -> Result<(Diffs<()>, bool)> {
  let mut confirmed = vec![];
  let mut end = 0;
  let mut quit = false;
  let path = diffs.path;
  for diff in diffs.contents {
    let mut diff_list: Vec<_> = diff
      .into_iter()
      .filter(|diff| diff.range.start >= end)
      .collect();
    if diff_list.is_empty() {
      continue;
    }
    let to_confirm = if interactive.accept_all {
      diff_list.remove(0).split().0
    } else {
      use InteractionChoice as IC;
      match print_diff_and_prompt_action(interactive, &path, diff_list)? {
        IC::Yes(c) => c,
        IC::All(c) => {
          interactive.accept_all = true;
          c
        }
        IC::No => continue,
        IC::Quit => {
          quit = true;
          break;
        }
      }
    };
    end = to_confirm.range.end;
    confirmed.push(smallvec![to_confirm]);
    interactive.committed_cnt = interactive.committed_cnt.saturating_add(1);
  }
  let diffs = Diffs {
    path,
    old_source: diffs.old_source,
    contents: confirmed,
  };
  Ok((diffs, quit))
}

enum InteractionChoice {
  Yes(InteractiveDiff<()>),
  All(InteractiveDiff<()>),
  No,
  Quit,
}

/// returns if accept_current and accept_all
fn print_diff_and_prompt_action(
  interactive: &mut InteractivePrinter,
  path: &Path,
  processed: Vec<InteractiveDiff<Buffer>>,
) -> Result<InteractionChoice> {
  utils::run_in_alternate_screen(|| {
    let mut to_confirm = Vec::with_capacity(processed.len());
    let mut display = Vec::with_capacity(processed.len());
    for diff in processed {
      let (c, d) = diff.split();
      to_confirm.push(c);
      display.push(d);
    }
    let mut index = 0;
    let len = to_confirm.len();
    let titles: Vec<_> = to_confirm.iter().map(|d| d.title.as_deref()).collect();
    let ret = loop {
      let confirmed = to_confirm[index].clone();
      let display = display[index].clone();
      interactive.inner.process(display)?;
      interactive.inner.print_diff_title(&titles, index)?;
      break match interactive.prompt_edit() {
        '\t' => {
          index = (index + 1) % len;
          clear()?;
          continue;
        }
        'y' => InteractionChoice::Yes(confirmed),
        'a' => InteractionChoice::All(confirmed),
        'e' => {
          let pos = confirmed.first_line;
          open_in_editor(path, pos)?;
          InteractionChoice::No
        }
        'q' => InteractionChoice::Quit,
        'n' => InteractionChoice::No,
        _ => return Err(anyhow::anyhow!("Unexpected choice")),
      };
    };
    Ok(ret)
  })
}

fn apply_rewrite(diffs: Diffs<()>) -> String {
  let mut new_content = String::new();
  let old_content = diffs.old_source;
  let mut start = 0;
  for mut diff_list in diffs.contents {
    let diff = diff_list.remove(0);
    let range = diff.range;
    new_content.push_str(&old_content[start..range.start]);
    new_content.push_str(&diff.replacement);
    start = range.end;
  }
  // add trailing statements
  new_content.push_str(&old_content[start..]);
  new_content
}

/// start_line is zero-based
fn open_in_editor(path: &Path, start_line: usize) -> Result<()> {
  let editor = std::env::var("EDITOR").unwrap_or_else(|_| String::from("vim"));
  let exit = std::process::Command::new(editor)
    .arg(path)
    .arg(format!("+{}", start_line + 1))
    .spawn()
    .context(EC::OpenEditor)?
    .wait()
    .context(EC::OpenEditor)?;
  if exit.success() {
    Ok(())
  } else {
    Err(anyhow::anyhow!(EC::OpenEditor))
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_config::{from_yaml_string, Fixer, GlobalRules};
  use ast_grep_core::tree_sitter::{StrDoc, Visitor};
  use ast_grep_core::{AstGrep, Matcher};
  use ast_grep_language::SupportLang;

  fn make_rule(rule: &str) -> RuleConfig<SgLang> {
    let globals = GlobalRules::default();
    from_yaml_string(
      &format!(
        r"
id: test
message: test rule
severity: info
language: TypeScript
{rule}"
      ),
      &globals,
    )
    .unwrap()
    .pop()
    .unwrap()
  }

  fn make_diffs(grep: &AstGrep<StrDoc<SgLang>>, matcher: impl Matcher, fixer: &Fixer) -> Diffs<()> {
    let root = grep.root();
    let old_source = root.root().get_text().to_string();
    let contents = Visitor::new(&matcher)
      .reentrant(false)
      .visit(root)
      .map(|nm| {
        let diff = Diff::generate(nm, &matcher, fixer);
        smallvec![InteractiveDiff {
          first_line: 0,
          range: diff.range,
          replacement: diff.replacement,
          title: diff.title,
          display: (),
        }]
      })
      .collect();
    Diffs {
      old_source,
      path: PathBuf::new(),
      contents,
    }
  }

  #[test]
  fn test_apply_rewrite() {
    let root = AstGrep::new("let a = () => c++", SupportLang::TypeScript.into());
    let config = make_rule(
      r"
rule:
  all:
    - pattern: $B
    - any:
        - pattern: $A++
fix: ($B, lifecycle.update(['$A']))",
    );
    let mut matcher = config.matcher;
    let fixer = matcher.fixer.remove(0);
    let diffs = make_diffs(&root, matcher, &fixer);
    let ret = apply_rewrite(diffs);
    assert_eq!(ret, "let a = () => (c++, lifecycle.update(['c']))");
  }

  #[test]
  fn test_rewrite_nested() {
    let root = AstGrep::new("Some(Some(1))", SupportLang::TypeScript.into());
    let diffs = make_diffs(
      &root,
      "Some($A)",
      &Fixer::from_str::<SgLang>("$A", &SupportLang::TypeScript.into())
        .expect("fixer must compile"),
    );
    let ret = apply_rewrite(diffs);
    assert_eq!("Some(1)", ret);
  }

  // https://github.com/ast-grep/ast-grep/issues/668
  #[test]
  fn test_rewrite_with_empty_lines() {
    let root = AstGrep::new("\n\n\nSome(1)", SupportLang::TypeScript.into());
    let diffs = make_diffs(
      &root,
      "Some($A)",
      &Fixer::from_str::<SgLang>("$A", &SupportLang::TypeScript.into())
        .expect("fixer must compile"),
    );
    let ret = apply_rewrite(diffs);
    assert_eq!("\n\n\n1", ret);
  }

  fn test_open_editor_respect_editor_env() {
    std::env::set_var("EDITOR", "echo");
    let exit = open_in_editor(&PathBuf::from("Cargo.toml"), 1);
    assert!(exit.is_ok());
  }

  fn test_open_editor_error_handling() {
    std::env::set_var("EDITOR", "NOT_EXIST_XXXXX");
    let exit = open_in_editor(&PathBuf::from("Cargo.toml"), 1);
    let error = exit.expect_err("should be error");
    let error = error.downcast_ref::<EC>().expect("should be error context");
    assert!(matches!(error, EC::OpenEditor));
  }

  #[test]
  fn test_open_editor() {
    // these two tests must run in sequence
    // since setting env will cause racing condition
    test_open_editor_respect_editor_env();
    test_open_editor_error_handling();
  }
}



================================================
FILE: crates/cli/src/print/json_print.rs
================================================
use crate::lang::SgLang;
use ast_grep_config::{LabelStyle, Metadata, RuleConfig, Severity};
use ast_grep_core::Doc;
use ast_grep_core::{meta_var::MetaVariable, tree_sitter::StrDoc, Node as SgNode};

type Node<'t, L> = SgNode<'t, StrDoc<L>>;

use std::collections::HashMap;

use super::{Diff, NodeMatch, PrintProcessor, Printer};
use anyhow::Result;
use clap::ValueEnum;
use codespan_reporting::files::SimpleFile;
use serde::{Deserialize, Serialize};

use std::borrow::Cow;
use std::io::{Stdout, Write};
use std::path::Path;

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
/// Zero-based character position in a file.
struct Position {
  /// Zero-based line number
  line: usize,
  /// Zero-based character column in a line
  column: usize,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Range {
  /// inclusive start, exclusive end
  byte_offset: std::ops::Range<usize>,
  start: Position,
  end: Position,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct MatchNode<'t> {
  text: Cow<'t, str>,
  range: Range,
}
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct MatchLabel<'t, 'r> {
  text: Cow<'t, str>,
  range: Range,
  #[serde(skip_serializing_if = "Option::is_none")]
  message: Option<&'r str>,
  style: LabelStyle,
}

/// a sub field of leading and trailing text count around match.
/// plugin authors can use it to split `lines` into leading, matching and trailing
/// See ast-grep/ast-grep#1381
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CharCount {
  leading: usize,
  trailing: usize,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct MatchJSON<'t, 'b> {
  text: Cow<'t, str>,
  range: Range,
  file: Cow<'b, str>,
  lines: String,
  char_count: CharCount,
  #[serde(skip_serializing_if = "Option::is_none")]
  replacement: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  replacement_offsets: Option<std::ops::Range<usize>>,
  language: SgLang,
  #[serde(skip_serializing_if = "Option::is_none")]
  meta_variables: Option<MetaVariables<'t>>,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct MetaVariables<'t> {
  single: HashMap<String, MatchNode<'t>>,
  multi: HashMap<String, Vec<MatchNode<'t>>>,
  transformed: HashMap<String, String>,
}
fn from_env<'t>(nm: &NodeMatch<'t>) -> Option<MetaVariables<'t>> {
  let env = nm.get_env();
  let mut vars = env.get_matched_variables().peekable();
  vars.peek()?;
  let mut single = HashMap::new();
  let mut multi = HashMap::new();
  let mut transformed = HashMap::new();
  for var in vars {
    use MetaVariable as MV;
    match var {
      MV::Capture(n, _) => {
        if let Some(node) = env.get_match(&n) {
          single.insert(
            n,
            MatchNode {
              text: node.text(),
              range: get_range(node),
            },
          );
        } else if let Some(bytes) = env.get_transformed(&n) {
          transformed.insert(n, String::from_utf8_lossy(bytes).into_owned());
        }
      }
      MV::MultiCapture(n) => {
        let nodes = env.get_multiple_matches(&n);
        multi.insert(
          n,
          nodes
            .into_iter()
            .map(|node| MatchNode {
              text: node.text(),
              range: get_range(&node),
            })
            .collect(),
        );
      }
      _ => continue,
    }
  }
  Some(MetaVariables {
    single,
    multi,
    transformed,
  })
}

fn get_range(n: &Node<'_, SgLang>) -> Range {
  let start_pos = n.start_pos();
  let end_pos = n.end_pos();
  Range {
    byte_offset: n.range(),
    start: Position {
      line: start_pos.line(),
      column: start_pos.column(n),
    },
    end: Position {
      line: end_pos.line(),
      column: end_pos.column(n),
    },
  }
}

impl<'t, 'b> MatchJSON<'t, 'b> {
  fn new(nm: NodeMatch<'t>, path: &'b str, context: (u16, u16)) -> Self {
    let display = nm.display_context(context.0 as usize, context.1 as usize);
    let lines = format!("{}{}{}", display.leading, display.matched, display.trailing);
    MatchJSON {
      file: Cow::Borrowed(path),
      text: nm.text(),
      lines,
      char_count: CharCount {
        leading: display.leading.chars().count(),
        trailing: display.trailing.chars().count(),
      },
      language: *nm.lang(),
      replacement: None,
      replacement_offsets: None,
      range: get_range(&nm),
      meta_variables: from_env(&nm),
    }
  }

  fn diff(diff: Diff<'t>, path: &'b str, context: (u16, u16)) -> Self {
    let mut ret = Self::new(diff.node_match, path, context);
    ret.replacement = Some(diff.replacement);
    ret.replacement_offsets = Some(diff.range);
    ret
  }
}
fn get_labels<'b, 't>(rule: &'b RuleConfig<SgLang>, nm: &NodeMatch<'t>) -> Vec<MatchLabel<'t, 'b>> {
  rule
    .get_labels(nm)
    .into_iter()
    .map(|label| {
      let start_pos = label.start_node.start_pos();
      let end_pos = label.end_node.end_pos();
      let byte_offset = label.range();
      let range = Range {
        byte_offset: byte_offset.clone(),
        start: Position {
          line: start_pos.line(),
          // TODO:using pos.column with non-matching node is Okay now
          // because it only uses the source of the root doc
          column: start_pos.column(nm),
        },
        end: Position {
          line: end_pos.line(),
          column: end_pos.column(nm),
        },
      };
      let source = nm.get_doc().get_source();
      MatchLabel {
        text: Cow::Borrowed(&source[byte_offset]),
        range,
        message: label.message,
        style: label.style,
      }
    })
    .collect()
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct RuleMatchJSON<'t, 'b> {
  #[serde(flatten)]
  matched: MatchJSON<'t, 'b>,
  rule_id: &'b str,
  severity: Severity,
  note: Option<String>,
  message: String,
  #[serde(skip_serializing_if = "Vec::is_empty")]
  labels: Vec<MatchLabel<'t, 'b>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  metadata: Option<Cow<'b, Metadata>>,
}
impl<'t, 'b> RuleMatchJSON<'t, 'b> {
  fn new(nm: NodeMatch<'t>, path: &'b str, rule: &'b RuleConfig<SgLang>, metadata: bool) -> Self {
    let message = rule.get_message(&nm);
    let labels = get_labels(rule, &nm);
    let matched = MatchJSON::new(nm, path, (0, 0));
    let metadata = if metadata {
      rule.metadata.as_ref().map(Cow::Borrowed)
    } else {
      None
    };
    Self {
      matched,
      rule_id: &rule.id,
      severity: rule.severity.clone(),
      note: rule.note.clone(),
      message,
      labels,
      metadata,
    }
  }
  fn diff(diff: Diff<'t>, path: &'b str, rule: &'b RuleConfig<SgLang>, metadata: bool) -> Self {
    let nm = &diff.node_match;
    let message = rule.get_message(nm);
    let labels = get_labels(rule, nm);
    let matched = MatchJSON::diff(diff, path, (0, 0));
    let metadata = if metadata {
      rule.metadata.as_ref().map(Cow::Borrowed)
    } else {
      None
    };
    Self {
      matched,
      rule_id: &rule.id,
      severity: rule.severity.clone(),
      note: rule.note.clone(),
      message,
      labels,
      metadata,
    }
  }
}

/// Controls how to print and format JSON object in output.
#[derive(Clone, Copy, PartialEq, Eq, ValueEnum)]
pub enum JsonStyle {
  /// Prints the matches as a pretty-printed JSON array, with indentation and line breaks.
  /// This is useful for human readability, but not for parsing by other programs.
  /// This is the default value for the `--json` option.
  Pretty,
  /// Prints each match as a separate JSON object, followed by a newline character.
  /// This is useful for streaming the output to other programs that can read one object per line.
  Stream,
  /// Prints the matches as a single-line JSON array, without any whitespace.
  /// This is useful for saving space and minimizing the output size.
  Compact,
}

pub struct JSONPrinter<W: Write> {
  output: W,
  style: JsonStyle,
  context: (u16, u16),
  include_metadata: bool,
  // indicate if any matches happened
  matched: bool,
}
impl JSONPrinter<Stdout> {
  pub fn stdout(style: JsonStyle) -> Self {
    Self::new(std::io::stdout(), style)
  }
}

impl<W: Write> JSONPrinter<W> {
  pub fn new(output: W, style: JsonStyle) -> Self {
    // no match happened yet
    Self {
      style,
      output,
      include_metadata: false,
      context: (0, 0),
      matched: false,
    }
  }

  pub fn context(mut self, context: (u16, u16)) -> Self {
    self.context = context;
    self
  }

  pub fn include_metadata(mut self, include: bool) -> Self {
    self.include_metadata = include;
    self
  }
}

impl<W: Write> Printer for JSONPrinter<W> {
  type Processed = Buffer;
  type Processor = JSONProcessor;

  fn get_processor(&self) -> JSONProcessor {
    JSONProcessor {
      style: self.style,
      context: self.context,
      include_metadata: self.include_metadata,
    }
  }
  fn process(&mut self, processed: Buffer) -> Result<()> {
    if processed.is_empty() {
      return Ok(());
    }
    let output = &mut self.output;
    let matched = self.matched;
    self.matched = true;
    // print separator if there was a match before
    if matched {
      let separator = match self.style {
        JsonStyle::Pretty => ",\n",
        JsonStyle::Stream => "",
        JsonStyle::Compact => ",",
      };
      write!(output, "{separator}")?;
    } else if self.style == JsonStyle::Pretty {
      // print newline for the first match in pretty style
      writeln!(output)?;
    }
    output.write_all(&processed)?;
    Ok(())
  }

  fn before_print(&mut self) -> Result<()> {
    if self.style == JsonStyle::Stream {
      return Ok(());
    }
    write!(self.output, "[")?;
    Ok(())
  }

  fn after_print(&mut self) -> Result<()> {
    if self.style == JsonStyle::Stream {
      return Ok(());
    }
    let output = &mut self.output;
    if self.matched && self.style == JsonStyle::Pretty {
      writeln!(output)?;
    }
    writeln!(output, "]")?;
    Ok(())
  }
}

pub struct JSONProcessor {
  style: JsonStyle,
  include_metadata: bool,
  context: (u16, u16),
}

impl JSONProcessor {
  fn print_docs<S: Serialize>(&self, mut docs: impl Iterator<Item = S>) -> Result<Buffer> {
    let mut ret = Vec::new();
    let Some(doc) = docs.next() else {
      return Ok(ret);
    };
    let output = &mut ret;
    match self.style {
      JsonStyle::Pretty => {
        serde_json::to_writer_pretty(&mut *output, &doc)?;
        for doc in docs {
          writeln!(&mut *output, ",")?;
          serde_json::to_writer_pretty(&mut *output, &doc)?;
        }
      }
      JsonStyle::Stream => {
        // Stream mode requires a newline after each object
        for doc in std::iter::once(doc).chain(docs) {
          serde_json::to_writer(&mut *output, &doc)?;
          writeln!(&mut *output)?;
        }
      }
      JsonStyle::Compact => {
        serde_json::to_writer(&mut *output, &doc)?;
        for doc in docs {
          write!(output, ",")?;
          serde_json::to_writer(&mut *output, &doc)?;
        }
      }
    }
    Ok(ret)
  }
}

type Buffer = Vec<u8>;

impl PrintProcessor<Buffer> for JSONProcessor {
  fn print_rule(
    &self,
    matches: Vec<NodeMatch>,
    file: SimpleFile<Cow<str>, &str>,
    rule: &RuleConfig<SgLang>,
  ) -> Result<Buffer> {
    let path = file.name();
    let jsons = matches
      .into_iter()
      .map(|nm| RuleMatchJSON::new(nm, path, rule, self.include_metadata));
    self.print_docs(jsons)
  }

  fn print_matches(&self, matches: Vec<NodeMatch>, path: &Path) -> Result<Buffer> {
    let path = path.to_string_lossy();
    let context = self.context;
    let jsons = matches
      .into_iter()
      .map(|nm| MatchJSON::new(nm, &path, context));
    self.print_docs(jsons)
  }

  fn print_diffs(&self, diffs: Vec<Diff>, path: &Path) -> Result<Buffer> {
    let path = path.to_string_lossy();
    let context = self.context;
    let jsons = diffs
      .into_iter()
      .map(|diff| MatchJSON::diff(diff, &path, context));
    self.print_docs(jsons)
  }
  fn print_rule_diffs(
    &self,
    diffs: Vec<(Diff, &RuleConfig<SgLang>)>,
    path: &Path,
  ) -> Result<Buffer> {
    let path = path.to_string_lossy();
    let jsons = diffs
      .into_iter()
      .map(|(diff, rule)| RuleMatchJSON::diff(diff, &path, rule, self.include_metadata));
    self.print_docs(jsons)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_config::{from_yaml_string, Fixer, GlobalRules};
  use ast_grep_language::{LanguageExt, SupportLang};

  struct Test(String);
  impl Write for Test {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
      let s = std::str::from_utf8(buf).expect("should ok");
      self.0.push_str(s);
      Ok(buf.len())
    }
    fn flush(&mut self) -> std::io::Result<()> {
      Ok(())
    }
  }
  fn make_test_printer(style: JsonStyle) -> JSONPrinter<Test> {
    JSONPrinter::new(Test(String::new()), style)
  }
  fn get_text(printer: &JSONPrinter<Test>) -> String {
    let output = &printer.output;
    output.0.to_string()
  }

  #[test]
  fn test_empty_printer() {
    for style in [JsonStyle::Pretty, JsonStyle::Compact] {
      let mut printer = make_test_printer(style);
      printer.before_print().unwrap();
      let buffer = printer
        .get_processor()
        .print_matches(vec![], "test.tsx".as_ref())
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      assert_eq!(get_text(&printer), "[]\n");
    }
  }

  // source, pattern, replace, debug note
  type Case<'t> = (&'t str, &'t str, &'t str, &'t str);

  const MATCHES_CASES: &[Case] = &[
    ("let a = 123", "a", "b", "Simple match"),
    (
      "Some(1), Some(2), Some(3)",
      "Some",
      "Any",
      "Same line match",
    ),
    (
      "Some(1), Some(2)\nSome(3), Some(4)",
      "Some",
      "Any",
      "Multiple line match",
    ),
    (
      "import a from 'b';import a from 'b';",
      "import a from 'b';",
      "import c from 'b';",
      "immediate following but not overlapping",
    ),
  ];

  #[test]
  fn test_invariant() {
    for &(source, pattern, _, note) in MATCHES_CASES {
      // heading is required for CI
      let mut printer = make_test_printer(JsonStyle::Pretty);
      let grep = SgLang::from(SupportLang::Tsx).ast_grep(source);
      let matches = grep.root().find_all(pattern).collect();
      printer.before_print().unwrap();
      let buffer = printer
        .get_processor()
        .print_matches(matches, "test.tsx".as_ref())
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      let json_str = get_text(&printer);
      let json: Vec<MatchJSON> = serde_json::from_str(&json_str).unwrap();
      assert_eq!(json[0].text, pattern, "{note}");
    }
  }

  #[test]
  fn test_replace_json() {
    for &(source, pattern, replace, note) in MATCHES_CASES {
      // heading is required for CI
      let mut printer = make_test_printer(JsonStyle::Compact);
      let lang = SgLang::from(SupportLang::Tsx);
      let grep = lang.ast_grep(source);
      let root = grep.root();
      let matches = root.find_all(pattern);
      let fixer = Fixer::from_str(replace, &lang).expect("should work");
      let diffs = matches
        .map(|m| Diff::generate(m, &pattern, &fixer))
        .collect();
      printer.before_print().unwrap();
      let buffer = printer
        .get_processor()
        .print_diffs(diffs, "test.tsx".as_ref())
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      let json_str = get_text(&printer);
      let json: Vec<MatchJSON> = serde_json::from_str(&json_str).unwrap();
      let actual = json[0].replacement.as_ref().expect("should have diff");
      assert_eq!(actual, replace, "{note}");
    }
  }

  fn make_rule(rule: &str) -> RuleConfig<SgLang> {
    let globals = GlobalRules::default();
    from_yaml_string(
      &format!(
        r#"
id: test
message: test rule
severity: info
language: TypeScript
note: a long random note
rule:
  pattern: "{rule}""#
      ),
      &globals,
    )
    .unwrap()
    .pop()
    .unwrap()
  }

  #[test]
  fn test_rule_json() {
    for &(source, pattern, _, note) in MATCHES_CASES {
      // TODO: understand why import does not work
      if source.contains("import") {
        continue;
      }
      let mut printer = make_test_printer(JsonStyle::Pretty);
      let grep = SgLang::from(SupportLang::Tsx).ast_grep(source);
      let rule = make_rule(pattern);
      let matches = grep.root().find_all(&rule.matcher).collect();
      printer.before_print().unwrap();
      let file = SimpleFile::new(Cow::Borrowed("test.ts"), source);
      let buffer = printer
        .get_processor()
        .print_rule(matches, file, &rule)
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      let json_str = get_text(&printer);
      let json: Vec<RuleMatchJSON> = serde_json::from_str(&json_str).unwrap();
      assert_eq!(json[0].matched.text, pattern, "{note}");
      assert_eq!(json[0].note, rule.note);
    }
  }

  #[test]
  fn test_single_matched_json() {
    let mut printer = make_test_printer(JsonStyle::Pretty);
    let lang = SgLang::from(SupportLang::Tsx);
    let grep = lang.ast_grep("console.log(123)");
    let matches = grep.root().find_all("console.log($A)").collect();
    printer.before_print().unwrap();
    let buffer = printer
      .get_processor()
      .print_matches(matches, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    printer.after_print().unwrap();
    let json_str = get_text(&printer);
    let json: Vec<MatchJSON> = serde_json::from_str(&json_str).unwrap();
    let actual = &json[0]
      .meta_variables
      .as_ref()
      .expect("should exist")
      .single;
    assert_eq!(actual["A"].text, "123");
  }

  #[test]
  fn test_multi_matched_json() {
    let mut printer = make_test_printer(JsonStyle::Compact);
    let lang = SgLang::from(SupportLang::Tsx);
    let grep = lang.ast_grep("console.log(1, 2, 3)");
    let matches = grep.root().find_all("console.log($$$A)").collect();
    printer.before_print().unwrap();
    let buffer = printer
      .get_processor()
      .print_matches(matches, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    printer.after_print().unwrap();
    let json_str = get_text(&printer);
    let json: Vec<MatchJSON> = serde_json::from_str(&json_str).unwrap();
    let actual = &json[0].meta_variables.as_ref().expect("should exist").multi;
    assert_eq!(actual["A"][0].text, "1");
    assert_eq!(actual["A"][2].text, "2");
    assert_eq!(actual["A"][4].text, "3");
  }

  #[test]
  fn test_streaming() {
    for &(source, pattern, _, note) in MATCHES_CASES {
      let mut printer = make_test_printer(JsonStyle::Stream);
      let grep = SgLang::from(SupportLang::Tsx).ast_grep(source);
      let matches = grep.root().find_all(pattern).collect();
      printer.before_print().unwrap();
      let buffer = printer
        .get_processor()
        .print_matches(matches, "test.tsx".as_ref())
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      let json_str = get_text(&printer);
      let jsons: Vec<&str> = json_str.lines().collect();
      assert!(!jsons.is_empty());
      let json: Vec<MatchJSON> = jsons
        .into_iter()
        .map(|s| serde_json::from_str(s).unwrap())
        .collect();
      assert_eq!(json[0].text, pattern, "{note}");
    }
  }

  use crate::verify::test::get_rule_config;
  const TRANSFORM_TEXT: &str = "
transform:
  B:
    substring:
      source: $A
      startChar: 1
      endChar: -1
";
  #[test]
  fn test_transform() {
    let mut printer = make_test_printer(JsonStyle::Compact);
    let rule = get_rule_config(&format!("pattern: console.log($A)\n{TRANSFORM_TEXT}"));
    let grep = SgLang::from(SupportLang::TypeScript).ast_grep("console.log(123)");
    let matches = grep.root().find_all(&rule.matcher).collect();
    printer.before_print().unwrap();
    let buffer = printer
      .get_processor()
      .print_matches(matches, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    printer.after_print().unwrap();
    let json_str = get_text(&printer);
    let json: Vec<MatchJSON> = serde_json::from_str(&json_str).unwrap();
    let metas = &json[0].meta_variables.as_ref().expect("should exist");
    assert_eq!(metas.single["A"].text, "123");
    assert_eq!(metas.transformed["B"], "2");
  }

  const LABEL_TEXT: &str = "
labels:
  A:
    style: primary
    message: var label
";
  #[test]
  fn test_label() {
    let mut printer = make_test_printer(JsonStyle::Compact);
    let rule = get_rule_config(&format!("pattern: console.log($A)\n{LABEL_TEXT}"));
    let grep = SgLang::from(SupportLang::TypeScript).ast_grep("console.log(123)");
    let matches = grep.root().find_all(&rule.matcher).collect();
    printer.before_print().unwrap();
    let file = SimpleFile::new(Cow::Borrowed("test.ts"), "console.log(123)");
    let buffer = printer
      .get_processor()
      .print_rule(matches, file, &rule)
      .unwrap();
    printer.process(buffer).unwrap();
    printer.after_print().unwrap();
    let json_str = get_text(&printer);
    let json: Vec<RuleMatchJSON> = serde_json::from_str(&json_str).unwrap();
    let labels = &json[0].labels;
    assert_eq!(labels[0].message.unwrap(), "var label");
    assert_eq!(labels[0].style, LabelStyle::Primary);
    assert_eq!(labels[0].text, "123");
  }

  const META_TEXT: &str = "
metadata:
  A: test-meta
";
  #[test]
  fn test_metadata() {
    for included in [true, false] {
      let mut printer = make_test_printer(JsonStyle::Compact).include_metadata(included);
      let rule = get_rule_config(&format!("pattern: console.log($A)\n{META_TEXT}"));
      let grep = SgLang::from(SupportLang::TypeScript).ast_grep("console.log(123)");
      let matches = grep.root().find_all(&rule.matcher).collect();
      printer.before_print().unwrap();
      let file = SimpleFile::new(Cow::Borrowed("test.ts"), "console.log(123)");
      let buffer = printer
        .get_processor()
        .print_rule(matches, file, &rule)
        .unwrap();
      printer.process(buffer).unwrap();
      printer.after_print().unwrap();
      let json_str = get_text(&printer);
      let json: Vec<RuleMatchJSON> = serde_json::from_str(&json_str).unwrap();
      let metadata = &json[0].metadata;
      assert_eq!(metadata.is_some(), included);
    }
  }
}



================================================
FILE: crates/cli/src/print/mod.rs
================================================
mod cloud_print;
mod colored_print;
mod interactive_print;
mod json_print;

use crate::lang::SgLang;
use ast_grep_config::{Fixer, RuleConfig};
use ast_grep_core::{tree_sitter::StrDoc, Matcher, NodeMatch as SgNodeMatch};

use anyhow::Result;
use clap::ValueEnum;

use std::borrow::Cow;
use std::path::Path;

pub use cloud_print::{CloudPrinter, Platform};
pub use codespan_reporting::files::SimpleFile;
use codespan_reporting::term::termcolor::ColorChoice;
pub use colored_print::{ColoredPrinter, Heading, ReportStyle};
pub use interactive_print::InteractivePrinter;
pub use json_print::{JSONPrinter, JsonStyle};

type NodeMatch<'a> = SgNodeMatch<'a, StrDoc<SgLang>>;

/// A trait to process nodeMatches to diff/match output
/// it must be Send + 'static to be shared in worker thread
pub trait PrintProcessor<Output>: Send + Sync + 'static {
  fn print_rule(
    &self,
    matches: Vec<NodeMatch>,
    file: SimpleFile<Cow<str>, &str>,
    rule: &RuleConfig<SgLang>,
  ) -> Result<Output>;
  fn print_matches(&self, matches: Vec<NodeMatch>, path: &Path) -> Result<Output>;
  fn print_diffs(&self, diffs: Vec<Diff>, path: &Path) -> Result<Output>;
  fn print_rule_diffs(
    &self,
    diffs: Vec<(Diff, &RuleConfig<SgLang>)>,
    path: &Path,
  ) -> Result<Output>;
}

pub trait Printer {
  // processed item must be sent to printer thread
  type Processed: Send + 'static;
  type Processor: PrintProcessor<Self::Processed>;

  fn get_processor(&self) -> Self::Processor;
  /// Runs processed output from processor. This runs multiple times.
  fn process(&mut self, processed: Self::Processed) -> Result<()>;

  /// Run before all printing. One CLI will run this exactly once.
  #[inline]
  fn before_print(&mut self) -> Result<()> {
    Ok(())
  }
  /// Run after all printing. One CLI will run this exactly once.
  #[inline]
  fn after_print(&mut self) -> Result<()> {
    Ok(())
  }
}

#[derive(Clone)]
pub struct AdditionalFix {
  pub replacement: String,
  pub range: std::ops::Range<usize>,
  pub title: Option<String>,
}

#[derive(Clone)]
pub struct Diff<'n> {
  /// the matched node
  pub node_match: NodeMatch<'n>,
  /// string content for the replacement
  pub replacement: String,
  pub range: std::ops::Range<usize>,
  pub title: Option<String>,
  pub additional_fixes: Option<Box<[AdditionalFix]>>,
}

impl<'n> Diff<'n> {
  pub fn generate(node_match: NodeMatch<'n>, matcher: &impl Matcher, rewrite: &Fixer) -> Self {
    let edit = node_match.make_edit(matcher, rewrite);
    let replacement = String::from_utf8(edit.inserted_text).unwrap();
    Self {
      node_match,
      replacement,
      range: edit.position..edit.position + edit.deleted_length,
      additional_fixes: None,
      title: rewrite.title().map(|t| t.to_string()),
    }
  }

  pub fn multiple(
    node_match: NodeMatch<'n>,
    matcher: &impl Matcher,
    fixers: &[Fixer],
  ) -> Option<Self> {
    let fixer = fixers.first()?;
    let mut ret = Self::generate(node_match.clone(), matcher, fixer);
    // no additional fixes
    if fixers.len() == 1 {
      return Some(ret);
    }
    let additional = fixers
      .iter()
      .skip(1)
      .map(|f| {
        let edit = node_match.make_edit(matcher, f);
        AdditionalFix {
          replacement: String::from_utf8(edit.inserted_text).unwrap(),
          range: edit.position..edit.position + edit.deleted_length,
          title: f.title().map(|t| t.to_string()),
        }
      })
      .collect::<Vec<_>>()
      .into_boxed_slice();
    ret.additional_fixes = Some(additional);
    Some(ret)
  }

  pub fn into_list(mut self) -> Vec<Self> {
    let node_match = self.node_match.clone();
    let additional_fixes = self.additional_fixes.take();
    let mut ret = vec![self];
    ret.extend(additional_fixes.into_iter().flatten().map(|f| Self {
      node_match: node_match.clone(),
      replacement: f.replacement,
      range: f.range,
      additional_fixes: None,
      title: f.title,
    }));
    ret
  }

  /// Returns the root doc source code
  /// N.B. this can be different from node.text() because
  /// tree-sitter's root Node may not start at the begining
  pub fn get_root_text(&self) -> &'n str {
    self.node_match.root().get_text()
  }
}

#[derive(ValueEnum, Clone, Copy)]
pub enum ColorArg {
  /// Try to use colors, but don't force the issue. If the output is piped to another program,
  /// or the console isn't available on Windows, or if TERM=dumb, or if `NO_COLOR` is defined,
  /// for example, then don't use colors.
  Auto,
  /// Try very hard to emit colors. This includes emitting ANSI colors
  /// on Windows if the console API is unavailable (not implemented yet).
  Always,
  /// Ansi is like Always, except it never tries to use anything other
  /// than emitting ANSI color codes.
  Ansi,
  /// Never emit colors.
  Never,
}

impl ColorArg {
  pub fn should_use_color(self) -> bool {
    use colored_print::should_use_color;
    should_use_color(&self.into())
  }
}

impl From<ColorArg> for ColorChoice {
  fn from(arg: ColorArg) -> ColorChoice {
    use ColorArg::*;
    match arg {
      Auto => {
        if atty::is(atty::Stream::Stdout) {
          ColorChoice::Auto
        } else {
          ColorChoice::Never
        }
      }
      Always => ColorChoice::Always,
      Ansi => ColorChoice::AlwaysAnsi,
      Never => ColorChoice::Never,
    }
  }
}



================================================
FILE: crates/cli/src/print/colored_print/markdown.rs
================================================
use crate::lang::SgLang;
use ast_grep_config::RuleConfig;
use dashmap::DashMap;
use termimad::MadSkin;

/// A Markdown renderer that caches rendered notes to avoid recomputing.
pub struct Markdown {
  cache: DashMap<String, String>,
  skin: MadSkin,
}

impl Markdown {
  pub fn new(color: bool) -> Self {
    Self {
      cache: DashMap::new(),
      skin: Self::skin(color),
    }
  }

  pub fn render_note(&self, rule: &RuleConfig<SgLang>) -> Option<String> {
    let note = rule.note.as_ref()?;
    if let Some(cached) = self.cache.get(&rule.id) {
      return Some(cached.clone());
    }
    let rendered = self.skin.text(note, None).to_string();
    self.cache.insert(rule.id.clone(), rendered.clone());
    Some(rendered)
  }

  fn skin(color: bool) -> MadSkin {
    if !color {
      return MadSkin::no_style();
    }
    let is_light = is_light_terminal();
    if is_light {
      MadSkin::default_light()
    } else {
      MadSkin::default_dark()
    }
  }
}

fn is_light_terminal() -> bool {
  use terminal_light as tl;
  // prefer using env instead of escape sequences
  // https://github.com/ast-grep/ast-grep/issues/2114
  if let Ok(color) = tl::env::bg_color() {
    tl::Color::Ansi(color).luma() > 0.6
  } else {
    tl::luma().is_ok_and(|l| l > 0.6)
  }
}



================================================
FILE: crates/cli/src/print/colored_print/match_merger.rs
================================================
use super::NodeMatch;
use ast_grep_core::tree_sitter::DisplayContext;

/// merging overlapping/adjacent matches
/// adjacent matches: matches that starts or ends on the same line
pub struct MatchMerger<'a> {
  pub last_start_line: usize,
  pub last_end_line: usize,
  pub last_trailing: &'a str,
  pub last_end_offset: usize,
  pub context: (u16, u16),
}

impl<'a> MatchMerger<'a> {
  pub fn new(nm: &NodeMatch<'a>, (before, after): (u16, u16)) -> Self {
    let display = nm.display_context(before as usize, after as usize);
    let last_start_line = display.start_line + 1;
    let last_end_line = nm.end_pos().line() + 1;
    let last_trailing = display.trailing;
    let last_end_offset = nm.range().end;
    Self {
      last_start_line,
      last_end_line,
      last_end_offset,
      last_trailing,
      context: (before, after),
    }
  }

  // merge non-overlapping matches but start/end on the same line
  pub fn merge_adjacent(&mut self, nm: &NodeMatch<'a>) -> Option<usize> {
    let display = self.display(nm);
    let start_line = display.start_line;
    if start_line <= self.last_end_line + self.context.1 as usize {
      let last_end_offset = self.last_end_offset;
      self.last_end_offset = nm.range().end;
      self.last_trailing = display.trailing;
      Some(last_end_offset)
    } else {
      None
    }
  }

  pub fn conclude_match(&mut self, nm: &NodeMatch<'a>) {
    let display = self.display(nm);
    self.last_start_line = display.start_line + 1;
    self.last_end_line = nm.end_pos().line() + 1;
    self.last_trailing = display.trailing;
    self.last_end_offset = nm.range().end;
  }

  #[inline]
  pub fn check_overlapping(&self, nm: &NodeMatch<'a>) -> bool {
    let range = nm.range();

    // merge overlapping matches.
    // N.B. range.start == last_end_offset does not mean overlapping
    if range.start < self.last_end_offset {
      // guaranteed by pre-order
      debug_assert!(range.end <= self.last_end_offset);
      true
    } else {
      false
    }
  }

  pub fn display(&self, nm: &NodeMatch<'a>) -> DisplayContext<'a> {
    let (before, after) = self.context;
    nm.display_context(before as usize, after as usize)
  }
}



================================================
FILE: crates/cli/src/print/colored_print/styles.rs
================================================
// copied from termcolor
use super::{ColorChoice, DiffStyles};
use ansi_term::{Color, Style};
use anyhow::Result;

use std::borrow::Cow;
use std::env;
use std::io::Write;
use std::path::Path;

// warn[rule-id]: rule message here.
// |------------|------------------|
//    header            message
#[derive(Default, Clone)]
pub struct RuleStyle {
  // header style
  pub error: Style,
  pub warning: Style,
  pub info: Style,
  pub hint: Style,
  // message style
  pub message: Style,
  pub note: Style,
}

impl RuleStyle {
  fn colored() -> Self {
    Self {
      error: Color::Red.bold(),
      warning: Color::Yellow.bold(),
      info: Style::new().bold(),
      hint: Style::new().dimmed().bold(),
      note: Style::new().italic(),
      message: Style::new().bold(),
    }
  }
}

// TODO: use termcolor instead
#[derive(Default, Clone)]
pub struct PrintStyles {
  // print match color
  pub file_path: Style,
  pub matched: Style,
  pub rule: RuleStyle,
  pub diff: DiffStyles,
}

impl PrintStyles {
  fn colored() -> Self {
    Self {
      file_path: Color::Cyan.italic(),
      matched: Color::Red.bold(),
      diff: DiffStyles::colored(),
      rule: RuleStyle::colored(),
    }
  }
  fn no_color() -> Self {
    Self::default()
  }

  pub fn push_matched_to_ret(&self, ret: &mut String, matched: &str) -> Result<()> {
    use std::fmt::Write;
    // TODO: use intersperse
    let mut lines = matched.lines();
    if let Some(line) = lines.next() {
      write!(ret, "{}", self.matched.paint(line))?;
    } else {
      return Ok(());
    }
    for line in lines {
      ret.push('\n');
      write!(ret, "{}", self.matched.paint(line))?;
    }
    Ok(())
  }

  pub fn print_prelude(&self, path: &Path, writer: &mut impl Write) -> Result<()> {
    let file_path = adjust_dir_separator(path);
    writeln!(writer, "{}", self.file_path.paint(file_path))?;
    Ok(())
  }

  pub fn print_highlight<W: Write>(
    &self,
    ret: &str,
    start_line: usize,
    writer: &mut W,
  ) -> Result<usize> {
    let max_line_num = ret.lines().count() + start_line;
    // compute width for line number. log10(num) = the digit count of num - 1
    let width = max_line_num.checked_ilog10().unwrap_or(0) as usize + 1;
    for (offset, line) in ret.lines().enumerate() {
      // note the width modifier must be applied before coloring the line_num
      let line_num = format!("{:<width$}", start_line + offset);
      // otherwise the color ascii code will be counted in the width
      let ln_text = self.diff.line_num.paint(line_num);
      writeln!(writer, "{ln_text}│{line}")?;
    }
    Ok(width)
  }
}

#[cfg(not(target_os = "windows"))]
fn adjust_dir_separator(p: &Path) -> Cow<'_, str> {
  p.to_string_lossy()
}

// change \ to / on windows
#[cfg(target_os = "windows")]
fn adjust_dir_separator(p: &Path) -> String {
  const VERBATIM_PREFIX: &str = r#"\\?\"#;
  let p = p.display().to_string();
  if p.starts_with(VERBATIM_PREFIX) {
    p[VERBATIM_PREFIX.len()..].to_string()
  } else {
    p
  }
}

impl From<ColorChoice> for PrintStyles {
  fn from(color: ColorChoice) -> Self {
    if should_use_color(&color) {
      Self::colored()
    } else {
      Self::no_color()
    }
  }
}

/// Returns true if we should attempt to write colored output.
pub fn should_use_color(color: &ColorChoice) -> bool {
  match *color {
    // TODO: we should check if ansi is supported on windows console
    ColorChoice::Always => true,
    ColorChoice::AlwaysAnsi => true,
    ColorChoice::Never => false,
    // NOTE tty check is added
    ColorChoice::Auto => atty::is(atty::Stream::Stdout) && env_allows_color(),
  }
}

fn env_allows_color() -> bool {
  match env::var_os("TERM") {
    // On Windows, if TERM isn't set, then we should not automatically
    // assume that colors aren't allowed. This is unlike Unix environments
    None => {
      if !cfg!(windows) {
        return false;
      }
    }
    Some(k) => {
      if k == "dumb" {
        return false;
      }
    }
  }
  // If TERM != dumb, then the only way we don't allow colors at this
  // point is if NO_COLOR is set.
  if env::var_os("NO_COLOR").is_some() {
    return false;
  }
  true
}



================================================
FILE: crates/cli/src/print/colored_print/test.rs
================================================
#![cfg(test)]

use super::*;
use ast_grep_config::{from_yaml_string, Fixer, GlobalRules};
use ast_grep_language::{LanguageExt, SupportLang};
use codespan_reporting::term::termcolor::Buffer;

use std::fmt::Write;

fn make_test_printer() -> ColoredPrinter<Buffer> {
  ColoredPrinter::new(Buffer::no_color()).color(ColorChoice::Never)
}
fn get_text(printer: &ColoredPrinter<Buffer>) -> String {
  let buffer = &printer.writer;
  let bytes = buffer.as_slice();
  std::str::from_utf8(bytes)
    .expect("buffer should be valid utf8")
    .to_owned()
}

#[test]
fn test_empty_printer() {
  let printer = make_test_printer();
  assert_eq!(get_text(&printer), "");
}

// source, pattern, debug note
type Case<'a> = (&'a str, &'a str, &'a str);

const MATCHES_CASES: &[Case] = &[
  ("let a = 123", "a", "Simple match"),
  ("Some(1), Some(2), Some(3)", "Some", "Same line match"),
  (
    "Some(1), Some(2)\nSome(3), Some(4)",
    "Some",
    "Multiple line match",
  ),
  (
    "import a from 'b';import a from 'b';",
    "import a from 'b';",
    "immediate following but not overlapping",
  ),
  ("Some(Some(123))", "Some($A)", "overlapping"),
];
#[test]
fn test_print_matches() {
  let lang = SgLang::from(SupportLang::Tsx);
  for &(source, pattern, note) in MATCHES_CASES {
    // heading is required for CI
    let mut printer = make_test_printer().heading(Heading::Always);
    let grep = lang.ast_grep(source);
    let matches = grep.root().find_all(pattern).collect();
    let processor = printer.get_processor();
    let buffer = processor
      .print_matches(matches, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    let expected = source
      .lines()
      .enumerate()
      .fold(String::new(), |mut b, (i, l)| {
        _ = writeln!(b, "{}│{l}", i + 1);
        b
      });
    // append heading to expected
    let output = format!("test.tsx\n{expected}\n");
    assert_eq!(get_text(&printer), output, "{note}");
  }
}

#[test]
fn test_print_matches_without_heading() {
  let lang = SgLang::from(SupportLang::Tsx);
  for &(source, pattern, note) in MATCHES_CASES {
    let mut printer = make_test_printer().heading(Heading::Never);
    let grep = lang.ast_grep(source);
    let matches = grep.root().find_all(pattern).collect();
    let processor = printer.get_processor();
    let buffer = processor
      .print_matches(matches, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    // append heading to expected
    let output = source
      .lines()
      .enumerate()
      .fold(String::new(), |mut b, (i, e)| {
        _ = writeln!(b, "test.tsx:{}:{e}", i + 1);
        b
      });
    assert_eq!(get_text(&printer), output, "{note}");
  }
}

#[test]
fn test_print_rules() {
  let globals = GlobalRules::default();
  let lang = SgLang::from(SupportLang::TypeScript);
  for &(source, pattern, note) in MATCHES_CASES {
    let mut printer = make_test_printer()
      .heading(Heading::Never)
      .style(ReportStyle::Short);
    let grep = lang.ast_grep(source);
    let file = SimpleFile::new(Cow::Borrowed("test.tsx"), source);
    let rule = from_yaml_string(
      &format!(
        r"
id: test-id
message: test rule
severity: info
language: TypeScript
rule:
  pattern: {pattern}"
      ),
      &globals,
    )
    .expect("should parse")
    .pop()
    .unwrap();
    let matcher = rule.get_matcher(&globals).expect("should parse");
    let matches = grep.root().find_all(&matcher).collect();
    let processor = printer.get_processor();
    let buffer = processor
      .print_rule(matches, file, &rule)
      .expect("test only");
    printer.process(buffer).expect("test only");
    let text = get_text(&printer);
    assert!(text.contains("test.tsx"), "{note}");
    assert!(text.contains("note[test-id]"), "{note}");
    assert!(text.contains("test rule"), "{note}");
  }
}

// source, pattern, rewrite, debug note
type DiffCase<'a> = (&'a str, &'a str, &'a str, &'a str);

const DIFF_CASES: &[DiffCase] = &[
  ("let a = 123", "a", "b", "Simple match"),
  (
    "Some(1), Some(2), Some(3)",
    "Some",
    "Any",
    "Same line match",
  ),
  (
    "Some(1), Some(2)\nSome(3), Some(4)",
    "Some",
    "Any",
    "Multiple line match",
  ),
  (
    "import a from 'b';import a from 'b';",
    "import a from 'b';",
    "",
    "immediate following but not overlapping",
  ),
  (
    "\n\ntest",
    "test",
    "rest",
    // https://github.com/ast-grep/ast-grep/issues/517
    "leading empty space",
  ),
];

#[test]
fn test_print_diffs() {
  for &(source, pattern, rewrite, note) in DIFF_CASES {
    // heading is required for CI
    let mut printer = make_test_printer().heading(Heading::Always);
    let lang = SgLang::from(SupportLang::Tsx);
    let fixer = Fixer::from_str(rewrite, &lang).expect("should work");
    let grep = lang.ast_grep(source);
    let root = grep.root();
    let matches = root.find_all(pattern);
    let diffs = matches
      .map(|n| Diff::generate(n, &pattern, &fixer))
      .collect();
    let buffer = printer
      .get_processor()
      .print_diffs(diffs, "test.tsx".as_ref())
      .unwrap();
    printer.process(buffer).unwrap();
    assert!(get_text(&printer).contains(rewrite), "{note}");
  }
}

fn test_overlap_print_impl(heading: Heading) {
  let src = "
    Some(1)
    // empty
    Some(2)
  ";
  let mut printer = make_test_printer().heading(heading).context((1, 1));
  let lang = SgLang::from(SupportLang::Tsx);
  let grep = lang.ast_grep(src);
  let matches = grep.root().find_all("Some($A)").collect();
  let buffer = printer
    .get_processor()
    .print_matches(matches, "test.tsx".as_ref())
    .unwrap();
  printer.process(buffer).unwrap();
  let text = get_text(&printer);
  // Overlapped match should only print once.
  assert_eq!(text.matches("Some(1)").count(), 1);
  assert_eq!(text.matches("empty").count(), 1);
  assert_eq!(text.matches("Some(2)").count(), 1);
}

#[test]
fn test_overlap_print() {
  // test_overlap_print_impl(Heading::Always);
  test_overlap_print_impl(Heading::Never);
  // test_overlap_print_impl(Heading::Auto);
}

fn test_non_overlap_print_impl(heading: Heading) {
  let src = "
    Some(1)
    // empty
    Some(2)
  ";
  let mut printer = make_test_printer().heading(heading);
  let lang = SgLang::from(SupportLang::Tsx);
  let grep = lang.ast_grep(src);
  let matches = grep.root().find_all("Some($A)").collect();
  let buffer = printer
    .get_processor()
    .print_matches(matches, "test.tsx".as_ref())
    .unwrap();
  printer.process(buffer).unwrap();
  let text = get_text(&printer);
  assert_eq!(text.matches("Some(1)").count(), 1);
  assert!(!text.contains("empty"));
  assert_eq!(text.matches("Some(2)").count(), 1);
}

#[test]
fn test_non_overlap_print() {
  test_non_overlap_print_impl(Heading::Always);
  test_non_overlap_print_impl(Heading::Never);
  test_non_overlap_print_impl(Heading::Auto);
}

fn get_printed_text(mut printer: ColoredPrinter<Buffer>, diff_case: &DiffCase) -> String {
  let (source, pattern, rewrite, _) = diff_case;
  let globals = GlobalRules::default();
  let grep = SgLang::from(SupportLang::TypeScript).ast_grep(source);
  let rule = from_yaml_string(
    &format!(
      r"
id: test-id
message: test rule
severity: info
language: TypeScript
rule:
  pattern: {pattern}
fix: '{rewrite}'"
    ),
    &globals,
  )
  .expect("should parse")
  .pop()
  .unwrap();
  let matcher = rule.get_matcher(&globals).expect("should parse");
  let fixer = matcher.fixer.first().expect("should have fixer");
  let root = grep.root();
  let matches = root.find_all(&matcher);
  let diffs = matches.map(|n| (Diff::generate(n, &pattern, fixer), &rule));
  let buffer = printer
    .get_processor()
    .print_rule_diffs(diffs.collect(), Path::new("test.tsx"))
    .expect("test only");
  printer.process(buffer).expect("test only");
  get_text(&printer)
}

#[test]
fn test_print_rule_diffs() {
  for diff_case in DIFF_CASES {
    let printer = make_test_printer()
      .heading(Heading::Never)
      .style(ReportStyle::Rich);
    let text = get_printed_text(printer, diff_case);
    let (_, _, rewrite, note) = diff_case;
    assert!(text.contains("test.tsx"), "{note}");
    assert!(text.contains("note[test-id]"), "{note}");
    assert!(text.contains(rewrite), "{note}");
  }
}

#[test]
fn test_print_rule_diffs_short() {
  for diff_case in DIFF_CASES {
    let printer = make_test_printer()
      .heading(Heading::Never)
      .style(ReportStyle::Short);
    let text = get_printed_text(printer, diff_case);
    let (_, _, rewrite, note) = diff_case;
    assert!(text.contains("test.tsx:"), "{note}");
    assert!(text.contains("note[test-id]"), "{note}");
    assert!(rewrite.is_empty() || !text.contains(rewrite), "{note}");
  }
}

#[test]
fn test_before_after() {
  let src = "
    // b 3
    // b 2
    // b 1
    Some(match)
    // a 1
    // a 2
    // a 3
  ";
  for b in 0..3 {
    for a in 0..3 {
      let mut printer = make_test_printer().context((b, a));
      let lang = SgLang::from(SupportLang::Tsx);
      let grep = lang.ast_grep(src);
      let matches = grep.root().find_all("Some($A)").collect();
      let buffer = printer
        .get_processor()
        .print_matches(matches, "test.tsx".as_ref())
        .unwrap();
      printer.process(buffer).unwrap();
      let text = get_text(&printer);
      // Overlapped match should only print once.
      assert!(text.contains("Some(match)"));
      for i in 1..3 {
        let contains_before = text.contains(&format!("b {i}"));
        let b_in_bound = i <= b;
        let contains_after = text.contains(&format!("a {i}"));
        let a_in_bound = i <= a;
        // text occurrence should be the same as inbound check
        assert_eq!(contains_before, b_in_bound);
        assert_eq!(contains_after, a_in_bound);
      }
    }
  }
}



================================================
FILE: crates/cli/src/utils/args.rs
================================================
use crate::lang::SgLang;
use crate::print::{ColorArg, JsonStyle};
use crate::utils::ErrorContext as EC;
use crate::utils::Granularity;

use anyhow::{Context, Result};
use clap::{Args, ValueEnum};
use ignore::{
  overrides::{Override, OverrideBuilder},
  WalkBuilder, WalkParallel,
};
use regex::Regex;
use serde::{Deserialize, Serialize};

use std::path::PathBuf;

/// input related options
#[derive(Args)]
pub struct InputArgs {
  /// The paths to search. You can provide multiple paths separated by spaces.
  #[clap(value_parser, default_value = ".")]
  pub paths: Vec<PathBuf>,

  /// Follow symbolic links.
  ///
  /// This flag instructs ast-grep to follow symbolic links while traversing
  /// directories. This behavior is disabled by default. Note that ast-grep will
  /// check for symbolic link loops and report errors if it finds one. ast-grep will
  /// also report errors for broken links.
  #[clap(long)]
  pub follow: bool,

  /// Do not respect hidden file system or ignore files (.gitignore, .ignore, etc.).
  ///
  /// You can suppress multiple ignore files by passing `no-ignore` multiple times.
  #[clap(long, action = clap::ArgAction::Append, value_name = "FILE_TYPE")]
  pub no_ignore: Vec<IgnoreFile>,

  /// Enable search code from StdIn.
  ///
  /// Use this if you need to take code stream from standard input.
  #[clap(long)]
  pub stdin: bool,

  /// Include or exclude file paths.
  ///
  /// Include or exclude files and directories for searching that match the
  /// given glob. This always overrides any other ignore logic. Multiple glob
  /// flags may be used. Globbing rules match .gitignore globs. Precede a
  /// glob with a ! to exclude it. If multiple globs match a file or
  /// directory, the glob given later in the command line takes precedence.
  #[clap(long, action = clap::ArgAction::Append)]
  pub globs: Vec<String>,

  /// Set the approximate number of threads to use.
  ///
  /// This flag sets the approximate number of threads to use. A value of 0
  /// (which is the default) causes ast-grep to choose the thread count using
  /// heuristics.
  #[clap(short = 'j', long, default_value = "0", value_name = "NUM")]
  pub threads: usize,
}

impl InputArgs {
  fn get_threads(&self) -> usize {
    if self.threads == 0 {
      std::thread::available_parallelism()
        .map_or(1, |n| n.get())
        .min(12)
    } else {
      self.threads
    }
  }

  fn build_globs(&self) -> Result<Override> {
    let cwd = std::env::current_dir()?;
    let mut builder = OverrideBuilder::new(cwd);
    for glob in &self.globs {
      builder.add(glob)?;
    }
    Ok(builder.build()?)
  }

  // using `overrides` before `types` is okay
  // because ignore builder's method is a simple setter
  fn walk_basic(&self) -> Result<WalkBuilder> {
    let threads = self.get_threads();
    let globs = self.build_globs().context(EC::BuildGlobs)?;
    let mut walk_builder = NoIgnore::disregard(&self.no_ignore).walk(&self.paths);
    walk_builder
      .threads(threads)
      .follow_links(self.follow)
      .overrides(globs);
    Ok(walk_builder)
  }

  pub fn walk(&self) -> Result<WalkParallel> {
    Ok(self.walk_basic()?.build_parallel())
  }

  pub fn walk_langs(&self, langs: impl Iterator<Item = SgLang>) -> Result<WalkParallel> {
    let types = SgLang::file_types_for_langs(langs);
    let mut builder = self.walk_basic()?;
    Ok(builder.types(types).build_parallel())
  }

  pub fn walk_lang(&self, lang: SgLang) -> Result<WalkParallel> {
    let types = lang.augmented_file_type();
    let mut builder = self.walk_basic()?;
    Ok(builder.types(types).build_parallel())
  }
}

/// output related options
#[derive(Args)]
pub struct OutputArgs {
  /// Start interactive edit session.
  ///
  /// You can confirm the code change and apply it to files selectively,
  /// or you can open text editor to tweak the matched code.
  /// Note that code rewrite only happens inside a session.
  #[clap(short, long)]
  pub interactive: bool,

  /// Apply all rewrite without confirmation if true.
  #[clap(short = 'U', long)]
  pub update_all: bool,

  /// Output matches in structured JSON.
  ///
  /// If this flag is set, ast-grep will output matches in JSON format.
  /// You can pass optional value to this flag by using `--json=<STYLE>` syntax
  /// to further control how JSON object is formatted and printed. ast-grep will `pretty`-print JSON if no value is passed.
  /// Note, the json flag must use `=` to specify its value.
  /// It conflicts with interactive.
  #[clap(
      long,
      conflicts_with = "interactive",
      value_name="STYLE",
      num_args(0..=1),
      require_equals = true,
      default_missing_value = "pretty"
  )]
  pub json: Option<JsonStyle>,

  /// Controls output color.
  ///
  /// This flag controls when to use colors. The default setting is 'auto', which
  /// means ast-grep will try to guess when to use colors. If ast-grep is
  /// printing to a terminal, then it will use colors, but if it is redirected to a
  /// file or a pipe, then it will suppress color output. ast-grep will also suppress
  /// color output in some other circumstances. For example, no color will be used
  /// if the TERM environment variable is not set or set to 'dumb'.
  #[clap(long, default_value = "auto", value_name = "WHEN")]
  pub color: ColorArg,

  /// Inspect information for file/rule discovery and scanning.
  ///
  /// This flag helps user to observe ast-grep's internal filtering of files and rules.
  /// Inspection will output how many and why files and rules are scanned and skipped.
  /// Inspection outputs to stderr and does not affect the result of the search.
  #[clap(long, default_value = "nothing", value_name = "GRANULARITY")]
  pub inspect: Granularity,
}

impl OutputArgs {
  // either explicit interactive or implicit update_all
  pub fn needs_interactive(&self) -> bool {
    self.interactive || self.update_all
  }
}

/// context related options
#[derive(Args)]
pub struct ContextArgs {
  /// Show NUM lines after each match.
  ///
  /// It conflicts with both the -C/--context flag.
  #[clap(
    short = 'A',
    long,
    default_value = "0",
    conflicts_with = "context",
    value_name = "NUM"
  )]
  pub after: u16,

  /// Show NUM lines before each match.
  ///
  /// It conflicts with both the -C/--context flag.
  #[clap(
    short = 'B',
    long,
    default_value = "0",
    conflicts_with = "context",
    value_name = "NUM"
  )]
  pub before: u16,

  /// Show NUM lines around each match.
  ///
  /// This is equivalent to providing both the
  /// -B/--before and -A/--after flags with the same value.
  /// It conflicts with both the -B/--before and -A/--after flags.
  #[clap(short = 'C', long, default_value = "0", value_name = "NUM")]
  pub context: u16,
}

impl ContextArgs {
  pub fn get(&self) -> (u16, u16) {
    if self.context > 0 {
      (self.context, self.context)
    } else {
      (self.before, self.after)
    }
  }
}

/// File types to ignore, this is mostly the same as ripgrep.
#[derive(Clone, Copy, Deserialize, Serialize, ValueEnum)]
pub enum IgnoreFile {
  /// Search hidden files and directories. By default, hidden files and directories are skipped.
  Hidden,
  /// Don't respect .ignore files.
  /// This does *not* affect whether ast-grep will ignore files and directories whose names begin with a dot.
  /// For that, use --no-ignore hidden.
  Dot,
  /// Don't respect ignore files that are manually configured for the repository such as git's '.git/info/exclude'.
  Exclude,
  /// Don't respect ignore files that come from "global" sources such as git's
  /// `core.excludesFile` configuration option (which defaults to `$HOME/.config/git/ignore`).
  Global,
  /// Don't respect ignore files (.gitignore, .ignore, etc.) in parent directories.
  Parent,
  /// Don't respect version control ignore files (.gitignore, etc.).
  /// This implies --no-ignore parent for VCS files.
  /// Note that .ignore files will continue to be respected.
  Vcs,
}

#[derive(Default)]
pub struct NoIgnore {
  disregard_hidden: bool,
  disregard_parent: bool,
  disregard_dot: bool,
  disregard_vcs: bool,
  disregard_global: bool,
  disregard_exclude: bool,
}

impl NoIgnore {
  pub fn disregard(ignores: &[IgnoreFile]) -> Self {
    let mut ret = NoIgnore::default();
    use IgnoreFile::*;
    for ignore in ignores {
      match ignore {
        Hidden => ret.disregard_hidden = true,
        Dot => ret.disregard_dot = true,
        Exclude => ret.disregard_exclude = true,
        Global => ret.disregard_global = true,
        Parent => ret.disregard_parent = true,
        Vcs => ret.disregard_vcs = true,
      }
    }
    ret
  }

  pub fn walk(&self, path: &[PathBuf]) -> WalkBuilder {
    let mut paths = path.iter();
    let mut builder = WalkBuilder::new(paths.next().expect("non empty"));
    for path in paths {
      builder.add(path);
    }
    builder
      .hidden(!self.disregard_hidden)
      .parents(!self.disregard_parent)
      .ignore(!self.disregard_dot)
      .git_global(!self.disregard_vcs && !self.disregard_global)
      .git_ignore(!self.disregard_vcs)
      .git_exclude(!self.disregard_vcs && !self.disregard_exclude);
    builder
  }
}

/// CLI args to overwrite rule configuration
#[derive(Args, Debug)]
pub struct OverwriteArgs {
  /// Scan the codebase with rules with ids matching REGEX.
  ///
  /// This flags conflicts with --rule. It is useful to scan with a subset of rules from a large
  /// set of rule definitions within a project.
  #[clap(long, conflicts_with = "rule", value_name = "REGEX")]
  pub filter: Option<Regex>,
  /// Set rule severity to error
  ///
  /// This flag sets the specified RULE_ID's severity to error. You can specify multiple rules by using the flag multiple times,
  /// e.g., `--error=RULE_1 --error=RULE_2`. If no RULE_ID is provided, all rules will be set to error, e.g., `--error`.
  /// Note, this flag must use `=` to specify its value.
  #[clap(long, action = clap::ArgAction::Append, value_name = "RULE_ID", num_args(0..), require_equals = true)]
  pub error: Option<Vec<String>>,
  /// Set rule severity to warning
  ///
  /// This flag sets the specified RULE_ID's severity to warning. You can specify multiple rules by using the flag multiple times.
  /// If no RULE_ID is provided, all rules will be set to warning.
  /// Note, this flag must use `=` to specify its value.
  #[clap(long, action = clap::ArgAction::Append, value_name = "RULE_ID", num_args(0..), require_equals = true)]
  pub warning: Option<Vec<String>>,
  /// Set rule severity to info
  ///
  /// This flag sets the specified RULE_ID's severity to info. You can specify multiple rules by using the flag multiple times.
  /// If no RULE_ID is provided, all rules will be set to info.
  /// Note, this flag must use `=` to specify its value.
  #[clap(long, action = clap::ArgAction::Append, value_name = "RULE_ID", num_args(0..), require_equals = true)]
  pub info: Option<Vec<String>>,
  /// Set rule severity to hint
  ///
  /// This flag sets the specified RULE_ID's severity to hint. You can specify multiple rules by using the flag multiple times.
  /// If no RULE_ID is provided, all rules will be set to hint.
  /// Note, this flag must use `=` to specify its value.
  #[clap(long, action = clap::ArgAction::Append, value_name = "RULE_ID", num_args(0..), require_equals = true)]
  pub hint: Option<Vec<String>>,
  /// Turn off rule
  ///
  /// This flag turns off the specified RULE_ID. You can disable multiple rules by using the flag multiple times.
  /// If no RULE_ID is provided, all rules will be turned off.
  /// Note, this flag must use `=` to specify its value.
  #[clap(long, action = clap::ArgAction::Append, value_name = "RULE_ID", num_args(0..), require_equals = true)]
  pub off: Option<Vec<String>>,
}

impl OverwriteArgs {
  /// Returns true if none rule is turned off on CLI nor filtered out
  pub fn include_all_rules(&self) -> bool {
    self.filter.is_none() && self.off.is_none()
  }
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_build_globs() {
    let input = InputArgs {
      paths: vec![],
      follow: true,
      no_ignore: vec![IgnoreFile::Dot, IgnoreFile::Exclude],
      stdin: false,
      globs: vec!["*.rs".to_string(), "!*.toml".to_string()],
      threads: 0,
    };
    assert!(input.build_globs().is_ok());
    let input = InputArgs {
      paths: vec![],
      follow: true,
      no_ignore: vec![IgnoreFile::Dot, IgnoreFile::Exclude],
      stdin: false,
      globs: vec!["*.{rs".to_string()],
      threads: 0,
    };
    assert!(input.build_globs().is_err());
  }
}



================================================
FILE: crates/cli/src/utils/debug_query.rs
================================================
use crate::lang::SgLang;
use ansi_term::Style;
use ast_grep_core::{
  matcher::PatternNode, meta_var::MetaVariable, tree_sitter::TSLanguage, MatchStrictness, Pattern,
};
use ast_grep_language::LanguageExt;
use clap::ValueEnum;
use tree_sitter as ts;

#[derive(Clone, Copy, PartialEq, Eq, ValueEnum)]
pub enum DebugFormat {
  /// Print the query parsed in Pattern format
  Pattern,
  /// Print the query in tree-sitter AST format, only named nodes are shown
  Ast,
  /// Print the query in tree-sitter CST format, both named and unnamed nodes are shown
  Cst,
  /// Print the query in S-expression format
  Sexp,
}
impl DebugFormat {
  pub fn debug_pattern(&self, pattern: &Pattern, lang: SgLang, colored: bool) {
    match self {
      DebugFormat::Pattern => {
        let lang = lang.get_ts_language();
        let mut ret = String::new();
        let fmt = DumpFmt::named(colored);
        if dump_pattern(&pattern.node, &pattern.strictness, &lang, &fmt, 0, &mut ret).is_ok() {
          eprintln!("Debug Pattern:\n{ret}");
        } else {
          eprintln!("unexpected error in writing pattern string");
        }
      }
      DebugFormat::Sexp | DebugFormat::Ast | DebugFormat::Cst => {
        debug_assert!(false, "debug_pattern can only be called with pattern")
      }
    }
  }

  pub fn debug_tree(&self, src: &str, lang: SgLang, colored: bool) {
    let root = lang.ast_grep(src);
    match self {
      DebugFormat::Pattern => {
        debug_assert!(false, "debug_tree cannot be called with Pattern")
      }
      DebugFormat::Sexp => {
        eprintln!("Debug Sexp:\n{}", root.root().get_inner_node().to_sexp());
      }
      DebugFormat::Ast => {
        let dumped = dump_node(root.root().get_inner_node());
        eprintln!("Debug AST:\n{}", dumped.ast(colored));
      }
      DebugFormat::Cst => {
        let dumped = dump_node(root.root().get_inner_node());
        eprintln!("Debug CST:\n{}", dumped.cst(colored));
      }
    }
  }
}

fn dump_pattern(
  pattern: &PatternNode,
  strictness: &MatchStrictness,
  lang: &TSLanguage,
  style: &DumpFmt,
  indent: usize,
  ret: &mut String,
) -> FmtResult {
  let indent_str = "  ".repeat(indent);
  match pattern {
    PatternNode::MetaVar { meta_var } => {
      let meta_var = match meta_var {
        MetaVariable::Capture(name, _) => format!("${name}"),
        MetaVariable::MultiCapture(name) => format!("$$${name}"),
        MetaVariable::Multiple => "$$$".to_string(),
        MetaVariable::Dropped(_) => "$_".to_string(),
      };
      let meta_var = style.kind_style.paint(meta_var);
      writeln!(
        ret,
        "{indent_str}{} {meta_var}",
        style.field_style.paint("MetaVar")
      )?;
    }
    PatternNode::Terminal {
      text,
      kind_id,
      is_named,
    } => {
      if !*is_named {
        if matches!(
          strictness,
          MatchStrictness::Cst | MatchStrictness::Smart | MatchStrictness::Template
        ) {
          writeln!(ret, "{indent_str}{text}")?;
        }
        return Ok(());
      }
      let kind = if matches!(strictness, MatchStrictness::Template) {
        text
      } else {
        lang.node_kind_for_id(*kind_id).unwrap()
      };
      let kind = style.kind_style.paint(kind);
      let text = if matches!(
        strictness,
        MatchStrictness::Signature | MatchStrictness::Template
      ) {
        ""
      } else {
        text
      };
      writeln!(ret, "{indent_str}{kind} {text}")?;
    }
    PatternNode::Internal { kind_id, children } => {
      if matches!(strictness, MatchStrictness::Template) {
        writeln!(ret, "{indent_str}(node)")?;
      } else {
        let kind = lang.node_kind_for_id(*kind_id).unwrap();
        let kind = style.kind_style.paint(kind);
        writeln!(ret, "{indent_str}{kind}")?;
      };
      for child in children {
        dump_pattern(child, strictness, lang, style, indent + 1, ret)?;
      }
    }
  }
  Ok(())
}

pub struct DumpNode {
  field: Option<String>,
  kind: String,
  start: Pos,
  end: Pos,
  is_named: bool,
  children: Vec<DumpNode>,
}

struct DumpFmt {
  kind_style: Style,
  field_style: Style,
  named_only: bool,
}

impl DumpFmt {
  fn named(colored: bool) -> Self {
    let style = Style::new();
    Self {
      kind_style: if colored { style.bold() } else { style },
      field_style: if colored { style.italic() } else { style },
      named_only: true,
    }
  }
  fn all(colored: bool) -> Self {
    let style = Style::new();
    Self {
      kind_style: if colored { style.bold() } else { style },
      field_style: if colored { style.italic() } else { style },
      named_only: false,
    }
  }
}

use std::fmt::{Result as FmtResult, Write};
impl DumpNode {
  pub fn ast(&self, colored: bool) -> String {
    let mut result = String::new();
    let fmt = DumpFmt::named(colored);
    self
      .helper(&mut result, &fmt, 0)
      .expect("should write string");
    result
  }

  pub fn cst(&self, colored: bool) -> String {
    let mut result = String::new();
    let fmt = DumpFmt::all(colored);
    self
      .helper(&mut result, &fmt, 0)
      .expect("should write string");
    result
  }

  fn helper(&self, result: &mut String, fmt: &DumpFmt, depth: usize) -> FmtResult {
    let indent = "  ".repeat(depth);
    if fmt.named_only && !self.is_named {
      return Ok(());
    }
    write!(result, "{indent}")?;
    if let Some(field) = &self.field {
      let field = fmt.field_style.paint(field);
      write!(result, "{field}: ")?;
    }
    write!(result, "{}", fmt.kind_style.paint(&self.kind))?;
    writeln!(result, " ({:?})-({:?})", self.start, self.end)?;
    for child in &self.children {
      child.helper(result, fmt, depth + 1)?;
    }
    Ok(())
  }
}

pub struct Pos {
  row: usize,
  column: usize,
}

impl std::fmt::Debug for Pos {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{},{}", self.row, self.column)
  }
}

impl From<ts::Point> for Pos {
  #[inline]
  fn from(pt: ts::Point) -> Self {
    Pos {
      row: pt.row,
      column: pt.column,
    }
  }
}

fn dump_node(node: ts::Node) -> DumpNode {
  let mut cursor = node.walk();
  let mut nodes = vec![];
  dump_one_node(&mut cursor, &mut nodes);
  nodes.pop().expect("should have at least one node")
}

fn dump_one_node(cursor: &mut ts::TreeCursor, target: &mut Vec<DumpNode>) {
  let node = cursor.node();
  let kind = if node.is_missing() {
    format!("MISSING {}", node.kind())
  } else {
    node.kind().to_string()
  };
  let start = node.start_position().into();
  let end = node.end_position().into();
  let field = cursor.field_name().map(|c| c.to_string());
  let mut children = vec![];
  if cursor.goto_first_child() {
    dump_nodes(cursor, &mut children);
    cursor.goto_parent();
  }
  target.push(DumpNode {
    field,
    kind,
    start,
    end,
    children,
    is_named: node.is_named(),
  })
}

fn dump_nodes(cursor: &mut ts::TreeCursor, target: &mut Vec<DumpNode>) {
  loop {
    dump_one_node(cursor, target);
    if !cursor.goto_next_sibling() {
      break;
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_language::{TypeScript, C};
  const DUMPED: &str = r#"
program (0,0)-(0,11)
  variable_declaration (0,0)-(0,11)
    variable_declarator (0,4)-(0,11)
      name: identifier (0,4)-(0,5)
      value: number (0,8)-(0,11)"#;
  #[test]
  fn test_dump_node() {
    let lang = SgLang::Builtin(TypeScript.into());
    let root = lang.ast_grep("var a = 123");
    let dumped = dump_node(root.root().get_inner_node());
    assert_eq!(DUMPED.trim(), dumped.ast(false).trim());
  }

  const MISSING: &str = r#"
translation_unit (0,0)-(0,9)
  declaration (0,0)-(0,9)
    type: primitive_type (0,0)-(0,3)
    declarator: init_declarator (0,4)-(0,9)
      declarator: identifier (0,4)-(0,5)
      = (0,6)-(0,7)
      value: number_literal (0,8)-(0,9)
    MISSING ; (0,9)-(0,9)"#;
  #[test]
  fn test_missing_node() {
    let lang = SgLang::Builtin(C.into());
    let root = lang.ast_grep("int a = 1");
    let dumped = dump_node(root.root().get_inner_node());
    assert_eq!(MISSING.trim(), dumped.cst(false).trim());
  }
}



================================================
FILE: crates/cli/src/utils/error_context.rs
================================================
use ansi_term::{Color, Style};
use anyhow::{Error, Result};

use crossterm::tty::IsTty;
use std::fmt;
use std::path::PathBuf;

const DOC_SITE_HOST: &str = "https://ast-grep.github.io";
const PATTERN_GUIDE: Option<&str> = Some("/guide/pattern-syntax.html");
const CONFIG_GUIDE: Option<&str> = Some("/guide/rule-config.html");
const CONFIG_REFERENCE: Option<&str> = Some("/reference/sgconfig.html");
const PROJECT_GUIDE: Option<&str> = Some("/guide/scan-project.html");
const TOOL_OVERVIEW: Option<&str> = Some("/guide/tooling-overview.html#parse-code-from-stdin");
const CLI_USAGE: Option<&str> = Some("/reference/cli.html");
const TEST_GUIDE: Option<&str> = Some("/guide/test-rule.html");
const UTIL_GUIDE: Option<&str> = Some("/guide/rule-config/utility-rule.html");
const EDITOR_INTEGRATION: Option<&str> = Some("/guide/editor-integration.html");
const LANGUAGE_LIST: Option<&str> = Some("/reference/languages.html");
const PLAYGROUND: Option<&str> = Some("/playground.html");
const CUSTOM_LANG_GUIDE: Option<&str> = Some("/advanced/custom-language.html");
const UTILITY_RULE: Option<&str> = Some("/guide/rule-config/utility-rule.html");

/// AppError stands for ast-grep command line usage.
/// It provides abstraction around exit code, context,
/// message, potential fix and reference link.
#[derive(Debug, Clone)]
pub enum ErrorContext {
  // Config
  ReadConfiguration,
  ParseConfiguration,
  WalkRuleDir(PathBuf),
  ReadRule(PathBuf),
  ParseRule(PathBuf),
  ParseTest(PathBuf),
  InvalidGlobalUtils,
  GlobPattern,
  BuildGlobs,
  UnrecognizableLanguage(String),
  LangInjection,
  CustomLanguage,
  // Run
  ParsePattern,
  LanguageNotSpecified,
  StdInIsNotInteractive,
  PatternHasError,
  // Scan
  DiagnosticError(usize),
  RuleNotSpecified,
  RuleNotFound(String),
  // LSP
  StartLanguageServer,
  // Edit
  OpenEditor,
  WriteFile(PathBuf),
  // Test
  TestFail(String),
  TestSnapshotMismatch(String),
  // New
  ProjectAlreadyExist,
  ProjectNotExist,
  FileAlreadyExist(PathBuf),
  NoTestDirConfigured,
  NoUtilDirConfigured,
  InsufficientCLIArgument(&'static str),
  // Completions
  CannotInferShell,
  // Interactive
  ExitInteractiveEditing,
}

impl ErrorContext {
  fn exit_code(&self) -> i32 {
    use ErrorContext::*;
    // reference: https://mariadb.com/kb/en/operating-system-error-codes/
    match self {
      DiagnosticError(_) => 1,
      ProjectNotExist | LanguageNotSpecified | RuleNotSpecified | RuleNotFound(_) => 2,
      TestFail(_) | TestSnapshotMismatch(_) => 3,
      NoTestDirConfigured | NoUtilDirConfigured => 4,
      ReadConfiguration | ReadRule(_) | WalkRuleDir(_) | WriteFile(_) => 5,
      StdInIsNotInteractive => 6,
      ParseTest(_) | ParseRule(_) | ParseConfiguration | ParsePattern | InvalidGlobalUtils
      | LangInjection => 8,
      GlobPattern | BuildGlobs => 9,
      CannotInferShell => 10,
      ProjectAlreadyExist | FileAlreadyExist(_) => 17,
      InsufficientCLIArgument(_) => 22,
      UnrecognizableLanguage(_) => 33,
      CustomLanguage => 79,
      OpenEditor | StartLanguageServer => 126,
      // soft error
      PatternHasError | ExitInteractiveEditing => 0,
    }
  }

  fn is_soft_error(&self) -> bool {
    self.exit_code() == 0
  }
}

impl fmt::Display for ErrorContext {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let err_msg = ErrorMessage::from_context(self);
    write!(f, "{}", err_msg.title)
  }
}

// guideline: https://twitter.com/mgechev/status/1405019854906834944
// * Use consistent terminology
// * Be clear and concise
// * Provide context
// * Suggest a fix
struct ErrorMessage {
  title: String,
  description: String,
  link: Option<&'static str>,
}

impl ErrorMessage {
  fn new<T: ToString, D: ToString>(title: T, description: D, link: Option<&'static str>) -> Self {
    Self {
      title: title.to_string(),
      description: description.to_string(),
      link,
    }
  }

  fn from_context(ctx: &ErrorContext) -> ErrorMessage {
    use ErrorContext::*;
    match ctx {
      ReadConfiguration => Self::new(
        "Cannot read configuration.",
        "Please add an sgconfig.yml configuration file in the project root to run the scan command.",
        CONFIG_GUIDE,
      ),
      ParseConfiguration => Self::new(
        "Cannot parse configuration",
        "The sgconfig.yml is not a valid configuration file. Please refer to doc and fix the error.",
        CONFIG_REFERENCE,
      ),
      WalkRuleDir(dir) => Self::new(
        format!("Cannot read rule directory {}", dir.display()),
        "The rule directory cannot be read or traversed",
        None,
      ),
      ReadRule(file) => Self::new(
        format!("Cannot read rule {}", file.display()),
        "The rule file either does not exist or cannot be opened.",
        CONFIG_GUIDE,
      ),
      ParseRule(file) => Self::new(
        format!("Cannot parse rule {}", file.display()),
        "The file is not a valid ast-grep rule. Please refer to doc and fix the error.",
        CONFIG_GUIDE,
      ),
      GlobPattern => Self::new(
        "Cannot parse glob pattern in config",
        "The pattern in files/ignore is not a valid glob. Please refer to doc and fix the error.",
        CONFIG_GUIDE,
      ),
      BuildGlobs => Self::new(
        "Cannot build glob from CLI flag",
        "The patterns in --globs is invalid. Please refer to doc and fix the error.",
        CLI_USAGE,
      ),
      LangInjection => Self::new(
        "Cannot parse languageInjections in config",
        "The rule in languageInjections is not valid. Please refer to doc and fix the error.",
        CONFIG_GUIDE,
      ),
      CustomLanguage => Self::new(
        "Cannot load custom language library",
        "The custom language library is not found or cannot be loaded.",
        CUSTOM_LANG_GUIDE,
      ),
      InvalidGlobalUtils => Self::new(
        "Error occurs when parsing global utility rules",
        "Please check the YAML rules inside the rule directory",
        UTILITY_RULE,
      ),
      UnrecognizableLanguage(lang) => Self::new(
        format!("Language `{lang}` is not supported"),
        "Please choose a built-in language or register a custom language in sgconfig.yml.",
        LANGUAGE_LIST,
      ),
      ParseTest(file) => Self::new(
        format!("Cannot parse test case {}", file.display()),
        "The file is not a valid ast-grep test case. Please refer to doc and fix the error.",
        TEST_GUIDE,
      ),
      DiagnosticError(num) => Self::new(
        format!("{num} error(s) found in code."),
        "Scan succeeded and found error level diagnostics in the codebase.",
        None,
      ),
      ParsePattern => Self::new(
        "Cannot parse query as a valid pattern.",
        "The pattern either fails to parse or contains error. Please refer to pattern syntax guide.",
        PATTERN_GUIDE,
      ),
      LanguageNotSpecified => Self::new(
        "Language must be specified for code from StdIn.",
        "Please use `--lang` to specify the code language.",
        TOOL_OVERVIEW,
      ),
      StdInIsNotInteractive => Self::new(
        "Interactive mode is incompatible with parsing code from StdIn.",
        "`--interactive` needs StdIn, but it is used as source code. Please use files as input.",
        TOOL_OVERVIEW,
      ),
      PatternHasError => Self::new(
        "Pattern contains an ERROR node and may cause unexpected results.",
        "ast-grep parsed the pattern but it matched nothing in this run. Try using playground to refine the pattern.",
        PLAYGROUND,
      ),
      RuleNotSpecified => Self::new(
        "Only one rule can scan code from StdIn.",
        "Please use `--rule path/to/rule.yml` to choose the rule.",
        TOOL_OVERVIEW,
      ),
      RuleNotFound(id) => Self::new(
        format!("Rule not found: {id}"),
        format!("Rule with id '{id}' not found in project configuration. Please make sure it exists."),
        TOOL_OVERVIEW,
      ),
      StartLanguageServer => Self::new(
        "Cannot start language server.",
        "Please see language server logging file.",
        EDITOR_INTEGRATION,
      ),
      OpenEditor => Self::new(
        "Cannot open file in editor.",
        "Please check if the editor is installed and the EDITOR environment variable is correctly set.",
        CLI_USAGE,
      ),
      WriteFile(file) => Self::new(
        format!("Cannot rewrite file {}", file.display()),
        "Fail to apply fix to the file. Skip to next file",
        None,
      ),
      TestFail(message) => Self::new(
        message,
        "You can use ast-grep playground to debug your rules and test cases.",
        PLAYGROUND,
      ),
      TestSnapshotMismatch(message) => Self::new(
        message,
        "Test failed due to mismatching snapshots. Run with `--update-all` to update all snapshots, or `--interactive` to update selectively.",
        TEST_GUIDE,
      ),
      ProjectAlreadyExist => Self::new(
        "ast-grep project already exists.",
        "You are already inside a sub-folder of an ast-grep project. Try finding sgconfig.yml in ancestor directory?",
        PROJECT_GUIDE,
      ),
      ProjectNotExist => Self::new(
        "No ast-grep project configuration is found.",
        "You need to create an ast-grep project for this command. Try `sg new` to create one.",
        PROJECT_GUIDE,
      ),
      FileAlreadyExist(path) => Self::new(
        format!("File `{}` already exists.", path.display()),
        "The item you want to create already exists. Try editing the existing file or create a new one with a different name?",
        None,
      ),
      NoTestDirConfigured => Self::new(
        "No test file directory is configured.",
        "Fail to create a test file because the project `sgconfig.yml` does not specify any test configuration.",
        TEST_GUIDE,
      ),
      NoUtilDirConfigured => Self::new(
        "No util file directory is configured.",
        "Fail to create a utility rule because the project `sgconfig.yml` does not specify any utils directory.",
        UTIL_GUIDE,
      ),
      InsufficientCLIArgument(name) => Self::new(
        "Insufficient command line argument provided to use `--yes` option.",
        format!("You need to provide `{name}` in command line to use non-interactive `new`."),
        None,
      ),
      CannotInferShell => Self::new(
        "Can not infer which shell to generate completions.",
        "Either specify shell flavor by `sg completions [SHELL]` or set correct `SHELL` environment.",
        CLI_USAGE,
      ),
      ExitInteractiveEditing => Self::new(
        "Interactive editing exited.",
        "Your accepted edit has been saved.",
        None,
      ),
    }
  }
}

pub fn exit_with_error(error: Error) -> Result<()> {
  if let Some(e) = error.downcast_ref::<clap::Error>() {
    e.exit()
  }
  if let Some(e) = error.downcast_ref::<ErrorContext>() {
    let error_fmt = ErrorFormat {
      context: e,
      inner: &error,
    };
    eprintln!("{error_fmt}");
    std::process::exit(e.exit_code())
  }
  // use anyhow's default error reporting
  Err(error)
}

// use raw ansi escape code to render links in terminal. references:
// https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
// https://github.com/zkat/miette/blob/c25676cb1f4266c2607836e6359f15b9cbd8637e/src/handlers/graphical.rs#L186
fn ansi_link(url: String) -> String {
  format!(
    "\u{1b}]8;;{}\u{1b}\\{}\u{1b}]8;;\u{1b}\\",
    url,
    ansi_term::Color::Cyan.italic().paint(&url)
  )
}

struct ErrorFormat<'a> {
  context: &'a ErrorContext,
  inner: &'a Error,
}

#[derive(Default)]
struct ErrorStyle {
  message: Style,
  error: Style,
  warning: Style,
  help: Style,
  reference: Style,
}

impl ErrorStyle {
  fn colored() -> Self {
    Self {
      message: Style::new().bold(),
      error: Style::new().fg(Color::Red),
      warning: Style::new().fg(Color::Yellow),
      help: Style::new().fg(Color::Blue),
      reference: Style::new().bold().dimmed(),
    }
  }
}

impl fmt::Display for ErrorFormat<'_> {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let ErrorMessage {
      title,
      description,
      link,
    } = ErrorMessage::from_context(self.context);
    let needs_color = std::io::stderr().is_tty();
    let style = if needs_color {
      ErrorStyle::colored()
    } else {
      ErrorStyle::default()
    };
    let (notice_style, notice, sign) = if self.context.is_soft_error() {
      (style.warning, "Warning:", "⚠")
    } else {
      (style.error, "Error:", "✖")
    };
    let message = style.message.paint(title);
    writeln!(f, "{} {message}", notice_style.paint(notice))?;
    let help = style.help.paint("Help:");
    writeln!(f, "{help} {description}")?;
    if let Some(url) = link {
      let reference = style.reference.paint("See also:");
      let link = format!("{DOC_SITE_HOST}{url}");
      let link = if needs_color { ansi_link(link) } else { link };
      writeln!(f, "{reference} {link}")?;
    }

    // skip root error
    let mut causes = self.inner.chain().skip(1).peekable();
    if causes.peek().is_none() {
      return Ok(());
    }
    writeln!(f)?;
    writeln!(f, "{} Caused by", notice_style.paint(sign))?;
    for err in causes {
      let prefix = notice_style.paint("╰▻");
      writeln!(f, "{prefix} {err}")?;
    }
    Ok(())
  }
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_display_error() {
    let error = anyhow::anyhow!("test error").context(ErrorContext::ReadConfiguration);
    let error_fmt = ErrorFormat {
      context: &ErrorContext::ReadConfiguration,
      inner: &error,
    };
    let display = format!("{error_fmt}");
    assert_eq!(display.lines().count(), 6);
    assert!(display.contains("Cannot read configuration."));
    assert!(
      display.contains("Caused by"),
      "Should display the error chain"
    );
    assert!(display.contains("test error"));
    assert!(display.contains("Error"));
    assert!(display.contains('✖'));
  }

  #[test]
  fn test_display_warning() {
    let error = anyhow::anyhow!("test error");
    let error_fmt = ErrorFormat {
      context: &ErrorContext::PatternHasError,
      inner: &error,
    };
    let display = format!("{error_fmt}");
    assert_eq!(display.lines().count(), 3);
    assert!(display.contains("Pattern contains an ERROR node"));
    assert!(display.contains("Warning"));
  }

  #[test]
  fn test_bare_anyhow() {
    let error = anyhow::anyhow!(ErrorContext::ReadConfiguration);
    let error_fmt = ErrorFormat {
      context: &ErrorContext::ReadConfiguration,
      inner: &error,
    };
    let display = format!("{error_fmt}");
    assert_eq!(display.lines().count(), 3);
    assert!(display.contains("Cannot read configuration."));
    assert!(
      !display.contains("Caused by"),
      "Should not contain error chain"
    );
  }

  #[test]
  fn test_exit_interactive_editing_is_soft_error() {
    let error = anyhow::anyhow!(ErrorContext::ExitInteractiveEditing);
    let error_fmt = ErrorFormat {
      context: &ErrorContext::ExitInteractiveEditing,
      inner: &error,
    };
    let display = format!("{error_fmt}");
    assert_eq!(display.lines().count(), 2);
    assert!(display.contains("Interactive editing exited."));
    assert!(display.contains("Warning"));
    assert!(!display.contains("Error"));

    // Check that it's considered a soft error with exit code 0
    assert_eq!(ErrorContext::ExitInteractiveEditing.exit_code(), 0);
    assert!(ErrorContext::ExitInteractiveEditing.is_soft_error());
  }
}



================================================
FILE: crates/cli/src/utils/inspect.rs
================================================
//! See https://github.com/ast-grep/ast-grep/issues/905
//! The `--tracing` flag helps user to inspect ast-grep's scan process. It has these levels:
//! - Summary level: show how many files are scanned, how many matches and etc for one CLI run. Included stats
//!   * number of rules used in this scan and skipped rules (due to severity: off)
//!   * number file scanned
//!   * number file matched
//! - Entity level: show how a file is scanned
//!   * reasons if skipped (file too large, does not have fixed string in pattern, no matching rule, etc)
//!   * number of rules applied
//!   * rules skipped (dues to ignore/files)
//! - Detail level: show how a rule runs on a file

use crate::config::ProjectConfig;
use crate::lang::SgLang;
use ast_grep_config::{RuleCollection, RuleConfig};

use anyhow::Result;
use clap::ValueEnum;

use std::fmt;
use std::io::{Stderr, Write};
use std::path::Path;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Mutex;

#[derive(Clone, Copy, ValueEnum, Default, PartialEq, Eq, PartialOrd, Ord)]
pub enum Granularity {
  /// Do not show any tracing information
  #[default]
  Nothing = 0,
  /// Show summary about how many files are scanned and skipped
  Summary = 1,
  /// Show per-file/per-rule tracing information
  Entity = 2,
  // Detail,
}

impl fmt::Debug for Granularity {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    match self {
      Granularity::Nothing => write!(f, "nothing"),
      Granularity::Summary => write!(f, "summary"),
      Granularity::Entity => write!(f, "entity"),
    }
  }
}

impl Granularity {
  pub fn project_trace(&self) -> ProjectTrace {
    self.project_trace_impl(std::io::stderr())
  }
  fn project_trace_impl<W: Write>(&self, w: W) -> TraceInfo<(), W> {
    TraceInfo {
      level: *self,
      inner: (),
      output: Mutex::new(w),
    }
  }

  pub fn run_trace(&self) -> RunTrace {
    self.run_trace_impl(std::io::stderr())
  }
  fn run_trace_impl<W: Write>(&self, w: W) -> TraceInfo<FileTrace, W> {
    TraceInfo {
      level: *self,
      inner: Default::default(),
      output: Mutex::new(w),
    }
  }

  pub fn scan_trace(&self, rule_stats: RuleTrace) -> ScanTrace {
    self.scan_trace_impl(rule_stats, std::io::stderr())
  }
  fn scan_trace_impl<W: Write>(&self, rule_stats: RuleTrace, w: W) -> TraceInfo<RuleTrace, W> {
    TraceInfo {
      level: *self,
      inner: rule_stats,
      output: Mutex::new(w),
    }
  }
}

// total = scanned + skipped
//       = (matched + unmatched) + skipped
#[derive(Default)]
pub struct FileTrace {
  files_scanned: AtomicUsize,
  files_skipped: AtomicUsize,
}

impl FileTrace {
  pub fn add_scanned(&self) {
    self.files_scanned.fetch_add(1, Ordering::AcqRel);
  }
  pub fn add_skipped(&self) {
    self.files_skipped.fetch_add(1, Ordering::AcqRel);
  }
}

pub struct TraceInfo<T, W: Write> {
  pub level: Granularity,
  pub inner: T,
  output: Mutex<W>,
}

impl<T, W: Write + Sync> TraceInfo<T, W> {
  #[inline(always)]
  fn semi_structured_print<F>(&self, level: Granularity, f: F) -> Result<()>
  where
    F: FnOnce(&mut W) -> Result<()>,
  {
    if self.level < level {
      return Ok(());
    }
    let mut w = self.output.lock().expect("lock should not be poisoned");
    write!(w, "sg: {level:?}")?;
    f(&mut *w)?;
    writeln!(&mut *w)?;
    Ok(())
  }

  #[inline(always)]
  fn print_summary<F>(&self, entity_type: &str, kv_write: F) -> Result<()>
  where
    F: FnOnce(&mut W) -> Result<()>,
  {
    self.semi_structured_print(Granularity::Summary, |w| {
      write!(w, "|{entity_type}: ")?;
      kv_write(w)
    })
  }

  #[inline(always)]
  fn print_entity<F, D>(&self, entity_type: &str, entity_path: D, kv_write: F) -> Result<()>
  where
    F: FnOnce(&mut W) -> Result<()>,
    D: fmt::Display,
  {
    self.semi_structured_print(Granularity::Entity, |w| {
      write!(w, "|{entity_type}|{entity_path}: ")?;
      kv_write(w)
    })
  }

  fn print_files(&self, trace: &FileTrace) -> Result<()> {
    self.print_summary("file", |w| {
      let scanned = trace.files_scanned.load(Ordering::Acquire);
      let skipped = trace.files_skipped.load(Ordering::Acquire);
      write!(w, "scannedFileCount={scanned},skippedFileCount={skipped}")?;
      Ok(())
    })
  }
}

impl<W: Write + Sync> TraceInfo<(), W> {
  pub fn print_project(&self, project: &Result<ProjectConfig>) -> Result<()> {
    self.print_summary("project", |w| {
      if let Ok(project) = project {
        let dir = project.project_dir.display();
        write!(w, "isProject=true,projectDir={dir}")?;
      } else {
        write!(w, "isProject=false")?;
      }
      Ok(())
    })
  }
}

impl<W: Write + Sync> TraceInfo<FileTrace, W> {
  pub fn print(&self) -> Result<()> {
    self.print_files(&self.inner)
  }

  pub fn print_file(&self, path: &Path, lang: SgLang) -> Result<()> {
    self.print_entity("file", path.display(), |w| {
      write!(w, "language={lang}")?;
      Ok(())
    })
  }
}

impl<W: Write + Sync> TraceInfo<RuleTrace, W> {
  // TODO: support more format?
  pub fn print(&self) -> Result<()> {
    self.print_files(&self.inner.file_trace)?;
    self.print_summary("rule", |w| {
      let (effective, skipped) = (
        self.inner.effective_rule_count,
        self.inner.skipped_rule_count,
      );
      write!(
        w,
        "effectiveRuleCount={effective},skippedRuleCount={skipped}"
      )?;
      Ok(())
    })?;
    Ok(())
  }

  pub fn print_file(&self, path: &Path, lang: SgLang, rules: &[&RuleConfig<SgLang>]) -> Result<()> {
    self.print_entity("file", path.display(), |w| {
      let len = rules.len();
      write!(w, "language={lang},appliedRuleCount={len}")?;
      Ok(())
    })?;
    Ok(())
  }

  pub fn print_rules(&self, rules: &RuleCollection<SgLang>) -> Result<()> {
    if self.level < Granularity::Entity {
      return Ok(());
    }
    rules.for_each_rule(|rule| {
      _ = self.print_entity("rule", &rule.id, |w| {
        write!(w, "finalSeverity={:?}", rule.severity)?;
        Ok(())
      });
    });
    Ok(())
  }
}

#[derive(Default)]
pub struct RuleTrace {
  pub file_trace: FileTrace,
  pub effective_rule_count: usize,
  pub skipped_rule_count: usize,
}

pub type ProjectTrace = TraceInfo<(), Stderr>;
pub type RunTrace = TraceInfo<FileTrace, Stderr>;
pub type ScanTrace = TraceInfo<RuleTrace, Stderr>;

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_tracing() {
    let tracing = Granularity::Summary;
    let mut ret = String::new();
    let run_trace = tracing.run_trace_impl(unsafe { ret.as_mut_vec() });
    assert_eq!(run_trace.level, Granularity::Summary);
    assert_eq!(run_trace.inner.files_scanned.load(Ordering::Relaxed), 0);
    assert_eq!(run_trace.inner.files_skipped.load(Ordering::Relaxed), 0);
    assert!(run_trace.print().is_ok());
    assert_eq!(
      ret,
      "sg: summary|file: scannedFileCount=0,skippedFileCount=0\n"
    );

    let mut ret = String::new();
    let rule_stats = RuleTrace {
      effective_rule_count: 10,
      skipped_rule_count: 2,
      file_trace: Default::default(),
    };
    let scan_trace = tracing.scan_trace_impl(rule_stats, unsafe { ret.as_mut_vec() });
    assert_eq!(scan_trace.level, Granularity::Summary);
    assert_eq!(
      scan_trace
        .inner
        .file_trace
        .files_scanned
        .load(Ordering::Relaxed),
      0
    );
    assert_eq!(
      scan_trace
        .inner
        .file_trace
        .files_skipped
        .load(Ordering::Relaxed),
      0
    );
    assert_eq!(scan_trace.inner.effective_rule_count, 10);
    assert_eq!(scan_trace.inner.skipped_rule_count, 2);
    assert!(scan_trace.print().is_ok());
    assert_eq!(
      ret,
      r"sg: summary|file: scannedFileCount=0,skippedFileCount=0
sg: summary|rule: effectiveRuleCount=10,skippedRuleCount=2
"
    );
  }

  #[test]
  fn test_tracing_nothing() {
    let tracing = Granularity::Nothing;
    let mut ret = String::new();
    let run_trace = tracing.run_trace_impl(unsafe { ret.as_mut_vec() });
    assert_eq!(run_trace.level, Granularity::Nothing);
    assert!(run_trace.print().is_ok());
    assert!(ret.is_empty());
  }
}



================================================
FILE: crates/cli/src/utils/mod.rs
================================================
mod args;
mod debug_query;
mod error_context;
mod inspect;
mod print_diff;
mod rule_overwrite;
mod worker;

pub use args::{ContextArgs, InputArgs, OutputArgs, OverwriteArgs};
pub use debug_query::DebugFormat;
pub use error_context::{exit_with_error, ErrorContext};
pub use inspect::{FileTrace, Granularity, RuleTrace, RunTrace, ScanTrace};
pub use print_diff::DiffStyles;
pub use rule_overwrite::RuleOverwrite;
pub use worker::{Items, PathWorker, StdInWorker, Worker};

use crate::lang::SgLang;

use anyhow::{anyhow, Context, Result};
use crossterm::{
  cursor::MoveTo,
  event::{self, Event, KeyCode, KeyModifiers},
  execute,
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
  terminal::{Clear, ClearType},
};
use smallvec::{smallvec, SmallVec};

use ast_grep_config::RuleCollection;
use ast_grep_core::Pattern;
use ast_grep_core::{tree_sitter::StrDoc, Matcher};
use ast_grep_language::{Language, LanguageExt};

use std::fs::read_to_string;
use std::io::stdout;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::str::FromStr;

type AstGrep = ast_grep_core::AstGrep<StrDoc<SgLang>>;

fn read_char() -> Result<char> {
  loop {
    if let Event::Key(evt) = event::read()? {
      match evt.code {
        KeyCode::Tab => break Ok('\t'),
        KeyCode::Enter => break Ok('\n'),
        KeyCode::Char('c') if evt.modifiers.contains(KeyModifiers::CONTROL) => break Ok('q'),
        KeyCode::Char(c) => break Ok(c),
        _ => (),
      }
    }
  }
}

/// Prompts for user input on STDOUT
fn prompt_reply_stdout(prompt: &str) -> Result<char> {
  let mut stdout = std::io::stdout();
  write!(stdout, "{prompt}")?;
  stdout.flush()?;
  terminal::enable_raw_mode()?;
  let ret = read_char();
  terminal::disable_raw_mode()?;
  ret
}

// clear screen
pub fn clear() -> Result<()> {
  execute!(stdout(), Clear(ClearType::All), MoveTo(0, 0))?;
  Ok(())
  // https://github.com/console-rs/console/blob/be1c2879536c90ffc2b54938b5964084f5fef67d/src/common_term.rs#L56
  // print!("\r\x1b[2J\r\x1b[H");
}

pub fn run_in_alternate_screen<T>(f: impl FnOnce() -> Result<T>) -> Result<T> {
  execute!(stdout(), EnterAlternateScreen)?;
  clear()?;
  let ret = f();
  // it is possible f panics and leaves the terminal in alternate screen mode
  // this may not be worth handling, see #1499
  execute!(stdout(), LeaveAlternateScreen)?;
  ret
}

pub fn prompt(prompt_text: &str, letters: &str, default: Option<char>) -> Result<char> {
  loop {
    let input = prompt_reply_stdout(prompt_text)?;
    if let Some(default) = default {
      if input == '\n' {
        return Ok(default);
      }
    }
    if letters.contains(input) {
      return Ok(input);
    }
    eprintln!("Unrecognized command, try again?")
  }
}

fn read_file(path: &Path) -> Result<String> {
  let file_content =
    read_to_string(path).with_context(|| format!("Cannot read file {}", path.to_string_lossy()))?;
  // skip large files or empty file
  if file_too_large(&file_content) {
    Err(anyhow!("File is too large"))
  } else if file_content.is_empty() {
    Err(anyhow!("File is empty"))
  } else {
    Ok(file_content)
  }
}

fn collect_file_stats(
  path: &Path,
  lang: SgLang,
  configs: &RuleCollection<SgLang>,
  rule_stats: &ScanTrace,
) -> Result<()> {
  let rules = configs.get_rule_from_lang(path, lang);
  rule_stats.print_file(path, lang, &rules)?;
  Ok(())
}

pub fn filter_file_rule(
  path: &Path,
  configs: &RuleCollection<SgLang>,
  trace: &ScanTrace,
) -> Result<SmallVec<[AstGrep; 1]>> {
  let Some(lang) = SgLang::from_path(path) else {
    return Ok(smallvec![]);
  };
  let file_content = read_file(path)?;
  let grep = lang.ast_grep(file_content);
  collect_file_stats(path, lang, configs, trace)?;
  let mut ret = smallvec![grep.clone()];
  if let Some(injected) = lang.injectable_sg_langs() {
    let sub_roots = grep.get_injections(|s| SgLang::from_str(s).ok());
    let inj = injected.filter_map(|l| {
      let root = sub_roots.iter().find(|d| *d.lang() == l)?;
      let grep = root.clone();
      collect_file_stats(path, l, configs, trace).ok()?;
      Some(grep)
    });
    ret.extend(inj)
  }
  Ok(ret)
}

// sub_matchers are the injected languages
// e.g. js/css in html
pub fn filter_file_pattern<'a>(
  path: &Path,
  lang: SgLang,
  root_matcher: Option<&'a Pattern>,
  sub_matchers: &'a [(SgLang, Pattern)],
) -> Result<SmallVec<[MatchUnit<&'a Pattern>; 1]>> {
  let file_content = read_file(path)?;
  let grep = lang.ast_grep(&file_content);
  let do_match = |ast_grep: AstGrep, matcher: &'a Pattern| {
    let fixed = matcher.fixed_string();
    if !fixed.is_empty() && !file_content.contains(&*fixed) {
      return None;
    }
    Some(MatchUnit {
      grep: ast_grep,
      path: path.to_path_buf(),
      matcher,
    })
  };
  let mut ret = smallvec![];
  if let Some(matcher) = root_matcher {
    ret.extend(do_match(grep.clone(), matcher));
  }
  let injections = grep.get_injections(|s| SgLang::from_str(s).ok());
  let sub_units = injections.into_iter().filter_map(|inner| {
    let (_, matcher) = sub_matchers.iter().find(|i| *inner.lang() == i.0)?;
    let injected = inner;
    do_match(injected, matcher)
  });
  ret.extend(sub_units);
  Ok(ret)
}

const MAX_FILE_SIZE: usize = 3_000_000;
const MAX_LINE_COUNT: usize = 200_000;

// skip files that are too large in size AND have too many lines
fn file_too_large(file_content: &str) -> bool {
  // the && operator is intentional here to include more files
  file_content.len() > MAX_FILE_SIZE && file_content.lines().count() > MAX_LINE_COUNT
}

/// A single atomic unit where matches happen.
/// It contains the file path, sg instance and matcher.
/// An analogy to compilation unit in C programming language.
pub struct MatchUnit<M: Matcher> {
  pub path: PathBuf,
  pub grep: AstGrep,
  pub matcher: M,
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_language::SupportLang;

  #[test]
  fn test_html_embedding() {
    let root =
      SgLang::Builtin(SupportLang::Html).ast_grep("<script lang=typescript>alert(123)</script>");
    let docs = root.get_injections(|s| SgLang::from_str(s).ok());
    assert_eq!(docs.len(), 1);
    let script = docs[0].root().child(0).expect("should exist");
    assert_eq!(script.kind(), "expression_statement");
  }

  #[test]
  fn test_html_embedding_lang_not_found() {
    let root = SgLang::Builtin(SupportLang::Html).ast_grep("<script lang=xxx>alert(123)</script>");
    let docs = root.get_injections(|s| SgLang::from_str(s).ok());
    assert_eq!(docs.len(), 0);
  }
}



================================================
FILE: crates/cli/src/utils/print_diff.rs
================================================
use crate::print::ColorArg;

use ansi_term::{Color, Style};
use anyhow::Result;
use similar::{ChangeTag, DiffOp, TextDiff};

use std::fmt::Display;
use std::io::Write;

// TODO: use termcolor instead
/// Print diff styles for colored output
#[derive(Default, Clone)]
pub struct DiffStyles {
  pub line_num: Style,
  // diff insert style
  pub insert: Style,
  pub insert_emphasis: Style,
  // diff deletion style
  pub delete: Style,
  pub delete_emphasis: Style,
  pub hunk_header: Style,
  pub select_fix: Style,
}

impl DiffStyles {
  pub fn colored() -> Self {
    static THISTLE1: Color = Color::Fixed(225);
    static SEA_GREEN: Color = Color::Fixed(158);
    static RED: Color = Color::Fixed(161);
    static GREEN: Color = Color::Fixed(35);
    let insert = Style::new().fg(GREEN);
    let delete = Style::new().fg(RED);
    let hunk_header = Style::new().fg(Color::Blue);
    let select_fix = Style::new().underline().bold();
    Self {
      line_num: Style::new().dimmed(),
      insert,
      insert_emphasis: insert.on(SEA_GREEN).bold(),
      delete,
      delete_emphasis: delete.on(THISTLE1).bold(),
      hunk_header,
      select_fix,
    }
  }
  fn no_color() -> Self {
    Self::default()
  }

  pub fn print_diff(
    &self,
    old: &str,
    new: &str,
    writer: &mut impl Write,
    context: usize,
  ) -> Result<()> {
    print_diff(self, old, new, writer, context)
  }
}

impl From<ColorArg> for DiffStyles {
  fn from(color: ColorArg) -> Self {
    if color.should_use_color() {
      Self::colored()
    } else {
      Self::no_color()
    }
  }
}

fn index_display(index: Option<usize>, style: Style, width: usize) -> impl Display {
  let index_str = match index {
    None => format!("{:width$}", ""),
    Some(idx) => format!("{:<width$}", idx + 1), // 0-based index -> 1-based line num
  };
  style.paint(index_str)
}

// TODO: currently diff print context is three lines before/after the match.
// This is suboptimal. We should use function/class as the enclosing scope to print relevant lines. See #155
fn compute_header(group: &[DiffOp]) -> String {
  let old_start = group[0].old_range().start;
  let new_start = group[0].new_range().start;
  let (old_len, new_len) = group.iter().fold((0, 0), |(o, n), op| {
    (o + op.old_range().len(), n + op.new_range().len())
  });
  format!("@@ -{old_start},{old_len} +{new_start},{new_len} @@")
}

fn print_diff(
  styles: &DiffStyles,
  old: &str,
  new: &str,
  writer: &mut impl Write,
  context: usize,
) -> Result<()> {
  let diff = TextDiff::from_lines(old, new);
  for group in diff.grouped_ops(context) {
    let op = group.last().unwrap();
    let old_width = op.old_range().end.checked_ilog10().unwrap_or(0) as usize + 1;
    let new_width = op.new_range().end.checked_ilog10().unwrap_or(0) as usize + 1;
    let header = compute_header(&group);
    writeln!(writer, "{}", styles.hunk_header.paint(header))?;
    for op in group {
      for change in diff.iter_inline_changes(&op) {
        let (sign, s, em, line_num) = match change.tag() {
          ChangeTag::Delete => ("-", styles.delete, styles.delete_emphasis, styles.delete),
          ChangeTag::Insert => ("+", styles.insert, styles.insert_emphasis, styles.insert),
          ChangeTag::Equal => (" ", Style::new(), Style::new(), styles.line_num),
        };
        write!(
          writer,
          "{} {}│{}",
          index_display(change.old_index(), line_num, old_width),
          index_display(change.new_index(), line_num, new_width),
          s.paint(sign),
        )?;
        for (emphasized, value) in change.iter_strings_lossy() {
          if emphasized {
            write!(writer, "{}", em.paint(value))?;
          } else {
            write!(writer, "{}", s.paint(value))?;
          }
        }
        if change.missing_newline() {
          writeln!(writer)?;
        }
      }
    }
  }
  Ok(())
}



================================================
FILE: crates/cli/src/utils/rule_overwrite.rs
================================================
use super::OverwriteArgs;
use crate::lang::SgLang;
use crate::utils::ErrorContext as EC;

use anyhow::Result;
use ast_grep_config::{RuleConfig, Severity};
use ast_grep_core::Language;
use regex::Regex;

use std::collections::HashMap;

#[derive(Default)]
pub struct RuleOverwrite {
  default_severity: Option<Severity>,
  by_rule_id: HashMap<String, Severity>,
  rule_filter: Option<Regex>,
}

fn read_severity(
  severity: Severity,
  ids: &Option<Vec<String>>,
  by_rule_id: &mut HashMap<String, Severity>,
  default_severity: &mut Option<Severity>,
) {
  let Some(ids) = ids.as_ref() else { return };
  if ids.is_empty() {
    *default_severity = Some(severity);
    return;
  }
  for id in ids {
    by_rule_id.insert(id.clone(), severity.clone());
  }
}

impl RuleOverwrite {
  pub fn new_for_verify(filter: Option<&Regex>, include_off: bool) -> Self {
    Self {
      default_severity: if include_off {
        Some(Severity::Hint)
      } else {
        None
      },
      by_rule_id: HashMap::new(),
      rule_filter: filter.cloned(),
    }
  }
  pub fn new(cli: &OverwriteArgs) -> Result<Self> {
    let mut default_severity = None;
    let mut by_rule_id = HashMap::new();
    read_severity(
      Severity::Error,
      &cli.error,
      &mut by_rule_id,
      &mut default_severity,
    );
    read_severity(
      Severity::Warning,
      &cli.warning,
      &mut by_rule_id,
      &mut default_severity,
    );
    read_severity(
      Severity::Info,
      &cli.info,
      &mut by_rule_id,
      &mut default_severity,
    );
    read_severity(
      Severity::Hint,
      &cli.hint,
      &mut by_rule_id,
      &mut default_severity,
    );
    read_severity(
      Severity::Off,
      &cli.off,
      &mut by_rule_id,
      &mut default_severity,
    );
    Ok(Self {
      default_severity,
      by_rule_id,
      rule_filter: cli.filter.clone(),
    })
  }

  pub fn process_configs(
    &self,
    configs: Vec<RuleConfig<SgLang>>,
  ) -> Result<Vec<RuleConfig<SgLang>>> {
    let mut configs = if let Some(filter) = &self.rule_filter {
      filter_rule_by_regex(configs, filter)?
    } else {
      configs
    };
    for config in &mut configs {
      let overwrite = self.find(&config.id);
      overwrite.overwrite(config);
    }
    Ok(configs)
  }

  pub fn find(&self, id: &str) -> OverwriteResult {
    let severity = self
      .by_rule_id
      .get(id)
      .cloned()
      .or_else(|| self.default_severity.clone());
    OverwriteResult { severity }
  }
}

fn filter_rule_by_regex(
  configs: Vec<RuleConfig<SgLang>>,
  filter: &Regex,
) -> Result<Vec<RuleConfig<SgLang>>> {
  let selected: Vec<_> = configs
    .into_iter()
    .filter(|c| filter.is_match(&c.id))
    .collect();

  if selected.is_empty() {
    Err(anyhow::anyhow!(EC::RuleNotFound(filter.to_string())))
  } else {
    Ok(selected)
  }
}

pub struct OverwriteResult {
  pub severity: Option<Severity>,
}

impl OverwriteResult {
  fn overwrite<L>(&self, rule: &mut RuleConfig<L>)
  where
    L: Language,
  {
    if let Some(severity) = &self.severity {
      rule.severity = severity.clone();
    }
  }
}



================================================
FILE: crates/cli/src/utils/worker.rs
================================================
use crate::print::Printer;
use crate::utils::FileTrace;

use anyhow::{anyhow, Result};
use ignore::{DirEntry, WalkParallel, WalkState};

use std::path::{Path, PathBuf};
use std::sync::{mpsc, Arc};

/// A trait to abstract how ast-grep discovers work Items.
///
/// It follows multiple-producer-single-consumer pattern.
/// ast-grep will produce items in one or more separate thread(s) and
/// `consume_items` in the main thread, blocking the function return.
/// Worker at the moment has two main flavors:
/// * PathWorker: discovers files on the file system, based on ignore
/// * StdInWorker: parse text content from standard input stream
pub trait Worker: Sync + Send {
  /// `consume_items` will run in a separate single thread.
  /// printing matches or error reporting can happen here.
  fn consume_items<P: Printer>(&self, items: Items<P::Processed>, printer: P) -> Result<()>;
}

/// A trait to abstract how ast-grep discovers, parses and processes files.
///
/// It follows multiple-producer-single-consumer pattern.
/// ast-grep discovers files in parallel by `build_walk`.
/// Then every file is parsed and filtered in `produce_item`.
/// Finally, `produce_item` will send `Item` to the consumer thread.
pub trait PathWorker: Worker {
  /// WalkParallel will determine what files will be processed.
  fn build_walk(&self) -> Result<WalkParallel>;
  /// Record trace for the worker.
  fn get_trace(&self) -> &FileTrace;
  /// Parse and find_match can be done in `produce_item`.
  fn produce_item<P: Printer>(
    &self,
    path: &Path,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>>;

  fn run_path<P: Printer>(self, printer: P) -> Result<()>
  where
    Self: Sized + 'static,
  {
    run_worker(Arc::new(self), printer)
  }
}

pub trait StdInWorker: Worker {
  fn parse_stdin<P: Printer>(
    &self,
    src: String,
    processor: &P::Processor,
  ) -> Result<Vec<P::Processed>>;

  fn run_std_in<P: Printer>(&self, printer: P) -> Result<()> {
    let source = std::io::read_to_string(std::io::stdin())?;
    let processor = printer.get_processor();
    if let Ok(items) = self.parse_stdin::<P>(source, &processor) {
      self.consume_items(Items::once(items)?, printer)
    } else {
      Ok(())
    }
  }
}

pub struct Items<T>(mpsc::Receiver<T>);
impl<T> Iterator for Items<T> {
  type Item = T;
  fn next(&mut self) -> Option<Self::Item> {
    // TODO: add error reporting here
    self.0.recv().ok()
  }
}
impl<T> Items<T> {
  fn once(items: Vec<T>) -> Result<Self> {
    let (tx, rx) = mpsc::channel();
    for item in items {
      // use write to avoid send/sync trait bound
      match tx.send(item) {
        Ok(_) => (),
        Err(e) => return Err(anyhow!(e.to_string())),
      };
    }
    Ok(Items(rx))
  }
}

fn filter_result(result: Result<DirEntry, ignore::Error>) -> Option<PathBuf> {
  let entry = match result {
    Ok(entry) => entry,
    Err(err) => {
      eprintln!("ERROR: {err}");
      return None;
    }
  };
  if !entry.file_type()?.is_file() {
    return None;
  }
  let path = entry.into_path();
  // TODO: is it correct here? see https://github.com/ast-grep/ast-grep/issues/1343
  match path.strip_prefix("./") {
    Ok(p) => Some(p.to_path_buf()),
    Err(_) => Some(path),
  }
}

fn run_worker<W: PathWorker + ?Sized + 'static, P: Printer>(
  worker: Arc<W>,
  printer: P,
) -> Result<()> {
  let (tx, rx) = mpsc::channel();
  let w = worker.clone();
  let walker = worker.build_walk()?;
  let processor = printer.get_processor();
  // walker run will block the thread
  std::thread::spawn(move || {
    let tx = tx;
    let processor = processor;
    walker.run(|| {
      let tx = tx.clone();
      let w = w.clone();
      let processor = &processor;
      Box::new(move |result| {
        let Some(p) = filter_result(result) else {
          return WalkState::Continue;
        };
        let stats = w.get_trace();
        stats.add_scanned();
        let Ok(items) = w.produce_item::<P>(&p, processor) else {
          stats.add_skipped();
          return WalkState::Continue;
        };
        for result in items {
          match tx.send(result) {
            Ok(_) => continue,
            Err(_) => return WalkState::Quit,
          }
        }
        WalkState::Continue
      })
    });
  });
  worker.consume_items(Items(rx), printer)
}



================================================
FILE: crates/cli/src/verify/case_result.rs
================================================
/*!
Maintains struct/enum for rule test results.

ast-grep rule test has several concepts.
Refer to https://ast-grep.github.io/guide/test-rule.html#basic-concepts
for general review.
*/
use super::{snapshot::TestSnapshot, SgLang, TestSnapshots};
use ast_grep_config::RuleConfig;
use ast_grep_language::LanguageExt;

/// [CaseStatus] categorize whether and how ast-grep
/// reports error for either valid or invalid code.
///
/// TestCase has two forms of input: valid code and invalid code.
/// sg can either reports or not reports an error.
/// This is a 2*2 = 4 scenarios. Also for reported scenario, we may have snapshot mismatching.
#[derive(PartialEq, Eq, Debug)]
pub enum CaseStatus<'a> {
  /// Reported no issue for valid code
  Validated,
  /// Reported correct issue for invalid code
  Reported,
  /// User accepted new snapshot updates
  Updated {
    source: &'a str,
    updated: TestSnapshot,
  },
  /// Reported issues for invalid code but it is wrong
  Wrong {
    source: &'a str,
    actual: TestSnapshot,
    expected: Option<TestSnapshot>,
  },
  /// Reported no issue for invalid code
  Missing(&'a str),
  /// Reported some issue for valid code
  Noisy(&'a str),
  /// Error occurred when applying fix
  Error,
}

impl<'a> CaseStatus<'a> {
  pub fn verify_valid(rule_config: &RuleConfig<SgLang>, case: &'a str) -> Self {
    let rule = &rule_config.matcher;
    let sg = rule_config.language.ast_grep(case);
    if sg.root().find(rule).is_some() {
      CaseStatus::Noisy(case)
    } else {
      CaseStatus::Validated
    }
  }

  pub fn verify_invalid(rule_config: &RuleConfig<SgLang>, case: &'a str) -> Self {
    let sg = rule_config.language.ast_grep(case);
    let rule = &rule_config.matcher;
    if sg.root().find(rule).is_some() {
      CaseStatus::Reported
    } else {
      CaseStatus::Missing(case)
    }
  }

  pub fn verify_snapshot(
    rule_config: &RuleConfig<SgLang>,
    case: &'a str,
    snapshot: Option<&TestSnapshot>,
  ) -> Self {
    let actual = match TestSnapshot::generate(rule_config, case) {
      Ok(Some(snap)) => snap,
      Ok(None) => return CaseStatus::Missing(case),
      Err(_) => return CaseStatus::Error,
    };
    match snapshot {
      Some(e) if e == &actual => CaseStatus::Reported,
      nullable => CaseStatus::Wrong {
        source: case,
        actual,
        expected: nullable.cloned(),
      },
    }
  }

  pub fn accept(&mut self) -> bool {
    let CaseStatus::Wrong { source, actual, .. } = self else {
      return false;
    };
    let updated = std::mem::replace(
      actual,
      TestSnapshot {
        fixed: None,
        labels: vec![],
      },
    );
    *self = CaseStatus::Updated { source, updated };
    true
  }

  pub fn is_pass(&self) -> bool {
    matches!(
      self,
      CaseStatus::Validated | CaseStatus::Reported | CaseStatus::Updated { .. }
    )
  }
}

/// The result for one rule-test.yml
/// id is the rule id. cases contains a list of [CaseStatus] for valid and invalid cases.
#[derive(PartialEq, Eq, Default, Debug)]
pub struct CaseResult<'a> {
  pub id: &'a str,
  pub cases: Vec<CaseStatus<'a>>,
}

impl CaseResult<'_> {
  /// Did all cases in the rule-test pass the test?
  pub fn passed(&self) -> bool {
    self.cases.iter().all(CaseStatus::is_pass)
  }

  /// Checks if all failing cases in this result are snapshot mismatches.
  /// This method exists to determine the appropriate error message to show users
  /// when test failures occur - snapshot mismatches suggest the rule is working
  /// but snapshots need updating, while other failures indicate rule problems.
  pub fn is_snapshot_mismatch_only_failure(&self) -> bool {
    let mut has_failures = false;
    for case in &self.cases {
      if !case.is_pass() {
        has_failures = true;
        if !matches!(case, CaseStatus::Wrong { .. }) {
          return false; // Found a non-snapshot failure
        }
      }
    }
    has_failures // Only return true if there are failures and all are snapshots
  }

  pub fn changed_snapshots(&self) -> TestSnapshots {
    let snapshots = self
      .cases
      .iter()
      .filter_map(|c| match c {
        CaseStatus::Updated { source, updated } => Some((source.to_string(), updated.clone())),
        _ => None,
      })
      .collect();
    TestSnapshots {
      id: self.id.to_string(),
      snapshots,
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::verify::test::get_rule_config;

  #[test]
  fn test_snapshot() {
    let rule = get_rule_config("pattern: let a = 1");
    let ret = CaseStatus::verify_snapshot(&rule, "function () { let a = 1 }", None);
    assert!(matches!(&ret, CaseStatus::Wrong { expected: None, .. }));
    let CaseStatus::Wrong { actual, source, .. } = ret else {
      panic!("wrong");
    };
    assert_eq!(source, "function () { let a = 1 }");
    let primary = &actual.labels[0];
    assert_eq!(primary.source, "let a = 1");
    let ret = CaseStatus::verify_snapshot(&rule, "function () { let a = 1 }", Some(&actual));
    assert!(matches!(ret, CaseStatus::Reported));
  }

  #[test]
  fn test_is_snapshot_mismatch_only_failure() {
    // Test case with only snapshot mismatches
    let snapshot_only_result = CaseResult {
      id: "test",
      cases: vec![
        CaseStatus::Wrong {
          source: "test",
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
        CaseStatus::Wrong {
          source: "test2",
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
      ],
    };
    assert!(snapshot_only_result.is_snapshot_mismatch_only_failure());

    // Test case with mixed failures
    let mixed_result = CaseResult {
      id: "test",
      cases: vec![
        CaseStatus::Wrong {
          source: "test",
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
        CaseStatus::Missing("test2"),
      ],
    };
    assert!(!mixed_result.is_snapshot_mismatch_only_failure());

    // Test case with all passing
    let passing_result = CaseResult {
      id: "test",
      cases: vec![CaseStatus::Validated, CaseStatus::Reported],
    };
    assert!(!passing_result.is_snapshot_mismatch_only_failure());

    // Test case with non-snapshot failures only
    let non_snapshot_result = CaseResult {
      id: "test",
      cases: vec![CaseStatus::Missing("test"), CaseStatus::Noisy("test2")],
    };
    assert!(!non_snapshot_result.is_snapshot_mismatch_only_failure());
  }
}



================================================
FILE: crates/cli/src/verify/find_file.rs
================================================
use super::{SnapshotCollection, TestCase, TestSnapshots};
use crate::config::ProjectConfig;
use crate::utils::ErrorContext as EC;

use anyhow::{Context, Result};
use ast_grep_config::from_str;
use ast_grep_language::config_file_type;
use ignore::WalkBuilder;
use regex::Regex;
use serde_yaml::{with::singleton_map_recursive::deserialize, Deserializer};

use std::collections::HashMap;
use std::fs::read_to_string;
use std::path::{Path, PathBuf};

const SNAPSHOT_DIR: &str = "__snapshots__";

#[derive(Default)]
pub struct TestHarness {
  pub test_cases: Vec<TestCase>,
  pub snapshots: SnapshotCollection,
  pub path_map: HashMap<String, PathBuf>,
}

impl TestHarness {
  pub fn from_config(project_config: ProjectConfig, regex_filter: Option<&Regex>) -> Result<Self> {
    find_tests(project_config, regex_filter)
  }

  pub fn from_dir(
    test_dirname: &Path,
    snapshot_dirname: Option<&Path>,
    regex_filter: Option<&Regex>,
  ) -> Result<Self> {
    let mut builder = HarnessBuilder {
      dest: TestHarness::default(),
      base_dir: std::env::current_dir()?,
      regex_filter,
    };
    builder.read_test_files(test_dirname, snapshot_dirname)?;
    Ok(builder.dest)
  }
}

struct HarnessBuilder<'a> {
  dest: TestHarness,
  base_dir: PathBuf,
  regex_filter: Option<&'a Regex>,
}

impl HarnessBuilder<'_> {
  fn included_in_filter(&self, id: &str) -> bool {
    self.regex_filter.map(|r| r.is_match(id)).unwrap_or(true)
  }

  fn read_test_files(
    &mut self,
    test_dirname: &Path,
    snapshot_dirname: Option<&Path>,
  ) -> Result<()> {
    let test_path = self.base_dir.join(test_dirname);
    let snapshot_dirname = snapshot_dirname.unwrap_or_else(|| SNAPSHOT_DIR.as_ref());
    let snapshot_path = test_path.join(snapshot_dirname);
    let walker = WalkBuilder::new(&test_path)
      .types(config_file_type())
      .build();
    for dir in walker {
      let config_file = dir.with_context(|| EC::WalkRuleDir(test_path.clone()))?;
      // file_type is None only if it is stdin, safe to unwrap here
      if !config_file
        .file_type()
        .expect("file type should be available for non-stdin")
        .is_file()
      {
        continue;
      }
      let path = config_file.path();
      let yaml = read_to_string(path).with_context(|| EC::ReadRule(path.to_path_buf()))?;
      if path.starts_with(&snapshot_path) {
        deserialize_snapshot_yaml(path, yaml, self)?;
      } else {
        deserialize_test_yaml(path, yaml, &snapshot_path, self)?;
      }
    }
    Ok(())
  }
}

pub fn find_tests(
  project_config: ProjectConfig,
  regex_filter: Option<&Regex>,
) -> Result<TestHarness> {
  let ProjectConfig {
    project_dir,
    test_configs,
    ..
  } = project_config;
  let test_configs = test_configs.unwrap_or_default();
  let mut builder = HarnessBuilder {
    base_dir: project_dir,
    regex_filter,
    dest: TestHarness::default(),
  };
  for test in test_configs {
    builder.read_test_files(&test.test_dir, test.snapshot_dir.as_deref())?;
  }
  Ok(builder.dest)
}

fn deserialize_snapshot_yaml(
  path: &Path,
  yaml: String,
  builder: &mut HarnessBuilder<'_>,
) -> Result<()> {
  let snapshot: TestSnapshots =
    from_str(&yaml).with_context(|| EC::ParseTest(path.to_path_buf()))?;
  if !builder.included_in_filter(&snapshot.id) {
    return Ok(());
  }
  let id = snapshot.id.clone();
  let existing = builder.dest.snapshots.insert(id.clone(), snapshot);
  if existing.is_some() {
    eprintln!("Warning: found duplicate test case snapshot for `{id}`");
  }
  Ok(())
}

fn deserialize_test_yaml(
  path: &Path,
  yaml: String,
  snapshot_path: &Path,
  builder: &mut HarnessBuilder<'_>,
) -> Result<()> {
  for deser in Deserializer::from_str(&yaml) {
    let test_case: TestCase =
      deserialize(deser).with_context(|| EC::ParseTest(path.to_path_buf()))?;
    if builder.included_in_filter(&test_case.id) {
      let harness = &mut builder.dest;
      harness
        .path_map
        .insert(test_case.id.clone(), snapshot_path.to_path_buf());
      harness.test_cases.push(test_case);
    }
  }
  Ok(())
}

#[cfg(test)]
mod test {
  use super::*;
  const MULTI: &str = "
id: test1
valid: [a]
invalid: [a]
---
id: test2
valid: [a]
invalid: [a]
";

  fn read_test(yaml: &str) -> TestHarness {
    let mut builder = HarnessBuilder {
      dest: TestHarness::default(),
      base_dir: PathBuf::new(),
      regex_filter: None,
    };
    let path = Path::new(".");
    deserialize_test_yaml(path, yaml.to_string(), path, &mut builder).expect("should ok");
    builder.dest
  }
  #[test]
  fn test_read_test() {
    let yaml = "{id: test, valid: ['a'], invalid: ['b']}";
    let harness = read_test(yaml);
    assert_eq!(harness.test_cases.len(), 1);
    assert_eq!(harness.test_cases[0].id, "test");
  }
  #[test]
  fn test_read_multi() {
    let harness = read_test(MULTI);
    assert_eq!(harness.test_cases.len(), 2);
    assert_eq!(harness.test_cases[0].id, "test1");
    assert_eq!(harness.test_cases[1].id, "test2");
  }

  const SNAPSHOTS: &str = "
id: test-1
snapshots:
  alert(123):
    labels:
    - source: alert(123)
      style: primary
      start: 0
      end: 10
";

  #[test]
  fn test_read_snapshot() {
    let mut builder = HarnessBuilder {
      dest: TestHarness::default(),
      base_dir: PathBuf::new(),
      regex_filter: None,
    };
    let path = Path::new(".");
    deserialize_snapshot_yaml(path, SNAPSHOTS.to_string(), &mut builder).expect("should ok");
    assert!(builder.dest.snapshots["test-1"]
      .snapshots
      .contains_key("alert(123)"));
  }
}



================================================
FILE: crates/cli/src/verify/reporter.rs
================================================
use crate::print::ColorArg;
use crate::utils::{prompt, run_in_alternate_screen, DiffStyles};

use ansi_term::{Color, Style};
use anyhow::Result;
use serde_yaml::to_string;

use std::io::Write;

use super::{CaseResult, CaseStatus, SnapshotAction, TestCase};

/// Represents the result of running tests
#[derive(Debug)]
pub enum TestResult {
  /// All tests passed successfully
  Success { message: String },
  /// Some tests failed due to rule errors
  RuleFail { message: String },
  /// Some tests failed due to snapshot mismatches only
  MismatchSnapshotOnly { message: String },
}

pub(super) trait Reporter {
  type Output: Write;
  fn get_output(&mut self) -> &mut Self::Output;
  /// A hook function runs before tests start.
  fn before_report(&mut self, test_cases: &[TestCase]) -> Result<()> {
    report_case_number(self.get_output(), test_cases)
  }
  /// A hook function runs after tests completed.
  fn after_report(&mut self, results: &[CaseResult]) -> Result<TestResult> {
    let mut passed = 0;
    let mut failed = 0;

    for result in results {
      if result.passed() {
        passed += 1;
      } else {
        failed += 1;
      }
    }

    let message = format!("{passed} passed; {failed} failed;");
    if failed > 0 {
      // Check if all failing tests are snapshot mismatches only
      let all_snapshot_mismatches = results
        .iter()
        .filter(|r| !r.passed())
        .all(|r| r.is_snapshot_mismatch_only_failure());

      if all_snapshot_mismatches {
        Ok(TestResult::MismatchSnapshotOnly {
          message: format!("test failed. {message}"),
        })
      } else {
        Ok(TestResult::RuleFail {
          message: format!("test failed. {message}"),
        })
      }
    } else {
      let result = Color::Green.paint("ok");
      Ok(TestResult::Success {
        message: format!("test result: {result}. {message}"),
      })
    }
  }

  fn report_failed_cases(&mut self, results: &mut [CaseResult]) -> Result<()> {
    let output = self.get_output();
    writeln!(output)?;
    writeln!(output, "----------- Case Details -----------")?;
    for result in results {
      if result.passed() {
        continue;
      }
      for status in &mut result.cases {
        if !self.report_case_detail(result.id, status)? {
          return Ok(());
        }
      }
    }
    Ok(())
  }

  fn report_summaries(&mut self, results: &[CaseResult]) -> Result<()> {
    for result in results {
      self.report_case_summary(result.id, &result.cases)?;
    }
    let output = self.get_output();
    writeln!(output)?;
    Ok(())
  }

  fn report_case_summary(&mut self, case_id: &str, summary: &[CaseStatus]) -> Result<()> {
    let passed = summary.iter().all(CaseStatus::is_pass);
    let style = Style::new().fg(Color::White).bold();
    let case_status = if summary.is_empty() {
      style.on(Color::Yellow).paint("SKIP")
    } else if passed {
      style.on(Color::Green).paint("PASS")
    } else {
      style.on(Color::Red).paint("FAIL")
    };
    let summary = report_summary(summary);
    writeln!(self.get_output(), "{case_status} {case_id}  {summary}")?;
    Ok(())
  }

  /// returns if should continue reporting
  /// user can mutate case_status to Updated in this function
  fn report_case_detail(&mut self, case_id: &str, result: &mut CaseStatus) -> Result<bool>;
  fn collect_snapshot_action(&self) -> SnapshotAction;
}

fn report_case_number(output: &mut impl Write, test_cases: &[TestCase]) -> Result<()> {
  writeln!(output, "Running {} tests", test_cases.len())?;
  Ok(())
}

fn report_summary(summary: &[CaseStatus]) -> String {
  if summary.len() > 40 {
    let mut pass = 0;
    let mut updated = 0;
    let mut wrong = 0;
    let mut missing = 0;
    let mut noisy = 0;
    let mut error = 0;
    for s in summary {
      match s {
        CaseStatus::Validated | CaseStatus::Reported => pass += 1,
        CaseStatus::Updated { .. } => updated += 1,
        CaseStatus::Wrong { .. } => wrong += 1,
        CaseStatus::Missing(_) => missing += 1,
        CaseStatus::Noisy(_) => noisy += 1,
        CaseStatus::Error => error += 1,
      }
    }
    let stats = vec![
      ("Pass", pass),
      ("Updated", updated),
      ("Wrong", wrong),
      ("Missing", missing),
      ("Noisy", noisy),
      ("Error", error),
    ];
    let result: Vec<_> = stats
      .into_iter()
      .filter_map(|(label, count)| {
        if count > 0 {
          Some(format!("{label} × {count}"))
        } else {
          None
        }
      })
      .collect();
    let result = result.join(", ");
    format!("{result:.^50}")
  } else {
    summary
      .iter()
      .map(|s| match s {
        CaseStatus::Validated | CaseStatus::Reported => '.',
        CaseStatus::Wrong { .. } => 'W',
        CaseStatus::Updated { .. } => 'U',
        CaseStatus::Missing(_) => 'M',
        CaseStatus::Noisy(_) => 'N',
        CaseStatus::Error => 'E',
      })
      .collect()
  }
}

fn indented_write<W: Write>(output: &mut W, code: &str) -> Result<()> {
  for line in code.lines() {
    writeln!(output, "  {line}")?;
  }
  Ok(())
}

fn report_case_detail_impl<W: Write>(
  output: &mut W,
  case_id: &str,
  result: &CaseStatus,
) -> Result<bool> {
  let case_id = Style::new().bold().paint(case_id);
  let noisy = Style::new().underline().paint("Noisy");
  let missing = Style::new().underline().paint("Missing");
  let wrong = Style::new().underline().paint("Wrong");
  let error = Style::new().underline().paint("Error");
  let update = Style::new().underline().paint("Updated");
  let styles = DiffStyles::from(ColorArg::Auto);
  match result {
    CaseStatus::Validated | CaseStatus::Reported => (),
    CaseStatus::Updated { source, .. } => {
      writeln!(
        output,
        "[{update}] Rule {case_id}'s snapshot baseline has been updated."
      )?;
      writeln!(output)?;
      indented_write(output, source)?;
      writeln!(output)?;
    }
    CaseStatus::Wrong {
      source,
      actual,
      expected,
    } => {
      if let Some(expected) = expected {
        writeln!(
          output,
          "[{wrong}] {case_id} snapshot is different from baseline."
        )?;
        let actual_str = to_string(&actual)?;
        let expected_str = to_string(&expected)?;
        writeln!(output, "{}", Style::new().italic().paint("Diff:"))?;
        styles.print_diff(&expected_str, &actual_str, output, 3)?;
      } else {
        writeln!(output, "[{wrong}] No {case_id} baseline found.")?;
        // TODO: add to print_styles
        writeln!(
          output,
          "{}",
          Style::new().italic().paint("Generated Snapshot:")
        )?;
        indented_write(output, &to_string(&actual)?)?;
      }
      // TODO: add to print_styles
      writeln!(output, "{}", Style::new().italic().paint("For Code:"))?;
      indented_write(output, source)?;
      writeln!(output)?;
    }
    CaseStatus::Missing(s) => {
      writeln!(
        output,
        "[{missing}] Expect rule {case_id} to report issues, but none found in:"
      )?;
      writeln!(output)?;
      indented_write(output, s)?;
      writeln!(output)?;
    }
    CaseStatus::Noisy(s) => {
      writeln!(
        output,
        "[{noisy}] Expect {case_id} to report no issue, but some issues found in:"
      )?;
      writeln!(output)?;
      indented_write(output, s)?;
      writeln!(output)?;
    }
    CaseStatus::Error => {
      writeln!(output, "[{error}] Fail to apply fix to {case_id}")?;
    }
  }
  // continue
  Ok(true)
}

pub struct DefaultReporter<Output: Write> {
  // TODO: visibility
  pub output: Output,
  pub update_all: bool,
}

impl<O: Write> Reporter for DefaultReporter<O> {
  type Output = O;

  fn get_output(&mut self) -> &mut Self::Output {
    &mut self.output
  }
  fn report_case_detail(&mut self, case_id: &str, result: &mut CaseStatus) -> Result<bool> {
    if self.update_all {
      result.accept();
    }
    report_case_detail_impl(self.get_output(), case_id, result)
  }
  fn collect_snapshot_action(&self) -> SnapshotAction {
    if self.update_all {
      SnapshotAction::NeedUpdate
    } else {
      SnapshotAction::AcceptNone
    }
  }
}

pub struct InteractiveReporter<Output: Write> {
  pub output: Output,
  pub should_accept_all: bool,
}

const PROMPT: &str = "Accept new snapshot? (Yes[y], No[n], Accept All[a], Quit[q])";
impl<O: Write> Reporter for InteractiveReporter<O> {
  type Output = O;

  fn get_output(&mut self) -> &mut Self::Output {
    &mut self.output
  }

  fn collect_snapshot_action(&self) -> SnapshotAction {
    SnapshotAction::NeedUpdate
  }

  fn report_case_detail(&mut self, case_id: &str, status: &mut CaseStatus) -> Result<bool> {
    if matches!(status, CaseStatus::Validated | CaseStatus::Reported) {
      return Ok(true);
    }
    run_in_alternate_screen(|| {
      report_case_detail_impl(self.get_output(), case_id, status)?;
      if !matches!(status, CaseStatus::Wrong { .. }) {
        let response = prompt("Next[enter], Quit[q]", "q", Some('\n'))?;
        return Ok(response != 'q');
      }
      if self.should_accept_all {
        return self.accept_new_snapshot(status);
      }
      let response = prompt(PROMPT, "ynaq", Some('n'))?;
      match response {
        'y' => self.accept_new_snapshot(status),
        'n' => Ok(true),
        'a' => {
          self.should_accept_all = true;
          self.accept_new_snapshot(status)
        }
        'q' => Ok(false),
        _ => unreachable!(),
      }
    })
  }
}

impl<O: Write> InteractiveReporter<O> {
  fn accept_new_snapshot(&mut self, status: &mut CaseStatus) -> Result<bool> {
    let accepted = status.accept();
    debug_assert!(accepted, "status should be updated");
    Ok(true)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::verify::snapshot::TestSnapshot;
  use crate::verify::test::TEST_RULE;

  const MOCK: &str = "hello";

  fn mock_case_status() -> Vec<CaseStatus<'static>> {
    vec![
      CaseStatus::Reported,
      CaseStatus::Missing(MOCK),
      CaseStatus::Noisy(MOCK),
      CaseStatus::Wrong {
        source: MOCK,
        actual: TestSnapshot {
          fixed: None,
          labels: vec![],
        },
        expected: None,
      },
      CaseStatus::Error,
    ]
  }

  #[test]
  fn test_report_summary() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };
    reporter.report_case_summary(TEST_RULE, &mock_case_status())?;
    let s = String::from_utf8(reporter.output)?;
    assert!(s.contains(".MNWE"));
    Ok(())
  }

  #[test]
  fn test_many_cases() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };
    use std::iter::repeat_with;
    let cases: Vec<_> = repeat_with(mock_case_status).flatten().take(50).collect();
    reporter.report_case_summary(TEST_RULE, &cases)?;
    let s = String::from_utf8(reporter.output)?;
    assert!(!s.contains(".MNWE"));
    assert!(s.contains("Pass × 10, Wrong × 10, Missing × 10, Noisy × 10, Error × 10"));
    Ok(())
  }

  #[test]
  fn test_valid_case_detail() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };
    reporter.report_case_detail(TEST_RULE, &mut CaseStatus::Reported)?;
    reporter.report_case_detail(TEST_RULE, &mut CaseStatus::Validated)?;
    let s = String::from_utf8(reporter.output)?;
    assert_eq!(s, "");
    Ok(())
  }

  #[test]
  fn test_invalid_case_detail() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };
    reporter.report_case_detail(TEST_RULE, &mut CaseStatus::Missing(MOCK))?;
    reporter.report_case_detail(TEST_RULE, &mut CaseStatus::Noisy(MOCK))?;
    let s = String::from_utf8(reporter.output)?;
    assert!(s.contains("Missing"));
    assert!(s.contains("Noisy"));
    assert!(!s.contains("Error"));
    assert!(!s.contains("Wrong"));
    assert!(s.contains(MOCK));
    assert!(s.contains(TEST_RULE));
    Ok(())
  }

  #[test]
  fn test_after_report_snapshot_mismatch_only() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };

    let results = vec![CaseResult {
      id: TEST_RULE,
      cases: vec![
        CaseStatus::Wrong {
          source: MOCK,
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
        CaseStatus::Wrong {
          source: MOCK,
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
      ],
    }];

    let test_result = reporter.after_report(&results)?;
    assert!(matches!(
      test_result,
      TestResult::MismatchSnapshotOnly { message: _ }
    ));
    Ok(())
  }

  #[test]
  fn test_after_report_mixed_failures() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };

    let results = vec![CaseResult {
      id: TEST_RULE,
      cases: vec![
        CaseStatus::Wrong {
          source: MOCK,
          actual: TestSnapshot {
            fixed: None,
            labels: vec![],
          },
          expected: None,
        },
        CaseStatus::Missing(MOCK), // Non-snapshot failure
      ],
    }];

    let test_result = reporter.after_report(&results)?;
    assert!(matches!(test_result, TestResult::RuleFail { message: _ }));
    Ok(())
  }

  #[test]
  fn test_after_report_success() -> Result<()> {
    let output = vec![];
    let mut reporter = DefaultReporter {
      output,
      update_all: false,
    };

    let results = vec![CaseResult {
      id: TEST_RULE,
      cases: vec![CaseStatus::Validated, CaseStatus::Reported],
    }];

    let test_result = reporter.after_report(&results)?;
    assert!(matches!(test_result, TestResult::Success { .. }));
    Ok(())
  }
}



================================================
FILE: crates/cli/src/verify/snapshot.rs
================================================
use crate::lang::SgLang;
use anyhow::{anyhow, Result};
use ast_grep_config::{Label, LabelStyle, RuleConfig};
use ast_grep_core::{
  tree_sitter::{LanguageExt, StrDoc},
  Doc,
};

use super::CaseResult;
use serde::{Deserialize, Serialize, Serializer};

use std::collections::{BTreeMap, HashMap};

type CaseId = String;
type Source = String;

/// A collection of test snapshots for different rules
/// where each [TestSnapshots] is identified by its rule ID.
pub type SnapshotCollection = HashMap<CaseId, TestSnapshots>;

fn merge_snapshots(
  accepted: SnapshotCollection,
  mut existing: SnapshotCollection,
) -> SnapshotCollection {
  for (id, tests) in accepted {
    if let Some(existing) = existing.get_mut(&id) {
      existing.snapshots.extend(tests.snapshots);
    } else {
      existing.insert(id, tests);
    }
  }
  existing
}

/// Represents user's decision when [CaseStatus::Wrong].
/// Snapshot update can be accepted or rejected.
#[derive(Debug)]
pub enum SnapshotAction {
  /// Accept changes
  NeedUpdate,
  /// Reject all changes.
  AcceptNone,
}

impl SnapshotAction {
  pub fn update_snapshot_collection(
    self,
    existing: SnapshotCollection,
    results: &[CaseResult],
  ) -> Option<SnapshotCollection> {
    let accepted = match self {
      Self::NeedUpdate => results
        .iter()
        .map(|result| (result.id.to_string(), result.changed_snapshots()))
        .collect(),
      Self::AcceptNone => return None,
    };
    Some(merge_snapshots(accepted, existing))
  }
}

/// A list of test snapshots for one specific rule-test identified by its `CaseId`.
/// A test yaml for one rule have multiple valid/invalid test cases.
/// Each invalid code test case has its [TestSnapshot].
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TestSnapshots {
  pub id: CaseId,
  #[serde(serialize_with = "ordered_map")]
  pub snapshots: HashMap<Source, TestSnapshot>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TestSnapshot {
  #[serde(skip_serializing_if = "Option::is_none")]
  pub fixed: Option<String>,
  pub labels: Vec<LabelSnapshot>,
}

impl TestSnapshot {
  /// Generate snapshot from rule and test case code
  // Ideally we should return Option<Result<T>>
  // because Some/None indicates if we have found matches,
  // then Result<T> indicates if we have error during replace
  // But to reuse anyhow we use the Result<Option<T>>
  pub fn generate(rule_config: &RuleConfig<SgLang>, case: &str) -> Result<Option<Self>> {
    let mut sg = rule_config.language.ast_grep(case);
    let rule = &rule_config.matcher;
    let Some(matched) = sg.root().find(rule) else {
      return Ok(None);
    };
    let labels = rule_config
      .get_labels(&matched)
      .into_iter()
      .map(LabelSnapshot::from)
      .collect();
    let Some(fix) = rule_config.matcher.fixer.first() else {
      return Ok(Some(Self {
        fixed: None,
        labels,
      }));
    };
    let changed = sg.replace(rule, fix).map_err(|e| anyhow!(e))?;
    debug_assert!(changed);
    Ok(Some(Self {
      fixed: Some(sg.source().to_string()),
      labels,
    }))
  }
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LabelSnapshot {
  pub(super) source: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  message: Option<String>,
  style: LabelStyle,
  start: usize,
  end: usize,
}
impl<'r, 't> From<Label<'r, 't, StrDoc<SgLang>>> for LabelSnapshot {
  fn from(label: Label<'r, 't, StrDoc<SgLang>>) -> Self {
    let range = label.range();
    let source = label.start_node.get_doc().get_source();
    Self {
      source: source[range.clone()].to_string(),
      message: label.message.map(ToString::to_string),
      style: label.style,
      start: range.start,
      end: range.end,
    }
  }
}

fn ordered_map<S>(value: &HashMap<String, TestSnapshot>, serializer: S) -> Result<S::Ok, S::Error>
where
  S: Serializer,
{
  let ordered: BTreeMap<_, _> = value.iter().collect();
  ordered.serialize(serializer)
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::verify::test::{get_rule_config, TEST_RULE};

  #[test]
  fn test_generate() -> Result<()> {
    let rule_config = get_rule_config("pattern: let x = $A");
    let case = "let x = 42;";
    let result = TestSnapshot::generate(&rule_config, case)?;
    assert_eq!(
      result,
      Some(TestSnapshot {
        fixed: None,
        labels: vec![LabelSnapshot {
          source: "let x = 42;".into(),
          message: None,
          style: LabelStyle::Primary,
          start: 0,
          end: 11,
        }]
      })
    );
    Ok(())
  }

  #[test]
  fn test_not_found() -> Result<()> {
    let rule_config = get_rule_config("pattern: var x = $A");
    let case = "let x = 42;";
    let result = TestSnapshot::generate(&rule_config, case)?;
    assert_eq!(result, None,);
    Ok(())
  }

  #[test]
  fn test_secondary_label() -> Result<()> {
    let rule_config =
      get_rule_config("{pattern: 'let x = $A;', inside: {kind: 'statement_block'}}");
    let case = "function test() { let x = 42; }";
    let result = TestSnapshot::generate(&rule_config, case)?;
    assert_eq!(
      result,
      Some(TestSnapshot {
        fixed: None,
        labels: vec![
          LabelSnapshot {
            source: "let x = 42;".into(),
            message: None,
            style: LabelStyle::Primary,
            start: 18,
            end: 29,
          },
          LabelSnapshot {
            source: "{ let x = 42; }".into(),
            message: None,
            style: LabelStyle::Secondary,
            start: 16,
            end: 31
          }
        ],
      })
    );
    Ok(())
  }

  #[test]
  fn test_snapshot_action() -> Result<()> {
    use crate::verify::CaseStatus;
    let action = SnapshotAction::NeedUpdate;
    let rule_config = get_rule_config("pattern: let x = $A");
    let sc = SnapshotCollection::new();
    let op = action
      .update_snapshot_collection(
        sc,
        &[CaseResult {
          id: TEST_RULE,
          cases: vec![CaseStatus::Updated {
            source: "let x = 123",
            updated: TestSnapshot::generate(&rule_config, "let x = 123")?.unwrap(),
          }],
        }],
      )
      .expect("should have new op");
    assert_eq!(
      op[TEST_RULE].snapshots["let x = 123"].labels[0].source,
      "let x = 123"
    );
    Ok(())
  }
}



================================================
FILE: crates/cli/src/verify/test_case.rs
================================================
use super::case_result::{CaseResult, CaseStatus};
use super::snapshot::TestSnapshots;
use crate::lang::SgLang;

use ast_grep_config::RuleConfig;
use serde::{Deserialize, Serialize};

/// Corresponds to one rule-test.yml for testing.
///
/// A rule-test contains these fields:
/// * id: the id of the rule that will be tested against
/// * valid: code that we do not expect to have any issues
/// * invalid: code that we do expect to have some issues
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TestCase {
  pub id: String,
  #[serde(default)]
  pub valid: Vec<String>,
  #[serde(default)]
  pub invalid: Vec<String>,
}

impl TestCase {
  pub fn verify_rule(&self, rule_config: &RuleConfig<SgLang>) -> CaseResult<'_> {
    debug_assert_eq!(self.id, rule_config.id);
    verify_test_case(self, rule_config)
  }

  pub fn verify_with_snapshot(
    &'_ self,
    rule_config: &RuleConfig<SgLang>,
    snapshots: Option<&TestSnapshots>,
  ) -> CaseResult<'_> {
    debug_assert_eq!(self.id, rule_config.id);
    verify_test_case_with_snapshots(self, rule_config, snapshots)
  }
}

fn verify_test_case<'a>(
  test_case: &'a TestCase,
  rule_config: &RuleConfig<SgLang>,
) -> CaseResult<'a> {
  let valid_cases = test_case
    .valid
    .iter()
    .map(|valid| CaseStatus::verify_valid(rule_config, valid));
  let invalid_cases = test_case
    .invalid
    .iter()
    .map(|invalid| CaseStatus::verify_invalid(rule_config, invalid));
  CaseResult {
    id: &test_case.id,
    cases: valid_cases.chain(invalid_cases).collect(),
  }
}

fn verify_test_case_with_snapshots<'a>(
  test_case: &'a TestCase,
  rule_config: &RuleConfig<SgLang>,
  snapshots: Option<&TestSnapshots>,
) -> CaseResult<'a> {
  let valid_cases = test_case
    .valid
    .iter()
    .map(|valid| CaseStatus::verify_valid(rule_config, valid));
  let invalid_cases = test_case.invalid.iter().map(|invalid| {
    let snap = snapshots.and_then(|s| s.snapshots.get(invalid));
    CaseStatus::verify_snapshot(rule_config, invalid, snap)
  });
  CaseResult {
    id: &test_case.id,
    cases: valid_cases.chain(invalid_cases).collect(),
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::verify::snapshot::TestSnapshot;
  use crate::verify::test::{get_rule_config, TEST_RULE};

  fn mock_test_case(valid: &[&str], invalid: &[&str]) -> TestCase {
    TestCase {
      id: TEST_RULE.to_string(),
      valid: valid.iter().map(|s| s.to_string()).collect(),
      invalid: invalid.iter().map(|s| s.to_string()).collect(),
    }
  }

  fn mock_snapshots(case: &str, snap: TestSnapshot) -> TestSnapshots {
    TestSnapshots {
      id: TEST_RULE.to_string(),
      snapshots: vec![(case.to_string(), snap)].into_iter().collect(),
    }
  }

  fn mock_snapshot(rule_config: &RuleConfig<SgLang>, case: &str) -> TestSnapshot {
    TestSnapshot::generate(rule_config, case)
      .expect("should ok")
      .expect("should generate")
  }

  #[test]
  fn test_verify_rule() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&["var x = 123"], &["let x = 123"]);
    let result = test_case.verify_rule(&rule_config);
    assert_eq!(result.id, test_case.id);
    assert!(matches!(result.cases[0], CaseStatus::Validated));
    assert!(matches!(result.cases[1], CaseStatus::Reported));
  }

  #[test]
  fn test_invalid() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&["let x = 123"], &["var x = 123"]);
    let result = test_case.verify_rule(&rule_config);
    assert_eq!(result.id, test_case.id);
    assert!(matches!(result.cases[0], CaseStatus::Noisy("let x = 123")));
    assert!(matches!(
      result.cases[1],
      CaseStatus::Missing("var x = 123")
    ));
  }
  #[test]
  fn test_verify_snapshot_with_existing() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&[], &["let x = 123"]);
    let snap = mock_snapshot(&rule_config, "let x = 123");
    let snaps = mock_snapshots("let x = 123", snap.clone());
    let result = test_case.verify_with_snapshot(&rule_config, Some(&snaps));
    assert_eq!(result.cases[0], CaseStatus::Reported);
  }

  #[test]
  fn test_verify_snapshot_with_mismatch() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&["var x = 123"], &["let x = 123"]);
    let snap = mock_snapshot(&rule_config, "let x = 456");
    let snaps = mock_snapshots("let x = 123", snap.clone());
    let result = test_case.verify_with_snapshot(&rule_config, Some(&snaps));
    assert_eq!(result.cases[0], CaseStatus::Validated);
    assert_eq!(
      result.cases[1],
      CaseStatus::Wrong {
        source: "let x = 123",
        actual: mock_snapshot(&rule_config, "let x = 123"),
        expected: Some(mock_snapshot(&rule_config, "let x = 456")),
      }
    );
  }

  #[test]
  fn test_verify_snapshot_without_existing() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&["var x = 123"], &["let x = 123"]);
    let result = test_case.verify_with_snapshot(&rule_config, None);
    assert_eq!(result.cases[0], CaseStatus::Validated);
    assert_eq!(
      result.cases[1],
      CaseStatus::Wrong {
        source: "let x = 123",
        actual: mock_snapshot(&rule_config, "let x = 123"),
        expected: None,
      }
    );
  }

  #[test]
  fn test_verify_snapshot_without_existing_2() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = mock_test_case(&["var x = 123"], &["let x = 123"]);
    let snap = mock_snapshot(&rule_config, "let x = 456");
    let snaps = mock_snapshots("let x = 456", snap.clone());
    let result = test_case.verify_with_snapshot(&rule_config, Some(&snaps));
    assert_eq!(result.cases[0], CaseStatus::Validated);
    assert_eq!(
      result.cases[1],
      CaseStatus::Wrong {
        source: "let x = 123",
        actual: mock_snapshot(&rule_config, "let x = 123"),
        expected: None,
      }
    );
  }

  #[test]
  #[should_panic]
  #[cfg(debug_assertions)]
  fn test_unmatching_id() {
    let rule_config = get_rule_config("pattern: let x = $A");
    let test_case = TestCase {
      id: "non-matching".into(),
      valid: vec![],
      invalid: vec![],
    };
    test_case.verify_rule(&rule_config);
  }
}



================================================
FILE: crates/cli/tests/help_test.rs
================================================
mod common;

use anyhow::Result;
use assert_cmd::Command;
use common::create_test_files;
use predicates::str::contains;

#[test]
fn test_help_work_for_invalid_sgconfig() -> Result<()> {
  let dir = create_test_files([("sgconfig.yml", "invalid")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["help"])
    .assert()
    .success()
    .stdout(contains("ast-grep"));
  Ok(())
}



================================================
FILE: crates/cli/tests/run_test.rs
================================================
mod common;

use anyhow::Result;
use assert_cmd::Command;
use common::create_test_files;
use predicates::prelude::*;
use predicates::str::contains;

#[test]
fn test_simple_infer_lang() -> Result<()> {
  let dir = create_test_files([("a.ts", "console.log(123)"), ("b.rs", "console.log(456)")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "console.log($A)"])
    .assert()
    .success()
    .stdout(contains("console.log(123)"))
    .stdout(contains("console.log(456)"));
  Ok(())
}

#[test]
fn test_simple_specific_lang() -> Result<()> {
  let dir = create_test_files([("a.ts", "console.log(123)"), ("b.rs", "console.log(456)")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "console.log($A)", "-l", "rs"])
    .assert()
    .success()
    .stdout(contains("console.log(123)").not())
    .stdout(contains("console.log(456)"));
  Ok(())
}

#[test]
fn test_js_in_html() -> Result<()> {
  let dir = create_test_files([
    ("a.html", "<script>alert(1)</script>"),
    ("b.js", "alert(456)"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "-l", "js"])
    .assert()
    .success()
    .stdout(contains("alert(1)"))
    .stdout(contains("alert(456)"));
  Ok(())
}

#[test]
fn test_rewrite_js_in_html() -> Result<()> {
  let dir = create_test_files([("a.html", "<script>alert(1)</script>")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "-r", "alert(456)"])
    .assert()
    .success()
    .stdout(contains("alert(1)"))
    .stdout(contains("alert(456)"));
  Ok(())
}

#[test]
fn test_inspect() -> Result<()> {
  let dir = create_test_files([("a.js", "alert(1)"), ("b.js", "alert(456)")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "-l", "js", "--inspect", "entity"])
    .assert()
    .success()
    .stdout(contains("alert(1)"))
    .stderr(contains("scannedFileCount=2"));
  Ok(())
}

#[test]
fn test_debug_query() -> Result<()> {
  // should not print pattern if invalid
  Command::cargo_bin("ast-grep")?
    .args(["-p", "foo;bar;", "-l", "js", "--debug-query"])
    .assert()
    .failure()
    .stderr(contains("Debug Pattern").not())
    .stderr(contains("Cannot parse query as a valid pattern"));

  // should  print debug tree even for invalid pattern
  Command::cargo_bin("ast-grep")?
    .args(["-p", "foo;bar;", "-l", "js", "--debug-query=ast"])
    .assert()
    .failure()
    .stderr(contains("Debug AST"))
    .stderr(contains("Cannot parse query as a valid pattern"));

  Ok(())
}

#[test]
fn test_unsupport_config_arg() -> Result<()> {
  let dir = create_test_files([])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "-c", "not-found.yml"])
    .assert()
    .failure()
    .stderr(contains("unexpected argument"));
  Ok(())
}

#[test]
fn test_trace_default_project() -> Result<()> {
  let dir = create_test_files([("sgconfig.yml", "ruleDirs: []")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "--inspect=summary"])
    .assert()
    .success()
    .stderr(contains("isProject=true,projectDir"));
  Ok(())
}

#[test]
fn test_trace_project() -> Result<()> {
  let dir = create_test_files([("not.yml", "ruleDirs: []")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["-p", "alert($A)", "--inspect=summary"])
    .assert()
    .success()
    .stderr(contains("isProject=false"));
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["run", "-c=not.yml", "-p", "alert($A)", "--inspect=summary"])
    .assert()
    .success()
    .stderr(contains("isProject=true,projectDir"));
  Ok(())
}



================================================
FILE: crates/cli/tests/scan_test.rs
================================================
mod common;

use anyhow::Result;
use assert_cmd::Command;
use ast_grep::main_with_args;
use common::create_test_files;
use predicates::prelude::*;
use predicates::str::contains;
use serde_json::{from_slice, Value};
use tempfile::TempDir;

const CONFIG: &str = "
ruleDirs:
- rules
testConfigs:
- testDir: rule-tests
";
const RULE1: &str = "
id: on-rule
message: test rule
severity: warning
language: TypeScript
rule:
  pattern: Some($A)
";

const RULE2: &str = "
id: off-rule
severity: off
language: TypeScript
rule:
  pattern: Some($A)
";

fn setup() -> Result<TempDir> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/on-rule.yml", RULE1),
    ("rules/off-rule.yml", RULE2),
    ("test.ts", "Some(123)"),
  ])?;
  assert!(dir.path().join("sgconfig.yml").exists());
  Ok(dir)
}

fn sg(s: &str) -> Result<()> {
  let args = s.split(' ').map(String::from);
  main_with_args(args)
}

#[test]
fn test_sg_scan() -> Result<()> {
  let dir = setup()?;
  let config = dir.path().join("sgconfig.yml");
  let ret = sg(&format!("ast-grep scan -c {}", config.display()));
  assert!(ret.is_ok());
  let ret = sg(&format!("ast-grep scan -c={}", config.display()));
  assert!(ret.is_ok());
  let ret = sg(&format!("ast-grep scan --config {}", config.display()));
  assert!(ret.is_ok());
  let ret = sg(&format!("ast-grep scan --config={}", config.display()));
  assert!(ret.is_ok());
  drop(dir);
  Ok(())
}

#[test]
fn test_sg_rule_off() -> Result<()> {
  let dir = setup()?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan"])
    .assert()
    .success()
    .stdout(contains("on-rule"))
    .stdout(contains("off-rule").not());
  drop(dir);
  Ok(())
}

#[test]
fn test_sg_scan_inline_rules() -> Result<()> {
  let inline_rules = "{id: test, language: ts, rule: {pattern: console.log($A)}}";
  Command::cargo_bin("ast-grep")?
    .args(["scan", "--stdin", "--inline-rules", inline_rules, "--json"])
    .write_stdin("console.log(123)")
    .assert()
    .stdout(contains("\"text\": \"console.log(123)\""))
    .stdout(predicate::function(|n| from_slice::<Value>(n).is_ok()));
  Ok(())
}

const MULTI_RULES: &str = "
id: rule-1
language: TypeScript
rule: { pattern: Some($A) }
---
id: rule-2
language: TypeScript
rule: { pattern: None }
";

#[test]
fn test_sg_scan_multiple_rules_in_one_file() -> Result<()> {
  let dir = create_test_files([("rule.yml", MULTI_RULES), ("test.ts", "Some(123) + None")])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "-r", "rule.yml"])
    .assert()
    .success()
    .stdout(contains("rule-1"))
    .stdout(contains("rule-2"))
    .stdout(contains("rule-3").not());
  Ok(())
}

// see #517, #668
#[test]
fn test_sg_scan_py_empty_text() -> Result<()> {
  let inline_rules = "{id: test, language: py, rule: {pattern: None}}";
  Command::cargo_bin("ast-grep")?
    .args(["scan", "--stdin", "--inline-rules", inline_rules])
    .write_stdin("\n\n\n\n\nNone")
    .assert()
    .stdout(contains("STDIN:6:1"));
  Ok(())
}

#[test]
fn test_sg_scan_html() -> Result<()> {
  let dir = create_test_files([
    ("rule.yml", RULE1),
    ("test.html", "<script lang=ts>Some(123)</script>"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "-r", "rule.yml", "--inspect=summary"])
    .assert()
    .success()
    .stdout(contains("on-rule"))
    .stdout(contains("script"))
    .stdout(contains("rule-3").not())
    .stderr(contains("scannedFileCount=1"));
  Ok(())
}

#[test]
fn test_scan_unused_suppression() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", RULE1),
    ("test.ts", "None(123) // ast-grep-ignore"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan"])
    .assert()
    .success()
    .stdout(contains("unused-suppression"));
  Ok(())
}

#[test]
fn test_unused_suppression_only_in_scan() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", RULE1),
    ("test.ts", "None(123) // ast-grep-ignore"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "-r", "rules/rule.yml"])
    .assert()
    .success()
    .stdout(contains("unused-suppression").not());
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--filter", "on-rule"])
    .assert()
    .success()
    .stdout(contains("unused-suppression").not());
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--off", "on-rule"])
    .assert()
    .success()
    .stdout(contains("unused-suppression").not());
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--inline-rules", RULE1])
    .assert()
    .success()
    .stdout(contains("unused-suppression").not());
  Ok(())
}

#[test]
fn test_scan_unused_suppression_off() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", RULE1),
    ("test.ts", "None(123) // ast-grep-ignore"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--off"])
    .assert()
    .success();
  Ok(())
}

#[test]
fn test_severity_override() -> Result<()> {
  let dir = setup()?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--error"])
    .assert()
    .failure()
    .stdout(contains("error"));
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--error=on-rule"])
    .assert()
    .failure()
    .stdout(contains("error"));
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "--error=not-exist"])
    .assert()
    .success()
    .stdout(contains("warning"));
  Ok(())
}

const PY_RULE: &str = r"
id: transform-indent
language: python
rule: { pattern: 'class $CN(): $A' }
transform:
  AR:
    substring: { source: $A }
fix: |-
  class $CN():
      $AR
";

const PY_FILE: &str = r"
if something:
    class B():
        def replace(self):
        print(self1)
";

#[test]
fn test_transform_indent() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", PY_RULE),
    ("test.py", PY_FILE),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan"])
    .assert()
    .success()
    .stdout(contains("print").not())
    .stdout(contains("transform-indent"));
  Ok(())
}

const LABEL_RULE: &str = r"
id: label-test
language: TypeScript
rule: { all: [pattern: Some($A), pattern: $B] }
labels:
  A:
    style: primary
    message: primary-label
  B:
    style: secondary
    message: secondary-label
";

#[test]
fn test_label() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", LABEL_RULE),
    ("test.ts", "Some(123) + None"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan"])
    .assert()
    .success()
    .stdout(contains("primary-label"))
    .stdout(contains("secondary-label"))
    .stdout(contains(" -----^^^-")) // a label range test
    .stdout(contains(" -----^^^--").not());
  Ok(())
}
const FILE_RULE: &str = "
id: file-rule
message: test rule
language: TypeScript
rule: { pattern: Some($A) }
files: [ test/*.ts ]
";

#[test]
fn test_file() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/rule.yml", FILE_RULE),
    ("test/hit.ts", "Some(123)"),
    ("not.ts", "Some(456)"),
  ])?;
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path().join("test"))
    .args(["scan"])
    .assert()
    .success()
    .stdout(contains("hit.ts"))
    .stdout(contains("not.ts").not());
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path().join("test"))
    .args(["scan", "-c", "../sgconfig.yml"])
    .assert()
    .success()
    .stdout(contains("hit.ts"))
    .stdout(contains("not.ts").not());
  Command::cargo_bin("ast-grep")?
    .current_dir(dir.path())
    .args(["scan", "-c", "sgconfig.yml"])
    .assert()
    .success()
    .stdout(contains("hit.ts"))
    .stdout(contains("not.ts").not());
  Ok(())
}



================================================
FILE: crates/cli/tests/verify_test.rs
================================================
mod common;

use anyhow::Result;
use ast_grep::main_with_args;
use common::create_test_files;
use tempfile::TempDir;

const CONFIG: &str = "
ruleDirs:
- rules
testConfigs:
- testDir: rule-tests
";
const RULE: &str = "
id: test-rule
message: test rule
severity: warning
language: TypeScript
rule:
  pattern: Some($A)
";
const OFF_RULE: &str = "
id: test-rule
message: test rule
severity: off
language: TypeScript
rule:
  pattern: Some($A)
";

const TEST: &str = "
id: test-rule
valid:
- None
invalid:
- Some(123)
";

const WRONG_TEST: &str = "
id: test-rule
valid:
- Some(123)
invalid:
- None
";

fn setup() -> Result<TempDir> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/test-rule.yml", RULE),
    ("rule-tests/test-rule-test.yml", TEST),
    ("test.ts", "Some(123)"),
  ])?;
  assert!(dir.path().join("sgconfig.yml").exists());
  Ok(dir)
}

fn sg(s: &str) -> Result<()> {
  let args = s.split(' ').map(String::from);
  main_with_args(args)
}

#[test]
fn test_sg_test() -> Result<()> {
  let dir = setup()?;
  let config = dir.path().join("sgconfig.yml");
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests",
    config.display()
  ));
  assert!(ret.is_ok());
  drop(dir);
  Ok(())
}

fn setup_error() -> Result<TempDir> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/test-rule.yml", RULE),
    ("rule-tests/test-rule-test.yml", WRONG_TEST),
    ("test.ts", "Some(123)"),
  ])?;
  assert!(dir.path().join("sgconfig.yml").exists());
  Ok(dir)
}

#[test]
fn test_sg_test_error() -> Result<()> {
  let dir = setup_error()?;
  let config = dir.path().join("sgconfig.yml");
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests",
    config.display()
  ));
  assert!(ret.is_err());
  drop(dir);
  Ok(())
}

// should skip/pick wrong_test based on filter
#[test]
fn test_sg_test_filter() -> Result<()> {
  let dir = setup_error()?;
  let config = dir.path().join("sgconfig.yml");
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests -f error-rule",
    config.display()
  ));
  assert!(ret.is_err());
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests -f test-rule",
    config.display()
  ));
  assert!(ret.is_err());
  drop(dir);
  Ok(())
}

#[test]
fn test_sg_test_off_rule() -> Result<()> {
  let dir = create_test_files([
    ("sgconfig.yml", CONFIG),
    ("rules/test-rule.yml", OFF_RULE),
    ("rule-tests/test-rule-test.yml", WRONG_TEST),
    ("test.ts", "Some(123)"),
  ])?;
  let config = dir.path().join("sgconfig.yml");
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests",
    config.display()
  ));
  assert!(ret.is_ok());
  let ret = sg(&format!(
    "ast-grep test -c {} --skip-snapshot-tests --include-off",
    config.display()
  ));
  assert!(ret.is_err());
  drop(dir);
  Ok(())
}



================================================
FILE: crates/cli/tests/common/mod.rs
================================================
use anyhow::Result;
use std::fs::File;
use std::io::Write;
use tempfile::TempDir;

pub fn create_test_files<'a>(
  names_and_contents: impl IntoIterator<Item = (&'a str, &'a str)>,
) -> Result<TempDir> {
  let dir = TempDir::new()?;
  for (name, contents) in names_and_contents {
    if let Some((sub, _)) = name.split_once('/') {
      let sub_dir = dir.path().join(sub);
      std::fs::create_dir_all(sub_dir)?;
    }
    let path = dir.path().join(name);
    let mut file = File::create(path.clone())?;
    file.write_all(contents.as_bytes())?;
    file.sync_all()?;
  }
  Ok(dir)
}



================================================
FILE: crates/config/Cargo.toml
================================================
[package]
name = "ast-grep-config"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]

authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true

[features]
default = ["tree-sitter"]
tree-sitter = ["ast-grep-core/tree-sitter"]

[dependencies]
ast-grep-core.workspace = true

bit-set.workspace = true
globset = "0.4.14"
regex.workspace = true
serde.workspace = true
serde_yaml = "0.9.33"
thiserror.workspace = true
schemars.workspace = true

[dev-dependencies]
tree-sitter-typescript = "0.23.2"


================================================
FILE: crates/config/src/check_var.rs
================================================
use crate::fixer::{Fixer, FixerError};
use crate::rule::referent_rule::RuleRegistration;
use crate::rule::Rule;
use crate::rule_config::RuleConfigError;
use crate::rule_core::RuleCoreError;
use crate::transform::{Transform, TransformError};
use crate::RuleCore;

use std::collections::{HashMap, HashSet};

type RResult<T> = std::result::Result<T, RuleCoreError>;

pub enum CheckHint<'r> {
  Global,
  Normal,
  Rewriter(&'r HashSet<&'r str>),
}

/// Different rule sections have different variable scopes/check procedure.
/// so we need to check rules with different hints.
pub fn check_rule_with_hint<'r>(
  rule: &'r Rule,
  utils: &'r RuleRegistration,
  constraints: &'r HashMap<String, Rule>,
  transform: &'r Option<Transform>,
  fixer: &Vec<Fixer>,
  hint: CheckHint<'r>,
) -> RResult<()> {
  match hint {
    CheckHint::Global => {
      // do not check utils defined here because global rules are not yet ready
      check_vars(rule, utils, constraints, transform, fixer)?;
    }
    CheckHint::Normal => {
      check_utils_defined(rule, constraints)?;
      check_vars(rule, utils, constraints, transform, fixer)?;
    }
    // upper_vars is needed to check metavar defined in containing vars
    CheckHint::Rewriter(upper_vars) => {
      if fixer.is_empty() {
        return Err(RuleCoreError::Fixer(FixerError::InvalidRewriter));
      }
      check_utils_defined(rule, constraints)?;
      check_vars_in_rewriter(rule, utils, constraints, transform, fixer, upper_vars)?;
    }
  }
  Ok(())
}

fn check_vars_in_rewriter<'r>(
  rule: &'r Rule,
  utils: &'r RuleRegistration,
  constraints: &'r HashMap<String, Rule>,
  transform: &'r Option<Transform>,
  fixer: &Vec<Fixer>,
  upper_var: &HashSet<&str>,
) -> RResult<()> {
  let vars = get_vars_from_rules(rule, utils);
  let vars = check_var_in_constraints(vars, constraints)?;
  let mut vars = check_var_in_transform(vars, transform)?;
  for v in upper_var {
    vars.insert(v);
  }
  check_var_in_fix(vars, fixer)?;
  Ok(())
}

fn check_utils_defined(rule: &Rule, constraints: &HashMap<String, Rule>) -> RResult<()> {
  rule.verify_util()?;
  for constraint in constraints.values() {
    constraint.verify_util()?;
  }
  Ok(())
}

fn check_vars<'r>(
  rule: &'r Rule,
  utils: &'r RuleRegistration,
  constraints: &'r HashMap<String, Rule>,
  transform: &'r Option<Transform>,
  fixer: &Vec<Fixer>,
) -> RResult<()> {
  let vars = get_vars_from_rules(rule, utils);
  let vars = check_var_in_constraints(vars, constraints)?;
  let vars = check_var_in_transform(vars, transform)?;
  check_var_in_fix(vars, fixer)?;
  Ok(())
}

fn get_vars_from_rules<'r>(rule: &'r Rule, utils: &'r RuleRegistration) -> HashSet<&'r str> {
  let mut vars = rule.defined_vars();
  for var in utils.get_local_util_vars() {
    vars.insert(var);
  }
  vars
}

fn check_var_in_constraints<'r>(
  mut vars: HashSet<&'r str>,
  constraints: &'r HashMap<String, Rule>,
) -> RResult<HashSet<&'r str>> {
  for rule in constraints.values() {
    for var in rule.defined_vars() {
      vars.insert(var);
    }
  }
  for var in constraints.keys() {
    let var: &str = var;
    if !vars.contains(var) {
      return Err(RuleCoreError::UndefinedMetaVar(
        var.to_owned(),
        "constraints",
      ));
    }
  }
  Ok(vars)
}

fn check_var_in_transform<'r>(
  mut vars: HashSet<&'r str>,
  transform: &'r Option<Transform>,
) -> RResult<HashSet<&'r str>> {
  let Some(transform) = transform else {
    return Ok(vars);
  };
  for var in transform.keys() {
    // vars already has the transform value. Report error!
    if !vars.insert(var) {
      return Err(RuleCoreError::Transform(TransformError::AlreadyDefined(
        var.to_string(),
      )));
    }
  }
  for trans in transform.values() {
    let needed = trans.used_vars();
    if !vars.contains(needed) {
      return Err(RuleCoreError::UndefinedMetaVar(
        needed.to_string(),
        "transform",
      ));
    }
  }
  Ok(vars)
}

fn check_var_in_fix(vars: HashSet<&str>, fixers: &Vec<Fixer>) -> RResult<()> {
  for fixer in fixers {
    for var in fixer.used_vars() {
      if !vars.contains(&var) {
        return Err(RuleCoreError::UndefinedMetaVar(var.to_string(), "fix"));
      }
    }
  }
  Ok(())
}

pub fn check_rewriters_in_transform(
  rule: &RuleCore,
  rewriters: &HashMap<String, RuleCore>,
) -> Result<(), RuleConfigError> {
  if let Some(err) = check_one_rewriter_in_rule(rule, rewriters) {
    return Err(err);
  }
  let error = rewriters
    .values()
    .find_map(|rewriter| check_one_rewriter_in_rule(rewriter, rewriters));
  if let Some(err) = error {
    return Err(err);
  }
  Ok(())
}

fn check_one_rewriter_in_rule(
  rule: &RuleCore,
  rewriters: &HashMap<String, RuleCore>,
) -> Option<RuleConfigError> {
  let transform = rule.transform.as_ref()?;
  let mut used_rewriters = transform
    .values()
    .flat_map(|trans| trans.used_rewriters().iter());
  let undefined_writers = used_rewriters.find(|r| !rewriters.contains_key(*r))?;
  Some(RuleConfigError::UndefinedRewriter(
    undefined_writers.to_string(),
  ))
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::test::TypeScript;
  use crate::{from_str, DeserializeEnv, SerializableRuleCore};

  #[test]
  fn test_defined_vars() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(
      r"
rule: {pattern: $A = $B}
constraints:
  A: { pattern: $C = $D }
transform:
  E:
    substring:
      source: $B
      startCar: 1",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    assert_eq!(
      matcher.defined_vars(),
      ["A", "B", "C", "D", "E"].into_iter().collect()
    );
  }

  fn get_undefined(src: &str) -> (String, &str) {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(src).expect("should deser");
    match ser_rule.get_matcher(env) {
      Err(RuleCoreError::UndefinedMetaVar(name, section)) => (name, section),
      _ => panic!("unexpected error"),
    }
  }

  #[test]
  fn test_undefined_vars_in_constraints() {
    let (name, section) = get_undefined(
      r"
rule: {pattern: $A}
constraints: {B: {pattern: bbb}}
",
    );
    assert_eq!(name, "B");
    assert_eq!(section, "constraints");
  }
  #[test]
  fn test_undefined_vars_in_transform() {
    let (name, section) = get_undefined(
      r"
rule: {pattern: $A}
constraints: {A: {pattern: $C}}
transform:
  B:
    replace: {source: $C, replace: a, by: b }
  D:
    replace: {source: $E, replace: a, by: b }
",
    );
    assert_eq!(name, "E");
    assert_eq!(section, "transform");
  }
  #[test]
  fn test_undefined_vars_in_fix() {
    let (name, section) = get_undefined(
      r"
rule: {pattern: $A}
constraints: {A: {pattern: $C}}
transform:
  B:
    replace: {source: $C, replace: a, by: b }
fix: $D
",
    );
    assert_eq!(name, "D");
    assert_eq!(section, "fix");
  }

  #[test]
  fn test_defined_vars_in_utils() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(
      r"
rule: {matches: test}
utils:
  test: { pattern: $B}",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    assert_eq!(matcher.defined_vars(), ["B"].into_iter().collect());
  }

  #[test]
  fn test_use_vars_in_utils() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(
      r"
utils:
  test: { pattern: $B }
rule: { matches: test }
fix: $B = 123",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    assert_eq!(matcher.defined_vars(), ["B"].into_iter().collect());
  }

  #[test]
  fn test_defined_vars_cyclic() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(
      r"
rule: { matches: test1 }
utils:
  test1: { pattern: $B, inside: {matches: test2} }
  test2: { pattern: $A, has: {matches: test1} }",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    assert_eq!(matcher.defined_vars(), ["A", "B"].into_iter().collect());
  }

  #[test]
  fn test_transform_already_defined() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore = from_str(
      r"
rule: { pattern: $A = $B }
transform:
  B: { substring: { source: $A } }",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env);
    match matcher {
      Err(RuleCoreError::Transform(TransformError::AlreadyDefined(b))) => {
        assert_eq!(b, "B");
      }
      _ => panic!("unexpected error"),
    }
  }
}



================================================
FILE: crates/config/src/combined.rs
================================================
use crate::{RuleConfig, SerializableRule, SerializableRuleConfig, SerializableRuleCore, Severity};

use ast_grep_core::language::Language;
use ast_grep_core::matcher::{Matcher, MatcherExt};
use ast_grep_core::{AstGrep, Doc, Node, NodeMatch};

use std::collections::{HashMap, HashSet};

pub struct ScanResult<'t, 'r, D: Doc, L: Language> {
  pub diffs: Vec<(&'r RuleConfig<L>, NodeMatch<'t, D>)>,
  pub matches: Vec<(&'r RuleConfig<L>, Vec<NodeMatch<'t, D>>)>,
}

/// store the index to the rule and the matched node
/// it will be converted to ScanResult by resolving the rule
struct ScanResultInner<'t, D: Doc> {
  diffs: Vec<(usize, NodeMatch<'t, D>)>,
  matches: HashMap<usize, Vec<NodeMatch<'t, D>>>,
  unused_suppressions: Vec<NodeMatch<'t, D>>,
}

impl<'t, D: Doc> ScanResultInner<'t, D> {
  pub fn into_result<'r, L: Language>(
    self,
    combined: &CombinedScan<'r, L>,
    separate_fix: bool,
  ) -> ScanResult<'t, 'r, D, L> {
    let mut diffs: Vec<_> = self
      .diffs
      .into_iter()
      .map(|(idx, nm)| (combined.get_rule(idx), nm))
      .collect();
    let mut matches: Vec<_> = self
      .matches
      .into_iter()
      .map(|(idx, nms)| (combined.get_rule(idx), nms))
      .collect();
    if let Some(rule) = combined.unused_suppression_rule {
      if separate_fix {
        diffs.extend(self.unused_suppressions.into_iter().map(|nm| (rule, nm)));
        diffs.sort_unstable_by_key(|(_, nm)| nm.range().start);
      } else if !self.unused_suppressions.is_empty() {
        // do not push empty suppression to matches
        let mut supprs = self.unused_suppressions;
        supprs.sort_unstable_by_key(|nm| nm.range().start);
        matches.push((rule, supprs));
      }
    }
    ScanResult { diffs, matches }
  }
}

enum SuppressKind {
  /// suppress the whole file
  File,
  /// suppress specific line
  Line(usize),
}

fn get_suppression_kind(node: &Node<'_, impl Doc>) -> Option<SuppressKind> {
  if !node.kind().contains("comment") || !node.text().contains(IGNORE_TEXT) {
    return None;
  }
  let line = node.start_pos().line();
  let suppress_next_line = if let Some(prev) = node.prev() {
    prev.start_pos().line() != line
  } else {
    true
  };
  // if the first line is suppressed and the next line is empyt,
  // we suppress the whole file see gh #1541
  if line == 0
    && suppress_next_line
    && node
      .next()
      .map(|next| next.start_pos().line() >= 2)
      .unwrap_or(true)
  {
    return Some(SuppressKind::File);
  }
  let key = if suppress_next_line { line + 1 } else { line };
  Some(SuppressKind::Line(key))
}

struct Suppressions {
  file: Option<Suppression>,
  /// line number which may be suppressed
  lines: HashMap<usize, Suppression>,
}

impl Suppressions {
  fn collect_all<D: Doc>(root: &AstGrep<D>) -> (Self, HashMap<usize, Node<'_, D>>) {
    let mut suppressions = Self {
      file: None,
      lines: HashMap::new(),
    };
    let mut suppression_nodes = HashMap::new();
    for node in root.root().dfs() {
      let is_all_suppressed = suppressions.collect(&node, &mut suppression_nodes);
      if is_all_suppressed {
        break;
      }
    }
    (suppressions, suppression_nodes)
  }
  /// collect all suppression nodes from the root node
  /// returns if the whole file need to be suppressed, including unused sup
  /// see #1541
  fn collect<'r, D: Doc>(
    &mut self,
    node: &Node<'r, D>,
    suppression_nodes: &mut HashMap<usize, Node<'r, D>>,
  ) -> bool {
    let Some(sup) = get_suppression_kind(node) else {
      return false;
    };
    let suppressed = Suppression {
      suppressed: parse_suppression_set(&node.text()),
      node_id: node.node_id(),
    };
    suppression_nodes.insert(node.node_id(), node.clone());
    match sup {
      SuppressKind::File => {
        let is_all_suppressed = suppressed.suppressed.is_none();
        self.file = Some(suppressed);
        is_all_suppressed
      }
      SuppressKind::Line(key) => {
        self.lines.insert(
          key,
          Suppression {
            suppressed: parse_suppression_set(&node.text()),
            node_id: node.node_id(),
          },
        );
        false
      }
    }
  }

  fn file_suppression(&self) -> MaySuppressed<'_> {
    if let Some(sup) = &self.file {
      MaySuppressed::Yes(sup)
    } else {
      MaySuppressed::No
    }
  }

  fn line_suppression<D: Doc>(&self, node: &Node<'_, D>) -> MaySuppressed<'_> {
    let line = node.start_pos().line();
    if let Some(sup) = self.lines.get(&line) {
      MaySuppressed::Yes(sup)
    } else {
      MaySuppressed::No
    }
  }
}

struct Suppression {
  /// None = suppress all
  suppressed: Option<HashSet<String>>,
  node_id: usize,
}

enum MaySuppressed<'a> {
  Yes(&'a Suppression),
  No,
}

impl MaySuppressed<'_> {
  fn suppressed_id(&self, rule_id: &str) -> Option<usize> {
    let suppression = match self {
      MaySuppressed::No => return None,
      MaySuppressed::Yes(s) => s,
    };
    if let Some(set) = &suppression.suppressed {
      if set.contains(rule_id) {
        Some(suppression.node_id)
      } else {
        None
      }
    } else {
      Some(suppression.node_id)
    }
  }
}

const IGNORE_TEXT: &str = "ast-grep-ignore";

/// A struct to group all rules according to their potential kinds.
/// This can greatly reduce traversal times and skip unmatchable rules.
/// Rules are referenced by their index in the rules vector.
pub struct CombinedScan<'r, L: Language> {
  rules: Vec<&'r RuleConfig<L>>,
  /// a vec of vec, mapping from kind to a list of rule index
  kind_rule_mapping: Vec<Vec<usize>>,
  /// a rule for unused_suppressions
  unused_suppression_rule: Option<&'r RuleConfig<L>>,
}

impl<'r, L: Language> CombinedScan<'r, L> {
  pub fn new(mut rules: Vec<&'r RuleConfig<L>>) -> Self {
    // process fixable rule first, the order by id
    // note, mapping.push will invert order so we sort fixable order in reverse
    rules.sort_unstable_by_key(|r| (r.fix.is_some(), &r.id));
    let mut mapping = Vec::new();
    for (idx, rule) in rules.iter().enumerate() {
      let Some(kinds) = rule.matcher.potential_kinds() else {
        eprintln!("rule `{}` must have kind", &rule.id);
        continue;
      };
      for kind in &kinds {
        // NOTE: common languages usually have about several hundred kinds
        // from 200+ ~ 500+, it is okay to waste about 500 * 24 Byte vec size = 12kB
        // see https://github.com/Wilfred/difftastic/tree/master/vendored_parsers
        while mapping.len() <= kind {
          mapping.push(vec![]);
        }
        mapping[kind].push(idx);
      }
    }
    Self {
      rules,
      kind_rule_mapping: mapping,
      unused_suppression_rule: None,
    }
  }

  pub fn set_unused_suppression_rule(&mut self, rule: &'r RuleConfig<L>) {
    if matches!(rule.severity, Severity::Off) {
      return;
    }
    self.unused_suppression_rule = Some(rule);
  }

  pub fn scan<'a, D>(&self, root: &'a AstGrep<D>, separate_fix: bool) -> ScanResult<'a, '_, D, L>
  where
    D: Doc<Lang = L>,
  {
    let mut result = ScanResultInner {
      diffs: vec![],
      matches: HashMap::new(),
      unused_suppressions: vec![],
    };
    let (suppressions, mut suppression_nodes) = Suppressions::collect_all(root);
    let file_sup = suppressions.file_suppression();
    if let MaySuppressed::Yes(s) = file_sup {
      if s.suppressed.is_none() {
        return result.into_result(self, separate_fix);
      }
    }
    for node in root.root().dfs() {
      let kind = node.kind_id() as usize;
      let Some(rule_idx) = self.kind_rule_mapping.get(kind) else {
        continue;
      };
      let line_sup = suppressions.line_suppression(&node);
      for &idx in rule_idx {
        let rule = &self.rules[idx];
        let Some(ret) = rule.matcher.match_node(node.clone()) else {
          continue;
        };
        if let Some(id) = file_sup.suppressed_id(&rule.id) {
          suppression_nodes.remove(&id);
          continue;
        }
        if let Some(id) = line_sup.suppressed_id(&rule.id) {
          suppression_nodes.remove(&id);
          continue;
        }
        if rule.fix.is_none() || !separate_fix {
          let matches = result.matches.entry(idx).or_default();
          matches.push(ret);
        } else {
          result.diffs.push((idx, ret));
        }
      }
    }
    result.unused_suppressions = suppression_nodes
      .into_values()
      .map(NodeMatch::from)
      .collect();
    result.into_result(self, separate_fix)
  }

  pub fn get_rule(&self, idx: usize) -> &'r RuleConfig<L> {
    self.rules[idx]
  }

  pub fn unused_config(severity: Severity, lang: L) -> RuleConfig<L> {
    let rule: SerializableRule = crate::from_str(r#"{"any": []}"#).unwrap();
    let core = SerializableRuleCore {
      rule,
      constraints: None,
      fix: crate::from_str(r#"''"#).unwrap(),
      transform: None,
      utils: None,
    };
    let config = SerializableRuleConfig {
      core,
      id: "unused-suppression".to_string(),
      severity,
      files: None,
      ignores: None,
      language: lang,
      message: "Unused 'ast-grep-ignore' directive.".into(),
      metadata: None,
      note: None,
      rewriters: None,
      url: None,
      labels: None,
    };
    RuleConfig::try_from(config, &Default::default()).unwrap()
  }
}

fn parse_suppression_set(text: &str) -> Option<HashSet<String>> {
  let (_, after) = text.trim().split_once(IGNORE_TEXT)?;
  let after = after.trim();
  if after.is_empty() {
    return None;
  }
  let (_, rules) = after.split_once(':')?;
  let set = rules.split(',').map(|r| r.trim().to_string()).collect();
  Some(set)
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::test::TypeScript;
  use crate::SerializableRuleConfig;
  use ast_grep_core::tree_sitter::{LanguageExt, StrDoc};

  fn create_rule() -> RuleConfig<TypeScript> {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'console.log($A)'}
language: Tsx",
    )
    .expect("parse");
    RuleConfig::try_from(rule, &Default::default()).expect("work")
  }

  fn test_scan<F>(source: &str, test_fn: F)
  where
    F: Fn(
      Vec<(
        &'_ RuleConfig<TypeScript>,
        Vec<NodeMatch<'_, StrDoc<TypeScript>>>,
      )>,
    ),
  {
    let root = TypeScript::Tsx.ast_grep(source);
    let rule = create_rule();
    let rules = vec![&rule];
    let scan = CombinedScan::new(rules);
    let scanned = scan.scan(&root, false);
    test_fn(scanned.matches);
  }

  #[test]
  fn test_ignore_node() {
    let source = r#"
    // ast-grep-ignore
    console.log('ignored all')
    console.log('no ignore')
    // ast-grep-ignore: test
    console.log('ignore one')
    // ast-grep-ignore: not-test
    console.log('ignore another')
    // ast-grep-ignore: not-test, test
    console.log('multiple ignore')
    "#;
    test_scan(source, |scanned| {
      let matches = &scanned[0];
      assert_eq!(matches.1.len(), 2);
      assert_eq!(matches.1[0].text(), "console.log('no ignore')");
      assert_eq!(matches.1[1].text(), "console.log('ignore another')");
    });
  }

  #[test]
  fn test_ignore_node_same_line() {
    let source = r#"
    console.log('ignored all') // ast-grep-ignore
    console.log('no ignore')
    console.log('ignore one') // ast-grep-ignore: test
    console.log('ignore another') // ast-grep-ignore: not-test
    console.log('multiple ignore') // ast-grep-ignore: not-test, test
    "#;
    test_scan(source, |scanned| {
      let matches = &scanned[0];
      assert_eq!(matches.1.len(), 2);
      assert_eq!(matches.1[0].text(), "console.log('no ignore')");
      assert_eq!(matches.1[1].text(), "console.log('ignore another')");
    });
  }

  fn test_scan_unused<F>(source: &str, test_fn: F)
  where
    F: Fn(
      Vec<(
        &'_ RuleConfig<TypeScript>,
        Vec<NodeMatch<'_, StrDoc<TypeScript>>>,
      )>,
    ),
  {
    let root = TypeScript::Tsx.ast_grep(source);
    let rule = create_rule();
    let rules = vec![&rule];
    let mut scan = CombinedScan::new(rules);
    let mut unused = create_rule();
    unused.id = "unused-suppression".to_string();
    scan.set_unused_suppression_rule(&unused);
    let scanned = scan.scan(&root, false);
    test_fn(scanned.matches);
  }

  #[test]
  fn test_non_used_suppression() {
    let source = r#"
    console.log('no ignore')
    console.debug('not used') // ast-grep-ignore: test
    console.log('multiple ignore') // ast-grep-ignore: test
    "#;
    test_scan_unused(source, |scanned| {
      assert_eq!(scanned.len(), 2);
      let unused = &scanned[1];
      assert_eq!(unused.1.len(), 1);
      assert_eq!(unused.1[0].text(), "// ast-grep-ignore: test");
    });
  }

  #[test]
  fn test_file_suppression() {
    let source = r#"// ast-grep-ignore: test

    console.log('ignored')
    console.debug('report') // ast-grep-ignore: test
    console.log('report') // ast-grep-ignore: test
    "#;
    test_scan_unused(source, |scanned| {
      assert_eq!(scanned.len(), 1);
      let unused = &scanned[0];
      assert_eq!(unused.1.len(), 2);
    });
    let source = r#"// ast-grep-ignore: test
    console.debug('above is not file sup')
    console.log('not ignored')
    "#;
    test_scan_unused(source, |scanned| {
      assert_eq!(scanned.len(), 2);
      assert_eq!(scanned[0].0.id, "test");
      assert_eq!(scanned[1].0.id, "unused-suppression");
    });
  }

  #[test]
  fn test_file_suppression_all() {
    let source = r#"// ast-grep-ignore

    console.log('ignored')
    console.debug('report') // ast-grep-ignore: test
    console.log('report') // ast-grep-ignore
    "#;
    test_scan_unused(source, |scanned| {
      assert_eq!(scanned.len(), 0);
    });
    let source = r#"// ast-grep-ignore

    console.debug('no hit')
    "#;
    test_scan_unused(source, |scanned| {
      assert_eq!(scanned.len(), 0);
    });
  }
}



================================================
FILE: crates/config/src/fixer.rs
================================================
use crate::maybe::Maybe;
use crate::rule::{Relation, Rule, RuleSerializeError, StopBy};
use crate::transform::Transformation;
use crate::DeserializeEnv;
use ast_grep_core::replacer::{Content, Replacer, TemplateFix, TemplateFixError};
use ast_grep_core::{Doc, Language, Matcher, NodeMatch};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use thiserror::Error;

use std::collections::{HashMap, HashSet};
use std::ops::Range;

/// A pattern string or fix object to auto fix the issue.
/// It can reference metavariables appeared in rule.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged)]
pub enum SerializableFixer {
  Str(String),
  Config(Box<SerializableFixConfig>),
  List(Vec<SerializableFixConfig>),
}

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct SerializableFixConfig {
  template: String,
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  expand_end: Maybe<Relation>,
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  expand_start: Maybe<Relation>,
  #[serde(skip_serializing_if = "Option::is_none")]
  title: Option<String>,
}

#[derive(Debug, Error)]
pub enum FixerError {
  #[error("Fixer template is invalid.")]
  InvalidTemplate(#[from] TemplateFixError),
  #[error("Fixer expansion contains invalid rule.")]
  WrongExpansion(#[from] RuleSerializeError),
  #[error("Rewriter must have exactly one fixer.")]
  InvalidRewriter,
  #[error("Fixer in list must have title.")]
  MissingTitle,
}

struct Expansion {
  matches: Rule,
  stop_by: StopBy,
}

impl Expansion {
  fn parse<L: Language>(
    relation: &Maybe<Relation>,
    env: &DeserializeEnv<L>,
  ) -> Result<Option<Self>, FixerError> {
    let inner = match relation {
      Maybe::Absent => return Ok(None),
      Maybe::Present(r) => r.clone(),
    };
    let stop_by = StopBy::try_from(inner.stop_by, env)?;
    let matches = env.deserialize_rule(inner.rule)?;
    Ok(Some(Self { matches, stop_by }))
  }
}

pub struct Fixer {
  template: TemplateFix,
  expand_start: Option<Expansion>,
  expand_end: Option<Expansion>,
  title: Option<String>,
}

impl Fixer {
  fn do_parse<L: Language>(
    serialized: &SerializableFixConfig,
    env: &DeserializeEnv<L>,
    transform: &Option<HashMap<String, Transformation>>,
  ) -> Result<Self, FixerError> {
    let SerializableFixConfig {
      template: fix,
      expand_end,
      expand_start,
      title,
    } = serialized;
    let expand_start = Expansion::parse(expand_start, env)?;
    let expand_end = Expansion::parse(expand_end, env)?;
    let template = if let Some(trans) = transform {
      let keys: Vec<_> = trans.keys().cloned().collect();
      TemplateFix::with_transform(fix, &env.lang, &keys)
    } else {
      TemplateFix::try_new(fix, &env.lang)?
    };
    Ok(Self {
      template,
      expand_start,
      expand_end,
      title: title.clone(),
    })
  }

  pub fn parse<L: Language>(
    fixer: &SerializableFixer,
    env: &DeserializeEnv<L>,
    transform: &Option<HashMap<String, Transformation>>,
  ) -> Result<Vec<Self>, FixerError> {
    let ret = match fixer {
      SerializableFixer::Str(fix) => Self::with_transform(fix, env, transform),
      SerializableFixer::Config(cfg) => Self::do_parse(cfg, env, transform),
      SerializableFixer::List(list) => {
        return Self::parse_list(list, env, transform);
      }
    };
    Ok(vec![ret?])
  }

  fn parse_list<L: Language>(
    list: &[SerializableFixConfig],
    env: &DeserializeEnv<L>,
    transform: &Option<HashMap<String, Transformation>>,
  ) -> Result<Vec<Self>, FixerError> {
    list
      .iter()
      .map(|cfg| {
        if cfg.title.is_none() {
          return Err(FixerError::MissingTitle);
        }
        Self::do_parse(cfg, env, transform)
      })
      .collect()
  }

  pub(crate) fn with_transform<L: Language>(
    fix: &str,
    env: &DeserializeEnv<L>,
    transform: &Option<HashMap<String, Transformation>>,
  ) -> Result<Self, FixerError> {
    let template = if let Some(trans) = transform {
      let keys: Vec<_> = trans.keys().cloned().collect();
      TemplateFix::with_transform(fix, &env.lang, &keys)
    } else {
      TemplateFix::try_new(fix, &env.lang)?
    };
    Ok(Self {
      template,
      expand_end: None,
      expand_start: None,
      title: None,
    })
  }

  pub fn from_str<L: Language>(src: &str, lang: &L) -> Result<Self, FixerError> {
    let template = TemplateFix::try_new(src, lang)?;
    Ok(Self {
      template,
      expand_start: None,
      expand_end: None,
      title: None,
    })
  }

  pub fn title(&self) -> Option<&str> {
    self.title.as_deref()
  }

  pub(crate) fn used_vars(&self) -> HashSet<&str> {
    self.template.used_vars()
  }
}

impl<D, C> Replacer<D> for Fixer
where
  D: Doc<Source = C>,
  C: Content,
{
  fn generate_replacement(&self, nm: &NodeMatch<'_, D>) -> Vec<C::Underlying> {
    // simple forwarding to template
    self.template.generate_replacement(nm)
  }
  fn get_replaced_range(&self, nm: &NodeMatch<'_, D>, matcher: impl Matcher) -> Range<usize> {
    let range = nm.range();
    if self.expand_start.is_none() && self.expand_end.is_none() {
      return if let Some(len) = matcher.get_match_len(nm.get_node().clone()) {
        range.start..range.start + len
      } else {
        range
      };
    }
    let start = expand_start(self.expand_start.as_ref(), nm);
    let end = expand_end(self.expand_end.as_ref(), nm);
    start..end
  }
}

fn expand_start<D: Doc>(expansion: Option<&Expansion>, nm: &NodeMatch<'_, D>) -> usize {
  let node = nm.get_node();
  let mut env = std::borrow::Cow::Borrowed(nm.get_env());
  let Some(start) = expansion else {
    return node.range().start;
  };
  let node = start.stop_by.find(
    || node.prev(),
    || node.prev_all(),
    |n| start.matches.match_node_with_env(n, &mut env),
  );
  node
    .map(|n| n.range().start)
    .unwrap_or_else(|| nm.range().start)
}

fn expand_end<D: Doc>(expansion: Option<&Expansion>, nm: &NodeMatch<'_, D>) -> usize {
  let node = nm.get_node();
  let mut env = std::borrow::Cow::Borrowed(nm.get_env());
  let Some(end) = expansion else {
    return node.range().end;
  };
  let node = end.stop_by.find(
    || node.next(),
    || node.next_all(),
    |n| end.matches.match_node_with_env(n, &mut env),
  );
  node
    .map(|n| n.range().end)
    .unwrap_or_else(|| nm.range().end)
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::maybe::Maybe;
  use crate::test::TypeScript;
  use ast_grep_core::tree_sitter::LanguageExt;

  #[test]
  fn test_parse() {
    let fixer: SerializableFixer = from_str("test").expect("should parse");
    assert!(matches!(fixer, SerializableFixer::Str(_)));
  }

  fn parse(config: SerializableFixConfig) -> Result<Fixer, FixerError> {
    let config = SerializableFixer::Config(Box::new(config));
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let fixer = Fixer::parse(&config, &env, &Some(Default::default()))?.remove(0);
    Ok(fixer)
  }

  #[test]
  fn test_deserialize_object() -> Result<(), serde_yaml::Error> {
    let src = "{template: 'abc', expandEnd: {regex: ',', stopBy: neighbor}}";
    let SerializableFixer::Config(cfg) = from_str(src)? else {
      panic!("wrong parsing")
    };
    assert_eq!(cfg.template, "abc");
    let Maybe::Present(relation) = cfg.expand_end else {
      panic!("wrong parsing")
    };
    let rule = relation.rule;
    assert_eq!(rule.regex, Maybe::Present(",".to_string()));
    assert!(rule.pattern.is_absent());
    Ok(())
  }

  #[test]
  fn test_parse_config() -> Result<(), FixerError> {
    let relation = from_str("{regex: ',', stopBy: neighbor}").expect("should deser");
    let config = SerializableFixConfig {
      expand_end: Maybe::Present(relation),
      expand_start: Maybe::Absent,
      template: "abcd".to_string(),
      title: None,
    };
    let ret = parse(config)?;
    assert!(ret.expand_start.is_none());
    assert!(ret.expand_end.is_some());
    assert!(matches!(ret.template, TemplateFix::Textual(_)));
    Ok(())
  }

  #[test]
  fn test_parse_str() -> Result<(), FixerError> {
    let config = SerializableFixer::Str("abcd".to_string());
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ret = Fixer::parse(&config, &env, &None)?.remove(0);
    assert!(ret.expand_end.is_none());
    assert!(ret.expand_start.is_none());
    assert!(matches!(ret.template, TemplateFix::Textual(_)));
    Ok(())
  }

  #[test]
  fn test_replace_fixer() -> Result<(), FixerError> {
    let expand_end = from_str("{regex: ',', stopBy: neighbor}").expect("should word");
    let config = SerializableFixConfig {
      expand_end: Maybe::Present(expand_end),
      expand_start: Maybe::Absent,
      template: "var $A = 456".to_string(),
      title: None,
    };
    let fixer = parse(config)?;
    let grep = TypeScript::Tsx.ast_grep("let a = 123");
    let node = grep.root().find("let $A = 123").expect("should found");
    let edit = fixer.generate_replacement(&node);
    assert_eq!(String::from_utf8_lossy(&edit), "var a = 456");
    Ok(())
  }

  #[test]
  fn test_relace_range() -> Result<(), FixerError> {
    use ast_grep_core::matcher::KindMatcher;
    let expand_end = from_str("{regex: ',', stopBy: neighbor}").expect("should word");
    let config = SerializableFixConfig {
      expand_end: Maybe::Present(expand_end),
      expand_start: Maybe::Absent,
      template: "c: 456".to_string(),
      title: None,
    };
    let fixer = parse(config)?;
    let grep = TypeScript::Tsx.ast_grep("var a = { b: 123, }");
    let matcher = KindMatcher::new("pair", TypeScript::Tsx);
    let node = grep.root().find(&matcher).expect("should found");
    let edit = node.make_edit(&matcher, &fixer);
    let text = String::from_utf8_lossy(&edit.inserted_text);
    assert_eq!(text, "c: 456");
    assert_eq!(edit.position, 10);
    assert_eq!(edit.deleted_length, 7);
    Ok(())
  }

  #[test]
  fn test_fixer_list() -> Result<(), FixerError> {
    let config: SerializableFixer = from_str(
      r"
- { template: 'abc', title: 'fixer 1'}
- { template: 'def', title: 'fixer 2'}",
    )
    .expect("should parse");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let fixers = Fixer::parse(&config, &env, &Some(Default::default()))?;
    assert_eq!(fixers.len(), 2);
    let config: SerializableFixer = from_str(
      r"
- { template: 'abc', title: 'fixer 1'}
- { template: 'def'}",
    )
    .expect("should parse");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ret = Fixer::parse(&config, &env, &Some(Default::default()));
    assert!(ret.is_err());
    Ok(())
  }
}



================================================
FILE: crates/config/src/label.rs
================================================
use ast_grep_core::{Doc, Node, NodeMatch};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ops::Range};

#[derive(Serialize, Deserialize, Clone, JsonSchema, PartialEq, Eq, Debug)]
#[serde(rename_all = "camelCase")]
pub enum LabelStyle {
  /// Labels that describe the primary cause of a diagnostic.
  Primary,
  /// Labels that provide additional context for a diagnostic.
  Secondary,
}

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct LabelConfig {
  pub style: LabelStyle,
  pub message: Option<String>,
}

/// A label is a way to mark a specific part of the code with a styled message.
/// It is used to provide diagnostic information in LSP or CLI.
/// 'r represents a lifetime for the message string from `rule`.
/// 't represents a lifetime for the node from a ast `tree`.
pub struct Label<'r, 't, D: Doc> {
  pub style: LabelStyle,
  pub message: Option<&'r str>,
  pub start_node: Node<'t, D>,
  pub end_node: Node<'t, D>,
}

impl<'t, D: Doc> Label<'_, 't, D> {
  fn primary(n: &Node<'t, D>) -> Self {
    Self {
      style: LabelStyle::Primary,
      start_node: n.clone(),
      end_node: n.clone(),
      message: None,
    }
  }
  fn secondary(n: &Node<'t, D>) -> Self {
    Self {
      style: LabelStyle::Secondary,
      start_node: n.clone(),
      end_node: n.clone(),
      message: None,
    }
  }

  pub fn range(&self) -> Range<usize> {
    let start = self.start_node.range().start;
    let end = self.end_node.range().end;
    start..end
  }
}

pub fn get_labels_from_config<'r, 't, D: Doc>(
  config: &'r HashMap<String, LabelConfig>,
  node_match: &NodeMatch<'t, D>,
) -> Vec<Label<'r, 't, D>> {
  let env = node_match.get_env();
  config
    .iter()
    .filter_map(|(var, conf)| {
      let (start, end) = if let Some(n) = env.get_match(var) {
        (n.clone(), n.clone())
      } else {
        let ns = env.get_multiple_matches(var);
        let start = ns.first()?.clone();
        let end = ns.last()?.clone();
        (start, end)
      };
      Some(Label {
        style: conf.style.clone(),
        message: conf.message.as_deref(),
        start_node: start,
        end_node: end,
      })
    })
    .collect()
}

pub fn get_default_labels<'t, D: Doc>(n: &NodeMatch<'t, D>) -> Vec<Label<'static, 't, D>> {
  let mut ret = vec![Label::primary(n)];
  if let Some(secondary) = n.get_env().get_labels("secondary") {
    ret.extend(secondary.iter().map(Label::secondary));
  }
  ret
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::test::TypeScript;
  use ast_grep_core::matcher::Pattern;
  use ast_grep_core::tree_sitter::LanguageExt;
  use ast_grep_core::tree_sitter::StrDoc;

  #[test]
  fn test_label_primary_secondary() {
    let doc = TypeScript::Tsx.ast_grep("let a = 1;");
    let root = doc.root();
    let label = Label::primary(&root);
    assert_eq!(label.style, LabelStyle::Primary);
    assert_eq!(label.range(), root.range());
    let label2 = Label::<'_, '_, StrDoc<TypeScript>>::secondary(&root);
    assert_eq!(label2.style, LabelStyle::Secondary);
  }

  #[test]
  fn test_get_labels_from_config_single() {
    let doc = TypeScript::Tsx.ast_grep("let foo = 42;");
    let pattern = Pattern::try_new("let $A = $B;", TypeScript::Tsx).unwrap();
    let m = doc.root().find(pattern).unwrap();
    let mut config = std::collections::HashMap::new();
    config.insert(
      "A".to_string(),
      LabelConfig {
        style: LabelStyle::Primary,
        message: Some("var label".to_string()),
      },
    );
    let labels = get_labels_from_config(&config, &m);
    assert_eq!(labels.len(), 1);
    assert_eq!(labels[0].style, LabelStyle::Primary);
    assert_eq!(labels[0].message, Some("var label"));
  }

  #[test]
  fn test_get_labels_from_config_multiple() {
    let doc = TypeScript::Tsx.ast_grep("let foo = 42, bar = 99;");
    let pattern = Pattern::try_new("let $A = $B, $C = $D;", TypeScript::Tsx).unwrap();
    let m = doc.root().find(pattern).unwrap();
    let mut config = std::collections::HashMap::new();
    config.insert(
      "A".to_string(),
      LabelConfig {
        style: LabelStyle::Secondary,
        message: None,
      },
    );
    let labels = get_labels_from_config(&config, &m);
    assert_eq!(labels.len(), 1);
    assert_eq!(labels[0].style, LabelStyle::Secondary);
  }

  #[test]
  fn test_get_default_labels() {
    let doc = TypeScript::Tsx.ast_grep("let foo = 42;");
    let pattern = Pattern::try_new("let $A = $B;", TypeScript::Tsx).unwrap();
    let m = doc.root().find(pattern).unwrap();
    let labels = get_default_labels(&m);
    assert!(!labels.is_empty());
    assert_eq!(labels[0].style, LabelStyle::Primary);
  }
}



================================================
FILE: crates/config/src/lib.rs
================================================
mod check_var;
mod combined;
mod fixer;
mod label;
mod maybe;
mod rule;
mod rule_collection;
mod rule_config;
mod rule_core;
mod transform;

use serde::Deserialize;
use serde_yaml::{with::singleton_map_recursive::deserialize, Deserializer, Error as YamlError};

use ast_grep_core::language::Language;

pub use combined::CombinedScan;
pub use fixer::Fixer;
pub use label::{Label, LabelStyle};
pub use rule::referent_rule::GlobalRules;
pub use rule::DeserializeEnv;
pub use rule::{Rule, RuleSerializeError, SerializableRule};
pub use rule_collection::RuleCollection;
pub use rule_config::{Metadata, RuleConfig, RuleConfigError, SerializableRuleConfig, Severity};
pub use rule_core::{RuleCore, RuleCoreError, SerializableRuleCore};
pub use transform::Transformation;

pub fn from_str<'de, T: Deserialize<'de>>(s: &'de str) -> Result<T, YamlError> {
  let deserializer = Deserializer::from_str(s);
  deserialize(deserializer)
}

pub fn from_yaml_string<'a, L: Language + Deserialize<'a>>(
  yamls: &'a str,
  registration: &GlobalRules,
) -> Result<Vec<RuleConfig<L>>, RuleConfigError> {
  let mut ret = vec![];
  for yaml in Deserializer::from_str(yamls) {
    let config = RuleConfig::deserialize(yaml, registration)?;
    ret.push(config);
  }
  Ok(ret)
}
#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
  use ast_grep_core::tree_sitter::{LanguageExt, StrDoc, TSLanguage};
  use ast_grep_core::Language;
  use std::path::Path;

  #[derive(Clone, Deserialize, PartialEq, Eq)]
  pub enum TypeScript {
    Tsx,
  }
  impl Language for TypeScript {
    fn kind_to_id(&self, kind: &str) -> u16 {
      TSLanguage::from(tree_sitter_typescript::LANGUAGE_TSX).id_for_node_kind(kind, true)
    }
    fn field_to_id(&self, field: &str) -> Option<u16> {
      TSLanguage::from(tree_sitter_typescript::LANGUAGE_TSX)
        .field_id_for_name(field)
        .map(|f| f.get())
    }
    fn from_path<P: AsRef<Path>>(_path: P) -> Option<Self> {
      Some(TypeScript::Tsx)
    }
    fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
      builder.build(|src| StrDoc::try_new(src, self.clone()))
    }
  }
  impl LanguageExt for TypeScript {
    fn get_ts_language(&self) -> TSLanguage {
      tree_sitter_typescript::LANGUAGE_TSX.into()
    }
  }

  fn test_rule_match(yaml: &str, source: &str) {
    let globals = GlobalRules::default();
    let config = &from_yaml_string::<TypeScript>(yaml, &globals).expect("rule should parse")[0];
    let grep = config.language.ast_grep(source);
    assert!(grep.root().find(&config.matcher).is_some());
  }

  fn test_rule_unmatch(yaml: &str, source: &str) {
    let globals = GlobalRules::default();
    let config = &from_yaml_string::<TypeScript>(yaml, &globals).expect("rule should parse")[0];
    let grep = config.language.ast_grep(source);
    assert!(grep.root().find(&config.matcher).is_none());
  }

  fn make_yaml(rule: &str) -> String {
    format!(
      r"
id: test
message: test rule
severity: info
language: Tsx
rule:
{rule}
"
    )
  }

  #[test]
  fn test_deserialize_rule_config() {
    let yaml = &make_yaml(
      "
  pattern: let a = 123
",
    );
    test_rule_match(yaml, "let a = 123; let b = 33;");
    test_rule_match(yaml, "class B { func() {let a = 123; }}");
    test_rule_unmatch(yaml, "const a = 33");
  }

  #[test]
  fn test_deserialize_nested() {
    let yaml = &make_yaml(
      "
  all:
    - pattern: let $A = 123
    - pattern: let a = $B
",
    );
    test_rule_match(yaml, "let a = 123; let b = 33;");
    test_rule_match(yaml, "class B { func() {let a = 123; }}");
    test_rule_unmatch(yaml, "const a = 33");
    test_rule_unmatch(yaml, "let a = 33");
  }

  #[test]
  fn test_deserialize_kind() {
    let yaml = &make_yaml(
      "
    kind: class_body
",
    );
    test_rule_match(yaml, "class B { func() {let a = 123; }}");
    test_rule_unmatch(yaml, "const B = { func() {let a = 123; }}");
  }

  #[test]
  fn test_deserialize_inside() {
    let yaml = &make_yaml(
      "
  all:
    - inside:
        kind: class_body
        stopBy: end
    - pattern: let a = 123
",
    );
    test_rule_unmatch(yaml, "let a = 123; let b = 33;");
    test_rule_match(yaml, "class B { func() {let a = 123; }}");
    test_rule_unmatch(yaml, "let a = 123");
  }

  #[test]
  fn test_deserialize_not_inside() {
    let yaml = &make_yaml(
      "
  all:
    - not:
        inside:
          kind: class_body
          stopBy: end
    - pattern: let a = 123
",
    );
    test_rule_match(yaml, "let a = 123; let b = 33;");
    test_rule_unmatch(yaml, "class B { func() {let a = 123; }}");
    test_rule_unmatch(yaml, "let a = 13");
  }

  #[test]
  fn test_deserialize_meta_var() {
    let yaml = &make_yaml(
      "
  all:
    - inside:
        any:
          - pattern: function $A($$$) { $$$ }
          - pattern: let $A = ($$$) => $$$
        stopBy: end
    - pattern: $A($$$)
",
    );
    test_rule_match(yaml, "function recursion() { recursion() }");
    test_rule_match(yaml, "let recursion = () => { recursion() }");
    test_rule_unmatch(yaml, "function callOther() { other() }");
  }

  #[test]
  fn test_deserialize_constraints() {
    let yaml = r"
id: test
message: test rule
severity: info
language: Tsx
rule:
  all:
    - pattern: console.log($A)
    - inside:
        pattern: function $B() {$$$}
        stopBy: end
constraints:
  B:
    regex: test
";
    test_rule_match(yaml, "function test() { console.log(1) }");
    test_rule_match(yaml, "function test() { console.log(2) }");
    test_rule_unmatch(yaml, "function tt() { console.log(2) }");
  }

  // https://github.com/ast-grep/ast-grep/issues/813
  #[test]
  fn test_util_rule_with_vaargs() {
    let yaml = r"
id: sibling
language: Tsx
utils:
  utilpat:
    pattern: '$A($$$B);'
rule:
  matches: utilpat
  follows:
    matches: utilpat
    stopBy: end
";
    test_rule_match(yaml, "a();a(123);a();a(123)");
  }
}



================================================
FILE: crates/config/src/maybe.rs
================================================
use schemars::{JsonSchema, Schema, SchemaGenerator};
use serde::{de, ser, Deserialize, Serialize};
use std::borrow::Cow;

#[derive(Clone, PartialEq, Eq, Debug, Copy, Default)]
pub enum Maybe<T> {
  #[default]
  Absent,
  Present(T),
}

impl<T> Maybe<T> {
  pub fn is_present(&self) -> bool {
    matches!(self, Maybe::Present(_))
  }
  pub fn is_absent(&self) -> bool {
    matches!(self, Maybe::Absent)
  }
  pub fn unwrap(self) -> T {
    match self {
      Maybe::Absent => panic!("called `Maybe::unwrap()` on an `Absent` value"),
      Maybe::Present(t) => t,
    }
  }
}

impl<T> From<Maybe<T>> for Option<T> {
  fn from(maybe: Maybe<T>) -> Self {
    match maybe {
      Maybe::Present(v) => Some(v),
      Maybe::Absent => None,
    }
  }
}

impl<T> From<Option<T>> for Maybe<T> {
  fn from(opt: Option<T>) -> Maybe<T> {
    match opt {
      Some(v) => Maybe::Present(v),
      None => Maybe::Absent,
    }
  }
}

const ERROR_STR: &str = r#"Maybe fields need to be annotated with:
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]"#;

impl<T: Serialize> Serialize for Maybe<T> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      Maybe::Absent => Err(ser::Error::custom(ERROR_STR)),
      Maybe::Present(t) => T::serialize(t, serializer),
    }
  }
}

impl<'de, T: Deserialize<'de>> Deserialize<'de> for Maybe<T> {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    match Option::deserialize(deserializer)? {
      Some(t) => Ok(Maybe::Present(t)),
      None => Err(de::Error::custom("Maybe field cannot be null.")),
    }
  }
}

impl<T: JsonSchema> JsonSchema for Maybe<T> {
  fn schema_name() -> Cow<'static, str> {
    Cow::Owned(format!("Maybe_{}", T::schema_name()))
  }
  fn schema_id() -> Cow<'static, str> {
    Cow::Owned(format!("Maybe<{}>", T::schema_id()))
  }
  fn json_schema(gen: &mut SchemaGenerator) -> Schema {
    gen.subschema_for::<T>()
  }

  fn inline_schema() -> bool {
    true
  }

  fn _schemars_private_non_optional_json_schema(gen: &mut SchemaGenerator) -> Schema {
    T::_schemars_private_non_optional_json_schema(gen)
  }

  fn _schemars_private_is_option() -> bool {
    true
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;

  #[derive(Serialize, Deserialize, Debug)]
  struct Correct {
    #[serde(default, skip_serializing_if = "Maybe::is_absent")]
    a: Maybe<i32>,
  }
  #[derive(Serialize, Deserialize, Debug)]
  struct Wrong {
    #[serde(skip_serializing_if = "Maybe::is_absent")]
    a: Maybe<i32>,
  }

  #[test]
  fn test_de_correct_ok() {
    let correct: Correct = from_str("a: 123").expect("should ok");
    assert!(matches!(correct.a, Maybe::Present(123)));
    let correct: Correct = from_str("").expect("should ok");
    assert!(matches!(correct.a, Maybe::Absent));
  }
  #[test]
  fn test_de_correct_err() {
    let ret: Result<Correct, _> = from_str("a:");
    assert!(ret.is_err());
    let err = ret.unwrap_err().to_string();
    assert!(err.contains("cannot be null"));
  }
  #[test]
  fn test_de_wrong_err() {
    let wrong: Wrong = from_str("a: 123").expect("should ok");
    assert!(matches!(wrong.a, Maybe::Present(123)));
    let wrong: Result<Wrong, _> = from_str("a:");
    assert!(wrong.is_err());
    let wrong: Result<Wrong, _> = from_str("");
    assert!(wrong.is_err());
  }

  #[test]
  #[should_panic]
  fn test_unwrap_absent() {
    let nothing: Maybe<()> = Maybe::Absent;
    nothing.unwrap();
  }

  #[test]
  fn test_from_optio() {
    let mut maybe = Maybe::from(None);
    assert!(maybe.is_absent());
    maybe = Maybe::from(Some(123));
    assert!(maybe.is_present());
  }
}



================================================
FILE: crates/config/src/rule_collection.rs
================================================
use crate::{RuleConfig, Severity};
use ast_grep_core::language::Language;
use globset::{Glob, GlobSet, GlobSetBuilder};
use std::path::Path;

/// RuleBucket stores rules of the same language id.
/// Rules for different language will stay in separate buckets.
pub struct RuleBucket<L: Language> {
  rules: Vec<RuleConfig<L>>,
  lang: L,
}

impl<L: Language> RuleBucket<L> {
  fn new(lang: L) -> Self {
    Self {
      rules: vec![],
      lang,
    }
  }
  pub fn add(&mut self, rule: RuleConfig<L>) {
    self.rules.push(rule);
  }
}

struct ContingentRule<L: Language> {
  rule: RuleConfig<L>,
  files_globs: Option<GlobSet>,
  ignore_globs: Option<GlobSet>,
}

fn build_glob_set(paths: &Vec<String>) -> Result<GlobSet, globset::Error> {
  let mut builder = GlobSetBuilder::new();
  for path in paths {
    builder.add(Glob::new(path)?);
  }
  builder.build()
}

impl<L> TryFrom<RuleConfig<L>> for ContingentRule<L>
where
  L: Language,
{
  type Error = globset::Error;
  fn try_from(rule: RuleConfig<L>) -> Result<Self, Self::Error> {
    let files_globs = rule.files.as_ref().map(build_glob_set).transpose()?;
    let ignore_globs = rule.ignores.as_ref().map(build_glob_set).transpose()?;
    Ok(Self {
      rule,
      files_globs,
      ignore_globs,
    })
  }
}

impl<L: Language> ContingentRule<L> {
  pub fn matches_path<P: AsRef<Path>>(&self, path: P) -> bool {
    if let Some(ignore_globs) = &self.ignore_globs {
      if ignore_globs.is_match(&path) {
        return false;
      }
    }
    if let Some(files_globs) = &self.files_globs {
      return files_globs.is_match(path);
    }
    true
  }
}

/// A collection of rules to run one round of scanning.
/// Rules will be grouped together based on their language, path globbing and pattern rule.
pub struct RuleCollection<L: Language + Eq> {
  // use vec since we don't have many languages
  /// a list of rule buckets grouped by languages.
  /// Tenured rules will always run against a file of that language type.
  tenured: Vec<RuleBucket<L>>,
  /// contingent rules will run against a file if it matches file/ignore glob.
  contingent: Vec<ContingentRule<L>>,
}

impl<L: Language + Eq> RuleCollection<L> {
  pub fn try_new(configs: Vec<RuleConfig<L>>) -> Result<Self, globset::Error> {
    let mut tenured = vec![];
    let mut contingent = vec![];
    for config in configs {
      if matches!(config.severity, Severity::Off) {
        continue;
      } else if config.files.is_none() && config.ignores.is_none() {
        Self::add_tenured_rule(&mut tenured, config);
      } else {
        contingent.push(ContingentRule::try_from(config)?);
      }
    }
    Ok(Self {
      tenured,
      contingent,
    })
  }

  pub fn get_rule_from_lang(&self, path: &Path, lang: L) -> Vec<&RuleConfig<L>> {
    let mut all_rules = vec![];
    for rule in &self.tenured {
      if rule.lang == lang {
        all_rules = rule.rules.iter().collect();
        break;
      }
    }
    all_rules.extend(self.contingent.iter().filter_map(|cont| {
      if cont.rule.language == lang && cont.matches_path(path) {
        Some(&cont.rule)
      } else {
        None
      }
    }));
    all_rules
  }

  pub fn for_path<P: AsRef<Path>>(&self, path: P) -> Vec<&RuleConfig<L>> {
    let path = path.as_ref();
    let Some(lang) = L::from_path(path) else {
      return vec![];
    };
    let mut ret = self.get_rule_from_lang(path, lang);
    ret.sort_unstable_by_key(|r| &r.id);
    ret
  }

  pub fn get_rule(&self, id: &str) -> Option<&RuleConfig<L>> {
    for rule in &self.tenured {
      for r in &rule.rules {
        if r.id == id {
          return Some(r);
        }
      }
    }
    for rule in &self.contingent {
      if rule.rule.id == id {
        return Some(&rule.rule);
      }
    }
    None
  }

  pub fn total_rule_count(&self) -> usize {
    let mut ret = self.tenured.iter().map(|bucket| bucket.rules.len()).sum();
    ret += self.contingent.len();
    ret
  }

  pub fn for_each_rule(&self, mut f: impl FnMut(&RuleConfig<L>)) {
    for bucket in &self.tenured {
      for rule in &bucket.rules {
        f(rule);
      }
    }
    for rule in &self.contingent {
      f(&rule.rule);
    }
  }

  fn add_tenured_rule(tenured: &mut Vec<RuleBucket<L>>, rule: RuleConfig<L>) {
    let lang = rule.language.clone();
    for bucket in tenured.iter_mut() {
      if bucket.lang == lang {
        bucket.add(rule);
        return;
      }
    }
    let mut bucket = RuleBucket::new(lang);
    bucket.add(rule);
    tenured.push(bucket);
  }
}

impl<L: Language + Eq> Default for RuleCollection<L> {
  fn default() -> Self {
    Self {
      tenured: vec![],
      contingent: vec![],
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_yaml_string;
  use crate::test::TypeScript;
  use crate::GlobalRules;

  fn make_rule(files: &str) -> RuleCollection<TypeScript> {
    let globals = GlobalRules::default();
    let rule_config = from_yaml_string(
      &format!(
        r"
id: test
message: test rule
severity: info
language: Tsx
rule:
  all: [kind: number]
{files}"
      ),
      &globals,
    )
    .unwrap()
    .pop()
    .unwrap();
    RuleCollection::try_new(vec![rule_config]).expect("should parse")
  }

  fn assert_match_path(collection: &RuleCollection<TypeScript>, path: &str) {
    let rules = collection.for_path(path);
    assert_eq!(rules.len(), 1);
    assert_eq!(rules[0].id, "test");
  }

  fn assert_ignore_path(collection: &RuleCollection<TypeScript>, path: &str) {
    let rules = collection.for_path(path);
    assert!(rules.is_empty());
  }

  #[test]
  fn test_ignore_rule() {
    let src = r#"
ignores:
  - ./manage.py
  - "**/test*"
"#;
    let collection = make_rule(src);
    assert_ignore_path(&collection, "./manage.py");
    assert_ignore_path(&collection, "./src/test.py");
    assert_match_path(&collection, "./src/app.py");
  }

  #[test]
  fn test_files_rule() {
    let src = r#"
files:
  - ./manage.py
  - "**/test*"
"#;
    let collection = make_rule(src);
    assert_match_path(&collection, "./manage.py");
    assert_match_path(&collection, "./src/test.py");
    assert_ignore_path(&collection, "./src/app.py");
  }

  #[test]
  fn test_files_with_ignores_rule() {
    let src = r#"
files:
  - ./src/**/*.py
ignores:
  - ./src/excluded/*.py
"#;
    let collection = make_rule(src);
    assert_match_path(&collection, "./src/test.py");
    assert_match_path(&collection, "./src/some_folder/test.py");
    assert_ignore_path(&collection, "./src/excluded/app.py");
  }

  #[test]
  fn test_rule_collection_get_contingent_rule() {
    let src = r#"
files:
  - ./manage.py
  - "**/test*"
"#;
    let collection = make_rule(src);
    assert!(collection.get_rule("test").is_some());
  }

  #[test]
  fn test_rule_collection_get_tenured_rule() {
    let src = r#""#;
    let collection = make_rule(src);
    assert!(collection.get_rule("test").is_some());
  }

  #[test]
  #[ignore]
  fn test_rules_for_path() {
    todo!()
  }
}



================================================
FILE: crates/config/src/rule_config.rs
================================================
use crate::GlobalRules;

use crate::check_var::{check_rewriters_in_transform, CheckHint};
use crate::fixer::Fixer;
use crate::label::{get_default_labels, get_labels_from_config, Label, LabelConfig};
use crate::rule::DeserializeEnv;
use crate::rule_core::{RuleCore, RuleCoreError, SerializableRuleCore};

use ast_grep_core::language::Language;
use ast_grep_core::replacer::Replacer;
use ast_grep_core::source::Content;
use ast_grep_core::{Doc, Matcher, NodeMatch};

use schemars::{json_schema, JsonSchema, Schema, SchemaGenerator};
use serde::{Deserialize, Serialize};
use serde_yaml::Error as YamlError;
use serde_yaml::{with::singleton_map_recursive::deserialize, Deserializer};
use thiserror::Error;

use std::borrow::Cow;
use std::collections::HashMap;
use std::ops::{Deref, DerefMut};

#[derive(Serialize, Deserialize, Clone, Default, JsonSchema, Debug)]
#[serde(rename_all = "camelCase")]
pub enum Severity {
  #[default]
  /// A kind reminder for code with potential improvement.
  Hint,
  /// A suggestion that code can be improved or optimized.
  Info,
  /// A warning that code might produce bugs or does not follow best practice.
  Warning,
  /// An error that code produces bugs or has logic errors.
  Error,
  /// Turns off the rule.
  Off,
}

#[derive(Debug, Error)]
pub enum RuleConfigError {
  #[error("Fail to parse yaml as RuleConfig")]
  Yaml(#[from] YamlError),
  #[error("Fail to parse yaml as Rule.")]
  Core(#[from] RuleCoreError),
  #[error("Rewriter rule `{1}` is not configured correctly.")]
  Rewriter(#[source] RuleCoreError, String),
  #[error("Undefined rewriter `{0}` used in transform.")]
  UndefinedRewriter(String),
  #[error("Rewriter rule `{0}` should have `fix`.")]
  NoFixInRewriter(String),
  #[error("Label meta-variable `{0}` must be defined in `rule` or `constraints`.")]
  LabelVariable(String),
  #[error("Rule must specify a set of AST kinds to match. Try adding `kind` rule.")]
  MissingPotentialKinds,
}

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct SerializableRewriter {
  #[serde(flatten)]
  pub core: SerializableRuleCore,
  /// Unique, descriptive identifier, e.g., no-unused-variable
  pub id: String,
}

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[schemars(title = "ast-grep rule")]
pub struct SerializableRuleConfig<L: Language> {
  #[serde(flatten)]
  pub core: SerializableRuleCore,
  /// Unique, descriptive identifier, e.g., no-unused-variable
  pub id: String,
  /// Specify the language to parse and the file extension to include in matching.
  pub language: L,
  /// Rewrite rules for `rewrite` transformation
  pub rewriters: Option<Vec<SerializableRewriter>>,
  /// Main message highlighting why this rule fired. It should be single line and concise,
  /// but specific enough to be understood without additional context.
  #[serde(default)]
  pub message: String,
  /// Additional notes to elaborate the message and provide potential fix to the issue.
  /// `notes` can contain markdown syntax, but it cannot reference meta-variables.
  pub note: Option<String>,
  /// One of: hint, info, warning, or error
  #[serde(default)]
  pub severity: Severity,
  /// Custom label dictionary to configure reporting. Key is the meta-variable name and
  /// value is the label message and label style.
  pub labels: Option<HashMap<String, LabelConfig>>,
  /// Glob patterns to specify that the rule only applies to matching files
  pub files: Option<Vec<String>>,
  /// Glob patterns that exclude rules from applying to files
  pub ignores: Option<Vec<String>>,
  /// Documentation link to this rule
  pub url: Option<String>,
  /// Extra information for the rule
  pub metadata: Option<Metadata>,
}

/// A trivial wrapper around a HashMap to work around
/// the limitation of `serde_yaml::Value` not implementing `JsonSchema`.
#[derive(Serialize, Deserialize, Clone)]
pub struct Metadata(HashMap<String, serde_yaml::Value>);

impl JsonSchema for Metadata {
  fn schema_name() -> Cow<'static, str> {
    Cow::Borrowed("Metadata")
  }
  fn schema_id() -> Cow<'static, str> {
    Cow::Borrowed("Metadata")
  }
  fn json_schema(_gen: &mut SchemaGenerator) -> Schema {
    json_schema!({
      "type": "object",
      "additionalProperties": true,
      "description": "Additional metadata for the rule, can be used to store extra information."
    })
  }
}

impl<L: Language> SerializableRuleConfig<L> {
  pub fn get_matcher(&self, globals: &GlobalRules) -> Result<RuleCore, RuleConfigError> {
    // every RuleConfig has one rewriters, and the rewriter is shared between sub-rules
    // all RuleConfigs has one common globals
    // every sub-rule has one util
    let env = DeserializeEnv::new(self.language.clone()).with_globals(globals);
    let rule = self.core.get_matcher(env.clone())?;
    self.register_rewriters(&rule, env)?;
    self.check_labels(&rule)?;
    Ok(rule)
  }

  fn check_labels(&self, rule: &RuleCore) -> Result<(), RuleConfigError> {
    let Some(labels) = &self.labels else {
      return Ok(());
    };
    // labels var must be vars with node, transform var cannot be used
    let vars = rule.defined_node_vars();
    for var in labels.keys() {
      if !vars.contains(var.as_str()) {
        return Err(RuleConfigError::LabelVariable(var.clone()));
      }
    }
    Ok(())
  }

  fn register_rewriters(
    &self,
    rule: &RuleCore,
    env: DeserializeEnv<L>,
  ) -> Result<(), RuleConfigError> {
    let Some(ser) = &self.rewriters else {
      return Ok(());
    };
    let reg = &env.registration;
    let vars = rule.defined_vars();
    for val in ser {
      if val.core.fix.is_none() {
        return Err(RuleConfigError::NoFixInRewriter(val.id.clone()));
      }
      let rewriter = val
        .core
        .get_matcher_with_hint(env.clone(), CheckHint::Rewriter(&vars))
        .map_err(|e| RuleConfigError::Rewriter(e, val.id.clone()))?;
      reg.insert_rewriter(&val.id, rewriter);
    }
    check_rewriters_in_transform(rule, reg.get_rewriters())?;
    Ok(())
  }
}

impl<L: Language> Deref for SerializableRuleConfig<L> {
  type Target = SerializableRuleCore;
  fn deref(&self) -> &Self::Target {
    &self.core
  }
}

impl<L: Language> DerefMut for SerializableRuleConfig<L> {
  fn deref_mut(&mut self) -> &mut Self::Target {
    &mut self.core
  }
}

pub struct RuleConfig<L: Language> {
  inner: SerializableRuleConfig<L>,
  pub matcher: RuleCore,
}

impl<L: Language> RuleConfig<L> {
  pub fn try_from(
    inner: SerializableRuleConfig<L>,
    globals: &GlobalRules,
  ) -> Result<Self, RuleConfigError> {
    let matcher = inner.get_matcher(globals)?;
    if matcher.potential_kinds().is_none() {
      return Err(RuleConfigError::MissingPotentialKinds);
    }
    Ok(Self { inner, matcher })
  }

  pub fn deserialize<'de>(
    deserializer: Deserializer<'de>,
    globals: &GlobalRules,
  ) -> Result<Self, RuleConfigError>
  where
    L: Deserialize<'de>,
  {
    let inner: SerializableRuleConfig<L> = deserialize(deserializer)?;
    Self::try_from(inner, globals)
  }

  pub fn get_message<D>(&self, node: &NodeMatch<D>) -> String
  where
    D: Doc,
  {
    let env = self.matcher.get_env(self.language.clone());
    let parsed = Fixer::with_transform(&self.message, &env, &self.transform).expect("should work");
    let bytes = parsed.generate_replacement(node);
    <D::Source as Content>::encode_bytes(&bytes).to_string()
  }
  pub fn get_fixer(&self) -> Result<Vec<Fixer>, RuleConfigError> {
    if let Some(fix) = &self.fix {
      let env = self.matcher.get_env(self.language.clone());
      let parsed = Fixer::parse(fix, &env, &self.transform).map_err(RuleCoreError::Fixer)?;
      Ok(parsed)
    } else {
      Ok(vec![])
    }
  }
  pub fn get_labels<'t, D: Doc>(&self, node: &NodeMatch<'t, D>) -> Vec<Label<'_, 't, D>> {
    if let Some(labels_config) = &self.labels {
      get_labels_from_config(labels_config, node)
    } else {
      get_default_labels(node)
    }
  }
}
impl<L: Language> Deref for RuleConfig<L> {
  type Target = SerializableRuleConfig<L>;
  fn deref(&self) -> &Self::Target {
    &self.inner
  }
}

impl<L: Language> DerefMut for RuleConfig<L> {
  fn deref_mut(&mut self) -> &mut Self::Target {
    &mut self.inner
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::rule::SerializableRule;
  use crate::test::TypeScript;
  use ast_grep_core::tree_sitter::LanguageExt;

  fn ts_rule_config(rule: SerializableRule) -> SerializableRuleConfig<TypeScript> {
    let core = SerializableRuleCore {
      rule,
      constraints: None,
      transform: None,
      utils: None,
      fix: None,
    };
    SerializableRuleConfig {
      core,
      id: "".into(),
      language: TypeScript::Tsx,
      rewriters: None,
      message: "".into(),
      note: None,
      severity: Severity::Hint,
      labels: None,
      files: None,
      ignores: None,
      url: None,
      metadata: None,
    }
  }

  #[test]
  fn test_rule_message() {
    let globals = GlobalRules::default();
    let rule = from_str("pattern: class $A {}").expect("cannot parse rule");
    let mut config = ts_rule_config(rule);
    config.id = "test".into();
    config.message = "Found $A".into();
    let config = RuleConfig::try_from(config, &Default::default()).expect("should work");
    let grep = TypeScript::Tsx.ast_grep("class TestClass {}");
    let node_match = grep
      .root()
      .find(config.get_matcher(&globals).unwrap())
      .expect("should find match");
    assert_eq!(config.get_message(&node_match), "Found TestClass");
  }

  #[test]
  fn test_augmented_rule() {
    let globals = GlobalRules::default();
    let rule = from_str(
      "
pattern: console.log($A)
inside:
  stopBy: end
  pattern: function test() { $$$ }
",
    )
    .expect("should parse");
    let config = ts_rule_config(rule);
    let grep = TypeScript::Tsx.ast_grep("console.log(1)");
    let matcher = config.get_matcher(&globals).unwrap();
    assert!(grep.root().find(&matcher).is_none());
    let grep = TypeScript::Tsx.ast_grep("function test() { console.log(1) }");
    assert!(grep.root().find(&matcher).is_some());
  }

  #[test]
  fn test_multiple_augment_rule() {
    let globals = GlobalRules::default();
    let rule = from_str(
      "
pattern: console.log($A)
inside:
  stopBy: end
  pattern: function test() { $$$ }
has:
  stopBy: end
  pattern: '123'
",
    )
    .expect("should parse");
    let config = ts_rule_config(rule);
    let grep = TypeScript::Tsx.ast_grep("function test() { console.log(1) }");
    let matcher = config.get_matcher(&globals).unwrap();
    assert!(grep.root().find(&matcher).is_none());
    let grep = TypeScript::Tsx.ast_grep("function test() { console.log(123) }");
    assert!(grep.root().find(&matcher).is_some());
  }

  #[test]
  fn test_rule_env() {
    let globals = GlobalRules::default();
    let rule = from_str(
      "
all:
  - pattern: console.log($A)
  - inside:
      stopBy: end
      pattern: function $B() {$$$}
",
    )
    .expect("should parse");
    let config = ts_rule_config(rule);
    let grep = TypeScript::Tsx.ast_grep("function test() { console.log(1) }");
    let node_match = grep
      .root()
      .find(config.get_matcher(&globals).unwrap())
      .expect("should found");
    let env = node_match.get_env();
    let a = env.get_match("A").expect("should exist").text();
    assert_eq!(a, "1");
    let b = env.get_match("B").expect("should exist").text();
    assert_eq!(b, "test");
  }

  #[test]
  fn test_transform() {
    let globals = GlobalRules::default();
    let rule = from_str("pattern: console.log($A)").expect("should parse");
    let mut config = ts_rule_config(rule);
    let transform = from_str(
      "
B:
  substring:
    source: $A
    startChar: 1
    endChar: -1
",
    )
    .expect("should parse");
    config.transform = Some(transform);
    let grep = TypeScript::Tsx.ast_grep("function test() { console.log(123) }");
    let node_match = grep
      .root()
      .find(config.get_matcher(&globals).unwrap())
      .expect("should found");
    let env = node_match.get_env();
    let a = env.get_match("A").expect("should exist").text();
    assert_eq!(a, "123");
    let b = env.get_transformed("B").expect("should exist");
    assert_eq!(b, b"2");
  }

  fn get_matches_config() -> SerializableRuleConfig<TypeScript> {
    let rule = from_str(
      "
matches: test-rule
",
    )
    .unwrap();
    let utils = from_str(
      "
test-rule:
  pattern: some($A)
",
    )
    .unwrap();
    let mut ret = ts_rule_config(rule);
    ret.utils = Some(utils);
    ret
  }

  #[test]
  fn test_utils_rule() {
    let globals = GlobalRules::default();
    let config = get_matches_config();
    let matcher = config.get_matcher(&globals).unwrap();
    let grep = TypeScript::Tsx.ast_grep("some(123)");
    assert!(grep.root().find(&matcher).is_some());
    let grep = TypeScript::Tsx.ast_grep("some()");
    assert!(grep.root().find(&matcher).is_none());
  }
  #[test]
  fn test_get_fixer() {
    let globals = GlobalRules::default();
    let mut config = get_matches_config();
    config.fix = Some(from_str("string!!").unwrap());
    let rule = RuleConfig::try_from(config, &globals).unwrap();
    let fixer = rule.get_fixer().unwrap().remove(0);
    let grep = TypeScript::Tsx.ast_grep("some(123)");
    let nm = grep.root().find(&rule.matcher).unwrap();
    let replacement = fixer.generate_replacement(&nm);
    assert_eq!(String::from_utf8_lossy(&replacement), "string!!");
  }

  #[test]
  fn test_add_rewriters() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
transform:
  B:
    rewrite:
      rewriters: [re]
      source: $A
rewriters:
- id: re
  rule: {kind: number}
  fix: yjsnp
    ",
    )
    .expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("work");
    let grep = TypeScript::Tsx.ast_grep("a = 123");
    let nm = grep.root().find(&rule.matcher).unwrap();
    let b = nm.get_env().get_transformed("B").expect("should have");
    assert_eq!(String::from_utf8_lossy(b), "yjsnp");
  }

  #[test]
  fn test_rewriters_access_utils() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
utils:
  num: { kind: number }
transform:
  B:
    rewrite:
      rewriters: [re]
      source: $A
rewriters:
- id: re
  rule: {matches: num, pattern: $NOT}
  fix: yjsnp
    ",
    )
    .expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("work");
    let grep = TypeScript::Tsx.ast_grep("a = 456");
    let nm = grep.root().find(&rule.matcher).unwrap();
    let b = nm.get_env().get_transformed("B").expect("should have");
    assert!(nm.get_env().get_match("NOT").is_none());
    assert_eq!(String::from_utf8_lossy(b), "yjsnp");
  }

  #[test]
  fn test_rewriter_utils_should_not_pollute_registration() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {matches: num}
language: Tsx
transform:
  B:
    rewrite:
      rewriters: [re]
      source: $B
rewriters:
- id: re
  rule: {matches: num}
  fix: yjsnp
  utils:
    num: { kind: number }
    ",
    )
    .expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    assert!(matches!(ret, Err(RuleConfigError::Core(_))));
  }

  #[test]
  fn test_rewriter_should_have_fix() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {kind: number}
language: Tsx
rewriters:
- id: wrong
  rule: {matches: num}",
    )
    .expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    match ret {
      Err(RuleConfigError::NoFixInRewriter(name)) => assert_eq!(name, "wrong"),
      _ => panic!("unexpected error"),
    }
  }

  #[test]
  fn test_utils_in_rewriter_should_work() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
transform:
  B:
    rewrite:
      rewriters: [re]
      source: $A
rewriters:
- id: re
  rule: {matches: num}
  fix: yjsnp
  utils:
    num: { kind: number }
    ",
    )
    .expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("work");
    let grep = TypeScript::Tsx.ast_grep("a = 114514");
    let nm = grep.root().find(&rule.matcher).unwrap();
    let b = nm.get_env().get_transformed("B").expect("should have");
    assert_eq!(String::from_utf8_lossy(b), "yjsnp");
  }

  #[test]
  fn test_use_rewriter_recursive() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
transform:
  B: { rewrite: { rewriters: [re], source: $A } }
rewriters:
- id: handle-num
  rule: {regex: '114'}
  fix: '1919810'
- id: re
  rule: {kind: number, pattern: $A}
  transform:
    B: { rewrite: { rewriters: [handle-num], source: $A } }
  fix: $B
    ",
    )
    .expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("work");
    let grep = TypeScript::Tsx.ast_grep("a = 114514");
    let nm = grep.root().find(&rule.matcher).unwrap();
    let b = nm.get_env().get_transformed("B").expect("should have");
    assert_eq!(String::from_utf8_lossy(b), "1919810");
  }

  fn make_undefined_error(src: &str) -> String {
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let err = RuleConfig::try_from(rule, &Default::default());
    match err {
      Err(RuleConfigError::UndefinedRewriter(name)) => name,
      _ => panic!("unexpected parsing result"),
    }
  }

  #[test]
  fn test_undefined_rewriter() {
    let undefined = make_undefined_error(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
transform:
  B: { rewrite: { rewriters: [not-defined], source: $A } }
rewriters:
- id: re
  rule: {kind: number, pattern: $A}
  fix: hah
    ",
    );
    assert_eq!(undefined, "not-defined");
  }
  #[test]
  fn test_wrong_rewriter() {
    let rule: SerializableRuleConfig<TypeScript> = from_str(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
rewriters:
- id: wrong
  rule: {kind: '114'}
  fix: '1919810'
    ",
    )
    .expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    match ret {
      Err(RuleConfigError::Rewriter(_, name)) => assert_eq!(name, "wrong"),
      _ => panic!("unexpected error"),
    }
  }

  #[test]
  fn test_undefined_rewriter_in_transform() {
    let undefined = make_undefined_error(
      r"
id: test
rule: {pattern: 'a = $A'}
language: Tsx
transform:
  B: { rewrite: { rewriters: [re], source: $A } }
rewriters:
- id: re
  rule: {kind: number, pattern: $A}
  transform:
    C: { rewrite: { rewriters: [nested-undefined], source: $A } }
  fix: hah
    ",
    );
    assert_eq!(undefined, "nested-undefined");
  }

  #[test]
  fn test_rewriter_use_upper_var() {
    let src = r"
id: test
rule: {pattern: '$B = $A'}
language: Tsx
transform:
  D: { rewrite: { rewriters: [re], source: $A } }
rewriters:
- id: re
  rule: {kind: number, pattern: $C}
  fix: $B.$C
    ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    assert!(ret.is_ok());
  }

  #[test]
  fn test_rewriter_use_undefined_var() {
    let src = r"
id: test
rule: {pattern: '$B = $A'}
language: Tsx
transform:
  B: { rewrite: { rewriters: [re], source: $A } }
rewriters:
- id: re
  rule: {kind: number, pattern: $C}
  fix: $D.$C
    ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    assert!(ret.is_err());
  }

  #[test]
  fn test_get_message_transform() {
    let src = r"
id: test-rule
language: Tsx
rule: { kind: string, pattern: $ARG }
transform:
  TEST: { replace: { replace: 'a', by: 'b', source: $ARG, } }
message: $TEST
    ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("should work");
    let grep = TypeScript::Tsx.ast_grep("a = '123'");
    let nm = grep.root().find(&rule.matcher).unwrap();
    assert_eq!(rule.get_message(&nm), "'123'");
  }

  #[test]
  fn test_get_message_transform_string() {
    let src = r"
id: test-rule
language: Tsx
rule: { kind: string, pattern: $ARG }
transform:
  TEST: replace($ARG, replace=a, by=b)
message: $TEST
    ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("should work");
    let grep = TypeScript::Tsx.ast_grep("a = '123'");
    let nm = grep.root().find(&rule.matcher).unwrap();
    assert_eq!(rule.get_message(&nm), "'123'");
  }

  #[test]
  fn test_complex_metadata() {
    let src = r"
id: test-rule
language: Tsx
rule: { kind: string }
metadata:
  test: [1, 2, 3]
  ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let rule = RuleConfig::try_from(rule, &Default::default()).expect("should work");
    let grep = TypeScript::Tsx.ast_grep("a = '123'");
    let nm = grep.root().find(&rule.matcher);
    assert!(nm.is_some());
  }

  #[test]
  fn test_label() {
    let src = r"
id: test-rule
language: Tsx
rule: { pattern: Some($A) }
labels:
  A: { style: primary, message: 'var label' }
  ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    assert!(ret.is_ok());
    let src = r"
id: test-rule
language: Tsx
rule: { pattern: Some($A) }
labels:
  B: { style: primary, message: 'var label' }
  ";
    let rule: SerializableRuleConfig<TypeScript> = from_str(src).expect("should parse");
    let ret = RuleConfig::try_from(rule, &Default::default());
    assert!(matches!(ret, Err(RuleConfigError::LabelVariable(_))));
  }
}



================================================
FILE: crates/config/src/rule_core.rs
================================================
use crate::check_var::{check_rule_with_hint, CheckHint};
use crate::fixer::{Fixer, FixerError, SerializableFixer};
use crate::rule::referent_rule::RuleRegistration;
use crate::rule::Rule;
use crate::rule::{RuleSerializeError, SerializableRule};
use crate::transform::{Transform, TransformError, Transformation};
use crate::DeserializeEnv;

use ast_grep_core::language::Language;
use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::{Doc, Matcher, Node};
use serde::{Deserialize, Serialize};
use serde_yaml::Error as YamlError;

use bit_set::BitSet;
use schemars::JsonSchema;
use thiserror::Error;

use std::borrow::Cow;
use std::collections::{HashMap, HashSet};
use std::ops::Deref;

#[derive(Debug, Error)]
pub enum RuleCoreError {
  #[error("Fail to parse yaml as RuleConfig")]
  Yaml(#[from] YamlError),
  #[error("`utils` is not configured correctly.")]
  Utils(#[source] RuleSerializeError),
  #[error("`rule` is not configured correctly.")]
  Rule(#[from] RuleSerializeError),
  #[error("`constraints` is not configured correctly.")]
  Constraints(#[source] RuleSerializeError),
  #[error("`transform` is not configured correctly.")]
  Transform(#[from] TransformError),
  #[error("`fix` pattern is invalid.")]
  Fixer(#[from] FixerError),
  #[error("Undefined meta var `{0}` used in `{1}`.")]
  UndefinedMetaVar(String, &'static str),
}

type RResult<T> = std::result::Result<T, RuleCoreError>;

/// Used for global rules, rewriters, and pyo3/napi
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct SerializableRuleCore {
  /// A rule object to find matching AST nodes
  pub rule: SerializableRule,
  /// Additional meta variables pattern to filter matching
  pub constraints: Option<HashMap<String, SerializableRule>>,
  /// Utility rules that can be used in `matches`
  pub utils: Option<HashMap<String, SerializableRule>>,
  /// A dictionary for metavariable manipulation. Dict key is the new variable name.
  /// Dict value is a [transformation] that specifies how meta var is processed.
  /// See [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).
  pub transform: Option<HashMap<String, Transformation>>,
  /// A pattern string or a FixConfig object to auto fix the issue.
  /// It can reference metavariables appeared in rule.
  /// See details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).
  pub fix: Option<SerializableFixer>,
}

impl SerializableRuleCore {
  /// This function assumes env's local is empty.
  fn get_deserialize_env<L: Language>(&self, env: DeserializeEnv<L>) -> RResult<DeserializeEnv<L>> {
    if let Some(utils) = &self.utils {
      let env = env.with_utils(utils).map_err(RuleCoreError::Utils)?;
      Ok(env)
    } else {
      Ok(env)
    }
  }

  fn get_constraints<L: Language>(
    &self,
    env: &DeserializeEnv<L>,
  ) -> RResult<HashMap<String, Rule>> {
    let mut constraints = HashMap::new();
    let Some(serde_cons) = &self.constraints else {
      return Ok(constraints);
    };
    for (key, ser) in serde_cons {
      let constraint = env
        .deserialize_rule(ser.clone())
        .map_err(RuleCoreError::Constraints)?;
      constraints.insert(key.to_string(), constraint);
    }
    Ok(constraints)
  }

  fn get_fixer<L: Language>(&self, env: &DeserializeEnv<L>) -> RResult<Vec<Fixer>> {
    if let Some(fix) = &self.fix {
      let parsed = Fixer::parse(fix, env, &self.transform)?;
      Ok(parsed)
    } else {
      Ok(vec![])
    }
  }

  fn get_matcher_from_env<L: Language>(&self, env: &DeserializeEnv<L>) -> RResult<RuleCore> {
    let rule = env.deserialize_rule(self.rule.clone())?;
    let constraints = self.get_constraints(env)?;
    let transform = self
      .transform
      .as_ref()
      .map(|t| Transform::deserialize(t, env))
      .transpose()?;
    let fixer = self.get_fixer(env)?;
    Ok(
      RuleCore::new(rule)
        .with_matchers(constraints)
        .with_registration(env.registration.clone())
        .with_transform(transform)
        .with_fixer(fixer),
    )
  }

  pub fn get_matcher<L: Language>(&self, env: DeserializeEnv<L>) -> RResult<RuleCore> {
    self.get_matcher_with_hint(env, CheckHint::Normal)
  }

  pub(crate) fn get_matcher_with_hint<L: Language>(
    &self,
    env: DeserializeEnv<L>,
    hint: CheckHint,
  ) -> RResult<RuleCore> {
    let env = self.get_deserialize_env(env)?;
    let ret = self.get_matcher_from_env(&env)?;
    check_rule_with_hint(
      &ret.rule,
      &ret.registration,
      &ret.constraints,
      &ret.transform,
      &ret.fixer,
      hint,
    )?;
    Ok(ret)
  }
}

pub struct RuleCore {
  rule: Rule,
  constraints: HashMap<String, Rule>,
  kinds: Option<BitSet>,
  pub(crate) transform: Option<Transform>,
  pub fixer: Vec<Fixer>,
  // this is required to hold util rule reference
  registration: RuleRegistration,
}

impl RuleCore {
  #[inline]
  pub fn new(rule: Rule) -> Self {
    let kinds = rule.potential_kinds();
    Self {
      rule,
      kinds,
      ..Default::default()
    }
  }

  #[inline]
  pub fn with_matchers(self, constraints: HashMap<String, Rule>) -> Self {
    Self {
      constraints,
      ..self
    }
  }

  #[inline]
  pub fn with_registration(self, registration: RuleRegistration) -> Self {
    Self {
      registration,
      ..self
    }
  }

  #[inline]
  pub fn with_transform(self, transform: Option<Transform>) -> Self {
    Self { transform, ..self }
  }

  #[inline]
  pub fn with_fixer(self, fixer: Vec<Fixer>) -> Self {
    Self { fixer, ..self }
  }

  pub fn get_env<L: Language>(&self, lang: L) -> DeserializeEnv<L> {
    DeserializeEnv {
      lang,
      registration: self.registration.clone(),
    }
  }
  /// Get the meta variables that have real ast node matches
  /// that is, meta vars defined in the rules and constraints
  pub(crate) fn defined_node_vars(&self) -> HashSet<&str> {
    let mut ret = self.rule.defined_vars();
    for v in self.registration.get_local_util_vars() {
      ret.insert(v);
    }
    for constraint in self.constraints.values() {
      for var in constraint.defined_vars() {
        ret.insert(var);
      }
    }
    ret
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    let mut ret = self.defined_node_vars();
    if let Some(trans) = &self.transform {
      for key in trans.keys() {
        ret.insert(key);
      }
    }
    ret
  }

  pub(crate) fn do_match<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
    enclosing_env: Option<&MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if let Some(kinds) = &self.kinds {
      if !kinds.contains(node.kind_id().into()) {
        return None;
      }
    }
    let ret = self.rule.match_node_with_env(node, env)?;
    if !env.to_mut().match_constraints(&self.constraints) {
      return None;
    }
    if let Some(trans) = &self.transform {
      let rewriters = self.registration.get_rewriters();
      let env = env.to_mut();
      if let Some(enclosing) = enclosing_env {
        trans.apply_transform(env, rewriters, enclosing);
      } else {
        let enclosing = env.clone();
        trans.apply_transform(env, rewriters, &enclosing);
      };
    }
    Some(ret)
  }
}
impl Deref for RuleCore {
  type Target = Rule;
  fn deref(&self) -> &Self::Target {
    &self.rule
  }
}

impl Default for RuleCore {
  #[inline]
  fn default() -> Self {
    Self {
      rule: Rule::default(),
      constraints: HashMap::default(),
      kinds: None,
      transform: None,
      fixer: vec![],
      registration: RuleRegistration::default(),
    }
  }
}

impl Matcher for RuleCore {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    self.do_match(node, env, None)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    self.rule.potential_kinds()
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::rule::referent_rule::{ReferentRule, ReferentRuleError};
  use crate::test::TypeScript;
  use ast_grep_core::matcher::{Pattern, RegexMatcher};
  use ast_grep_core::tree_sitter::LanguageExt;

  fn get_matcher(src: &str) -> RResult<RuleCore> {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule: SerializableRuleCore = from_str(src).expect("should word");
    rule.get_matcher(env)
  }

  #[test]
  fn test_rule_error() {
    let ret = get_matcher(r"rule: {kind: bbb}");
    assert!(matches!(ret, Err(RuleCoreError::Rule(_))));
  }

  #[test]
  fn test_utils_error() {
    let ret = get_matcher(
      r"
rule: { kind: number }
utils: { testa: {kind: bbb} }
  ",
    );
    assert!(matches!(ret, Err(RuleCoreError::Utils(_))));
  }

  #[test]
  fn test_undefined_utils_error() {
    let ret = get_matcher(r"rule: { kind: number, matches: undefined-util }");
    match ret {
      Err(RuleCoreError::Rule(RuleSerializeError::MatchesReference(
        ReferentRuleError::UndefinedUtil(name),
      ))) => {
        assert_eq!(name, "undefined-util");
      }
      _ => panic!("wrong error"),
    }
  }

  #[test]
  fn test_cyclic_transform_error() {
    let ret = get_matcher(
      r"
rule: { kind: number }
transform:
  A: {substring: {source: $B}}
  B: {substring: {source: $A}}",
    );
    assert!(matches!(
      ret,
      Err(RuleCoreError::Transform(TransformError::Cyclic(_)))
    ));
  }

  #[test]
  fn test_rule_reg_with_utils() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore =
      from_str("{rule: {matches: test}, utils: {test: {kind: number}} }").expect("should deser");
    let rule = ReferentRule::try_new("test".into(), &env.registration).expect("should work");
    let not = ReferentRule::try_new("test2".into(), &env.registration).expect("should work");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    let grep = TypeScript::Tsx.ast_grep("a = 123");
    assert!(grep.root().find(&matcher).is_some());
    assert!(grep.root().find(&rule).is_some());
    assert!(grep.root().find(&not).is_none());
    let grep = TypeScript::Tsx.ast_grep("a = '123'");
    assert!(grep.root().find(&matcher).is_none());
    assert!(grep.root().find(&rule).is_none());
    assert!(grep.root().find(&not).is_none());
  }

  #[test]
  fn test_rule_with_constraints() {
    let mut constraints = HashMap::new();
    constraints.insert(
      "A".to_string(),
      Rule::Regex(RegexMatcher::try_new("a").unwrap()),
    );
    let rule =
      RuleCore::new(Rule::Pattern(Pattern::new("$A", TypeScript::Tsx))).with_matchers(constraints);
    let grep = TypeScript::Tsx.ast_grep("a");
    assert!(grep.root().find(&rule).is_some());
    let grep = TypeScript::Tsx.ast_grep("bbb");
    assert!(grep.root().find(&rule).is_none());
  }

  #[test]
  fn test_constraints_inheriting_env() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore =
      from_str("{rule: {pattern: $A = $B}, constraints: {A: {pattern: $B}} }")
        .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    let grep = TypeScript::Tsx.ast_grep("a = a");
    assert!(grep.root().find(&matcher).is_some());
    let grep = TypeScript::Tsx.ast_grep("a = b");
    assert!(grep.root().find(&matcher).is_none());
  }

  #[test]
  fn test_constraints_writing_to_env() {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ser_rule: SerializableRuleCore =
      from_str("{rule: {pattern: $A = $B}, constraints: {B: {pattern: $C + $D}} }")
        .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    let grep = TypeScript::Tsx.ast_grep("a = a");
    assert!(grep.root().find(&matcher).is_none());
    let grep = TypeScript::Tsx.ast_grep("a = 1 + 2");
    let nm = grep.root().find(&matcher).expect("should match");
    let env = nm.get_env();
    let matched = env.get_match("C").expect("should match C").text();
    assert_eq!(matched, "1");
    let matched = env.get_match("D").expect("should match D").text();
    assert_eq!(matched, "2");
  }

  fn get_rewriters() -> (&'static str, RuleCore) {
    // NOTE: initialize a DeserializeEnv here is not 100% correct
    // it does not inherit global rules or local rules
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rewriter: SerializableRuleCore =
      from_str("{rule: {kind: number, pattern: $REWRITE}, fix: yjsnp}").expect("should parse");
    let rewriter = rewriter.get_matcher(env).expect("should work");
    ("re", rewriter)
  }

  #[test]
  fn test_rewriter_writing_to_env() {
    let (id, rewriter) = get_rewriters();
    let env = DeserializeEnv::new(TypeScript::Tsx);
    env.registration.insert_rewriter(id, rewriter);
    let ser_rule: SerializableRuleCore = from_str(
      r"
rule: {pattern: $A = $B}
transform:
  C:
    rewrite:
      source: $B
      rewriters: [re]",
    )
    .expect("should deser");
    let matcher = ser_rule.get_matcher(env).expect("should parse");
    let grep = TypeScript::Tsx.ast_grep("a = 1 + 2");
    let nm = grep.root().find(&matcher).expect("should match");
    let env = nm.get_env();
    let matched = env.get_match("B").expect("should match").text();
    assert_eq!(matched, "1 + 2");
    let matched = env.get_match("A").expect("should match").text();
    assert_eq!(matched, "a");
    let transformed = env.get_transformed("C").expect("should transform");
    assert_eq!(String::from_utf8_lossy(transformed), "yjsnp + yjsnp");
    assert!(env.get_match("REWRITE").is_none());

    let grep = TypeScript::Tsx.ast_grep("a = a");
    let nm = grep.root().find(&matcher).expect("should match");
    let env = nm.get_env();
    let matched = env.get_match("B").expect("should match").text();
    assert_eq!(matched, "a");
    let transformed = env.get_transformed("C").expect("should transform");
    assert_eq!(String::from_utf8_lossy(transformed), "a");
  }
}



================================================
FILE: crates/config/src/rule/deserialize_env.rs
================================================
use super::referent_rule::{GlobalRules, ReferentRuleError, RuleRegistration};
use crate::check_var::CheckHint;
use crate::maybe::Maybe;
use crate::rule::{self, Rule, RuleSerializeError, SerializableRule};
use crate::rule_core::{RuleCoreError, SerializableRuleCore};
use crate::transform::Trans;
use ast_grep_core::meta_var::MetaVariable;

use ast_grep_core::language::Language;

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use std::collections::HashMap;

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct SerializableGlobalRule<L: Language> {
  #[serde(flatten)]
  pub core: SerializableRuleCore,
  /// Unique, descriptive identifier, e.g., no-unused-variable
  pub id: String,
  /// Specify the language to parse and the file extension to include in matching.
  pub language: L,
}

fn into_map<L: Language>(
  rules: Vec<SerializableGlobalRule<L>>,
) -> HashMap<String, (L, SerializableRuleCore)> {
  rules
    .into_iter()
    .map(|r| (r.id, (r.language, r.core)))
    .collect()
}

type OrderResult<T> = Result<T, String>;

/// A struct to store information to deserialize rules.
#[derive(Clone)]
pub struct DeserializeEnv<L: Language> {
  /// registration for global utility rules and local utility rules.
  pub(crate) registration: RuleRegistration,
  /// current rules' language
  pub(crate) lang: L,
}

trait DependentRule: Sized {
  fn visit_dependency<'a>(&'a self, sorter: &mut TopologicalSort<'a, Self>) -> OrderResult<()>;
}

impl DependentRule for SerializableRule {
  fn visit_dependency<'a>(&'a self, sorter: &mut TopologicalSort<'a, Self>) -> OrderResult<()> {
    visit_dependent_rule_ids(self, sorter)
  }
}

impl<L: Language> DependentRule for (L, SerializableRuleCore) {
  fn visit_dependency<'a>(&'a self, sorter: &mut TopologicalSort<'a, Self>) -> OrderResult<()> {
    visit_dependent_rule_ids(&self.1.rule, sorter)
  }
}

impl DependentRule for Trans<MetaVariable> {
  fn visit_dependency<'a>(&'a self, sorter: &mut TopologicalSort<'a, Self>) -> OrderResult<()> {
    let used_var = self.used_vars();
    sorter.visit(used_var)
  }
}

/// A struct to topological sort rules
/// it is used to report cyclic dependency errors in rules/transformation
struct TopologicalSort<'a, T: DependentRule> {
  maps: &'a HashMap<String, T>,
  order: Vec<&'a str>,
  // bool stands for if the rule has completed visit
  seen: HashMap<&'a str, bool>,
}

impl<'a, T: DependentRule> TopologicalSort<'a, T> {
  fn get_order(maps: &HashMap<String, T>) -> OrderResult<Vec<&str>> {
    let mut top_sort = TopologicalSort::new(maps);
    for key in maps.keys() {
      top_sort.visit(key)?;
    }
    Ok(top_sort.order)
  }

  fn new(maps: &'a HashMap<String, T>) -> Self {
    Self {
      maps,
      order: vec![],
      seen: HashMap::new(),
    }
  }

  fn visit(&mut self, key: &'a str) -> OrderResult<()> {
    if let Some(&completed) = self.seen.get(key) {
      // if the rule has been seen but not completed
      // it means we have a cyclic dependency and report an error here
      return if completed {
        Ok(())
      } else {
        Err(key.to_string())
      };
    }
    let Some(item) = self.maps.get(key) else {
      // key can be found elsewhere
      // e.g. if key is rule_id
      // if rule_id not found in global, it can be a local rule
      // if rule_id not found in local, it can be a global rule
      // TODO: add check here and return Err if rule not found
      return Ok(());
    };
    // mark the id as seen but not completed
    self.seen.insert(key, false);
    item.visit_dependency(self)?;
    // mark the id as seen and completed
    self.seen.insert(key, true);
    self.order.push(key);
    Ok(())
  }
}

fn visit_dependent_rule_ids<'a, T: DependentRule>(
  rule: &'a SerializableRule,
  sort: &mut TopologicalSort<'a, T>,
) -> OrderResult<()> {
  // handle all composite rule here
  if let Maybe::Present(matches) = &rule.matches {
    sort.visit(matches)?;
  }
  if let Maybe::Present(all) = &rule.all {
    for sub in all {
      visit_dependent_rule_ids(sub, sort)?;
    }
  }
  if let Maybe::Present(any) = &rule.any {
    for sub in any {
      visit_dependent_rule_ids(sub, sort)?;
    }
  }
  if let Maybe::Present(not) = &rule.not {
    visit_dependent_rule_ids(not, sort)?;
  }
  Ok(())
}

impl<L: Language> DeserializeEnv<L> {
  pub fn new(lang: L) -> Self {
    Self {
      registration: Default::default(),
      lang,
    }
  }

  /// register utils rule in the DeserializeEnv for later usage.
  /// N.B. This function will manage the util registration order
  /// by their dependency. `potential_kinds` need ordered insertion.
  pub fn with_utils(
    self,
    utils: &HashMap<String, SerializableRule>,
  ) -> Result<Self, RuleSerializeError> {
    let order = TopologicalSort::get_order(utils)
      .map_err(ReferentRuleError::CyclicRule)
      .map_err(RuleSerializeError::MatchesReference)?;
    for id in order {
      let rule = utils.get(id).expect("must exist");
      let rule = self.deserialize_rule(rule.clone())?;
      self.registration.insert_local(id, rule)?;
    }
    Ok(self)
  }

  /// register global utils rule discovered in the config.
  pub fn parse_global_utils(
    utils: Vec<SerializableGlobalRule<L>>,
  ) -> Result<GlobalRules, RuleCoreError> {
    let registration = GlobalRules::default();
    let utils = into_map(utils);
    let order = TopologicalSort::get_order(&utils)
      .map_err(ReferentRuleError::CyclicRule)
      .map_err(RuleSerializeError::from)?;
    for id in order {
      let (lang, core) = utils.get(id).expect("must exist");
      let env = DeserializeEnv::new(lang.clone()).with_globals(&registration);
      let matcher = core.get_matcher_with_hint(env, CheckHint::Global)?;
      registration
        .insert(id, matcher)
        .map_err(RuleSerializeError::MatchesReference)?;
    }
    Ok(registration)
  }

  pub fn deserialize_rule(&self, serialized: SerializableRule) -> Result<Rule, RuleSerializeError> {
    rule::deserialize_rule(serialized, self)
  }

  pub(crate) fn get_transform_order<'a>(
    &self,
    trans: &'a HashMap<String, Trans<MetaVariable>>,
  ) -> Result<Vec<&'a str>, String> {
    TopologicalSort::get_order(trans)
  }

  pub fn with_globals(self, globals: &GlobalRules) -> Self {
    Self {
      registration: RuleRegistration::from_globals(globals),
      lang: self.lang,
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::test::TypeScript;
  use crate::{from_str, Rule};
  use ast_grep_core::tree_sitter::LanguageExt;
  use ast_grep_core::Matcher;

  type Result<T> = std::result::Result<T, RuleSerializeError>;

  fn get_dependent_utils() -> Result<(Rule, DeserializeEnv<TypeScript>)> {
    let utils = from_str(
      "
accessor-name:
  matches: member-name
  regex: whatever
member-name:
  kind: identifier
",
    )
    .expect("failed to parse utils");
    let env = DeserializeEnv::new(TypeScript::Tsx).with_utils(&utils)?;
    assert_eq!(utils.keys().count(), 2);
    let rule = from_str("matches: accessor-name").unwrap();
    Ok((
      env.deserialize_rule(rule).unwrap(),
      env, // env is required for weak ref
    ))
  }

  #[test]
  fn test_local_util_matches() -> Result<()> {
    let (rule, _env) = get_dependent_utils()?;
    let grep = TypeScript::Tsx.ast_grep("whatever");
    assert!(grep.root().find(rule).is_some());
    Ok(())
  }

  #[test]
  #[ignore = "TODO, need to figure out potential_kinds"]
  fn test_local_util_kinds() -> Result<()> {
    // run multiple times to avoid accidental working order due to HashMap randomness
    for _ in 0..10 {
      let (rule, _env) = get_dependent_utils()?;
      assert!(rule.potential_kinds().is_some());
    }
    Ok(())
  }

  #[test]
  fn test_using_global_rule_in_local() -> Result<()> {
    let utils = from_str(
      "
local-rule:
  matches: global-rule
",
    )
    .expect("failed to parse utils");
    // should not panic
    DeserializeEnv::new(TypeScript::Tsx).with_utils(&utils)?;
    Ok(())
  }

  #[test]
  fn test_using_cyclic_local() -> Result<()> {
    let utils = from_str(
      "
local-rule:
  matches: local-rule
",
    )
    .expect("failed to parse utils");
    let ret = DeserializeEnv::new(TypeScript::Tsx).with_utils(&utils);
    assert!(ret.is_err());
    Ok(())
  }

  #[test]
  fn test_using_transitive_cycle() -> Result<()> {
    let utils = from_str(
      "
local-rule-a:
  matches: local-rule-b
local-rule-b:
  all:
    - matches: local-rule-c
local-rule-c:
  any:
    - matches: local-rule-a
",
    )
    .expect("failed to parse utils");
    let ret = DeserializeEnv::new(TypeScript::Tsx).with_utils(&utils);
    assert!(ret.is_err());
    Ok(())
  }

  #[test]
  fn test_cyclic_not() -> Result<()> {
    let utils = from_str(
      "
local-rule-a:
  not: {matches: local-rule-b}
local-rule-b:
  matches: local-rule-a",
    )
    .expect("failed to parse utils");
    let ret = DeserializeEnv::new(TypeScript::Tsx).with_utils(&utils);
    assert!(matches!(
      ret,
      Err(RuleSerializeError::MatchesReference(
        ReferentRuleError::CyclicRule(_)
      ))
    ));
    Ok(())
  }
}



================================================
FILE: crates/config/src/rule/mod.rs
================================================
mod deserialize_env;
mod nth_child;
mod range;
pub mod referent_rule;
mod relational_rule;
mod selector;
mod stop_by;

pub use deserialize_env::DeserializeEnv;
pub use relational_rule::Relation;
use selector::{parse_selector, SelectorError};
pub use stop_by::StopBy;

use crate::maybe::Maybe;
use nth_child::{NthChild, NthChildError, SerializableNthChild};
use range::{RangeMatcher, RangeMatcherError, SerializableRange};
use referent_rule::{ReferentRule, ReferentRuleError};
use relational_rule::{Follows, Has, Inside, Precedes};

use ast_grep_core::language::Language;
use ast_grep_core::matcher::{KindMatcher, RegexMatcher, RegexMatcherError};
use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::{ops as o, Doc, Node};
use ast_grep_core::{MatchStrictness, Matcher, Pattern, PatternError};

use bit_set::BitSet;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::collections::HashSet;
use thiserror::Error;

/// A rule object to find matching AST nodes. We have three categories of rules in ast-grep.
///
/// * Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.
///
/// * Relational: filter matched target according to their position relative to other nodes.
///
/// * Composite: use logic operation all/any/not to compose the above rules to larger rules.
///
/// Every rule has it's unique name so we can combine several rules in one object.
#[derive(Serialize, Deserialize, Clone, Default, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct SerializableRule {
  // avoid embedding AtomicRule/RelationalRule/CompositeRule with flatten here for better error message

  // atomic
  /// A pattern string or a pattern object.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub pattern: Maybe<PatternStyle>,
  /// The kind name of the node to match. You can look up code's kind names in playground.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub kind: Maybe<String>,
  /// A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub regex: Maybe<String>,
  /// `nth_child` accepts number, string or object.
  /// It specifies the position in nodes' sibling list.
  #[serde(default, skip_serializing_if = "Maybe::is_absent", rename = "nthChild")]
  pub nth_child: Maybe<SerializableNthChild>,
  /// `range` accepts a range object.
  /// the target node must exactly appear in the range.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub range: Maybe<SerializableRange>,

  // relational
  /// `inside` accepts a relational rule object.
  /// the target node must appear inside of another node matching the `inside` sub-rule.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub inside: Maybe<Box<Relation>>,
  /// `has` accepts a relational rule object.
  /// the target node must has a descendant node matching the `has` sub-rule.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub has: Maybe<Box<Relation>>,
  /// `precedes` accepts a relational rule object.
  /// the target node must appear before another node matching the `precedes` sub-rule.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub precedes: Maybe<Box<Relation>>,
  /// `follows` accepts a relational rule object.
  /// the target node must appear after another node matching the `follows` sub-rule.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub follows: Maybe<Box<Relation>>,
  // composite
  /// A list of sub rules and matches a node if all of sub rules match.
  /// The meta variables of the matched node contain all variables from the sub-rules.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub all: Maybe<Vec<SerializableRule>>,
  /// A list of sub rules and matches a node if any of sub rules match.
  /// The meta variables of the matched node only contain those of the matched sub-rule.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub any: Maybe<Vec<SerializableRule>>,
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  /// A single sub-rule and matches a node if the sub rule does not match.
  pub not: Maybe<Box<SerializableRule>>,
  /// A utility rule id and matches a node if the utility rule matches.
  #[serde(default, skip_serializing_if = "Maybe::is_absent")]
  pub matches: Maybe<String>,
}

struct Categorized {
  pub atomic: AtomicRule,
  pub relational: RelationalRule,
  pub composite: CompositeRule,
}

impl SerializableRule {
  fn categorized(self) -> Categorized {
    Categorized {
      atomic: AtomicRule {
        pattern: self.pattern.into(),
        kind: self.kind.into(),
        regex: self.regex.into(),
        nth_child: self.nth_child.into(),
        range: self.range.into(),
      },
      relational: RelationalRule {
        inside: self.inside.into(),
        has: self.has.into(),
        precedes: self.precedes.into(),
        follows: self.follows.into(),
      },
      composite: CompositeRule {
        all: self.all.into(),
        any: self.any.into(),
        not: self.not.into(),
        matches: self.matches.into(),
      },
    }
  }
}

pub struct AtomicRule {
  pub pattern: Option<PatternStyle>,
  pub kind: Option<String>,
  pub regex: Option<String>,
  pub nth_child: Option<SerializableNthChild>,
  pub range: Option<SerializableRange>,
}
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub enum Strictness {
  /// all nodes are matched
  Cst,
  /// all nodes except source trivial nodes are matched.
  Smart,
  /// only ast nodes are matched
  Ast,
  /// ast-nodes excluding comments are matched
  Relaxed,
  /// ast-nodes excluding comments, without text
  Signature,
  /// similar to smart, but node kinds are ignored, only text is matched.
  Template,
}

impl From<MatchStrictness> for Strictness {
  fn from(value: MatchStrictness) -> Self {
    use MatchStrictness as M;
    use Strictness as S;
    match value {
      M::Cst => S::Cst,
      M::Smart => S::Smart,
      M::Ast => S::Ast,
      M::Relaxed => S::Relaxed,
      M::Signature => S::Signature,
      M::Template => S::Template,
    }
  }
}

impl From<Strictness> for MatchStrictness {
  fn from(value: Strictness) -> Self {
    use MatchStrictness as M;
    use Strictness as S;
    match value {
      S::Cst => M::Cst,
      S::Smart => M::Smart,
      S::Ast => M::Ast,
      S::Relaxed => M::Relaxed,
      S::Signature => M::Signature,
      S::Template => M::Template,
    }
  }
}

/// A String pattern will match one single AST node according to pattern syntax.
/// Or an object with field `context`, `selector` and optionally `strictness`.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged)]
pub enum PatternStyle {
  Str(String),
  Contextual {
    /// The surrounding code that helps to resolve any ambiguity in the syntax.
    context: String,
    /// The sub-syntax node kind that is the actual matcher of the pattern.
    selector: Option<String>,
    /// Strictness of the pattern. More strict pattern matches fewer nodes.
    strictness: Option<Strictness>,
  },
}

pub struct RelationalRule {
  pub inside: Option<Box<Relation>>,
  pub has: Option<Box<Relation>>,
  pub precedes: Option<Box<Relation>>,
  pub follows: Option<Box<Relation>>,
}

pub struct CompositeRule {
  pub all: Option<Vec<SerializableRule>>,
  pub any: Option<Vec<SerializableRule>>,
  pub not: Option<Box<SerializableRule>>,
  pub matches: Option<String>,
}

pub enum Rule {
  // atomic
  Pattern(Pattern),
  Kind(KindMatcher),
  Regex(RegexMatcher),
  NthChild(NthChild),
  Range(RangeMatcher),
  // relational
  Inside(Box<Inside>),
  Has(Box<Has>),
  Precedes(Box<Precedes>),
  Follows(Box<Follows>),
  // composite
  All(o::All<Rule>),
  Any(o::Any<Rule>),
  Not(Box<o::Not<Rule>>),
  Matches(ReferentRule),
}
impl Rule {
  /// Check if it has a cyclic referent rule with the id.
  pub(crate) fn check_cyclic(&self, id: &str) -> bool {
    match self {
      Rule::All(all) => all.inner().iter().any(|r| r.check_cyclic(id)),
      Rule::Any(any) => any.inner().iter().any(|r| r.check_cyclic(id)),
      Rule::Not(not) => not.inner().check_cyclic(id),
      Rule::Matches(m) => m.rule_id == id,
      _ => false,
    }
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    match self {
      Rule::Pattern(p) => p.defined_vars(),
      Rule::Kind(_) => HashSet::new(),
      Rule::Regex(_) => HashSet::new(),
      Rule::NthChild(n) => n.defined_vars(),
      Rule::Range(_) => HashSet::new(),
      Rule::Has(c) => c.defined_vars(),
      Rule::Inside(p) => p.defined_vars(),
      Rule::Precedes(f) => f.defined_vars(),
      Rule::Follows(f) => f.defined_vars(),
      Rule::All(sub) => sub.inner().iter().flat_map(|r| r.defined_vars()).collect(),
      Rule::Any(sub) => sub.inner().iter().flat_map(|r| r.defined_vars()).collect(),
      Rule::Not(sub) => sub.inner().defined_vars(),
      // TODO: this is not correct, we are collecting util vars else where
      Rule::Matches(_r) => HashSet::new(),
    }
  }

  /// check if util rules used are defined
  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    match self {
      Rule::Pattern(_) => Ok(()),
      Rule::Kind(_) => Ok(()),
      Rule::Regex(_) => Ok(()),
      Rule::NthChild(n) => n.verify_util(),
      Rule::Range(_) => Ok(()),
      Rule::Has(c) => c.verify_util(),
      Rule::Inside(p) => p.verify_util(),
      Rule::Precedes(f) => f.verify_util(),
      Rule::Follows(f) => f.verify_util(),
      Rule::All(sub) => sub.inner().iter().try_for_each(|r| r.verify_util()),
      Rule::Any(sub) => sub.inner().iter().try_for_each(|r| r.verify_util()),
      Rule::Not(sub) => sub.inner().verify_util(),
      Rule::Matches(r) => Ok(r.verify_util()?),
    }
  }
}

impl Matcher for Rule {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    use Rule::*;
    match self {
      // atomic
      Pattern(pattern) => pattern.match_node_with_env(node, env),
      Kind(kind) => kind.match_node_with_env(node, env),
      Regex(regex) => regex.match_node_with_env(node, env),
      NthChild(nth_child) => nth_child.match_node_with_env(node, env),
      Range(range) => range.match_node_with_env(node, env),
      // relational
      Inside(parent) => match_and_add_label(&**parent, node, env),
      Has(child) => match_and_add_label(&**child, node, env),
      Precedes(latter) => match_and_add_label(&**latter, node, env),
      Follows(former) => match_and_add_label(&**former, node, env),
      // composite
      All(all) => all.match_node_with_env(node, env),
      Any(any) => any.match_node_with_env(node, env),
      Not(not) => not.match_node_with_env(node, env),
      Matches(rule) => rule.match_node_with_env(node, env),
    }
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    use Rule::*;
    match self {
      // atomic
      Pattern(pattern) => pattern.potential_kinds(),
      Kind(kind) => kind.potential_kinds(),
      Regex(regex) => regex.potential_kinds(),
      NthChild(nth_child) => nth_child.potential_kinds(),
      Range(range) => range.potential_kinds(),
      // relational
      Inside(parent) => parent.potential_kinds(),
      Has(child) => child.potential_kinds(),
      Precedes(latter) => latter.potential_kinds(),
      Follows(former) => former.potential_kinds(),
      // composite
      All(all) => all.potential_kinds(),
      Any(any) => any.potential_kinds(),
      Not(not) => not.potential_kinds(),
      Matches(rule) => rule.potential_kinds(),
    }
  }
}

/// Rule matches nothing by default.
/// In Math jargon, Rule is vacuously false.
impl Default for Rule {
  fn default() -> Self {
    Self::Any(o::Any::new(std::iter::empty()))
  }
}

fn match_and_add_label<'tree, D: Doc, M: Matcher>(
  inner: &M,
  node: Node<'tree, D>,
  env: &mut Cow<MetaVarEnv<'tree, D>>,
) -> Option<Node<'tree, D>> {
  let matched = inner.match_node_with_env(node, env)?;
  env.to_mut().add_label("secondary", matched.clone());
  Some(matched)
}

#[derive(Debug, Error)]
pub enum RuleSerializeError {
  #[error("Rule must have one positive matcher.")]
  MissPositiveMatcher,
  #[error("Rule contains invalid kind matcher.")]
  InvalidKind(#[from] SelectorError),
  #[error("Rule contains invalid pattern matcher.")]
  InvalidPattern(#[from] PatternError),
  #[error("Rule contains invalid nthChild.")]
  NthChild(#[from] NthChildError),
  #[error("Rule contains invalid regex matcher.")]
  WrongRegex(#[from] RegexMatcherError),
  #[error("Rule contains invalid matches reference.")]
  MatchesReference(#[from] ReferentRuleError),
  #[error("Rule contains invalid range matcher.")]
  InvalidRange(#[from] RangeMatcherError),
  #[error("field is only supported in has/inside.")]
  FieldNotSupported,
  #[error("Relational rule contains invalid field {0}.")]
  InvalidField(String),
}

// TODO: implement positive/non positive
pub fn deserialize_rule<L: Language>(
  serialized: SerializableRule,
  env: &DeserializeEnv<L>,
) -> Result<Rule, RuleSerializeError> {
  let mut rules = Vec::with_capacity(1);
  use Rule as R;
  let categorized = serialized.categorized();
  // ATTENTION, relational_rule should always come at last
  // after target node is decided by atomic/composite rule
  deserialze_atomic_rule(categorized.atomic, &mut rules, env)?;
  deserialze_composite_rule(categorized.composite, &mut rules, env)?;
  deserialize_relational_rule(categorized.relational, &mut rules, env)?;

  if rules.is_empty() {
    Err(RuleSerializeError::MissPositiveMatcher)
  } else if rules.len() == 1 {
    Ok(rules.pop().expect("should not be empty"))
  } else {
    Ok(R::All(o::All::new(rules)))
  }
}

fn deserialze_composite_rule<L: Language>(
  composite: CompositeRule,
  rules: &mut Vec<Rule>,
  env: &DeserializeEnv<L>,
) -> Result<(), RuleSerializeError> {
  use Rule as R;
  let convert_rules = |rules: Vec<SerializableRule>| -> Result<_, RuleSerializeError> {
    let mut inner = Vec::with_capacity(rules.len());
    for rule in rules {
      inner.push(deserialize_rule(rule, env)?);
    }
    Ok(inner)
  };
  if let Some(all) = composite.all {
    rules.push(R::All(o::All::new(convert_rules(all)?)));
  }
  if let Some(any) = composite.any {
    rules.push(R::Any(o::Any::new(convert_rules(any)?)));
  }
  if let Some(not) = composite.not {
    let not = o::Not::new(deserialize_rule(*not, env)?);
    rules.push(R::Not(Box::new(not)));
  }
  if let Some(id) = composite.matches {
    let matches = ReferentRule::try_new(id, &env.registration)?;
    rules.push(R::Matches(matches));
  }
  Ok(())
}

fn deserialize_relational_rule<L: Language>(
  relational: RelationalRule,
  rules: &mut Vec<Rule>,
  env: &DeserializeEnv<L>,
) -> Result<(), RuleSerializeError> {
  use Rule as R;
  // relational
  if let Some(inside) = relational.inside {
    rules.push(R::Inside(Box::new(Inside::try_new(*inside, env)?)));
  }
  if let Some(has) = relational.has {
    rules.push(R::Has(Box::new(Has::try_new(*has, env)?)));
  }
  if let Some(precedes) = relational.precedes {
    rules.push(R::Precedes(Box::new(Precedes::try_new(*precedes, env)?)));
  }
  if let Some(follows) = relational.follows {
    rules.push(R::Follows(Box::new(Follows::try_new(*follows, env)?)));
  }
  Ok(())
}

fn deserialze_atomic_rule<L: Language>(
  atomic: AtomicRule,
  rules: &mut Vec<Rule>,
  env: &DeserializeEnv<L>,
) -> Result<(), RuleSerializeError> {
  use Rule as R;
  if let Some(pattern) = atomic.pattern {
    rules.push(match pattern {
      PatternStyle::Str(pat) => R::Pattern(Pattern::try_new(&pat, env.lang.clone())?),
      PatternStyle::Contextual {
        context,
        selector,
        strictness,
      } => {
        let pattern = if let Some(selector) = selector {
          Pattern::contextual(&context, &selector, env.lang.clone())?
        } else {
          Pattern::try_new(&context, env.lang.clone())?
        };
        let pattern = if let Some(strictness) = strictness {
          pattern.with_strictness(strictness.into())
        } else {
          pattern
        };
        R::Pattern(pattern)
      }
    });
  }
  if let Some(kind) = atomic.kind {
    let rule = parse_selector(&kind, env.lang.clone())?;
    rules.push(rule);
  }
  if let Some(regex) = atomic.regex {
    rules.push(R::Regex(RegexMatcher::try_new(&regex)?));
  }
  if let Some(nth_child) = atomic.nth_child {
    rules.push(R::NthChild(NthChild::try_new(nth_child, env)?));
  }
  if let Some(range) = atomic.range {
    rules.push(R::Range(RangeMatcher::try_new(range.start, range.end)?));
  }
  Ok(())
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::test::TypeScript;
  use ast_grep_core::tree_sitter::LanguageExt;
  use PatternStyle::*;

  #[test]
  fn test_pattern() {
    let src = r"
pattern: Test
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(rule.pattern.is_present());
    let src = r"
pattern:
  context: class $C { set $B() {} }
  selector: method_definition
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(matches!(rule.pattern, Maybe::Present(Contextual { .. }),));
  }

  #[test]
  fn test_augmentation() {
    let src = r"
pattern: class A {}
inside:
  pattern: function() {}
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(rule.inside.is_present());
    assert!(rule.pattern.is_present());
  }

  #[test]
  fn test_multi_augmentation() {
    let src = r"
pattern: class A {}
inside:
  pattern: function() {}
has:
  pattern: Some()
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(rule.inside.is_present());
    assert!(rule.has.is_present());
    assert!(rule.follows.is_absent());
    assert!(rule.precedes.is_absent());
    assert!(rule.pattern.is_present());
  }

  #[test]
  fn test_maybe_not() {
    let src = "not: 123";
    let ret: Result<SerializableRule, _> = from_str(src);
    assert!(ret.is_err());
    let src = "not:";
    let ret: Result<SerializableRule, _> = from_str(src);
    assert!(ret.is_err());
  }

  #[test]
  fn test_nested_augmentation() {
    let src = r"
pattern: class A {}
inside:
  pattern: function() {}
  inside:
    pattern:
      context: Some()
      selector: ss
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(rule.inside.is_present());
    let inside = rule.inside.unwrap();
    assert!(inside.rule.pattern.is_present());
    assert!(inside.rule.inside.unwrap().rule.pattern.is_present());
  }

  #[test]
  fn test_precedes_follows() {
    let src = r"
pattern: class A {}
precedes:
  pattern: function() {}
follows:
  pattern:
    context: Some()
    selector: ss
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    assert!(rule.precedes.is_present());
    assert!(rule.follows.is_present());
    let follows = rule.follows.unwrap();
    assert!(follows.rule.pattern.is_present());
    assert!(follows.rule.pattern.is_present());
  }

  #[test]
  fn test_deserialize_rule() {
    let src = r"
pattern: class A {}
kind: class_declaration
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule = deserialize_rule(rule, &env).expect("should deserialize");
    let root = TypeScript::Tsx.ast_grep("class A {}");
    assert!(root.root().find(rule).is_some());
  }

  #[test]
  fn test_deserialize_order() {
    let src = r"
pattern: class A {}
inside:
  kind: class
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule = deserialize_rule(rule, &env).expect("should deserialize");
    assert!(matches!(rule, Rule::All(_)));
  }

  #[test]
  fn test_defined_vars() {
    let src = r"
pattern: var $A = 123
inside:
  pattern: var $B = 456
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule = deserialize_rule(rule, &env).expect("should deserialize");
    assert_eq!(rule.defined_vars(), ["A", "B"].into_iter().collect());
  }

  #[test]
  fn test_issue_1164() {
    let src = r"
    kind: statement_block
    has:
      pattern: this.$A = promise()
      stopBy: end";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule = deserialize_rule(rule, &env).expect("should deserialize");
    let root = TypeScript::Tsx.ast_grep(
      "if (a) {
      this.a = b;
      this.d = promise()
    }",
    );
    assert!(root.root().find(rule).is_some());
  }

  #[test]
  fn test_issue_1225() {
    let src = r"
    kind: statement_block
    has:
      pattern: $A
      regex: const";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let rule = deserialize_rule(rule, &env).expect("should deserialize");
    let root = TypeScript::Tsx.ast_grep(
      "{
        let x = 1;
        const z = 9;
      }",
    );
    assert!(root.root().find(rule).is_some());
  }
}



================================================
FILE: crates/config/src/rule/nth_child.rs
================================================
use super::{DeserializeEnv, Rule, RuleSerializeError, SerializableRule};

use ast_grep_core::language::Language;
use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::{Doc, Matcher, Node};

use std::borrow::Cow;
use std::collections::HashSet;

use bit_set::BitSet;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum NthChildError {
  #[error("Illegal character {0} encountered")]
  IllegalCharacter(char),
  #[error("Invalid syntax")]
  InvalidSyntax,
  #[error("Invalid ofRule")]
  InvalidRule(#[from] Box<RuleSerializeError>),
}

/// A string or number describing the indices of matching nodes in a list of siblings.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged)]
pub enum NthChildSimple {
  /// A number indicating the precise element index
  Numeric(usize),
  /// Functional notation like CSS's An + B
  Functional(String),
}

enum ParseState {
  Initial,
  N,
  Sign(bool), // bool flag: has met n before?
  Num(bool),  // bool flag: has met n before
}

fn parse_an_b(input: &str) -> Result<FunctionalPosition, NthChildError> {
  use ParseState::*;
  let mut step_size = 0;
  let mut sign = 1;
  let mut num = 0;
  let mut state = Initial;
  for c in input.chars() {
    // ignore all white spaces
    if c.is_whitespace() {
      continue;
    }
    match state {
      Initial => match c {
        '+' | '-' => {
          state = Sign(false);
          sign = if c == '+' { 1 } else { -1 };
        }
        '0'..='9' => {
          state = Num(false);
          num = (c as u8 - b'0') as i32;
        }
        'n' | 'N' => {
          state = N;
          step_size = sign;
        }
        c => return Err(NthChildError::IllegalCharacter(c)),
      },
      Sign(has_n) => match c {
        '+' | '-' => return Err(NthChildError::InvalidSyntax),
        '0'..='9' => {
          state = Num(has_n);
          num = (c as u8 - b'0') as i32;
        }
        'n' | 'N' => {
          if has_n {
            return Err(NthChildError::InvalidSyntax);
          }
          state = N;
          step_size = sign;
        }
        c => return Err(NthChildError::IllegalCharacter(c)),
      },
      Num(has_n) => match c {
        '+' | '-' => return Err(NthChildError::InvalidSyntax),
        '0'..='9' => {
          num = num * 10 + (c as u8 - b'0') as i32;
        }
        'n' | 'N' => {
          if has_n {
            return Err(NthChildError::InvalidSyntax);
          }
          state = N;
          step_size = sign * num;
          num = 0;
        }
        c => return Err(NthChildError::IllegalCharacter(c)),
      },
      N => match c {
        '+' | '-' => {
          state = Sign(true);
          sign = if c == '+' { 1 } else { -1 };
          num = 0;
        }
        '0'..='9' => return Err(NthChildError::InvalidSyntax),
        'n' | 'N' => return Err(NthChildError::InvalidSyntax),
        c => return Err(NthChildError::IllegalCharacter(c)),
      },
    }
  }
  if matches!(state, Sign(_) | Initial) {
    Err(NthChildError::InvalidSyntax)
  } else {
    Ok(FunctionalPosition {
      step_size,
      offset: num * sign,
    })
  }
}

impl NthChildSimple {
  fn try_parse(&self) -> Result<FunctionalPosition, NthChildError> {
    match self {
      NthChildSimple::Numeric(n) => Ok(FunctionalPosition {
        step_size: 0,
        offset: *n as i32,
      }),
      NthChildSimple::Functional(s) => parse_an_b(s),
    }
  }
}

/// `nthChild` accepts either a number, a string or an object.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged, rename_all = "camelCase")]
pub enum SerializableNthChild {
  /// Simple syntax
  Simple(NthChildSimple),
  /// Object style syntax
  #[serde(rename_all = "camelCase")]
  Complex {
    /// nth-child syntax
    position: NthChildSimple,
    /// select the nth node that matches the rule, like CSS's of syntax
    of_rule: Option<Box<SerializableRule>>,
    /// matches from the end instead like CSS's nth-last-child
    #[serde(default)]
    reverse: bool,
  },
}

/// Corresponds to the CSS syntax An+B
/// See https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child#functional_notation
struct FunctionalPosition {
  step_size: i32,
  offset: i32,
}

impl FunctionalPosition {
  /// index is 0-based, but output is 1-based
  fn is_matched(&self, index: usize) -> bool {
    let index = (index + 1) as i32; // Convert 0-based index to 1-based
    let FunctionalPosition { step_size, offset } = self;
    if *step_size == 0 {
      index == *offset
    } else {
      let n = index - offset;
      n / step_size >= 0 && n % step_size == 0
    }
  }
}

pub struct NthChild {
  position: FunctionalPosition,
  of_rule: Option<Box<Rule>>,
  reverse: bool,
}

impl NthChild {
  pub fn try_new<L: Language>(
    rule: SerializableNthChild,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, NthChildError> {
    match rule {
      SerializableNthChild::Simple(position) => Ok(NthChild {
        position: position.try_parse()?,
        of_rule: None,
        reverse: false,
      }),
      SerializableNthChild::Complex {
        position,
        of_rule,
        reverse,
      } => Ok(NthChild {
        position: position.try_parse()?,
        of_rule: of_rule
          .map(|r| env.deserialize_rule(*r))
          .transpose()
          .map_err(Box::new)?
          .map(Box::new),
        reverse,
      }),
    }
  }

  fn find_index<'t, D: Doc>(
    &self,
    node: &Node<'t, D>,
    env: &mut Cow<MetaVarEnv<'t, D>>,
  ) -> Option<usize> {
    let parent = node.parent()?;
    //  only consider named children
    let mut children: Vec<_> = if let Some(rule) = &self.of_rule {
      // if of_rule is present, only consider children that match the rule
      parent
        .children()
        .filter(|n| n.is_named())
        .filter_map(|child| rule.match_node_with_env(child, env))
        .collect()
    } else {
      parent.children().filter(|n| n.is_named()).collect()
    };
    // count the index from the end if reverse is true
    if self.reverse {
      children.reverse()
    }
    children
      .iter()
      .position(|child| child.node_id() == node.node_id())
  }
  pub fn defined_vars(&self) -> HashSet<&str> {
    if let Some(rule) = &self.of_rule {
      rule.defined_vars()
    } else {
      HashSet::new()
    }
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    if let Some(rule) = &self.of_rule {
      rule.verify_util()
    } else {
      Ok(())
    }
  }
}

impl Matcher for NthChild {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let index = self.find_index(&node, env)?;
    self.position.is_matched(index).then_some(node)
  }
  fn potential_kinds(&self) -> Option<BitSet> {
    let rule = self.of_rule.as_ref()?;
    rule.potential_kinds()
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::test::TypeScript as TS;
  use ast_grep_core::matcher::RegexMatcher;
  use ast_grep_core::meta_var::MetaVarEnv;
  use ast_grep_core::tree_sitter::LanguageExt;

  #[test]
  fn test_positional() {
    let position = FunctionalPosition {
      step_size: 0,
      offset: 1,
    };
    assert!(position.is_matched(0));
    assert!(!position.is_matched(1));
    assert!(!position.is_matched(2));
  }

  #[test]
  fn test_positional_an_b() {
    let position = FunctionalPosition {
      step_size: 2,
      offset: -1,
    };
    assert!(position.is_matched(0));
    assert!(!position.is_matched(1));
    assert!(position.is_matched(2));
    assert!(!position.is_matched(3));
    assert!(position.is_matched(4));
  }

  fn find_index(rule: Option<Rule>, reverse: bool) -> Option<usize> {
    let rule = NthChild {
      position: FunctionalPosition {
        step_size: 2,
        offset: -1,
      },
      of_rule: rule.map(Box::new),
      reverse,
    };
    let mut env = Cow::Owned(MetaVarEnv::new());
    let grep = TS::Tsx.ast_grep("[1,2,3,4]");
    let node = grep.root().find("2").unwrap();
    rule.find_index(&*node, &mut env)
  }

  #[test]
  fn test_find_index_simple() {
    let i = find_index(None, false);
    assert_eq!(i, Some(1));
  }

  #[test]
  fn test_find_index_reverse() {
    let i = find_index(None, true);
    assert_eq!(i, Some(2));
  }

  #[test]
  fn test_find_of_rule() {
    let regex = RegexMatcher::try_new(r"2|3").unwrap();
    let i = find_index(Some(Rule::Regex(regex.clone())), false);
    assert_eq!(i, Some(0));
    let i = find_index(Some(Rule::Regex(regex)), true);
    assert_eq!(i, Some(1));
  }

  fn parse(s: &str) -> FunctionalPosition {
    parse_an_b(s).expect("should parse")
  }
  fn test_parse(s: &str, step: i32, offset: i32) {
    let pos = parse(s);
    assert_eq!(pos.step_size, step, "{s}: wrong step");
    assert_eq!(pos.offset, offset, "{s}: wrong offset");
  }

  #[test]
  fn test_parse_selector() {
    // https://www.w3.org/TR/css-syntax-3/#anb-microsyntax
    test_parse("12n + 2", 12, 2);
    test_parse("-12n + 21", -12, 21);
    test_parse("-12n - 21", -12, -21);
    test_parse("2n + 0", 2, 0);
    test_parse("-1n + 6", -1, 6);
    test_parse("-4n + 10", -4, 10);
    test_parse("0n + 5", 0, 5);
    test_parse("2", 0, 2);
    test_parse("-2", 0, -2);
    test_parse("n", 1, 0);
    test_parse("-n", -1, 0);
    test_parse("N", 1, 0);
    test_parse("-N", -1, 0);
    test_parse("123   n", 123, 0);
  }

  fn parse_error(s: &str, name: &str) {
    let Err(err) = parse_an_b(s) else {
      panic!("should parse error: {s}");
    };
    match err {
      NthChildError::InvalidSyntax => assert_eq!(name, "syntax"),
      NthChildError::IllegalCharacter(_) => assert_eq!(name, "character"),
      NthChildError::InvalidRule(_) => assert_eq!(name, "rule"),
    }
  }

  #[test]
  fn test_error() {
    parse_error("3a + b", "character");
    parse_error("3 - n", "syntax");
    parse_error("3 ++ n", "syntax");
    parse_error("n++", "syntax");
    parse_error("3 + 5", "syntax");
    parse_error("3n +", "syntax");
    parse_error("3n + n", "syntax");
    parse_error("n + 3n", "syntax");
    parse_error("+ n + n", "syntax");
    parse_error("+ n - n", "syntax");
    parse_error("nN", "syntax");
    parse_error("+", "syntax");
    parse_error("-", "syntax");
    parse_error("a", "character");
    parse_error("+a", "character");
    parse_error("na", "character");
  }

  fn deser(src: &str) -> Rule {
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let env = DeserializeEnv::new(TS::Tsx);
    env.deserialize_rule(rule).expect("should deserialize")
  }

  #[test]
  fn test_serialize() {
    let root = TS::Tsx.ast_grep("[1,2,3,4]");
    let root = root.root();
    let rule = deser(r"nthChild: 3");
    assert_eq!(root.find(rule).expect("should find").text(), "3");
    let rule = deser(r"nthChild: { position: 2n + 2 }");
    assert_eq!(root.find(rule).expect("should find").text(), "2");
    let rule = deser(r"nthChild: { position: 2n + 2, reverse: true }");
    assert_eq!(root.find(rule).expect("should find").text(), "1");
    let rule = deser(r"nthChild: { position: 2n + 2, ofRule: {regex: '2|3'} }");
    assert_eq!(root.find(rule).expect("should find").text(), "3");
  }

  #[test]
  fn test_defined_vars() {
    let rule = deser(r"nthChild: { position: 2, ofRule: {pattern: '$A'} }");
    assert_eq!(rule.defined_vars(), vec!["A"].into_iter().collect());
  }

  #[test]
  fn test_verify_util() {
    let rule = deser(r"nthChild: { position: 2, ofRule: {pattern: '$A'} }");
    assert!(rule.verify_util().is_ok());
  }
}



================================================
FILE: crates/config/src/rule/range.rs
================================================
use ast_grep_core::{meta_var::MetaVarEnv, Doc, Node};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Represents a zero-based character-wise position in a document
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct SerializablePosition {
  /// 0-based line number in the source code
  pub line: usize,
  /// 0-based column number in the source code
  pub column: usize,
}

/// Represents a position in source code using 0-based line and column numbers
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
pub struct SerializableRange {
  /// start position in the source code
  pub start: SerializablePosition,
  /// end position in the source code
  pub end: SerializablePosition,
}

use std::borrow::Cow;

use bit_set::BitSet;
use thiserror::Error;

use super::Matcher;

/// Errors that can occur when creating or using a RangeMatcher
#[derive(Debug, Error)]
pub enum RangeMatcherError {
  /// Returned when the range is invalid. This can occur when:
  /// - start position is after end position
  /// - positions contain invalid line/column values
  #[error("The start position must be before the end position.")]
  InvalidRange,
}

pub struct RangeMatcher {
  start: SerializablePosition,
  end: SerializablePosition,
}

impl RangeMatcher {
  pub fn new(start_pos: SerializablePosition, end_pos: SerializablePosition) -> Self {
    Self {
      start: start_pos,
      end: end_pos,
    }
  }

  pub fn try_new(
    start_pos: SerializablePosition,
    end_pos: SerializablePosition,
  ) -> Result<RangeMatcher, RangeMatcherError> {
    if start_pos.line > end_pos.line
      || (start_pos.line == end_pos.line && start_pos.column > end_pos.column)
    {
      return Err(RangeMatcherError::InvalidRange);
    }

    let range = Self::new(start_pos, end_pos);
    Ok(range)
  }
}

impl Matcher for RangeMatcher {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let node_start_pos = node.start_pos();
    let node_end_pos = node.end_pos();

    // first check line since it is cheaper
    if self.start.line != node_start_pos.line() || self.end.line != node_end_pos.line() {
      return None;
    }
    // then check column, this can be expensive for utf-8 encoded files
    if self.start.column != node_start_pos.column(&node)
      || self.end.column != node_end_pos.column(&node)
    {
      return None;
    }
    Some(node)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    None
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::test::TypeScript as TS;
  use ast_grep_core::matcher::MatcherExt;
  use ast_grep_core::tree_sitter::LanguageExt;

  #[test]
  fn test_invalid_range() {
    let range = RangeMatcher::try_new(
      SerializablePosition {
        line: 0,
        column: 10,
      },
      SerializablePosition { line: 0, column: 5 },
    );
    assert!(range.is_err());
  }

  #[test]
  fn test_range_match() {
    let cand = TS::Tsx.ast_grep("class A { a = 123 }");
    let cand = cand.root();
    let pattern = RangeMatcher::new(
      SerializablePosition {
        line: 0,
        column: 10,
      },
      SerializablePosition {
        line: 0,
        column: 17,
      },
    );
    assert!(pattern.find_node(cand).is_some());
  }

  #[test]
  fn test_range_non_match() {
    let cand = TS::Tsx.ast_grep("class A { a = 123 }");
    let cand = cand.root();
    let pattern = RangeMatcher::new(
      SerializablePosition {
        line: 0,
        column: 10,
      },
      SerializablePosition {
        line: 0,
        column: 15,
      },
    );
    assert!(pattern.find_node(cand).is_none(),);
  }

  #[test]
  fn test_multiline_range() {
    let cand = TS::Tsx
      .ast_grep("class A { \n b = () => { \n const c = 1 \n const d = 3 \n return c + d \n } }");
    let cand = cand.root();
    let pattern = RangeMatcher::new(
      SerializablePosition { line: 1, column: 1 },
      SerializablePosition { line: 5, column: 2 },
    );
    assert!(pattern.find_node(cand).is_some());
  }

  #[test]
  fn test_unicode_range() {
    let cand = TS::Tsx.ast_grep("let a = '🦄'");
    let cand = cand.root();
    let pattern = RangeMatcher::new(
      SerializablePosition { line: 0, column: 8 },
      SerializablePosition {
        line: 0,
        column: 11,
      },
    );
    let node = pattern.find_node(cand);
    assert!(node.is_some());
    assert_eq!(node.expect("should exist").text(), "'🦄'");
  }
}



================================================
FILE: crates/config/src/rule/referent_rule.rs
================================================
use crate::{Rule, RuleCore};

use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::{Doc, Matcher, Node};

use bit_set::BitSet;
use thiserror::Error;

use std::borrow::Cow;
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Weak};

pub struct Registration<R>(Arc<HashMap<String, R>>);

impl<R> Clone for Registration<R> {
  fn clone(&self) -> Self {
    Self(self.0.clone())
  }
}

impl<R> Registration<R> {
  #[allow(clippy::mut_from_ref)]
  fn write(&self) -> &mut HashMap<String, R> {
    // SAFETY: `write` will only be called during initialization and
    // it only insert new item to the hashmap. It is safe to cast the raw ptr.
    unsafe { &mut *(Arc::as_ptr(&self.0) as *mut HashMap<String, R>) }
  }
}
pub type GlobalRules = Registration<RuleCore>;

impl GlobalRules {
  pub fn insert(&self, id: &str, rule: RuleCore) -> Result<(), ReferentRuleError> {
    let map = self.write();
    if map.contains_key(id) {
      return Err(ReferentRuleError::DuplicateRule(id.into()));
    }
    map.insert(id.to_string(), rule);
    let rule = map.get(id).unwrap();
    // TODO: we can skip check here because insertion order
    // is guaranteed in deserialize_env
    if rule.check_cyclic(id) {
      return Err(ReferentRuleError::CyclicRule(id.to_string()));
    }
    Ok(())
  }
}

impl<R> Default for Registration<R> {
  fn default() -> Self {
    Self(Default::default())
  }
}

#[derive(Clone, Default)]
pub struct RuleRegistration {
  /// utility rule to every RuleCore, every sub-rule has its own local utility
  local: Registration<Rule>,
  /// global rules are shared by all RuleConfigs. It is a singleton.
  global: Registration<RuleCore>,
  /// Every RuleConfig has its own rewriters. But sub-rules share parent's rewriters.
  rewriters: Registration<RuleCore>,
}

// these are shit code
impl RuleRegistration {
  pub fn get_rewriters(&self) -> &HashMap<String, RuleCore> {
    &self.rewriters.0
  }

  pub fn from_globals(global: &GlobalRules) -> Self {
    Self {
      local: Default::default(),
      global: global.clone(),
      rewriters: Default::default(),
    }
  }

  fn get_ref(&self) -> RegistrationRef {
    let local = Arc::downgrade(&self.local.0);
    let global = Arc::downgrade(&self.global.0);
    RegistrationRef { local, global }
  }

  pub(crate) fn insert_local(&self, id: &str, rule: Rule) -> Result<(), ReferentRuleError> {
    let map = self.local.write();
    if map.contains_key(id) {
      return Err(ReferentRuleError::DuplicateRule(id.into()));
    }
    map.insert(id.to_string(), rule);
    let rule = map.get(id).unwrap();
    // TODO: we can skip check here because insertion order
    // is guaranteed in deserialize_env
    if rule.check_cyclic(id) {
      return Err(ReferentRuleError::CyclicRule(id.to_string()));
    }
    Ok(())
  }

  pub(crate) fn insert_rewriter(&self, id: &str, rewriter: RuleCore) {
    self.rewriters.insert(id, rewriter).expect("should work");
  }

  pub(crate) fn get_local_util_vars(&self) -> HashSet<&str> {
    let mut ret = HashSet::new();
    let utils = &self.local.0;
    for rule in utils.values() {
      for v in rule.defined_vars() {
        ret.insert(v);
      }
    }
    ret
  }
}

/// RegistrationRef must use Weak pointer to avoid
/// cyclic reference in RuleRegistration
struct RegistrationRef {
  local: Weak<HashMap<String, Rule>>,
  global: Weak<HashMap<String, RuleCore>>,
}
impl RegistrationRef {
  fn get_local(&self) -> Arc<HashMap<String, Rule>> {
    self
      .local
      .upgrade()
      .expect("Rule Registration must be kept alive")
  }
  fn get_global(&self) -> Arc<HashMap<String, RuleCore>> {
    self
      .global
      .upgrade()
      .expect("Rule Registration must be kept alive")
  }
}

#[derive(Debug, Error)]
pub enum ReferentRuleError {
  #[error("Rule `{0}` is not defined.")]
  UndefinedUtil(String),
  #[error("Duplicate rule id `{0}` is found.")]
  DuplicateRule(String),
  #[error("Rule `{0}` has a cyclic dependency in its `matches` sub-rule.")]
  CyclicRule(String),
}

pub struct ReferentRule {
  pub(crate) rule_id: String,
  reg_ref: RegistrationRef,
}

impl ReferentRule {
  pub fn try_new(
    rule_id: String,
    registration: &RuleRegistration,
  ) -> Result<Self, ReferentRuleError> {
    Ok(Self {
      reg_ref: registration.get_ref(),
      rule_id,
    })
  }

  fn eval_local<F, T>(&self, func: F) -> Option<T>
  where
    F: FnOnce(&Rule) -> T,
  {
    let rules = self.reg_ref.get_local();
    let rule = rules.get(&self.rule_id)?;
    Some(func(rule))
  }

  fn eval_global<F, T>(&self, func: F) -> Option<T>
  where
    F: FnOnce(&RuleCore) -> T,
  {
    let rules = self.reg_ref.get_global();
    let rule = rules.get(&self.rule_id)?;
    Some(func(rule))
  }

  pub(super) fn verify_util(&self) -> Result<(), ReferentRuleError> {
    let rules = self.reg_ref.get_local();
    if rules.contains_key(&self.rule_id) {
      return Ok(());
    }
    let rules = self.reg_ref.get_global();
    if rules.contains_key(&self.rule_id) {
      return Ok(());
    }
    Err(ReferentRuleError::UndefinedUtil(self.rule_id.clone()))
  }
}

impl Matcher for ReferentRule {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    self
      .eval_local(|r| r.match_node_with_env(node.clone(), env))
      .or_else(|| self.eval_global(|r| r.match_node_with_env(node, env)))
      .flatten()
  }
  fn potential_kinds(&self) -> Option<BitSet> {
    self
      .eval_local(|r| {
        debug_assert!(!r.check_cyclic(&self.rule_id), "no cyclic rule allowed");
        r.potential_kinds()
      })
      .or_else(|| {
        self.eval_global(|r| {
          debug_assert!(!r.check_cyclic(&self.rule_id), "no cyclic rule allowed");
          r.potential_kinds()
        })
      })
      .flatten()
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::rule::Rule;
  use crate::test::TypeScript as TS;
  use ast_grep_core::ops as o;
  use ast_grep_core::Pattern;

  type Result = std::result::Result<(), ReferentRuleError>;

  #[test]
  fn test_cyclic_error() -> Result {
    let registration = RuleRegistration::default();
    let rule = ReferentRule::try_new("test".into(), &registration)?;
    let rule = Rule::Matches(rule);
    let error = registration.insert_local("test", rule);
    assert!(matches!(error, Err(ReferentRuleError::CyclicRule(_))));
    Ok(())
  }

  #[test]
  fn test_cyclic_all() -> Result {
    let registration = RuleRegistration::default();
    let rule = ReferentRule::try_new("test".into(), &registration)?;
    let rule = Rule::All(o::All::new(std::iter::once(Rule::Matches(rule))));
    let error = registration.insert_local("test", rule);
    assert!(matches!(error, Err(ReferentRuleError::CyclicRule(_))));
    Ok(())
  }

  #[test]
  fn test_cyclic_not() -> Result {
    let registration = RuleRegistration::default();
    let rule = ReferentRule::try_new("test".into(), &registration)?;
    let rule = Rule::Not(Box::new(o::Not::new(Rule::Matches(rule))));
    let error = registration.insert_local("test", rule);
    assert!(matches!(error, Err(ReferentRuleError::CyclicRule(_))));
    Ok(())
  }

  #[test]
  fn test_success_rule() -> Result {
    let registration = RuleRegistration::default();
    let rule = ReferentRule::try_new("test".into(), &registration)?;
    let pattern = Rule::Pattern(Pattern::new("some", TS::Tsx));
    let ret = registration.insert_local("test", pattern);
    assert!(ret.is_ok());
    assert!(rule.potential_kinds().is_some());
    Ok(())
  }
}



================================================
FILE: crates/config/src/rule/relational_rule.rs
================================================
use super::deserialize_env::DeserializeEnv;
use super::stop_by::{SerializableStopBy, StopBy};
use crate::rule::{Rule, RuleSerializeError, SerializableRule};
use ast_grep_core::language::Language;
use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::{Doc, Matcher, Node};

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::collections::HashSet;

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
#[schemars(
  description = "A relational rule object, which is a Rule object with two additional fields stopBy and field."
)]
pub struct Relation {
  #[serde(flatten)]
  pub rule: SerializableRule,
  #[serde(default)]
  pub stop_by: SerializableStopBy,
  pub field: Option<String>,
}

fn field_name_to_id<L: Language>(
  field: Option<String>,
  env: &DeserializeEnv<L>,
) -> Result<Option<u16>, RuleSerializeError> {
  let Some(field) = field else {
    return Ok(None);
  };
  match env.lang.field_to_id(&field) {
    Some(id) => Ok(Some(id)),
    None => Err(RuleSerializeError::InvalidField(field)),
  }
}

pub struct Inside {
  outer: Rule,
  field: Option<u16>,
  stop_by: StopBy,
}
impl Inside {
  pub(crate) fn rule(rule: Rule) -> Self {
    Self {
      outer: rule,
      field: None,
      stop_by: StopBy::Neighbor,
    }
  }
  pub(crate) fn rule_descent(rule: Rule) -> Self {
    Self {
      outer: rule,
      field: None,
      stop_by: StopBy::End,
    }
  }
  pub fn try_new<L: Language>(
    relation: Relation,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, RuleSerializeError> {
    Ok(Self {
      stop_by: StopBy::try_from(relation.stop_by, env)?,
      field: field_name_to_id(relation.field, env)?,
      outer: env.deserialize_rule(relation.rule)?, // TODO
    })
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    self
      .outer
      .defined_vars()
      .union(&self.stop_by.defined_vars())
      .copied()
      .collect()
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    self.outer.verify_util()?;
    self.stop_by.verify_util()
  }
}

impl Matcher for Inside {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let parent = || node.parent();
    let ancestors = || node.ancestors();
    if let Some(field) = self.field {
      let mut last_id = node.node_id();
      let finder = move |nd: Node<'tree, D>| {
        let expect_id = last_id;
        last_id = nd.node_id();
        let n = nd.child_by_field_id(field)?;
        if n.node_id() != expect_id {
          None
        } else {
          self.outer.match_node_with_env(nd, env)
        }
      };
      self.stop_by.find(parent, ancestors, finder)
    } else {
      let finder = |n| self.outer.match_node_with_env(n, env);
      self.stop_by.find(parent, ancestors, finder)
    }
  }
}

pub struct Has {
  inner: Rule,
  stop_by: StopBy,
  field: Option<u16>,
}
impl Has {
  pub fn try_new<L: Language>(
    relation: Relation,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, RuleSerializeError> {
    Ok(Self {
      stop_by: StopBy::try_from(relation.stop_by, env)?,
      inner: env.deserialize_rule(relation.rule)?,
      field: field_name_to_id(relation.field, env)?,
    })
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    self
      .inner
      .defined_vars()
      .union(&self.stop_by.defined_vars())
      .copied()
      .collect()
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    self.inner.verify_util()?;
    self.stop_by.verify_util()
  }
}

impl Matcher for Has {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if let Some(field) = self.field {
      let nd = node.child_by_field_id(field)?;
      return match &self.stop_by {
        StopBy::Neighbor => self.inner.match_node_with_env(nd, env),
        StopBy::End => nd
          .dfs()
          .find_map(|n| self.inner.match_node_with_env(n, env)),
        StopBy::Rule(matcher) => {
          // TODO: use Pre traversal to reduce stack allocation
          self.inner.match_node_with_env(nd.clone(), env).or_else(|| {
            if nd.matches(matcher) {
              None
            } else {
              nd.children()
                .find_map(|n| self.inner.match_node_with_env(n, env))
            }
          })
        }
      };
    }
    match &self.stop_by {
      StopBy::Neighbor => node
        .children()
        .find_map(|n| self.inner.match_node_with_env(n, env)),
      StopBy::End => node
        .dfs()
        .skip(1)
        .find_map(|n| self.inner.match_node_with_env(n, env)),
      StopBy::Rule(matcher) => {
        // TODO: use Pre traversal to reduce stack allocation
        node.children().find_map(|n| {
          self.inner.match_node_with_env(n.clone(), env).or_else(|| {
            if n.matches(matcher) {
              None
            } else {
              self.match_node_with_env(n, env)
            }
          })
        })
      }
    }
  }
}

pub struct Precedes {
  later: Rule,
  stop_by: StopBy,
}
impl Precedes {
  pub fn try_new<L: Language>(
    relation: Relation,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, RuleSerializeError> {
    if relation.field.is_some() {
      return Err(RuleSerializeError::FieldNotSupported);
    }
    Ok(Self {
      stop_by: StopBy::try_from(relation.stop_by, env)?,
      later: env.deserialize_rule(relation.rule)?,
    })
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    self
      .later
      .defined_vars()
      .union(&self.stop_by.defined_vars())
      .copied()
      .collect()
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    self.later.verify_util()?;
    self.stop_by.verify_util()
  }
}
impl Matcher for Precedes {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let next = || node.next();
    let next_all = || node.next_all();
    let finder = |n| self.later.match_node_with_env(n, env);
    self.stop_by.find(next, next_all, finder)
  }
}

pub struct Follows {
  former: Rule,
  stop_by: StopBy,
}
impl Follows {
  pub(crate) fn rule(rule: Rule) -> Self {
    Self {
      former: rule,
      stop_by: StopBy::Neighbor,
    }
  }
  pub(crate) fn rule_descent(rule: Rule) -> Self {
    Self {
      former: rule,
      stop_by: StopBy::End,
    }
  }
  pub fn try_new<L: Language>(
    relation: Relation,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, RuleSerializeError> {
    if relation.field.is_some() {
      return Err(RuleSerializeError::FieldNotSupported);
    }
    Ok(Self {
      stop_by: StopBy::try_from(relation.stop_by, env)?,
      former: env.deserialize_rule(relation.rule)?,
    })
  }
  pub fn defined_vars(&self) -> HashSet<&str> {
    self
      .former
      .defined_vars()
      .union(&self.stop_by.defined_vars())
      .copied()
      .collect()
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    self.former.verify_util()?;
    self.stop_by.verify_util()
  }
}
impl Matcher for Follows {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let prev = || node.prev();
    let prev_all = || node.prev_all();
    let finder = |n| self.former.match_node_with_env(n, env);
    self.stop_by.find(prev, prev_all, finder)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::test::TypeScript as TS;
  use ast_grep_core::matcher::KindMatcher;
  use ast_grep_core::ops as o;
  use ast_grep_core::Pattern;
  use ast_grep_core::{tree_sitter::LanguageExt, Language};

  fn find_rule<M: Matcher>(src: &str, matcher: M) -> Option<String> {
    let grep = TS::Tsx.ast_grep(src);
    grep.root().find(matcher).map(|s| s.text().to_string())
  }

  fn test_found<M: Matcher>(found_list: &[&str], matcher: M) {
    for found in found_list {
      assert!(find_rule(found, &matcher).is_some());
    }
  }

  fn test_not_found<M: Matcher>(not_found_list: &[&str], matcher: M) {
    for found in not_found_list {
      assert!(find_rule(found, &matcher).is_none());
    }
  }

  fn make_rule(target: &str, relation: Rule) -> impl Matcher {
    o::All::new(vec![Rule::Pattern(Pattern::new(target, TS::Tsx)), relation])
  }

  #[test]
  fn test_precedes_operator() {
    let precedes = Precedes {
      later: Rule::Pattern(Pattern::new("var a = 1", TS::Tsx)),
      stop_by: StopBy::End,
    };
    let rule = make_rule("var b = 2", Rule::Precedes(Box::new(precedes)));
    test_found(
      &[
        "var b = 2; var a = 1;",
        "var b = 2; alert(b); var a = 1;",
        "var b = 2; var a = 1",
        "var b = 2\n var a = 1",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var a = 1",
        "var b = 2; var a = 2;",
        "var a = 1; var b = 2;",
        "{ var a = 1 }",
        "var b = 2; { var a = 1 }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_precedes_immediate() {
    let precedes = Precedes {
      later: Rule::Pattern(Pattern::new("var a = 1", TS::Tsx)),
      stop_by: StopBy::Neighbor,
    };
    let rule = make_rule("var b = 2", Rule::Precedes(Box::new(precedes)));
    test_found(
      &[
        "var b = 2; var a = 1;",
        "var b = 2; var a = 1",
        "var b = 2\n var a = 1",
        "{ var b = 2; var a = 1 }",
        "function test() { var b = 2; var a = 1 }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var a = 1",
        "var b = 2; var a = 2;",
        "var a = 1; var b = 2;",
        "var b = 2; alert(b); var a = 1;",
        "{ var b = 2 } var a = 1;",
      ],
      &rule,
    );
  }

  #[test]
  fn test_follows_operator() {
    let follows = Follows {
      former: Rule::Pattern(Pattern::new("var b = 2", TS::Tsx)),
      stop_by: StopBy::End,
    };
    let rule = make_rule("var a = 1", Rule::Follows(Box::new(follows)));
    test_found(
      &[
        "var b = 2; var a = 1;",
        "var b = 2; var a = 1",
        "var b = 2; alert(b); var a = 1",
        "var b = 2\n var a = 1",
        "alert(b); var b = 2; var a = 1",
        "{var b = 2; var a = 1;}", // inside block
      ],
      &rule,
    );
    test_not_found(
      &[
        "var a = 1",
        "var b = 2",
        "var a = 1; var b = 2;",
        "var a = 1; alert(b) ;var b = 2;",
        "var a = 1\n var b = 2;",
        "{var b = 2;} var a = 1;", // inside block
      ],
      &rule,
    );
  }

  #[test]
  fn test_follows_immediate() {
    let follows = Follows {
      former: Rule::Pattern(Pattern::new("var b = 2", TS::Tsx)),
      stop_by: StopBy::Neighbor,
    };
    let rule = make_rule("var a = 1", Rule::Follows(Box::new(follows)));
    test_found(
      &[
        "var b = 2; var a = 1;",
        "var b = 2; var a = 1",
        "var b = 2\n var a = 1",
        "alert(b); var b = 2; var a = 1",
        "{var b = 2; var a = 1;}", // inside block
      ],
      &rule,
    );
    test_not_found(
      &[
        "var a = 1",
        "var b = 2",
        "var a = 1; var b = 2;",
        "var a = 1; alert(b) ;var b = 2;",
        "var a = 1\n var b = 2;",
        "var b = 2; alert(b); var a = 1", // not immediate
        "{var b = 2;} var a = 1;",        // inside block
      ],
      &rule,
    );
  }

  #[test]
  fn test_has_rule() {
    let has = Has {
      stop_by: StopBy::End,
      inner: Rule::Pattern(Pattern::new("var a = 1", TS::Tsx)),
      field: None,
    };
    let rule = make_rule("function test() { $$$ }", Rule::Has(Box::new(has)));
    test_found(
      &[
        "function test() { var a = 1 }",
        "function test() { var a = 1; var b = 2 }",
        "function test() { function nested() { var a = 1 } }",
        "function test() { if (nested) { var a = 1 } }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var test = function () { var a = 2 }",
        "function test() { var a = 2 }",
        "function test() { let a = 1; var b = 2 }",
        "if (test) {  { var a = 1 } }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_has_until_should_not_abort_prematurely() {
    let has = Has {
      stop_by: StopBy::Rule(Rule::Kind(KindMatcher::new(
        "function_declaration",
        TS::Tsx,
      ))),
      inner: Rule::Pattern(Pattern::new("var a = 1", TS::Tsx)),
      field: None,
    };
    let rule = make_rule("function test() { $$$ }", Rule::Has(Box::new(has)));
    test_found(
      &[
        "function test() { var a = 1}",
        "function test() { function inner() { var a = 1 }; var a = 1}",
      ],
      &rule,
    );
    test_not_found(
      &[
        "function test() { var a = 2}",
        "function test() { function inner() { var a = 1 }}",
      ],
      &rule,
    );
  }

  #[test]
  fn test_has_until_should_be_inclusive() {
    let has = Has {
      stop_by: StopBy::Rule(Rule::Kind(KindMatcher::new(
        "function_declaration",
        TS::Tsx,
      ))),
      inner: Rule::Pattern(Pattern::new("function inner() {$$$}", TS::Tsx)),
      field: None,
    };
    let rule = make_rule("function test() { $$$ }", Rule::Has(Box::new(has)));
    test_found(
      &[
        "function test() { function inner() { var a = 1 };}",
        "function test() { var a = 1; function inner() { var a = 1 };}",
        "function test() { if (false) { function inner() { var a = 1 };} }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "function test() { var a = 2}",
        "function test() { function bbb() { function inner() { var a = 1 } }}",
      ],
      &rule,
    );
  }

  #[test]
  fn test_has_immediate() {
    let has = Has {
      stop_by: StopBy::Neighbor,
      inner: Rule::Pattern(Pattern::new("var a = 1", TS::Tsx)),
      field: None,
    };
    let rule = o::All::new(vec![
      Rule::Pattern(Pattern::new("{ $$$ }", TS::Tsx)),
      Rule::Inside(Box::new(Inside {
        outer: Rule::Pattern(Pattern::new("function test() { $$$ }", TS::Tsx)),
        stop_by: StopBy::Neighbor,
        field: None,
      })),
      Rule::Has(Box::new(has)),
    ]);
    test_found(
      &[
        "function test() { var a = 1 }",
        "function test() { var a = 1; var b = 2 }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var test = function () { var a = 2 }",
        "function test() { var a = 2 }",
        "function test() { let a = 1; var b = 2 }",
        "if (test) {  { var a = 1 } }",
        // nested
        "function test() { if (nested) { var a = 1 } }",
        "function test() { function nested() { var a = 1 } }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_inside_rule() {
    let inside = Inside {
      stop_by: StopBy::End,
      outer: Rule::Pattern(Pattern::new("function test() { $$$ }", TS::Tsx)),
      field: None,
    };
    let rule = make_rule("var a = 1", Rule::Inside(Box::new(inside)));
    test_found(
      &[
        "function test() { var a = 1 }",
        "function test() { var a = 1; var b = 2 }",
        "function test() { function nested() { var a = 1 } }",
        "function test() { if (nested) { var a = 1 } }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var test = function () { var a = 2 }",
        "function test() { var a = 2 }",
        "function test() { let a = 1; var b = 2 }",
        "if (test) {  { var a = 1 } }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_inside_inclusive() {
    let inside = Inside {
      stop_by: StopBy::Rule(Rule::Kind(KindMatcher::new(
        "function_declaration",
        TS::Tsx,
      ))),
      outer: Rule::Pattern(Pattern::new("function test() { $$$ }", TS::Tsx)),
      field: None,
    };
    let rule = make_rule("var a = 1", Rule::Inside(Box::new(inside)));
    test_found(
      &[
        "function test() { var a = 1 }",
        "function test() { var a = 1; var b = 2 }",
        "function test() { if (nested) { var a = 1 } }",
        "function test() { var b = function(nested) { var a = 1 } }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "function test() { function nested() { var a = 1 } }",
        "var test = function () { var a = 2 }",
        "function test() { var a = 2 }",
        "function test() { let a = 1; var b = 2 }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_inside_immediate() {
    let inside = Inside {
      stop_by: StopBy::Neighbor,
      outer: Rule::All(o::All::new(vec![
        Rule::Pattern(Pattern::new("{ $$$ }", TS::Tsx)),
        Rule::Inside(Box::new(Inside {
          outer: Rule::Pattern(Pattern::new("function test() { $$$ }", TS::Tsx)),
          stop_by: StopBy::Neighbor,
          field: None,
        })),
      ])),
      field: None,
    };
    let rule = make_rule("var a = 1", Rule::Inside(Box::new(inside)));
    test_found(
      &[
        "function test() { var a = 1 }",
        "function test() { var a = 1; var b = 2 }",
      ],
      &rule,
    );
    test_not_found(
      &[
        "var test = function () { var a = 2 }",
        "function test() { var a = 2 }",
        "function test() { let a = 1; var b = 2 }",
        "if (test) {  { var a = 1 } }",
        // nested
        "function test() { function nested() { var a = 1 } }",
        "function test() { if (nested) { var a = 1 } }",
      ],
      &rule,
    );
  }

  #[test]
  fn test_inside_field() {
    let inside = Inside {
      stop_by: StopBy::End,
      outer: Rule::Kind(KindMatcher::new("for_statement", TS::Tsx)),
      field: TS::Tsx.field_to_id("condition"),
    };
    let rule = make_rule("a = 1", Rule::Inside(Box::new(inside)));
    test_found(&["for (;a = 1;) {}"], &rule);
    test_not_found(&["for (;; a = 1) {}"], &rule);
  }

  #[test]
  fn test_has_field() {
    let has = Has {
      stop_by: StopBy::End,
      inner: Rule::Pattern(Pattern::new("a = 1", TS::Tsx)),
      field: TS::Tsx.field_to_id("condition"),
    };
    let rule = o::All::new(vec![
      Rule::Kind(KindMatcher::new("for_statement", TS::Tsx)),
      Rule::Has(Box::new(has)),
    ]);
    test_found(&["for (;a = 1;) {}"], &rule);
    test_not_found(&["for (;; a = 1) {}", "for (;;) { a = 1}"], &rule);
  }

  #[test]
  fn test_invalid_field() {
    let env = DeserializeEnv::new(TS::Tsx);
    let relation = Relation {
      rule: crate::from_str("pattern: test").unwrap(),
      stop_by: SerializableStopBy::End,
      field: Some("invalid_field".to_string()),
    };
    let inside = Inside::try_new(relation, &env);
    assert!(inside.is_err());
    match inside {
      Err(RuleSerializeError::InvalidField(_)) => {}
      _ => panic!("expected InvalidField error"),
    }
  }

  #[test]
  fn test_defined_vars() {
    let precedes = Precedes {
      later: Rule::Pattern(Pattern::new("var a = $A", TS::Tsx)),
      stop_by: StopBy::Rule(Rule::Pattern(Pattern::new("var b = $B", TS::Tsx))),
    };
    assert_eq!(precedes.defined_vars(), ["A", "B"].into_iter().collect());
    let follows = Follows {
      former: Rule::Pattern(Pattern::new("var a = 123", TS::Tsx)),
      stop_by: StopBy::Rule(Rule::Pattern(Pattern::new("var b = $B", TS::Tsx))),
    };
    assert_eq!(follows.defined_vars(), ["B"].into_iter().collect());
    let inside = Inside {
      stop_by: StopBy::Rule(Rule::Pattern(Pattern::new("var $C", TS::Tsx))),
      outer: Rule::Pattern(Pattern::new("var a = $A", TS::Tsx)),
      field: TS::Tsx.field_to_id("condition"),
    };
    assert_eq!(inside.defined_vars(), ["A", "C"].into_iter().collect());
    let has = Has {
      stop_by: StopBy::Rule(Rule::Kind(KindMatcher::new("for_statement", TS::Tsx))),
      inner: Rule::Pattern(Pattern::new("var a = $A", TS::Tsx)),
      field: TS::Tsx.field_to_id("condition"),
    };
    assert_eq!(has.defined_vars(), ["A"].into_iter().collect());
  }
}



================================================
FILE: crates/config/src/rule/selector.rs
================================================
#![allow(clippy::doc_lazy_continuation)]
/// a css selector parser for tree-sitter kind
///
/// Example selector
/// * `call_expression > identifier`
/// is equvalent to
/// ```yaml
/// kind: identifier
/// inside:
///   kind: call_expression
/// ```
/// * `call_expression identifier`
/// is equvalent to
/// ```yaml
/// kind: identifier
/// inside:
///   kind: call_expression
///   stopBy: end
/// ```
/** Grammar for selector

<selector-list> = <complex-selector>#

<complex-selector> = <compound-selector> [ <combinator> <compound-selector> ]*

<compound-selector> = [ <type-selector>? <subclass-selector>* ]!

<combinator> = '>' | '+' | '~' | ' '

<type-selector> = <ident-token>

<subclass-selector> = <class-selector> | <pseudo-class-selector>

<class-selector> = '.' <ident-token>

<pseudo-class-selector> = ':' <ident-token> [ '(' <selector-list> ')' ]?
*/
use super::{
  relational_rule::{Follows, Inside},
  Rule,
};
use ast_grep_core::{
  matcher::{KindMatcher, KindMatcherError},
  ops, Language,
};
use thiserror::Error;

// Inspired by CSS Selector, see
// https://www.w3.org/TR/selectors-4/#grammar
/// Token types for the lexer
#[derive(Debug, Clone, PartialEq)]
enum Token<'a> {
  Identifier(&'a str),
  /// + ~ > or space ` `
  Combinator(char),
  /// .
  ClassDot,
  /// :
  PseudoColon,
  /// (
  LeftParen,
  /// )
  RightParen,
  /// ,
  Comma,
}

pub fn parse_selector<L: Language>(source: &str, lang: L) -> Result<Rule, SelectorError> {
  let mut input = Input::new(source, lang);
  let ret = try_parse_selector(&mut input)?;
  if !input.is_empty() {
    return Err(SelectorError::UnexpectedToken);
  }
  Ok(ret)
}

/// <selector-list> = <complex-selector>#
fn try_parse_selector<'a, L: Language>(input: &mut Input<'a, L>) -> Result<Rule, SelectorError> {
  let mut rules = vec![];
  while !input.is_empty() {
    let complex_selector = parse_complex_selector(input)?;
    rules.push(complex_selector);
    if let Some(Token::Comma) = input.peek()? {
      input.next()?; // consume the comma
    } else if !input.is_empty() {
      break;
    }
  }
  Ok(Rule::Any(ops::Any::new(rules)))
}

/// <complex-selector> = <compound-selector> [ <combinator> <compound-selector> ]*
fn parse_complex_selector<'a, L: Language>(
  input: &mut Input<'a, L>,
) -> Result<Rule, SelectorError> {
  let mut rule = parse_compound_selector(input)?;
  loop {
    let Some(combinator) = try_parse_combinator(input)? else {
      break; // no more combinators
    };
    let next_rule = parse_compound_selector(input)?;
    match combinator {
      '>' => {
        rule = Rule::All(ops::All::new([
          next_rule,
          Rule::Inside(Box::new(Inside::rule(rule))),
        ]));
      }
      '+' => {
        rule = Rule::All(ops::All::new([
          next_rule,
          Rule::Follows(Box::new(Follows::rule(rule))),
        ]));
      }
      '~' => {
        rule = Rule::All(ops::All::new([
          next_rule,
          Rule::Follows(Box::new(Follows::rule_descent(rule))),
        ]));
      }
      ' ' => {
        // space combinator means any descendant
        rule = Rule::All(ops::All::new([
          next_rule,
          Rule::Inside(Box::new(Inside::rule_descent(rule))),
        ]));
      }
      _ => {
        return Err(SelectorError::IllegalCharacter(combinator));
      }
    }
  }
  Ok(rule)
}

/// <combinator> = '>' | '+' | '~' | ' '
fn try_parse_combinator<'a, L: Language>(
  input: &mut Input<'a, L>,
) -> Result<Option<char>, SelectorError> {
  let Some(Token::Combinator(c)) = input.peek()? else {
    return Ok(None);
  };
  let c = *c;
  input.next()?; // consume the combinator
  Ok(Some(c))
}

/// <compound-selector> = [ <type-selector>? <subclass-selector>* ]!
fn parse_compound_selector<'a, L: Language>(
  input: &mut Input<'a, L>,
) -> Result<Rule, SelectorError> {
  let mut rules = vec![];
  if let Some(rule) = try_parse_type_selector(input)? {
    rules.push(rule);
  }
  while let Some(subclass_rule) = try_parse_subclass_selector(input)? {
    rules.push(subclass_rule);
  }
  if rules.is_empty() {
    return Err(SelectorError::MissingSelector);
  }
  Ok(Rule::All(ops::All::new(rules)))
}

fn try_parse_type_selector<'a, L: Language>(
  input: &mut Input<'a, L>,
) -> Result<Option<Rule>, SelectorError> {
  let Some(Token::Identifier(ident)) = input.peek()? else {
    return Ok(None);
  };
  let ident = *ident;
  let lang = input.language.clone();
  input.next()?;
  let matcher = KindMatcher::try_new(ident, lang)?;
  Ok(Some(Rule::Kind(matcher)))
}

/// <subclass-selector> = <class-selector> | <pseudo-class-selector>
fn try_parse_subclass_selector<'a, L: Language>(
  input: &mut Input<'a, L>,
) -> Result<Option<Rule>, SelectorError> {
  if let Some(Token::ClassDot) = input.peek()? {
    return Err(SelectorError::Unsupported("class-selector"));
  } else if let Some(Token::PseudoColon) = input.peek()? {
    return Err(SelectorError::Unsupported("pseudo-class-selector"));
  }
  Ok(None)
}

#[derive(Debug, Error)]
pub enum SelectorError {
  #[error("Illegal character {0} encountered")]
  IllegalCharacter(char),
  #[error("Unexpected token")]
  UnexpectedToken,
  #[error("Missing Selector")]
  MissingSelector,
  #[error("Invalid Kind")]
  InvalidKind(#[from] KindMatcherError),
  #[error("{0} is not supported yet")]
  Unsupported(&'static str),
}

struct Input<'a, L: Language> {
  source: &'a str,
  lookahead: Option<Token<'a>>,
  language: L,
}

impl<'a, L: Language> Input<'a, L> {
  fn new(source: &'a str, language: L) -> Self {
    Self {
      source: source.trim(),
      lookahead: None,
      language,
    }
  }

  fn is_empty(&self) -> bool {
    self.source.is_empty() && self.lookahead.is_none()
  }

  fn consume_whitespace(&mut self) {
    self.source = self.source.trim_start();
  }

  fn do_next(&mut self) -> Result<Option<Token<'a>>, SelectorError> {
    if self.source.is_empty() {
      return Ok(None);
    }
    let (next_token, step, need_trim) = match self.source.as_bytes()[0] as char {
      ' ' => {
        let len = self
          .source
          .find(|c: char| !c.is_whitespace())
          .unwrap_or(self.source.len());
        if self.source.len() > len && matches!(self.source.as_bytes()[len] as char, '+' | '~' | '>')
        {
          self.consume_whitespace();
          return self.do_next(); // skip whitespace
        }
        (Token::Combinator(' '), len, true)
      }
      c @ ('+' | '~' | '>') => (Token::Combinator(c), 1, true),
      '.' => (Token::ClassDot, 1, false),
      ':' => (Token::PseudoColon, 1, false),
      '(' => (Token::LeftParen, 1, true),
      ')' => (Token::RightParen, 1, false),
      ',' => (Token::Comma, 1, true),
      'a'..='z' | 'A'..='Z' | '_' | '-' => {
        let len = self
          .source
          .find(|c| !matches!(c, 'a'..='z' | 'A'..='Z' | '_' | '-'))
          .unwrap_or(self.source.len());
        let ident = &self.source[..len];
        (Token::Identifier(ident), len, false)
      }
      c => {
        return Err(SelectorError::IllegalCharacter(c));
      }
    };
    self.source = &self.source[step..];
    if need_trim {
      self.consume_whitespace();
    }
    Ok(Some(next_token))
  }

  fn next(&mut self) -> Result<Option<Token<'a>>, SelectorError> {
    if let Some(token) = self.lookahead.take() {
      Ok(Some(token))
    } else {
      self.do_next()
    }
  }

  fn peek(&mut self) -> Result<&Option<Token<'a>>, SelectorError> {
    if self.lookahead.is_some() {
      return Ok(&self.lookahead);
    }
    let next_token = self.do_next()?;
    self.lookahead = next_token;
    Ok(&self.lookahead)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::test::TypeScript as TS;
  use ast_grep_core::tree_sitter::LanguageExt;

  fn input_to_tokens(input: &str) -> Result<Vec<Token<'_>>, SelectorError> {
    let mut input = Input::new(input, TS::Tsx);
    let mut tokens = Vec::new();
    while let Some(token) = input.next()? {
      tokens.push(token);
    }
    Ok(tokens)
  }

  #[test]
  fn test_valid_tokens() -> Result<(), SelectorError> {
    let tokens = input_to_tokens("call_expression + statement > .body :has, identifier")?;
    let expected = vec![
      Token::Identifier("call_expression"),
      Token::Combinator('+'),
      Token::Identifier("statement"),
      Token::Combinator('>'),
      Token::ClassDot,
      Token::Identifier("body"),
      Token::Combinator(' '),
      Token::PseudoColon,
      Token::Identifier("has"),
      Token::Comma,
      Token::Identifier("identifier"),
    ];
    assert_eq!(tokens, expected);
    // Test with extra whitespace
    let tokens =
      input_to_tokens("  call_expression   +   statement  >   .body    :has,    identifier  ")?;
    assert_eq!(tokens, expected);
    Ok(())
  }

  #[test]
  fn test_illegal_character() {
    let mut input = Input::new("call_expression $ statement", TS::Tsx);

    assert_eq!(
      input.next().unwrap(),
      Some(Token::Identifier("call_expression"))
    );
    assert_eq!(input.next().unwrap(), Some(Token::Combinator(' ')));
    assert!(matches!(
      input.next(),
      Err(SelectorError::IllegalCharacter('$'))
    ));
  }

  #[test]
  fn test_edge_cases() -> Result<(), SelectorError> {
    // Empty string
    let mut input = Input::new("", TS::Tsx);
    assert_eq!(input.next()?, None);

    // Leading and trailing whitespaces
    let mut input = Input::new("   call_expression   ", TS::Tsx);
    assert_eq!(input.next()?, Some(Token::Identifier("call_expression")));
    assert_eq!(input.next()?, None);

    // Mixed valid and invalid characters
    let mut input = Input::new("call_expression$statement", TS::Tsx);
    assert_eq!(input.next()?, Some(Token::Identifier("call_expression")));
    assert!(matches!(
      input.next(),
      Err(SelectorError::IllegalCharacter('$'))
    ));

    // Long sequence of identifiers
    let mut input = Input::new("thisisaverylongidentifier", TS::Tsx);
    assert_eq!(
      input.next()?,
      Some(Token::Identifier("thisisaverylongidentifier"))
    );
    assert_eq!(input.next()?, None);
    Ok(())
  }

  #[test]
  fn test_parse_selector() -> Result<(), SelectorError> {
    let selector = "call_expression > identifier";
    let rule = parse_selector(selector, TS::Tsx)?;
    let root = TS::Tsx.ast_grep("test(123)");
    let ident = root.root().find(&rule).expect("Should find identifier");
    assert_eq!(ident.kind(), "identifier");
    assert_eq!(ident.text(), "test");
    let rule = parse_selector("call_expression > number", TS::Tsx)?;
    assert!(root.root().find(&rule).is_none());
    let rule = parse_selector("call_expression number", TS::Tsx)?;
    let number = root.root().find(&rule).expect("Should find number");
    assert_eq!(number.text(), "123");
    Ok(())
  }
}



================================================
FILE: crates/config/src/rule/stop_by.rs
================================================
use super::deserialize_env::DeserializeEnv;
use crate::rule::{Rule, RuleSerializeError, SerializableRule};

use ast_grep_core::language::Language;
use ast_grep_core::{Doc, Node};

use schemars::{json_schema, JsonSchema, Schema, SchemaGenerator};
use serde::de::{self, Deserializer, MapAccess, Visitor};
use serde::{Deserialize, Serialize};

use std::borrow::Cow;
use std::collections::HashSet;
use std::fmt;

// NB StopBy's JsonSchema is changed in xtask/schema.rs
// revise schema is easier than manually implementation
#[derive(Clone, Default)]
pub enum SerializableStopBy {
  #[default]
  Neighbor,
  End,
  Rule(Box<SerializableRule>),
}

impl JsonSchema for SerializableStopBy {
  fn schema_name() -> Cow<'static, str> {
    Cow::Borrowed("SerializableStopBy")
  }

  fn json_schema(_: &mut SchemaGenerator) -> Schema {
    json_schema!({
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [SerializableStopBy::NEIGHBOR_KEY, SerializableStopBy::END_KEY],
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ],
    })
  }
}

impl SerializableStopBy {
  /// String key used for serializing the Neighbor variant
  const NEIGHBOR_KEY: &str = "neighbor";
  /// String key used for serializing the End variant
  const END_KEY: &str = "end";
}

struct StopByVisitor;
impl<'de> Visitor<'de> for StopByVisitor {
  type Value = SerializableStopBy;
  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
    formatter.write_str("`neighbor`, `end` or a rule object")
  }

  fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
  where
    E: de::Error,
  {
    match value {
      SerializableStopBy::NEIGHBOR_KEY => Ok(SerializableStopBy::Neighbor),
      SerializableStopBy::END_KEY => Ok(SerializableStopBy::End),
      v => Err(de::Error::custom(format!(
        "unknown variant `{v}`, expected `{}`, `{}` or a rule object",
        SerializableStopBy::NEIGHBOR_KEY,
        SerializableStopBy::END_KEY,
      ))),
    }
  }

  fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
  where
    A: MapAccess<'de>,
  {
    let rule = Deserialize::deserialize(de::value::MapAccessDeserializer::new(map))?;
    Ok(SerializableStopBy::Rule(rule))
  }
}

impl<'de> Deserialize<'de> for SerializableStopBy {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: Deserializer<'de>,
  {
    deserializer.deserialize_any(StopByVisitor)
  }
}

impl Serialize for SerializableStopBy {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      SerializableStopBy::Neighbor => serializer.serialize_str(SerializableStopBy::NEIGHBOR_KEY),
      SerializableStopBy::End => serializer.serialize_str(SerializableStopBy::END_KEY),
      SerializableStopBy::Rule(rule) => rule.serialize(serializer),
    }
  }
}

pub enum StopBy {
  Neighbor,
  End,
  Rule(Rule),
}

impl StopBy {
  pub(crate) fn try_from<L: Language>(
    relation: SerializableStopBy,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, RuleSerializeError> {
    use SerializableStopBy as S;
    Ok(match relation {
      S::Neighbor => StopBy::Neighbor,
      S::End => StopBy::End,
      S::Rule(r) => StopBy::Rule(env.deserialize_rule(*r)?),
    })
  }

  pub fn defined_vars(&self) -> HashSet<&str> {
    match self {
      StopBy::Rule(rule) => rule.defined_vars(),
      StopBy::End => HashSet::new(),
      StopBy::Neighbor => HashSet::new(),
    }
  }

  pub fn verify_util(&self) -> Result<(), RuleSerializeError> {
    match self {
      StopBy::Rule(rule) => rule.verify_util(),
      StopBy::End => Ok(()),
      StopBy::Neighbor => Ok(()),
    }
  }
}

impl StopBy {
  // TODO: document this monster method
  pub(crate) fn find<'t, O, M, I, F, D>(
    &self,
    once: O,
    multi: M,
    mut finder: F,
  ) -> Option<Node<'t, D>>
  where
    D: Doc,
    I: Iterator<Item = Node<'t, D>>,
    O: FnOnce() -> Option<Node<'t, D>>,
    M: FnOnce() -> I,
    F: FnMut(Node<'t, D>) -> Option<Node<'t, D>>,
  {
    match self {
      StopBy::Neighbor => finder(once()?),
      StopBy::End => {
        let mut iter = multi();
        iter.find_map(finder)
      }
      StopBy::Rule(stop) => {
        let iter = multi();
        iter.take_while(inclusive_until(stop)).find_map(finder)
      }
    }
  }
}

fn inclusive_until<'t, D: Doc>(rule: &Rule) -> impl FnMut(&Node<'t, D>) -> bool + '_ {
  let mut matched = false;
  move |n| {
    if matched {
      false
    } else {
      matched = n.matches(rule);
      true
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::test::TypeScript;

  #[test]
  fn test_relational() {
    let src = r"
inside:
  pattern: class A {}
  stopBy: neighbor
";
    let rule: SerializableRule = from_str(src).expect("cannot parse rule");
    let stop_by = rule.inside.unwrap().stop_by;
    assert!(matches!(stop_by, SerializableStopBy::Neighbor));
  }

  fn to_stop_by(src: &str) -> Result<SerializableStopBy, serde_yaml::Error> {
    from_str(src)
  }

  #[test]
  fn test_stop_by_ok() {
    let stop = to_stop_by("'neighbor'").expect("cannot parse stopBy");
    assert!(matches!(stop, SerializableStopBy::Neighbor));
    let stop = to_stop_by("'end'").expect("cannot parse stopBy");
    assert!(matches!(stop, SerializableStopBy::End));
    let stop = to_stop_by("kind: some-kind").expect("cannot parse stopBy");
    assert!(matches!(stop, SerializableStopBy::Rule(_)));
  }

  macro_rules! cast_err {
    ($reg: expr) => {
      match $reg {
        Err(a) => a,
        _ => panic!("non-matching variant"),
      }
    };
  }

  #[test]
  fn test_stop_by_err() {
    let err = cast_err!(to_stop_by("'ddd'")).to_string();
    assert!(err.contains("unknown variant"));
    assert!(err.contains("ddd"));
    let err = cast_err!(to_stop_by("pattern: 1233"));
    assert!(err.to_string().contains("variant"));
  }

  fn parse_stop_by(src: &str) -> StopBy {
    let stop_by = to_stop_by(src).expect("cannot parse stopBy");
    StopBy::try_from(stop_by, &DeserializeEnv::new(TypeScript::Tsx)).expect("cannot convert")
  }

  #[test]
  fn test_stop_by_no_defined_vars() {
    let stop_by = parse_stop_by("neighbor");
    assert!(stop_by.defined_vars().is_empty());
    let stop_by = parse_stop_by("end");
    assert!(stop_by.defined_vars().is_empty());
  }

  #[test]
  fn test_stop_by_defined_vars() {
    let stop_by = parse_stop_by("kind: class");
    assert_eq!(stop_by.defined_vars(), HashSet::new());
    let stop_by = parse_stop_by("pattern: $A");
    assert_eq!(stop_by.defined_vars(), ["A"].into_iter().collect());
  }

  #[test]
  fn test_serialization_deserialization_symmetry() {
    let stop = to_stop_by("'neighbor'").expect("cannot parse stopBy");
    let serialized = serde_yaml::to_string(&stop).expect("cannot serialize stopBy");
    let deserialized = to_stop_by(&serialized).expect("cannot parse stopBy");
    assert!(matches!(deserialized, SerializableStopBy::Neighbor));

    let stop = to_stop_by("'end'").expect("cannot parse stopBy");
    let serialized = serde_yaml::to_string(&stop).expect("cannot serialize stopBy");
    let deserialized = to_stop_by(&serialized).expect("cannot parse stopBy");
    assert!(matches!(deserialized, SerializableStopBy::End));

    let stop = to_stop_by("kind: some-kind").expect("cannot parse stopBy");
    let serialized = serde_yaml::to_string(&stop).expect("cannot serialize stopBy");
    let deserialized = to_stop_by(&serialized).expect("cannot parse stopBy");
    assert!(matches!(deserialized, SerializableStopBy::Rule(_)));
  }
}



================================================
FILE: crates/config/src/transform/mod.rs
================================================
mod parse;
mod rewrite;
mod string_case;
mod trans;

use crate::{DeserializeEnv, RuleCore};

use ast_grep_core::meta_var::MetaVarEnv;
use ast_grep_core::meta_var::MetaVariable;
use ast_grep_core::Doc;
use ast_grep_core::Language;

use parse::ParseTransError;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use thiserror::Error;

pub use trans::Trans;

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged)]
pub enum Transformation {
  Simplied(String),
  Object(Trans<String>),
}

impl Transformation {
  pub fn parse<L: Language>(&self, lang: &L) -> Result<Trans<MetaVariable>, TransformError> {
    match self {
      Transformation::Simplied(s) => {
        let t: Trans<String> = s.parse()?;
        t.parse(lang)
      }
      Transformation::Object(t) => t.parse(lang),
    }
  }
}

#[derive(Debug, Error)]
pub enum TransformError {
  #[error("Cannot parse transform string.")]
  Parse(#[from] ParseTransError),
  #[error("`{0}` has a cyclic dependency.")]
  Cyclic(String),
  #[error("Transform var `{0}` has already defined.")]
  AlreadyDefined(String),
  #[error("source `{0}` should be $-prefixed.")]
  MalformedVar(String),
}

pub struct Transform {
  transforms: Vec<(String, Trans<MetaVariable>)>,
}

impl Transform {
  pub fn deserialize<L: Language>(
    map: &HashMap<String, Transformation>,
    env: &DeserializeEnv<L>,
  ) -> Result<Self, TransformError> {
    let map: Result<_, _> = map
      .iter()
      .map(|(key, val)| val.parse(&env.lang).map(|t| (key.to_string(), t)))
      .collect();
    let map = map?;
    let order = env
      .get_transform_order(&map)
      .map_err(TransformError::Cyclic)?;
    let transforms = order
      .iter()
      .map(|&key| (key.to_string(), map[key].clone()))
      .collect();
    Ok(Self { transforms })
  }

  pub fn apply_transform<'c, D: Doc>(
    &self,
    env: &mut MetaVarEnv<'c, D>,
    rewriters: &HashMap<String, RuleCore>,
    enclosing_env: &MetaVarEnv<'c, D>,
  ) {
    let mut ctx = Ctx {
      env,
      rewriters,
      enclosing_env,
    };
    for (key, tr) in &self.transforms {
      tr.insert(key, &mut ctx);
    }
  }

  pub(crate) fn keys(&self) -> impl Iterator<Item = &String> {
    self.transforms.iter().map(|t| &t.0)
  }

  pub(crate) fn values(&self) -> impl Iterator<Item = &Trans<MetaVariable>> {
    self.transforms.iter().map(|t| &t.1)
  }
}

// two lifetime to represent env root lifetime and lang/trans lifetime
struct Ctx<'b, 'c, D: Doc> {
  rewriters: &'b HashMap<String, RuleCore>,
  env: &'b mut MetaVarEnv<'c, D>,
  enclosing_env: &'b MetaVarEnv<'c, D>,
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::from_str;
  use crate::test::TypeScript;
  use ast_grep_core::tree_sitter::LanguageExt;

  #[test]
  fn test_transform_str() {}

  #[test]
  fn test_single_cyclic_transform() {
    let mut trans = HashMap::new();
    let trans_a = from_str("substring: {source: $A}").unwrap();
    trans.insert("A".into(), trans_a);
    let env = DeserializeEnv::new(TypeScript::Tsx);
    match Transform::deserialize(&trans, &env) {
      Err(TransformError::Cyclic(a)) => assert_eq!(a, "A"),
      _ => panic!("unexpected error"),
    }
  }

  #[test]
  fn test_cyclic_transform() {
    let mut trans = HashMap::new();
    let trans_a = from_str("substring: {source: $B}").unwrap();
    trans.insert("A".into(), trans_a);
    let trans_b = from_str("substring: {source: $A}").unwrap();
    trans.insert("B".into(), trans_b);
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ret = Transform::deserialize(&trans, &env);
    assert!(matches!(ret, Err(TransformError::Cyclic(_))));
  }

  #[test]
  fn test_transform_use_matched() {
    let mut trans = HashMap::new();
    let trans_a = from_str("substring: {source: $C}").unwrap();
    trans.insert("A".into(), trans_a);
    let trans_b = from_str("substring: {source: $A}").unwrap();
    trans.insert("B".into(), trans_b);
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let ret = Transform::deserialize(&trans, &env);
    assert!(ret.is_ok());
  }

  #[test]
  fn test_transform_indentation() {
    let src = "
if (true) {
  let a = {
    b: 123
  }
}
";
    let expected = "{
  b: 123
}";
    let mut trans = HashMap::new();
    let tr = from_str("{ substring: { source: $A } }").expect("should work");
    trans.insert("TR".into(), tr);
    let grep = TypeScript::Tsx.ast_grep(src);
    let root = grep.root();
    let mut nm = root.find("let a = $A").expect("should find");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let trans = Transform::deserialize(&trans, &env).expect("should deserialize");
    trans.apply_transform(nm.get_env_mut(), &Default::default(), &Default::default());
    let actual = nm.get_env().get_transformed("TR").expect("should have TR");
    let actual = std::str::from_utf8(actual).expect("should work");
    assert_eq!(actual, expected);
  }
}



================================================
FILE: crates/config/src/transform/parse.rs
================================================
use super::rewrite::Rewrite;
use super::trans::{Convert, Replace, Substring};
use super::Trans;
use serde_yaml::from_str as yaml_from_str;
use std::str::FromStr;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ParseTransError {
  #[error("`{0}` has syntax error.")]
  Syntax(String),
  #[error("`{0}` is not a valid transformation.")]
  InvalidTransform(String),
  #[error("`{0}` is not a valid argument.")]
  InvalidArg(String),
  #[error("Argument `{0}` is required.")]
  RequiredArg(&'static str),
  #[error("Invalid argument value.")]
  ArgValue(#[from] serde_yaml::Error),
}

impl FromStr for Trans<String> {
  type Err = ParseTransError;

  fn from_str(s: &str) -> Result<Self, Self::Err> {
    let decomposed = decompose_str(s)?;
    let trans = match decomposed.func {
      "convert" => Trans::Convert(to_convert(decomposed)?),
      "replace" => Trans::Replace(to_replace(decomposed)?),
      "substring" => Trans::Substring(to_substring(decomposed)?),
      "rewrite" => Trans::Rewrite(to_rewrite(decomposed)?),
      invalid => return Err(ParseTransError::InvalidTransform(invalid.to_string())),
    };
    Ok(trans)
  }
}

struct DecomposedTransString<'a> {
  func: &'a str,
  source: &'a str,
  args: Vec<(&'a str, &'a str)>,
}

fn decompose_str(input: &str) -> Result<DecomposedTransString<'_>, ParseTransError> {
  let error = || ParseTransError::Syntax(input.to_string());
  let input = input.trim();
  let (func, rest) = input.split_once('(').ok_or_else(error)?;
  let func = func.trim();
  let rest = rest.trim_end_matches(')');
  let (source, rest) = rest.split_once(',').ok_or_else(error)?;
  let source = source.trim();
  let args = decompose_args(rest.trim()).ok_or_else(error)?;
  Ok(DecomposedTransString { func, source, args })
}

fn decompose_args(mut rest: &str) -> Option<Vec<(&str, &str)>> {
  let mut args = Vec::new();
  while !rest.is_empty() {
    let (key, next) = rest.split_once('=')?;
    let next = next.trim_start();
    let end_index = if next.starts_with(['\'', '"', '[']) {
      let end_char = match next.as_bytes()[0] {
        b'[' => ']',
        b => b as char,
      };
      next[1..].find(end_char)? + 1
    } else {
      next.find(',').unwrap_or(next.len()) - 1
    };
    let (val, next) = next.split_at(end_index + 1);
    // value should not be trimmed
    args.push((key.trim(), val));
    rest = next.trim_start().trim_start_matches(',').trim();
  }
  Some(args)
}

fn to_convert(decomposed: DecomposedTransString) -> Result<Convert<String>, ParseTransError> {
  debug_assert_eq!(decomposed.func, "convert");
  let mut to_case = None;
  let mut separated_by = None;
  for (key, value) in decomposed.args {
    match key {
      "toCase" => to_case = Some(value),
      "separatedBy" => separated_by = Some(value),
      _ => return Err(ParseTransError::InvalidArg(key.to_string())),
    }
  }
  let to_case = to_case.ok_or(ParseTransError::RequiredArg("to_case"))?;
  let to_case = yaml_from_str(to_case)?;
  let separated_by = separated_by.map(yaml_from_str).transpose()?;
  Ok(Convert {
    source: decomposed.source.to_string(),
    to_case,
    separated_by,
  })
}

fn to_replace(decomposed: DecomposedTransString) -> Result<Replace<String>, ParseTransError> {
  debug_assert_eq!(decomposed.func, "replace");
  let mut replace = None;
  let mut by = None;
  for (key, value) in decomposed.args {
    match key {
      "replace" => replace = Some(value),
      "by" => by = Some(value),
      _ => return Err(ParseTransError::InvalidArg(key.to_string())),
    }
  }
  let replace = replace.ok_or(ParseTransError::RequiredArg("replace"))?;
  let by = by.ok_or(ParseTransError::RequiredArg("by"))?;
  Ok(Replace {
    source: decomposed.source.to_string(),
    replace: serde_yaml::from_str(replace)?,
    by: serde_yaml::from_str(by)?,
  })
}
fn to_substring(decomposed: DecomposedTransString) -> Result<Substring<String>, ParseTransError> {
  debug_assert_eq!(decomposed.func, "substring");
  let mut start_char = None;
  let mut end_char = None;
  for (key, value) in decomposed.args {
    match key {
      "startChar" => start_char = Some(value),
      "endChar" => end_char = Some(value),
      _ => return Err(ParseTransError::InvalidArg(key.to_string())),
    }
  }
  let start_char = start_char.map(yaml_from_str).transpose()?;
  let end_char = end_char.map(yaml_from_str).transpose()?;
  Ok(Substring {
    source: decomposed.source.to_string(),
    start_char,
    end_char,
  })
}
fn to_rewrite(decomposed: DecomposedTransString) -> Result<Rewrite<String>, ParseTransError> {
  debug_assert_eq!(decomposed.func, "rewrite");
  let mut rewriters = None;
  let mut join_by = None;
  for (key, value) in decomposed.args {
    match key {
      "rewriters" => rewriters = Some(value),
      "joinBy" => join_by = Some(value),
      _ => return Err(ParseTransError::InvalidArg(key.to_string())),
    }
  }
  let rewriters = rewriters.ok_or(ParseTransError::RequiredArg("rewriters"))?;
  let rewriters = yaml_from_str(rewriters)?;
  Ok(Rewrite {
    source: decomposed.source.to_string(),
    rewriters,
    join_by: join_by.map(yaml_from_str).transpose()?,
  })
}

#[cfg(test)]
mod test {
  use crate::transform::string_case::StringCase;

  use super::*;

  #[test]
  fn test_decompose_str() {
    let input = "substring($A, startChar=1, endChar=2)";
    let decomposed = decompose_str(input).expect("should parse");
    assert_eq!(decomposed.func, "substring");
    assert_eq!(decomposed.source, "$A");
    assert_eq!(decomposed.args.len(), 2);
    assert_eq!(decomposed.args[0], ("startChar", "1"));
    assert_eq!(decomposed.args[1], ("endChar", "2"));
  }
  const SUBSTRING_CASE: &str = "substring($A, startChar=1, endChar=2)";
  const REPLACE_CASE: &str = "replace($A, replace= ^.+, by=', ')";
  const CONVERT_CASE: &str = "convert($A, toCase=camelCase, separatedBy=[underscore, dash])";
  const REWRITE_CASE: &str = "rewrite($A, rewriters=[rule1, rule2], joinBy = ',,,,')";

  #[test]
  fn test_decompose_cases() {
    let cases = [SUBSTRING_CASE, REPLACE_CASE, CONVERT_CASE, REWRITE_CASE];
    for case in cases {
      let decomposed = decompose_str(case).expect("should parse");
      match decomposed.func {
        "convert" => assert_eq!(decomposed.args.len(), 2),
        "replace" => assert_eq!(decomposed.args.len(), 2),
        "substring" => assert_eq!(decomposed.args.len(), 2),
        "rewrite" => assert_eq!(decomposed.args.len(), 2),
        _ => panic!("Unexpected function: {}", decomposed.func),
      }
    }
  }

  #[test]
  fn test_valid_transform() {
    let cases = [
      "convert($A, toCase=camelCase, separatedBy=[])",
      "replace($A, replace= ^.+, by =  '[')",
      "substring(   $A, startChar=1)",
      "substring(  $A,)",
      "rewrite($A, rewriters=[rule1, rule2])",
    ];
    for case in cases {
      Trans::from_str(case).expect("should parse convert");
    }
  }

  #[test]
  fn test_parse_convert() {
    let convert = Trans::from_str(CONVERT_CASE).expect("should parse convert");
    let Trans::Convert(convert) = convert else {
      panic!("Expected Convert transformation");
    };
    assert_eq!(convert.source, "$A");
    assert_eq!(convert.separated_by.map(|v| v.len()), Some(2));
    assert!(matches!(convert.to_case, StringCase::CamelCase));
  }

  #[test]
  fn test_parse_replace() {
    let replace = Trans::from_str(REPLACE_CASE).expect("should parse replace");
    let Trans::Replace(replace) = replace else {
      panic!("Expected Replace transformation");
    };
    assert_eq!(replace.source, "$A");
    assert_eq!(replace.replace, "^.+");
    assert_eq!(replace.by, ", ");
  }

  #[test]
  fn test_parse_substring() {
    let substring = Trans::from_str(SUBSTRING_CASE).expect("should parse substring");
    let Trans::Substring(substring) = substring else {
      panic!("Expected Substring transformation");
    };
    assert_eq!(substring.source, "$A");
    assert_eq!(substring.start_char, Some(1));
    assert_eq!(substring.end_char, Some(2));
  }

  #[test]
  fn test_parse_rewrite() {
    let rewrite = Trans::from_str(REWRITE_CASE).expect("should parse rewrite");
    let Trans::Rewrite(rewrite) = rewrite else {
      panic!("Expected Rewrite transformation");
    };
    assert_eq!(rewrite.source, "$A");
    assert_eq!(
      rewrite.rewriters,
      vec!["rule1".to_owned(), "rule2".to_owned()]
    );
    assert_eq!(rewrite.join_by, Some(",,,,".into()));
  }
}



================================================
FILE: crates/config/src/transform/rewrite.rs
================================================
use super::Ctx;
use super::{trans::parse_meta_var, TransformError};
use crate::rule_core::RuleCore;

use ast_grep_core::meta_var::MetaVariable;
use ast_grep_core::source::{Content, Edit};
use ast_grep_core::{Doc, Language, Node, NodeMatch};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Rewrite<T> {
  pub source: T,
  pub rewriters: Vec<String>,
  // do we need this?
  // sort_by: Option<String>,
  pub join_by: Option<String>,
}

fn get_nodes_from_env<'b, D: Doc>(var: &MetaVariable, ctx: &Ctx<'_, 'b, D>) -> Vec<Node<'b, D>> {
  match var {
    MetaVariable::MultiCapture(n) => ctx.env.get_multiple_matches(n),
    MetaVariable::Capture(m, _) => {
      if let Some(n) = ctx.env.get_match(m) {
        vec![n.clone()]
      } else {
        vec![]
      }
    }
    _ => vec![],
  }
}
impl Rewrite<String> {
  pub fn parse<L: Language>(&self, lang: &L) -> Result<Rewrite<MetaVariable>, TransformError> {
    let source = parse_meta_var(&self.source, lang)?;
    Ok(Rewrite {
      source,
      rewriters: self.rewriters.clone(),
      join_by: self.join_by.clone(),
    })
  }
}

impl Rewrite<MetaVariable> {
  pub(super) fn compute<D: Doc>(&self, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
    let var = &self.source;
    let nodes = get_nodes_from_env(var, ctx);
    if nodes.is_empty() {
      return None;
    }
    let rewriters = ctx.rewriters;
    let start = nodes[0].range().start;
    let bytes = ctx.env.get_var_bytes(var)?;
    let rules: Vec<_> = self
      .rewriters
      .iter()
      .filter_map(|id| rewriters.get(id)) // NOTE: rewriter must be defined
      .collect();
    let edits = find_and_make_edits(nodes, &rules, ctx);
    let rewritten = if let Some(joiner) = &self.join_by {
      let mut ret = vec![];
      let mut edits = edits.into_iter();
      if let Some(first) = edits.next() {
        let mut pos = first.position - start + first.deleted_length;
        ret.extend(first.inserted_text);
        let joiner = D::Source::decode_str(joiner);
        for edit in edits {
          let p = edit.position - start;
          // skip overlapping edits
          if pos > p {
            continue;
          }
          ret.extend_from_slice(&joiner);
          ret.extend(edit.inserted_text);
          pos = p + edit.deleted_length;
        }
        ret
      } else {
        ret
      }
    } else {
      make_edit::<D>(bytes, edits, start)
    };
    Some(D::Source::encode_bytes(&rewritten).to_string())
  }
}

type Bytes<D> = [<<D as Doc>::Source as Content>::Underlying];
fn find_and_make_edits<'n, D: Doc>(
  nodes: Vec<Node<'n, D>>,
  rules: &[&RuleCore],
  ctx: &Ctx<'_, 'n, D>,
) -> Vec<Edit<D::Source>> {
  nodes
    .into_iter()
    .flat_map(|n| replace_one(n, rules, ctx))
    .collect()
}

fn replace_one<'n, D: Doc>(
  node: Node<'n, D>,
  rules: &[&RuleCore],
  ctx: &Ctx<'_, 'n, D>,
) -> Vec<Edit<D::Source>> {
  let mut edits = vec![];
  for child in node.dfs() {
    for rule in rules {
      let mut env = std::borrow::Cow::Borrowed(ctx.enclosing_env);
      // NOTE: we inherit meta_var_env from enclosing rule
      // but match env will NOT inherited recursively!
      // e.g. $B is matched in parent linter and it is inherited.
      // $C is matched in rewriter but is NOT inherited in recursive rewriter
      // this is to enable recursive rewriter to match sub nodes
      // in future, we can use the explict `expose` to control env inheritance
      if let Some(n) = rule.do_match(child.clone(), &mut env, Some(ctx.enclosing_env)) {
        let nm = NodeMatch::new(n, env.into_owned());
        edits.push(nm.make_edit(rule, rule.fixer.first().expect("rewriter must have fix")));
        // stop at first fix, skip duplicate fix
        break;
      }
    }
  }
  edits
}

fn make_edit<D: Doc>(
  old_content: &Bytes<D>,
  edits: Vec<Edit<D::Source>>,
  offset: usize,
) -> Vec<<<D as Doc>::Source as Content>::Underlying> {
  let mut new_content = vec![];
  let mut start = 0;
  for edit in edits {
    let pos = edit.position - offset;
    // skip overlapping edits
    if start > pos {
      continue;
    }
    new_content.extend_from_slice(&old_content[start..pos]);
    new_content.extend_from_slice(&edit.inserted_text);
    start = pos + edit.deleted_length;
  }
  // add trailing statements
  new_content.extend_from_slice(&old_content[start..]);
  new_content
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::check_var::CheckHint;
  use crate::from_str;
  use crate::rule::referent_rule::RuleRegistration;
  use crate::rule::DeserializeEnv;
  use crate::rule_core::SerializableRuleCore;
  use crate::test::TypeScript;
  use std::collections::HashSet;

  fn apply_transformation(
    rewrite: Rewrite<String>,
    src: &str,
    pat: &str,
    rewriters: RuleRegistration,
  ) -> String {
    compute_rewritten(src, pat, rewrite, rewriters).expect("should have transforms")
  }

  macro_rules! str_vec {
    ( $($a: expr),* ) => { vec![ $($a.to_string()),* ] };
  }

  fn make_rewriters(pairs: &[(&str, &str)]) -> RuleRegistration {
    make_rewriter_reg(pairs, Default::default())
  }

  fn make_rewriter_reg(pairs: &[(&str, &str)], vars: HashSet<&str>) -> RuleRegistration {
    let env = DeserializeEnv::new(TypeScript::Tsx);
    for (key, ser) in pairs {
      let serialized: SerializableRuleCore = from_str(ser).unwrap();
      let rule = serialized
        .get_matcher_with_hint(env.clone(), CheckHint::Rewriter(&vars))
        .unwrap();
      env.registration.insert_rewriter(key, rule);
    }
    env.registration
  }

  #[test]
  fn test_perform_one_rewrite() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["rewrite"],
      join_by: None,
    };
    let rewriters = make_rewriters(&[("rewrite", "{rule: {kind: number}, fix: '810'}")]);
    let ret = apply_transformation(rewrite, "log(t(1, 2, 3))", "log($A)", rewriters);
    assert_eq!(ret, "t(810, 810, 810)");
  }

  #[test]
  fn test_perform_multiple_rewriters() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re1", "re2"],
      join_by: None,
    };
    let reg = make_rewriters(&[
      ("re1", "{rule: {regex: '^1$'}, fix: '810'}"),
      ("re2", "{rule: {regex: '^2$'}, fix: '1919'}"),
    ]);
    let ret = apply_transformation(rewrite, "log(t(1, 2, 3))", "log($A)", reg);
    assert_eq!(ret, "t(810, 1919, 3)");
  }

  #[test]
  fn test_ignore_unused_rewriters() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re1"],
      join_by: None,
    };
    let reg = make_rewriters(&[
      ("ignored", "{rule: {regex: '^2$'}, fix: '1919'}"),
      ("re1", "{rule: {kind: number}, fix: '810'}"),
    ]);
    let ret = apply_transformation(rewrite, "log(t(1, 2, 3))", "log($A)", reg);
    assert_eq!(ret, "t(810, 810, 810)");
  }

  #[test]
  fn test_rewriters_order() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re2", "re1"],
      join_by: None,
    };
    // first match wins the rewrite
    let reg = make_rewriters(&[
      ("re2", "{rule: {regex: '^2$'}, fix: '1919'}"),
      ("re1", "{rule: {kind: number}, fix: '810'}"),
    ]);
    let ret = apply_transformation(rewrite, "log(t(1, 2, 3))", "log($A)", reg);
    assert_eq!(ret, "t(810, 1919, 810)");
  }

  #[test]
  fn test_rewriters_overlapping() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re1", "re2"],
      join_by: None,
    };
    // parent node wins fix, even if rule comes later
    let reg = make_rewriters(&[
      ("re1", "{rule: {kind: number}, fix: '810'}"),
      ("re2", "{rule: {kind: array}, fix: '1919'}"),
    ]);
    let ret = apply_transformation(rewrite, "[1, 2, 3]", "$A", reg);
    assert_eq!(ret, "1919");
  }

  #[test]
  fn test_rewriters_join_by() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re1"],
      join_by: Some(" + ".into()),
    };
    let reg = make_rewriters(&[("re1", "{rule: {kind: number}, fix: '810'}")]);
    let ret = apply_transformation(rewrite, "log(t(1, 2, 3))", "log($A)", reg);
    assert_eq!(ret, "810 + 810 + 810");
  }

  #[test]
  fn test_recursive_rewriters() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re1"],
      join_by: None,
    };
    let rule = r#"
rule: {pattern: '[$$$C]'}
transform:
  D:
    rewrite:
      source: $$$C
      rewriters: [re1]
fix: $D
    "#;
    let reg = make_rewriters(&[("re1", rule)]);
    let ret = apply_transformation(rewrite, "[1, [2, [3, [4]]]]", "$A", reg);
    assert_eq!(ret, "1, 2, 3, 4");
  }

  #[test]
  fn test_should_inherit_match_env() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re"],
      join_by: None,
    };
    let reg = make_rewriters(&[("re", "{rule: {pattern: $C}, fix: '123'}")]);
    let ret = apply_transformation(rewrite.clone(), "[1, 2]", "[$A, $B]", reg.clone());
    assert_eq!(ret, "123");
    let ret = apply_transformation(rewrite.clone(), "[1, 1]", "[$A, $C]", reg.clone());
    assert_eq!(ret, "123");
    // should not match $C so no rewrite
    let ret = apply_transformation(rewrite, "[1, 2]", "[$A, $C]", reg);
    assert_eq!(ret, "1");
  }

  #[test]
  fn test_node_not_found() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re"],
      join_by: None,
    };
    let rewriters = make_rewriters(&[("re", "{rule: {pattern: $B}, fix: '123'}")]);
    let ret = compute_rewritten("[1, 2]", "[$B, $C]", rewrite, rewriters);
    assert_eq!(ret, None);
  }

  #[test]
  fn test_rewrite_use_enclosing_env() {
    let rewrite = Rewrite {
      source: "$A".into(),
      rewriters: str_vec!["re"],
      join_by: None,
    };
    let mut vars = HashSet::new();
    vars.insert("C");
    let reg = make_rewriter_reg(&[("re", "{rule: {pattern: $B}, fix: '$B == $C'}")], vars);
    let ret = apply_transformation(rewrite, "[1, 2]", "[$A, $C]", reg);
    assert_eq!(ret, "1 == 2");
  }

  fn compute_rewritten(
    src: &str,
    pat: &str,
    rewrite: Rewrite<String>,
    reg: RuleRegistration,
  ) -> Option<String> {
    use ast_grep_core::tree_sitter::LanguageExt;
    let grep = TypeScript::Tsx.ast_grep(src);
    let root = grep.root();
    let mut nm = root.find(pat).expect("should find");
    let before_vars: Vec<_> = nm.get_env().get_matched_variables().collect();
    let env = nm.get_env_mut();
    let enclosing = env.clone();
    let rewriters = reg.get_rewriters();
    let mut ctx = Ctx {
      env,
      rewriters,
      enclosing_env: &enclosing,
    };
    let after_vars: Vec<_> = ctx.env.get_matched_variables().collect();
    assert_eq!(
      before_vars, after_vars,
      "rewrite should not write back to env"
    );
    rewrite.parse(&TypeScript::Tsx).ok()?.compute(&mut ctx)
  }
}



================================================
FILE: crates/config/src/transform/string_case.rs
================================================
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::ops::Range;

fn capitalize(string: &str) -> String {
  let mut chars = string.chars();
  if let Some(c) = chars.next() {
    c.to_uppercase().chain(chars).collect()
  } else {
    string.to_string()
  }
}

/// An enumeration representing different cases for strings.
#[derive(Serialize, Deserialize, Clone, Copy, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub enum StringCase {
  LowerCase,
  UpperCase,
  Capitalize,
  CamelCase,
  SnakeCase,
  KebabCase,
  PascalCase,
}

use StringCase::*;

impl StringCase {
  pub fn apply(&self, s: &str, seps: Option<&[Separator]>) -> String {
    match &self {
      LowerCase => s.to_lowercase(),
      UpperCase => s.to_uppercase(),
      Capitalize => capitalize(s),
      CamelCase => join_camel_case(split(s, seps)),
      SnakeCase => join(split(s, seps), '_'),
      KebabCase => join(split(s, seps), '-'),
      PascalCase => split(s, seps).map(capitalize).collect(),
    }
  }
}

#[derive(Serialize, Deserialize, Clone, Copy, JsonSchema)]
#[serde(rename_all = "camelCase")]
/// Separator to split string. e.g. `user_accountName` -> `user`, `accountName`
/// It will be rejoin according to `StringCase`.
pub enum Separator {
  CaseChange,
  Dash,
  Dot,
  Slash,
  Space,
  Underscore,
}

impl From<&[Separator]> for Delimiter {
  fn from(value: &[Separator]) -> Self {
    use Separator::*;
    let mut delimiter = vec![];
    let mut state = CaseState::IgnoreCase;
    value.iter().for_each(|v| match v {
      CaseChange => state = CaseState::Lower,
      Dash => delimiter.push('-'),
      Dot => delimiter.push('.'),
      Slash => delimiter.push('/'),
      Space => delimiter.push(' '),
      Underscore => delimiter.push('_'),
    });
    Self {
      left: 0,
      right: 0,
      state,
      delimiter,
    }
  }
}

#[derive(PartialEq, Eq)]
/// CaseState is used to record the case change between two characters.
/// It will be used if separator is CaseChange.
enum CaseState {
  Lower,
  OneUpper,
  /// MultiUpper records consecutive uppercase characters.
  /// char is the last uppercase char, used to calculate the split range.
  MultiUpper(char),
  IgnoreCase,
}

struct Delimiter {
  left: usize,
  right: usize,
  state: CaseState,
  delimiter: Vec<char>,
}
impl Delimiter {
  fn all() -> Delimiter {
    Delimiter {
      left: 0,
      right: 0,
      state: CaseState::Lower,
      delimiter: vec!['-', '.', '/', ' ', '_'],
    }
  }
  fn delimit(&mut self, c: char) -> Option<Range<usize>> {
    let Self {
      left,
      right,
      state,
      delimiter,
    } = self;
    use CaseState::*;
    // normal delimiter
    if delimiter.contains(&c) {
      let range = *left..*right;
      *left = *right + 1;
      *right = *left;
      if *state != IgnoreCase {
        self.state = Lower;
      }
      return Some(range);
    }
    // case delimiter, from lowercase to uppercase
    if *state == Lower && c.is_uppercase() {
      let range = *left..*right;
      *left = *right;
      *right = *left + c.len_utf8();
      self.state = OneUpper;
      return Some(range);
    }
    // case 2, consecutive UpperCases followed by lowercase
    // e.g. XMLHttp -> XML Http
    if let MultiUpper(last_char) = state {
      if c.is_lowercase() {
        let new_left = *right - last_char.len_utf8();
        let range = *left..new_left;
        *left = new_left;
        *right += c.len_utf8();
        self.state = Lower;
        return Some(range);
      }
    }
    *right += c.len_utf8();
    if *state == CaseState::IgnoreCase {
      return None;
    } else if c.is_lowercase() {
      self.state = Lower;
    } else if *state == Lower {
      self.state = OneUpper;
    } else {
      self.state = MultiUpper(c);
    }
    None
  }
  fn conclude(&mut self, len: usize) -> Option<Range<usize>> {
    let Self { left, right, .. } = self;
    if left < right && *right <= len {
      let range = *left..*right;
      *left = *right;
      Some(range)
    } else {
      None
    }
  }
}

/**
  Split string by Separator
*/
fn split<'a>(s: &'a str, seps: Option<&[Separator]>) -> impl Iterator<Item = &'a str> {
  let mut chars = s.chars();
  let mut delimiter = if let Some(seps) = seps {
    Delimiter::from(seps)
  } else {
    Delimiter::all()
  };
  std::iter::from_fn(move || {
    for c in chars.by_ref() {
      if let Some(range) = delimiter.delimit(c) {
        if range.start != range.end {
          return Some(&s[range]);
        }
      }
    }
    let range = delimiter.conclude(s.len())?;
    if range.start != range.end {
      Some(&s[range])
    } else {
      None
    }
  })
}

fn join<'a, I>(mut words: I, sep: char) -> String
where
  I: Iterator<Item = &'a str>,
{
  let mut result = String::new();
  if let Some(w) = words.next() {
    result.push_str(&w.to_lowercase());
  }
  for w in words {
    result.push(sep);
    result.push_str(&w.to_lowercase());
  }
  result
}

fn join_camel_case<'a, I>(words: I) -> String
where
  I: Iterator<Item = &'a str>,
{
  let mut result = String::new();
  for (i, word) in words.enumerate() {
    if i == 0 {
      result.push_str(&word.to_lowercase());
    } else {
      result.push_str(&capitalize(word));
    }
  }
  result
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_case_conversions() {
    assert_eq!(StringCase::LowerCase.apply("aBc", None), "abc");
    assert_eq!(StringCase::UpperCase.apply("aBc", None), "ABC");
    assert_eq!(StringCase::Capitalize.apply("aBc", None), "ABc");
  }
  const CAMEL: &str = "camelsLiveInTheDesert";
  const SNAKE: &str = "snakes_live_in_forests";
  const KEBAB: &str = "kebab-is-a-delicious-food";
  const PASCAL: &str = "PascalIsACoolGuy";
  const PATH: &str = "path/is/a/slashed/string";
  const DOT: &str = "www.dot.com";
  const URL: &str = "x.com/hd_nvim";

  fn assert_split(s: &str, v: &[&str]) {
    let actual: Vec<_> = split(s, None).collect();
    assert_eq!(v, actual)
  }

  #[test]
  fn test_split() {
    assert_split(CAMEL, &["camels", "Live", "In", "The", "Desert"]);
    assert_split(SNAKE, &["snakes", "live", "in", "forests"]);
    assert_split(KEBAB, &["kebab", "is", "a", "delicious", "food"]);
    assert_split(PASCAL, &["Pascal", "Is", "A", "Cool", "Guy"]);
    assert_split(PATH, &["path", "is", "a", "slashed", "string"]);
    assert_split(DOT, &["www", "dot", "com"]);
    assert_split(URL, &["x", "com", "hd", "nvim"]);
    assert_split("XMLHttpRequest", &["XML", "Http", "Request"]);
    assert_split("whatHTML", &["what", "HTML"]);
  }

  fn assert_split_sep(s: &str, seps: &[Separator], v: &[&str]) {
    let actual: Vec<_> = split(s, Some(seps)).collect();
    assert_eq!(v, actual)
  }

  #[test]
  fn test_split_by_separator() {
    use Separator::*;
    assert_split_sep("user_accountName", &[Underscore], &["user", "accountName"]);
    assert_split_sep("user_accountName", &[Space], &["user_accountName"]);
    assert_split_sep("user_accountName", &[CaseChange], &["user_account", "Name"]);
  }

  fn assert_format(fmt: StringCase, src: &str, expected: &str) {
    assert_eq!(fmt.apply(src, None), expected)
  }

  #[test]
  fn test_format() {
    assert_format(SnakeCase, CAMEL, "camels_live_in_the_desert");
    assert_format(KebabCase, CAMEL, "camels-live-in-the-desert");
    assert_format(PascalCase, KEBAB, "KebabIsADeliciousFood");
    assert_format(PascalCase, SNAKE, "SnakesLiveInForests");
  }
}



================================================
FILE: crates/config/src/transform/trans.rs
================================================
use super::rewrite::Rewrite;
use super::{string_case, Ctx, TransformError};
use ast_grep_core::meta_var::MetaVariable;
use ast_grep_core::source::Content;
use ast_grep_core::{Doc, Language};

use regex::Regex;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use string_case::{Separator, StringCase};

fn get_text_from_env<D: Doc>(var: &MetaVariable, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
  // TODO: check if topological sort has resolved transform dependency
  let bytes = ctx.env.get_var_bytes(var)?;
  Some(<D::Source as Content>::encode_bytes(bytes).into_owned())
}

/// Extracts a substring from the meta variable's text content.
///
/// Both `start_char` and `end_char` support negative indexing,
/// which counts character from the end of an array, moving backwards.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Substring<T> {
  /// source meta variable to be transformed
  pub source: T,
  /// optional starting character index of the substring, defaults to 0.
  pub start_char: Option<i32>,
  /// optional ending character index of the substring, defaults to the end of the string.
  pub end_char: Option<i32>,
}

impl Substring<MetaVariable> {
  fn compute<D: Doc>(&self, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
    let text = get_text_from_env(&self.source, ctx)?;
    let chars: Vec<_> = text.chars().collect();
    let len = chars.len() as i32;
    let start = resolve_char(&self.start_char, 0, len);
    let end = resolve_char(&self.end_char, len, len);
    if start > end || start >= len as usize || end > len as usize {
      return Some(String::new());
    }
    Some(chars[start..end].iter().collect())
  }
}

/// resolve relative negative char index to absolute index
/// e.g. -1 => len - 1, n > len => n
fn resolve_char(opt: &Option<i32>, dft: i32, len: i32) -> usize {
  let c = *opt.as_ref().unwrap_or(&dft);
  if c >= len {
    len as usize
  } else if c >= 0 {
    c as usize
  } else if len + c < 0 {
    0
  } else {
    debug_assert!(c < 0);
    (len + c) as usize
  }
}

/// Replaces a substring in the meta variable's text content with another string.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Replace<T> {
  /// source meta variable to be transformed
  pub source: T,
  /// a regex to find substring to be replaced
  pub replace: String,
  /// the replacement string
  pub by: String,
}
impl Replace<MetaVariable> {
  fn compute<D: Doc>(&self, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
    let text = get_text_from_env(&self.source, ctx)?;
    let re = Regex::new(&self.replace).unwrap();
    Some(re.replace_all(&text, &self.by).into_owned())
  }
}

/// Converts the source meta variable's text content to a specified case format.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Convert<T> {
  /// source meta variable to be transformed
  pub source: T,
  /// the target case format to convert the text content to
  pub to_case: StringCase,
  /// optional separators to specify how to separate word
  pub separated_by: Option<Vec<Separator>>,
}

impl Convert<MetaVariable> {
  fn compute<D: Doc>(&self, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
    let text = get_text_from_env(&self.source, ctx)?;
    Some(self.to_case.apply(&text, self.separated_by.as_deref()))
  }
}

/// Represents a transformation that can be applied to a matched AST node.
/// Available transformations are `substring`, `replace` and `convert`.
#[derive(Serialize, Deserialize, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub enum Trans<T> {
  Substring(Substring<T>),
  Replace(Replace<T>),
  Convert(Convert<T>),
  Rewrite(Rewrite<T>),
}

impl<T> Trans<T> {
  fn source(&self) -> &T {
    use Trans as T;
    match self {
      T::Replace(r) => &r.source,
      T::Substring(s) => &s.source,
      T::Convert(c) => &c.source,
      T::Rewrite(r) => &r.source,
    }
  }
}

pub(crate) fn parse_meta_var<L: Language>(
  src: &str,
  lang: &L,
) -> Result<MetaVariable, TransformError> {
  let source = lang.pre_process_pattern(src);
  if let Some(var) = lang.extract_meta_var(&source) {
    Ok(var)
  } else {
    Err(TransformError::MalformedVar(src.to_string()))
  }
}

impl Trans<String> {
  pub fn parse<L: Language>(&self, lang: &L) -> Result<Trans<MetaVariable>, TransformError> {
    use Trans as T;
    Ok(match self {
      T::Replace(r) => T::Replace(Replace {
        source: parse_meta_var(&r.source, lang)?,
        replace: r.replace.clone(),
        by: r.by.clone(),
      }),
      T::Substring(s) => T::Substring(Substring {
        source: parse_meta_var(&s.source, lang)?,
        start_char: s.start_char,
        end_char: s.end_char,
      }),
      T::Convert(c) => T::Convert(Convert {
        source: parse_meta_var(&c.source, lang)?,
        to_case: c.to_case,
        separated_by: c.separated_by.clone(),
      }),
      T::Rewrite(r) => T::Rewrite(r.parse(lang)?),
    })
  }
}
impl Trans<MetaVariable> {
  pub(super) fn insert<D: Doc>(&self, key: &str, ctx: &mut Ctx<'_, '_, D>) {
    let src = self.source();
    // TODO: add this debug assertion back
    // debug_assert!(ctx.env.get_transformed(key).is_none());
    // avoid cyclic
    ctx.env.insert_transformation(src, key, vec![]);
    let opt = self.compute(ctx);
    let bytes = if let Some(s) = opt {
      <D::Source as Content>::decode_str(&s).to_vec()
    } else {
      vec![]
    };
    ctx.env.insert_transformation(src, key, bytes);
  }
  fn compute<D: Doc>(&self, ctx: &mut Ctx<'_, '_, D>) -> Option<String> {
    use Trans as T;
    match self {
      T::Replace(r) => r.compute(ctx),
      T::Substring(s) => s.compute(ctx),
      T::Convert(c) => c.compute(ctx),
      T::Rewrite(r) => r.compute(ctx),
    }
  }

  pub fn used_rewriters(&self) -> &[String] {
    use Trans as T;
    match self {
      T::Replace(_) => &[],
      T::Substring(_) => &[],
      T::Convert(_) => &[],
      T::Rewrite(r) => &r.rewriters,
    }
  }
  pub fn used_vars(&self) -> &str {
    let s = self.source();
    use MetaVariable as MV;
    match s {
      MV::Capture(v, _) => v,
      MV::MultiCapture(v) => v,
      MV::Dropped(_) | MV::Multiple => panic!("transform var must be named"),
    }
  }
}

#[cfg(test)]
mod test {
  use super::super::Transform;
  use super::*;
  use crate::test::TypeScript;
  use crate::{DeserializeEnv, Transformation};
  use ast_grep_core::tree_sitter::LanguageExt;
  use serde_yaml::with::singleton_map_recursive;
  use std::collections::HashMap;

  type R = std::result::Result<(), ()>;

  fn get_transformed(src: &str, pat: &str, trans: &Trans<String>) -> Option<String> {
    let grep = TypeScript::Tsx.ast_grep(src);
    let root = grep.root();
    let mut nm = root.find(pat).expect("should find");
    let mut ctx = Ctx {
      env: nm.get_env_mut(),
      rewriters: &Default::default(),
      enclosing_env: &Default::default(),
    };
    trans.parse(&TypeScript::Tsx).ok()?.compute(&mut ctx)
  }

  fn parse(trans: &str) -> Result<Trans<String>, ()> {
    let deserializer = serde_yaml::Deserializer::from_str(trans);
    singleton_map_recursive::deserialize(deserializer).map_err(|_| ())
  }

  #[test]
  fn test_transform_parse_error() {
    let str_trans = parse(r#"substring: { source: WRONG }"#).expect("should work");
    match str_trans.parse(&TypeScript::Tsx) {
      Err(TransformError::MalformedVar(n)) => assert_eq!(n, "WRONG"),
      _ => panic!("should be malformed var"),
    }
  }

  #[test]
  fn test_simple_replace() -> R {
    let trans = parse(
      r#"
      substring:
        source: "$A"
        startChar: 1
        endChar: -1
    "#,
    )?;
    let actual = get_transformed("let a = 123", "let a= $A", &trans).ok_or(())?;
    assert_eq!(actual, "2");
    Ok(())
  }

  #[test]
  fn test_no_end_char() -> R {
    let trans = parse(
      r#"
      substring:
        source: "$A"
        startChar: 1
    "#,
    )?;
    let actual = get_transformed("let a = 123", "let a= $A", &trans).ok_or(())?;
    assert_eq!(actual, "23");
    Ok(())
  }
  #[test]
  fn test_no_start_char() -> R {
    let trans = parse(
      r#"
      substring:
        source: "$A"
        endChar: -1
    "#,
    )?;
    let actual = get_transformed("let a = 123", "let a= $A", &trans).ok_or(())?;
    assert_eq!(actual, "12");
    Ok(())
  }

  #[test]
  fn test_replace() -> R {
    let trans = parse(
      r#"
      replace:
        source: "$A"
        replace: \d
        by: "b"
    "#,
    )?;
    let actual = get_transformed("let a = 123", "let a= $A", &trans).ok_or(())?;
    assert_eq!(actual, "bbb");
    Ok(())
  }

  #[test]
  fn test_wrong_rule() {
    let parsed = parse(
      r#"
      replace:
        source: "$A"
    "#,
    );
    assert!(parsed.is_err());
  }

  fn transform_env(trans: HashMap<String, Trans<String>>) -> HashMap<String, String> {
    let grep = TypeScript::Tsx.ast_grep("let a = 123");
    let root = grep.root();
    let trans = trans
      .into_iter()
      .map(|(k, v)| (k, Transformation::Object(v)))
      .collect();
    let mut nm = root.find("let a = $A").expect("should find");
    let env = DeserializeEnv::new(TypeScript::Tsx);
    let trans = Transform::deserialize(&trans, &env).expect("should deserialize");
    trans.apply_transform(nm.get_env_mut(), &Default::default(), &Default::default());
    nm.get_env().clone().into()
  }

  #[test]
  fn test_insert_env() -> R {
    let tr1 = parse(
      r#"
      replace:
        source: "$A"
        replace: \d
        by: "b"
    "#,
    )?;
    let tr2 = parse(
      r#"
      substring:
        source: "$A"
        startChar: 1
        endChar: -1
    "#,
    )?;
    let mut map = HashMap::new();
    map.insert("TR1".into(), tr1);
    map.insert("TR2".into(), tr2);
    let env = transform_env(map);
    assert_eq!(env["TR1"], "bbb");
    assert_eq!(env["TR2"], "2");
    Ok(())
  }

  #[test]
  fn test_dependent_trans() -> R {
    let rep = parse(
      r#"
      replace:
        source: "$A"
        replace: \d
        by: "b"
    "#,
    )?;
    let sub = parse(
      r#"
      substring:
        source: "$REP"
        startChar: 1
        endChar: -1
    "#,
    )?;
    let up = parse(
      r#"
      convert:
        source: "$SUB"
        toCase: upperCase
    "#,
    )?;
    let mut map = HashMap::new();
    map.insert("REP".into(), rep);
    map.insert("SUB".into(), sub);
    map.insert("UP".into(), up);
    let env = transform_env(map);
    assert_eq!(env["REP"], "bbb");
    assert_eq!(env["SUB"], "b");
    assert_eq!(env["UP"], "B");
    Ok(())
  }

  #[test]
  fn test_uppercase_convert() -> R {
    let trans = parse(
      r#"
      convert:
        source: "$A"
        toCase: upperCase
    "#,
    )?;
    let actual = get_transformed("let a = real_quiet_now", "let a = $A", &trans).ok_or(())?;
    assert_eq!(actual, "REAL_QUIET_NOW");
    Ok(())
  }

  #[test]
  fn test_capitalize_convert() -> R {
    let trans = parse(
      r#"
      convert:
        source: "$A"
        toCase: capitalize
    "#,
    )?;
    let actual = get_transformed("let a = snugglebunny", "let a = $A", &trans).ok_or(())?;
    assert_eq!(actual, "Snugglebunny");
    Ok(())
  }

  #[test]
  fn test_lowercase_convert() -> R {
    let trans = parse(
      r#"
      convert:
        source: "$A"
        toCase: lowerCase
    "#,
    )?;
    let actual = get_transformed("let a = SCREAMS", "let a = $A", &trans).ok_or(())?;
    assert_eq!(actual, "screams");
    Ok(())
  }

  #[test]
  fn test_separation_convert() -> R {
    let trans = parse(
      r#"
      convert:
        source: "$A"
        toCase: snakeCase
        separatedBy: [underscore]
    "#,
    )?;
    let actual = get_transformed("let a = camelCase_Not", "let a = $A", &trans).ok_or(())?;
    assert_eq!(actual, "camelcase_not");
    Ok(())
  }

  #[test]
  fn test_transform_indentation_with_insertion() -> R {
    let src = "
if (true) {
  let a = {
    b: 123
  }
}
";
    // note the indentation
    let expected = "{
    b: 123
  }";
    let tr = parse("{ substring: { source: $A } }")?;
    let actual = get_transformed(src, "let a = $A", &tr).ok_or(())?;
    assert_eq!(actual, expected);
    Ok(())
  }

  // TODO: add a symbolic test for Rewrite
}



================================================
FILE: crates/core/Cargo.toml
================================================
[package]
name = "ast-grep-core"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]
categories = ["command-line-utilities", "development-tools", "parsing"]

authors.workspace = true
documentation.workspace = true
edition.workspace = true
homepage.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true

[dependencies]
bit-set.workspace = true
regex.workspace = true
thiserror.workspace = true
tree-sitter = { workspace = true, optional = true }

[features]
default = ["tree-sitter"]

[dev-dependencies]
tree-sitter-typescript = "0.23.2"


================================================
FILE: crates/core/src/language.rs
================================================
use crate::matcher::PatternBuilder;
use crate::meta_var::{extract_meta_var, MetaVariable};
use crate::{Pattern, PatternError};
use std::borrow::Cow;
use std::path::Path;

/// Trait to abstract ts-language usage in ast-grep, which includes:
/// * which character is used for meta variable.
/// * if we need to use other char in meta var for parser at runtime
/// * pre process the Pattern code.
pub trait Language: Clone + 'static {
  /// normalize pattern code before matching
  /// e.g. remove expression_statement, or prefer parsing {} to object over block
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    Cow::Borrowed(query)
  }

  /// Configure meta variable special character
  /// By default $ is the metavar char, but in PHP it can be #
  #[inline]
  fn meta_var_char(&self) -> char {
    '$'
  }

  /// Some language does not accept $ as the leading char for identifiers.
  /// We need to change $ to other char at run-time to make parser happy, thus the name expando.
  /// By default this is the same as meta_var char so replacement is done at runtime.
  #[inline]
  fn expando_char(&self) -> char {
    self.meta_var_char()
  }

  /// extract MetaVariable from a given source string
  /// At runtime we need to use expand_char
  fn extract_meta_var(&self, source: &str) -> Option<MetaVariable> {
    extract_meta_var(source, self.expando_char())
  }
  /// Return the file language from path. Return None if the file type is not supported.
  fn from_path<P: AsRef<Path>>(_path: P) -> Option<Self> {
    // TODO: throw panic here if not implemented properly?
    None
  }

  fn kind_to_id(&self, kind: &str) -> u16;
  fn field_to_id(&self, field: &str) -> Option<u16>;
  fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError>;
}

#[cfg(test)]
pub use test::*;

#[cfg(test)]
mod test {
  use super::*;
  use crate::tree_sitter::{LanguageExt, StrDoc, TSLanguage};

  #[derive(Clone)]
  pub struct Tsx;
  impl Language for Tsx {
    fn kind_to_id(&self, kind: &str) -> u16 {
      let ts_lang: TSLanguage = tree_sitter_typescript::LANGUAGE_TSX.into();
      ts_lang.id_for_node_kind(kind, /* named */ true)
    }
    fn field_to_id(&self, field: &str) -> Option<u16> {
      self
        .get_ts_language()
        .field_id_for_name(field)
        .map(|f| f.get())
    }
    fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
      builder.build(|src| StrDoc::try_new(src, self.clone()))
    }
  }
  impl LanguageExt for Tsx {
    fn get_ts_language(&self) -> TSLanguage {
      tree_sitter_typescript::LANGUAGE_TSX.into()
    }
  }
}



================================================
FILE: crates/core/src/lib.rs
================================================
/*!
This module contains the core library for ast-grep.

It provides APIs for parsing, traversing, searching and replacing tree-sitter nodes.
Usually you will only need ast-grep CLI instead of this crate.
But if you want to use ast-grep as a library, this is the right place.
*/

pub mod language;
pub mod matcher;
pub mod meta_var;
pub mod ops;
pub mod replacer;
pub mod source;
#[cfg(feature = "tree-sitter")]
pub mod tree_sitter;

#[doc(hidden)]
pub mod pinned;

mod match_tree;
mod node;

pub use language::Language;
pub use match_tree::MatchStrictness;
pub use matcher::{Matcher, NodeMatch, Pattern, PatternError};
pub use node::{Node, Position};
pub use source::Doc;

use node::Root;

pub type AstGrep<D> = Root<D>;

#[cfg(test)]
mod test {
  use super::*;
  use crate::tree_sitter::LanguageExt;
  use language::Tsx;
  use ops::Op;

  pub type Result = std::result::Result<(), String>;

  #[test]
  fn test_replace() -> Result {
    let mut ast_grep = Tsx.ast_grep("var a = 1; let b = 2;");
    ast_grep.replace("var $A = $B", "let $A = $B")?;
    let source = ast_grep.generate();
    assert_eq!(source, "let a = 1; let b = 2;"); // note the semicolon
    Ok(())
  }

  #[test]
  fn test_replace_by_rule() -> Result {
    let rule = Op::either("let a = 123").or("let b = 456");
    let mut ast_grep = Tsx.ast_grep("let a = 123");
    let replaced = ast_grep.replace(rule, "console.log('it works!')")?;
    assert!(replaced);
    let source = ast_grep.generate();
    assert_eq!(source, "console.log('it works!')");
    Ok(())
  }

  #[test]
  fn test_replace_unnamed_node() -> Result {
    // ++ and -- is unnamed node in tree-sitter javascript
    let mut ast_grep = Tsx.ast_grep("c++");
    ast_grep.replace("$A++", "$A--")?;
    let source = ast_grep.generate();
    assert_eq!(source, "c--");
    Ok(())
  }

  #[test]
  fn test_replace_trivia() -> Result {
    let mut ast_grep = Tsx.ast_grep("var a = 1 /*haha*/;");
    ast_grep.replace("var $A = $B", "let $A = $B")?;
    let source = ast_grep.generate();
    assert_eq!(source, "let a = 1 /*haha*/;"); // semicolon

    let mut ast_grep = Tsx.ast_grep("var a = 1; /*haha*/");
    ast_grep.replace("var $A = $B", "let $A = $B")?;
    let source = ast_grep.generate();
    assert_eq!(source, "let a = 1; /*haha*/");
    Ok(())
  }

  #[test]
  fn test_replace_trivia_with_skipped() -> Result {
    let mut ast_grep = Tsx.ast_grep("return foo(1, 2,) /*haha*/;");
    ast_grep.replace("return foo($A, $B)", "return bar($A, $B)")?;
    let source = ast_grep.generate();
    assert_eq!(source, "return bar(1, 2) /*haha*/;"); // semicolon
    Ok(())
  }
}



================================================
FILE: crates/core/src/matcher.rs
================================================
//! This module defines the core `Matcher` trait in ast-grep.
//!
//! `Matcher` has three notable implementations in this module:
//! * Pattern: matches against a tree-sitter node based on its tree structure.
//! * KindMatcher: matches a node based on its `kind`
//! * RegexMatcher: matches a node based on its textual content using regex.

mod kind;
mod node_match;
mod pattern;
mod text;

use crate::Doc;
use crate::{meta_var::MetaVarEnv, Node};

use bit_set::BitSet;
use std::borrow::Cow;

pub use kind::{kind_utils, KindMatcher, KindMatcherError};
pub use node_match::NodeMatch;
pub use pattern::{Pattern, PatternBuilder, PatternError, PatternNode};
pub use text::{RegexMatcher, RegexMatcherError};

/// `Matcher` defines whether a tree-sitter node matches certain pattern,
/// and update the matched meta-variable values in `MetaVarEnv`.
/// N.B. At least one positive term is required for matching
pub trait Matcher {
  /// Returns the node why the input is matched or None if not matched.
  /// The return value is usually input node itself, but it can be different node.
  /// For example `Has` matcher can return the child or descendant node.
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    _node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>>;

  /// Returns a bitset for all possible target node kind ids.
  /// Returns None if the matcher needs to try against all node kind.
  fn potential_kinds(&self) -> Option<BitSet> {
    None
  }

  /// get_match_len will skip trailing anonymous child node to exclude punctuation.
  // This is not included in NodeMatch since it is only used in replace
  fn get_match_len<D: Doc>(&self, _node: Node<'_, D>) -> Option<usize> {
    None
  }
}

/// MatcherExt provides additional utility methods for `Matcher`.
/// It is implemented for all types that implement `Matcher`.
/// N.B. This trait is not intended to be implemented by users.
pub trait MatcherExt: Matcher {
  fn match_node<'tree, D: Doc>(&self, node: Node<'tree, D>) -> Option<NodeMatch<'tree, D>> {
    // in future we might need to customize initial MetaVarEnv
    let mut env = Cow::Owned(MetaVarEnv::new());
    let node = self.match_node_with_env(node, &mut env)?;
    Some(NodeMatch::new(node, env.into_owned()))
  }

  fn find_node<'tree, D: Doc>(&self, node: Node<'tree, D>) -> Option<NodeMatch<'tree, D>> {
    for n in node.dfs() {
      if let Some(ret) = self.match_node(n.clone()) {
        return Some(ret);
      }
    }
    None
  }
}

impl<T> MatcherExt for T where T: Matcher {}

impl Matcher for str {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let pattern = Pattern::new(self, node.lang().clone());
    pattern.match_node_with_env(node, env)
  }

  fn get_match_len<D: Doc>(&self, node: Node<'_, D>) -> Option<usize> {
    let pattern = Pattern::new(self, node.lang().clone());
    pattern.get_match_len(node)
  }
}

impl<T> Matcher for &T
where
  T: Matcher + ?Sized,
{
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    (**self).match_node_with_env(node, env)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    (**self).potential_kinds()
  }

  fn get_match_len<D: Doc>(&self, node: Node<'_, D>) -> Option<usize> {
    (**self).get_match_len(node)
  }
}

pub struct MatchAll;
impl Matcher for MatchAll {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    Some(node)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    // return None to match anything
    None
  }
}

pub struct MatchNone;
impl Matcher for MatchNone {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    _node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    None
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    // matches nothing
    Some(BitSet::new())
  }
}



================================================
FILE: crates/core/src/meta_var.rs
================================================
use crate::match_tree::does_node_match_exactly;
use crate::matcher::Matcher;
use crate::source::Content;
use crate::{Doc, Node};
use std::borrow::Cow;
use std::collections::HashMap;

use crate::replacer::formatted_slice;

pub type MetaVariableID = String;

pub type Underlying<D> = Vec<<<D as Doc>::Source as Content>::Underlying>;

/// a dictionary that stores metavariable instantiation
/// const a = 123 matched with const a = $A will produce env: $A => 123
#[derive(Clone)]
pub struct MetaVarEnv<'tree, D: Doc> {
  single_matched: HashMap<MetaVariableID, Node<'tree, D>>,
  multi_matched: HashMap<MetaVariableID, Vec<Node<'tree, D>>>,
  transformed_var: HashMap<MetaVariableID, Underlying<D>>,
}

impl<'t, D: Doc> MetaVarEnv<'t, D> {
  pub fn new() -> Self {
    Self {
      single_matched: HashMap::new(),
      multi_matched: HashMap::new(),
      transformed_var: HashMap::new(),
    }
  }

  pub fn insert(&mut self, id: &str, ret: Node<'t, D>) -> Option<&mut Self> {
    if self.match_variable(id, &ret) {
      self.single_matched.insert(id.to_string(), ret);
      Some(self)
    } else {
      None
    }
  }

  pub fn insert_multi(&mut self, id: &str, ret: Vec<Node<'t, D>>) -> Option<&mut Self> {
    if self.match_multi_var(id, &ret) {
      self.multi_matched.insert(id.to_string(), ret);
      Some(self)
    } else {
      None
    }
  }

  pub fn get_match(&self, var: &str) -> Option<&'_ Node<'t, D>> {
    self.single_matched.get(var)
  }

  pub fn get_multiple_matches(&self, var: &str) -> Vec<Node<'t, D>> {
    self.multi_matched.get(var).cloned().unwrap_or_default()
  }

  pub fn add_label(&mut self, label: &str, node: Node<'t, D>) {
    self
      .multi_matched
      .entry(label.into())
      .or_default()
      .push(node);
  }

  pub fn get_labels(&self, label: &str) -> Option<&Vec<Node<'t, D>>> {
    self.multi_matched.get(label)
  }

  pub fn get_matched_variables(&self) -> impl Iterator<Item = MetaVariable> + use<'_, 't, D> {
    let single = self
      .single_matched
      .keys()
      .cloned()
      .map(|n| MetaVariable::Capture(n, false));
    let transformed = self
      .transformed_var
      .keys()
      .cloned()
      .map(|n| MetaVariable::Capture(n, false));
    let multi = self
      .multi_matched
      .keys()
      .cloned()
      .map(MetaVariable::MultiCapture);
    single.chain(multi).chain(transformed)
  }

  fn match_variable(&self, id: &str, candidate: &Node<'t, D>) -> bool {
    if let Some(m) = self.single_matched.get(id) {
      return does_node_match_exactly(m, candidate);
    }
    true
  }
  fn match_multi_var(&self, id: &str, cands: &[Node<'t, D>]) -> bool {
    let Some(nodes) = self.multi_matched.get(id) else {
      return true;
    };
    let mut named_nodes = nodes.iter().filter(|n| n.is_named());
    let mut named_cands = cands.iter().filter(|n| n.is_named());
    loop {
      if let Some(node) = named_nodes.next() {
        let Some(cand) = named_cands.next() else {
          // cand is done but node is not
          break false;
        };
        if !does_node_match_exactly(node, cand) {
          break false;
        }
      } else if named_cands.next().is_some() {
        // node is done but cand is not
        break false;
      } else {
        // both None, matches
        break true;
      }
    }
  }

  pub fn match_constraints<M: Matcher>(
    &mut self,
    var_matchers: &HashMap<MetaVariableID, M>,
  ) -> bool {
    let mut env = Cow::Borrowed(self);
    for (var_id, candidate) in &self.single_matched {
      if let Some(m) = var_matchers.get(var_id) {
        if m.match_node_with_env(candidate.clone(), &mut env).is_none() {
          return false;
        }
      }
    }
    if let Cow::Owned(env) = env {
      *self = env;
    }
    true
  }

  pub fn insert_transformation(&mut self, var: &MetaVariable, name: &str, slice: Underlying<D>) {
    let node = match var {
      MetaVariable::Capture(v, _) => self.single_matched.get(v),
      MetaVariable::MultiCapture(vs) => self.multi_matched.get(vs).and_then(|vs| vs.first()),
      _ => None,
    };
    let deindented = if let Some(v) = node {
      formatted_slice(&slice, v.get_doc().get_source(), v.range().start).to_vec()
    } else {
      slice
    };
    self.transformed_var.insert(name.to_string(), deindented);
  }

  pub fn get_transformed(&self, var: &str) -> Option<&Underlying<D>> {
    self.transformed_var.get(var)
  }
  pub fn get_var_bytes<'s>(
    &'s self,
    var: &MetaVariable,
  ) -> Option<&'s [<D::Source as Content>::Underlying]> {
    get_var_bytes_impl(self, var)
  }
}

impl<D: Doc> MetaVarEnv<'_, D> {
  /// internal for readopt NodeMatch in pinned.rs
  /// readopt node and env when sending them to other threads
  pub(crate) fn visit_nodes<F>(&mut self, mut f: F)
  where
    F: FnMut(&mut Node<'_, D>),
  {
    for n in self.single_matched.values_mut() {
      f(n)
    }
    for ns in self.multi_matched.values_mut() {
      for n in ns {
        f(n)
      }
    }
  }
}

fn get_var_bytes_impl<'e, 't, C, D>(
  env: &'e MetaVarEnv<'t, D>,
  var: &MetaVariable,
) -> Option<&'e [C::Underlying]>
where
  D: Doc<Source = C> + 't,
  C: Content + 't,
{
  match var {
    MetaVariable::Capture(n, _) => {
      if let Some(node) = env.get_match(n) {
        let bytes = node.get_doc().get_source().get_range(node.range());
        Some(bytes)
      } else if let Some(bytes) = env.get_transformed(n) {
        Some(bytes)
      } else {
        None
      }
    }
    MetaVariable::MultiCapture(n) => {
      let nodes = env.get_multiple_matches(n);
      if nodes.is_empty() {
        None
      } else {
        // NOTE: start_byte is not always index range of source's slice.
        // e.g. start_byte is still byte_offset in utf_16 (napi). start_byte
        // so we need to call source's get_range method
        let start = nodes[0].range().start;
        let end = nodes[nodes.len() - 1].range().end;
        Some(nodes[0].get_doc().get_source().get_range(start..end))
      }
    }
    _ => None,
  }
}

impl<D: Doc> Default for MetaVarEnv<'_, D> {
  fn default() -> Self {
    Self::new()
  }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum MetaVariable {
  /// $A for captured meta var
  Capture(MetaVariableID, bool),
  /// $_ for non-captured meta var
  Dropped(bool),
  /// $$$ for non-captured multi var
  Multiple,
  /// $$$A for captured ellipsis
  MultiCapture(MetaVariableID),
}

pub(crate) fn extract_meta_var(src: &str, meta_char: char) -> Option<MetaVariable> {
  use MetaVariable::*;
  let ellipsis: String = std::iter::repeat(meta_char).take(3).collect();
  if src == ellipsis {
    return Some(Multiple);
  }
  if let Some(trimmed) = src.strip_prefix(&ellipsis) {
    if !trimmed.chars().all(is_valid_meta_var_char) {
      return None;
    }
    if trimmed.starts_with('_') {
      return Some(Multiple);
    } else {
      return Some(MultiCapture(trimmed.to_owned()));
    }
  }
  if !src.starts_with(meta_char) {
    return None;
  }
  let trimmed = &src[meta_char.len_utf8()..];
  let (trimmed, named) = if let Some(t) = trimmed.strip_prefix(meta_char) {
    (t, false)
  } else {
    (trimmed, true)
  };
  if !trimmed.starts_with(is_valid_first_char) || // empty or started with number
    !trimmed.chars().all(is_valid_meta_var_char)
  // not in form of $A or $_
  {
    return None;
  }
  if trimmed.starts_with('_') {
    Some(Dropped(named))
  } else {
    Some(Capture(trimmed.to_owned(), named))
  }
}

#[inline]
fn is_valid_first_char(c: char) -> bool {
  matches!(c, 'A'..='Z' | '_')
}

#[inline]
pub(crate) fn is_valid_meta_var_char(c: char) -> bool {
  is_valid_first_char(c) || c.is_ascii_digit()
}

impl<'tree, D: Doc> From<MetaVarEnv<'tree, D>> for HashMap<String, String> {
  fn from(env: MetaVarEnv<'tree, D>) -> Self {
    let mut ret = HashMap::new();
    for (id, node) in env.single_matched {
      ret.insert(id, node.text().into());
    }
    for (id, bytes) in env.transformed_var {
      ret.insert(id, <D::Source as Content>::encode_bytes(&bytes).to_string());
    }
    for (id, nodes) in env.multi_matched {
      let s: Vec<_> = nodes.iter().map(|n| n.text()).collect();
      let s = s.join(", ");
      ret.insert(id, format!("[{s}]"));
    }
    ret
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::tree_sitter::LanguageExt;
  use crate::Pattern;

  fn extract_var(s: &str) -> Option<MetaVariable> {
    extract_meta_var(s, '$')
  }
  #[test]
  fn test_match_var() {
    use MetaVariable::*;
    assert_eq!(extract_var("$$$"), Some(Multiple));
    assert_eq!(extract_var("$ABC"), Some(Capture("ABC".into(), true)));
    assert_eq!(extract_var("$$ABC"), Some(Capture("ABC".into(), false)));
    assert_eq!(extract_var("$MATCH1"), Some(Capture("MATCH1".into(), true)));
    assert_eq!(extract_var("$$$ABC"), Some(MultiCapture("ABC".into())));
    assert_eq!(extract_var("$_"), Some(Dropped(true)));
    assert_eq!(extract_var("$_123"), Some(Dropped(true)));
    assert_eq!(extract_var("$$_"), Some(Dropped(false)));
  }

  #[test]
  fn test_not_meta_var() {
    assert_eq!(extract_var("$123"), None);
    assert_eq!(extract_var("$"), None);
    assert_eq!(extract_var("$$"), None);
    assert_eq!(extract_var("abc"), None);
    assert_eq!(extract_var("$abc"), None);
  }

  fn match_constraints(pattern: &str, node: &str) -> bool {
    let mut matchers = HashMap::new();
    matchers.insert("A".to_string(), Pattern::new(pattern, Tsx));
    let mut env = MetaVarEnv::new();
    let root = Tsx.ast_grep(node);
    let node = root.root().child(0).unwrap().child(0).unwrap();
    env.insert("A", node);
    env.match_constraints(&matchers)
  }

  #[test]
  fn test_non_ascii_meta_var() {
    let extract = |s| extract_meta_var(s, 'µ');
    use MetaVariable::*;
    assert_eq!(extract("µµµ"), Some(Multiple));
    assert_eq!(extract("µABC"), Some(Capture("ABC".into(), true)));
    assert_eq!(extract("µµABC"), Some(Capture("ABC".into(), false)));
    assert_eq!(extract("µµµABC"), Some(MultiCapture("ABC".into())));
    assert_eq!(extract("µ_"), Some(Dropped(true)));
    assert_eq!(extract("abc"), None);
    assert_eq!(extract("µabc"), None);
  }

  #[test]
  fn test_match_constraints() {
    assert!(match_constraints("a + b", "a + b"));
  }

  #[test]
  fn test_match_not_constraints() {
    assert!(!match_constraints("a - b", "a + b"));
  }

  #[test]
  fn test_multi_var_match() {
    let grep = Tsx.ast_grep("if (true) { a += 1; b += 1 } else { a += 1; b += 1 }");
    let node = grep.root();
    let found = node.find("if (true) { $$$A } else { $$$A }");
    assert!(found.is_some());
    let grep = Tsx.ast_grep("if (true) { a += 1 } else { b += 1 }");
    let node = grep.root();
    let not_found = node.find("if (true) { $$$A } else { $$$A }");
    assert!(not_found.is_none());
  }

  #[test]
  fn test_multi_var_match_with_trailing() {
    let grep = Tsx.ast_grep("if (true) { a += 1; } else { a += 1; b += 1 }");
    let node = grep.root();
    let not_found = node.find("if (true) { $$$A } else { $$$A }");
    assert!(not_found.is_none());
    let grep = Tsx.ast_grep("if (true) { a += 1; b += 1; } else { a += 1 }");
    let node = grep.root();
    let not_found = node.find("if (true) { $$$A } else { $$$A }");
    assert!(not_found.is_none());
  }
}



================================================
FILE: crates/core/src/node.rs
================================================
use crate::matcher::{Matcher, MatcherExt, NodeMatch};
use crate::replacer::Replacer;
use crate::source::{Content, Edit as E, SgNode};
use crate::Doc;
use crate::Language;

type Edit<D> = E<<D as Doc>::Source>;

use std::borrow::Cow;

/// Represents a position in the source code.
/// The line and column are zero-based, character offsets.
/// It is different from tree-sitter's position which is zero-based `byte` offsets.
/// Note, accessing `column` is O(n) operation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Position {
  /// zero-based line offset. Text encoding does not matter.
  line: usize,
  /// zero-based BYTE offset instead of character offset
  byte_column: usize,
  /// byte offset of this position
  byte_offset: usize,
}

impl Position {
  pub fn new(line: usize, byte_column: usize, byte_offset: usize) -> Self {
    Self {
      line,
      byte_column,
      byte_offset,
    }
  }
  pub fn line(&self) -> usize {
    self.line
  }
  /// Returns the column in terms of characters.
  /// Note: node does not have to be a node of matching position.
  pub fn column<D: Doc>(&self, node: &Node<'_, D>) -> usize {
    let source = node.get_doc().get_source();
    source.get_char_column(self.byte_column, self.byte_offset)
  }
  pub fn byte_point(&self) -> (usize, usize) {
    (self.line, self.byte_column)
  }
}

/// Represents [`tree_sitter::Tree`] and owns source string
/// Note: Root is generic against [`Language`](crate::language::Language)
#[derive(Clone)]
pub struct Root<D: Doc> {
  pub(crate) doc: D,
}

impl<D: Doc> Root<D> {
  pub fn doc(doc: D) -> Self {
    Self { doc }
  }

  pub fn lang(&self) -> &D::Lang {
    self.doc.get_lang()
  }
  /// The root node represents the entire source
  pub fn root(&self) -> Node<'_, D> {
    Node {
      inner: self.doc.root_node(),
      root: self,
    }
  }

  // extract non generic implementation to reduce code size
  pub fn edit(&mut self, edit: Edit<D>) -> Result<&mut Self, String> {
    self.doc.do_edit(&edit)?;
    Ok(self)
  }

  pub fn replace<M: Matcher, R: Replacer<D>>(
    &mut self,
    pattern: M,
    replacer: R,
  ) -> Result<bool, String> {
    let root = self.root();
    if let Some(edit) = root.replace(pattern, replacer) {
      drop(root); // rust cannot auto drop root if D is not specified
      self.edit(edit)?;
      Ok(true)
    } else {
      Ok(false)
    }
  }

  /// Adopt the tree_sitter as the descendant of the root and return the wrapped sg Node.
  /// It assumes `inner` is the under the root and will panic at dev build if wrong node is used.
  pub fn adopt<'r>(&'r self, inner: D::Node<'r>) -> Node<'r, D> {
    debug_assert!(self.check_lineage(&inner));
    Node { inner, root: self }
  }

  fn check_lineage(&self, inner: &D::Node<'_>) -> bool {
    let mut node = inner.clone();
    while let Some(n) = node.parent() {
      node = n;
    }
    node.node_id() == self.doc.root_node().node_id()
  }

  /// P.S. I am your father.
  #[doc(hidden)]
  pub unsafe fn readopt<'a: 'b, 'b>(&'a self, node: &mut Node<'b, D>) {
    debug_assert!(self.check_lineage(&node.inner));
    node.root = self;
  }
}

// why we need one more content? https://github.com/ast-grep/ast-grep/issues/1951
/// 'r represents root lifetime
#[derive(Clone)]
pub struct Node<'r, D: Doc> {
  pub(crate) inner: D::Node<'r>,
  pub(crate) root: &'r Root<D>,
}
pub type KindId = u16;

/// APIs for Node inspection
impl<'r, D: Doc> Node<'r, D> {
  pub fn get_doc(&self) -> &'r D {
    &self.root.doc
  }
  pub fn node_id(&self) -> usize {
    self.inner.node_id()
  }
  pub fn is_leaf(&self) -> bool {
    self.inner.is_leaf()
  }
  /// if has no named children.
  /// N.B. it is different from is_named && is_leaf
  // see https://github.com/ast-grep/ast-grep/issues/276
  pub fn is_named_leaf(&self) -> bool {
    self.inner.is_named_leaf()
  }
  pub fn is_error(&self) -> bool {
    self.inner.is_error()
  }
  pub fn kind(&self) -> Cow<'_, str> {
    self.inner.kind()
  }
  pub fn kind_id(&self) -> KindId {
    self.inner.kind_id()
  }

  pub fn is_named(&self) -> bool {
    self.inner.is_named()
  }
  pub fn is_missing(&self) -> bool {
    self.inner.is_missing()
  }

  /// byte offsets of start and end.
  pub fn range(&self) -> std::ops::Range<usize> {
    self.inner.range()
  }

  /// Nodes' start position in terms of zero-based rows and columns.
  pub fn start_pos(&self) -> Position {
    self.inner.start_pos()
  }

  /// Nodes' end position in terms of rows and columns.
  pub fn end_pos(&self) -> Position {
    self.inner.end_pos()
  }

  pub fn text(&self) -> Cow<'r, str> {
    self.root.doc.get_node_text(&self.inner)
  }

  pub fn lang(&self) -> &'r D::Lang {
    self.root.lang()
  }

  /// the underlying tree-sitter Node
  pub fn get_inner_node(&self) -> D::Node<'r> {
    self.inner.clone()
  }

  pub fn root(&self) -> &'r Root<D> {
    self.root
  }
}

/**
 * Corresponds to inside/has/precedes/follows
 */
impl<D: Doc> Node<'_, D> {
  pub fn matches<M: Matcher>(&self, m: M) -> bool {
    m.match_node(self.clone()).is_some()
  }

  pub fn inside<M: Matcher>(&self, m: M) -> bool {
    self.ancestors().find_map(|n| m.match_node(n)).is_some()
  }

  pub fn has<M: Matcher>(&self, m: M) -> bool {
    self.dfs().skip(1).find_map(|n| m.match_node(n)).is_some()
  }

  pub fn precedes<M: Matcher>(&self, m: M) -> bool {
    self.next_all().find_map(|n| m.match_node(n)).is_some()
  }

  pub fn follows<M: Matcher>(&self, m: M) -> bool {
    self.prev_all().find_map(|n| m.match_node(n)).is_some()
  }
}

/// tree traversal API
impl<'r, D: Doc> Node<'r, D> {
  #[must_use]
  pub fn parent(&self) -> Option<Self> {
    let inner = self.inner.parent()?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  pub fn children(&self) -> impl ExactSizeIterator<Item = Node<'r, D>> + '_ {
    self.inner.children().map(|inner| Node {
      inner,
      root: self.root,
    })
  }

  #[must_use]
  pub fn child(&self, nth: usize) -> Option<Self> {
    let inner = self.inner.child(nth)?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  pub fn field(&self, name: &str) -> Option<Self> {
    let inner = self.inner.field(name)?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  pub fn child_by_field_id(&self, field_id: u16) -> Option<Self> {
    let inner = self.inner.child_by_field_id(field_id)?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  pub fn field_children(&self, name: &str) -> impl Iterator<Item = Node<'r, D>> + '_ {
    let field_id = self.lang().field_to_id(name);
    self.inner.field_children(field_id).map(|inner| Node {
      inner,
      root: self.root,
    })
  }

  /// Returns all ancestors nodes of `self`.
  /// Using cursor is overkill here because adjust cursor is too expensive.
  pub fn ancestors(&self) -> impl Iterator<Item = Node<'r, D>> + '_ {
    let root = self.root.doc.root_node();
    self.inner.ancestors(root).map(|inner| Node {
      inner,
      root: self.root,
    })
  }
  #[must_use]
  pub fn next(&self) -> Option<Self> {
    let inner = self.inner.next()?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  /// Returns all sibling nodes next to `self`.
  // NOTE: Need go to parent first, then move to current node by byte offset.
  // This is because tree_sitter cursor is scoped to the starting node.
  // See https://github.com/tree-sitter/tree-sitter/issues/567
  pub fn next_all(&self) -> impl Iterator<Item = Node<'r, D>> + '_ {
    self.inner.next_all().map(|inner| Node {
      inner,
      root: self.root,
    })
  }

  #[must_use]
  pub fn prev(&self) -> Option<Node<'r, D>> {
    let inner = self.inner.prev()?;
    Some(Node {
      inner,
      root: self.root,
    })
  }

  pub fn prev_all(&self) -> impl Iterator<Item = Node<'r, D>> + '_ {
    self.inner.prev_all().map(|inner| Node {
      inner,
      root: self.root,
    })
  }

  pub fn dfs<'s>(&'s self) -> impl Iterator<Item = Node<'r, D>> + 's {
    self.inner.dfs().map(|inner| Node {
      inner,
      root: self.root,
    })
  }

  #[must_use]
  pub fn find<M: Matcher>(&self, pat: M) -> Option<NodeMatch<'r, D>> {
    pat.find_node(self.clone())
  }

  pub fn find_all<'s, M: Matcher + 's>(
    &'s self,
    pat: M,
  ) -> impl Iterator<Item = NodeMatch<'r, D>> + 's {
    let kinds = pat.potential_kinds();
    self.dfs().filter_map(move |cand| {
      if let Some(k) = &kinds {
        if !k.contains(cand.kind_id().into()) {
          return None;
        }
      }
      pat.match_node(cand)
    })
  }
}

/// Tree manipulation API
impl<D: Doc> Node<'_, D> {
  pub fn replace<M: Matcher, R: Replacer<D>>(&self, matcher: M, replacer: R) -> Option<Edit<D>> {
    let matched = matcher.find_node(self.clone())?;
    let edit = matched.make_edit(&matcher, &replacer);
    Some(edit)
  }

  pub fn after(&self) -> Edit<D> {
    todo!()
  }
  pub fn before(&self) -> Edit<D> {
    todo!()
  }
  pub fn append(&self) -> Edit<D> {
    todo!()
  }
  pub fn prepend(&self) -> Edit<D> {
    todo!()
  }

  /// Empty children. Remove all child node
  pub fn empty(&self) -> Option<Edit<D>> {
    let mut children = self.children().peekable();
    let start = children.peek()?.range().start;
    let end = children.last()?.range().end;
    Some(Edit::<D> {
      position: start,
      deleted_length: end - start,
      inserted_text: Vec::new(),
    })
  }

  /// Remove the node itself
  pub fn remove(&self) -> Edit<D> {
    let range = self.range();
    Edit::<D> {
      position: range.start,
      deleted_length: range.end - range.start,
      inserted_text: Vec::new(),
    }
  }
}

#[cfg(test)]
mod test {
  use crate::language::{Language, Tsx};
  use crate::tree_sitter::LanguageExt;
  #[test]
  fn test_is_leaf() {
    let root = Tsx.ast_grep("let a = 123");
    let node = root.root();
    assert!(!node.is_leaf());
  }

  #[test]
  fn test_children() {
    let root = Tsx.ast_grep("let a = 123");
    let node = root.root();
    let children: Vec<_> = node.children().collect();
    assert_eq!(children.len(), 1);
    let texts: Vec<_> = children[0]
      .children()
      .map(|c| c.text().to_string())
      .collect();
    assert_eq!(texts, vec!["let", "a = 123"]);
  }
  #[test]
  fn test_empty() {
    let root = Tsx.ast_grep("let a = 123");
    let node = root.root();
    let edit = node.empty().unwrap();
    assert_eq!(edit.inserted_text.len(), 0);
    assert_eq!(edit.deleted_length, 11);
    assert_eq!(edit.position, 0);
  }

  #[test]
  fn test_field_children() {
    let root = Tsx.ast_grep("let a = 123");
    let node = root.root().find("let a = $A").unwrap();
    let children: Vec<_> = node.field_children("kind").collect();
    assert_eq!(children.len(), 1);
    assert_eq!(children[0].text(), "let");
  }

  const MULTI_LINE: &str = "
if (a) {
  test(1)
} else {
  x
}
";

  #[test]
  fn test_display_context() {
    // src, matcher, lead, trail
    let cases = [
      ["i()", "i()", "", ""],
      ["i()", "i", "", "()"],
      [MULTI_LINE, "test", "  ", "(1)"],
    ];
    // display context should not panic
    for [src, matcher, lead, trail] in cases {
      let root = Tsx.ast_grep(src);
      let node = root.root().find(matcher).expect("should match");
      let display = node.display_context(0, 0);
      assert_eq!(display.leading, lead);
      assert_eq!(display.trailing, trail);
    }
  }

  #[test]
  fn test_multi_line_context() {
    let cases = [
      ["i()", "i()", "", ""],
      [MULTI_LINE, "test", "if (a) {\n  ", "(1)\n} else {"],
    ];
    // display context should not panic
    for [src, matcher, lead, trail] in cases {
      let root = Tsx.ast_grep(src);
      let node = root.root().find(matcher).expect("should match");
      let display = node.display_context(1, 1);
      assert_eq!(display.leading, lead);
      assert_eq!(display.trailing, trail);
    }
  }

  #[test]
  fn test_replace_all_nested() {
    let root = Tsx.ast_grep("Some(Some(1))");
    let node = root.root();
    let edits = node.replace_all("Some($A)", "$A");
    assert_eq!(edits.len(), 1);
    assert_eq!(edits[0].inserted_text, "Some(1)".as_bytes());
  }

  #[test]
  fn test_replace_all_multiple_sorted() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2)");
    let node = root.root();
    let edits = node.replace_all("Some($A)", "$A");
    // edits must be sorted by position
    assert_eq!(edits.len(), 2);
    assert_eq!(edits[0].inserted_text, "Some(1)".as_bytes());
    assert_eq!(edits[1].inserted_text, "2".as_bytes());
  }

  #[test]
  fn test_inside() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2)");
    let root = root.root();
    let node = root.find("Some(1)").expect("should exist");
    assert!(node.inside("Some($A)"));
  }
  #[test]
  fn test_has() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2)");
    let root = root.root();
    let node = root.find("Some($A)").expect("should exist");
    assert!(node.has("Some(1)"));
  }
  #[test]
  fn precedes() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2);");
    let root = root.root();
    let node = root.find("Some($A);").expect("should exist");
    assert!(node.precedes("Some(2);"));
  }
  #[test]
  fn follows() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2);");
    let root = root.root();
    let node = root.find("Some(2);").expect("should exist");
    assert!(node.follows("Some(Some(1));"));
  }

  #[test]
  fn test_field() {
    let root = Tsx.ast_grep("class A{}");
    let root = root.root();
    let node = root.find("class $C {}").expect("should exist");
    assert!(node.field("name").is_some());
    assert!(node.field("none").is_none());
  }
  #[test]
  fn test_child_by_field_id() {
    let root = Tsx.ast_grep("class A{}");
    let root = root.root();
    let node = root.find("class $C {}").expect("should exist");
    let id = Tsx.field_to_id("name").unwrap();
    assert!(node.child_by_field_id(id).is_some());
    assert!(node.child_by_field_id(id + 1).is_none());
  }

  #[test]
  fn test_remove() {
    let root = Tsx.ast_grep("Some(Some(1)); Some(2);");
    let root = root.root();
    let node = root.find("Some(2);").expect("should exist");
    let edit = node.remove();
    assert_eq!(edit.position, 15);
    assert_eq!(edit.deleted_length, 8);
  }

  #[test]
  fn test_ascii_pos() {
    let root = Tsx.ast_grep("a");
    let root = root.root();
    let node = root.find("$A").expect("should exist");
    assert_eq!(node.start_pos().line(), 0);
    assert_eq!(node.start_pos().column(&*node), 0);
    assert_eq!(node.end_pos().line(), 0);
    assert_eq!(node.end_pos().column(&*node), 1);
  }

  #[test]
  fn test_unicode_pos() {
    let root = Tsx.ast_grep("🦀");
    let root = root.root();
    let node = root.find("$A").expect("should exist");
    assert_eq!(node.start_pos().line(), 0);
    assert_eq!(node.start_pos().column(&*node), 0);
    assert_eq!(node.end_pos().line(), 0);
    assert_eq!(node.end_pos().column(&*node), 1);
    let root = Tsx.ast_grep("\n  🦀🦀");
    let root = root.root();
    let node = root.find("$A").expect("should exist");
    assert_eq!(node.start_pos().line(), 1);
    assert_eq!(node.start_pos().column(&*node), 2);
    assert_eq!(node.end_pos().line(), 1);
    assert_eq!(node.end_pos().column(&*node), 4);
  }
}



================================================
FILE: crates/core/src/ops.rs
================================================
use crate::matcher::{MatchAll, MatchNone, Matcher};
use crate::meta_var::MetaVarEnv;
use crate::{Doc, Node};
use bit_set::BitSet;
use std::borrow::Cow;

pub struct And<P1: Matcher, P2: Matcher> {
  pattern1: P1,
  pattern2: P2,
}

impl<P1, P2> Matcher for And<P1, P2>
where
  P1: Matcher,
  P2: Matcher,
{
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    // keep the original env intact until both arms match
    let mut new_env = Cow::Borrowed(env.as_ref());
    let node = self.pattern1.match_node_with_env(node, &mut new_env)?;
    let ret = self.pattern2.match_node_with_env(node, &mut new_env)?;
    // both succeed – commit the combined env
    *env = Cow::Owned(new_env.into_owned());
    Some(ret)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    let set1 = self.pattern1.potential_kinds();
    let set2 = self.pattern2.potential_kinds();
    // if both constituent have Some(bitset), intersect them
    // otherwise returns either of the non-null set
    match (&set1, &set2) {
      (Some(s1), Some(s2)) => Some(s1.intersection(s2).collect()),
      _ => set1.xor(set2),
    }
  }
}

// we pre-compute and cache potential_kinds. So patterns should not be mutated.
// Box<[P]> is used here for immutability so that kinds will never be invalidated.
pub struct All<P: Matcher> {
  patterns: Box<[P]>,
  kinds: Option<BitSet>,
}

impl<P: Matcher> All<P> {
  pub fn new<PS: IntoIterator<Item = P>>(patterns: PS) -> Self {
    let patterns: Box<[P]> = patterns.into_iter().collect();
    let kinds = Self::compute_kinds(&patterns);
    Self { patterns, kinds }
  }

  fn compute_kinds(patterns: &[P]) -> Option<BitSet> {
    let mut set: Option<BitSet> = None;
    for pattern in patterns {
      let Some(n) = pattern.potential_kinds() else {
        continue;
      };
      if let Some(set) = set.as_mut() {
        set.intersect_with(&n);
      } else {
        set = Some(n);
      }
    }
    set
  }

  pub fn inner(&self) -> &[P] {
    &self.patterns
  }
}

impl<P: Matcher> Matcher for All<P> {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if let Some(kinds) = &self.kinds {
      if !kinds.contains(node.kind_id().into()) {
        return None;
      }
    }
    let mut new_env = Cow::Borrowed(env.as_ref());
    let all_satisfied = self
      .patterns
      .iter()
      .all(|p| p.match_node_with_env(node.clone(), &mut new_env).is_some());
    if all_satisfied {
      *env = Cow::Owned(new_env.into_owned());
      Some(node)
    } else {
      None
    }
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    self.kinds.clone()
  }
}

// Box<[P]> for immutability and potential_kinds cache correctness
pub struct Any<P> {
  patterns: Box<[P]>,
  kinds: Option<BitSet>,
}

impl<P: Matcher> Any<P> {
  pub fn new<PS: IntoIterator<Item = P>>(patterns: PS) -> Self {
    let patterns: Box<[P]> = patterns.into_iter().collect();
    let kinds = Self::compute_kinds(&patterns);
    Self { patterns, kinds }
  }

  fn compute_kinds(patterns: &[P]) -> Option<BitSet> {
    let mut set = BitSet::new();
    for pattern in patterns {
      let n = pattern.potential_kinds()?;
      set.union_with(&n);
    }
    Some(set)
  }

  pub fn inner(&self) -> &[P] {
    &self.patterns
  }
}

impl<M: Matcher> Matcher for Any<M> {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if let Some(kinds) = &self.kinds {
      if !kinds.contains(node.kind_id().into()) {
        return None;
      }
    }
    let mut new_env = Cow::Borrowed(env.as_ref());
    let found = self.patterns.iter().find_map(|p| {
      new_env = Cow::Borrowed(env.as_ref());
      p.match_node_with_env(node.clone(), &mut new_env)
    });
    if found.is_some() {
      *env = Cow::Owned(new_env.into_owned());
      Some(node)
    } else {
      None
    }
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    self.kinds.clone()
  }
}

pub struct Or<P1: Matcher, P2: Matcher> {
  pattern1: P1,
  pattern2: P2,
}

impl<P1, P2> Matcher for Or<P1, P2>
where
  P1: Matcher,
  P2: Matcher,
{
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    let mut new_env = Cow::Borrowed(env.as_ref());
    if let Some(ret) = self
      .pattern1
      .match_node_with_env(node.clone(), &mut new_env)
    {
      *env = Cow::Owned(new_env.into_owned());
      Some(ret)
    } else {
      self.pattern2.match_node_with_env(node, env)
    }
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    let mut set1 = self.pattern1.potential_kinds()?;
    let set2 = self.pattern2.potential_kinds()?;
    set1.union_with(&set2);
    Some(set1)
  }
}

pub struct Not<M: Matcher> {
  not: M,
}

impl<M: Matcher> Not<M> {
  pub fn new(not: M) -> Self {
    Self { not }
  }

  pub fn inner(&self) -> &M {
    &self.not
  }
}
impl<P> Matcher for Not<P>
where
  P: Matcher,
{
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    self
      .not
      .match_node_with_env(node.clone(), env)
      .xor(Some(node))
  }
}

#[derive(Clone)]
pub struct Op<M: Matcher> {
  inner: M,
}

impl<M> Matcher for Op<M>
where
  M: Matcher,
{
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    self.inner.match_node_with_env(node, env)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    self.inner.potential_kinds()
  }
}

/*
pub struct Predicate<F> {
  func: F,
}

impl<L, F> Matcher for Predicate<F>
where
  L: Language,
  F: for<'tree> Fn(&Node<'tree, StrDoc<L>>) -> bool,
{
  fn match_node_with_env<'tree, D: Doc<Lang=L>>(
    &self,
    node: Node<'tree, D>,
    env: &mut MetaVarEnv<'tree, D>,
  ) -> Option<Node<'tree, D>> {
    (self.func)(&node).then_some(node)
  }
}
*/

/*
// we don't need specify M for static method
impl<L: Language> Op<L, MatchNone> {
  pub fn func<F>(func: F) -> Predicate<F>
  where
    F: for<'tree> Fn(&Node<'tree, StrDoc<L>>) -> bool,
  {
    Predicate { func }
  }
}
*/

impl<M: Matcher> Op<M> {
  pub fn not(pattern: M) -> Not<M> {
    Not { not: pattern }
  }
}

impl<M: Matcher> Op<M> {
  pub fn every(pattern: M) -> Op<And<M, MatchAll>> {
    Op {
      inner: And {
        pattern1: pattern,
        pattern2: MatchAll,
      },
    }
  }
  pub fn either(pattern: M) -> Op<Or<M, MatchNone>> {
    Op {
      inner: Or {
        pattern1: pattern,
        pattern2: MatchNone,
      },
    }
  }

  pub fn all<MS: IntoIterator<Item = M>>(patterns: MS) -> All<M> {
    All::new(patterns)
  }

  pub fn any<MS: IntoIterator<Item = M>>(patterns: MS) -> Any<M> {
    Any::new(patterns)
  }

  pub fn new(matcher: M) -> Op<M> {
    Self { inner: matcher }
  }
}

type NestedAnd<M, N, O> = And<And<M, N>, O>;
impl<M: Matcher, N: Matcher> Op<And<M, N>> {
  pub fn and<O: Matcher>(self, other: O) -> Op<NestedAnd<M, N, O>> {
    Op {
      inner: And {
        pattern1: self.inner,
        pattern2: other,
      },
    }
  }
}

type NestedOr<M, N, O> = Or<Or<M, N>, O>;
impl<M: Matcher, N: Matcher> Op<Or<M, N>> {
  pub fn or<O: Matcher>(self, other: O) -> Op<NestedOr<M, N, O>> {
    Op {
      inner: Or {
        pattern1: self.inner,
        pattern2: other,
      },
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::matcher::MatcherExt;
  use crate::meta_var::MetaVarEnv;
  use crate::Root;

  fn test_find(matcher: &impl Matcher, code: &str) {
    let node = Root::str(code, Tsx);
    assert!(matcher.find_node(node.root()).is_some());
  }
  fn test_not_find(matcher: &impl Matcher, code: &str) {
    let node = Root::str(code, Tsx);
    assert!(matcher.find_node(node.root()).is_none());
  }
  fn find_all(matcher: impl Matcher, code: &str) -> Vec<String> {
    let node = Root::str(code, Tsx);
    node
      .root()
      .find_all(matcher)
      .map(|n| n.text().to_string())
      .collect()
  }

  #[test]
  fn test_or() {
    let matcher = Or {
      pattern1: "let a = 1",
      pattern2: "const b = 2",
    };
    test_find(&matcher, "let a = 1");
    test_find(&matcher, "const b = 2");
    test_not_find(&matcher, "let a = 2");
    test_not_find(&matcher, "const a = 1");
    test_not_find(&matcher, "let b = 2");
    test_not_find(&matcher, "const b = 1");
  }

  #[test]
  fn test_not() {
    let matcher = Not { not: "let a = 1" };
    test_find(&matcher, "const b = 2");
  }

  #[test]
  fn test_and() {
    let matcher = And {
      pattern1: "let a = $_",
      pattern2: Not { not: "let a = 123" },
    };
    test_find(&matcher, "let a = 233");
    test_find(&matcher, "let a = 456");
    test_not_find(&matcher, "let a = 123");
  }

  #[test]
  fn test_api_and() {
    let matcher = Op::every("let a = $_").and(Op::not("let a = 123"));
    test_find(&matcher, "let a = 233");
    test_find(&matcher, "let a = 456");
    test_not_find(&matcher, "let a = 123");
  }

  #[test]
  fn test_api_or() {
    let matcher = Op::either("let a = 1").or("const b = 2");
    test_find(&matcher, "let a = 1");
    test_find(&matcher, "const b = 2");
    test_not_find(&matcher, "let a = 2");
    test_not_find(&matcher, "const a = 1");
    test_not_find(&matcher, "let b = 2");
    test_not_find(&matcher, "const b = 1");
  }
  #[test]
  fn test_multiple_match() {
    let sequential = find_all("$A + b", "let f = () => a + b; let ff = () => c + b");
    assert_eq!(sequential.len(), 2);
    let nested = find_all(
      "function $A() { $$$ }",
      "function a() { function b() { b } }",
    );
    assert_eq!(nested.len(), 2);
  }

  #[test]
  fn test_multiple_match_order() {
    let ret = find_all(
      "$A + b",
      "let f = () => () => () => a + b; let ff = () => c + b",
    );
    assert_eq!(ret, ["a + b", "c + b"], "should match source code order");
  }

  /*
  #[test]
  fn test_api_func() {
    let matcher = Op::func(|n| n.text().contains("114514"));
    test_find(&matcher, "let a = 114514");
    test_not_find(&matcher, "let a = 1919810");
  }
  */
  use crate::Pattern;
  trait TsxMatcher {
    fn t(self) -> Pattern;
  }
  impl TsxMatcher for &str {
    fn t(self) -> Pattern {
      Pattern::new(self, Tsx)
    }
  }

  #[test]
  fn test_and_kinds() {
    // intersect None kinds
    let matcher = Op::every("let a = $_".t()).and(Op::not("let a = 123".t()));
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    let matcher = Op::every(Op::not("let a = $_".t())).and("let a = 123".t());
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // intersect Same kinds
    let matcher = Op::every("let a = $_".t()).and("let b = 123".t());
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // intersect different kinds
    let matcher = Op::every("let a = 1".t()).and("console.log(1)".t());
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(0));
    // two None kinds
    let matcher = Op::every(Op::not("let a = $_".t())).and(Op::not("let a = 123".t()));
    assert_eq!(matcher.potential_kinds(), None);
  }

  #[test]
  fn test_or_kinds() {
    // union None kinds
    let matcher = Op::either("let a = $_".t()).or(Op::not("let a = 123".t()));
    assert_eq!(matcher.potential_kinds(), None);
    let matcher = Op::either(Op::not("let a = $_".t())).or("let a = 123".t());
    assert_eq!(matcher.potential_kinds(), None);
    // union Same kinds
    let matcher = Op::either("let a = $_".t()).or("let b = 123".t());
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // union different kinds
    let matcher = Op::either("let a = 1".t()).or("console.log(1)".t());
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(2));
    // two None kinds
    let matcher = Op::either(Op::not("let a = $_".t())).or(Op::not("let a = 123".t()));
    assert_eq!(matcher.potential_kinds(), None);
  }

  #[test]
  fn test_all_kinds() {
    // intersect None kinds
    let matcher = Op::all(["let a = $_".t(), "$A".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    let matcher = Op::all(["$A".t(), "let a = $_".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // intersect Same kinds
    let matcher = Op::all(["let a = $_".t(), "let b = 123".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // intersect different kinds
    let matcher = Op::all(["let a = 1".t(), "console.log(1)".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(0));
    // two None kinds
    let matcher = Op::all(["$A".t(), "$B".t()]);
    assert_eq!(matcher.potential_kinds(), None);
  }

  #[test]
  fn test_any_kinds() {
    // union None kinds
    let matcher = Op::any(["let a = $_".t(), "$A".t()]);
    assert_eq!(matcher.potential_kinds(), None);
    let matcher = Op::any(["$A".t(), "let a = $_".t()]);
    assert_eq!(matcher.potential_kinds(), None);
    // union Same kinds
    let matcher = Op::any(["let a = $_".t(), "let b = 123".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(1));
    // union different kinds
    let matcher = Op::any(["let a = 1".t(), "console.log(1)".t()]);
    assert_eq!(matcher.potential_kinds().map(|v| v.len()), Some(2));
    // two None kinds
    let matcher = Op::any(["$A".t(), "$B".t()]);
    assert_eq!(matcher.potential_kinds(), None);
  }

  #[test]
  fn test_or_revert_env() {
    let matcher = Op::either(Op::every("foo($A)".t()).and("impossible".t())).or("foo($B)".t());
    let code = Root::str("foo(123)", Tsx);
    let matches = code.root().find(matcher).expect("should found");
    assert!(matches.get_env().get_match("A").is_none());
    assert_eq!(matches.get_env().get_match("B").unwrap().text(), "123");
  }

  #[test]
  fn test_any_revert_env() {
    let matcher = Op::any([
      Op::all(["foo($A)".t(), "impossible".t()]),
      Op::all(["foo($B)".t()]),
    ]);
    let code = Root::str("foo(123)", Tsx);
    let matches = code.root().find(matcher).expect("should found");
    assert!(matches.get_env().get_match("A").is_none());
    assert_eq!(matches.get_env().get_match("B").unwrap().text(), "123");
  }

  // gh #1225
  #[test]
  fn test_all_revert_env() {
    let matcher = Op::all(["$A(123)".t(), "$B(456)".t()]);
    let code = Root::str("foo(123)", Tsx);
    let node = code.root().find("foo($C)").expect("should exist");
    let node = node.get_node().clone();
    let mut env = Cow::Owned(MetaVarEnv::new());
    assert!(matcher.match_node_with_env(node, &mut env).is_none());
    assert!(env.get_match("A").is_none());
  }
}



================================================
FILE: crates/core/src/pinned.rs
================================================
use crate::matcher::NodeMatch;
use crate::node::{Node, Root};
use crate::Doc;

// ast-grep Node contains a reference to Root. It implies that
// node can be used only when the Root is valid and not dropped.
// By default, tree-sitter Node<'r> is scoped by ast Root's lifetime
// That is, Node can be only used when root is on the call stack (RAII)
// It is usually sufficient but for following scenario the brwchck is too conservative:
// 1. passing Root and Node across threads
// 2. passing Root and Node across FFI boundary (from Rust to napi/pyo3)
//
// This resembles self-referencing pattern and we can use solution similar to PinBox.
// Actually, tree-sitter's Node reference is already pointing to a heap address.
// N.B. it is not documented but can be inferred from the source code and concurrency doc paragraph.
// https://github.com/tree-sitter/tree-sitter/blob/20924fa4cdeb10d82ac308481e39bf8519334e55/lib/src/tree.c#L9-L20
// https://github.com/tree-sitter/tree-sitter/blob/20924fa4cdeb10d82ac308481e39bf8519334e55/lib/src/tree.c#L37-L39
// https://tree-sitter.github.io/tree-sitter/using-parsers#concurrency
//
// So **as long as Root is not dropped, the Tree will not be freed. And Node will be valid.**
//
// PinnedNodeData provides a systematical way to keep Root live and `T` can be anything containing valid Nodes.
// Nodes' lifetime is 'static, meaning the Node is not borrow checked instead of living throughout the program.
// There are two ways to use PinnedNodeData
// 1. use it by borrowing. PinnedNodeData guarantees Root is alive and Node in T is valid.
//    Notable example is sending Node across threads.
// 2. take its ownership. Users should take extra care to keep Root alive.
//    Notable example is sending Root to JavaScript/Python heap.
#[doc(hidden)]
pub struct PinnedNodeData<D: Doc, T> {
  pin: Root<D>,
  data: T,
}

impl<T, D: Doc + 'static> PinnedNodeData<D, T> {
  pub fn new<F>(pin: Root<D>, func: F) -> Self
  where
    F: FnOnce(&'static Root<D>) -> T,
  {
    // TODO: explain why unsafe works here and what guarantee it needs
    let reference = unsafe { &*(&pin as *const Root<D>) as &'static Root<D> };
    let data = func(reference);
    Self { pin, data }
  }
}

impl<D: Doc + 'static, T> PinnedNodeData<D, T>
where
  T: NodeData<D>,
{
  pub fn get_data(&mut self) -> &T::Data {
    let pin = unsafe { &*(&self.pin as *const Root<D>) as &'static Root<D> };
    self.data.visit_nodes(|n| unsafe { pin.readopt(n) });
    self.data.get_data()
  }
  pub fn into_raw(self) -> (Root<D>, T) {
    (self.pin, self.data)
  }
}

/// # Safety
/// TODO: explain unsafe trait
pub unsafe trait NodeData<D: Doc> {
  type Data;
  fn get_data(&self) -> &Self::Data;
  fn visit_nodes<F>(&mut self, f: F)
  where
    F: FnMut(&mut Node<'_, D>);
}

unsafe impl<D: Doc> NodeData<D> for Node<'static, D> {
  type Data = Node<'static, D>;
  fn get_data(&self) -> &Self::Data {
    self
  }
  fn visit_nodes<F>(&mut self, mut f: F)
  where
    F: FnMut(&mut Node<'_, D>),
  {
    f(self)
  }
}

unsafe impl<D: Doc> NodeData<D> for NodeMatch<'static, D> {
  type Data = NodeMatch<'static, D>;
  fn get_data(&self) -> &Self::Data {
    self
  }
  fn visit_nodes<F>(&mut self, mut f: F)
  where
    F: FnMut(&mut Node<'_, D>),
  {
    // update the matched Node
    f(unsafe { self.get_node_mut() });
    // update the meta variable captured
    let env = self.get_env_mut();
    env.visit_nodes(f);
  }
}

unsafe impl<D: Doc> NodeData<D> for Vec<NodeMatch<'static, D>> {
  type Data = Vec<NodeMatch<'static, D>>;
  fn get_data(&self) -> &Self::Data {
    self
  }
  fn visit_nodes<F>(&mut self, mut f: F)
  where
    F: FnMut(&mut Node<'_, D>),
  {
    for n in self {
      n.visit_nodes(&mut f)
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::node::Root;
  use crate::tree_sitter::StrDoc;

  fn return_from_func() -> PinnedNodeData<StrDoc<Tsx>, Node<'static, StrDoc<Tsx>>> {
    let root = Root::str("let a = 123", Tsx);
    PinnedNodeData::new(root, |r| r.root().child(0).unwrap().child(1).unwrap())
  }

  #[test]
  fn test_borrow() {
    let mut retained = return_from_func();
    let b = retained.get_data();
    assert_eq!(b.text(), "a = 123");
    assert!(matches!(b.lang(), Tsx));
  }

  #[test]
  #[ignore]
  fn test_node_match() {
    todo!()
  }

  fn return_vec() -> PinnedNodeData<StrDoc<Tsx>, Vec<NodeMatch<'static, StrDoc<Tsx>>>> {
    let root = Root::str("let a = 123", Tsx);
    PinnedNodeData::new(root, |r| {
      r.root()
        .child(0)
        .unwrap()
        .children()
        .map(NodeMatch::from)
        .collect()
    })
  }

  #[test]
  fn test_vec_node() {
    let mut pinned = return_vec();
    let nodes = pinned.get_data();
    assert!(!nodes.is_empty());
    assert_eq!(nodes[0].text(), "let");
    assert_eq!(nodes[1].text(), "a = 123");
  }
}



================================================
FILE: crates/core/src/replacer.rs
================================================
use crate::matcher::Matcher;
use crate::meta_var::{is_valid_meta_var_char, MetaVariableID, Underlying};
use crate::{Doc, Node, NodeMatch, Root};
use std::ops::Range;

pub(crate) use indent::formatted_slice;

use crate::source::Edit as E;
type Edit<D> = E<<D as Doc>::Source>;

mod indent;
mod structural;
mod template;

pub use crate::source::Content;
pub use template::{TemplateFix, TemplateFixError};

/// Replace meta variable in the replacer string
pub trait Replacer<D: Doc> {
  fn generate_replacement(&self, nm: &NodeMatch<'_, D>) -> Underlying<D>;
  fn get_replaced_range(&self, nm: &NodeMatch<'_, D>, matcher: impl Matcher) -> Range<usize> {
    let range = nm.range();
    if let Some(len) = matcher.get_match_len(nm.get_node().clone()) {
      range.start..range.start + len
    } else {
      range
    }
  }
}

impl<D: Doc> Replacer<D> for str {
  fn generate_replacement(&self, nm: &NodeMatch<'_, D>) -> Underlying<D> {
    template::gen_replacement(self, nm)
  }
}

impl<D: Doc> Replacer<D> for Root<D> {
  fn generate_replacement(&self, nm: &NodeMatch<'_, D>) -> Underlying<D> {
    structural::gen_replacement(self, nm)
  }
}

impl<D, T> Replacer<D> for &T
where
  D: Doc,
  T: Replacer<D> + ?Sized,
{
  fn generate_replacement(&self, nm: &NodeMatch<D>) -> Underlying<D> {
    (**self).generate_replacement(nm)
  }
}

impl<D: Doc> Replacer<D> for Node<'_, D> {
  fn generate_replacement(&self, _nm: &NodeMatch<'_, D>) -> Underlying<D> {
    let range = self.range();
    self.root.doc.get_source().get_range(range).to_vec()
  }
}

enum MetaVarExtract {
  /// $A for captured meta var
  Single(MetaVariableID),
  /// $$$A for captured ellipsis
  Multiple(MetaVariableID),
  Transformed(MetaVariableID),
}

impl MetaVarExtract {
  fn used_var(&self) -> &str {
    match self {
      MetaVarExtract::Single(s) => s,
      MetaVarExtract::Multiple(s) => s,
      MetaVarExtract::Transformed(s) => s,
    }
  }
}

fn split_first_meta_var(
  src: &str,
  meta_char: char,
  transform: &[MetaVariableID],
) -> Option<(MetaVarExtract, usize)> {
  debug_assert!(src.starts_with(meta_char));
  let mut i = 0;
  let mut skipped = 0;
  let is_multi = loop {
    i += 1;
    skipped += meta_char.len_utf8();
    if i == 3 {
      break true;
    }
    if !src[skipped..].starts_with(meta_char) {
      break false;
    }
  };
  // no Anonymous meta var allowed, so _ is not allowed
  let i = src[skipped..]
    .find(|c: char| !is_valid_meta_var_char(c))
    .unwrap_or(src.len() - skipped);
  // no name found
  if i == 0 {
    return None;
  }
  let name = src[skipped..skipped + i].to_string();
  let var = if is_multi {
    MetaVarExtract::Multiple(name)
  } else if transform.contains(&name) {
    MetaVarExtract::Transformed(name)
  } else {
    MetaVarExtract::Single(name)
  };
  Some((var, skipped + i))
}



================================================
FILE: crates/core/src/source.rs
================================================
//! This module defines the `Doc` and `Content` traits to abstract away source code encoding issues.
//!
//! ast-grep supports three kinds of encoding: utf-8 for CLI, utf-16 for nodeJS napi and `Vec<char>` for wasm.
//! Different encoding will produce different tree-sitter Node's range and position.
//!
//! The `Content` trait is defined to abstract different encoding.
//! It is used as associated type bound `Source` in the `Doc` trait.
//! Its associated type `Underlying`  represents the underlying type of the content, e.g. `Vec<u8>`, `Vec<u16>`.
//!
//! `Doc` is a trait that defines a document that can be parsed by Tree-sitter.
//! It has a `Source` associated type bounded by `Content` that represents the source code of the document,
//! and a `Lang` associated type that represents the language of the document.

use crate::{language::Language, node::KindId, Position};
use std::borrow::Cow;
use std::ops::Range;

// https://github.com/tree-sitter/tree-sitter/blob/e4e5ffe517ca2c668689b24cb17c51b8c6db0790/cli/src/parse.rs
#[derive(Debug)]
pub struct Edit<S: Content> {
  pub position: usize,
  pub deleted_length: usize,
  pub inserted_text: Vec<S::Underlying>,
}

/// NOTE: Some method names are the same as tree-sitter's methods.
/// Fully Qualified Syntax may needed https://stackoverflow.com/a/44445976/2198656
pub trait SgNode<'r>: Clone {
  fn parent(&self) -> Option<Self>;
  fn children(&self) -> impl ExactSizeIterator<Item = Self>;
  fn kind(&self) -> Cow<'_, str>;
  fn kind_id(&self) -> KindId;
  fn node_id(&self) -> usize;
  fn range(&self) -> std::ops::Range<usize>;
  fn start_pos(&self) -> Position;
  fn end_pos(&self) -> Position;

  // default implentation
  fn ancestors(&self, _root: Self) -> impl Iterator<Item = Self> {
    let mut ancestors = vec![];
    let mut current = self.clone();
    while let Some(parent) = current.parent() {
      ancestors.push(parent.clone());
      current = parent;
    }
    ancestors.reverse();
    ancestors.into_iter()
  }
  fn dfs(&self) -> impl Iterator<Item = Self> {
    let mut stack = vec![self.clone()];
    std::iter::from_fn(move || {
      if let Some(node) = stack.pop() {
        let children: Vec<_> = node.children().collect();
        stack.extend(children.into_iter().rev());
        Some(node)
      } else {
        None
      }
    })
  }
  fn child(&self, nth: usize) -> Option<Self> {
    self.children().nth(nth)
  }
  fn next(&self) -> Option<Self> {
    let parent = self.parent()?;
    let mut children = parent.children();
    while let Some(child) = children.next() {
      if child.node_id() == self.node_id() {
        return children.next();
      }
    }
    None
  }
  fn prev(&self) -> Option<Self> {
    let parent = self.parent()?;
    let children = parent.children();
    let mut prev = None;
    for child in children {
      if child.node_id() == self.node_id() {
        return prev;
      }
      prev = Some(child);
    }
    None
  }
  fn next_all(&self) -> impl Iterator<Item = Self> {
    let mut next = self.next();
    std::iter::from_fn(move || {
      let n = next.clone()?;
      next = n.next();
      Some(n)
    })
  }
  fn prev_all(&self) -> impl Iterator<Item = Self> {
    let mut prev = self.prev();
    std::iter::from_fn(move || {
      let n = prev.clone()?;
      prev = n.prev();
      Some(n)
    })
  }
  fn is_named(&self) -> bool {
    true
  }
  /// N.B. it is different from is_named && is_leaf
  /// if a node has no named children.
  fn is_named_leaf(&self) -> bool {
    self.is_leaf()
  }
  fn is_leaf(&self) -> bool {
    self.children().count() == 0
  }

  // missing node is a tree-sitter specific concept
  fn is_missing(&self) -> bool {
    false
  }
  fn is_error(&self) -> bool {
    false
  }

  fn field(&self, name: &str) -> Option<Self>;
  fn field_children(&self, field_id: Option<u16>) -> impl Iterator<Item = Self>;
  fn child_by_field_id(&self, field_id: u16) -> Option<Self>;
}

pub trait Doc: Clone + 'static {
  type Source: Content;
  type Lang: Language;
  type Node<'r>: SgNode<'r>;
  fn get_lang(&self) -> &Self::Lang;
  fn get_source(&self) -> &Self::Source;
  fn do_edit(&mut self, edit: &Edit<Self::Source>) -> Result<(), String>;
  fn root_node(&self) -> Self::Node<'_>;
  fn get_node_text<'a>(&'a self, node: &Self::Node<'a>) -> Cow<'a, str>;
}

pub trait Content: Sized {
  type Underlying: Clone + PartialEq;
  fn get_range(&self, range: Range<usize>) -> &[Self::Underlying];
  /// Used for string replacement. We need this for
  /// indentation and deindentation.
  fn decode_str(src: &str) -> Cow<'_, [Self::Underlying]>;
  /// Used for string replacement. We need this for
  /// transformation.
  fn encode_bytes(bytes: &[Self::Underlying]) -> Cow<'_, str>;
  /// Get the character column at the given position
  fn get_char_column(&self, column: usize, offset: usize) -> usize;
}

impl Content for String {
  type Underlying = u8;
  fn get_range(&self, range: Range<usize>) -> &[Self::Underlying] {
    &self.as_bytes()[range]
  }
  fn decode_str(src: &str) -> Cow<'_, [Self::Underlying]> {
    Cow::Borrowed(src.as_bytes())
  }
  fn encode_bytes(bytes: &[Self::Underlying]) -> Cow<'_, str> {
    String::from_utf8_lossy(bytes)
  }

  /// This is an O(n) operation. We assume the col will not be a
  /// huge number in reality. This may be problematic for special
  /// files like compressed js
  fn get_char_column(&self, _col: usize, offset: usize) -> usize {
    let src = self.as_bytes();
    let mut col = 0;
    // TODO: is it possible to use SIMD here???
    for &b in src[..offset].iter().rev() {
      if b == b'\n' {
        break;
      }
      // https://en.wikipedia.org/wiki/UTF-8#Description
      if b & 0b1100_0000 != 0b1000_0000 {
        col += 1;
      }
    }
    col
  }
}



================================================
FILE: crates/core/src/match_tree/match_node.rs
================================================
use super::strictness::{MatchOneNode, MatchStrictness};
use super::Aggregator;
use crate::matcher::{kind_utils, PatternNode};
use crate::meta_var::MetaVariable;
use crate::{Doc, Node};
use std::iter::Peekable;

pub(super) fn match_node_impl<'tree, D: Doc>(
  goal: &PatternNode,
  candidate: &Node<'tree, D>,
  agg: &mut impl Aggregator<'tree, D>,
  strictness: &MatchStrictness,
) -> MatchOneNode {
  use PatternNode as P;
  match &goal {
    // leaf = without named children
    P::Terminal {
      text,
      kind_id,
      is_named,
    } => match strictness.match_terminal(*is_named, text, *kind_id, candidate) {
      MatchOneNode::MatchedBoth => {
        if agg.match_terminal(candidate).is_some() {
          MatchOneNode::MatchedBoth
        } else {
          MatchOneNode::NoMatch
        }
      }
      c => c,
    },
    P::MetaVar { meta_var, .. } => {
      if strictness.should_skip_cand_for_metavar(candidate) {
        return MatchOneNode::SkipCandidate;
      }
      match agg.match_meta_var(meta_var, candidate) {
        Some(()) => MatchOneNode::MatchedBoth,
        None => MatchOneNode::NoMatch, // TODO: this may be wrong
      }
    }
    P::Internal {
      kind_id, children, ..
    } => {
      let kind_matched = strictness.should_skip_kind()
        || kind_utils::are_kinds_matching(*kind_id, candidate.kind_id());
      if !kind_matched {
        return MatchOneNode::NoMatch;
      }
      let cand_children = candidate.children();
      match match_nodes_impl_recursive(children, cand_children, agg, strictness) {
        Some(()) => MatchOneNode::MatchedBoth,
        None => MatchOneNode::NoMatch,
      }
    }
  }
}

fn match_nodes_impl_recursive<'tree, D: Doc>(
  goals: &[PatternNode],
  candidates: impl Iterator<Item = Node<'tree, D>>,
  agg: &mut impl Aggregator<'tree, D>,
  strictness: &MatchStrictness,
) -> Option<()> {
  let mut goal_children = goals.iter().peekable();
  let mut cand_children = candidates.peekable();
  cand_children.peek()?;
  loop {
    match may_match_ellipsis_impl(&mut goal_children, &mut cand_children, agg, strictness)? {
      ControlFlow::Return => return Some(()),
      ControlFlow::Continue => continue,
      ControlFlow::Fallthrough => (),
    }
    match match_single_node_while_skip_trivial(
      &mut goal_children,
      &mut cand_children,
      agg,
      strictness,
    )? {
      ControlFlow::Return => return Some(()),
      ControlFlow::Continue => continue,
      ControlFlow::Fallthrough => (),
    }
    let consumed_goal = goal_children.next();
    // if goal runs out, do not proceed cand nodes
    if consumed_goal.is_some() {
      cand_children.next();
    }
    if goal_children.peek().is_none() {
      // all goal found
      let has_trailing = cand_children.all(|n| strictness.should_skip_trailing(&n));
      return has_trailing.then_some(());
    }
    cand_children.peek()?;
  }
}

enum ControlFlow {
  Continue,
  Fallthrough,
  Return,
}

/// returns None means no match
fn may_match_ellipsis_impl<'p, 't: 'p, D: Doc>(
  goal_children: &mut Peekable<impl Iterator<Item = &'p PatternNode>>,
  cand_children: &mut Peekable<impl Iterator<Item = Node<'t, D>>>,
  agg: &mut impl Aggregator<'t, D>,
  strictness: &MatchStrictness,
) -> Option<ControlFlow> {
  let Some(curr_node) = goal_children.peek() else {
    // in rare case, an internal node's children is empty
    // see https://github.com/ast-grep/ast-grep/issues/1688
    return Some(ControlFlow::Return);
  };
  let Ok(optional_name) = try_get_ellipsis_mode(curr_node) else {
    return Some(ControlFlow::Fallthrough);
  };
  let mut matched = vec![];
  goal_children.next();
  // goal has all matched
  if goal_children.peek().is_none() {
    match_ellipsis(agg, &optional_name, matched, cand_children, 0)?;
    return Some(ControlFlow::Return);
  }
  // skip trivial nodes in goal after ellipsis
  let mut skipped_anonymous = 0;
  while goal_children.peek().unwrap().is_trivial() {
    goal_children.next();
    skipped_anonymous += 1;
    if goal_children.peek().is_none() {
      match_ellipsis(
        agg,
        &optional_name,
        matched,
        cand_children,
        skipped_anonymous,
      )?;
      return Some(ControlFlow::Return);
    }
  }
  // if next node is a Ellipsis, consume one candidate node
  if try_get_ellipsis_mode(goal_children.peek().unwrap()).is_ok() {
    matched.push(cand_children.next().unwrap());
    cand_children.peek()?;
    match_ellipsis(
      agg,
      &optional_name,
      matched,
      std::iter::empty(),
      skipped_anonymous,
    )?;
    return Some(ControlFlow::Continue);
  }
  loop {
    if matches!(
      match_node_impl(
        goal_children.peek().unwrap(),
        cand_children.peek().unwrap(),
        agg,
        strictness,
      ),
      MatchOneNode::MatchedBoth
    ) {
      // found match non Ellipsis,
      match_ellipsis(
        agg,
        &optional_name,
        matched,
        std::iter::empty(),
        skipped_anonymous,
      )?;
      break Some(ControlFlow::Fallthrough);
    }
    matched.push(cand_children.next().unwrap());
    cand_children.peek()?;
  }
}

fn match_single_node_while_skip_trivial<'p, 't: 'p, D: Doc>(
  goal_children: &mut Peekable<impl Iterator<Item = &'p PatternNode>>,
  cand_children: &mut Peekable<impl Iterator<Item = Node<'t, D>>>,
  agg: &mut impl Aggregator<'t, D>,
  strictness: &MatchStrictness,
) -> Option<ControlFlow> {
  loop {
    let Some(cand) = cand_children.peek() else {
      // if cand runs out, check remaining goal
      // if goal is skippable, it is a match, else a non match
      return strictness
        .should_skip_goal(goal_children)
        .then_some(ControlFlow::Fallthrough);
    };
    // try match goal node with candidate node
    match match_node_impl(goal_children.peek().unwrap(), cand, agg, strictness) {
      MatchOneNode::MatchedBoth => return Some(ControlFlow::Fallthrough),
      MatchOneNode::SkipGoal => {
        goal_children.next();
        if goal_children.peek().is_none() {
          return Some(ControlFlow::Fallthrough);
        }
      }
      MatchOneNode::SkipBoth => {
        cand_children.next();
        goal_children.next();
        if goal_children.peek().is_none() {
          return Some(ControlFlow::Fallthrough);
        }
      }
      // skip trivial node
      MatchOneNode::SkipCandidate => {
        cand_children.next();
      }
      // unmatched significant node
      MatchOneNode::NoMatch => return None,
    }
  }
}

/// Returns Ok if ellipsis pattern is found. If the ellipsis is named, returns it name.
/// If the ellipsis is unnamed, returns None. If it is not ellipsis node, returns Err.
fn try_get_ellipsis_mode(node: &PatternNode) -> Result<Option<String>, ()> {
  let PatternNode::MetaVar { meta_var, .. } = node else {
    return Err(());
  };
  match meta_var {
    MetaVariable::Multiple => Ok(None),
    MetaVariable::MultiCapture(n) => Ok(Some(n.into())),
    _ => Err(()),
  }
}

fn match_ellipsis<'t, D: Doc>(
  agg: &mut impl Aggregator<'t, D>,
  optional_name: &Option<String>,
  mut matched: Vec<Node<'t, D>>,
  cand_children: impl Iterator<Item = Node<'t, D>>,
  skipped_anonymous: usize,
) -> Option<()> {
  matched.extend(cand_children);
  agg.match_ellipsis(optional_name.as_deref(), matched, skipped_anonymous)?;
  Some(())
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::matcher::KindMatcher;
  use crate::{meta_var::MetaVarEnv, Matcher, Pattern, Root};
  use std::borrow::Cow;
  fn match_tree(p: &str, n: &str, strictness: MatchStrictness) -> MatchOneNode {
    let pattern = Pattern::new(p, Tsx);
    let kind = pattern.potential_kinds().expect("should have kind");
    let kind = KindMatcher::from_id(kind.into_iter().next().expect("should have kind") as u16);
    let n = Root::str(n, Tsx);
    let n = n.root().find(kind).expect("should find");
    let mut env = Cow::Owned(MetaVarEnv::new());
    match_node_impl(&pattern.node, &*n, &mut env, &strictness)
  }
  fn matched(p: &str, n: &str, strictness: MatchStrictness) {
    let ret = match_tree(p, n, strictness);
    assert!(
      matches!(ret, MatchOneNode::MatchedBoth),
      "expect match. pattern: `{p}`, node: `{n}`"
    );
  }
  fn unmatched(p: &str, n: &str, strictness: MatchStrictness) {
    let ret = match_tree(p, n, strictness);
    assert!(
      !matches!(ret, MatchOneNode::MatchedBoth),
      "expect no match. pattern: `{p}`, node: `{n}`"
    );
  }
  use MatchStrictness as M;

  #[test]
  fn test_ast_match() {
    matched("import $A from 'lib'", "import A from \"lib\"", M::Ast);
    unmatched("$A(bar)", "foo(/* A*/bar)", M::Ast);
    matched("$A(bar)", "foo(bar)", M::Ast);
    unmatched("$A(bar)", "foo(bar, baz)", M::Ast);
    matched("print($A,)", "print(123)", M::Ast);
    matched("print($$$A,b,$$$C)", "print(b)", M::Ast);
    matched("print($$$A,b,$$$C)", "print(a, b)", M::Ast);
    matched("print($$$A,b,$$$C)", "print(a, b, c)", M::Ast);
    matched("print($$$A,b,$$$C)", "print(a, b, c,)", M::Ast);
  }

  #[test]
  fn test_relaxed_match() {
    matched("import $A from 'lib'", "import A from \"lib\"", M::Relaxed);
    matched("$A(bar)", "foo(/* A*/bar)", M::Relaxed);
    // fix https://github.com/ast-grep/ast-grep/issues/1848
    matched(
      "import { foo } from 'bar'",
      "import { foo, } from 'bar'",
      M::Relaxed,
    );
    matched("foo($A, $B)", "foo(1/*test*/, 2/*test*/)", M::Relaxed);
    unmatched(
      "import { foo } from 'bar'",
      "import { foo, bar, baz } from 'bar'",
      M::Relaxed,
    );
    unmatched(
      "import { foo } from 'bar'",
      "import { foo, bar } from 'bar'",
      M::Relaxed,
    );
  }

  #[test]
  fn test_cst_match() {
    unmatched("import $A from 'lib'", "import A from \"lib\"", M::Cst);
    unmatched("$A(bar)", "foo(/* A*/bar)", M::Cst);
    unmatched("print($A,)", "print(123)", M::Cst);
  }

  #[test]
  fn test_signature_match() {
    matched(
      "import $A from 'lib'",
      "import A from \"lib\"",
      M::Signature,
    );
    matched("$A(bar)", "foo(/* A*/bar)", M::Signature);
  }

  #[test]
  fn test_template_match() {
    matched("$A = $B", "a = 123", M::Template);
  }
}



================================================
FILE: crates/core/src/match_tree/mod.rs
================================================
mod match_node;
mod strictness;

use match_node::match_node_impl;
use strictness::MatchOneNode;
pub use strictness::MatchStrictness;

use crate::meta_var::{MetaVarEnv, MetaVariable};
use crate::{Doc, Node, Pattern};

use std::borrow::Cow;

trait Aggregator<'t, D: Doc> {
  fn match_terminal(&mut self, node: &Node<'t, D>) -> Option<()>;
  fn match_meta_var(&mut self, var: &MetaVariable, node: &Node<'t, D>) -> Option<()>;
  fn match_ellipsis(
    &mut self,
    var: Option<&str>,
    nodes: Vec<Node<'t, D>>,
    skipped_anonymous: usize,
  ) -> Option<()>;
}

struct ComputeEnd(usize);

impl<'t, D: Doc> Aggregator<'t, D> for ComputeEnd {
  fn match_terminal(&mut self, node: &Node<'t, D>) -> Option<()> {
    self.0 = node.range().end;
    Some(())
  }
  fn match_meta_var(&mut self, _: &MetaVariable, node: &Node<'t, D>) -> Option<()> {
    self.0 = node.range().end;
    Some(())
  }
  fn match_ellipsis(
    &mut self,
    _var: Option<&str>,
    nodes: Vec<Node<'t, D>>,
    _skipped: usize,
  ) -> Option<()> {
    let n = nodes.last()?;
    self.0 = n.range().end;
    Some(())
  }
}

pub fn match_end_non_recursive(goal: &Pattern, candidate: Node<impl Doc>) -> Option<usize> {
  let mut end = ComputeEnd(0);
  match match_node_impl(&goal.node, &candidate, &mut end, &goal.strictness) {
    MatchOneNode::MatchedBoth => Some(end.0),
    _ => None,
  }
}

fn match_leaf_meta_var<'tree, D: Doc>(
  mv: &MetaVariable,
  candidate: &Node<'tree, D>,
  env: &mut Cow<MetaVarEnv<'tree, D>>,
) -> Option<()> {
  use MetaVariable as MV;
  match mv {
    MV::Capture(name, named) => {
      if *named && !candidate.is_named() {
        None
      } else {
        env.to_mut().insert(name, candidate.clone())?;
        Some(())
      }
    }
    MV::Dropped(named) => {
      if *named && !candidate.is_named() {
        None
      } else {
        Some(())
      }
    }
    // Ellipsis will be matched in parent level
    MV::Multiple => {
      debug_assert!(false, "Ellipsis should be matched in parent level");
      Some(())
    }
    MV::MultiCapture(name) => {
      env.to_mut().insert(name, candidate.clone())?;
      Some(())
    }
  }
}

impl<'t, D: Doc> Aggregator<'t, D> for Cow<'_, MetaVarEnv<'t, D>> {
  fn match_terminal(&mut self, _: &Node<'t, D>) -> Option<()> {
    Some(())
  }
  fn match_meta_var(&mut self, var: &MetaVariable, node: &Node<'t, D>) -> Option<()> {
    match_leaf_meta_var(var, node, self)
  }
  fn match_ellipsis(
    &mut self,
    var: Option<&str>,
    nodes: Vec<Node<'t, D>>,
    skipped_anonymous: usize,
  ) -> Option<()> {
    if let Some(var) = var {
      let mut matched = nodes;
      let skipped = matched.len().saturating_sub(skipped_anonymous);
      drop(matched.drain(skipped..));
      self.to_mut().insert_multi(var, matched)?;
    }
    Some(())
  }
}

pub fn match_node_non_recursive<'tree, D: Doc>(
  goal: &Pattern,
  candidate: Node<'tree, D>,
  env: &mut Cow<MetaVarEnv<'tree, D>>,
) -> Option<Node<'tree, D>> {
  match match_node_impl(&goal.node, &candidate, env, &goal.strictness) {
    MatchOneNode::MatchedBoth => Some(candidate),
    _ => None,
  }
}

pub fn does_node_match_exactly<D: Doc>(goal: &Node<D>, candidate: &Node<D>) -> bool {
  // return true if goal and candidate are the same node
  if goal.node_id() == candidate.node_id() {
    return true;
  }
  // gh issue #1087, we make pattern matching a little bit more permissive
  // compare node text if at least one node is leaf
  if goal.is_named_leaf() || candidate.is_named_leaf() {
    return goal.text() == candidate.text();
  }
  if goal.kind_id() != candidate.kind_id() {
    return false;
  }
  let goal_children = goal.children();
  let cand_children = candidate.children();
  if goal_children.len() != cand_children.len() {
    return false;
  }
  goal_children
    .zip(cand_children)
    .all(|(g, c)| does_node_match_exactly(&g, &c))
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::meta_var::MetaVarEnv;
  use crate::tree_sitter::StrDoc;
  use crate::{Node, Root};
  use std::collections::HashMap;

  fn find_node_recursive<'tree>(
    goal: &Pattern,
    node: Node<'tree, StrDoc<Tsx>>,
    env: &mut Cow<MetaVarEnv<'tree, StrDoc<Tsx>>>,
  ) -> Option<Node<'tree, StrDoc<Tsx>>> {
    match_node_non_recursive(goal, node.clone(), env).or_else(|| {
      node
        .children()
        .find_map(|sub| find_node_recursive(goal, sub, env))
    })
  }

  fn test_match(s1: &str, s2: &str) -> HashMap<String, String> {
    let goal = Pattern::new(s1, Tsx);
    let cand = Root::str(s2, Tsx);
    let cand = cand.root();
    let mut env = Cow::Owned(MetaVarEnv::new());
    let ret = find_node_recursive(&goal, cand.clone(), &mut env);
    assert!(
      ret.is_some(),
      "goal: {goal:?}, candidate: {}",
      cand.get_inner_node().to_sexp(),
    );
    HashMap::from(env.into_owned())
  }

  fn test_non_match(s1: &str, s2: &str) {
    let goal = Pattern::new(s1, Tsx);
    let cand = Root::str(s2, Tsx);
    let cand = cand.root();
    let mut env = Cow::Owned(MetaVarEnv::new());
    let ret = find_node_recursive(&goal, cand, &mut env);
    assert!(ret.is_none());
  }

  #[test]
  fn test_simple_match() {
    test_match("const a = 123", "const a=123");
    test_non_match("const a = 123", "var a = 123");
  }

  #[test]
  fn test_nested_match() {
    test_match("const a = 123", "function() {const a= 123;}");
    test_match("const a = 123", "class A { constructor() {const a= 123;}}");
    test_match(
      "const a = 123",
      "for (let a of []) while (true) { const a = 123;}",
    );
  }

  #[test]
  fn test_should_exactly_match() {
    test_match(
      "function foo() { let a = 123; }",
      "function foo() { let a = 123; }",
    );
    test_non_match(
      "function foo() { let a = 123; }",
      "function bar() { let a = 123; }",
    );
  }

  #[test]
  fn test_match_inner() {
    test_match(
      "function bar() { let a = 123; }",
      "function foo() { function bar() {let a = 123; }}",
    );
    test_non_match(
      "function foo() { let a = 123; }",
      "function foo() { function bar() {let a = 123; }}",
    );
  }

  #[test]
  fn test_single_ellipsis() {
    test_match("foo($$$)", "foo(a, b, c)");
    test_match("foo($$$)", "foo()");
  }
  #[test]
  fn test_named_ellipsis() {
    test_match("foo($$$A, c)", "foo(a, b, c)");
    test_match("foo($$$A, b, c)", "foo(a, b, c)");
    test_match("foo($$$A, a, b, c)", "foo(a, b, c)");
    test_non_match("foo($$$A, a, b, c)", "foo(b, c)");
  }

  #[test]
  fn test_leading_ellipsis() {
    test_match("foo($$$, c)", "foo(a, b, c)");
    test_match("foo($$$, b, c)", "foo(a, b, c)");
    test_match("foo($$$, a, b, c)", "foo(a, b, c)");
    test_non_match("foo($$$, a, b, c)", "foo(b, c)");
  }
  #[test]
  fn test_trailing_ellipsis() {
    test_match("foo(a, $$$)", "foo(a, b, c)");
    test_match("foo(a, b, $$$)", "foo(a, b, c)");
    // test_match("foo(a, b, c, $$$)", "foo(a, b, c)");
    test_non_match("foo(a, b, c, $$$)", "foo(b, c)");
  }

  #[test]
  fn test_meta_var_named() {
    test_match("return $A", "return 123;");
    test_match("return $_", "return 123;");
    test_non_match("return $A", "return;");
    test_non_match("return $_", "return;");
    test_match("return $$A", "return;");
    test_match("return $$_A", "return;");
  }

  #[test]
  fn test_meta_var_multiple_occurrence() {
    test_match("$A($$$)", "test(123)");
    test_match("$A($B)", "test(123)");
    test_non_match("$A($A)", "test(aaa)");
    test_non_match("$A($A)", "test(123)");
    test_non_match("$A($A, $A)", "test(123, 456)");
    test_match("$A($A)", "test(test)");
    test_non_match("$A($A)", "foo(bar)");
  }

  #[test]
  fn test_string() {
    test_match("'a'", "'a'");
    test_match("'abcdefg'", "'abcdefg'");
    test_match("`abcdefg`", "`abcdefg`");
    test_non_match("'a'", "'b'");
    test_non_match("'abcdefg'", "'gggggg'");
  }

  #[test]
  fn test_skip_trivial_node() {
    test_match("foo($A, $B)", "foo(a, b,)");
    test_match("class A { b() {}}", "class A { get b() {}}");
  }

  #[test]
  fn test_trivia_in_pattern() {
    test_match("foo($A, $B,)", "foo(a, b,)");
    test_non_match("foo($A, $B,)", "foo(a, b)");
    test_match("class A { get b() {}}", "class A { get b() {}}");
    test_non_match("class A { get b() {}}", "class A { b() {}}");
  }

  fn find_end_recursive(goal: &Pattern, node: Node<StrDoc<Tsx>>) -> Option<usize> {
    match_end_non_recursive(goal, node.clone()).or_else(|| {
      node
        .children()
        .find_map(|sub| find_end_recursive(goal, sub))
    })
  }

  fn test_end(s1: &str, s2: &str) -> Option<usize> {
    let goal = Pattern::new(s1, Tsx);
    let cand = Root::str(s2, Tsx);
    let cand = cand.root();
    find_end_recursive(&goal, cand.clone())
  }

  #[test]
  fn test_match_end() {
    let end = test_end("return $A", "return 123 /* trivia */");
    assert_eq!(end.expect("should work"), 10);
    let end = test_end("return f($A)", "return f(1,) /* trivia */");
    assert_eq!(end.expect("should work"), 12);
  }

  // see https://github.com/ast-grep/ast-grep/issues/411
  #[test]
  fn test_ellipsis_end() {
    let end = test_end(
      "import {$$$A, B, $$$C} from 'a'",
      "import {A, B, C} from 'a'",
    );
    assert_eq!(end.expect("must match"), 25);
  }

  #[test]
  fn test_gh_1087() {
    test_match("($P) => $F($P)", "(x) => bar(x)");
  }
}



================================================
FILE: crates/core/src/match_tree/strictness.rs
================================================
use crate::matcher::{kind_utils, PatternNode};
use crate::meta_var::MetaVariable;
use crate::node::Node;
use crate::Doc;
use std::iter::Peekable;
use std::str::FromStr;

#[derive(Clone)]
pub enum MatchStrictness {
  Cst,       // all nodes are matched
  Smart,     // all nodes except source trivial nodes are matched.
  Ast,       // only ast nodes are matched
  Relaxed,   // ast-nodes excluding comments are matched
  Signature, // ast-nodes excluding comments, without text
  Template,  // similar to smart, but node kinds are ignored, only text is matched.
}

pub(crate) enum MatchOneNode {
  MatchedBoth,
  SkipBoth,
  SkipGoal,
  SkipCandidate,
  NoMatch,
}

fn skip_comment(n: &Node<impl Doc>) -> bool {
  n.kind().contains("comment")
}

fn skip_comment_or_unnamed(n: &Node<impl Doc>) -> bool {
  if !n.is_named() {
    return true;
  }
  skip_comment(n)
}

impl MatchStrictness {
  pub(crate) fn should_skip_kind(&self) -> bool {
    use MatchStrictness as M;
    match self {
      M::Template => true,
      M::Cst => false,
      M::Smart => false,
      M::Ast => false,
      M::Relaxed => false,
      M::Signature => false,
    }
  }

  fn should_skip_comment(&self) -> bool {
    use MatchStrictness as M;
    match self {
      M::Cst | M::Smart | M::Ast => false,
      M::Relaxed | M::Signature | M::Template => true,
    }
  }

  pub(crate) fn match_terminal(
    &self,
    is_named: bool,
    text: &str,
    goal_kind: u16,
    candidate: &Node<impl Doc>,
  ) -> MatchOneNode {
    use MatchStrictness as M;
    let cand_kind = candidate.kind_id();
    let is_kind_matched = kind_utils::are_kinds_matching(goal_kind, cand_kind);
    // work around ast-grep/ast-grep#1419 and tree-sitter/tree-sitter-typescript#306
    // tree-sitter-typescript has wrong span of unnamed node so text would not match
    // just compare kind for unnamed node
    if is_kind_matched && (!is_named || text == candidate.text()) {
      return MatchOneNode::MatchedBoth;
    }
    if self.should_skip_comment() && skip_comment(candidate) {
      return MatchOneNode::SkipCandidate;
    }
    let (skip_goal, skip_candidate) = match self {
      M::Cst => (false, false),
      M::Smart => (false, !candidate.is_named()),
      M::Ast => (!is_named, !candidate.is_named()),
      M::Relaxed => (!is_named, !candidate.is_named()),
      M::Signature => {
        if is_kind_matched {
          return MatchOneNode::MatchedBoth;
        }
        (!is_named, !candidate.is_named())
      }
      M::Template => {
        if text == candidate.text() {
          return MatchOneNode::MatchedBoth;
        } else {
          (false, !candidate.is_named())
        }
      }
    };
    match (skip_goal, skip_candidate) {
      (true, true) => MatchOneNode::SkipBoth,
      (true, false) => MatchOneNode::SkipGoal,
      (false, true) => MatchOneNode::SkipCandidate,
      (false, false) => MatchOneNode::NoMatch,
    }
  }

  pub(crate) fn should_skip_cand_for_metavar<D: Doc>(&self, candidate: &Node<D>) -> bool {
    use MatchStrictness as M;
    match self {
      M::Cst | M::Ast | M::Smart => false,
      M::Relaxed | M::Signature | M::Template => skip_comment(candidate),
    }
  }

  // TODO: this is a method for working around trailing nodes after pattern is matched
  pub(crate) fn should_skip_trailing<D: Doc>(&self, candidate: &Node<D>) -> bool {
    use MatchStrictness as M;
    match self {
      M::Cst => false,
      M::Smart => true,
      M::Ast => false,
      M::Relaxed => skip_comment_or_unnamed(candidate),
      M::Signature => skip_comment_or_unnamed(candidate),
      M::Template => skip_comment(candidate),
    }
  }

  pub(crate) fn should_skip_goal<'p>(
    &self,
    goal_children: &mut Peekable<impl Iterator<Item = &'p PatternNode>>,
  ) -> bool {
    use MatchStrictness as M;
    while let Some(pattern) = goal_children.peek() {
      let skipped = match self {
        M::Cst => false,
        M::Smart | M::Template => match pattern {
          PatternNode::MetaVar { meta_var } => match meta_var {
            MetaVariable::Multiple => true,
            MetaVariable::MultiCapture(_) => true,
            MetaVariable::Dropped(_) => false,
            MetaVariable::Capture(..) => false,
          },
          PatternNode::Terminal { .. } => false,
          PatternNode::Internal { .. } => false,
        },
        M::Ast | M::Relaxed | M::Signature => match pattern {
          PatternNode::MetaVar { meta_var } => match meta_var {
            MetaVariable::Multiple => true,
            MetaVariable::MultiCapture(_) => true,
            MetaVariable::Dropped(named) => !named,
            MetaVariable::Capture(_, named) => !named,
          },
          PatternNode::Terminal { is_named, .. } => !is_named,
          PatternNode::Internal { .. } => false,
        },
      };
      if !skipped {
        return false;
      }
      goal_children.next();
    }
    true
  }
}

impl FromStr for MatchStrictness {
  type Err = &'static str;
  fn from_str(s: &str) -> Result<Self, Self::Err> {
    match s {
      "cst" => Ok(MatchStrictness::Cst),
      "smart" => Ok(MatchStrictness::Smart),
      "ast" => Ok(MatchStrictness::Ast),
      "relaxed" => Ok(MatchStrictness::Relaxed),
      "signature" => Ok(MatchStrictness::Signature),
      "template" => Ok(MatchStrictness::Template),
      _ => Err("invalid strictness, valid options are: cst, smart, ast, relaxed, signature"),
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::{Pattern, Root};

  fn test_match(p: &str, n: &str, strictness: MatchStrictness) -> bool {
    let mut pattern = Pattern::new(p, Tsx);
    pattern.strictness = strictness;
    let root = Root::str(n, Tsx);
    let node = root.root();
    node.find(pattern).is_some()
  }

  fn template_pattern(p: &str, n: &str) -> bool {
    test_match(p, n, MatchStrictness::Template)
  }

  #[test]
  fn test_template_pattern() {
    assert!(template_pattern("$A = $B", "a = b"));
    assert!(template_pattern("$A = $B", "var a = b"));
    assert!(template_pattern("$A = $B", "let a = b"));
    assert!(template_pattern("$A = $B", "const a = b"));
    assert!(template_pattern("$A = $B", "class A { a = b }"));
  }

  fn relaxed_pattern(p: &str, n: &str) -> bool {
    test_match(p, n, MatchStrictness::Relaxed)
  }

  #[test]
  fn test_ignore_comment() {
    assert!(relaxed_pattern("$A($B)", "foo(bar /* .. */)"));
    assert!(relaxed_pattern(
      "$A($B)",
      "
      foo(
        bar, // ..
      )"
    ));
    assert!(relaxed_pattern("$A($B)", "foo(/* .. */ bar)"));
    assert!(relaxed_pattern(
      "$A($B)",
      "
      foo( // ..
        bar
      )"
    ));
  }
}



================================================
FILE: crates/core/src/matcher/kind.rs
================================================
use super::Matcher;

use crate::language::Language;
use crate::meta_var::MetaVarEnv;
use crate::node::KindId;
use crate::{Doc, Node};

use std::borrow::Cow;

use bit_set::BitSet;
use thiserror::Error;

// 0 is symbol_end for not found, 65535 is builtin symbol ERROR
// see https://tree-sitter.docsforge.com/master/api/#TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION
// and https://tree-sitter.docsforge.com/master/api/ts_language_symbol_for_name/
const TS_BUILTIN_SYM_END: KindId = 0;
const TS_BUILTIN_SYM_ERROR: KindId = 65535;

#[derive(Debug, Error)]
pub enum KindMatcherError {
  #[error("Kind `{0}` is invalid.")]
  InvalidKindName(String),
}

#[derive(Clone)]
pub struct KindMatcher {
  kind: KindId,
}

impl KindMatcher {
  pub fn new<L: Language>(node_kind: &str, lang: L) -> Self {
    Self {
      kind: lang.kind_to_id(node_kind),
    }
  }

  pub fn try_new<L: Language>(node_kind: &str, lang: L) -> Result<Self, KindMatcherError> {
    let s = Self::new(node_kind, lang);
    if s.is_invalid() {
      Err(KindMatcherError::InvalidKindName(node_kind.into()))
    } else {
      Ok(s)
    }
  }

  pub fn from_id(kind: KindId) -> Self {
    Self { kind }
  }

  /// Whether the kind matcher contains undefined tree-sitter kind.
  pub fn is_invalid(&self) -> bool {
    self.kind == TS_BUILTIN_SYM_END
  }

  /// Construct a matcher that only matches ERROR
  pub fn error_matcher() -> Self {
    Self::from_id(TS_BUILTIN_SYM_ERROR)
  }
}

pub mod kind_utils {
  use super::*;

  /// Whether the kind will match parsing error occurred in the source code.
  /// for example, we can use `kind: ERROR` in YAML to find invalid syntax in source.
  /// the name `is_error` implies the matcher itself is error.
  /// But here the matcher itself is valid and it is what it matches is error.
  pub fn is_error_kind(kind: KindId) -> bool {
    kind == TS_BUILTIN_SYM_ERROR
  }

  pub fn are_kinds_matching(goal: KindId, candidate: KindId) -> bool {
    goal == candidate || is_error_kind(goal)
  }
}

impl Matcher for KindMatcher {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if node.kind_id() == self.kind {
      Some(node)
    } else {
      None
    }
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    let mut set = BitSet::new();
    set.insert(self.kind.into());
    Some(set)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::matcher::MatcherExt;
  use crate::{tree_sitter::StrDoc, Root};

  fn pattern_node(s: &str) -> Root<StrDoc<Tsx>> {
    Root::str(s, Tsx)
  }
  #[test]
  fn test_kind_match() {
    let kind = "public_field_definition";
    let cand = pattern_node("class A { a = 123 }");
    let cand = cand.root();
    let pattern = KindMatcher::new(kind, Tsx);
    assert!(
      pattern.find_node(cand.clone()).is_some(),
      "goal: {}, candidate: {}",
      kind,
      cand.get_inner_node().to_sexp(),
    );
  }

  #[test]
  fn test_kind_non_match() {
    let kind = "field_definition";
    let cand = pattern_node("const a = 123");
    let cand = cand.root();
    let pattern = KindMatcher::new(kind, Tsx);
    assert!(
      pattern.find_node(cand.clone()).is_none(),
      "goal: {}, candidate: {}",
      kind,
      cand.get_inner_node().to_sexp(),
    );
  }

  #[test]
  fn test_kind_potential_kinds() {
    let kind = "field_definition";
    let matcher = KindMatcher::new(kind, Tsx);
    let potential_kinds = matcher
      .potential_kinds()
      .expect("should have potential kinds");
    // should has exactly one potential kind
    assert_eq!(potential_kinds.len(), 1);
  }
}



================================================
FILE: crates/core/src/matcher/node_match.rs
================================================
use super::Matcher;
use crate::meta_var::MetaVarEnv;
use crate::replacer::Replacer;
use crate::source::Edit as E;
use crate::{Doc, Node};

use std::borrow::Borrow;
use std::ops::Deref;

type Edit<D> = E<<D as Doc>::Source>;

/// Represents the matched node with populated MetaVarEnv.
/// It derefs to the Node so you can use it as a Node.
/// To access the underlying MetaVarEnv, call `get_env` method.
#[derive(Clone)]
pub struct NodeMatch<'t, D: Doc>(Node<'t, D>, MetaVarEnv<'t, D>);

impl<'tree, D: Doc> NodeMatch<'tree, D> {
  pub fn new(node: Node<'tree, D>, env: MetaVarEnv<'tree, D>) -> Self {
    Self(node, env)
  }

  pub fn get_node(&self) -> &Node<'tree, D> {
    &self.0
  }

  /// Returns the populated MetaVarEnv for this match.
  pub fn get_env(&self) -> &MetaVarEnv<'tree, D> {
    &self.1
  }
  pub fn get_env_mut(&mut self) -> &mut MetaVarEnv<'tree, D> {
    &mut self.1
  }
  /// # Safety
  /// should only called for readopting nodes
  pub(crate) unsafe fn get_node_mut(&mut self) -> &mut Node<'tree, D> {
    &mut self.0
  }
}

impl<D: Doc> NodeMatch<'_, D> {
  pub fn replace_by<R: Replacer<D>>(&self, replacer: R) -> Edit<D> {
    let range = self.range();
    let position = range.start;
    let deleted_length = range.len();
    let inserted_text = replacer.generate_replacement(self);
    Edit::<D> {
      position,
      deleted_length,
      inserted_text,
    }
  }

  #[doc(hidden)]
  pub fn make_edit<M, R>(&self, matcher: &M, replacer: &R) -> Edit<D>
  where
    M: Matcher,
    R: Replacer<D>,
  {
    let range = replacer.get_replaced_range(self, matcher);
    let inserted_text = replacer.generate_replacement(self);
    Edit::<D> {
      position: range.start,
      deleted_length: range.len(),
      inserted_text,
    }
  }
}

impl<'tree, D: Doc> From<Node<'tree, D>> for NodeMatch<'tree, D> {
  fn from(node: Node<'tree, D>) -> Self {
    Self(node, MetaVarEnv::new())
  }
}

/// NodeMatch is an immutable view to Node
impl<'tree, D: Doc> From<NodeMatch<'tree, D>> for Node<'tree, D> {
  fn from(node_match: NodeMatch<'tree, D>) -> Self {
    node_match.0
  }
}

/// NodeMatch is an immutable view to Node
impl<'tree, D: Doc> Deref for NodeMatch<'tree, D> {
  type Target = Node<'tree, D>;
  fn deref(&self) -> &Self::Target {
    &self.0
  }
}

/// NodeMatch is an immutable view to Node
impl<'tree, D: Doc> Borrow<Node<'tree, D>> for NodeMatch<'tree, D> {
  fn borrow(&self) -> &Node<'tree, D> {
    &self.0
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::tree_sitter::{LanguageExt, StrDoc};

  fn use_node<L: LanguageExt>(n: &Node<StrDoc<L>>) -> String {
    n.text().to_string()
  }

  fn borrow_node<'a, D, B>(b: B) -> String
  where
    D: Doc + 'static,
    B: Borrow<Node<'a, D>>,
  {
    b.borrow().text().to_string()
  }

  #[test]
  fn test_node_match_as_node() {
    let root = Tsx.ast_grep("var a = 1");
    let node = root.root();
    let src = node.text().to_string();
    let nm = NodeMatch::from(node);
    let ret = use_node(&*nm);
    assert_eq!(ret, src);
    assert_eq!(use_node(&*nm), borrow_node(nm));
  }

  #[test]
  fn test_node_env() {
    let root = Tsx.ast_grep("var a = 1");
    let find = root.root().find("var $A = 1").expect("should find");
    let env = find.get_env();
    let node = env.get_match("A").expect("should find");
    assert_eq!(node.text(), "a");
  }

  #[test]
  fn test_replace_by() {
    let root = Tsx.ast_grep("var a = 1");
    let find = root.root().find("var $A = 1").expect("should find");
    let fixed = find.replace_by("var b = $A");
    assert_eq!(fixed.position, 0);
    assert_eq!(fixed.deleted_length, 9);
    assert_eq!(fixed.inserted_text, "var b = a".as_bytes());
  }
}



================================================
FILE: crates/core/src/matcher/pattern.rs
================================================
use crate::language::Language;
use crate::match_tree::{match_end_non_recursive, match_node_non_recursive, MatchStrictness};
use crate::matcher::{kind_utils, KindMatcher, KindMatcherError, Matcher};
use crate::meta_var::{MetaVarEnv, MetaVariable};
use crate::source::SgNode;
use crate::{Doc, Node, Root};

use bit_set::BitSet;
use thiserror::Error;

use std::borrow::Cow;
use std::collections::HashSet;

#[derive(Clone)]
pub struct Pattern {
  pub node: PatternNode,
  root_kind: Option<u16>,
  pub strictness: MatchStrictness,
}

pub struct PatternBuilder<'a> {
  selector: Option<&'a str>,
  src: Cow<'a, str>,
}

impl PatternBuilder<'_> {
  pub fn build<D, F>(&self, parse: F) -> Result<Pattern, PatternError>
  where
    F: FnOnce(&str) -> Result<D, String>,
    D: Doc,
  {
    let doc = parse(&self.src).map_err(PatternError::Parse)?;
    let root = Root::doc(doc);
    if let Some(selector) = self.selector {
      self.contextual(&root, selector)
    } else {
      self.single(&root)
    }
  }
  fn single<D: Doc>(&self, root: &Root<D>) -> Result<Pattern, PatternError> {
    let goal = root.root();
    if goal.children().len() == 0 {
      return Err(PatternError::NoContent(self.src.to_string()));
    }
    if !is_single_node(&goal.inner) {
      return Err(PatternError::MultipleNode(self.src.to_string()));
    }
    let node = Pattern::single_matcher(root);
    Ok(Pattern::from(node))
  }

  fn contextual<D: Doc>(&self, root: &Root<D>, selector: &str) -> Result<Pattern, PatternError> {
    let goal = root.root();
    let kind_matcher = KindMatcher::try_new(selector, root.lang().clone())?;
    let Some(node) = goal.find(&kind_matcher) else {
      return Err(PatternError::NoSelectorInContext {
        context: self.src.to_string(),
        selector: selector.into(),
      });
    };
    Ok(Pattern {
      root_kind: Some(node.kind_id()),
      node: convert_node_to_pattern(node.get_node().clone()),
      strictness: MatchStrictness::Smart,
    })
  }
}

#[derive(Clone)]
pub enum PatternNode {
  MetaVar {
    meta_var: MetaVariable,
  },
  /// Node without children.
  Terminal {
    text: String,
    is_named: bool,
    kind_id: u16,
  },
  /// Non-Terminal Syntax Nodes are called Internal
  Internal {
    kind_id: u16,
    children: Vec<PatternNode>,
  },
}

impl PatternNode {
  // for skipping trivial nodes in goal after ellipsis
  pub fn is_trivial(&self) -> bool {
    match self {
      PatternNode::Terminal { is_named, .. } => !*is_named,
      _ => false,
    }
  }

  pub fn fixed_string(&self) -> Cow<'_, str> {
    match &self {
      PatternNode::Terminal { text, .. } => Cow::Borrowed(text),
      PatternNode::MetaVar { .. } => Cow::Borrowed(""),
      PatternNode::Internal { children, .. } => {
        children
          .iter()
          .map(|n| n.fixed_string())
          .fold(Cow::Borrowed(""), |longest, curr| {
            if longest.len() >= curr.len() {
              longest
            } else {
              curr
            }
          })
      }
    }
  }
}
impl<'r, D: Doc> From<Node<'r, D>> for PatternNode {
  fn from(node: Node<'r, D>) -> Self {
    convert_node_to_pattern(node)
  }
}

impl<'r, D: Doc> From<Node<'r, D>> for Pattern {
  fn from(node: Node<'r, D>) -> Self {
    Self {
      node: convert_node_to_pattern(node),
      root_kind: None,
      strictness: MatchStrictness::Smart,
    }
  }
}

fn convert_node_to_pattern<D: Doc>(node: Node<'_, D>) -> PatternNode {
  if let Some(meta_var) = extract_var_from_node(&node) {
    PatternNode::MetaVar { meta_var }
  } else if node.is_leaf() {
    PatternNode::Terminal {
      text: node.text().to_string(),
      is_named: node.is_named(),
      kind_id: node.kind_id(),
    }
  } else {
    let children = node.children().filter_map(|n| {
      if n.is_missing() {
        None
      } else {
        Some(PatternNode::from(n))
      }
    });
    PatternNode::Internal {
      kind_id: node.kind_id(),
      children: children.collect(),
    }
  }
}

fn extract_var_from_node<D: Doc>(goal: &Node<'_, D>) -> Option<MetaVariable> {
  let key = goal.text();
  goal.lang().extract_meta_var(&key)
}

#[derive(Debug, Error)]
pub enum PatternError {
  #[error("Fails to parse the pattern query: `{0}`")]
  Parse(String),
  #[error("No AST root is detected. Please check the pattern source `{0}`.")]
  NoContent(String),
  #[error("Multiple AST nodes are detected. Please check the pattern source `{0}`.")]
  MultipleNode(String),
  #[error(transparent)]
  InvalidKind(#[from] KindMatcherError),
  #[error("Fails to create Contextual pattern: selector `{selector}` matches no node in the context `{context}`.")]
  NoSelectorInContext { context: String, selector: String },
}

#[inline]
fn is_single_node<'r, N: SgNode<'r>>(n: &N) -> bool {
  match n.children().len() {
    1 => true,
    2 => {
      let c = n.child(1).expect("second child must exist");
      // some language will have weird empty syntax node at the end
      // see golang's `$A = 0` pattern test case
      c.is_missing() || c.kind().is_empty()
    }
    _ => false,
  }
}
impl Pattern {
  pub fn has_error(&self) -> bool {
    let kind = match &self.node {
      PatternNode::Terminal { kind_id, .. } => *kind_id,
      PatternNode::Internal { kind_id, .. } => *kind_id,
      PatternNode::MetaVar { .. } => match self.root_kind {
        Some(k) => k,
        None => return false,
      },
    };
    kind_utils::is_error_kind(kind)
  }

  pub fn fixed_string(&self) -> Cow<'_, str> {
    self.node.fixed_string()
  }

  /// Get all defined variables in the pattern.
  /// Used for validating rules and report undefined variables.
  pub fn defined_vars(&self) -> HashSet<&str> {
    let mut vars = HashSet::new();
    collect_vars(&self.node, &mut vars);
    vars
  }
}

fn meta_var_name(meta_var: &MetaVariable) -> Option<&str> {
  use MetaVariable as MV;
  match meta_var {
    MV::Capture(name, _) => Some(name),
    MV::MultiCapture(name) => Some(name),
    MV::Dropped(_) => None,
    MV::Multiple => None,
  }
}

fn collect_vars<'p>(p: &'p PatternNode, vars: &mut HashSet<&'p str>) {
  match p {
    PatternNode::MetaVar { meta_var, .. } => {
      if let Some(name) = meta_var_name(meta_var) {
        vars.insert(name);
      }
    }
    PatternNode::Terminal { .. } => {
      // collect nothing for terminal nodes!
    }
    PatternNode::Internal { children, .. } => {
      for c in children {
        collect_vars(c, vars);
      }
    }
  }
}

impl Pattern {
  pub fn try_new<L: Language>(src: &str, lang: L) -> Result<Self, PatternError> {
    let processed = lang.pre_process_pattern(src);
    let builder = PatternBuilder {
      selector: None,
      src: processed,
    };
    lang.build_pattern(&builder)
  }

  pub fn new<L: Language>(src: &str, lang: L) -> Self {
    Self::try_new(src, lang).unwrap()
  }

  pub fn with_strictness(mut self, strictness: MatchStrictness) -> Self {
    self.strictness = strictness;
    self
  }

  pub fn contextual<L: Language>(
    context: &str,
    selector: &str,
    lang: L,
  ) -> Result<Self, PatternError> {
    let processed = lang.pre_process_pattern(context);
    let builder = PatternBuilder {
      selector: Some(selector),
      src: processed,
    };
    lang.build_pattern(&builder)
  }
  fn single_matcher<D: Doc>(root: &Root<D>) -> Node<'_, D> {
    // debug_assert!(matches!(self.style, PatternStyle::Single));
    let node = root.root();
    let mut inner = node.inner;
    while is_single_node(&inner) {
      inner = inner.child(0).unwrap();
    }
    Node { inner, root }
  }
}

impl Matcher for Pattern {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    if let Some(k) = self.root_kind {
      if node.kind_id() != k {
        return None;
      }
    }
    // do not pollute the env if pattern does not match
    let mut may_write = Cow::Borrowed(env.as_ref());
    let node = match_node_non_recursive(self, node, &mut may_write)?;
    if let Cow::Owned(map) = may_write {
      // only change env when pattern matches
      *env = Cow::Owned(map);
    }
    Some(node)
  }

  fn potential_kinds(&self) -> Option<bit_set::BitSet> {
    // if strictness is Template, we can match any kind
    if matches!(self.strictness, MatchStrictness::Template) {
      return None;
    }
    let kind = match self.node {
      PatternNode::Terminal { kind_id, .. } => kind_id,
      PatternNode::MetaVar { .. } => self.root_kind?,
      PatternNode::Internal { kind_id, .. } => {
        if kind_utils::is_error_kind(kind_id) {
          // error can match any kind
          return None;
        }
        kind_id
      }
    };

    let mut kinds = BitSet::new();
    kinds.insert(kind.into());
    Some(kinds)
  }

  fn get_match_len<D: Doc>(&self, node: Node<'_, D>) -> Option<usize> {
    let start = node.range().start;
    let end = match_end_non_recursive(self, node)?;
    Some(end - start)
  }
}
impl std::fmt::Debug for PatternNode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      Self::MetaVar { meta_var, .. } => write!(f, "{meta_var:?}"),
      Self::Terminal { text, .. } => write!(f, "{text}"),
      Self::Internal { children, .. } => write!(f, "{children:?}"),
    }
  }
}

impl std::fmt::Debug for Pattern {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{:?}", self.node)
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use crate::matcher::MatcherExt;
  use crate::meta_var::MetaVarEnv;
  use crate::tree_sitter::StrDoc;
  use std::collections::HashMap;

  fn pattern_node(s: &str) -> Root<StrDoc<Tsx>> {
    Root::str(s, Tsx)
  }

  fn test_match(s1: &str, s2: &str) {
    let pattern = Pattern::new(s1, Tsx);
    let cand = pattern_node(s2);
    let cand = cand.root();
    assert!(
      pattern.find_node(cand.clone()).is_some(),
      "goal: {:?}, candidate: {}",
      pattern,
      cand.get_inner_node().to_sexp(),
    );
  }
  fn test_non_match(s1: &str, s2: &str) {
    let pattern = Pattern::new(s1, Tsx);
    let cand = pattern_node(s2);
    let cand = cand.root();
    assert!(
      pattern.find_node(cand.clone()).is_none(),
      "goal: {:?}, candidate: {}",
      pattern,
      cand.get_inner_node().to_sexp(),
    );
  }

  #[test]
  fn test_meta_variable() {
    test_match("const a = $VALUE", "const a = 123");
    test_match("const $VARIABLE = $VALUE", "const a = 123");
    test_match("const $VARIABLE = $VALUE", "const a = 123");
  }

  #[test]
  fn test_whitespace() {
    test_match("function t() { }", "function t() {}");
    test_match("function t() {}", "function t() {  }");
  }

  fn match_env(goal_str: &str, cand: &str) -> HashMap<String, String> {
    let pattern = Pattern::new(goal_str, Tsx);
    let cand = pattern_node(cand);
    let cand = cand.root();
    let nm = pattern.find_node(cand).unwrap();
    HashMap::from(nm.get_env().clone())
  }

  #[test]
  fn test_meta_variable_env() {
    let env = match_env("const a = $VALUE", "const a = 123");
    assert_eq!(env["VALUE"], "123");
  }

  #[test]
  fn test_pattern_should_not_pollute_env() {
    // gh issue #1164
    let pattern = Pattern::new("const $A = 114", Tsx);
    let cand = pattern_node("const a = 514");
    let cand = cand.root().child(0).unwrap();
    let map = MetaVarEnv::new();
    let mut env = Cow::Borrowed(&map);
    let nm = pattern.match_node_with_env(cand, &mut env);
    assert!(nm.is_none());
    assert!(env.get_match("A").is_none());
    assert!(map.get_match("A").is_none());
  }

  #[test]
  fn test_match_non_atomic() {
    let env = match_env("const a = $VALUE", "const a = 5 + 3");
    assert_eq!(env["VALUE"], "5 + 3");
  }

  #[test]
  fn test_class_assignment() {
    test_match("class $C { $MEMBER = $VAL}", "class A {a = 123}");
    test_non_match("class $C { $MEMBER = $VAL; b = 123; }", "class A {a = 123}");
    // test_match("a = 123", "class A {a = 123}");
    test_non_match("a = 123", "class B {b = 123}");
  }

  #[test]
  fn test_return() {
    test_match("$A($B)", "return test(123)");
  }

  #[test]
  fn test_contextual_pattern() {
    let pattern =
      Pattern::contextual("class A { $F = $I }", "public_field_definition", Tsx).expect("test");
    let cand = pattern_node("class B { b = 123 }");
    assert!(pattern.find_node(cand.root()).is_some());
    let cand = pattern_node("let b = 123");
    assert!(pattern.find_node(cand.root()).is_none());
  }

  #[test]
  fn test_contextual_match_with_env() {
    let pattern =
      Pattern::contextual("class A { $F = $I }", "public_field_definition", Tsx).expect("test");
    let cand = pattern_node("class B { b = 123 }");
    let nm = pattern.find_node(cand.root()).expect("test");
    let env = nm.get_env();
    let env = HashMap::from(env.clone());
    assert_eq!(env["F"], "b");
    assert_eq!(env["I"], "123");
  }

  #[test]
  fn test_contextual_unmatch_with_env() {
    let pattern =
      Pattern::contextual("class A { $F = $I }", "public_field_definition", Tsx).expect("test");
    let cand = pattern_node("let b = 123");
    let nm = pattern.find_node(cand.root());
    assert!(nm.is_none());
  }

  fn get_kind(kind_str: &str) -> usize {
    Tsx.kind_to_id(kind_str).into()
  }

  #[test]
  fn test_pattern_potential_kinds() {
    let pattern = Pattern::new("const a = 1", Tsx);
    let kind = get_kind("lexical_declaration");
    let kinds = pattern.potential_kinds().expect("should have kinds");
    assert_eq!(kinds.len(), 1);
    assert!(kinds.contains(kind));
  }

  #[test]
  fn test_pattern_with_non_root_meta_var() {
    let pattern = Pattern::new("const $A = $B", Tsx);
    let kind = get_kind("lexical_declaration");
    let kinds = pattern.potential_kinds().expect("should have kinds");
    assert_eq!(kinds.len(), 1);
    assert!(kinds.contains(kind));
  }

  #[test]
  fn test_bare_wildcard() {
    let pattern = Pattern::new("$A", Tsx);
    // wildcard should match anything, so kinds should be None
    assert!(pattern.potential_kinds().is_none());
  }

  #[test]
  fn test_contextual_potential_kinds() {
    let pattern =
      Pattern::contextual("class A { $F = $I }", "public_field_definition", Tsx).expect("test");
    let kind = get_kind("public_field_definition");
    let kinds = pattern.potential_kinds().expect("should have kinds");
    assert_eq!(kinds.len(), 1);
    assert!(kinds.contains(kind));
  }

  #[test]
  fn test_contextual_wildcard() {
    let pattern = Pattern::contextual("class A { $F }", "property_identifier", Tsx).expect("test");
    let kind = get_kind("property_identifier");
    let kinds = pattern.potential_kinds().expect("should have kinds");
    assert_eq!(kinds.len(), 1);
    assert!(kinds.contains(kind));
  }

  #[test]
  #[ignore]
  fn test_multi_node_pattern() {
    let pattern = Pattern::new("a;b;c;", Tsx);
    let kinds = pattern.potential_kinds().expect("should have kinds");
    assert_eq!(kinds.len(), 1);
    test_match("a;b;c", "a;b;c;");
  }

  #[test]
  #[ignore]
  fn test_multi_node_meta_var() {
    let env = match_env("a;$B;c", "a;b;c");
    assert_eq!(env["B"], "b");
    let env = match_env("a;$B;c", "a;1+2+3;c");
    assert_eq!(env["B"], "1+2+3");
  }

  #[test]
  #[ignore]
  fn test_pattern_size() {
    assert_eq!(std::mem::size_of::<Pattern>(), 40);
  }

  #[test]
  fn test_error_kind() {
    let ret = Pattern::contextual("a", "property_identifier", Tsx);
    assert!(ret.is_err());
    let ret = Pattern::new("123+", Tsx);
    assert!(ret.has_error());
  }

  #[test]
  fn test_bare_wildcard_in_context() {
    let pattern = Pattern::contextual("class A { $F }", "property_identifier", Tsx).expect("test");
    let cand = pattern_node("let b = 123");
    // it should not match
    assert!(pattern.find_node(cand.root()).is_none());
  }

  #[test]
  fn test_pattern_fixed_string() {
    let pattern = Pattern::new("class A { $F }", Tsx);
    assert_eq!(pattern.fixed_string(), "class");
    let pattern = Pattern::contextual("class A { $F }", "property_identifier", Tsx).expect("test");
    assert!(pattern.fixed_string().is_empty());
  }

  #[test]
  fn test_pattern_error() {
    let pattern = Pattern::try_new("", Tsx);
    assert!(matches!(pattern, Err(PatternError::NoContent(_))));
    let pattern = Pattern::try_new("12  3344", Tsx);
    assert!(matches!(pattern, Err(PatternError::MultipleNode(_))));
  }

  #[test]
  fn test_debug_pattern() {
    let pattern = Pattern::new("var $A = 1", Tsx);
    assert_eq!(
      format!("{pattern:?}"),
      "[var, [Capture(\"A\", true), =, 1]]"
    );
  }

  fn defined_vars(s: &str) -> Vec<String> {
    let pattern = Pattern::new(s, Tsx);
    let mut vars: Vec<_> = pattern
      .defined_vars()
      .into_iter()
      .map(String::from)
      .collect();
    vars.sort();
    vars
  }

  #[test]
  fn test_extract_meta_var_from_pattern() {
    let vars = defined_vars("var $A = 1");
    assert_eq!(vars, ["A"]);
  }

  #[test]
  fn test_extract_complex_meta_var() {
    let vars = defined_vars("function $FUNC($$$ARGS): $RET { $$$BODY }");
    assert_eq!(vars, ["ARGS", "BODY", "FUNC", "RET"]);
  }

  #[test]
  fn test_extract_duplicate_meta_var() {
    let vars = defined_vars("var $A = $A");
    assert_eq!(vars, ["A"]);
  }

  #[test]
  fn test_contextual_pattern_vars() {
    let pattern = Pattern::contextual("<div ref={$A}/>", "jsx_attribute", Tsx).expect("correct");
    assert_eq!(pattern.defined_vars(), ["A"].into_iter().collect());
  }

  #[test]
  fn test_gh_1087() {
    test_match("($P) => $F($P)", "(x) => bar(x)");
  }

  #[test]
  fn test_template_pattern_have_no_kinds() {
    let pattern = Pattern::new("$A = $B", Tsx).with_strictness(MatchStrictness::Template);
    assert!(pattern.potential_kinds().is_none());
    let pattern = Pattern::contextual("{a: b}", "pair", Tsx)
      .expect("should create template pattern")
      .with_strictness(MatchStrictness::Template);
    assert!(pattern.potential_kinds().is_none());
  }
}



================================================
FILE: crates/core/src/matcher/text.rs
================================================
use super::Matcher;
use crate::meta_var::MetaVarEnv;
use crate::Doc;
use crate::Node;

use bit_set::BitSet;
use regex::{Error as RegexError, Regex};
use thiserror::Error;

use std::borrow::Cow;

#[derive(Debug, Error)]
pub enum RegexMatcherError {
  #[error("Parsing text matcher fails.")]
  Regex(#[from] RegexError),
}

#[derive(Clone)]
pub struct RegexMatcher {
  regex: Regex,
}

impl RegexMatcher {
  pub fn try_new(text: &str) -> Result<Self, RegexMatcherError> {
    Ok(RegexMatcher {
      regex: Regex::new(text)?,
    })
  }
}

impl Matcher for RegexMatcher {
  fn match_node_with_env<'tree, D: Doc>(
    &self,
    node: Node<'tree, D>,
    _env: &mut Cow<MetaVarEnv<'tree, D>>,
  ) -> Option<Node<'tree, D>> {
    self.regex.is_match(&node.text()).then_some(node)
  }

  fn potential_kinds(&self) -> Option<BitSet> {
    None
  }
}



================================================
FILE: crates/core/src/replacer/indent.rs
================================================
#![allow(clippy::doc_overindented_list_items)]
/**
  This module is for indentation-sensitive replacement.

  Ideally, structural search and replacement should all be based on AST.
  But this means our changed AST need to be pretty-printed by structural rules,
  which we don't have enough resource to support. An indentation solution is used.

  The algorithm is quite complicated, uncomprehensive, sluggish and buggy.
  But let's walk through it by example.

  consider this code
  ```ignore
  if (true) {
    a(
      1
        + 2
        + 3
    )
  }
  ```

  and this pattern and replacement

  ```ignore
  // pattern
  a($B)
  // replacement
  c(
    $B
  )
  ```

  We need to compute the relative indentation of the captured meta-var.
  When we insert the meta-var into replacement, keep the relative indent intact,
  while also respecting the replacement indent.
  Finally, the whole replacement should replace the matched node
  in a manner that maintains the indentation of the source.

  We need to consider multiple indentations.
  Key concepts here:
  * meta-var node: in this case `$B` in pattern/replacement, or `1+2+3` in source.
  * matched node: in this case `a($B)` in pattern, a(1 + 2 + 3)` in source
  * meta-var source indentation: `$B` matches `1+2+3`, the first line's indentation in source code is 4.
  * meta-var replacement indentation: in this case 2
  * matched node source indentation: in this case 2

  ## Extract Meta-var with de-indent
  1. Initial meta-var node B text:
      The meta-var source indentation for `$B` is 4.
      However, meta-var node does not have the first line indentation.
      ```ignore
      1
            + 2
            + 3
      ```
  2. Deindent meta-var node B, except first line:
      De-indenting all lines following the first line by 4 spaces gives us this relative code layout.

      ```ignore
      1
        + 2
        + 3
      ```

  ## Insert meta-var into replacement with re-indent

  3. Re-indent by meta-var replacement indentation.
      meta-var node $B occurs in replace with first line indentation of 2.
      We need to re-indent the meta-var code before replacement, except the first line
      ```ignore
      1
          + 2
          + 3
      ```

  4. Insert meta-var code in to replacement
      ```ignore
      c(
        1
          + 2
          + 3
      )
      ```

  ## Insert replacement into source with re-indent

  5. Re-indent the replaced template code except first line
      The whole matched node first line indentation is 2.
      We need to reindent the replacement code by 2, except the first line.
      ```ignore
      c(
          1
            + 2
            + 3
        )
      ```

  6. Inserted replacement code to original tree

      ```ignore
      if (true) {
        c(
          1
            + 2
            + 3
        )
      }
      ```

  The steps 3,4 and steps 5,6 are similar. We can define a `replace_with_indent` to it.
  Following the same path, we can define a `extract_with_deindent` for steps 1,2
*/
use crate::source::Content;
use std::borrow::Cow;
use std::cmp::Ordering;
use std::ops::Range;

/// We assume NEW_LINE, TAB, SPACE is only one code unit.
/// This is sufficiently true for utf8, utf16 and char.
fn get_new_line<C: Content>() -> C::Underlying {
  C::decode_str("\n")[0].clone()
}
fn get_space<C: Content>() -> C::Underlying {
  C::decode_str(" ")[0].clone()
}

const MAX_LOOK_AHEAD: usize = 512;

/// Represents how we de-indent matched meta var.
pub enum DeindentedExtract<'a, C: Content> {
  /// If meta-var is only one line, no need to de-indent/re-indent
  SingleLine(&'a [C::Underlying]),
  /// meta-var's has multiple lines, may need re-indent
  MultiLine(&'a [C::Underlying], usize),
}

/// Returns DeindentedExtract for later de-indent/re-indent.
pub fn extract_with_deindent<C: Content>(
  content: &C,
  range: Range<usize>,
) -> DeindentedExtract<'_, C> {
  let extract_slice = content.get_range(range.clone());
  // no need to compute indentation for single line
  if !extract_slice.contains(&get_new_line::<C>()) {
    return DeindentedExtract::SingleLine(extract_slice);
  }
  let indent = get_indent_at_offset::<C>(content.get_range(0..range.start));
  DeindentedExtract::MultiLine(extract_slice, indent)
}

fn deindent_slice<'a, C: Content>(
  slice: &'a [C::Underlying],
  content: &'a C,
  start: usize,
) -> DeindentedExtract<'a, C> {
  if !slice.contains(&get_new_line::<C>()) {
    return DeindentedExtract::SingleLine(slice);
  }
  let indent = get_indent_at_offset::<C>(content.get_range(0..start));
  DeindentedExtract::MultiLine(slice, indent)
}

pub fn formatted_slice<'a, C: Content>(
  slice: &'a [C::Underlying],
  content: &'a C,
  start: usize,
) -> Cow<'a, [C::Underlying]> {
  let deindent = deindent_slice(slice, content, start);
  indent_lines(0, deindent)
}

pub fn indent_lines<C: Content>(
  indent: usize,
  extract: DeindentedExtract<C>,
) -> Cow<[C::Underlying]> {
  use DeindentedExtract::*;
  let (lines, original_indent) = match extract {
    SingleLine(line) => return Cow::Borrowed(line),
    MultiLine(lines, ind) => (lines, ind),
  };
  match original_indent.cmp(&indent) {
    // if old and new indent match, just return old lines
    Ordering::Equal => Cow::Borrowed(lines),
    // need strip old indent
    Ordering::Greater => Cow::Owned(remove_indent::<C>(original_indent - indent, lines)),
    // need add missing indent
    Ordering::Less => Cow::Owned(indent_lines_impl::<C, _>(
      indent - original_indent,
      lines.split(|b| *b == get_new_line::<C>()),
    )),
  }
}

fn indent_lines_impl<'a, C, Lines>(indent: usize, mut lines: Lines) -> Vec<C::Underlying>
where
  C: Content + 'a,
  Lines: Iterator<Item = &'a [C::Underlying]>,
{
  let mut ret = vec![];
  let space = get_space::<C>();
  let leading: Vec<_> = std::iter::repeat(space).take(indent).collect();
  // first line never got indent
  if let Some(line) = lines.next() {
    ret.extend(line.iter().cloned());
  };
  let new_line = get_new_line::<C>();
  for line in lines {
    ret.push(new_line.clone());
    ret.extend(leading.clone());
    ret.extend(line.iter().cloned());
  }
  ret
}

/// returns 0 if no indent is found before the offset
/// either truly no indent exists, or the offset is in a long line
pub fn get_indent_at_offset<C: Content>(src: &[C::Underlying]) -> usize {
  let lookahead = src.len().max(MAX_LOOK_AHEAD) - MAX_LOOK_AHEAD;

  let mut indent = 0;
  let new_line = get_new_line::<C>();
  let space = get_space::<C>();
  // TODO: support TAB. only whitespace is supported now
  for c in src[lookahead..].iter().rev() {
    if *c == new_line {
      return indent;
    }
    if *c == space {
      indent += 1;
    } else {
      indent = 0;
    }
  }
  // lookahead == 0 means we have indentation at first line.
  if lookahead == 0 && indent != 0 {
    indent
  } else {
    0
  }
}

// NOTE: we assume input is well indented.
// following line's should have fewer indentation than initial line
fn remove_indent<C: Content>(indent: usize, src: &[C::Underlying]) -> Vec<C::Underlying> {
  let indentation: Vec<_> = std::iter::repeat(get_space::<C>()).take(indent).collect();
  let new_line = get_new_line::<C>();
  let lines: Vec<_> = src
    .split(|b| *b == new_line)
    .map(|line| match line.strip_prefix(&*indentation) {
      Some(stripped) => stripped,
      None => line,
    })
    .collect();
  lines.join(&new_line).to_vec()
}

#[cfg(test)]
mod test {
  use super::*;

  fn test_deindent(source: &str, expected: &str, offset: usize) {
    let source = source.to_string();
    let expected = expected.trim();
    let start = source[offset..]
      .chars()
      .take_while(|n| n.is_whitespace())
      .count()
      + offset;
    let trailing_white = source
      .chars()
      .rev()
      .take_while(|n| n.is_whitespace())
      .count();
    let end = source.chars().count() - trailing_white;
    let extracted = extract_with_deindent(&source, start..end);
    let result_bytes = indent_lines::<String>(0, extracted);
    let actual = std::str::from_utf8(&result_bytes).unwrap();
    assert_eq!(actual, expected);
  }

  #[test]
  fn test_simple_deindent() {
    let src = r"
  def test():
    pass";
    let expected = r"
def test():
  pass";
    test_deindent(src, expected, 0);
  }

  #[test]
  fn test_first_line_indent_deindent() {
    // note this indentation has no newline
    let src = r"  def test():
    pass";
    let expected = r"
def test():
  pass";
    test_deindent(src, expected, 0);
  }

  #[test]
  fn test_space_in_middle_deindent() {
    let src = r"
a = lambda:
  pass";
    let expected = r"
lambda:
  pass";
    test_deindent(src, expected, 4);
  }

  #[test]
  fn test_middle_deindent() {
    let src = r"
  a = lambda:
    pass";
    let expected = r"
lambda:
  pass";
    test_deindent(src, expected, 6);
  }

  #[test]
  fn test_nested_deindent() {
    let src = r"
def outer():
  def test():
    pass";
    let expected = r"
def test():
  pass";
    test_deindent(src, expected, 13);
  }

  #[test]
  fn test_no_deindent() {
    let src = r"
def test():
  pass
";
    test_deindent(src, src, 0);
  }

  #[test]
  fn test_malformed_deindent() {
    let src = r"
  def test():
pass
";
    let expected = r"
def test():
pass
";
    test_deindent(src, expected, 0);
  }

  #[test]
  fn test_long_line_no_deindent() {
    let src = format!("{}abc\n  def", " ".repeat(MAX_LOOK_AHEAD + 1));
    test_deindent(&src, &src, 0);
  }

  fn test_replace_with_indent(target: &str, start: usize, inserted: &str) -> String {
    let target = target.to_string();
    let replace_lines = DeindentedExtract::MultiLine(inserted.as_bytes(), 0);
    let indent = get_indent_at_offset::<String>(&target.as_bytes()[..start]);
    let ret = indent_lines::<String>(indent, replace_lines);
    String::from_utf8(ret.to_vec()).unwrap()
  }

  #[test]
  fn test_simple_replace() {
    let target = "";
    let inserted = "def abc(): pass";
    let actual = test_replace_with_indent(target, 0, inserted);
    assert_eq!(actual, inserted);
    let inserted = "def abc():\n  pass";
    let actual = test_replace_with_indent(target, 0, inserted);
    assert_eq!(actual, inserted);
  }

  #[test]
  fn test_indent_replace() {
    let target = "  ";
    let inserted = "def abc(): pass";
    let actual = test_replace_with_indent(target, 2, inserted);
    assert_eq!(actual, "def abc(): pass");
    let inserted = "def abc():\n  pass";
    let actual = test_replace_with_indent(target, 2, inserted);
    assert_eq!(actual, "def abc():\n    pass");
    let target = "    "; // 4 spaces, but insert at 2
    let actual = test_replace_with_indent(target, 2, inserted);
    assert_eq!(actual, "def abc():\n    pass");
    let target = "    "; // 4 spaces, insert at 4
    let actual = test_replace_with_indent(target, 4, inserted);
    assert_eq!(actual, "def abc():\n      pass");
  }

  #[test]
  fn test_leading_text_replace() {
    let target = "a = ";
    let inserted = "def abc(): pass";
    let actual = test_replace_with_indent(target, 4, inserted);
    assert_eq!(actual, "def abc(): pass");
    let inserted = "def abc():\n  pass";
    let actual = test_replace_with_indent(target, 4, inserted);
    assert_eq!(actual, "def abc():\n  pass");
  }

  #[test]
  fn test_leading_text_indent_replace() {
    let target = "  a = ";
    let inserted = "def abc(): pass";
    let actual = test_replace_with_indent(target, 6, inserted);
    assert_eq!(actual, "def abc(): pass");
    let inserted = "def abc():\n  pass";
    let actual = test_replace_with_indent(target, 6, inserted);
    assert_eq!(actual, "def abc():\n    pass");
  }
}



================================================
FILE: crates/core/src/replacer/structural.rs
================================================
use super::{Edit, Underlying};
use crate::language::Language;
use crate::meta_var::MetaVarEnv;
use crate::source::{Content, SgNode};
use crate::{Doc, Node, NodeMatch, Root};

pub fn gen_replacement<D: Doc>(root: &Root<D>, nm: &NodeMatch<D>) -> Underlying<D> {
  let edits = collect_edits(root, nm.get_env(), nm.lang());
  merge_edits_to_vec(edits, root)
}

fn collect_edits<D: Doc>(root: &Root<D>, env: &MetaVarEnv<D>, lang: &D::Lang) -> Vec<Edit<D>> {
  let mut node = root.root();
  let root_id = node.node_id();
  let mut edits = vec![];

  // this is a post-order DFS that stops traversal when the node matches
  'outer: loop {
    if let Some(text) = get_meta_var_replacement(&node, env, lang.clone()) {
      let range = node.range();
      let position = range.start;
      let length = range.len();
      edits.push(Edit::<D> {
        position,
        deleted_length: length,
        inserted_text: text,
      });
    } else if let Some(first_child) = node.child(0) {
      // traverse down to child
      node = first_child;
      continue;
    } else if node.inner.is_missing() {
      // TODO: better handling missing node
      if let Some(sibling) = node.next() {
        node = sibling;
        continue;
      } else {
        break;
      }
    }
    // traverse up to parent until getting to root
    loop {
      // come back to the root node, terminating dfs
      if node.node_id() == root_id {
        break 'outer;
      }
      if let Some(sibling) = node.next() {
        node = sibling;
        break;
      }
      node = node.parent().unwrap();
    }
  }
  // add the missing one
  edits.push(Edit::<D> {
    position: root.root().range().end,
    deleted_length: 0,
    inserted_text: vec![],
  });
  edits
}

fn merge_edits_to_vec<D: Doc>(edits: Vec<Edit<D>>, root: &Root<D>) -> Underlying<D> {
  let mut ret = vec![];
  let mut start = 0;
  for edit in edits {
    debug_assert!(start <= edit.position, "Edit must be ordered!");
    ret.extend(
      root
        .doc
        .get_source()
        .get_range(start..edit.position)
        .iter()
        .cloned(),
    );
    ret.extend(edit.inserted_text.iter().cloned());
    start = edit.position + edit.deleted_length;
  }
  ret
}

fn get_meta_var_replacement<D: Doc>(
  node: &Node<D>,
  env: &MetaVarEnv<D>,
  lang: D::Lang,
) -> Option<Underlying<D>> {
  if !node.is_named_leaf() {
    return None;
  }
  let meta_var = lang.extract_meta_var(&node.text())?;
  let replaced = env.get_var_bytes(&meta_var)?;
  Some(replaced.to_vec())
}

#[cfg(test)]
mod test {
  use crate::language::Tsx;
  use crate::meta_var::MetaVarEnv;
  use crate::{replacer::Replacer, tree_sitter::LanguageExt, NodeMatch, Root};
  use std::collections::HashMap;

  fn test_pattern_replace(replacer: &str, vars: &[(&str, &str)], expected: &str) {
    let mut env = MetaVarEnv::new();
    let roots: Vec<_> = vars.iter().map(|(v, p)| (v, Tsx.ast_grep(p))).collect();
    for (var, root) in &roots {
      env.insert(var, root.root());
    }
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let replacer = Root::str(replacer, Tsx);
    let replaced = replacer.generate_replacement(&node_match);
    let replaced = String::from_utf8_lossy(&replaced);
    assert_eq!(
      replaced,
      expected,
      "wrong replacement {replaced} {expected} {:?}",
      HashMap::from(env)
    );
  }

  #[test]
  fn test_no_env() {
    test_pattern_replace("let a = 123", &[], "let a = 123");
    test_pattern_replace(
      "console.log('hello world'); let b = 123;",
      &[],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_single_env() {
    test_pattern_replace("let a = $A", &[("A", "123")], "let a = 123");
    test_pattern_replace(
      "console.log($HW); let b = 123;",
      &[("HW", "'hello world'")],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_multiple_env() {
    test_pattern_replace("let $V = $A", &[("A", "123"), ("V", "a")], "let a = 123");
    test_pattern_replace(
      "console.log($HW); let $B = 123;",
      &[("HW", "'hello world'"), ("B", "b")],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_multiple_occurrences() {
    test_pattern_replace("let $A = $A", &[("A", "a")], "let a = a");
    test_pattern_replace("var $A = () => $A", &[("A", "a")], "var a = () => a");
    test_pattern_replace(
      "const $A = () => { console.log($B); $A(); };",
      &[("B", "'hello world'"), ("A", "a")],
      "const a = () => { console.log('hello world'); a(); };",
    );
  }

  fn test_ellipsis_replace(replacer: &str, vars: &[(&str, &str)], expected: &str) {
    let mut env = MetaVarEnv::new();
    let roots: Vec<_> = vars.iter().map(|(v, p)| (v, Tsx.ast_grep(p))).collect();
    for (var, root) in &roots {
      env.insert_multi(var, root.root().children().collect());
    }
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let replacer = Root::str(replacer, Tsx);
    let replaced = replacer.generate_replacement(&node_match);
    let replaced = String::from_utf8_lossy(&replaced);
    assert_eq!(
      replaced,
      expected,
      "wrong replacement {replaced} {expected} {:?}",
      HashMap::from(env)
    );
  }

  #[test]
  fn test_ellipsis_meta_var() {
    test_ellipsis_replace(
      "let a = () => { $$$B }",
      &[("B", "alert('works!')")],
      "let a = () => { alert('works!') }",
    );
    test_ellipsis_replace(
      "let a = () => { $$$B }",
      &[("B", "alert('works!');console.log(123)")],
      "let a = () => { alert('works!');console.log(123) }",
    );
  }

  #[test]
  fn test_multi_ellipsis() {
    test_ellipsis_replace(
      "import {$$$A, B, $$$C} from 'a'",
      &[("A", "A"), ("C", "C")],
      "import {A, B, C} from 'a'",
    );
  }

  #[test]
  fn test_replace_in_string() {
    test_pattern_replace("'$A'", &[("A", "123")], "'123'");
  }

  #[test]
  fn test_nested_matching_replace() {
    // TODO
  }
}



================================================
FILE: crates/core/src/replacer/template.rs
================================================
use super::indent::{extract_with_deindent, get_indent_at_offset, indent_lines, DeindentedExtract};
use super::{split_first_meta_var, MetaVarExtract, Replacer};
use crate::language::Language;
use crate::meta_var::{MetaVarEnv, Underlying};
use crate::source::{Content, Doc};
use crate::NodeMatch;

use thiserror::Error;

use std::borrow::Cow;
use std::collections::HashSet;

pub enum TemplateFix {
  // no meta_var, pure text
  Textual(String),
  WithMetaVar(Template),
}

#[derive(Debug, Error)]
pub enum TemplateFixError {}

impl TemplateFix {
  pub fn try_new<L: Language>(template: &str, lang: &L) -> Result<Self, TemplateFixError> {
    Ok(create_template(template, lang.meta_var_char(), &[]))
  }

  pub fn with_transform<L: Language>(tpl: &str, lang: &L, trans: &[String]) -> Self {
    create_template(tpl, lang.meta_var_char(), trans)
  }

  pub fn used_vars(&self) -> HashSet<&str> {
    let template = match self {
      TemplateFix::WithMetaVar(t) => t,
      TemplateFix::Textual(_) => return HashSet::new(),
    };
    template.vars.iter().map(|v| v.0.used_var()).collect()
  }
}

impl<D: Doc> Replacer<D> for TemplateFix {
  fn generate_replacement(&self, nm: &NodeMatch<'_, D>) -> Underlying<D> {
    let leading = nm.get_doc().get_source().get_range(0..nm.range().start);
    let indent = get_indent_at_offset::<D::Source>(leading);
    let bytes = replace_fixer(self, nm.get_env());
    let replaced = DeindentedExtract::MultiLine(&bytes, 0);
    indent_lines::<D::Source>(indent, replaced).to_vec()
  }
}

type Indent = usize;

pub struct Template {
  fragments: Vec<String>,
  vars: Vec<(MetaVarExtract, Indent)>,
}

fn create_template(tmpl: &str, mv_char: char, transforms: &[String]) -> TemplateFix {
  let mut fragments = vec![];
  let mut vars = vec![];
  let mut offset = 0;
  let mut len = 0;
  while let Some(i) = tmpl[len + offset..].find(mv_char) {
    if let Some((meta_var, skipped)) =
      split_first_meta_var(&tmpl[len + offset + i..], mv_char, transforms)
    {
      fragments.push(tmpl[len..len + offset + i].to_string());
      // NB we have to count ident of the full string
      let indent = get_indent_at_offset::<String>(&tmpl.as_bytes()[..len + offset + i]);
      vars.push((meta_var, indent));
      len += skipped + offset + i;
      offset = 0;
      continue;
    }
    debug_assert!(len + offset + i < tmpl.len());
    // offset = 0, i = 0,
    // 0 1 2
    // $ a $
    offset = offset + i + 1;
  }
  if fragments.is_empty() {
    TemplateFix::Textual(tmpl[len..].to_string())
  } else {
    fragments.push(tmpl[len..].to_string());
    TemplateFix::WithMetaVar(Template { fragments, vars })
  }
}

fn replace_fixer<D: Doc>(fixer: &TemplateFix, env: &MetaVarEnv<'_, D>) -> Underlying<D> {
  let template = match fixer {
    TemplateFix::Textual(n) => return D::Source::decode_str(n).to_vec(),
    TemplateFix::WithMetaVar(t) => t,
  };
  let mut ret = vec![];
  let mut frags = template.fragments.iter();
  let vars = template.vars.iter();
  if let Some(frag) = frags.next() {
    ret.extend_from_slice(&D::Source::decode_str(frag));
  }
  for ((var, indent), frag) in vars.zip(frags) {
    if let Some(bytes) = maybe_get_var(env, var, indent) {
      ret.extend_from_slice(&bytes);
    }
    ret.extend_from_slice(&D::Source::decode_str(frag));
  }
  ret
}

fn maybe_get_var<'e, 't, C, D>(
  env: &'e MetaVarEnv<'t, D>,
  var: &MetaVarExtract,
  indent: &usize,
) -> Option<Cow<'e, [C::Underlying]>>
where
  C: Content + 'e,
  D: Doc<Source = C>,
{
  let (source, range) = match var {
    MetaVarExtract::Transformed(name) => {
      // transformed source does not have range, directly return bytes
      let source = env.get_transformed(name)?;
      let de_intended = DeindentedExtract::MultiLine(source, 0);
      let bytes = indent_lines::<D::Source>(*indent, de_intended);
      return Some(bytes);
    }
    MetaVarExtract::Single(name) => {
      let replaced = env.get_match(name)?;
      let source = replaced.get_doc().get_source();
      let range = replaced.range();
      (source, range)
    }
    MetaVarExtract::Multiple(name) => {
      let nodes = env.get_multiple_matches(name);
      if nodes.is_empty() {
        return None;
      }
      // NOTE: start_byte is not always index range of source's slice.
      // e.g. start_byte is still byte_offset in utf_16 (napi). start_byte
      // so we need to call source's get_range method
      let start = nodes[0].range().start;
      let end = nodes[nodes.len() - 1].range().end;
      let source = nodes[0].get_doc().get_source();
      (source, start..end)
    }
  };
  let extracted = extract_with_deindent(source, range);
  let bytes = indent_lines::<D::Source>(*indent, extracted);
  Some(bytes)
}

// replace meta_var in template string, e.g. "Hello $NAME" -> "Hello World"
pub fn gen_replacement<D: Doc>(template: &str, nm: &NodeMatch<'_, D>) -> Underlying<D> {
  let fixer = create_template(template, nm.lang().meta_var_char(), &[]);
  fixer.generate_replacement(nm)
}

#[cfg(test)]
mod test {

  use super::*;
  use crate::language::Tsx;
  use crate::matcher::NodeMatch;
  use crate::meta_var::{MetaVarEnv, MetaVariable};
  use crate::tree_sitter::LanguageExt;
  use crate::Pattern;
  use std::collections::HashMap;

  #[test]
  fn test_example() {
    let src = r"
if (true) {
  a(
    1
      + 2
      + 3
  )
}";
    let pattern = "a($B)";
    let template = r"c(
  $B
)";
    let mut src = Tsx.ast_grep(src);
    let pattern = Pattern::new(pattern, Tsx);
    let success = src.replace(pattern, template).expect("should replace");
    assert!(success);
    let expect = r"if (true) {
  c(
    1
      + 2
      + 3
  )
}";
    assert_eq!(src.root().text(), expect);
  }

  fn test_str_replace(replacer: &str, vars: &[(&str, &str)], expected: &str) {
    let mut env = MetaVarEnv::new();
    let roots: Vec<_> = vars.iter().map(|(v, p)| (v, Tsx.ast_grep(p))).collect();
    for (var, root) in &roots {
      env.insert(var, root.root());
    }
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let replaced = replacer.generate_replacement(&node_match);
    let replaced = String::from_utf8_lossy(&replaced);
    assert_eq!(
      replaced,
      expected,
      "wrong replacement {replaced} {expected} {:?}",
      HashMap::from(env)
    );
  }

  #[test]
  fn test_no_env() {
    test_str_replace("let a = 123", &[], "let a = 123");
    test_str_replace(
      "console.log('hello world'); let b = 123;",
      &[],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_single_env() {
    test_str_replace("let a = $A", &[("A", "123")], "let a = 123");
    test_str_replace(
      "console.log($HW); let b = 123;",
      &[("HW", "'hello world'")],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_multiple_env() {
    test_str_replace("let $V = $A", &[("A", "123"), ("V", "a")], "let a = 123");
    test_str_replace(
      "console.log($HW); let $B = 123;",
      &[("HW", "'hello world'"), ("B", "b")],
      "console.log('hello world'); let b = 123;",
    );
  }

  #[test]
  fn test_multiple_occurrences() {
    test_str_replace("let $A = $A", &[("A", "a")], "let a = a");
    test_str_replace("var $A = () => $A", &[("A", "a")], "var a = () => a");
    test_str_replace(
      "const $A = () => { console.log($B); $A(); };",
      &[("B", "'hello world'"), ("A", "a")],
      "const a = () => { console.log('hello world'); a(); };",
    );
  }

  fn test_ellipsis_replace(replacer: &str, vars: &[(&str, &str)], expected: &str) {
    let mut env = MetaVarEnv::new();
    let roots: Vec<_> = vars.iter().map(|(v, p)| (v, Tsx.ast_grep(p))).collect();
    for (var, root) in &roots {
      env.insert_multi(var, root.root().children().collect());
    }
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let replaced = replacer.generate_replacement(&node_match);
    let replaced = String::from_utf8_lossy(&replaced);
    assert_eq!(
      replaced,
      expected,
      "wrong replacement {replaced} {expected} {:?}",
      HashMap::from(env)
    );
  }

  #[test]
  fn test_ellipsis_meta_var() {
    test_ellipsis_replace(
      "let a = () => { $$$B }",
      &[("B", "alert('works!')")],
      "let a = () => { alert('works!') }",
    );
    test_ellipsis_replace(
      "let a = () => { $$$B }",
      &[("B", "alert('works!');console.log(123)")],
      "let a = () => { alert('works!');console.log(123) }",
    );
  }

  #[test]
  fn test_multi_ellipsis() {
    test_ellipsis_replace(
      "import {$$$A, B, $$$C} from 'a'",
      &[("A", "A"), ("C", "C")],
      "import {A, B, C} from 'a'",
    );
  }

  #[test]
  fn test_replace_in_string() {
    test_str_replace("'$A'", &[("A", "123")], "'123'");
  }

  fn test_template_replace(template: &str, vars: &[(&str, &str)], expected: &str) {
    let mut env = MetaVarEnv::new();
    let roots: Vec<_> = vars.iter().map(|(v, p)| (v, Tsx.ast_grep(p))).collect();
    for (var, root) in &roots {
      env.insert(var, root.root());
    }
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let bytes = template.generate_replacement(&node_match);
    let ret = String::from_utf8(bytes).expect("replacement must be valid utf-8");
    assert_eq!(expected, ret);
  }

  #[test]
  fn test_template() {
    test_template_replace("Hello $A", &[("A", "World")], "Hello World");
    test_template_replace("$B $A", &[("A", "World"), ("B", "Hello")], "Hello World");
  }

  #[test]
  fn test_template_vars() {
    let tf = TemplateFix::try_new("$A $B $C", &Tsx).expect("ok");
    assert_eq!(tf.used_vars(), ["A", "B", "C"].into_iter().collect());
    let tf = TemplateFix::try_new("$a$B$C", &Tsx).expect("ok");
    assert_eq!(tf.used_vars(), ["B", "C"].into_iter().collect());
    let tf = TemplateFix::try_new("$a$B$C", &Tsx).expect("ok");
    assert_eq!(tf.used_vars(), ["B", "C"].into_iter().collect());
  }

  // GH #641
  #[test]
  fn test_multi_row_replace() {
    test_template_replace(
      "$A = $B",
      &[("A", "x"), ("B", "[\n  1\n]")],
      "x = [\n  1\n]",
    );
  }

  #[test]
  fn test_replace_rewriter() {
    let tf = TemplateFix::with_transform("if (a)\n  $A", &Tsx, &["A".to_string()]);
    let mut env = MetaVarEnv::new();
    env.insert_transformation(
      &MetaVariable::Multiple,
      "A",
      "if (b)\n  foo".bytes().collect(),
    );
    let dummy = Tsx.ast_grep("dummy");
    let node_match = NodeMatch::new(dummy.root(), env.clone());
    let bytes = tf.generate_replacement(&node_match);
    let ret = String::from_utf8(bytes).expect("replacement must be valid utf-8");
    assert_eq!("if (a)\n  if (b)\n    foo", ret);
  }

  #[test]
  fn test_nested_matching_replace() {
    // TODO impossible, we don't support nested replacement
  }
}



================================================
FILE: crates/core/src/tree_sitter/mod.rs
================================================
pub mod traversal;

use crate::node::Root;
use crate::replacer::Replacer;
use crate::source::{Content, Doc, Edit, SgNode};
use crate::{node::KindId, Language, Position};
use crate::{AstGrep, Matcher};
use std::borrow::Cow;
use std::collections::HashMap;
use std::num::NonZero;
use thiserror::Error;
pub use traversal::{TsPre, Visitor};
pub use tree_sitter::Language as TSLanguage;
use tree_sitter::{InputEdit, LanguageError, Node, Parser, Point, Tree};
pub use tree_sitter::{Point as TSPoint, Range as TSRange};

/// Represents tree-sitter related error
#[derive(Debug, Error)]
pub enum TSParseError {
  #[error("incompatible `Language` is assigned to a `Parser`.")]
  Language(#[from] LanguageError),
  /// A general error when tree sitter fails to parse in time. It can be caused by
  /// the following reasons but tree-sitter does not provide error detail.
  /// * The timeout set with [Parser::set_timeout_micros] expired
  /// * The cancellation flag set with [Parser::set_cancellation_flag] was flipped
  /// * The parser has not yet had a language assigned with [Parser::set_language]
  #[error("general error when tree-sitter fails to parse.")]
  TreeUnavailable,
}

#[inline]
fn parse_lang(
  parse_fn: impl Fn(&mut Parser) -> Option<Tree>,
  ts_lang: TSLanguage,
) -> Result<Tree, TSParseError> {
  let mut parser = Parser::new();
  parser.set_language(&ts_lang)?;
  if let Some(tree) = parse_fn(&mut parser) {
    Ok(tree)
  } else {
    Err(TSParseError::TreeUnavailable)
  }
}

#[derive(Clone)]
pub struct StrDoc<L: LanguageExt> {
  pub src: String,
  pub lang: L,
  pub tree: Tree,
}

impl<L: LanguageExt> StrDoc<L> {
  pub fn try_new(src: &str, lang: L) -> Result<Self, String> {
    let src = src.to_string();
    let ts_lang = lang.get_ts_language();
    let tree = parse_lang(|p| p.parse(src.as_bytes(), None), ts_lang).map_err(|e| e.to_string())?;
    Ok(Self { src, lang, tree })
  }
  pub fn new(src: &str, lang: L) -> Self {
    Self::try_new(src, lang).expect("Parser tree error")
  }
  fn parse(&self, old_tree: Option<&Tree>) -> Result<Tree, TSParseError> {
    let source = self.get_source();
    let lang = self.get_lang().get_ts_language();
    parse_lang(|p| p.parse(source.as_bytes(), old_tree), lang)
  }
}

impl<L: LanguageExt> Doc for StrDoc<L> {
  type Source = String;
  type Lang = L;
  type Node<'r> = Node<'r>;
  fn get_lang(&self) -> &Self::Lang {
    &self.lang
  }
  fn get_source(&self) -> &Self::Source {
    &self.src
  }
  fn do_edit(&mut self, edit: &Edit<Self::Source>) -> Result<(), String> {
    let source = &mut self.src;
    perform_edit(&mut self.tree, source, edit);
    self.tree = self.parse(Some(&self.tree)).map_err(|e| e.to_string())?;
    Ok(())
  }
  fn root_node(&self) -> Node<'_> {
    self.tree.root_node()
  }
  fn get_node_text<'a>(&'a self, node: &Self::Node<'a>) -> Cow<'a, str> {
    Cow::Borrowed(
      node
        .utf8_text(self.src.as_bytes())
        .expect("invalid source text encoding"),
    )
  }
}

struct NodeWalker<'tree> {
  cursor: tree_sitter::TreeCursor<'tree>,
  count: usize,
}

impl<'tree> Iterator for NodeWalker<'tree> {
  type Item = Node<'tree>;
  fn next(&mut self) -> Option<Self::Item> {
    if self.count == 0 {
      return None;
    }
    let ret = Some(self.cursor.node());
    self.cursor.goto_next_sibling();
    self.count -= 1;
    ret
  }
}

impl ExactSizeIterator for NodeWalker<'_> {
  fn len(&self) -> usize {
    self.count
  }
}

impl<'r> SgNode<'r> for Node<'r> {
  fn parent(&self) -> Option<Self> {
    Node::parent(self)
  }
  fn ancestors(&self, root: Self) -> impl Iterator<Item = Self> {
    let mut ancestor = Some(root);
    let self_id = self.id();
    std::iter::from_fn(move || {
      let inner = ancestor.take()?;
      if inner.id() == self_id {
        return None;
      }
      ancestor = inner.child_with_descendant(*self);
      Some(inner)
    })
    // We must iterate up the tree to preserve backwards compatibility
    .collect::<Vec<_>>()
    .into_iter()
    .rev()
  }
  fn dfs(&self) -> impl Iterator<Item = Self> {
    TsPre::new(self)
  }
  fn child(&self, nth: usize) -> Option<Self> {
    // TODO remove cast after migrating to tree-sitter
    Node::child(self, nth)
  }
  fn children(&self) -> impl ExactSizeIterator<Item = Self> {
    let mut cursor = self.walk();
    cursor.goto_first_child();
    NodeWalker {
      cursor,
      count: self.child_count(),
    }
  }
  fn child_by_field_id(&self, field_id: u16) -> Option<Self> {
    Node::child_by_field_id(self, field_id)
  }
  fn next(&self) -> Option<Self> {
    self.next_sibling()
  }
  fn prev(&self) -> Option<Self> {
    self.prev_sibling()
  }
  fn next_all(&self) -> impl Iterator<Item = Self> {
    // if root is none, use self as fallback to return a type-stable Iterator
    let node = self.parent().unwrap_or(*self);
    let mut cursor = node.walk();
    cursor.goto_first_child_for_byte(self.start_byte());
    std::iter::from_fn(move || {
      if cursor.goto_next_sibling() {
        Some(cursor.node())
      } else {
        None
      }
    })
  }
  fn prev_all(&self) -> impl Iterator<Item = Self> {
    // if root is none, use self as fallback to return a type-stable Iterator
    let node = self.parent().unwrap_or(*self);
    let mut cursor = node.walk();
    cursor.goto_first_child_for_byte(self.start_byte());
    std::iter::from_fn(move || {
      if cursor.goto_previous_sibling() {
        Some(cursor.node())
      } else {
        None
      }
    })
  }
  fn is_named(&self) -> bool {
    Node::is_named(self)
  }
  /// N.B. it is different from is_named && is_leaf
  /// if a node has no named children.
  fn is_named_leaf(&self) -> bool {
    self.named_child_count() == 0
  }
  fn is_leaf(&self) -> bool {
    self.child_count() == 0
  }
  fn kind(&self) -> Cow<'_, str> {
    Cow::Borrowed(Node::kind(self))
  }
  fn kind_id(&self) -> KindId {
    Node::kind_id(self)
  }
  fn node_id(&self) -> usize {
    self.id()
  }
  fn range(&self) -> std::ops::Range<usize> {
    self.start_byte()..self.end_byte()
  }
  fn start_pos(&self) -> Position {
    let pos = self.start_position();
    let byte = self.start_byte();
    Position::new(pos.row, pos.column, byte)
  }
  fn end_pos(&self) -> Position {
    let pos = self.end_position();
    let byte = self.end_byte();
    Position::new(pos.row, pos.column, byte)
  }
  // missing node is a tree-sitter specific concept
  fn is_missing(&self) -> bool {
    Node::is_missing(self)
  }
  fn is_error(&self) -> bool {
    Node::is_error(self)
  }

  fn field(&self, name: &str) -> Option<Self> {
    self.child_by_field_name(name)
  }
  fn field_children(&self, field_id: Option<u16>) -> impl Iterator<Item = Self> {
    let field_id = field_id.and_then(NonZero::new);
    let mut cursor = self.walk();
    cursor.goto_first_child();
    // if field_id is not found, iteration is done
    let mut done = field_id.is_none();

    std::iter::from_fn(move || {
      if done {
        return None;
      }
      while cursor.field_id() != field_id {
        if !cursor.goto_next_sibling() {
          return None;
        }
      }
      let ret = cursor.node();
      if !cursor.goto_next_sibling() {
        done = true;
      }
      Some(ret)
    })
  }
}

pub fn perform_edit<S: ContentExt>(tree: &mut Tree, input: &mut S, edit: &Edit<S>) -> InputEdit {
  let edit = input.accept_edit(edit);
  tree.edit(&edit);
  edit
}

/// tree-sitter specific language trait
pub trait LanguageExt: Language {
  /// Create an [`AstGrep`] instance for the language
  fn ast_grep<S: AsRef<str>>(&self, source: S) -> AstGrep<StrDoc<Self>> {
    AstGrep::new(source, self.clone())
  }

  /// tree sitter language to parse the source
  fn get_ts_language(&self) -> TSLanguage;

  fn injectable_languages(&self) -> Option<&'static [&'static str]> {
    None
  }

  /// get injected language regions in the root document. e.g. get JavaScripts in HTML
  /// it will return a list of tuples of (language, regions).
  /// The first item is the embedded region language, e.g. javascript
  /// The second item is a list of regions in tree_sitter.
  /// also see https://tree-sitter.github.io/tree-sitter/using-parsers#multi-language-documents
  fn extract_injections<L: LanguageExt>(
    &self,
    _root: crate::Node<StrDoc<L>>,
  ) -> HashMap<String, Vec<TSRange>> {
    HashMap::new()
  }
}

fn position_for_offset(input: &[u8], offset: usize) -> Point {
  debug_assert!(offset <= input.len());
  let (mut row, mut col) = (0, 0);
  for c in &input[0..offset] {
    if *c as char == '\n' {
      row += 1;
      col = 0;
    } else {
      col += 1;
    }
  }
  Point::new(row, col)
}

impl<L: LanguageExt> AstGrep<StrDoc<L>> {
  pub fn new<S: AsRef<str>>(src: S, lang: L) -> Self {
    Root::str(src.as_ref(), lang)
  }

  pub fn source(&self) -> &str {
    self.doc.get_source().as_str()
  }

  pub fn generate(self) -> String {
    self.doc.src
  }
}

pub trait ContentExt: Content {
  fn accept_edit(&mut self, edit: &Edit<Self>) -> InputEdit;
}
impl ContentExt for String {
  fn accept_edit(&mut self, edit: &Edit<Self>) -> InputEdit {
    let start_byte = edit.position;
    let old_end_byte = edit.position + edit.deleted_length;
    let new_end_byte = edit.position + edit.inserted_text.len();
    let input = unsafe { self.as_mut_vec() };
    let start_position = position_for_offset(input, start_byte);
    let old_end_position = position_for_offset(input, old_end_byte);
    input.splice(start_byte..old_end_byte, edit.inserted_text.clone());
    let new_end_position = position_for_offset(input, new_end_byte);
    InputEdit {
      start_byte,
      old_end_byte,
      new_end_byte,
      start_position,
      old_end_position,
      new_end_position,
    }
  }
}

impl<L: LanguageExt> Root<StrDoc<L>> {
  pub fn str(src: &str, lang: L) -> Self {
    Self::try_new(src, lang).expect("should parse")
  }
  pub fn try_new(src: &str, lang: L) -> Result<Self, String> {
    let doc = StrDoc::try_new(src, lang)?;
    Ok(Self { doc })
  }
  pub fn get_text(&self) -> &str {
    &self.doc.src
  }

  pub fn get_injections<F: Fn(&str) -> Option<L>>(&self, get_lang: F) -> Vec<Self> {
    let root = self.root();
    let range = self.lang().extract_injections(root);
    let roots = range
      .into_iter()
      .filter_map(|(lang, ranges)| {
        let lang = get_lang(&lang)?;
        let source = self.doc.get_source();
        let mut parser = Parser::new();
        parser.set_included_ranges(&ranges).ok()?;
        parser.set_language(&lang.get_ts_language()).ok()?;
        let tree = parser.parse(source, None)?;
        Some(Self {
          doc: StrDoc {
            src: self.doc.src.clone(),
            lang,
            tree,
          },
        })
      })
      .collect();
    roots
  }
}

pub struct DisplayContext<'r> {
  /// content for the matched node
  pub matched: Cow<'r, str>,
  /// content before the matched node
  pub leading: &'r str,
  /// content after the matched node
  pub trailing: &'r str,
  /// zero-based start line of the context
  pub start_line: usize,
}

/// these methods are only for `StrDoc`
impl<'r, L: LanguageExt> crate::Node<'r, StrDoc<L>> {
  #[doc(hidden)]
  pub fn display_context(&self, before: usize, after: usize) -> DisplayContext<'r> {
    let source = self.root.doc.get_source().as_str();
    let bytes = source.as_bytes();
    let start = self.inner.start_byte();
    let end = self.inner.end_byte();
    let (mut leading, mut trailing) = (start, end);
    let mut lines_before = before + 1;
    while leading > 0 {
      if bytes[leading - 1] == b'\n' {
        lines_before -= 1;
        if lines_before == 0 {
          break;
        }
      }
      leading -= 1;
    }
    let mut lines_after = after + 1;
    // tree-sitter will append line ending to source so trailing can be out of bound
    trailing = trailing.min(bytes.len());
    while trailing < bytes.len() {
      if bytes[trailing] == b'\n' {
        lines_after -= 1;
        if lines_after == 0 {
          break;
        }
      }
      trailing += 1;
    }
    // lines_before means we matched all context, offset is `before` itself
    let offset = if lines_before == 0 {
      before
    } else {
      // otherwise, there are fewer than `before` line in src, compute the actual line
      before + 1 - lines_before
    };
    DisplayContext {
      matched: self.text(),
      leading: &source[leading..start],
      trailing: &source[end..trailing],
      start_line: self.start_pos().line() - offset,
    }
  }

  pub fn replace_all<M: Matcher, R: Replacer<StrDoc<L>>>(
    &self,
    matcher: M,
    replacer: R,
  ) -> Vec<Edit<String>> {
    // TODO: support nested matches like Some(Some(1)) with pattern Some($A)
    Visitor::new(&matcher)
      .reentrant(false)
      .visit(self.clone())
      .map(|matched| matched.make_edit(&matcher, &replacer))
      .collect()
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use tree_sitter::Point;

  fn parse(src: &str) -> Result<Tree, TSParseError> {
    parse_lang(|p| p.parse(src, None), Tsx.get_ts_language())
  }

  #[test]
  fn test_tree_sitter() -> Result<(), TSParseError> {
    let tree = parse("var a = 1234")?;
    let root_node = tree.root_node();
    assert_eq!(root_node.kind(), "program");
    assert_eq!(root_node.start_position().column, 0);
    assert_eq!(root_node.end_position().column, 12);
    assert_eq!(
      root_node.to_sexp(),
      "(program (variable_declaration (variable_declarator name: (identifier) value: (number))))"
    );
    Ok(())
  }

  #[test]
  fn test_object_literal() -> Result<(), TSParseError> {
    let tree = parse("{a: $X}")?;
    let root_node = tree.root_node();
    // wow this is not label. technically it is wrong but practically it is better LOL
    assert_eq!(root_node.to_sexp(), "(program (expression_statement (object (pair key: (property_identifier) value: (identifier)))))");
    Ok(())
  }

  #[test]
  fn test_string() -> Result<(), TSParseError> {
    let tree = parse("'$A'")?;
    let root_node = tree.root_node();
    assert_eq!(
      root_node.to_sexp(),
      "(program (expression_statement (string (string_fragment))))"
    );
    Ok(())
  }

  #[test]
  fn test_row_col() -> Result<(), TSParseError> {
    let tree = parse("😄")?;
    let root = tree.root_node();
    assert_eq!(root.start_position(), Point::new(0, 0));
    // NOTE: Point in tree-sitter is counted in bytes instead of char
    assert_eq!(root.end_position(), Point::new(0, 4));
    Ok(())
  }

  #[test]
  fn test_edit() -> Result<(), TSParseError> {
    let mut src = "a + b".to_string();
    let mut tree = parse(&src)?;
    let _ = perform_edit(
      &mut tree,
      &mut src,
      &Edit {
        position: 1,
        deleted_length: 0,
        inserted_text: " * b".into(),
      },
    );
    let tree2 = parse_lang(|p| p.parse(&src, Some(&tree)), Tsx.get_ts_language())?;
    assert_eq!(
      tree.root_node().to_sexp(),
      "(program (expression_statement (binary_expression left: (identifier) right: (identifier))))"
    );
    assert_eq!(tree2.root_node().to_sexp(), "(program (expression_statement (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (identifier))))");
    Ok(())
  }
}



================================================
FILE: crates/core/src/tree_sitter/traversal.rs
================================================
//! # Traverse Node AST
//!
//! ast-grep supports common tree traversal algorithms, including
//! * Pre order traversal
//! * Post order traversal
//! * Level order traversal
//!
//! Note tree traversal can also be used with Matcher. A traversal with Matcher will
//! produce a [`NodeMatch`] sequence where all items satisfies the Matcher.
//!
//! It is also possible to specify the reentrancy of a traversal.
//! That is, we can control whether a matching node should be visited when it is nested within another match.
//! For example, suppose we want to find all usages of calling `foo` in the source `foo(foo())`.
//! The code has two matching calls and we can configure a traversal
//! to report only the inner one, only the outer one or both.
//!
//! Pre and Post order traversals in this module are implemented using tree-sitter's cursor API without extra heap allocation.
//! It is recommended to use traversal instead of tree recursion to avoid stack overflow and memory overhead.
//! Level order is also included for completeness and should be used sparingly.

use super::StrDoc;
use crate::matcher::{Matcher, MatcherExt};
use crate::tree_sitter::LanguageExt;
use crate::{Doc, Node, NodeMatch, Root};

use tree_sitter as ts;

use std::collections::VecDeque;
use std::marker::PhantomData;

pub struct Visitor<M, A = PreOrder> {
  /// Whether a node will match if it contains or is contained in another match.
  reentrant: bool,
  /// Whether visit named node only
  named_only: bool,
  /// optional matcher to filter nodes
  matcher: M,
  /// The algorithm to traverse the tree, can be pre/post/level order
  algorithm: PhantomData<A>,
}

impl<M> Visitor<M> {
  pub fn new(matcher: M) -> Visitor<M> {
    Visitor {
      reentrant: true,
      named_only: false,
      matcher,
      algorithm: PhantomData,
    }
  }
}

impl<M, A> Visitor<M, A> {
  pub fn algorithm<Algo>(self) -> Visitor<M, Algo> {
    Visitor {
      reentrant: self.reentrant,
      named_only: self.named_only,
      matcher: self.matcher,
      algorithm: PhantomData,
    }
  }

  pub fn reentrant(self, reentrant: bool) -> Self {
    Self { reentrant, ..self }
  }

  pub fn named_only(self, named_only: bool) -> Self {
    Self { named_only, ..self }
  }
}

impl<M, A> Visitor<M, A>
where
  A: Algorithm,
{
  pub fn visit<L: LanguageExt>(
    self,
    node: Node<'_, StrDoc<L>>,
  ) -> Visit<'_, StrDoc<L>, A::Traversal<'_, L>, M>
  where
    M: Matcher,
  {
    let traversal = A::traverse(node);
    Visit {
      reentrant: self.reentrant,
      named: self.named_only,
      matcher: self.matcher,
      traversal,
      lang: PhantomData,
    }
  }
}

pub struct Visit<'t, D, T, M> {
  reentrant: bool,
  named: bool,
  matcher: M,
  traversal: T,
  lang: PhantomData<&'t D>,
}
impl<'t, D, T, M> Visit<'t, D, T, M>
where
  D: Doc + 't,
  T: Traversal<'t, D>,
  M: Matcher,
{
  #[inline]
  fn mark_match(&mut self, depth: Option<usize>) {
    if !self.reentrant {
      self.traversal.calibrate_for_match(depth);
    }
  }
}

impl<'t, D, T, M> Iterator for Visit<'t, D, T, M>
where
  D: Doc + 't,
  T: Traversal<'t, D>,
  M: Matcher,
{
  type Item = NodeMatch<'t, D>;
  fn next(&mut self) -> Option<Self::Item> {
    loop {
      let match_depth = self.traversal.get_current_depth();
      let node = self.traversal.next()?;
      let pass_named = !self.named || node.is_named();
      if let Some(node_match) = pass_named.then(|| self.matcher.match_node(node)).flatten() {
        self.mark_match(Some(match_depth));
        return Some(node_match);
      } else {
        self.mark_match(None);
      }
    }
  }
}

pub trait Algorithm {
  type Traversal<'t, L: LanguageExt>: Traversal<'t, StrDoc<L>>;
  fn traverse<L: LanguageExt>(node: Node<'_, StrDoc<L>>) -> Self::Traversal<'_, L>;
}

pub struct PreOrder;
impl Algorithm for PreOrder {
  type Traversal<'t, L: LanguageExt> = Pre<'t, L>;
  fn traverse<L: LanguageExt>(node: Node<'_, StrDoc<L>>) -> Self::Traversal<'_, L> {
    Pre::new(&node)
  }
}
pub struct PostOrder;
impl Algorithm for PostOrder {
  type Traversal<'t, L: LanguageExt> = Post<'t, L>;
  fn traverse<L: LanguageExt>(node: Node<'_, StrDoc<L>>) -> Self::Traversal<'_, L> {
    Post::new(&node)
  }
}

/// Traversal can iterate over node by using traversal algorithm.
/// The `next` method should only handle normal, reentrant iteration.
/// If reentrancy is not desired, traversal should mutate cursor in `calibrate_for_match`.
/// Visit will maintain the matched node depth so traversal does not need to use extra field.
pub trait Traversal<'t, D: Doc + 't>: Iterator<Item = Node<'t, D>> {
  /// Calibrate cursor position to skip overlapping matches.
  /// node depth will be passed if matched, otherwise None.
  fn calibrate_for_match(&mut self, depth: Option<usize>);
  /// Returns the current depth of cursor depth.
  /// Cursor depth is incremented by 1 when moving from parent to child.
  /// Cursor depth at Root node is 0.
  fn get_current_depth(&self) -> usize;
}

/// Represents a pre-order traversal
pub struct TsPre<'tree> {
  cursor: ts::TreeCursor<'tree>,
  // record the starting node, if we return back to starting point
  // we should terminate the dfs.
  start_id: Option<usize>,
  current_depth: usize,
}

impl<'tree> TsPre<'tree> {
  pub fn new(node: &ts::Node<'tree>) -> Self {
    Self {
      cursor: node.walk(),
      start_id: Some(node.id()),
      current_depth: 0,
    }
  }
  fn step_down(&mut self) -> bool {
    if self.cursor.goto_first_child() {
      self.current_depth += 1;
      true
    } else {
      false
    }
  }

  // retrace back to ancestors and find next node to explore
  fn trace_up(&mut self, start: usize) {
    let cursor = &mut self.cursor;
    while cursor.node().id() != start {
      // try visit sibling nodes
      if cursor.goto_next_sibling() {
        return;
      }
      self.current_depth -= 1;
      // go back to parent node
      if !cursor.goto_parent() {
        // it should never fail here. However, tree-sitter has bad parsing bugs
        // stop to avoid panic. https://github.com/ast-grep/ast-grep/issues/713
        break;
      }
    }
    // terminate traversal here
    self.start_id = None;
  }
}

/// Amortized time complexity is O(NlgN), depending on branching factor.
impl<'tree> Iterator for TsPre<'tree> {
  type Item = ts::Node<'tree>;
  // 1. Yield the node itself
  // 2. Try visit the child node until no child available
  // 3. Try visit next sibling after going back to parent
  // 4. Repeat step 3 until returning to the starting node
  fn next(&mut self) -> Option<Self::Item> {
    // start_id will always be Some until the dfs terminates
    let start = self.start_id?;
    let cursor = &mut self.cursor;
    let inner = cursor.node(); // get current node
    let ret = Some(inner);
    // try going to children first
    if self.step_down() {
      return ret;
    }
    // if no child available, go to ancestor nodes
    // until we get to the starting point
    self.trace_up(start);
    ret
  }
}

pub struct Pre<'tree, L: LanguageExt> {
  root: &'tree Root<StrDoc<L>>,
  inner: TsPre<'tree>,
}
impl<'tree, L: LanguageExt> Iterator for Pre<'tree, L> {
  type Item = Node<'tree, StrDoc<L>>;
  fn next(&mut self) -> Option<Self::Item> {
    let inner = self.inner.next()?;
    Some(self.root.adopt(inner))
  }
}

impl<'t, L: LanguageExt> Pre<'t, L> {
  pub fn new(node: &Node<'t, StrDoc<L>>) -> Self {
    let inner = TsPre::new(&node.inner);
    Self {
      root: node.root,
      inner,
    }
  }
}

impl<'t, L: LanguageExt> Traversal<'t, StrDoc<L>> for Pre<'t, L> {
  fn calibrate_for_match(&mut self, depth: Option<usize>) {
    // not entering the node, ignore
    let Some(depth) = depth else {
      return;
    };
    // if already entering sibling or traced up, ignore
    if self.inner.current_depth <= depth {
      return;
    }
    debug_assert!(self.inner.current_depth > depth);
    if let Some(start) = self.inner.start_id {
      // revert the step down
      self.inner.cursor.goto_parent();
      self.inner.trace_up(start);
    }
  }

  #[inline]
  fn get_current_depth(&self) -> usize {
    self.inner.current_depth
  }
}

/// Represents a post-order traversal
pub struct Post<'tree, L: LanguageExt> {
  cursor: ts::TreeCursor<'tree>,
  root: &'tree Root<StrDoc<L>>,
  start_id: Option<usize>,
  current_depth: usize,
  match_depth: usize,
}

/// Amortized time complexity is O(NlgN), depending on branching factor.
impl<'tree, L: LanguageExt> Post<'tree, L> {
  pub fn new(node: &Node<'tree, StrDoc<L>>) -> Self {
    let mut ret = Self {
      cursor: node.inner.walk(),
      root: node.root,
      start_id: Some(node.inner.id()),
      current_depth: 0,
      match_depth: 0,
    };
    ret.trace_down();
    ret
  }
  fn trace_down(&mut self) {
    while self.cursor.goto_first_child() {
      self.current_depth += 1;
    }
  }
  fn step_up(&mut self) {
    self.current_depth -= 1;
    self.cursor.goto_parent();
  }
}

/// Amortized time complexity is O(NlgN), depending on branching factor.
impl<'tree, L: LanguageExt> Iterator for Post<'tree, L> {
  type Item = Node<'tree, StrDoc<L>>;
  fn next(&mut self) -> Option<Self::Item> {
    // start_id will always be Some until the dfs terminates
    let start = self.start_id?;
    let cursor = &mut self.cursor;
    let node = self.root.adopt(cursor.node());
    // return to start
    if node.inner.id() == start {
      self.start_id = None
    } else if cursor.goto_next_sibling() {
      // try visit sibling
      self.trace_down();
    } else {
      self.step_up();
    }
    Some(node)
  }
}

impl<'t, L: LanguageExt> Traversal<'t, StrDoc<L>> for Post<'t, L> {
  fn calibrate_for_match(&mut self, depth: Option<usize>) {
    if let Some(depth) = depth {
      // Later matches' depth should always be greater than former matches.
      // because we bump match_depth in `step_up` during traversal.
      debug_assert!(depth >= self.match_depth);
      self.match_depth = depth;
      return;
    }
    // found new nodes to explore in trace_down, skip calibration.
    if self.current_depth >= self.match_depth {
      return;
    }
    let Some(start) = self.start_id else {
      return;
    };
    while self.cursor.node().id() != start {
      self.match_depth = self.current_depth;
      if self.cursor.goto_next_sibling() {
        // try visit sibling
        self.trace_down();
        return;
      }
      self.step_up();
    }
    // terminate because all ancestors are skipped
    self.start_id = None;
  }

  #[inline]
  fn get_current_depth(&self) -> usize {
    self.current_depth
  }
}

/// Represents a level-order traversal.
/// It is implemented with [`VecDeque`] since quadratic backtracking is too time consuming.
/// Though level-order is not used as frequently as other DFS traversals,
/// traversing a big AST with level-order should be done with caution since it might increase the memory usage.
pub struct Level<'tree, L: LanguageExt> {
  deque: VecDeque<ts::Node<'tree>>,
  cursor: ts::TreeCursor<'tree>,
  root: &'tree Root<StrDoc<L>>,
}

impl<'tree, L: LanguageExt> Level<'tree, L> {
  pub fn new(node: &Node<'tree, StrDoc<L>>) -> Self {
    let mut deque = VecDeque::new();
    deque.push_back(node.inner);
    let cursor = node.inner.walk();
    Self {
      deque,
      cursor,
      root: node.root,
    }
  }
}

/// Time complexity is O(N). Space complexity is O(N)
impl<'tree, L: LanguageExt> Iterator for Level<'tree, L> {
  type Item = Node<'tree, StrDoc<L>>;
  fn next(&mut self) -> Option<Self::Item> {
    let inner = self.deque.pop_front()?;
    let children = inner.children(&mut self.cursor);
    self.deque.extend(children);
    Some(self.root.adopt(inner))
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use crate::language::Tsx;
  use std::ops::Range;

  // recursive pre order as baseline
  fn pre_order(node: Node<StrDoc<Tsx>>) -> Vec<Range<usize>> {
    let mut ret = vec![node.range()];
    ret.extend(node.children().flat_map(pre_order));
    ret
  }

  // recursion baseline
  fn post_order(node: Node<StrDoc<Tsx>>) -> Vec<Range<usize>> {
    let mut ret: Vec<_> = node.children().flat_map(post_order).collect();
    ret.push(node.range());
    ret
  }

  fn pre_order_equivalent(source: &str) {
    let grep = Tsx.ast_grep(source);
    let node = grep.root();
    let iterative: Vec<_> = Pre::new(&node).map(|n| n.range()).collect();
    let recursive = pre_order(node);
    assert_eq!(iterative, recursive);
  }

  fn post_order_equivalent(source: &str) {
    let grep = Tsx.ast_grep(source);
    let node = grep.root();
    let iterative: Vec<_> = Post::new(&node).map(|n| n.range()).collect();
    let recursive = post_order(node);
    assert_eq!(iterative, recursive);
  }

  const CASES: &[&str] = &[
    "console.log('hello world')",
    "let a = (a, b, c)",
    "function test() { let a = 1; let b = 2; a === b}",
    "[[[[[[]]]]], 1 , 2 ,3]",
    "class A { test() { class B {} } }",
  ];

  #[test]
  fn tes_pre_order() {
    for case in CASES {
      pre_order_equivalent(case);
    }
  }

  #[test]
  fn test_post_order() {
    for case in CASES {
      post_order_equivalent(case);
    }
  }

  #[test]
  fn test_different_order() {
    for case in CASES {
      let grep = Tsx.ast_grep(case);
      let node = grep.root();
      let pre: Vec<_> = Pre::new(&node).map(|n| n.range()).collect();
      let post: Vec<_> = Post::new(&node).map(|n| n.range()).collect();
      let level: Vec<_> = Level::new(&node).map(|n| n.range()).collect();
      assert_ne!(pre, post);
      assert_ne!(pre, level);
      assert_ne!(post, level);
    }
  }

  #[test]
  fn test_fused_traversal() {
    for case in CASES {
      let grep = Tsx.ast_grep(case);
      let node = grep.root();
      let mut pre = Pre::new(&node);
      let mut post = Post::new(&node);
      while pre.next().is_some() {}
      while post.next().is_some() {}
      assert!(pre.next().is_none());
      assert!(pre.next().is_none());
      assert!(post.next().is_none());
      assert!(post.next().is_none());
    }
  }

  #[test]
  fn test_non_root_traverse() {
    let grep = Tsx.ast_grep("let a = 123; let b = 123;");
    let node = grep.root();
    let pre: Vec<_> = Pre::new(&node).map(|n| n.range()).collect();
    let post: Vec<_> = Post::new(&node).map(|n| n.range()).collect();
    let node2 = node.child(0).unwrap();
    let pre2: Vec<_> = Pre::new(&node2).map(|n| n.range()).collect();
    let post2: Vec<_> = Post::new(&node2).map(|n| n.range()).collect();
    // traversal should stop at node
    assert_ne!(pre, pre2);
    assert_ne!(post, post2);
    // child traversal should be a part of parent traversal
    assert!(pre[1..].starts_with(&pre2));
    assert!(post.starts_with(&post2));
  }

  fn pre_order_with_matcher(node: Node<StrDoc<Tsx>>, matcher: &str) -> Vec<Range<usize>> {
    if node.matches(matcher) {
      vec![node.range()]
    } else {
      node
        .children()
        .flat_map(|n| pre_order_with_matcher(n, matcher))
        .collect()
    }
  }

  fn post_order_with_matcher(node: Node<StrDoc<Tsx>>, matcher: &str) -> Vec<Range<usize>> {
    let mut ret: Vec<_> = node
      .children()
      .flat_map(|n| post_order_with_matcher(n, matcher))
      .collect();
    if ret.is_empty() && node.matches(matcher) {
      ret.push(node.range());
    }
    ret
  }

  const MATCHER_CASES: &[&str] = &[
    "Some(123)",
    "Some(1, 2, Some(2))",
    "NoMatch",
    "NoMatch(Some(123))",
    "Some(1, Some(2), Some(3))",
    "Some(1, Some(2), Some(Some(3)))",
  ];

  #[test]
  fn test_pre_order_visitor() {
    let matcher = "Some($$$)";
    for case in MATCHER_CASES {
      let grep = Tsx.ast_grep(case);
      let node = grep.root();
      let recur = pre_order_with_matcher(grep.root(), matcher);
      let visit: Vec<_> = Visitor::new(matcher)
        .reentrant(false)
        .visit(node)
        .map(|n| n.range())
        .collect();
      assert_eq!(recur, visit);
    }
  }
  #[test]
  fn test_post_order_visitor() {
    let matcher = "Some($$$)";
    for case in MATCHER_CASES {
      let grep = Tsx.ast_grep(case);
      let node = grep.root();
      let recur = post_order_with_matcher(grep.root(), matcher);
      let visit: Vec<_> = Visitor::new(matcher)
        .algorithm::<PostOrder>()
        .reentrant(false)
        .visit(node)
        .map(|n| n.range())
        .collect();
      assert_eq!(recur, visit);
    }
  }

  // match a leaf node will trace_up the cursor
  #[test]
  fn test_traversal_leaf() {
    let matcher = "true";
    let case = "((((true))));true";
    let grep = Tsx.ast_grep(case);
    let recur = pre_order_with_matcher(grep.root(), matcher);
    let visit: Vec<_> = Visitor::new(matcher)
      .reentrant(false)
      .visit(grep.root())
      .map(|n| n.range())
      .collect();
    assert_eq!(recur, visit);
    let recur = post_order_with_matcher(grep.root(), matcher);
    let visit: Vec<_> = Visitor::new(matcher)
      .algorithm::<PostOrder>()
      .reentrant(false)
      .visit(grep.root())
      .map(|n| n.range())
      .collect();
    assert_eq!(recur, visit);
  }
}



================================================
FILE: crates/dynamic/Cargo.toml
================================================
[package]
name = "ast-grep-dynamic"
description = "Load tree-sitter dynamic library for ast-grep"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]

authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true

[dependencies]
ast-grep-core = { workspace = true, features = ["tree-sitter"] }

ignore.workspace = true
libloading = "0.8.3"
serde.workspace = true
thiserror.workspace = true
tree-sitter.workspace = true
target-triple = "0.1.4"

[dev-dependencies]
serde_yaml.workspace = true


================================================
FILE: crates/dynamic/src/custom_lang.rs
================================================
use crate::{DynamicLang, DynamicLangError, Registration};
use serde::{Deserialize, Serialize};

use std::collections::HashMap;
use std::path::{Path, PathBuf};

#[derive(Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum LibraryPath {
  Single(PathBuf),
  Platform(HashMap<String, PathBuf>),
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CustomLang {
  pub library_path: LibraryPath,
  /// the dylib symbol to load ts-language, default is `tree_sitter_{name}`
  pub language_symbol: Option<String>,
  pub meta_var_char: Option<char>,
  pub expando_char: Option<char>,
  pub extensions: Vec<String>,
}

impl CustomLang {
  pub fn register(base: &Path, langs: HashMap<String, CustomLang>) -> Result<(), DynamicLangError> {
    let registrations: Result<_, _> = langs
      .into_iter()
      .map(|(name, custom)| to_registration(name, custom, base))
      .collect();
    unsafe { DynamicLang::register(registrations?) }
  }
}

fn to_registration(
  name: String,
  custom_lang: CustomLang,
  base: &Path,
) -> Result<Registration, DynamicLangError> {
  let lib_path = match custom_lang.library_path {
    LibraryPath::Single(path) => path,
    LibraryPath::Platform(mut map) => {
      let target = target_triple::TARGET;
      map
        .remove(target)
        .ok_or(DynamicLangError::NotConfigured(target))?
    }
  };
  let path = base.join(lib_path);
  let sym = custom_lang
    .language_symbol
    .unwrap_or_else(|| format!("tree_sitter_{name}"));
  Ok(Registration {
    lang_name: name,
    lib_path: path,
    symbol: sym,
    meta_var_char: custom_lang.meta_var_char,
    expando_char: custom_lang.expando_char,
    extensions: custom_lang.extensions,
  })
}

#[cfg(test)]
mod test {
  use super::*;
  use serde_yaml::from_str;

  #[test]
  fn test_custom_lang() {
    let yaml = r"
libraryPath: a/b/c.so
extensions: [d, e, f]";
    let cus: CustomLang = from_str(yaml).unwrap();
    assert_eq!(cus.language_symbol, None);
    assert_eq!(cus.extensions, vec!["d", "e", "f"]);
  }
  fn is_test_supported() -> bool {
    cfg!(all(target_os = "macos", target_arch = "aarch64"))
      || cfg!(all(target_os = "linux", target_arch = "x86_64"))
  }

  #[test]
  fn test_custom_lang_platform() {
    if !is_test_supported() {
      return;
    }
    let yaml = r"
libraryPath:
  aarch64-apple-darwin: a/b/c.so
  x86_64-unknown-linux-gnu: a/b/c.so
extensions: [d, e, f]";
    let cus: CustomLang = from_str(yaml).unwrap();
    assert_eq!(cus.language_symbol, None);
    assert_eq!(cus.extensions, vec!["d", "e", "f"]);
    let registration = to_registration("test_lang".to_string(), cus, Path::new(".")).unwrap();
    assert_eq!(registration.lang_name, "test_lang");
    assert_eq!(registration.lib_path.to_str(), Some("./a/b/c.so"));
  }

  #[test]
  fn test_unsupport_platform() {
    let yaml = r"
libraryPath:
  impossible-platform: a/b/c.so
extensions: [d, e, f]";
    let cus: CustomLang = from_str(yaml).unwrap();
    let reg = to_registration("test_lang".to_string(), cus, Path::new("."));
    assert!(matches!(
      reg,
      Err(DynamicLangError::NotConfigured(target_triple::TARGET))
    ));
  }
}



================================================
FILE: crates/dynamic/src/lib.rs
================================================
use ast_grep_core::tree_sitter::{LanguageExt, StrDoc, TSLanguage};
use ast_grep_core::Language;

use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ignore::types::{Types, TypesBuilder};
use libloading::{Error as LibError, Library, Symbol};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tree_sitter::{Language as NativeTS, LANGUAGE_VERSION, MIN_COMPATIBLE_LANGUAGE_VERSION};

use std::borrow::Cow;
use std::fs::canonicalize;
use std::path::{Path, PathBuf};
use std::ptr::{addr_of, addr_of_mut};
use std::str::FromStr;

mod custom_lang;

pub use custom_lang::{CustomLang, LibraryPath};

type LangIndex = u32;

/// Represents a tree-sitter language loaded as dynamic lib.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DynamicLang {
  index: LangIndex,
  // inline expando char since it is used frequently
  expando: char,
}

impl DynamicLang {
  pub fn all_langs() -> Vec<Self> {
    Self::langs()
      .iter()
      .enumerate()
      .map(|(index, inner)| DynamicLang {
        index: index as LangIndex,
        expando: inner.expando_char,
      })
      .collect()
  }
  pub fn file_types(&self) -> Types {
    let mut builder = TypesBuilder::new();
    let inner = self.inner();
    let mapping = unsafe { &*addr_of!(LANG_INDEX) };
    for (ext, i) in mapping.iter() {
      if *i == self.index {
        builder
          .add(&inner.name, &format!("*.{ext}"))
          .expect("file pattern must compile");
      }
    }
    builder.select(&inner.name);
    builder.build().expect("file type must be valid")
  }
}

impl Serialize for DynamicLang {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    let name = &self.inner().name;
    serializer.serialize_str(name)
  }
}

impl<'de> Deserialize<'de> for DynamicLang {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let name = String::deserialize(deserializer)?;
    DynamicLang::from_str(&name).map_err(serde::de::Error::custom)
  }
}

impl FromStr for DynamicLang {
  type Err = String;
  fn from_str(name: &str) -> Result<Self, Self::Err> {
    let langs = Self::langs();
    for (i, lang) in langs.iter().enumerate() {
      if lang.name == name {
        return Ok(DynamicLang {
          index: i as LangIndex,
          expando: lang.expando_char,
        });
      }
    }
    Err(format!("unknown language `{name}`."))
  }
}

struct Inner {
  lang: TSLanguage,
  name: String,
  meta_var_char: char,
  expando_char: char,
  // NOTE: need to hold a reference of lib to avoid cleanup
  _lib: Library,
}

#[derive(Debug, Error)]
pub enum DynamicLangError {
  #[error("Target dynamic lib `{0}` is not configure")]
  NotConfigured(&'static str),
  #[error("cannot load lib")]
  OpenLib(#[source] LibError),
  #[error("cannot read symbol")]
  ReadSymbol(#[source] LibError),
  #[error("Incompatible tree-sitter parser version `{0}`")]
  IncompatibleVersion(usize),
  #[error("cannot get the absolute path of dynamic lib")]
  GetLibPath(#[from] std::io::Error),
}

/// # Safety: we must keep lib in memory after load it.
/// libloading will do cleanup if `Library` is dropped which makes any lib symbol null pointer.
/// This is not desirable for our case.
unsafe fn load_ts_language(
  path: PathBuf,
  name: String,
) -> Result<(Library, TSLanguage), DynamicLangError> {
  let abs_path = canonicalize(path)?;
  let lib = Library::new(abs_path.as_os_str()).map_err(DynamicLangError::OpenLib)?;
  // NOTE: func is a symbol with lifetime bound to `lib`.
  // If we drop lib in the scope, func will be a dangling pointer.
  let func: Symbol<unsafe extern "C" fn() -> NativeTS> = lib
    .get(name.as_bytes())
    .map_err(DynamicLangError::ReadSymbol)?;
  let lang = func();
  let version = lang.abi_version();
  if !(MIN_COMPATIBLE_LANGUAGE_VERSION..=LANGUAGE_VERSION).contains(&version) {
    Err(DynamicLangError::IncompatibleVersion(version))
  } else {
    // ATTENTION: dragon ahead
    // must hold valid reference to NativeTS
    Ok((lib, lang))
  }
}

// both use vec since lang will be small
static mut DYNAMIC_LANG: Vec<Inner> = vec![];
static mut LANG_INDEX: Vec<(String, u32)> = vec![];

#[derive(Default)]
pub struct Registration {
  pub lang_name: String,
  pub lib_path: PathBuf,
  pub symbol: String,
  pub meta_var_char: Option<char>,
  pub expando_char: Option<char>,
  pub extensions: Vec<String>,
}

impl DynamicLang {
  /// # Safety
  /// the register function should be called exactly once before use.
  /// It relies on a global mut static variable to be initialized.
  pub unsafe fn register(regs: Vec<Registration>) -> Result<(), DynamicLangError> {
    debug_assert!(Self::langs().is_empty());
    let mut langs = vec![];
    let mut mapping = vec![];
    for reg in regs {
      Self::register_one(reg, &mut langs, &mut mapping)?;
    }
    _ = std::mem::replace(&mut *addr_of_mut!(DYNAMIC_LANG), langs);
    _ = std::mem::replace(&mut *addr_of_mut!(LANG_INDEX), mapping);
    Ok(())
  }

  pub fn name(&self) -> &str {
    &self.inner().name
  }

  fn register_one(
    reg: Registration,
    langs: &mut Vec<Inner>,
    mapping: &mut Vec<(String, LangIndex)>,
  ) -> Result<(), DynamicLangError> {
    // lib must be retained!!
    let (_lib, lang) = unsafe { load_ts_language(reg.lib_path, reg.symbol)? };
    let meta_var_char = reg.meta_var_char.unwrap_or('$');
    let expando_char = reg.expando_char.unwrap_or(meta_var_char);
    let inner = Inner {
      name: reg.lang_name,
      lang,
      meta_var_char,
      expando_char,
      _lib,
    };
    langs.push(inner);
    let idx = langs.len() as LangIndex - 1;
    for ext in reg.extensions {
      mapping.push((ext, idx));
    }
    Ok(())
  }
  fn inner(&self) -> &Inner {
    let langs = Self::langs();
    &langs[self.index as usize]
  }

  fn langs() -> &'static Vec<Inner> {
    unsafe { &*addr_of!(DYNAMIC_LANG) }
  }
}
impl Language for DynamicLang {
  /// normalize pattern code before matching
  /// e.g. remove expression_statement, or prefer parsing {} to object over block
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    if self.meta_var_char() == self.expando_char() {
      return Cow::Borrowed(query);
    };
    // use stack buffer to reduce allocation
    let mut buf = [0; 4];
    let expando = self.expando_char().encode_utf8(&mut buf);
    // TODO: use more precise replacement
    let replaced = query.replace(self.meta_var_char(), expando);
    Cow::Owned(replaced)
  }

  /// Configure meta variable special character
  /// By default $ is the metavar char, but in PHP it can be #
  #[inline]
  fn meta_var_char(&self) -> char {
    self.inner().meta_var_char
  }

  /// Some language does not accept $ as the leading char for identifiers.
  /// We need to change $ to other char at run-time to make parser happy, thus the name expando.
  /// By default this is the same as meta_var char so replacement is done at runtime.
  #[inline]
  fn expando_char(&self) -> char {
    self.expando
  }

  fn kind_to_id(&self, kind: &str) -> u16 {
    let inner = self.inner();
    inner.lang.id_for_node_kind(kind, true)
  }
  fn field_to_id(&self, field: &str) -> Option<u16> {
    let inner = self.inner();
    inner.lang.field_id_for_name(field).map(|f| f.get())
  }

  fn from_path<P: AsRef<Path>>(path: P) -> Option<Self> {
    let ext = path.as_ref().extension()?.to_str()?;
    let mapping = unsafe { &*addr_of!(LANG_INDEX) };
    let langs = Self::langs();
    mapping.iter().find_map(|(p, idx)| {
      if p == ext {
        let index = *idx;
        Some(Self {
          index,
          expando: langs[*idx as usize].expando_char,
        })
      } else {
        None
      }
    })
  }
  fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
    builder.build(|src| {
      let doc = StrDoc::try_new(src, *self)?;
      Ok(doc)
    })
  }
}

impl LanguageExt for DynamicLang {
  /// tree sitter language to parse the source
  fn get_ts_language(&self) -> TSLanguage {
    self.inner().lang.clone()
  }
}

#[cfg(test)]
mod test {
  use super::*;

  // currently we only have json parser for these platforms
  // apple silicon macos and linux x86_64
  fn get_tree_sitter_path() -> &'static str {
    if cfg!(all(target_os = "macos", target_arch = "aarch64")) {
      "../../fixtures/json-mac.so"
    } else if cfg!(all(target_os = "linux", target_arch = "x86_64")) {
      "../../fixtures/json-linux.so"
    } else {
      ""
    }
  }

  #[derive(Clone)]
  struct TSLangWrapper(TSLanguage);

  impl Language for TSLangWrapper {
    fn kind_to_id(&self, kind: &str) -> u16 {
      self.0.id_for_node_kind(kind, /* named */ true)
    }
    fn field_to_id(&self, field: &str) -> Option<u16> {
      self.0.field_id_for_name(field).map(|f| f.get())
    }
    fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
      builder.build(|src| StrDoc::try_new(src, self.clone()))
    }
  }

  impl LanguageExt for TSLangWrapper {
    fn get_ts_language(&self) -> TSLanguage {
      self.0.clone()
    }
  }

  #[test]
  fn test_load_parser() {
    let path = get_tree_sitter_path();
    // skip unsupported platform
    if path.is_empty() {
      return;
    }
    let (_lib, lang) = unsafe { load_ts_language(path.into(), "tree_sitter_json".into()).unwrap() };
    let lang = TSLangWrapper(lang);
    let sg = lang.ast_grep("{\"a\": 123}");
    assert_eq!(
      sg.root().get_inner_node().to_sexp(),
      "(document (object (pair key: (string (string_content)) value: (number))))"
    );
  }

  #[test]
  fn test_register_lang() {
    let path = get_tree_sitter_path();
    // skip unsupported platform
    if path.is_empty() {
      return;
    }
    let registration = Registration {
      lang_name: "json".to_string(),
      expando_char: Some('_'),
      extensions: vec!["json".into()],
      lib_path: PathBuf::from(path),
      meta_var_char: None,
      symbol: "tree_sitter_json".into(),
    };
    unsafe {
      DynamicLang::register(vec![registration]).expect("should succeed");
    }
    let langs = DynamicLang::all_langs();
    assert_eq!(langs.len(), 1);
    let lang = langs[0];
    let file_types = lang.file_types();
    assert!(file_types.matched("test.json", false).is_whitelist());
    assert_eq!(lang.name(), "json");
    let sg = lang.ast_grep("{\"test\": 123}");
    assert!(sg.root().find("123").is_some());
    let parsed = DynamicLang::from_str("json").expect("ok");
    assert_eq!(parsed.index, lang.index);
  }
}



================================================
FILE: crates/language/Cargo.toml
================================================
[package]
name = "ast-grep-language"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]

authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true

[dependencies]
ast-grep-core = { workspace = true, features = ["tree-sitter"] }

ignore.workspace = true
serde.workspace = true
tree-sitter.workspace = true

tree-sitter-bash = { version = "0.25.0", optional = true }
tree-sitter-cpp = { version = "0.23.0", optional = true }
tree-sitter-c-sharp = { version = "0.23.0", optional = true }
tree-sitter-css = { version = "0.23.2", optional = true }
tree-sitter-c = { version = "0.24.0", optional = true }
tree-sitter-elixir = { version = "0.3.0", optional = true }
tree-sitter-go = { version = "0.23.0", optional = true }
tree-sitter-haskell = { version = "0.23.0", optional = true }
tree-sitter-html = { version = "0.23.0", optional = true }
tree-sitter-javascript = { version = "0.25.0", optional = true }
tree-sitter-java = { version = "0.23.0", optional = true }
tree-sitter-json = { version = "0.23.0", optional = true }
tree-sitter-kotlin = { version = "0.4.0", optional = true, package = "tree-sitter-kotlin-sg" }
tree-sitter-lua = { version = "0.2.0", optional = true }
tree-sitter-nix = { version = "0.3.0", optional = true }
tree-sitter-php = { version = "0.24.0", optional = true }
tree-sitter-python = { version = "0.25.0", optional = true }
tree-sitter-ruby = { version = "0.23.0", optional = true }
tree-sitter-rust = { version = "0.24.0", optional = true }
tree-sitter-scala = { version = "0.24.0", optional = true }
tree-sitter-solidity = { version = "1.2.11", optional = true }
tree-sitter-swift = { version = "0.7.0", optional = true }
tree-sitter-typescript = { version = "0.23.2", optional = true }
tree-sitter-yaml = { version = "0.7.0", optional = true }
tree-sitter-hcl = { version = "1.1.0", optional = true }

[features]
builtin-parser = [
  "tree-sitter-bash",
  "tree-sitter-c",
  "tree-sitter-cpp",
  "tree-sitter-c-sharp",
  "tree-sitter-css",
  "tree-sitter-elixir",
  "tree-sitter-go",
  "tree-sitter-haskell",
  "tree-sitter-hcl",
  "tree-sitter-html",
  "tree-sitter-java",
  "tree-sitter-javascript",
  "tree-sitter-json",
  "tree-sitter-kotlin",
  "tree-sitter-lua",
  "tree-sitter-nix",
  "tree-sitter-php",
  "tree-sitter-python",
  "tree-sitter-ruby",
  "tree-sitter-rust",
  "tree-sitter-scala",
  "tree-sitter-solidity",
  "tree-sitter-swift",
  "tree-sitter-typescript",
  "tree-sitter-yaml",
]
napi-lang = [
  "tree-sitter-css",
  "tree-sitter-html",
  "tree-sitter-javascript",
  "tree-sitter-typescript",
]
default = ["builtin-parser"]



================================================
FILE: crates/language/src/bash.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Bash);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Bash);
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Bash)
}

#[test]
fn test_bash_pattern() {
  test_match("123", "123");
  test_match("echo $A", "echo test");
  // TODO
  // test_match("echo { $A }", "echo {1..10}");
  test_match("echo $abc", "echo $abc");
}

#[test]
fn test_bash_pattern_no_match() {
  test_non_match("echo $abc", "echo test");
  test_non_match("echo $abc", "echo $ABC");
}

#[test]
fn test_bash_replace() {
  // TODO: change the replacer to log $A
  let ret = test_replace("echo 123", "echo $A", "log 123");
  assert_eq!(ret, "log 123");
}



================================================
FILE: crates/language/src/cpp.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Cpp);
}

#[test]
fn test_cpp_pattern() {
  test_match("$A->b()", "expr->b()");
  test_match("if (a) { $$$VERYLONGNAME }", "if (a) { a;b;c; }");
  test_match("expr->$B()", "expr->b()");
  test_match("ns::ns2::$F()", "ns::ns2::func()");
  test_match("template <typename $T>", "template <typename T>");
  test_match("if constexpr ($C) {}", "if constexpr (13+5==18) {}");
  test_match(
    "template <typename T> typename std::enable_if<$C, T>::type;",
    "template <typename T> typename std::enable_if<std::is_signed<T>::value, T>::type;",
  );
  test_match("if ($A)", "if (a | b) abc;");
  // see https://github.com/ast-grep/ast-grep/issues/1791
  test_match("struct $A: $B", "struct A: B {}");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Cpp)
}

#[test]
fn test_cpp_replace() {
  let ret = test_replace("expr->b()", "$A->b()", "func($A)->b()");
  assert_eq!(ret, "func(expr)->b()");
  let ret = test_replace("if (a) { a;b;c; }", "if (a) { $$$A }", "$$$A");
  assert_eq!(ret, "a;b;c;");
  // https://stackoverflow.com/questions/78663351
  let ret = test_replace(
    "if (a) { a;b;c; }",
    "if (a) { $$$VERYLONGNAME }",
    "$$$VERYLONGNAME",
  );
  assert_eq!(ret, "a;b;c;");
}



================================================
FILE: crates/language/src/csharp.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, CSharp);
}

#[test]
fn test_c_sharp_pattern() {
  let target = "if (table == null) ThrowHelper.ThrowArgumentNullException(nameof(table));";
  test_match("int $A = 0;", "int nint = 0;");
  test_match("ThrowHelper.ThrowArgumentNullException($_)", target);
  test_match("ThrowHelper.$_", target);
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, CSharp)
}

#[test]
fn test_c_sharp_replace() {
  let ret = test_replace("int @int = 0;", "int $A = 0", "bool @bool = true");
  assert_eq!(ret, "bool @bool = true;");
}



================================================
FILE: crates/language/src/css.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Css);
}

#[test]
fn test_css_pattern() {
  test_match("$A { color: red; }", ".a { color: red; }");
  test_match(".a { color: $COLOR; }", ".a { color: red; }");
  test_match(".a { $PROP: red; }", ".a { color: red; }");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Css)
}

#[test]
fn test_css_replace() {
  let ret = test_replace(
    ".a {color: red; }",
    ".a { color: $COLOR}",
    ".a {background: $COLOR}",
  );
  assert_eq!(ret, ".a {background: red}");
}



================================================
FILE: crates/language/src/elixir.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Elixir);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Elixir);
}

#[test]
fn test_elixir_str() {
  test_match("IO.puts(\"$A\")", "IO.puts(\"123\")");
  test_match("IO.puts($A)", "IO.puts(123)");
  test_non_match("IO.puts(123)", "IO.puts(456)");
  test_non_match("\"123\"", "\"456\"");
}

#[test]
fn test_elixir_pattern() {
  test_match("$A", ":ok");
  test_match("$A != nil", "a != nil");
  test_match(
    r#"
    def $FUNC($$$ARGS) when $GUARDS do
      $$$BODY
    end
    "#,
    r#"
    def add(a, b) when is_integer(a) and is_integer(b) do
      a + b
    end
    "#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Elixir)
}

#[test]
fn test_elixir_replace() {
  let ret = test_replace(
    "Stream.map([1, 2, 3], fn x -> x * 2 end)",
    "Stream.map($$$ARGS)",
    "Enum.map($$$ARGS)",
  );
  assert_eq!(ret, "Enum.map([1, 2, 3], fn x -> x * 2 end)");

  let ret = test_replace(
    ":budgie = hd([:budgie, :cat, :dog])",
    "$FIRST = hd($LIST)",
    "[$FIRST | _] = $LIST",
  );
  assert_eq!(ret, "[:budgie | _] = [:budgie, :cat, :dog]");

  let ret = test_replace(
    "opts[:hostname] || \"localhost\"",
    "opts[$KEY] || $DEFAULT",
    "Keyword.get(opts, $KEY, $DEFAULT)",
  );
  assert_eq!(ret, "Keyword.get(opts, :hostname, \"localhost\")");

  let ret = test_replace(
    "Module.function(:a, :b)",
    "Module.function($ARG1, $ARG2)",
    "Module.function($ARG2, $ARG1)",
  );
  assert_eq!(ret, "Module.function(:b, :a)");

  let ret = test_replace(
    "Greeter.greet(:hello, \"human\")",
    "Greeter.greet($ARG1, $ARG2)",
    "Greeter.greet($ARG1, name: $ARG2)",
  );
  assert_eq!(ret, "Greeter.greet(:hello, name: \"human\")");

  let ret = test_replace(
    "for x <- [\"budgie\", \"cat\", \"dog\"], do: String.to_atom(x)",
    "for $I <- $LIST, do: $MODULE.$FUNCTION($I)",
    "Enum.map($LIST, fn $I -> $MODULE.$FUNCTION($I) end)",
  );
  assert_eq!(
    ret,
    "Enum.map([\"budgie\", \"cat\", \"dog\"], fn x -> String.to_atom(x) end)"
  );
}



================================================
FILE: crates/language/src/go.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Go);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Go);
}

#[test]
fn test_go_str() {
  test_match("print($A)", "print(123)");
  test_match("print('123')", "print('123')");
  test_non_match("print('123')", "print('456')");
  test_non_match("'123'", "'456'");
}

#[test]
fn test_go_pattern() {
  test_match("$A = 0", "a = 0");
  test_match(
    r#"func $A($$$) $B { $$$ }"#,
    r#"
func plus(a int, b int) int {
  return a + b
}"#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Go)
}

#[test]
fn test_go_replace() {
  let ret = test_replace(
    r#"
func intSeq() {
  defer func()  {
      i++
  }()
}"#,
    r#"defer func() {
$$$BODY }()"#,
    r#"func b() { $$$BODY }"#,
  );
  assert_eq!(
    ret,
    r#"
func intSeq() {
  func b() { i++ }
}"#
  );
}



================================================
FILE: crates/language/src/haskell.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Haskell);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Haskell);
}

#[test]
fn test_haskell_str() {
  test_match("return $A", "return 3");
  test_match(r#""abc""#, r#""abc""#);
  test_match("$A $B", "f x");
  test_match("$A ($B $C)", "f (x y)");
  test_match("let $A = $B in $A + $A", "let x = 3 in x + x");
  test_non_match("$A $B", "f");
  test_non_match("$A + $A", "3 + 4");
  test_non_match("$A ($B $C)", "f x y");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Haskell)
}

#[test]
fn test_haskell_replace() {
  let ret = test_replace(
    r#"
fibonacci :: [Int]
fibonacci =
  1 : 1 : zipWith (+) fibonacci (tail fibonacci)
"#,
    r#"$F = $$$BODY"#,
    r#"$F = undefined"#,
  );
  assert_eq!(
    ret,
    r#"
fibonacci :: [Int]
fibonacci = undefined
"#
  );

  let ret = test_replace(
    r#"
flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x
"#,
    r#"$F :: $A -> $B"#,
    r#"$F :: ($B) -> $A"#,
  );
  assert_eq!(
    ret,
    r#"
flip :: (b -> a -> c) -> (a -> b -> c)
flip f x y = f y x
"#
  );
}



================================================
FILE: crates/language/src/hcl.rs
================================================
#![cfg(test)]
use super::*;
use crate::test::{test_match_lang, test_replace_lang};

fn test_match(s1: &str, s2: &str) {
  test_match_lang(s1, s2, Hcl)
}

#[test]
fn test_hcl_pattern() {
  test_match("$A = $B", r#"foo = "bar""#);
  test_match(
    "resource $TYPE $NAME $BODY",
    r#"resource "aws_instance" "example" { ami = "ami-123" }"#,
  );
  test_match(
    "$BLOCK $BODY",
    r#"terraform { required_providers { aws = { source = "hashicorp/aws" } } }"#,
  );
  test_match(
    "variable $NAME $CONFIG",
    r#"variable "region" { default = "us-west-2" }"#,
  );
  test_match(
    "output $NAME $VALUE",
    r#"output "instance_ip" { value = aws_instance.example.public_ip }"#,
  );
  test_match("$VAR = [$$$ITEMS]", r#"tags = ["production", "web"]"#);
  test_match(
    "$VAR = { $$$PAIRS }",
    r#"labels = { environment = "prod", team = "backend" }"#,
  );
  test_match(r#"$VAR = "$CONTENT""#, r#"name = "instance""#);
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  test_replace_lang(src, pattern, replacer, Hcl)
}

#[test]
fn test_hcl_replace() {
  let ret = test_replace(r#"foo = "bar""#, r#"$A = $B"#, r#"$B = $A"#);
  assert_eq!(ret, r#""bar" = foo"#);

  let ret = test_replace(
    r#"resource "aws_instance" "example" { ami = "ami-123" }"#,
    r#"resource $TYPE $NAME $BODY"#,
    r#"resource $NAME $TYPE $BODY"#,
  );
  assert_eq!(
    ret,
    r#"resource "example" "aws_instance" { ami = "ami-123" }"#
  );

  let ret = test_replace(
    r#"variable "region" { default = "us-west-2" }"#,
    r#"variable "region" { default = $DEFAULT }"#,
    r#"variable "region" { default = "eu-west-1" }"#,
  );
  assert_eq!(ret, r#"variable "region" { default = "eu-west-1" }"#);
}



================================================
FILE: crates/language/src/html.rs
================================================
use super::pre_process_pattern;
use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ast_grep_core::tree_sitter::{LanguageExt, StrDoc, TSLanguage, TSRange};
use ast_grep_core::Language;
use ast_grep_core::{matcher::KindMatcher, Doc, Node};
use std::collections::HashMap;

// tree-sitter-html uses locale dependent iswalnum for tagName
// https://github.com/tree-sitter/tree-sitter-html/blob/b5d9758e22b4d3d25704b72526670759a9e4d195/src/scanner.c#L194
#[derive(Clone, Copy, Debug)]
pub struct Html;
impl Language for Html {
  fn expando_char(&self) -> char {
    'z'
  }
  fn pre_process_pattern<'q>(&self, query: &'q str) -> std::borrow::Cow<'q, str> {
    pre_process_pattern(self.expando_char(), query)
  }
  fn kind_to_id(&self, kind: &str) -> u16 {
    crate::parsers::language_html().id_for_node_kind(kind, true)
  }
  fn field_to_id(&self, field: &str) -> Option<u16> {
    crate::parsers::language_html()
      .field_id_for_name(field)
      .map(|f| f.get())
  }
  fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
    builder.build(|src| StrDoc::try_new(src, *self))
  }
}
impl LanguageExt for Html {
  fn get_ts_language(&self) -> TSLanguage {
    crate::parsers::language_html()
  }
  fn injectable_languages(&self) -> Option<&'static [&'static str]> {
    Some(&["css", "js", "ts", "tsx", "scss", "less", "stylus", "coffee"])
  }
  fn extract_injections<L: LanguageExt>(
    &self,
    root: Node<StrDoc<L>>,
  ) -> HashMap<String, Vec<TSRange>> {
    let lang = root.lang();
    let mut map = HashMap::new();
    let matcher = KindMatcher::new("script_element", lang.clone());
    for script in root.find_all(matcher) {
      let injected = find_lang(&script).unwrap_or_else(|| "js".into());
      let content = script.children().find(|c| c.kind() == "raw_text");
      if let Some(content) = content {
        map
          .entry(injected)
          .or_insert_with(Vec::new)
          .push(node_to_range(&content));
      };
    }
    let matcher = KindMatcher::new("style_element", lang.clone());
    for style in root.find_all(matcher) {
      let injected = find_lang(&style).unwrap_or_else(|| "css".into());
      let content = style.children().find(|c| c.kind() == "raw_text");
      if let Some(content) = content {
        map
          .entry(injected)
          .or_insert_with(Vec::new)
          .push(node_to_range(&content));
      };
    }
    map
  }
}

fn find_lang<D: Doc>(node: &Node<D>) -> Option<String> {
  let html = node.lang();
  let attr_matcher = KindMatcher::new("attribute", html.clone());
  let name_matcher = KindMatcher::new("attribute_name", html.clone());
  let val_matcher = KindMatcher::new("attribute_value", html.clone());
  node.find_all(attr_matcher).find_map(|attr| {
    let name = attr.find(&name_matcher)?;
    if name.text() != "lang" {
      return None;
    }
    let val = attr.find(&val_matcher)?;
    Some(val.text().to_string())
  })
}

fn node_to_range<D: Doc>(node: &Node<D>) -> TSRange {
  let r = node.range();
  let start = node.start_pos();
  let sp = start.byte_point();
  let sp = tree_sitter::Point::new(sp.0, sp.1);
  let end = node.end_pos();
  let ep = end.byte_point();
  let ep = tree_sitter::Point::new(ep.0, ep.1);
  TSRange {
    start_byte: r.start,
    end_byte: r.end,
    start_point: sp,
    end_point: ep,
  }
}

#[cfg(test)]
mod test {
  use super::*;

  fn test_match(query: &str, source: &str) {
    use crate::test::test_match_lang;
    test_match_lang(query, source, Html);
  }

  fn test_non_match(query: &str, source: &str) {
    use crate::test::test_non_match_lang;
    test_non_match_lang(query, source, Html);
  }

  #[test]
  fn test_html_match() {
    test_match("<input>", "<input>");
    test_match("<$TAG>", "<input>");
    test_match("<$TAG class='foo'>$$$</$TAG>", "<div class='foo'></div>");
    test_match("<div>$$$</div>", "<div>123</div>");
    test_non_match("<$TAG class='foo'>$$$</$TAG>", "<div></div>");
    test_non_match("<div>$$$</div>", "<div class='foo'>123</div>");
  }

  fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
    use crate::test::test_replace_lang;
    test_replace_lang(src, pattern, replacer, Html)
  }

  #[test]
  fn test_html_replace() {
    let ret = test_replace(
      r#"<div class='foo'>bar</div>"#,
      r#"<$TAG class='foo'>$$$B</$TAG>"#,
      r#"<$TAG class='$$$B'>foo</$TAG>"#,
    );
    assert_eq!(ret, r#"<div class='bar'>foo</div>"#);
  }

  fn extract(src: &str) -> HashMap<String, Vec<TSRange>> {
    let root = Html.ast_grep(src);
    Html.extract_injections(root.root())
  }

  #[test]
  fn test_html_extraction() {
    let map = extract("<script>a</script><style>.a{}</style>");
    assert!(map.contains_key("css"));
    assert!(map.contains_key("js"));
    assert_eq!(map["css"].len(), 1);
    assert_eq!(map["js"].len(), 1);
  }

  #[test]
  fn test_explicit_lang() {
    let map = extract("<script lang='ts'>a</script><script lang=ts>.a{}</script><style lang=scss></style><style lang=\"scss\"></style>");
    assert!(map.contains_key("ts"));
    assert_eq!(map["ts"].len(), 2);
    assert_eq!(map["scss"].len(), 2);
  }
}



================================================
FILE: crates/language/src/json.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Json);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Json);
}

#[test]
fn test_json_str() {
  test_match("123", "123");
  test_match("{\"d\": 123}", "{\"d\": 123}");
  test_non_match("344", "123");
  test_non_match("{\"key\": 123}", "{}");
}

#[test]
fn test_json_pattern() {
  test_match("$A", "123");
  test_match(r#"[$A]"#, r#"[123]"#);
  test_match(r#"{ $$$ }"#, r#"{"abc": 123}"#);
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Json)
}

#[test]
fn test_json_replace() {
  let ret = test_replace(r#"{ "a": 123 }"#, r#"123"#, r#"456"#);
  assert_eq!(ret, r#"{ "a": 456 }"#);
}



================================================
FILE: crates/language/src/kotlin.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Kotlin);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Kotlin);
}

#[test]
fn test_kotlin_str() {
  test_match("println($A)", "println(123)");
  test_match("println('123')", "println('123')");
  test_non_match("println('123')", "println('456')");
  test_non_match("'123'", "'456'");
}

#[test]
fn test_kotlin_pattern() {
  test_match("$A = 0", "a = 0");
  test_match(
    r#"fun $A($$$): $B { $$$ }"#,
    r#"
fun plus(a: Int, b: Int): Int {
  return a + b
}"#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Kotlin)
}

#[test]
fn test_kotlin_replace() {
  let ret = test_replace(
    r#"
fun plus(a: Int, b: Int): Int {
  return a + b
}"#,
    r#"fun $F($$$): $R { $$$BODY }"#,
    r#"fun $F() { $$$BODY }"#,
  );
  assert_eq!(
    ret,
    r#"
fun plus() { return a + b }"#
  );
}



================================================
FILE: crates/language/src/lib.rs
================================================
//! This module defines the supported programming languages for ast-grep.
//!
//! It provides a set of customized languages with expando_char / pre_process_pattern,
//! and a set of stub languages without preprocessing.
//! A rule of thumb: if your language does not accept identifiers like `$VAR`.
//! You need use `impl_lang_expando!` macro and a standalone file for testing.
//! Otherwise, you can define it as a stub language using `impl_lang!`.
//! To see the full list of languages, visit `<https://ast-grep.github.io/reference/languages.html>`
//!
//! ```
//! use ast_grep_language::{LanguageExt, SupportLang};
//!
//! let lang: SupportLang = "rs".parse().unwrap();
//! let src = "fn foo() {}";
//! let root = lang.ast_grep(src);
//! let found = root.root().find_all("fn $FNAME() {}").next().unwrap();
//! assert_eq!(found.start_pos().line(), 0);
//! assert_eq!(found.text(), "fn foo() {}");
//! ```

mod bash;
mod cpp;
mod csharp;
mod css;
mod elixir;
mod go;
mod haskell;
mod hcl;
mod html;
mod json;
mod kotlin;
mod lua;
mod nix;
mod parsers;
mod php;
mod python;
mod ruby;
mod rust;
mod scala;
mod solidity;
mod swift;
mod yaml;

use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
pub use html::Html;

use ast_grep_core::meta_var::MetaVariable;
use ast_grep_core::tree_sitter::{StrDoc, TSLanguage, TSRange};
use ast_grep_core::Node;
use ignore::types::{Types, TypesBuilder};
use serde::de::Visitor;
use serde::{de, Deserialize, Deserializer, Serialize};
use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::iter::repeat;
use std::path::Path;
use std::str::FromStr;

pub use ast_grep_core::language::Language;
pub use ast_grep_core::tree_sitter::LanguageExt;

/// this macro implements bare-bone methods for a language
macro_rules! impl_lang {
  ($lang: ident, $func: ident) => {
    #[derive(Clone, Copy, Debug)]
    pub struct $lang;
    impl Language for $lang {
      fn kind_to_id(&self, kind: &str) -> u16 {
        self
          .get_ts_language()
          .id_for_node_kind(kind, /*named*/ true)
      }
      fn field_to_id(&self, field: &str) -> Option<u16> {
        self
          .get_ts_language()
          .field_id_for_name(field)
          .map(|f| f.get())
      }
      fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
        builder.build(|src| StrDoc::try_new(src, self.clone()))
      }
    }
    impl LanguageExt for $lang {
      fn get_ts_language(&self) -> TSLanguage {
        parsers::$func().into()
      }
    }
  };
}

fn pre_process_pattern(expando: char, query: &str) -> std::borrow::Cow<'_, str> {
  let mut ret = Vec::with_capacity(query.len());
  let mut dollar_count = 0;
  for c in query.chars() {
    if c == '$' {
      dollar_count += 1;
      continue;
    }
    let need_replace = matches!(c, 'A'..='Z' | '_') // $A or $$A or $$$A
      || dollar_count == 3; // anonymous multiple
    let sigil = if need_replace { expando } else { '$' };
    ret.extend(repeat(sigil).take(dollar_count));
    dollar_count = 0;
    ret.push(c);
  }
  // trailing anonymous multiple
  let sigil = if dollar_count == 3 { expando } else { '$' };
  ret.extend(repeat(sigil).take(dollar_count));
  std::borrow::Cow::Owned(ret.into_iter().collect())
}

/// this macro will implement expando_char and pre_process_pattern
/// use this if your language does not accept $ as valid identifier char
macro_rules! impl_lang_expando {
  ($lang: ident, $func: ident, $char: expr) => {
    #[derive(Clone, Copy, Debug)]
    pub struct $lang;
    impl Language for $lang {
      fn kind_to_id(&self, kind: &str) -> u16 {
        self
          .get_ts_language()
          .id_for_node_kind(kind, /*named*/ true)
      }
      fn field_to_id(&self, field: &str) -> Option<u16> {
        self
          .get_ts_language()
          .field_id_for_name(field)
          .map(|f| f.get())
      }
      fn expando_char(&self) -> char {
        $char
      }
      fn pre_process_pattern<'q>(&self, query: &'q str) -> std::borrow::Cow<'q, str> {
        pre_process_pattern(self.expando_char(), query)
      }
      fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
        builder.build(|src| StrDoc::try_new(src, self.clone()))
      }
    }
    impl LanguageExt for $lang {
      fn get_ts_language(&self) -> TSLanguage {
        $crate::parsers::$func().into()
      }
    }
  };
}

pub trait Alias: Display {
  const ALIAS: &'static [&'static str];
}

/// Implements the `ALIAS` associated constant for the given lang, which is
/// then used to define the `alias` const fn and a `Deserialize` impl.
macro_rules! impl_alias {
  ($lang:ident => $as:expr) => {
    impl Alias for $lang {
      const ALIAS: &'static [&'static str] = $as;
    }

    impl fmt::Display for $lang {
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
      }
    }

    impl<'de> Deserialize<'de> for $lang {
      fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
      where
        D: Deserializer<'de>,
      {
        let vis = AliasVisitor {
          aliases: Self::ALIAS,
        };
        deserializer.deserialize_str(vis)?;
        Ok($lang)
      }
    }

    impl From<$lang> for SupportLang {
      fn from(_: $lang) -> Self {
        Self::$lang
      }
    }
  };
}
/// Generates as convenience conversions between the lang types
/// and `SupportedType`.
macro_rules! impl_aliases {
  ($($lang:ident => $as:expr),* $(,)?) => {
    $(impl_alias!($lang => $as);)*
    const fn alias(lang: SupportLang) -> &'static [&'static str] {
      match lang {
        $(SupportLang::$lang => $lang::ALIAS),*
      }
    }
  };
}

/* Customized Language with expando_char / pre_process_pattern */
// https://en.cppreference.com/w/cpp/language/identifiers
impl_lang_expando!(C, language_c, '𐀀');
impl_lang_expando!(Cpp, language_cpp, '𐀀');
// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#643-identifiers
// all letter number is accepted
// https://www.compart.com/en/unicode/category/Nl
impl_lang_expando!(CSharp, language_c_sharp, 'µ');
// https://www.w3.org/TR/CSS21/grammar.html#scanner
impl_lang_expando!(Css, language_css, '_');
// https://github.com/elixir-lang/tree-sitter-elixir/blob/a2861e88a730287a60c11ea9299c033c7d076e30/grammar.js#L245
impl_lang_expando!(Elixir, language_elixir, 'µ');
// we can use any Unicode code point categorized as "Letter"
// https://go.dev/ref/spec#letter
impl_lang_expando!(Go, language_go, 'µ');
// GHC supports Unicode syntax per
// https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/unicode_syntax.html
// and the tree-sitter-haskell grammar parses it too.
impl_lang_expando!(Haskell, language_haskell, 'µ');
// https://developer.hashicorp.com/terraform/language/syntax/configuration#identifiers
impl_lang_expando!(Hcl, language_hcl, 'µ');
// https://github.com/fwcd/tree-sitter-kotlin/pull/93
impl_lang_expando!(Kotlin, language_kotlin, 'µ');
// Nix uses $ for string interpolation (e.g., "${pkgs.hello}")
impl_lang_expando!(Nix, language_nix, '_');
// PHP accepts unicode to be used as some name not var name though
impl_lang_expando!(Php, language_php, 'µ');
// we can use any char in unicode range [:XID_Start:]
// https://docs.python.org/3/reference/lexical_analysis.html#identifiers
// see also [PEP 3131](https://peps.python.org/pep-3131/) for further details.
impl_lang_expando!(Python, language_python, 'µ');
// https://github.com/tree-sitter/tree-sitter-ruby/blob/f257f3f57833d584050336921773738a3fd8ca22/grammar.js#L30C26-L30C78
impl_lang_expando!(Ruby, language_ruby, 'µ');
// we can use any char in unicode range [:XID_Start:]
// https://doc.rust-lang.org/reference/identifiers.html
impl_lang_expando!(Rust, language_rust, 'µ');
//https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/#Identifiers
impl_lang_expando!(Swift, language_swift, 'µ');

// Stub Language without preprocessing
// Language Name, tree-sitter-name, alias, extension
impl_lang!(Bash, language_bash);
impl_lang!(Java, language_java);
impl_lang!(JavaScript, language_javascript);
impl_lang!(Json, language_json);
impl_lang!(Lua, language_lua);
impl_lang!(Scala, language_scala);
impl_lang!(Solidity, language_solidity);
impl_lang!(Tsx, language_tsx);
impl_lang!(TypeScript, language_typescript);
impl_lang!(Yaml, language_yaml);
// See ripgrep for extensions
// https://github.com/BurntSushi/ripgrep/blob/master/crates/ignore/src/default_types.rs

/// Represents all built-in languages.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Hash)]
pub enum SupportLang {
  Bash,
  C,
  Cpp,
  CSharp,
  Css,
  Go,
  Elixir,
  Haskell,
  Hcl,
  Html,
  Java,
  JavaScript,
  Json,
  Kotlin,
  Lua,
  Nix,
  Php,
  Python,
  Ruby,
  Rust,
  Scala,
  Solidity,
  Swift,
  Tsx,
  TypeScript,
  Yaml,
}

impl SupportLang {
  pub const fn all_langs() -> &'static [SupportLang] {
    use SupportLang::*;
    &[
      Bash, C, Cpp, CSharp, Css, Elixir, Go, Haskell, Hcl, Html, Java, JavaScript, Json, Kotlin,
      Lua, Nix, Php, Python, Ruby, Rust, Scala, Solidity, Swift, Tsx, TypeScript, Yaml,
    ]
  }

  pub fn file_types(&self) -> Types {
    file_types(*self)
  }
}

impl fmt::Display for SupportLang {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{self:?}")
  }
}

#[derive(Debug)]
pub enum SupportLangErr {
  LanguageNotSupported(String),
}

impl Display for SupportLangErr {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    use SupportLangErr::*;
    match self {
      LanguageNotSupported(lang) => write!(f, "{lang} is not supported!"),
    }
  }
}

impl std::error::Error for SupportLangErr {}

impl<'de> Deserialize<'de> for SupportLang {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: Deserializer<'de>,
  {
    deserializer.deserialize_str(SupportLangVisitor)
  }
}

struct SupportLangVisitor;

impl Visitor<'_> for SupportLangVisitor {
  type Value = SupportLang;

  fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
    f.write_str("SupportLang")
  }

  fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  where
    E: de::Error,
  {
    v.parse().map_err(de::Error::custom)
  }
}
struct AliasVisitor {
  aliases: &'static [&'static str],
}

impl Visitor<'_> for AliasVisitor {
  type Value = &'static str;

  fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(f, "one of {:?}", self.aliases)
  }

  fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  where
    E: de::Error,
  {
    self
      .aliases
      .iter()
      .copied()
      .find(|&a| v.eq_ignore_ascii_case(a))
      .ok_or_else(|| de::Error::invalid_value(de::Unexpected::Str(v), &self))
  }
}

impl_aliases! {
  Bash => &["bash"],
  C => &["c"],
  Cpp => &["cc", "c++", "cpp", "cxx"],
  CSharp => &["cs", "csharp"],
  Css => &["css"],
  Elixir => &["ex", "elixir"],
  Go => &["go", "golang"],
  Haskell => &["hs", "haskell"],
  Hcl => &["hcl"],
  Html => &["html"],
  Java => &["java"],
  JavaScript => &["javascript", "js", "jsx"],
  Json => &["json"],
  Kotlin => &["kotlin", "kt"],
  Lua => &["lua"],
  Nix => &["nix"],
  Php => &["php"],
  Python => &["py", "python"],
  Ruby => &["rb", "ruby"],
  Rust => &["rs", "rust"],
  Scala => &["scala"],
  Solidity => &["sol", "solidity"],
  Swift => &["swift"],
  TypeScript => &["ts", "typescript"],
  Tsx => &["tsx"],
  Yaml => &["yaml", "yml"],
}

/// Implements the language names and aliases.
impl FromStr for SupportLang {
  type Err = SupportLangErr;
  fn from_str(s: &str) -> Result<Self, Self::Err> {
    for &lang in Self::all_langs() {
      for moniker in alias(lang) {
        if s.eq_ignore_ascii_case(moniker) {
          return Ok(lang);
        }
      }
    }
    Err(SupportLangErr::LanguageNotSupported(s.to_string()))
  }
}

macro_rules! execute_lang_method {
  ($me: path, $method: ident, $($pname:tt),*) => {
    use SupportLang as S;
    match $me {
      S::Bash => Bash.$method($($pname,)*),
      S::C => C.$method($($pname,)*),
      S::Cpp => Cpp.$method($($pname,)*),
      S::CSharp => CSharp.$method($($pname,)*),
      S::Css => Css.$method($($pname,)*),
      S::Elixir => Elixir.$method($($pname,)*),
      S::Go => Go.$method($($pname,)*),
      S::Haskell => Haskell.$method($($pname,)*),
      S::Hcl => Hcl.$method($($pname,)*),
      S::Html => Html.$method($($pname,)*),
      S::Java => Java.$method($($pname,)*),
      S::JavaScript => JavaScript.$method($($pname,)*),
      S::Json => Json.$method($($pname,)*),
      S::Kotlin => Kotlin.$method($($pname,)*),
      S::Lua => Lua.$method($($pname,)*),
      S::Nix => Nix.$method($($pname,)*),
      S::Php => Php.$method($($pname,)*),
      S::Python => Python.$method($($pname,)*),
      S::Ruby => Ruby.$method($($pname,)*),
      S::Rust => Rust.$method($($pname,)*),
      S::Scala => Scala.$method($($pname,)*),
      S::Solidity => Solidity.$method($($pname,)*),
      S::Swift => Swift.$method($($pname,)*),
      S::Tsx => Tsx.$method($($pname,)*),
      S::TypeScript => TypeScript.$method($($pname,)*),
      S::Yaml => Yaml.$method($($pname,)*),
    }
  }
}

macro_rules! impl_lang_method {
  ($method: ident, ($($pname:tt: $ptype:ty),*) => $return_type: ty) => {
    #[inline]
    fn $method(&self, $($pname: $ptype),*) -> $return_type {
      execute_lang_method!{ self, $method, $($pname),* }
    }
  };
}
impl Language for SupportLang {
  impl_lang_method!(kind_to_id, (kind: &str) => u16);
  impl_lang_method!(field_to_id, (field: &str) => Option<u16>);
  impl_lang_method!(meta_var_char, () => char);
  impl_lang_method!(expando_char, () => char);
  impl_lang_method!(extract_meta_var, (source: &str) => Option<MetaVariable>);
  impl_lang_method!(build_pattern, (builder: &PatternBuilder) => Result<Pattern, PatternError>);
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    execute_lang_method! { self, pre_process_pattern, query }
  }
  fn from_path<P: AsRef<Path>>(path: P) -> Option<Self> {
    from_extension(path.as_ref())
  }
}

impl LanguageExt for SupportLang {
  impl_lang_method!(get_ts_language, () => TSLanguage);
  impl_lang_method!(injectable_languages, () => Option<&'static [&'static str]>);
  fn extract_injections<L: LanguageExt>(
    &self,
    root: Node<StrDoc<L>>,
  ) -> HashMap<String, Vec<TSRange>> {
    match self {
      SupportLang::Html => Html.extract_injections(root),
      _ => HashMap::new(),
    }
  }
}

fn extensions(lang: SupportLang) -> &'static [&'static str] {
  use SupportLang::*;
  match lang {
    Bash => &[
      "bash", "bats", "cgi", "command", "env", "fcgi", "ksh", "sh", "tmux", "tool", "zsh",
    ],
    C => &["c", "h"],
    Cpp => &["cc", "hpp", "cpp", "c++", "hh", "cxx", "cu", "ino"],
    CSharp => &["cs"],
    Css => &["css", "scss"],
    Elixir => &["ex", "exs"],
    Go => &["go"],
    Haskell => &["hs"],
    Hcl => &["hcl"],
    Html => &["html", "htm", "xhtml"],
    Java => &["java"],
    JavaScript => &["cjs", "js", "mjs", "jsx"],
    Json => &["json"],
    Kotlin => &["kt", "ktm", "kts"],
    Lua => &["lua"],
    Nix => &["nix"],
    Php => &["php"],
    Python => &["py", "py3", "pyi", "bzl"],
    Ruby => &["rb", "rbw", "gemspec"],
    Rust => &["rs"],
    Scala => &["scala", "sc", "sbt"],
    Solidity => &["sol"],
    Swift => &["swift"],
    TypeScript => &["ts", "cts", "mts"],
    Tsx => &["tsx"],
    Yaml => &["yaml", "yml"],
  }
}

/// Guess which programming language a file is written in
/// Adapt from `<https://github.com/Wilfred/difftastic/blob/master/src/parse/guess_language.rs>`
/// N.B do not confuse it with `FromStr` trait. This function is to guess language from file extension.
fn from_extension(path: &Path) -> Option<SupportLang> {
  let ext = path.extension()?.to_str()?;
  SupportLang::all_langs()
    .iter()
    .copied()
    .find(|&l| extensions(l).contains(&ext))
}

fn add_custom_file_type<'b>(
  builder: &'b mut TypesBuilder,
  file_type: &str,
  suffix_list: &[&str],
) -> &'b mut TypesBuilder {
  for suffix in suffix_list {
    let glob = format!("*.{suffix}");
    builder
      .add(file_type, &glob)
      .expect("file pattern must compile");
  }
  builder.select(file_type)
}

fn file_types(lang: SupportLang) -> Types {
  let mut builder = TypesBuilder::new();
  let exts = extensions(lang);
  let lang_name = lang.to_string();
  add_custom_file_type(&mut builder, &lang_name, exts);
  builder.build().expect("file type must be valid")
}

pub fn config_file_type() -> Types {
  let mut builder = TypesBuilder::new();
  let builder = add_custom_file_type(&mut builder, "yml", &["yml", "yaml"]);
  builder.build().expect("yaml type must be valid")
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_core::{matcher::MatcherExt, Pattern};

  pub fn test_match_lang(query: &str, source: &str, lang: impl LanguageExt) {
    let cand = lang.ast_grep(source);
    let pattern = Pattern::new(query, lang);
    assert!(
      pattern.find_node(cand.root()).is_some(),
      "goal: {pattern:?}, candidate: {}",
      cand.root().get_inner_node().to_sexp(),
    );
  }

  pub fn test_non_match_lang(query: &str, source: &str, lang: impl LanguageExt) {
    let cand = lang.ast_grep(source);
    let pattern = Pattern::new(query, lang);
    assert!(
      pattern.find_node(cand.root()).is_none(),
      "goal: {pattern:?}, candidate: {}",
      cand.root().get_inner_node().to_sexp(),
    );
  }

  pub fn test_replace_lang(
    src: &str,
    pattern: &str,
    replacer: &str,
    lang: impl LanguageExt,
  ) -> String {
    let mut source = lang.ast_grep(src);
    assert!(source
      .replace(pattern, replacer)
      .expect("should parse successfully"));
    source.generate()
  }

  #[test]
  fn test_js_string() {
    test_match_lang("'a'", "'a'", JavaScript);
    test_match_lang("\"\"", "\"\"", JavaScript);
    test_match_lang("''", "''", JavaScript);
  }

  #[test]
  fn test_guess_by_extension() {
    let path = Path::new("foo.rs");
    assert_eq!(from_extension(path), Some(SupportLang::Rust));
  }

  // TODO: add test for file_types
}



================================================
FILE: crates/language/src/lua.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Lua);
}

#[test]
fn test_lua_pattern() {
  test_match("s = $S", "s = 'string'");
  test_match("print($S)", "print('Hello World')");
  test_match("a = io.$METHOD($S)", "a = io.read('*number')");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Lua)
}

#[test]
fn test_lua_replace() {
  let ret = test_replace(
    r#"function fact (n)
      if n == 0 then
        return 1
      else
        return n * fact(n-1)
      end
    end"#,
    "function $FUNC($ARG) $$$ end",
    "$FUNC = function ($ARG) return 1 end",
  );
  assert_eq!(ret, "fact = function (n) return 1 end");
}



================================================
FILE: crates/language/src/nix.rs
================================================
#![cfg(test)]
use super::*;
use crate::test::{test_match_lang, test_replace_lang};

fn test_match(s1: &str, s2: &str) {
  test_match_lang(s1, s2, Nix)
}

#[test]
fn test_nix_pattern() {
  test_match("$A + $B", "1 + 2");
  test_match("{ $A = $B; }", "{ foo = bar; }");
  test_match("with $A; $B", "with pkgs; hello");
  test_match("let $A = $B; in $C", "let x = 5; in x + 1");
}

#[test]
fn test_nix_function() {
  test_match("$A: $B", "x: x + 1");
  test_match("{ $A, $B }: $C", "{ foo, bar }: foo + bar");
  test_match("{ $A ? $B }: $C", "{ x ? 5 }: x * 2");
}

#[test]
fn test_nix_list() {
  test_match("[ $A $B ]", "[ 1 2 ]");
  test_match("[ $$$ITEMS ]", "[ 1 2 3 4 5 ]");
}

#[test]
fn test_nix_string() {
  test_match("\"$A\"", "\"hello\"");
  test_match("''$A''", "''multi\nline''");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  test_replace_lang(src, pattern, replacer, Nix)
}

#[test]
fn test_nix_replace() {
  let ret = test_replace("1 + 2", "$A + $B", "$B + $A");
  assert_eq!(ret, "2 + 1");

  let ret = test_replace("{ foo = bar; }", "{ $A = $B; }", "{ $B = $A; }");
  assert_eq!(ret, "{ bar = foo; }");

  let ret = test_replace(
    "let x = 5; in x + 1",
    "let $A = $B; in $C",
    "let $A = $B * 2; in $C",
  );
  assert_eq!(ret, "let x = 5 * 2; in x + 1");
}



================================================
FILE: crates/language/src/parsers.rs
================================================
//! This mod maintains a list of tree-sitter parsers crate.
//! When feature flag `builtin-parser` is on, this mod will import all dependent crates.
//! However, tree-sitter bs cannot be compiled by wasm-pack.
//! In this case, we can use a blank implementation by turning feature flag off.
//! And use other implementation.

#[cfg(feature = "builtin-parser")]
macro_rules! into_lang {
  ($lang: ident, $field: ident) => {
    $lang::$field.into()
  };
  ($lang: ident) => {
    into_lang!($lang, LANGUAGE)
  };
}

#[cfg(not(feature = "builtin-parser"))]
macro_rules! into_lang {
  ($lang: ident, $field: ident) => {
    unimplemented!(
      "tree-sitter parser is not implemented when feature flag [builtin-parser] is off."
    )
  };
  ($lang: ident) => {
    into_lang!($lang, LANGUAGE)
  };
}

#[cfg(any(feature = "builtin-parser", feature = "napi-lang"))]
macro_rules! into_napi_lang {
  ($lang: path) => {
    $lang.into()
  };
}
#[cfg(not(any(feature = "builtin-parser", feature = "napi-lang")))]
macro_rules! into_napi_lang {
  ($lang: path) => {
    unimplemented!(
      "tree-sitter parser is not implemented when feature flag [builtin-parser] is off."
    )
  };
}

use ast_grep_core::tree_sitter::TSLanguage;

pub fn language_bash() -> TSLanguage {
  into_lang!(tree_sitter_bash)
}
pub fn language_c() -> TSLanguage {
  into_lang!(tree_sitter_c)
}
pub fn language_cpp() -> TSLanguage {
  into_lang!(tree_sitter_cpp)
}
pub fn language_c_sharp() -> TSLanguage {
  into_lang!(tree_sitter_c_sharp)
}
pub fn language_css() -> TSLanguage {
  into_napi_lang!(tree_sitter_css::LANGUAGE)
}
pub fn language_elixir() -> TSLanguage {
  into_lang!(tree_sitter_elixir)
}
pub fn language_go() -> TSLanguage {
  into_lang!(tree_sitter_go)
}
pub fn language_haskell() -> TSLanguage {
  into_lang!(tree_sitter_haskell)
}
pub fn language_hcl() -> TSLanguage {
  into_lang!(tree_sitter_hcl)
}
pub fn language_html() -> TSLanguage {
  into_napi_lang!(tree_sitter_html::LANGUAGE)
}
pub fn language_java() -> TSLanguage {
  into_lang!(tree_sitter_java)
}
pub fn language_javascript() -> TSLanguage {
  into_napi_lang!(tree_sitter_javascript::LANGUAGE)
}
pub fn language_json() -> TSLanguage {
  into_lang!(tree_sitter_json)
}
pub fn language_kotlin() -> TSLanguage {
  into_lang!(tree_sitter_kotlin)
}
pub fn language_lua() -> TSLanguage {
  into_lang!(tree_sitter_lua)
}
pub fn language_nix() -> TSLanguage {
  into_lang!(tree_sitter_nix)
}
pub fn language_php() -> TSLanguage {
  into_lang!(tree_sitter_php, LANGUAGE_PHP_ONLY)
}
pub fn language_python() -> TSLanguage {
  into_lang!(tree_sitter_python)
}
pub fn language_ruby() -> TSLanguage {
  into_lang!(tree_sitter_ruby)
}
pub fn language_rust() -> TSLanguage {
  into_lang!(tree_sitter_rust)
}
pub fn language_scala() -> TSLanguage {
  into_lang!(tree_sitter_scala)
}
pub fn language_solidity() -> TSLanguage {
  into_lang!(tree_sitter_solidity)
}
pub fn language_swift() -> TSLanguage {
  into_lang!(tree_sitter_swift)
}
pub fn language_tsx() -> TSLanguage {
  into_napi_lang!(tree_sitter_typescript::LANGUAGE_TSX)
}
pub fn language_typescript() -> TSLanguage {
  into_napi_lang!(tree_sitter_typescript::LANGUAGE_TYPESCRIPT)
}
pub fn language_yaml() -> TSLanguage {
  into_lang!(tree_sitter_yaml)
}



================================================
FILE: crates/language/src/php.rs
================================================
#![cfg(test)]

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Php);
}

#[test]
fn test_php_pattern() {
  // dummy example, php pattern actually does not work
  test_match("123", "123");
}

// https://github.com/ast-grep/ast-grep/issues/639#issuecomment-1876622828
// TODO: better php support



================================================
FILE: crates/language/src/python.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Python);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Python);
}

#[test]
fn test_python_str() {
  test_match("print($A)", "print(123)");
  test_match("print('123')", "print('123')");
  test_non_match("print('123')", "print('456')");
  test_non_match("'123'", "'456'");
  // https://github.com/ast-grep/ast-grep/issues/276
  // python has fixed the wrong parsing issue
  test_non_match(
    "getattr($O, \"__spec__\", None)",
    "getattr(response, \"render\", None)",
  );
  test_match(
    "getattr($O, \"render\", None)",
    "getattr(response, \"render\", None)",
  );
}

// https://github.com/ast-grep/ast-grep/issues/883
#[test]
fn test_issue_883() {
  test_match("r'^[A-Za-z0-9_-]+\\$'", "r'^[A-Za-z0-9_-]+\\$'");
}

#[test]
fn test_python_pattern() {
  test_match("$A = 0", "a = 0");
  // A test case from https://peps.python.org/pep-0636/#appendix-a-quick-intro
  test_match(
    r#"
match $A:
  case $B:
      $C
  case [$D(0, 0)]:
      $E
  case [$D($F, $G)]:
      $H
  case [$D(0, $I), $D(0, $J)]:
      $K
  case _:
      $L
"#,
    r#"
match points:
  case []:
      print("No points")
  case [Point(0, 0)]:
      print("The origin")
  case [Point(x, y)]:
      print(f"Single point {x}, {y}")
  case [Point(0, y1), Point(0, y2)]:
      print(f"Two on the Y axis at {y1}, {y2}")
  case _:
      print("Something else")
"#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Python)
}

#[test]
fn test_python_replace() {
  let ret = test_replace(
    r#"
if flag:
  a = value_pos
else:
  a = value_neg"#,
    r#"
if $FLAG:
  $VAR = $POS
else:
  $VAR = $NEG
"#,
    "$VAR = $POS if $FLAG else $NEG",
  );
  assert_eq!(ret, "\na = value_pos if flag else value_neg");

  let ret = test_replace(
    r#"
try:
  f = open(file_path, "r")
  file_content = f.read()
except:
  pass
finally:
  f.close()"#,
    r#"
try:
  $A = open($B, $C)
  $D = $A.read()
except:
  pass
finally:
  $A.close()"#,
    r#"
with open($B, $C) as $A:
  $D = $A.open()"#,
  );
  assert_eq!(
    ret,
    r#"

with open(file_path, "r") as f:
  file_content = f.open()"#
  );
}



================================================
FILE: crates/language/src/ruby.rs
================================================
#![cfg(test)]

use super::*;
use ast_grep_core::Pattern;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Ruby);
}

#[test]
fn test_ruby_pattern() {
  test_match("Foo::bar", "Foo::bar");
}

// https://github.com/ast-grep/ast-grep/issues/713
#[test]
fn test_ruby_tree_sitter_panic() {
  let pattern = Pattern::new("Foo::barbaz", Ruby);
  assert_eq!(pattern.fixed_string(), "barbaz");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Ruby)
}

#[test]
fn test_ruby_replace() {
  let ret = test_replace("Foo::bar()", "Foo::$METHOD()", "$METHOD()");
  assert_eq!(ret, "bar()");
}



================================================
FILE: crates/language/src/rust.rs
================================================
#![cfg(test)]
use super::*;
use crate::test::{test_match_lang, test_replace_lang};

fn test_match(s1: &str, s2: &str) {
  test_match_lang(s1, s2, Rust)
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Rust);
}

#[test]
fn test_rust_pattern() {
  // fix #6
  test_match("Some($A)", "fn test() { Some(123) }");
  test_match(
    "
match $A {
  Some($B) => $B,
  None => $C,
}",
    r#"fn test() {
patterns = match config.include.clone() {
  Some(patterns) => patterns,
  None => Vec::from([cwd
      .join("**/*.toml")
      .normalize()
      .to_string_lossy()
      .into_owned()]),
};
}"#,
  );
}

// it is fixed in https://github.com/tree-sitter/tree-sitter-rust/issues/218
// but not released yet
#[test]
fn test_issue_1057() {
  // fix #1057
  test_match("foo(\"meaning\");", "fn t() { foo(\"meaning\");}");
  test_non_match("foo(\"meaning\");", "fn t() { foo(\"service\");}");
}

#[test]
fn test_rust_wildcard_pattern() {
  // fix #412
  test_match("|$A, $B|", "let w = v.into_iter().reduce(|x, y| x + y);");
  test_match("|$$A, $$B|", "let w = v.into_iter().reduce(|x, _| x + x);");
  test_match("let ($$X, $$Y) = $$$T;", "let (_, y) = (1, 2);");
}

#[test]
fn test_rust_spread_syntax() {
  test_match(
    "let ($X, $Y) = $$$T;",
    "let (.., y) = (1,2,3,4,5,6,7,8,9,10);",
  );
  test_match(
    "$C { $$$A, ..$B};",
    r#"User {
    username: String::from(name),
    ..DEFAULT_USER
  };"#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  test_replace_lang(src, pattern, replacer, Rust)
}

#[test]
fn test_rust_replace() {
  let ret = test_replace("fn test() { Some(123) }", "Some($A)", "Ok($A)");
  assert_eq!(ret, "fn test() { Ok(123) }");
  let ret = test_replace(
    r#"
patterns = match config.include.clone() {
  Some(patterns) => patterns,
  None => 123,
}"#,
    "match $A {
  Some($B) => $B,
  None => $C,
}",
    "$A.unwrap_or($C)",
  );
  assert_eq!(ret, "\npatterns = config.include.clone().unwrap_or(123)");
}



================================================
FILE: crates/language/src/scala.rs
================================================
#![cfg(test)]
//! Standalone Scala file to test syntax.
//! Scala does not need special processing and can be a stub lang.
//! But this file is created for testing Scala2 and Scala3.

use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Scala);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Scala);
}

#[test]
fn test_scala_str() {
  test_match("println($A)", "println(123)");
  test_match("println(\"123\")", "println(\"123\")");
  test_non_match("println(\"123\")", "println(\"456\")");
  test_non_match("\"123\"", "\"456\"");
}

#[test]
fn test_scala_pattern() {
  test_match("val $A = 0", "val a = 0");
  test_match("foo($VAR)", "foo(bar)");
  test_match("type $A = String", "type Foo = String");
  test_match("$A.filter(_ == $B)", "foo.filter(_ == bar)");
  test_match("if ($A) $B else $C", "if (foo) bar else baz");
  // Scala 3 syntax
  test_match("if $A then $B else $C", "if foo then bar else baz");
  test_non_match("if ($A) $B else $C", "if foo then bar else baz");
  test_non_match("type $A = Int", "type Foo = String");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Scala)
}

#[test]
fn test_scala_replace() {
  let ret = test_replace(
    "foo.filter(_ == bar)",
    "$A.filter(_ == $B)",
    "$A.filter(_ == baz)",
  );
  assert_eq!(ret, "foo.filter(_ == baz)");
}



================================================
FILE: crates/language/src/solidity.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Solidity);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Solidity);
}

#[test]
fn test_solidity_str() {
  test_match("pragma solidity 0.8.28;", "pragma solidity 0.8.28;");
  test_match(
    r#"import { Test } from "forge-std/Test.sol";"#,
    r#"import { Test } from "forge-std/Test.sol";"#,
  );
  test_non_match("pragma solidity 0.8.28;", "pragma solidity 0.8.26;");
  test_non_match(
    r#"import { Test } from "forge-std/Test.sol";"#,
    r#"import { console } from "forge-std/Test.sol";"#,
  );
}

#[test]
fn test_solidity_pattern() {
  test_match(
    r#"import { $A } from "forge-std/Test.sol";"#,
    r#"import { Test } from "forge-std/Test.sol";"#,
  );
  test_match(
    r#"import { $$$ } from "forge-std/Test.sol";"#,
    r#"import { Test, console } from "forge-std/Test.sol";"#,
  );
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Solidity)
}

#[test]
fn test_solidity_replace() {
  let ret = test_replace(
    r#"import { Test } from "forge-std/Test.sol";"#,
    "Test",
    "console",
  );
  assert_eq!(ret, r#"import { console } from "forge-std/Test.sol";"#);
}



================================================
FILE: crates/language/src/swift.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Swift);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Swift);
}

#[test]
fn test_swift_str() {
  test_match("println(\"123\")", "println(\"123\")");
  test_non_match("println(\"123\")", "println(\"456\")");
  test_non_match("\"123\"", "\"456\"");
}

#[test]
fn test_swift_pattern() {
  test_match("fun($A)", "fun(123)");
  test_match("foo($$$)", "foo(1, 2, 3)");
  test_match(
    "foo() { $E in $F }",
    "foo() { s in
      s.a = 123
    }",
  );
  test_non_match("foo($$$) { $E in $F }", "foo(1, 2, 3)");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Swift)
}

const SOURCE: &str = r#"
foo(a: A, b: B, c: C) { s in
  s.a = a
  s.b = b
}"#;
const EXPECTED: &str = r#"
foo(b: B, a: A, c: C) { s in
  s.a = a
  s.b = b
}"#;

#[test]
fn test_swift_replace() {
  let ret = test_replace(
    SOURCE,
    "foo(a: $A, b: $B, c: $C) { $E in $$$F }",
    "foo(b: $B, a: $A, c: $C) { $E in
  $$$F}",
  );
  assert_eq!(ret, EXPECTED);
}



================================================
FILE: crates/language/src/yaml.rs
================================================
#![cfg(test)]
use super::*;

fn test_match(query: &str, source: &str) {
  use crate::test::test_match_lang;
  test_match_lang(query, source, Yaml);
}

fn test_non_match(query: &str, source: &str) {
  use crate::test::test_non_match_lang;
  test_non_match_lang(query, source, Yaml);
}

#[test]
fn test_yaml_str() {
  test_match("123", "123");
  test_non_match("123", "'123'");
  // the pattern below should not match but match now
  // test_non_match("\"123\"", "\"456\"");
}

#[test]
fn test_yaml_pattern() {
  test_match("foo: $BAR", "foo: 123");
  test_match("foo: $$$", "foo: [1, 2, 3]");
  test_match(
    "foo: $BAR",
    "foo:
      - a
    ",
  );
  test_non_match("foo: $BAR", "bar: bar");
}

fn test_replace(src: &str, pattern: &str, replacer: &str) -> String {
  use crate::test::test_replace_lang;
  test_replace_lang(src, pattern, replacer, Yaml)
}

const SOURCE: &str = r#"
key: value
list:
  - item1
  - item2
"#;
const EXPECTED: &str = r#"
value: key
list:
  - item1
  - item2
"#;

#[test]
fn test_yaml_replace() {
  let ret = test_replace(SOURCE, "$KEY: value", "value: $KEY");
  assert_eq!(ret, EXPECTED);
}



================================================
FILE: crates/lsp/Cargo.toml
================================================
[package]
name = "ast-grep-lsp"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = [
  "ast",
  "pattern",
  "codemod",
  "search",
  "rewrite",
]

version.workspace = true
authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true

[dependencies]
ast-grep-core.workspace = true
ast-grep-config.workspace = true
serde.workspace = true
dashmap.workspace = true

serde_json = "1.0.116"
tower-lsp-server = "0.21.1"
anyhow.workspace = true

[dev-dependencies]
ast-grep-language.workspace = true
futures = "0.3.31"
tokio = { version = "1.45.0", features = [
  "rt-multi-thread",
  "io-std",
  "io-util",
  "macros",
  "time",
] }
tokio-stream = "0.1.17"
tokio-util = "0.7.16"



================================================
FILE: crates/lsp/src/lib.rs
================================================
mod utils;

use ast_grep_core::NodeMatch;
use dashmap::DashMap;
use serde_json::Value;
use tower_lsp_server::jsonrpc::Result;
use tower_lsp_server::lsp_types::notification::{DidChangeWatchedFiles, Notification};
use tower_lsp_server::lsp_types::*;
use tower_lsp_server::UriExt;
use tower_lsp_server::{Client, LanguageServer};

use ast_grep_config::{CombinedScan, RuleCollection, Severity};
use ast_grep_core::{
  tree_sitter::{LanguageExt, StrDoc},
  AstGrep, Doc,
};

use std::collections::{BTreeMap, HashMap};
use std::path::PathBuf;
use std::sync::{Arc, RwLock};

use utils::{convert_match_to_diagnostic, diagnostic_to_code_action, Fixes, RewriteData};

pub use tower_lsp_server::{LspService, Server};

pub trait LSPLang: LanguageExt + Eq + Send + Sync + 'static {}
impl<T> LSPLang for T where T: LanguageExt + Eq + Send + Sync + 'static {}

type Notes = BTreeMap<(u32, u32, u32, u32), Arc<String>>;

struct VersionedAst<D: Doc> {
  version: i32,
  root: AstGrep<D>,
  notes: Notes,
  fixes: Fixes,
}

pub struct Backend<L: LSPLang> {
  client: Client,
  map: DashMap<String, VersionedAst<StrDoc<L>>>,
  base: PathBuf,
  rules: Arc<RwLock<RuleCollection<L>>>,
  // interner for rule ids to note, to avoid duplication
  interner: DashMap<String, Arc<String>>,
  // rule finding closure to reload rules
  rule_finder: Box<dyn Fn() -> anyhow::Result<RuleCollection<L>> + Send + Sync>,
  // store client capabilities to check support
  capabilities: Arc<RwLock<ClientCapabilities>>,
}

const FALLBACK_CODE_ACTION_PROVIDER: Option<CodeActionProviderCapability> =
  Some(CodeActionProviderCapability::Simple(true));

const APPLY_ALL_FIXES: &str = "ast-grep.applyAllFixes";
const QUICKFIX_AST_GREP: &str = "quickfix.ast-grep";
const FIX_ALL_AST_GREP: &str = "source.fixAll.ast-grep";

fn code_action_provider(
  client_capability: &ClientCapabilities,
) -> Option<CodeActionProviderCapability> {
  let is_literal_supported = client_capability
    .text_document
    .as_ref()?
    .code_action
    .as_ref()?
    .code_action_literal_support
    .is_some();
  if !is_literal_supported {
    return None;
  }
  Some(CodeActionProviderCapability::Options(CodeActionOptions {
    code_action_kinds: Some(vec![
      CodeActionKind::new(QUICKFIX_AST_GREP),
      CodeActionKind::new(FIX_ALL_AST_GREP),
    ]),
    work_done_progress_options: Default::default(),
    resolve_provider: Some(true),
  }))
}

impl<L: LSPLang> LanguageServer for Backend<L> {
  async fn initialize(&self, params: InitializeParams) -> Result<InitializeResult> {
    let code_action_provider = code_action_provider(&params.capabilities);
    if let Ok(mut cap) = self.capabilities.write() {
      *cap = params.capabilities;
    }
    Ok(InitializeResult {
      server_info: Some(ServerInfo {
        name: "ast-grep language server".to_string(),
        version: None,
      }),
      capabilities: ServerCapabilities {
        // TODO: change this to incremental
        text_document_sync: Some(TextDocumentSyncCapability::Kind(TextDocumentSyncKind::FULL)),
        code_action_provider: code_action_provider.or(FALLBACK_CODE_ACTION_PROVIDER),
        execute_command_provider: Some(ExecuteCommandOptions {
          commands: vec![APPLY_ALL_FIXES.to_string()],
          work_done_progress_options: Default::default(),
        }),
        hover_provider: Some(HoverProviderCapability::Simple(true)),
        ..ServerCapabilities::default()
      },
    })
  }

  async fn initialized(&self, _: InitializedParams) {
    self
      .client
      .log_message(MessageType::INFO, "server initialized!")
      .await;
    if let Err(e) = self.reload_rules().await {
      self
        .client
        .show_message(MessageType::ERROR, format!("Failed to load rules: {e}"))
        .await;
    }

    // Register file watchers for configuration files
    if let Err(e) = self.register_file_watchers().await {
      self
        .client
        .log_message(
          MessageType::ERROR,
          format!("Failed to register file watchers: {e:?}"),
        )
        .await;
    }
  }

  async fn shutdown(&self) -> Result<()> {
    Ok(())
  }

  async fn did_change_workspace_folders(&self, _: DidChangeWorkspaceFoldersParams) {
    self
      .client
      .log_message(MessageType::INFO, "workspace folders changed!")
      .await;
  }

  async fn did_change_configuration(&self, _: DidChangeConfigurationParams) {
    self
      .client
      .log_message(MessageType::INFO, "configuration changed!")
      .await;
  }

  async fn did_change_watched_files(&self, _params: DidChangeWatchedFilesParams) {
    // File watcher already ensures only yml files are watched, so just reload
    self
      .client
      .log_message(
        MessageType::INFO,
        "Configuration files changed, reloading rules...",
      )
      .await;

    if let Err(e) = self.reload_rules().await {
      self
        .client
        .show_message(MessageType::ERROR, format!("Failed to reload rules: {e}"))
        .await;
    } else {
      self
        .client
        .log_message(MessageType::INFO, "Rules reloaded successfully")
        .await;
    }
  }
  async fn did_open(&self, params: DidOpenTextDocumentParams) {
    self
      .client
      .log_message(MessageType::INFO, "file opened!")
      .await;
    self.on_open(params).await;
  }

  async fn did_change(&self, params: DidChangeTextDocumentParams) {
    self.on_change(params).await;
  }

  async fn did_save(&self, _: DidSaveTextDocumentParams) {
    self
      .client
      .log_message(MessageType::INFO, "file saved!")
      .await;
  }

  async fn did_close(&self, params: DidCloseTextDocumentParams) {
    self.on_close(params).await;
    self
      .client
      .log_message(MessageType::INFO, "file closed!")
      .await;
  }

  async fn code_action(&self, params: CodeActionParams) -> Result<Option<CodeActionResponse>> {
    Ok(self.on_code_action(params).await)
  }

  async fn execute_command(&self, params: ExecuteCommandParams) -> Result<Option<Value>> {
    Ok(self.on_execute_command(params).await)
  }

  async fn hover(&self, params: HoverParams) -> Result<Option<Hover>> {
    self
      .client
      .log_message(MessageType::LOG, "Get Hover Notes")
      .await;
    Ok(self.do_hover(params.text_document_position_params))
  }
}

fn pos_tuple_to_range((line, character, end_line, end_character): (u32, u32, u32, u32)) -> Range {
  Range {
    start: Position { line, character },
    end: Position {
      line: end_line,
      character: end_character,
    },
  }
}

impl<L: LSPLang> Backend<L> {
  pub fn new<F>(client: Client, base: PathBuf, rule_finder: F) -> Self
  where
    F: Fn() -> anyhow::Result<RuleCollection<L>> + Send + Sync + 'static,
  {
    Self {
      client,
      rules: Arc::new(RwLock::new(RuleCollection::default())),
      base,
      map: DashMap::new(),
      interner: DashMap::new(),
      rule_finder: Box::new(rule_finder),
      capabilities: Arc::new(RwLock::new(ClientCapabilities::default())),
    }
  }

  /// Convert URI to a path relative to base directory
  fn uri_to_relative_path(&self, uri: &Uri) -> Option<PathBuf> {
    let absolute_path = uri.to_file_path()?;
    if let Ok(relative_path) = absolute_path.strip_prefix(&self.base) {
      Some(relative_path.to_path_buf())
    } else {
      Some(absolute_path.to_path_buf())
    }
  }

  fn do_hover(&self, pos_params: TextDocumentPositionParams) -> Option<Hover> {
    let uri = pos_params.text_document.uri;
    let Position {
      line,
      character: column,
    } = pos_params.position;
    let ast = self.map.get(uri.as_str())?;
    let query = (line, column, line, column);
    // TODO: next_back is not precise, it can return a note that is larger
    let (pos, markdown) = ast.notes.range(..=query).next_back()?;
    // out of range check
    if pos.0 > line || pos.2 < line {
      return None;
    }
    if pos.0 == line && pos.1 > column || pos.2 == line && pos.3 < column {
      return None;
    }
    Some(Hover {
      contents: HoverContents::Markup(MarkupContent {
        kind: MarkupKind::Markdown,
        value: markdown.to_string(),
      }),
      range: Some(pos_tuple_to_range(*pos)),
    })
  }

  fn get_diagnostics(
    &self,
    uri: &Uri,
    versioned: &VersionedAst<StrDoc<L>>,
  ) -> Option<(Vec<Diagnostic>, Fixes)> {
    let path = self.uri_to_relative_path(uri)?;

    let rules = self.rules.read().ok()?;
    let rule_refs = rules.for_path(&path);
    if rule_refs.is_empty() {
      return None;
    }
    let unused_suppression_rule =
      CombinedScan::unused_config(Severity::Hint, rule_refs[0].language.clone());
    let mut scan = CombinedScan::new(rule_refs);
    scan.set_unused_suppression_rule(&unused_suppression_rule);
    let matches = scan.scan(&versioned.root, false).matches;
    let mut diagnostics = vec![];
    let mut fixes = Fixes::new();
    for (rule, ms) in matches {
      let to_diagnostic = |m: NodeMatch<StrDoc<L>>| {
        let diagnostic = convert_match_to_diagnostic(uri, &m, rule);
        let rewrite_data = RewriteData::from_node_match(&m, rule);
        if let Some(r) = rewrite_data {
          fixes.insert((diagnostic.range, rule.id.clone()), r);
        }
        diagnostic
      };
      diagnostics.extend(ms.into_iter().map(to_diagnostic));
    }
    Some((diagnostics, fixes))
  }

  fn build_notes(&self, diagnostics: &[Diagnostic]) -> Notes {
    let mut notes = BTreeMap::new();
    for diagnostic in diagnostics {
      let Some(NumberOrString::String(id)) = &diagnostic.code else {
        continue;
      };
      let Ok(rules) = self.rules.read() else {
        continue;
      };
      let Some(note) = rules.get_rule(id).and_then(|r| r.note.clone()) else {
        continue;
      };
      let start = diagnostic.range.start;
      let end = diagnostic.range.end;
      let atom = self
        .interner
        .entry(id.clone())
        .or_insert_with(|| Arc::new(note.clone()))
        .clone();
      notes.insert((start.line, start.character, end.line, end.character), atom);
    }
    notes
  }

  async fn publish_diagnostics(
    &self,
    uri: Uri,
    versioned: &mut VersionedAst<StrDoc<L>>,
  ) -> Option<()> {
    let (diagnostics, fixes) = self.get_diagnostics(&uri, versioned).unwrap_or_default();
    versioned.notes = self.build_notes(&diagnostics);
    versioned.fixes = fixes;

    self
      .client
      .publish_diagnostics(uri, diagnostics, Some(versioned.version))
      .await;
    Some(())
  }

  async fn get_path_of_first_workspace(&self) -> Option<std::path::PathBuf> {
    // need drop the lock before await
    let client_support_workspace = {
      let cap = self.capabilities.read().ok()?;
      cap
        .workspace
        .as_ref()
        .and_then(|w| w.workspace_folders)
        .unwrap_or(false)
    };
    if !client_support_workspace {
      return None;
    }
    let folders = self.client.workspace_folders().await.ok()??;
    let folder = folders.first()?;
    folder.uri.to_file_path().map(PathBuf::from)
  }

  // skip files outside of workspace root #1382, #1402
  async fn should_skip_file_outside_workspace(&self, text_doc: &TextDocumentItem) -> Option<()> {
    // fallback to base if no workspace provided by client #2211
    let workspace_root = self
      .get_path_of_first_workspace()
      .await
      .unwrap_or_else(|| self.base.clone());
    let doc_file_path = text_doc.uri.to_file_path()?;
    if doc_file_path.starts_with(workspace_root) {
      None
    } else {
      Some(())
    }
  }

  async fn on_open(&self, params: DidOpenTextDocumentParams) -> Option<()> {
    let text_doc = params.text_document;
    if self
      .should_skip_file_outside_workspace(&text_doc)
      .await
      .is_some()
    {
      return None;
    }
    let uri = text_doc.uri.as_str().to_owned();
    let text = text_doc.text;
    self
      .client
      .log_message(MessageType::LOG, "Parsing doc.")
      .await;
    let lang = Self::infer_lang_from_uri(&text_doc.uri)?;
    let root = AstGrep::new(text, lang);
    let mut versioned = VersionedAst {
      version: text_doc.version,
      root,
      notes: BTreeMap::new(),
      fixes: Fixes::new(),
    };
    self
      .client
      .log_message(MessageType::LOG, "Publishing init diagnostics.")
      .await;
    self.publish_diagnostics(text_doc.uri, &mut versioned).await;
    self.map.insert(uri.to_owned(), versioned); // don't lock dashmap
    Some(())
  }

  async fn on_change(&self, params: DidChangeTextDocumentParams) -> Option<()> {
    let text_doc = params.text_document;
    let uri = text_doc.uri.as_str();
    let change = &params.content_changes.first()?;
    let text = &change.text;
    self
      .client
      .log_message(MessageType::LOG, "Parsing changed doc.")
      .await;
    let lang = Self::infer_lang_from_uri(&text_doc.uri)?;
    let root = AstGrep::new(text, lang);
    let mut versioned = self.map.get_mut(uri)?;
    // skip old version update
    if versioned.version > text_doc.version {
      return None;
    }
    *versioned = VersionedAst {
      version: text_doc.version,
      root,
      notes: BTreeMap::new(),
      fixes: Fixes::new(),
    };
    self
      .client
      .log_message(MessageType::LOG, "Publishing diagnostics.")
      .await;
    self
      .publish_diagnostics(text_doc.uri, &mut *versioned)
      .await;
    Some(())
  }
  async fn on_close(&self, params: DidCloseTextDocumentParams) {
    self.map.remove(params.text_document.uri.as_str());
  }

  fn compute_all_fixes(
    &self,
    text_document: TextDocumentIdentifier,
  ) -> std::result::Result<HashMap<Uri, Vec<TextEdit>>, LspError>
  where
    L: ast_grep_core::Language + std::cmp::Eq,
  {
    let uri = text_document.uri;
    let versioned = self
      .map
      .get(uri.as_str())
      .ok_or(LspError::UnsupportedFileType)?;
    let (_diagnostics, fixes) = self
      .get_diagnostics(&uri, &versioned)
      .ok_or(LspError::NoActionableFix)?;

    let mut entries: Vec<_> = fixes.iter().collect();
    entries.sort_by(|((range_a, _), _), ((range_b, _), _)| {
      range_a
        .start
        .cmp(&range_b.start)
        .then(range_a.end.cmp(&range_b.end))
    });

    let mut last = Position {
      line: 0,
      character: 0,
    };
    let edits: Vec<TextEdit> = entries
      .into_iter()
      .filter_map(|((range, _id), rewrite_data)| {
        if range.start < last {
          return None;
        }
        let fixed = rewrite_data.fixers.first()?.fixed.to_string();
        let edit = TextEdit::new(*range, fixed);
        last = range.end;
        Some(edit)
      })
      .collect();
    if edits.is_empty() {
      return Err(LspError::NoActionableFix);
    }
    let mut changes = HashMap::new();
    changes.insert(uri, edits);
    Ok(changes)
  }

  async fn on_code_action(&self, params: CodeActionParams) -> Option<CodeActionResponse> {
    if let Some(kinds) = params.context.only.as_ref() {
      if kinds.contains(&CodeActionKind::SOURCE_FIX_ALL) {
        return self.fix_all_code_action(params.text_document);
      }
    }
    self.quickfix_code_action(params)
  }

  fn fix_all_code_action(
    &self,
    text_document: TextDocumentIdentifier,
  ) -> Option<CodeActionResponse> {
    let fixed = self.compute_all_fixes(text_document).ok()?;
    let edit = WorkspaceEdit::new(fixed);
    let code_action = CodeAction {
      title: "Fix by ast-grep".into(),
      command: None,
      diagnostics: None,
      edit: Some(edit),
      kind: Some(CodeActionKind::new(FIX_ALL_AST_GREP)),
      is_preferred: None,
      data: None,
      disabled: None,
    };
    Some(vec![CodeActionOrCommand::CodeAction(code_action)])
  }

  fn quickfix_code_action(&self, params: CodeActionParams) -> Option<CodeActionResponse> {
    if params.context.diagnostics.is_empty() {
      return None;
    }
    let text_doc = params.text_document;

    let document = self.map.get(text_doc.uri.as_str())?;
    let fixes_cache = &document.fixes;

    let response = params
      .context
      .diagnostics
      .into_iter()
      .filter(|d| {
        d.source
          .as_ref()
          .map(|s| s.contains("ast-grep"))
          .unwrap_or(false)
      })
      .filter_map(|d| diagnostic_to_code_action(&text_doc, d, fixes_cache))
      .flatten()
      .map(CodeActionOrCommand::from)
      .collect();
    Some(response)
  }

  // TODO: support other urls besides file_scheme
  fn infer_lang_from_uri(uri: &Uri) -> Option<L> {
    let path = uri.to_file_path()?;
    L::from_path(path)
  }

  async fn on_execute_command(&self, params: ExecuteCommandParams) -> Option<Value> {
    let ExecuteCommandParams {
      arguments,
      command,
      work_done_progress_params: _,
    } = params;

    match command.as_ref() {
      APPLY_ALL_FIXES => {
        self.on_apply_all_fix(command, arguments).await?;
        None
      }
      _ => {
        self
          .client
          .log_message(MessageType::LOG, format!("Unrecognized command: {command}"))
          .await;
        None
      }
    }
  }

  async fn on_apply_all_fix_impl(
    &self,
    first: Value,
  ) -> std::result::Result<WorkspaceEdit, LspError> {
    let text_doc: TextDocumentItem =
      serde_json::from_value(first).map_err(LspError::JSONDecodeError)?;
    let uri = text_doc.uri;
    // let version = text_doc.version;
    let changes = self.compute_all_fixes(TextDocumentIdentifier::new(uri))?;
    let workspace_edit = WorkspaceEdit {
      changes: Some(changes),
      document_changes: None,
      change_annotations: None,
    };
    Ok(workspace_edit)
  }

  async fn on_apply_all_fix(&self, command: String, arguments: Vec<Value>) -> Option<()> {
    self
      .client
      .log_message(
        MessageType::INFO,
        format!("Running ExecuteCommand {command}"),
      )
      .await;
    let first = arguments.first()?.clone();
    let workspace_edit = match self.on_apply_all_fix_impl(first).await {
      Ok(workspace_edit) => workspace_edit,
      Err(error) => {
        self.report_error(error).await;
        return None;
      }
    };
    self.client.apply_edit(workspace_edit).await.ok()?;
    None
  }

  async fn report_error(&self, error: LspError) {
    match error {
      LspError::JSONDecodeError(e) => {
        self
          .client
          .log_message(
            MessageType::ERROR,
            format!("JSON deserialization error: {e}"),
          )
          .await;
      }
      LspError::UnsupportedFileType => {
        self
          .client
          .log_message(MessageType::ERROR, "Unsupported file type")
          .await;
      }
      LspError::NoActionableFix => {
        self
          .client
          .log_message(MessageType::LOG, "No actionable fix")
          .await;
      }
    }
  }

  /// Register file watchers for configuration files
  async fn register_file_watchers(
    &self,
  ) -> std::result::Result<(), tower_lsp_server::jsonrpc::Error> {
    let yml_watcher = FileSystemWatcher {
      glob_pattern: GlobPattern::String("**/*.{yml,yaml}".to_string()),
      kind: Some(WatchKind::Create | WatchKind::Change | WatchKind::Delete),
    };
    let registration = Registration {
      id: "ast-grep-config-watcher".to_string(),
      method: DidChangeWatchedFiles::METHOD.to_string(),
      register_options: Some(
        serde_json::to_value(DidChangeWatchedFilesRegistrationOptions {
          watchers: vec![yml_watcher],
        })
        .map_err(|e| tower_lsp_server::jsonrpc::Error::invalid_params(e.to_string()))?,
      ),
    };

    self.client.register_capability(vec![registration]).await
  }

  /// Reload rules from configuration and republish diagnostics for all open files
  async fn reload_rules(&self) -> anyhow::Result<()> {
    self
      .client
      .log_message(MessageType::INFO, "Starting rule reload...")
      .await;

    match (self.rule_finder)() {
      Ok(new_rules) => {
        // Update the rules
        {
          let mut rules = self
            .rules
            .write()
            .map_err(|e| anyhow::anyhow!("Lock error: {e}"))?;
          *rules = new_rules;
        }

        self
          .client
          .log_message(
            MessageType::INFO,
            "Rules reloaded successfully using CLI logic",
          )
          .await;
      }
      Err(error) => {
        // popup message
        self
          .client
          .show_message(MessageType::ERROR, format!("Failed to load rules: {error}"))
          .await;
        // log message
        self
          .client
          .log_message(MessageType::ERROR, format!("Failed to load rules: {error}"))
          .await;
      }
    }

    // Clear the interner since rule IDs might have changed
    self.interner.clear();

    // Republish diagnostics for all open files
    self.republish_all_diagnostics().await;

    Ok(())
  }

  /// Republish diagnostics for all currently open files
  async fn republish_all_diagnostics(&self) {
    // Get all currently open file URIs
    for mut entry in self.map.iter_mut() {
      let (uri_str, versioned) = entry.pair_mut();
      let Ok(uri) = uri_str.parse::<Uri>() else {
        continue;
      };
      // Republish diagnostics for this file
      let (diagnostics, fixes) = match self.get_diagnostics(&uri, versioned) {
        Some((d, f)) => (d, f),
        None => (Vec::new(), HashMap::new()),
      };
      versioned.notes = self.build_notes(&diagnostics);
      versioned.fixes = fixes;
      self
        .client
        .publish_diagnostics(uri, diagnostics, Some(versioned.version))
        .await;
    }
  }
}

enum LspError {
  JSONDecodeError(serde_json::Error),
  UnsupportedFileType,
  NoActionableFix,
}



================================================
FILE: crates/lsp/src/utils.rs
================================================
//! Provides utility to convert ast-grep data types to lsp data types
use ast_grep_config::Label;
use ast_grep_config::LabelStyle;
use ast_grep_config::RuleConfig;
use ast_grep_config::Severity;
use ast_grep_core::tree_sitter::{LanguageExt, StrDoc};
use ast_grep_core::{Doc, Node, NodeMatch};

use tower_lsp_server::lsp_types::*;

use std::collections::HashMap;
use std::str::FromStr;

pub type Fixes = HashMap<(Range, String), RewriteData>;

#[derive(Clone)]
pub struct OneFix {
  pub title: Option<String>,
  pub fixed: String,
}

pub struct RewriteData {
  pub fixers: Vec<OneFix>,
  // maybe we should have fixed range
}

impl RewriteData {
  pub fn from_node_match<L: LanguageExt>(
    node_match: &NodeMatch<StrDoc<L>>,
    rule: &RuleConfig<L>,
  ) -> Option<Self> {
    let fixers: Vec<_> = rule
      .matcher
      .fixer
      .iter()
      .filter_map(|fixer| {
        let edit = node_match.make_edit(&rule.matcher, fixer);
        let range = node_match.range();
        // skip if the edit does not match the range
        // TODO: implement expanding range
        if edit.position != range.start || edit.deleted_length != range.len() {
          return None;
        }
        let rewrite = String::from_utf8(edit.inserted_text).ok()?;
        Some(OneFix {
          title: fixer.title().map(ToString::to_string),
          fixed: rewrite,
        })
      })
      .collect();
    if fixers.is_empty() {
      None
    } else {
      Some(Self { fixers })
    }
  }
}

// Accepts an optional fixes cache for fallback
pub fn diagnostic_to_code_action(
  text_doc: &TextDocumentIdentifier,
  diagnostic: Diagnostic,
  fixes_cache: &Fixes,
) -> Option<Vec<CodeAction>> {
  let NumberOrString::String(id) = diagnostic.code.as_ref()? else {
    return None;
  };

  let rewrite_data = fixes_cache.get(&(diagnostic.range, id.clone()))?;

  let actions = rewrite_data
    .fixers
    .clone()
    .into_iter()
    .enumerate()
    .map(|(i, fixer)| {
      let mut changes = HashMap::new();
      let text_edit = TextEdit::new(diagnostic.range, fixer.fixed);
      changes.insert(text_doc.uri.clone(), vec![text_edit]);

      let edit = WorkspaceEdit::new(changes);
      let title = fixer
        .title
        .unwrap_or_else(|| format!("Fix `{id}` with ast-grep"));
      CodeAction {
        title,
        command: None,
        diagnostics: None,
        edit: Some(edit),
        disabled: None,
        kind: Some(CodeActionKind::QUICKFIX),
        is_preferred: Some(i == 0), // mark the first fix as preferred
        data: None,
      }
    });
  Some(actions.collect())
}

fn convert_nodes_to_range<D: Doc>(start_node: &Node<D>, end_node: &Node<D>) -> Range {
  let start = start_node.start_pos();
  let end = end_node.end_pos();
  Range {
    start: Position {
      line: start.line() as u32,
      character: start.column(start_node) as u32,
    },
    end: Position {
      line: end.line() as u32,
      character: end.column(end_node) as u32,
    },
  }
}

fn get_related_info<L: LanguageExt>(
  uri: &Uri,
  labels: &[Label<StrDoc<L>>],
) -> Option<Vec<DiagnosticRelatedInformation>> {
  labels
    .iter()
    .filter_map(|label| {
      let message = label.message?;
      let range = convert_nodes_to_range(&label.start_node, &label.end_node);
      Some(DiagnosticRelatedInformation {
        location: Location {
          uri: uri.clone(),
          range,
        },
        message: message.to_string(),
      })
    })
    .collect::<Vec<_>>()
    .into()
}

fn get_primary_label<L: LanguageExt>(
  node_match: &NodeMatch<StrDoc<L>>,
  labels: &[Label<StrDoc<L>>],
) -> Range {
  let Some(label) = labels.iter().find(|l| l.style == LabelStyle::Primary) else {
    return convert_nodes_to_range(node_match, node_match);
  };
  let start = label.start_node.start_pos();
  let end = label.end_node.end_pos();
  Range {
    start: Position {
      line: start.line() as u32,
      character: start.column(&label.start_node) as u32,
    },
    end: Position {
      line: end.line() as u32,
      character: end.column(&label.end_node) as u32,
    },
  }
}

fn get_node_range_and_related_info<L: LanguageExt>(
  uri: &Uri,
  node_match: &NodeMatch<StrDoc<L>>,
  rule: &RuleConfig<L>,
) -> (Range, Option<Vec<DiagnosticRelatedInformation>>) {
  // if user has not specified any labels, we don't need to show anything
  // the default labels are pretty noisy
  if rule.labels.is_none() {
    let range = convert_nodes_to_range(node_match, node_match);
    return (range, None);
  }
  let labels = rule.get_labels(node_match);
  let related_information = get_related_info(uri, &labels);
  (get_primary_label(node_match, &labels), related_information)
}

pub fn convert_match_to_diagnostic<L: LanguageExt>(
  uri: &Uri,
  node_match: &NodeMatch<StrDoc<L>>,
  rule: &RuleConfig<L>,
) -> Diagnostic {
  let (range, related_information) = get_node_range_and_related_info(uri, node_match, rule);
  Diagnostic {
    range,
    code: Some(NumberOrString::String(rule.id.clone())),
    code_description: url_to_code_description(&rule.url),
    severity: Some(match rule.severity {
      Severity::Error => DiagnosticSeverity::ERROR,
      Severity::Warning => DiagnosticSeverity::WARNING,
      Severity::Info => DiagnosticSeverity::INFORMATION,
      Severity::Hint => DiagnosticSeverity::HINT,
      Severity::Off => unreachable!("turned-off rule should not have match"),
    }),
    message: get_non_empty_message(rule, node_match),
    source: Some(String::from("ast-grep")),
    tags: None,
    related_information,
    data: None,
  }
}

fn get_non_empty_message<L: LanguageExt>(
  rule: &RuleConfig<L>,
  nm: &NodeMatch<StrDoc<L>>,
) -> String {
  // Note: The LSP client in vscode won't show any diagnostics at all if it receives one with an empty message
  if rule.message.is_empty() {
    rule.id.to_string()
  } else {
    rule.get_message(nm)
  }
}

fn url_to_code_description(url: &Option<String>) -> Option<CodeDescription> {
  let href = Uri::from_str(url.as_ref()?).ok()?;
  Some(CodeDescription { href })
}



================================================
FILE: crates/lsp/tests/basic.rs
================================================
use ast_grep_config::{from_yaml_string, GlobalRules, RuleCollection, RuleConfig};
use ast_grep_language::SupportLang;
use ast_grep_lsp::*;
use futures::{SinkExt, StreamExt};
use serde_json::Value;
use std::io;
use std::path::Path;
use tokio::io::{duplex, split, AsyncReadExt, AsyncWriteExt, DuplexStream};
use tokio_util::bytes::{BufMut, BytesMut};
use tokio_util::codec::{Decoder, Encoder, Framed};
use tower_lsp_server::lsp_types::CodeAction;

pub fn req(msg: &str) -> String {
  format!("Content-Length: {}\r\n\r\n{}", msg.len(), msg)
}

// parse json rpc format
pub fn parse_jsonrpc(input: &mut &str) -> Option<Value> {
  let input_str = input.trim_start().trim_start_matches("Content-Length: ");

  let index = input_str.find('\r')?;
  let length = input_str[..index].parse::<usize>().ok()?;
  let input_str = &input_str[length.to_string().len()..];

  let input_str = input_str.trim_start_matches("\r\n\r\n");

  let body = &input_str[..length];
  let value = serde_json::from_str(&body[..length]).ok()?;
  *input = &input_str[length..];
  value
}

// A function that takes a byte slice as input and parse them to Vec<serde_json::Value>
pub fn resp(input: &[u8]) -> Vec<Value> {
  let mut input_str = std::str::from_utf8(input).unwrap();

  let mut resp_list = Vec::new();

  while let Some(val) = parse_jsonrpc(&mut input_str) {
    resp_list.push(val);
  }
  resp_list
}

#[test]
fn req_resp_should_work() {
  let req1_str = "{\"jsonrpc\":\"2.0\",\"method\":\"window/logMessage\",\"params\":{\"message\":\"Running CodeAction source.fixAll\",\"type\":4}}";
  let req2_str = "{\"jsonrpc\":\"2.0\",\"result\":[{\"edit\":{},\"isPreferred\":true,\"kind\":\"source.fixAll\",\"title\":\"Source Code fix action\"}],\"id\":1}";

  let test_buf = format!("{}{}", req(req1_str), req(req2_str));

  let resp_list = resp(test_buf.as_bytes());
  assert_eq!(
    resp_list,
    vec![
      serde_json::from_str::<Value>(req1_str).unwrap(),
      serde_json::from_str::<Value>(req2_str).unwrap()
    ]
  )
}

fn allocate_method_call_id() -> i32 {
  use std::sync::atomic::{AtomicI32, Ordering};
  static COUNTER: AtomicI32 = AtomicI32::new(1);
  COUNTER.fetch_add(1, Ordering::Relaxed)
}

pub fn create_lsp() -> (DuplexStream, DuplexStream) {
  let base = Path::new("./").to_path_buf();

  // Create a rule finder closure that builds the rule collection from scratch
  let rule_finder = move || {
    let globals = GlobalRules::default();
    let config: RuleConfig<SupportLang> = from_yaml_string(
      r"
id: no-console-rule
message: No console.log
severity: warning
language: TypeScript
rule:
  pattern: console.log($$$A)
note: no console.log
fix: |-
  alert($$$A)
",
      &globals,
    )
    .unwrap()
    .pop()
    .unwrap();
    let rc: RuleCollection<SupportLang> = RuleCollection::try_new(vec![config]).unwrap();
    Ok(rc)
  };

  let (service, socket) =
    LspService::build(|client| Backend::new(client, base, rule_finder)).finish();
  let (req_client, req_server) = duplex(1024);
  let (resp_server, resp_client) = duplex(1024);

  // start server as concurrent task
  tokio::spawn(Server::new(req_server, resp_server, socket).serve(service));

  (req_client, resp_client)
}

pub async fn initialize_lsp(
  req_client: &mut DuplexStream,
  resp_client: &mut DuplexStream,
) -> Vec<u8> {
  let initialize = r#"{
      "jsonrpc":"2.0",
      "id": 1,
      "method": "initialize",
      "params": {
        "capabilities": {
          "textDocumentSync": 1
        }
      }
    }"#;
  let mut buf = vec![0; 1024];

  req_client
    .write_all(req(initialize).as_bytes())
    .await
    .unwrap();
  let _ = resp_client.read(&mut buf).await.unwrap();

  buf
}

pub async fn request_execute_command_to_lsp(
  req_client: &mut DuplexStream,
  resp_client: &mut DuplexStream,
) -> Vec<u8> {
  let execute_command_request: &str = r#"
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "workspace/executeCommand",
    "params": {
      "command": "ast-grep.applyAllFixes",
      "arguments": [
        {
          "text": "class AstGrepTest {\n  test() {\n    console.log('Hello, world!')\n  }\n}\n\nclass AnotherCase {\n  get test2() {\n    return 123\n  }\n}\n\nconst NoProblemHere = {\n  test() {\n    if (Math.random() > 3) {\n      throw new Error('This is not an error')\n    }\n  },\n}\n",
          "uri": "file:///Users/codes/ast-grep-vscode/fixture/test.ts",
          "version": 1,
          "languageId": "typescript"
        }
      ]
    }
  }
  "#;
  let mut buf = vec![0; 1024];
  req_client
    .write_all(req(execute_command_request).as_bytes())
    .await
    .unwrap();
  let _ = resp_client.read(&mut buf).await.unwrap();

  buf
}

#[test]
fn test_basic() {
  tokio::runtime::Runtime::new().unwrap().block_on(async {
    let (mut req_client, mut resp_client) = create_lsp();

    let buf = initialize_lsp(&mut req_client, &mut resp_client).await;

    assert!(!resp(&buf).is_empty());
  });
}

#[test]
fn test_execute_apply_all_fixes() {
  tokio::runtime::Runtime::new().unwrap().block_on(async {
    let (mut req_client, mut resp_client) = create_lsp();

    initialize_lsp(&mut req_client, &mut resp_client).await;

    let buf = request_execute_command_to_lsp(&mut req_client, &mut resp_client).await;

    // {"jsonrpc":"2.0","method":"window/logMessage","params":{"message":"Running ExecuteCommand ast-grep.applyAllFixes","type":3}}
    let resp_list = resp(&buf);

    let running_command_resp = resp_list
      .iter()
      .find(|v| v["method"] == "window/logMessage")
      .unwrap();

    assert_eq!(
      running_command_resp["params"]["message"],
      "Running ExecuteCommand ast-grep.applyAllFixes"
    );
  });
}

#[tokio::test]
async fn test_file_watcher_registration() {
  let (mut req_client, mut resp_client) = create_lsp();
  let initialize = r#"{
      "jsonrpc":"2.0",
      "id": 1,
      "method": "initialize",
      "params": {
        "capabilities": {
          "workspace": {
            "workspaceFolders": true,
            "didChangeWatchedFiles": {
              "dynamicRegistration": true
            }
          }
        }
      }
    }"#;

  // Send initialize request
  req_client
    .write_all(req(initialize).as_bytes())
    .await
    .unwrap();

  let mut buf = vec![0; 4096];
  let len = resp_client.read(&mut buf).await.unwrap();
  let response = String::from_utf8_lossy(&buf[..len]);

  // Should contain initialization response
  assert!(response.contains("result") || response.contains("initialize"));

  // Send initialized notification
  let initialized = r#"{
      "jsonrpc":"2.0",
      "method": "initialized",
      "params": {}
    }"#;

  req_client
    .write_all(req(initialized).as_bytes())
    .await
    .unwrap();

  // Read responses - there should be file watcher registration
  let mut buf = vec![0; 4096];
  let len = resp_client.read(&mut buf).await.unwrap();
  let response = String::from_utf8_lossy(&buf[..len]);

  // Should contain capability registration for file watching
  assert!(
    response.contains("client/registerCapability")
      || response.contains("workspace/didChangeWatchedFiles")
      || response.contains("window/logMessage")
  );
}

#[tokio::test]
async fn test_did_change_watched_files() {
  let (mut req_client, mut resp_client) = create_lsp();
  initialize_lsp(&mut req_client, &mut resp_client).await;

  // Send didChangeWatchedFiles notification
  let change_notification = r#"{
      "jsonrpc":"2.0",
      "method": "workspace/didChangeWatchedFiles",
      "params": {
        "changes": [
          {
            "uri": "file:///test/sgconfig.yml",
            "type": 2
          }
        ]
      }
    }"#;

  req_client
    .write_all(req(change_notification).as_bytes())
    .await
    .unwrap();

  let mut buf = vec![0; 4096];
  let len = resp_client.read(&mut buf).await.unwrap();
  let response = String::from_utf8_lossy(&buf[..len]);

  // Should contain log messages about configuration changes
  assert!(
    response.contains("Configuration files changed")
      || response.contains("watched files have changed")
  );
}

// Helper: send_did_open_framed
pub async fn send_did_open_framed(
  framed: &mut Framed<DuplexStream, LspCodec>,
  uri: &str,
  language_id: &str,
  text: &str,
) {
  let did_open = serde_json::json!({
    "jsonrpc": "2.0",
    "method": "textDocument/didOpen",
    "params": {
      "textDocument": {
        "uri": uri,
        "languageId": language_id,
        "version": 1,
        "text": text
      }
    }
  });
  framed.send(did_open).await.unwrap();
}

pub async fn wait_for_diagnostics(
  sender: &mut Framed<DuplexStream, LspCodec>,
) -> Option<serde_json::Value> {
  // Wait for diagnostics
  let mut diagnostics: Option<serde_json::Value> = None;
  for _ in 0..20 {
    if let Ok(Some(Ok(msg))) =
      tokio::time::timeout(std::time::Duration::from_secs(2), sender.next()).await
    {
      if msg.get("method") == Some(&serde_json::json!("textDocument/publishDiagnostics")) {
        diagnostics = Some(msg["params"]["diagnostics"].clone());
        break;
      } else if msg.get("method") == Some(&serde_json::json!("workspace/workspaceFolders")) {
        // Respond with empty workspaceFolders
        let response = serde_json::json!({
          "jsonrpc": "2.0",
          "id": msg["id"].clone(),
          "result": [{
            "uri": "file:///Users/codes/ast-grep-vscode",
            "name": "ast-grep-vscode"
          }]
        });
        sender.send(response).await.unwrap();
      }
    }
  }

  diagnostics
}

async fn wait_for_response(
  sender: &mut Framed<DuplexStream, LspCodec>,
  id: i32,
) -> Option<serde_json::Value> {
  for _ in 0..20 {
    if let Ok(Some(Ok(msg))) =
      tokio::time::timeout(std::time::Duration::from_secs(2), sender.next()).await
    {
      if msg.get("id") == Some(&serde_json::json!(id)) {
        return Some(msg);
      }
    }
  }
  None
}

async fn request_code_action(
  sender: &mut Framed<DuplexStream, LspCodec>,
  file_uri: &str,
  diagnostic: &serde_json::Value,
) -> Option<serde_json::Value> {
  let method_call_id = allocate_method_call_id();
  let code_action_request = serde_json::json!({
    "jsonrpc": "2.0",
    "id": method_call_id,
    "method": "textDocument/codeAction",
    "params": {
      "range": diagnostic["range"].clone(),
      "textDocument": { "uri": file_uri },
      "context": {
        "diagnostics": [diagnostic.clone()]
      }
    }
  });
  sender.send(code_action_request).await.unwrap();
  wait_for_response(sender, method_call_id).await
}

fn apply_all_code_actions(text: &str, actions: &[Value]) -> String {
  // As offsets are based on the original text, we need to track changes
  let mut lines: Vec<String> = text.lines().map(|s| s.to_string()).collect();
  // Collect all edits from all code actions
  let mut all_edits = actions
    .iter()
    .filter_map(|action| {
      let action: CodeAction = serde_json::from_value(action.clone()).ok()?;
      action.edit?.changes
    })
    .flat_map(|changes| changes.into_values())
    .flatten()
    .map(|edit| {
      let range = edit.range;
      (
        range.start.line as usize,
        range.start.character as usize,
        range.end.line as usize,
        range.end.character as usize,
        edit.new_text,
      )
    })
    .collect::<Vec<_>>();

  // Sort the edits in reverse order to avoid offset issues
  all_edits.sort();
  all_edits.reverse();
  // Apply edits in reverse order
  for (start_line, start_char, end_line, end_char, new_text) in all_edits {
    assert!(
      start_line == end_line,
      "Multi-line edits are not supported in this test"
    );
    let line = &lines[start_line];
    let prefix = &line[..start_char];
    let suffix = &line[end_char..];
    lines[start_line] = format!("{prefix}{new_text}{suffix}");
  }

  // Join lines back into a single string
  lines.join("\n")
}

#[tokio::test]
async fn test_single_line_code_edit() {
  let yamls = r"
id: no-console-rule
language: TypeScript
rule:
  pattern: console.log($$$A)
fix: |-
  alert($$$A)
";
  let mut client = create_lsp_framed(yamls).await;

  // Send file content to server
  let file_uri = "file:///Users/codes/ast-grep-vscode/test.ts";
  let file_content = "console.log('Hello, world!')\n";
  send_did_open_framed(&mut client, file_uri, "typescript", file_content).await;

  let diagnostics = &wait_for_diagnostics(&mut client)
    .await
    .expect("No diagnostics received")
    .as_array()
    .expect("Diagnostics should be an array")
    .to_owned();

  assert_eq!(diagnostics.len(), 1, "Expected 1 diagnostic");

  let diagnostic = &diagnostics[0];

  let code_action = request_code_action(&mut client, file_uri, diagnostic).await;

  let code_action = code_action.expect("No code action response");
  // Request code action using diagnostics from server
  let actions = code_action["result"]
    .as_array()
    .expect("Result should be an array");
  assert!(actions.len() == 1, "No code actions returned");

  // Apply the first code action and verify the text change
  let fixed_text = apply_all_code_actions(file_content, actions);
  assert_eq!(fixed_text, "alert('Hello, world!')");
}

#[tokio::test]
async fn test_overlap_line_code_edit() {
  let yamls = r"
id: use-alert
language: TypeScript
message: Use alert instead of console.log
rule:
  pattern: console.log($$$A)
fix: |-
  alert($$$A)
---
id: use-window-alert
language: TypeScript
message: Use window.alert instead of console.log
rule:
  pattern: console.log($$$A)
fix: |-
  window.alert($$$A)
";
  let mut client = create_lsp_framed(yamls).await;

  // Send file content to server
  let file_uri = "file:///Users/codes/ast-grep-vscode/test.ts";
  let file_content = "console.log('Hello, world!')\n";
  send_did_open_framed(&mut client, file_uri, "typescript", file_content).await;

  let diagnostics = &wait_for_diagnostics(&mut client)
    .await
    .expect("No diagnostics received")
    .as_array()
    .expect("Diagnostics should be an array")
    .to_owned();

  assert_eq!(diagnostics.len(), 2, "Expected 2 diagnostics");

  for diagnostic in diagnostics {
    let code_action = request_code_action(&mut client, file_uri, diagnostic).await;
    let code_action = code_action.expect("No code action response");
    let actions = code_action["result"]
      .as_array()
      .expect("Result should be an array");
    assert_eq!(actions.len(), 1, "Expected 1 code action per diagnostic");
    if diagnostic["code"] == "use-alert" {
      assert_eq!(actions[0]["title"], "Fix `use-alert` with ast-grep");

      let fixed_text = apply_all_code_actions(file_content, actions);
      assert_eq!(fixed_text, "alert('Hello, world!')");
    } else if diagnostic["code"] == "use-window-alert" {
      assert_eq!(actions[0]["title"], "Fix `use-window-alert` with ast-grep");

      let fixed_text = apply_all_code_actions(file_content, actions);
      assert_eq!(fixed_text, "window.alert('Hello, world!')");
    } else {
      panic!("Unexpected diagnostic code");
    }
  }
}

#[tokio::test]
async fn test_code_action_fix_all() {
  let yamls = r"
id: use-alert
language: TypeScript
message: Use alert instead of console.log
rule:
  pattern: console.log($$$A)
fix: |-
  alert($$$A)";
  let mut client = create_lsp_framed(yamls).await;

  // Send file content to server
  let file_uri = "file:///Users/codes/ast-grep-vscode/test.ts";
  let file_content = "console.log('Hello, world!')\nconsole.log('Another log')\n";
  send_did_open_framed(&mut client, file_uri, "typescript", file_content).await;
  let diagnostics = &wait_for_diagnostics(&mut client)
    .await
    .expect("No diagnostics received")
    .as_array()
    .expect("Diagnostics should be an array")
    .to_owned();
  assert_eq!(diagnostics.len(), 2, "Expected 2 diagnostics");
  let method_call_id = allocate_method_call_id();
  let code_action_request = serde_json::json!({
    "jsonrpc": "2.0",
    "id": method_call_id,
    "method": "textDocument/codeAction",
    "params": {
      "range": {
        "start": { "line": 0, "character": 0 },
        "end": { "line": 1, "character": 20 }
      },
      "textDocument": { "uri": file_uri },
      "context": {
        "diagnostics": diagnostics,
        "only": ["source.fixAll"]
      }
    }
  });
  client.send(code_action_request).await.unwrap();
  let code_actions = wait_for_response(&mut client, method_call_id).await;
  let code_action = code_actions.expect("No code action response");
  let actions = code_action["result"]
    .as_array()
    .expect("Result should be an array");
  assert!(actions.len() == 1, "Expected 1 code action for fix all");
  assert_eq!(actions[0]["title"], "Fix by ast-grep");
  // Apply the fix all code action and verify the text change
  let fixed_text = apply_all_code_actions(file_content, actions);
  // TODO: This fix ends up with \n being trimmed at the end, need to investigate
  assert_eq!(fixed_text, "alert('Hello, world!')\nalert('Another log')");
}

// Custom LSP Codec for Content-Length framed JSON-RPC
#[derive(Default)]
pub struct LspCodec;

impl Decoder for LspCodec {
  type Item = serde_json::Value;
  type Error = io::Error;

  fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
    let src_str = match std::str::from_utf8(&src[..]) {
      Ok(s) => s,
      Err(_) => return Ok(None), // Not valid UTF-8 yet
    };
    let header = "Content-Length: ";
    let header_pos = src_str.find(header);
    if let Some(pos) = header_pos {
      let rest = &src_str[pos + header.len()..];
      let crlf = rest.find("\r\n\r\n");
      if let Some(crlf_pos) = crlf {
        let len_str = &rest[..crlf_pos];
        let content_len: usize = len_str
          .trim()
          .parse()
          .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
        let body_start = pos + header.len() + crlf_pos + 4;
        if src.len() >= body_start + content_len {
          let json_bytes = &src[body_start..body_start + content_len];
          let value = serde_json::from_slice(json_bytes)
            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
          // Remove processed bytes manually
          let _ = src.split_to(body_start + content_len);
          return Ok(Some(value));
        }
      }
    }
    Ok(None)
  }
}

impl Encoder<serde_json::Value> for LspCodec {
  type Error = io::Error;

  fn encode(&mut self, item: serde_json::Value, dst: &mut BytesMut) -> Result<(), Self::Error> {
    let json =
      serde_json::to_string(&item).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
    let header = format!("Content-Length: {}\r\n\r\n", json.len());
    dst.put(header.as_bytes());
    dst.put(json.as_bytes());
    Ok(())
  }
}

async fn create_lsp_framed(yamls: &'static str) -> Framed<DuplexStream, LspCodec> {
  let base = Path::new("./").to_path_buf();
  let rule_finder = move || {
    let globals = GlobalRules::default();
    let configs = from_yaml_string(yamls, &globals).unwrap();
    let rc: RuleCollection<SupportLang> = RuleCollection::try_new(configs).unwrap();
    Ok(rc)
  };
  let (service, socket) =
    LspService::build(|client| Backend::new(client, base, rule_finder)).finish();
  let (client_write, server_read) = duplex(16384);
  //let (server_write, client_read) = duplex(16384);
  let (r, w) = split(server_read);
  tokio::spawn(Server::new(r, w, socket).serve(service));

  let mut client = Framed::new(client_write, LspCodec);

  let init_call_id = allocate_method_call_id();
  // Initialize with data_support enabled
  let initialize = serde_json::json!({
      "jsonrpc": "2.0",
      "id": init_call_id,
      "method": "initialize",
      "params": {
          "capabilities": {
            "workspace": {
              "workspaceFolders": true,
              "didChangeWatchedFiles": {
                "dynamicRegistration": true
              }
            }
          }
      }
  });
  client.send(initialize).await.unwrap();
  // Wait for initialize response
  wait_for_response(&mut client, init_call_id).await.unwrap();

  // Send 'initialized' notification after receiving 'initialize' response
  client
    .send(serde_json::json!({
      "jsonrpc": "2.0",
      "method": "initialized",
      "params": {}
    }))
    .await
    .unwrap();
  client
}

#[test]
pub fn test_framed_codec() {
  let mut codec = LspCodec;
  let mut buf = BytesMut::new();
  let msg = serde_json::json!({
    "jsonrpc": "2.0",
    "method": "testMethod",
    "params": {
      "key": "value"
    }
  });
  codec.encode(msg.clone(), &mut buf).unwrap();
  let decoded = codec.decode(&mut buf).unwrap().unwrap();
  assert_eq!(decoded, msg);
}



================================================
FILE: crates/napi/README.md
================================================
# @ast-grep/napi

<p align=center>
  <img src="https://ast-grep.github.io/logo.svg" alt="ast-grep"/>
</p>

## ast-grep(sg)

ast-grep(sg) is a CLI tool for code structural search, lint, and rewriting.

This npm package is for programmatic usage of ast-grep.
Please see the [API usage guide](https://ast-grep.github.io/guide/api-usage.html) and [API reference](https://ast-grep.github.io/reference/api.html).

Other resources include [ast-grep's official site](https://ast-grep.github.io/) and [repository](https://github.com/ast-grep/ast-grep).

## Support matrix

### Operating Systems

|                  | node14 | node16 | node18 |
| ---------------- | ------ | ------ | ------ |
| Windows x64      | ✓      | ✓      | ✓      |
| macOS x64        | ✓      | ✓      | ✓      |
| macOS arm64      | ✓      | ✓      | ✓      |
| Linux x64 gnu    | ✓      | ✓      | ✓      |
| Windows x32      | ✓      | ✓      | ✓      |
| Windows arm64    | ✓      | ✓      | ✓      |
<!-- | Linux arm gnu    | ✓      | ✓      | ✓      | -->
<!-- | Linux x64 musl   | ✓      | ✓      | ✓      | -->
<!-- | Linux arm64 gnu  | ✓      | ✓      | ✓      | -->
<!-- | Linux arm64 musl | ✓      | ✓      | ✓      | -->
<!-- | Android arm64    | ✓      | ✓      | ✓      | -->
<!-- | Android armv7    | ✓      | ✓      | ✓      | -->
<!-- | FreeBSD x64      | ✓      | ✓      | ✓      | -->



================================================
FILE: crates/napi/build.rs
================================================
extern crate napi_build;

fn main() {
  napi_build::setup();
}



================================================
FILE: crates/napi/Cargo.toml
================================================
[package]
name = "ast-grep-napi"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]

authors.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true
edition.workspace = true
# do not publish this crate since it is only used for napi
publish = false

[dependencies]
ast-grep-core.workspace = true
ast-grep-config.workspace = true
ast-grep-language = { path = "../language", features = ["napi-lang"], default-features = false }
ast-grep-dynamic.workspace = true

napi = { version = "3.0.0", features = ["serde-json", "napi4", "error_anyhow"] }
napi-derive = "3.0.0"

ignore.workspace = true
tree-sitter.workspace = true
serde_json = "1.0.116"

[features]
# this feature is only for cargo test to avoid napi_ symbol undefined error
# see also napi-rs/napi-rs#1005, napi-rs/napi-rs#1099 and napi-rs/napi-rs#1032
napi-noop-in-unit-test = ["napi-derive/noop"]

[lib]
crate-type = ["cdylib"]

[build-dependencies]
napi-build = "2.2.2"


================================================
FILE: crates/napi/dprint.json
================================================
{
  "incremental": true,
  "typescript": {
    "semiColons": "asi",
    "arrowFunction.useParentheses": "preferNone",
    "quoteStyle": "preferSingle",
    "indentWidth": 2,
    "useTabs": false
  },
  "excludes": [
    "index.js",
    "node_modules",
    "**/*.min.js"
  ],
  "plugins": [
    "https://plugins.dprint.dev/typescript-0.93.0.wasm"
  ]
}


================================================
FILE: crates/napi/index.d.ts
================================================
// -----Type Only Export!-----//
export type { FileOption, FindConfig, NapiConfig } from './types/config'
export type { DynamicLangRegistrations } from './types/registerDynamicLang'
export type { Edit, Pos, Range } from './types/sgnode'
// Only Rule here. User can use Rule['pattern'], e.g., to get the type of subfield.
export type { Rule } from './types/rule'

// -----Runtime Value Export!-----//
export { findInFiles, kind, parse, parseAsync, parseFiles, pattern } from './types/api'
export { Lang } from './types/lang'
export { registerDynamicLanguage } from './types/registerDynamicLang'
export { SgNode, SgRoot } from './types/sgnode'
// deprecated
export * from './types/deprecated'



================================================
FILE: crates/napi/index.js
================================================
// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */

const { createRequire } = require('node:module')
require = createRequire(__filename)

const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      try {
        return require('./ast-grep-napi.android-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-android-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm') {
      try {
        return require('./ast-grep-napi.android-arm-eabi.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-android-arm-eabi')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Android ${process.arch}`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      try {
        return require('./ast-grep-napi.win32-x64-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-win32-x64-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'ia32') {
      try {
        return require('./ast-grep-napi.win32-ia32-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-win32-ia32-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./ast-grep-napi.win32-arm64-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-win32-arm64-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Windows: ${process.arch}`))
    }
  } else if (process.platform === 'darwin') {
    try {
      return require('./ast-grep-napi.darwin-universal.node')
    } catch (e) {
      loadErrors.push(e)
    }
    try {
      return require('@ast-grep/napi-darwin-universal')
    } catch (e) {
      loadErrors.push(e)
    }
    if (process.arch === 'x64') {
      try {
        return require('./ast-grep-napi.darwin-x64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-darwin-x64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./ast-grep-napi.darwin-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-darwin-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on macOS: ${process.arch}`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      try {
        return require('./ast-grep-napi.freebsd-x64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-freebsd-x64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./ast-grep-napi.freebsd-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-freebsd-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on FreeBSD: ${process.arch}`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        try {
          return require('./ast-grep-napi.linux-x64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-x64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./ast-grep-napi.linux-x64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-x64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        try {
          return require('./ast-grep-napi.linux-arm64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-arm64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./ast-grep-napi.linux-arm64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-arm64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        try {
          return require('./ast-grep-napi.linux-arm-musleabihf.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-arm-musleabihf')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./ast-grep-napi.linux-arm-gnueabihf.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-arm-gnueabihf')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        try {
          return require('./ast-grep-napi.linux-riscv64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-riscv64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./ast-grep-napi.linux-riscv64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@ast-grep/napi-linux-riscv64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'ppc64') {
      try {
        return require('./ast-grep-napi.linux-ppc64-gnu.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-linux-ppc64-gnu')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 's390x') {
      try {
        return require('./ast-grep-napi.linux-s390x-gnu.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-linux-s390x-gnu')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Linux: ${process.arch}`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      try {
        return require('./ast-grep-napi.linux-arm64-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-linux-arm64-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'x64') {
      try {
        return require('./ast-grep-napi.linux-x64-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-linux-x64-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm') {
      try {
        return require('./ast-grep-napi.linux-arm-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@ast-grep/napi-linux-arm-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on OpenHarmony: ${process.arch}`))
    }
  } else {
    loadErrors.push(new Error(`Unsupported OS: ${process.platform}, architecture: ${process.arch}`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./ast-grep-napi.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('@ast-grep/napi-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      `Cannot find native binding. ` +
        `npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). ` +
        'Please try `npm i` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(`Failed to load native binding`)
}

module.exports = nativeBinding
module.exports.SgNode = nativeBinding.SgNode
module.exports.SgRoot = nativeBinding.SgRoot
module.exports.findInFiles = nativeBinding.findInFiles
module.exports.kind = nativeBinding.kind
module.exports.Lang = nativeBinding.Lang
module.exports.parse = nativeBinding.parse
module.exports.parseAsync = nativeBinding.parseAsync
module.exports.parseFiles = nativeBinding.parseFiles
module.exports.pattern = nativeBinding.pattern
module.exports.registerDynamicLanguage = nativeBinding.registerDynamicLanguage
module.exports.css = nativeBinding.css
module.exports.html = nativeBinding.html
module.exports.js = nativeBinding.js
module.exports.jsx = nativeBinding.jsx
module.exports.ts = nativeBinding.ts
module.exports.tsx = nativeBinding.tsx



================================================
FILE: crates/napi/LICENSE
================================================
MIT License

Copyright (c) 2020 N-API for Rust

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: crates/napi/package.json
================================================
{
  "name": "@ast-grep/napi",
  "version": "0.39.5",
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "homepage": "https://ast-grep.github.io",
  "main": "index.js",
  "repository": "https://github.com/ast-grep/ast-grep",
  "license": "MIT",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "files": [
    "index.d.ts",
    "index.js",
    "types/*.ts",
    "lang/*.ts"
  ],
  "napi": {
    "binaryName": "ast-grep-napi",
    "targets": [
      "x86_64-unknown-linux-gnu",
      "x86_64-pc-windows-msvc",
      "x86_64-apple-darwin",
      "i686-pc-windows-msvc",
      "aarch64-apple-darwin",
      "aarch64-pc-windows-msvc",
      "aarch64-unknown-linux-gnu",
      "aarch64-unknown-linux-musl",
      "x64-unknown-linux-musl"
    ]
  },
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "scripts": {
    "artifacts": "napi artifacts",
    "build": "napi build --no-const-enum --dts ignore.d.ts --platform --release",
    "build:debug": "napi build --no-const-enum --dts ignore.d.ts --platform",
    "prepublishOnly": "napi prepublish -t npm --no-gh-release",
    "pretest": "ts-node scripts/generateTypes.ts --test-only",
    "test": "tsc --noEmit && ava",
    "version": "napi version",
    "lint": "oxlint && dprint check",
    "format": "dprint fmt",
    "format:check": "dprint check",
    "typegen": "ts-node scripts/generateTypes.ts"
  },
  "devDependencies": {
    "@ast-grep/napi": "0.39.5",
    "@napi-rs/cli": "3.2.0",
    "@types/node": "^22.10.2",
    "oxlint": "1.16.0",
    "ava": "6.4.1",
    "chalk": "5.6.2",
    "dprint": "0.50.2",
    "smol-toml": "^1.3.1",
    "ts-node": "10.9.2",
    "typescript": "5.9.2"
  },
  "ava": {
    "require": [
      "ts-node/register"
    ],
    "extensions": [
      "ts"
    ],
    "timeout": "2m",
    "workerThreads": false,
    "environmentVariables": {
      "TS_NODE_PROJECT": "./tsconfig.json"
    }
  }
}


================================================
FILE: crates/napi/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2018",
    "strict": true,
    /* smol toml insists it only supports Node>20 */
    "lib": ["ES2022.error"],
    "moduleResolution": "node",
    "module": "CommonJS",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "ts-node": {
    "transpileOnly": true
  },
  "include": ["."],
  "exclude": ["node_modules", "ignore.d.ts"]
}



================================================
FILE: crates/napi/.npmignore
================================================
[Empty file]


================================================
FILE: crates/napi/.yarnrc.yml
================================================
nodeLinker: node-modules



================================================
FILE: crates/napi/__test__/custom.spec.ts
================================================
import test from 'ava'

import { findInFiles, parse, registerDynamicLanguage } from '../index'

const { platform, arch } = process

const isAppleSilicon = platform === 'darwin' && arch === 'arm64'
const isX64Linux = platform === 'linux' && arch === 'x64'
const canTestDynamicLang = isAppleSilicon || isX64Linux

if (isAppleSilicon) {
  registerDynamicLanguage({
    json: {
      libraryPath: '../../fixtures/json-mac.so',
      languageSymbol: 'tree_sitter_json',
      extensions: ['json'],
    },
  })
} else if (isX64Linux) {
  registerDynamicLanguage({
    json: {
      libraryPath: '../../fixtures/json-linux.so',
      languageSymbol: 'tree_sitter_json',
      extensions: ['json'],
    },
  })
}

test('test load custom lang', t => {
  if (!canTestDynamicLang) {
    t.pass('This test is not available on this platform')
    return
  }
  const sg = parse('json', '{"test": 123}')
  const root = sg.root()
  const node = root.find('123')!
  t.truthy(node)
  t.is(node.kind(), 'number')
  const no = root.find('456')
  t.falsy(no)
})

test('discover file', async t => {
  if (!canTestDynamicLang) {
    t.pass('This test is not available on this platform')
    return
  }
  await findInFiles('json', {
    paths: ['../'],
    matcher: {
      rule: {
        kind: 'string',
      },
    },
  }, (error, nodes) => {
    t.falsy(error)
    t.truthy(nodes)
    t.is(nodes[0].kind(), 'string')
    const file = nodes[0].getRoot().filename()
    t.assert(file.endsWith('.json'))
  })
})



================================================
FILE: crates/napi/__test__/index.spec.ts
================================================
import test from 'ava'

import { html, js, parseFiles, ts, tsx } from '../index'
const { parse, kind } = js
const parseMulti = countedPromise(parseFiles)

test('find from native code', t => {
  const sg = parse('console.log(123)')
  const match = sg.root().find('console.log')
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 11, index: 11 },
  })
  const node = match!.find('console')
  t.deepEqual(node!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 7, index: 7 },
  })
})

test('parse async', async t => {
  const sg = await js.parseAsync('console.log(123)')
  const match = sg.root().find('console.log')
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 11, index: 11 },
  })
  const node = match!.find('console')
  t.deepEqual(node!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 7, index: 7 },
  })
})

test('find multiple nodes', t => {
  const sg = parse('a(1, 2, 3)')
  const match = sg.root().find('a($$$B)')
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 10, index: 10 },
  })
  const matchedVar = match!.getMultipleMatches('B')
  const start = matchedVar[0].range().start
  const end = matchedVar[matchedVar.length - 1].range().end
  t.deepEqual(start, { line: 0, column: 2, index: 2 })
  t.deepEqual(end, { line: 0, column: 9, index: 9 })
})

test('find unicode', t => {
  const str = `console.log("Hello, 世界")
  print("ザ・ワールド")`
  const sg = parse(str)
  const match = sg.root().find('console.log($_)')
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 24, index: 24 },
  })
  const node = sg.root().find('print($_)')
  t.deepEqual(node!.range(), {
    start: { line: 1, column: 2, index: 27 },
    end: { line: 1, column: 17, index: 42 },
  })
})

test('find with transformation', t => {
  const str = `console.log("Hello, 世界")`
  const sg = parse(str)
  const match = sg.root().find({
    rule: {
      pattern: 'console.log($A)',
    },
    transform: {
      NEW_ARG: {
        substring: {
          source: '$A',
          startChar: 1,
          endChar: -1,
        },
      },
    },
  })!
  t.deepEqual(match.getTransformed('NEW_ARG'), 'Hello, 世界')
  t.deepEqual(match.getMatch('A')?.text(), '"Hello, 世界"')
})

test('test code fix', t => {
  const sg = parse('a = console.log(123)')
  const match = sg.root().find('console.log')!
  const fix = match.replace('console.error')
  t.deepEqual(fix.insertedText, 'console.error')
  t.deepEqual(fix.startPos, 4)
  t.deepEqual(fix.endPos, 15) // length of console.log
  t.deepEqual(match.commitEdits([fix]), 'console.error')
  const newCode = sg.root().commitEdits([fix])
  t.deepEqual(newCode, 'a = console.error(123)')
})

test('test code with multiple fixes', t => {
  // and also test unicode
  const sg = parse('いいよ = log(123) + log(456)')
  const matches = sg.root().findAll(js.kind('number'))
  const fixes = matches.map(match => match.replace('114514'))
  // make it in reverse order to test rust behavior
  fixes.sort((a, b) => b.startPos - a.startPos)
  const newCode = sg.root().commitEdits(fixes)
  t.deepEqual(newCode, 'いいよ = log(114514) + log(114514)')
})

test('test code fix with user defined range', t => {
  const sg = parse('いいよ = log(123)')
  const match = sg.root().find(js.kind('number'))!
  const edit = match.replace('514')
  edit.startPos -= 1
  edit.endPos += 1
  const newCode = sg.root().commitEdits([edit])
  t.deepEqual(newCode, 'いいよ = log514')
})

test('findAll from native code', t => {
  const sg = parse('console.log(123); let a = console.log.bind(console);')
  const match = sg.root().findAll('console.log')
  t.deepEqual(match.length, 2)
  t.deepEqual(match[0].range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 11, index: 11 },
  })
  t.deepEqual(match[1].range(), {
    start: { line: 0, column: 26, index: 26 },
    end: { line: 0, column: 37, index: 37 },
  })
})

test('find not match', t => {
  const sg = parse('console.log(123)')
  const match = sg.root().find('notExist')
  t.is(match, null)
})

test('get variable', t => {
  const sg = parse('console.log("hello world")')
  const match = sg.root().find('console.log($MATCH)')
  t.is(match!.getMatch('MATCH')!.text(), '"hello world"')
})

test('find by kind', t => {
  const sg = parse('console.log("hello world")')
  const match = sg.root().find(kind('member_expression'))
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 11, index: 11 },
  })
})

test('find by config', t => {
  const sg = parse('console.log("hello world")')
  const match = sg.root().find({
    rule: { kind: 'member_expression' },
  })
  t.deepEqual(match!.range(), {
    start: { line: 0, column: 0, index: 0 },
    end: { line: 0, column: 11, index: 11 },
  })
})

test('test find files', async t => {
  await parseMulti(['./__test__/index.spec.ts'], (err, tree) => {
    t.is(err, null)
    t.is(tree.filename(), './__test__/index.spec.ts')
    t.assert(tree.root() !== null)
  })
})

test('test file count', async t => {
  let i = 0
  const fileCount = await parseMulti(['./'], (err, _) => {
    // ZZZ... sleep a while to mock expensive operation
    const start = Date.now()
    while (Date.now() - start < 1) {}
    t.is(err, null)
    i++
  })
  t.is(i, fileCount)
})

test('test languageGlobs', async t => {
  let i = 0
  let foundVue = false
  const fileCount = await parseMulti(
    {
      paths: ['./'],
      languageGlobs: {
        html: ['*.vue'],
      },
    },
    (err, root) => {
      t.is(err, null)
      if (root.filename().endsWith('.vue')) {
        foundVue = true
      }
      i++
    },
  )
  t.is(i, fileCount)
  t.true(foundVue)
})

test('show good error message for invalid arg', async t => {
  const sg = parse('console.log(123)')
  t.throws(() => sg.root().find({ rule: { regex: '(' } }), {
    message: /Rule contains invalid regex matcher/,
  })
  t.throws(
    () =>
      sg.root().find({
        rule: { all: [{ any: [{ kind: '33' }] }] },
      }),
    {
      message: /Rule contains invalid kind matcher/,
    },
  )
})

test('get node id', async t => {
  const sg = parse('console.log(123)')
  const nodeWithPattern = sg.root().find('console.log($$$)')
  const nodeWithKind = sg.root().find(kind('call_expression'))
  t.is(nodeWithPattern!.id(), nodeWithKind!.id())
})

test('find in files', async t => {
  const findInFiles = countedPromise(ts.findInFiles)
  await findInFiles(
    {
      paths: ['./'],
      matcher: {
        rule: { kind: 'member_expression' },
      },
    },
    (err, n) => {
      // ZZZ... sleep a while to mock expensive operation
      const start = Date.now()
      while (Date.now() - start < 1) {}
      t.is(err, null)
      t.assert(n.length > 0)
      t.assert(n[0].text().includes('.'))
    },
  )
})

// gh #1380
test('find in files with meta var', async t => {
  const findInFiles = countedPromise(ts.findInFiles)
  await findInFiles(
    {
      paths: ['./'],
      matcher: {
        rule: { pattern: 'parse($V)' },
      },
    },
    (err, n) => {
      // ZZZ... sleep a while to mock expensive operation
      const start = Date.now()
      while (Date.now() - start < 1) {}
      t.is(err, null)
      t.assert(n.length > 0)
      const metavarText = n[0].getMatch('V')?.text()
      t.is(metavarText, "'console.log(123)'")
    },
  )
})

test('find in files with filename', async t => {
  const findInFiles = countedPromise(ts.findInFiles)
  await findInFiles(
    {
      paths: ['./__test__/'],
      matcher: {
        rule: { kind: 'await_expression' },
      },
    },
    (err, n) => {
      t.is(err, null)
      const root = n[0].getRoot()
      const filename = root.filename()
      t.assert(filename.includes('.spec.ts'))
    },
  )
})

test('tsx should not find ts file', async t => {
  await tsx.findInFiles(
    {
      paths: ['./'],
      matcher: {
        rule: { kind: 'member_expression' },
      },
    },
    () => {
      t.assert(false)
    },
  )
  t.assert(true)
})

test('find with language globs', async t => {
  const findInFiles = countedPromise(tsx.findInFiles)
  await findInFiles(
    {
      paths: ['./__test__/'],
      matcher: {
        rule: { kind: 'await_expression' },
      },
      languageGlobs: ['*.ts'],
    },
    (err, n) => {
      t.is(err, null)
      const root = n[0].getRoot()
      t.assert(root.filename().includes('.spec.ts'))
    },
  )
})

test('find with language globs can parse with correct language', async t => {
  const findInFiles = countedPromise(html.findInFiles)
  await findInFiles(
    {
      paths: ['./'],
      matcher: {
        rule: { pattern: '<template>$A</template>' },
      },
      languageGlobs: ['*.vue'],
    },
    (err, n) => {
      t.is(err, null)
      const root = n[0].getRoot()
      t.is(root.filename().replace('\\', '/'), './__test__/test.vue')
      const div = root.root().find('<h1>$A</h1>')?.getMatch('A')?.text()
      t.is(div, '{{ greeting }}')
    },
  )
})

test('fieldChildren returns all the fields of the given field', t => {
  const sg = tsx.parse('const el = <div id="foo" className="bar" />')
  const jsxElement = sg.root().find(tsx.kind('jsx_self_closing_element'))!
  const fields = jsxElement.fieldChildren('attribute')
  t.is(fields.length, 2)
  t.is(fields[0].text(), 'id="foo"')
  t.is(fields[1].text(), 'className="bar"')
})

// oxlint-disable-next-line typescript/no-explicit-any
function countedPromise<F extends (t: any, cb: any) => Promise<number>>(
  func: F,
) {
  type P = Parameters<F>
  return async (t: P[0], cb: P[1]) => {
    let i = 0
    let fileCount: number | undefined = undefined
    let resolve = () => {} // will be called after all files are processed
    function wrapped(...args: unknown[]) {
      const ret = cb(...args)
      if (++i === fileCount) resolve()
      return ret
    }
    fileCount = await func(t, wrapped as P[1])
    // all files are not processed, wait the resolve function to be called
    if (fileCount > i) {
      await new Promise<void>(r => {
        resolve = r
      })
    }
    return fileCount
  }
}

test('find node by range', t => {
  const sg = parse(
    'const message = `This is a multiline message with unicode characters\nÜbergang\nدرود\n🙌\n`;',
  )
  const node = sg.root().find({
    rule: {
      range: {
        start: { line: 0, column: 16 },
        end: { line: 4, column: 1 },
      },
    },
  })
  const byKind = sg.root().find(js.kind('template_string'))
  t.is(node!.id(), byKind!.id())
})

test('check if a node matches a rule using pattern', t => {
  const sg = parse('console.log(123)')
  const match = sg.root().find({ rule: { kind: 'call_expression' } })
  t.assert(match!.matches('console.log($$$)'))
  t.assert(match!.matches('console.log') === false)
})

test('check if a node matches a rule using config', t => {
  const sg = parse('console.log(123)')
  const match = sg.root().find('console.log($$$)')
  t.assert(match!.matches({ rule: { kind: 'call_expression' } }))
  t.assert(match!.matches({ rule: { kind: 'identifier' } }) === false)
})

test('check if a node follows another using pattern', t => {
  const sg = parse('const a = 1; const b = 2;')
  const match = sg.root().find('const a = 1')
  t.assert(match!.follows('const b = 2') === false)
  t.assert(sg.root().find('const b = 2')!.follows('const a = 1'))
})

test('check if a node follows another using config', t => {
  const sg = parse('const a = 1; const b = 2;')
  const match = sg.root().find('const a = 1')
  t.assert(match!.follows({ rule: { pattern: 'const b = 2' } }) === false)
  t.assert(sg.root().find('const b = 2')!.follows({ rule: { pattern: 'const a = 1' } }))
})

test('check if a node precedes another using pattern', t => {
  const sg = parse('const a = 1; const b = 2;')
  const match = sg.root().find('const a = 1')
  t.assert(match!.precedes('const b = 2'))
  t.assert(sg.root().find('const b = 2')!.precedes('const a = 1') === false)
})

test('check if a node precedes another using config', t => {
  const sg = parse('const a = 1; const b = 2;')
  const match = sg.root().find('const a = 1')
  t.assert(match!.precedes({ rule: { pattern: 'const b = 2' } }))
  t.assert(sg.root().find('const b = 2')!.precedes({ rule: { pattern: 'const a = 1' } }) === false)
})

test('check if a node is inside another using pattern', t => {
  const sg = parse('if (true) { const x = 1; }')
  const match = sg.root().find('const x = 1')
  t.assert(match!.inside('if (true) { $$$ }'))
  t.assert(match!.inside('function() { $$$ }') === false)
})

test('check if a node is inside another using config', t => {
  const sg = parse('if (true) { const x = 1; }')
  const match = sg.root().find('const x = 1')
  t.assert(match!.inside({ rule: { pattern: 'if (true) { $$$ }' } }))
  t.assert(match!.inside({ rule: { pattern: 'function() { $$$ }' } }) === false)
})

test('check if a node has another using pattern', t => {
  const sg = parse('if (true) { const x = 1; }')
  const match = sg.root().find('if (true) { $$$ }')
  t.assert(match!.has('const x = 1'))
  t.assert(match!.has('const y = 2') === false)
})

test('check if a node has another using config', t => {
  const sg = parse('if (true) { const x = 1; }')
  const match = sg.root().find('if (true) { $$$ }')
  t.assert(match!.has({ rule: { pattern: 'const x = 1' } }))
  t.assert(match!.has({ rule: { pattern: 'const y = 2' } }) === false)
})



================================================
FILE: crates/napi/__test__/test.vue
================================================
<template>
  <div>
    <h1>{{ greeting }}</h1>
    <p>{{ message }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      greeting: 'Hello',
      message: 'Welcome to Vue SFC!',
    }
  },
}
</script>

<style>
h1 {
  color: #42b983;
}
</style>


================================================
FILE: crates/napi/__test__/type.spec.ts
================================================
import test from 'ava'

import { Lang, parse, parseAsync, type SgNode, type SgRoot } from '../index'
import type TypeScriptTypes from '../lang/TypeScript'

test('test no type annotation', t => {
  const sg = parse(Lang.TypeScript, 'a + b')
  // test root kind and field
  const root = sg.root()
  t.is(root.kind(), 'program')
  t.is(root.field('body'), null)
  // test child
  const child = root.child(0)
  t.assert(child !== null)
  const childKind = child!.kind()
  t.assert(childKind === 'expression_statement')
  t.assert(childKind !== ',')
  // test parent method
  const parent = child!.parent()
  t.assert(parent!.kind() === root.kind())
  // test find
  const sum = root.find({
    rule: {
      kind: 'binary_expression',
    },
  })!
  t.is(sum.kind(), 'binary_expression')
  t.is(sum.field('operator')!.kind(), '+')

  // test type refinement
  const a = root.find('a')!
  t.assert(a.is('identifier'))
  if (a.is('identifier')) {
    t.assert(a.kind() === 'identifier')
    // @ts-expect-error: should refine kind
    t.assert(a.kind() !== 'invalid')
    t.is(a.field('type_annotation'), null)
  }

  // test rule kind
  t.throws(() => {
    root.find({
      rule: {
        kind: 'notFound', // ok for no type
      },
    })
  })
})

test('test type assertion', t => {
  const sg = parse(Lang.TypeScript, 'a + b') as SgRoot<TypeScriptTypes>
  // test root
  const root = sg.root() as SgNode<TypeScriptTypes, 'program'>
  t.is(root.kind(), 'program')
  // @ts-expect-error
  t.is(root.field('body'), null)
  // test child
  const child = root.child(0) as SgNode<
    TypeScriptTypes,
    'expression_statement' | (string & {})
  >
  t.assert(child !== null)
  const childKind = child!.kind()
  t.assert(childKind === 'expression_statement')
  t.assert(childKind !== ',')
  // test parent method
  const parent = child!.parent()
  t.assert(parent?.kind() === root.kind())
  // test find
  const sum = root.find({
    rule: {
      kind: 'binary_expression',
    },
  }) as SgNode<TypeScriptTypes, 'binary_expression'>
  t.is(sum.kind(), 'binary_expression')
  const kind = sum.field('operator').kind()
  t.assert(kind === '+')
  t.assert(kind !== 'invalid')

  // test type refinement
  const a = root.find('a')!
  t.assert(a.is('identifier'))
  if (a.is('identifier')) {
    t.is(a.kind(), 'identifier')
    // @ts-expect-error: should refine kind
    t.assert(a.kind() !== 'invalid')
    // @ts-expect-error: should reject field
    t.is(a.field('type_annotation'), null)
  }
  // test rule kind
  t.throws(() => {
    root.find({
      rule: {
        // @ts-expect-error: reject kind
        kind: 'notFound',
      },
    })
  })
})

test('test type argument style', t => {
  const sg = parse<TypeScriptTypes>(Lang.TypeScript, 'a + b')
  // test root
  const root = sg.root()
  t.is(root.kind(), 'program')
  // @ts-expect-error
  t.is(root.field('body'), null)
  // test child
  const child = root.child<'expression_statement'>(0)
  t.assert(child !== null)
  const childKind = child!.kind()
  t.is(childKind, 'expression_statement')
  // @ts-expect-error
  t.assert(childKind !== ',')
  // test parent method
  const parent = child!.parent<'program'>()
  t.assert(parent!.kind() === root.kind())
  // @ts-expect-error should reject wrong kind
  const parent2 = child!.parent<'eskdf'>()
  t.assert(parent2!.kind() === root.kind())
  const parent3 = child!.parent<'expression_statement'>()
  // @ts-expect-error parent3 should take new kind
  t.assert(parent3!.kind() === root.kind())
  // @ts-expect-error should report invalid child type
  root.child<'binary_expression'>
  // test find
  const sum = root.find<'binary_expression'>({
    rule: {
      kind: 'binary_expression',
    },
  })!
  t.is(sum.kind(), 'binary_expression')
  const kind = sum.field('operator').kind()
  t.assert(kind === '+')
  t.assert(kind !== 'invalid')

  // test type refinement
  const a = root.find('a')!
  t.assert(a.is('identifier'))
  if (a.is('identifier')) {
    t.assert(a.kind() === 'identifier')
    // @ts-expect-error: should refine kind
    t.assert(a.kind() !== 'invalid')
    // @ts-expect-error: should reject field
    t.is(a.field('type_annotation'), null)
  }
  // okay to use any annotation
  t.is(a.field('type_annotation'), null)

  // test rule kind
  t.throws(() => {
    root.find({
      rule: {
        // @ts-expect-error: reject kind
        kind: 'notFound',
      },
    })
  })
})

test('subtype alias', async t => {
  const sg = await parseAsync<TypeScriptTypes>(
    Lang.TypeScript,
    'export function a() {}',
  )
  const root = sg.root()
  const exp = root.find<'export_statement'>('export function a() {}')!
  const declaration = exp.field('declaration')!
  const kind = declaration.kind()

  // test exhaustive switch
  switch (declaration.kindToRefine) {
    case 'enum_declaration': {
      declaration.field('name')
      // @ts-expect-error: report
      declaration.field('decorator')
      break
    }
    case 'abstract_class_declaration':
    case 'generator_function_declaration':
    case 'ambient_declaration':
    case 'class_declaration':
    case 'function_declaration':
    case 'function_signature':
    case 'import_alias':
    case 'interface_declaration':
    case 'internal_module':
    case 'lexical_declaration':
    case 'module':
    case 'type_alias_declaration':
    case 'variable_declaration':
      break
    default: {
      declaration satisfies never
      t.fail('should not be here')
    }
  }

  // test child kind
  const child = exp.child(0)!
  t.false(child.is('new_expression'))

  t.assert(kind === 'function_declaration')
  t.assert(declaration.kind() !== 'class_declaration')
  // @ts-expect-error: no type alias
  t.assert(declaration.kind() !== 'declaration')
  // @ts-expect-error: kind refined
  t.assert(declaration.kind() !== 'identifier')
  // test rule kind
  const wrong = root.find({
    rule: {
      // @ts-expect-error: reject alias type
      kind: 'declaration',
    },
  })
  t.falsy(wrong)
})



================================================
FILE: crates/napi/lang/.gitkeep
================================================
[Empty file]


================================================
FILE: crates/napi/npm/darwin-arm64/README.md
================================================
# `@ast-grep/napi-darwin-arm64`

This is the **aarch64-apple-darwin** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/darwin-arm64/package.json
================================================
{
  "name": "@ast-grep/napi-darwin-arm64",
  "version": "0.39.5",
  "os": [
    "darwin"
  ],
  "cpu": [
    "arm64"
  ],
  "main": "ast-grep-napi.darwin-arm64.node",
  "files": [
    "ast-grep-napi.darwin-arm64.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/darwin-x64/README.md
================================================
# `@ast-grep/napi-darwin-x64`

This is the **x86_64-apple-darwin** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/darwin-x64/package.json
================================================
{
  "name": "@ast-grep/napi-darwin-x64",
  "version": "0.39.5",
  "os": [
    "darwin"
  ],
  "cpu": [
    "x64"
  ],
  "main": "ast-grep-napi.darwin-x64.node",
  "files": [
    "ast-grep-napi.darwin-x64.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/linux-arm64-gnu/README.md
================================================
# `@ast-grep/napi-linux-arm64-gnu`

This is the **aarch64-unknown-linux-gnu** binary for `@ast-grep/napi`


================================================
FILE: crates/napi/npm/linux-arm64-gnu/package.json
================================================
{
  "name": "@ast-grep/napi-linux-arm64-gnu",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "arm64"
  ],
  "libc": [
    "glibc"
  ],
  "main": "ast-grep-napi.linux-arm64-gnu.node",
  "files": [
    "ast-grep-napi.linux-arm64-gnu.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/linux-arm64-musl/README.md
================================================
# `@ast-grep/napi-linux-arm64-musl`

This is the **aarch64-unknown-linux-musl** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/linux-arm64-musl/package.json
================================================
{
  "name": "@ast-grep/napi-linux-arm64-musl",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "arm64"
  ],
  "libc": [
    "musl"
  ],
  "main": "ast-grep-napi.linux-arm64-musl.node",
  "files": [
    "ast-grep-napi.linux-arm64-musl.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/linux-x64-gnu/README.md
================================================
# `@ast-grep/napi-linux-x64-gnu`

This is the **x86_64-unknown-linux-gnu** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/linux-x64-gnu/package.json
================================================
{
  "name": "@ast-grep/napi-linux-x64-gnu",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "x64"
  ],
  "libc": [
    "glibc"
  ],
  "main": "ast-grep-napi.linux-x64-gnu.node",
  "files": [
    "ast-grep-napi.linux-x64-gnu.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/linux-x64-musl/README.md
================================================
# `@ast-grep/napi-linux-x64-musl`

This is the **x86_64-unknown-linux-musl** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/linux-x64-musl/package.json
================================================
{
  "name": "@ast-grep/napi-linux-x64-musl",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "x64"
  ],
  "libc": [
    "musl"
  ],
  "main": "ast-grep-napi.linux-x64-musl.node",
  "files": [
    "ast-grep-napi.linux-x64-musl.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/win32-arm64-msvc/README.md
================================================
# `@ast-grep/napi-win32-arm64-msvc`

This is the **aarch64-pc-windows-msvc** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/win32-arm64-msvc/package.json
================================================
{
  "name": "@ast-grep/napi-win32-arm64-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "arm64"
  ],
  "main": "ast-grep-napi.win32-arm64-msvc.node",
  "files": [
    "ast-grep-napi.win32-arm64-msvc.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/win32-ia32-msvc/README.md
================================================
# `@ast-grep/napi-win32-ia32-msvc`

This is the **i686-pc-windows-msvc** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/win32-ia32-msvc/package.json
================================================
{
  "name": "@ast-grep/napi-win32-ia32-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "ia32"
  ],
  "main": "ast-grep-napi.win32-ia32-msvc.node",
  "files": [
    "ast-grep-napi.win32-ia32-msvc.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/npm/win32-x64-msvc/README.md
================================================
# `@ast-grep/napi-win32-x64-msvc`

This is the **x86_64-pc-windows-msvc** binary for `@ast-grep/napi`



================================================
FILE: crates/napi/npm/win32-x64-msvc/package.json
================================================
{
  "name": "@ast-grep/napi-win32-x64-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ],
  "main": "ast-grep-napi.win32-x64-msvc.node",
  "files": [
    "ast-grep-napi.win32-x64-msvc.node"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: crates/napi/scripts/constants.ts
================================================
import { Lang } from '..'

export const languagesCrateNames: Record<Lang, string> = {
  [Lang.JavaScript]: 'tree-sitter-javascript',
  [Lang.TypeScript]: 'tree-sitter-typescript',
  [Lang.Tsx]: 'tree-sitter-typescript',
  [Lang.Html]: 'tree-sitter-html',
  [Lang.Css]: 'tree-sitter-css',
}

export const languagesNodeTypesUrls = {
  [Lang.JavaScript]:
    'https://raw.githubusercontent.com/tree-sitter/tree-sitter-javascript/refs/tags/{{TAG}}/src/node-types.json',
  [Lang.TypeScript]:
    'https://raw.githubusercontent.com/tree-sitter/tree-sitter-typescript/refs/tags/{{TAG}}/typescript/src/node-types.json',
  [Lang.Tsx]:
    'https://raw.githubusercontent.com/tree-sitter/tree-sitter-typescript/refs/tags/{{TAG}}/tsx/src/node-types.json',
  [Lang.Html]: 'https://raw.githubusercontent.com/tree-sitter/tree-sitter-html/refs/tags/{{TAG}}/src/node-types.json',
  [Lang.Css]: 'https://raw.githubusercontent.com/tree-sitter/tree-sitter-css/refs/tags/{{TAG}}/src/node-types.json',
}



================================================
FILE: crates/napi/scripts/generateTypes.ts
================================================
import { readFile, stat, writeFile } from 'node:fs/promises'
import path from 'node:path'
// gen type cannot be imported on CI due to un-generated napi binding
import toml from 'smol-toml'
import type { Lang } from '../index'
import type { NodeType } from '../types/staticTypes'
import { languagesCrateNames, languagesNodeTypesUrls } from './constants'

const rootDir = path.resolve(__dirname, '..')
const langDir = path.join(rootDir, 'lang')

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await stat(filePath)
    return true
  } catch (_e) { // oxlint-disable-line eslint/no-unused-vars
    return false
  }
}

function filterOutUnNamedNode(node: NodeType): NodeType | null {
  if (!node.named) {
    return null
  }
  if (node.fields) {
    for (const field of Object.keys(node.fields)) {
      node.fields[field].types = node.fields[field].types.filter(n => n.named)
    }
  }
  if (node.children) {
    node.children.types = node.children.types.filter(n => n.named)
  }
  if (node.subtypes) {
    node.subtypes = node.subtypes.filter(n => n.named)
  }
  return node
}

function processNodeTypes(nodeTypes: NodeType[]): Record<string, NodeType> {
  const filteredNodeTypes = nodeTypes
    .map(filterOutUnNamedNode)
    .filter(node => !!node)
  const nodeTypeMap = Object.fromEntries(
    filteredNodeTypes.map(node => [node.type, node]),
  )
  return nodeTypeMap
}

async function generateLangNodeTypes() {
  const testOnly = process.argv.slice(2)[0]
  const languageCargoToml = await readFile(
    path.resolve(rootDir, '../language/Cargo.toml'),
    'utf8',
  )

  const parsedCargoToml = toml.parse(languageCargoToml) as {
    dependencies: Record<string, { version: string }>
  }

  let langs = Object.entries(languagesNodeTypesUrls) as [Lang, string][]
  // if we are running in test mode, we only want to generate types for TypeScript
  // and only if the file does not exist
  if (testOnly) {
    const existing = await fileExists(path.join(langDir, 'TypeScript.d.ts'))
    if (existing) {
      return
    }
    langs = langs.filter(([lang]) => lang === 'TypeScript')
  }

  for (const [lang, urlTemplate] of langs) {
    try {
      const treeSitterCrateName = languagesCrateNames[lang]
      const cargoVersion = parsedCargoToml.dependencies[treeSitterCrateName].version
      const tag = `v${cargoVersion}`
      const url = urlTemplate.replace('{{TAG}}', tag)
      const nodeTypesResponse = await fetch(url)
      const nodeTypes = (await nodeTypesResponse.json()) as NodeType[]
      const nodeTypeMap = processNodeTypes(nodeTypes)

      const fileContent = `// Auto-generated from tree-sitter ${lang} ${tag}`
        + '\n'
        + `type ${lang}Types = ${JSON.stringify(nodeTypeMap, null, 2)};`
        + '\n'
        + `export default ${lang}Types;`
      await writeFile(path.join(langDir, `${lang}.d.ts`), fileContent)
    } catch (e) {
      console.error(`Error while generating node types for ${lang}`)
      throw e
    }
  }
}

generateLangNodeTypes().catch(error => {
  console.error('Error:', error)
  process.exit(1)
})



================================================
FILE: crates/napi/src/doc.rs
================================================
use crate::napi_lang::NapiLang;

use ast_grep_config::{DeserializeEnv, RuleCore, SerializableRuleCore};
use ast_grep_core::source::{Content, Doc, Edit};
use ast_grep_core::tree_sitter::{ContentExt, LanguageExt, TSParseError};
use napi::anyhow::Error;
use napi::bindgen_prelude::Result as NapiResult;
use napi_derive::napi;
use tree_sitter::{InputEdit, Node, Parser, Point, Tree};

use std::borrow::Cow;
use std::ops::Range;

/// Rule configuration similar to YAML
/// See https://ast-grep.github.io/reference/yaml.html
#[napi(object)]
pub struct NapiConfig {
  /// The rule object, see https://ast-grep.github.io/reference/rule.html
  pub rule: serde_json::Value,
  /// See https://ast-grep.github.io/guide/rule-config.html#constraints
  pub constraints: Option<serde_json::Value>,
  /// Available languages: html, css, js, jsx, ts, tsx
  pub language: Option<String>,
  /// transform is NOT useful in JavaScript. You can use JS code to directly transform the result.
  /// https://ast-grep.github.io/reference/yaml.html#transform
  pub transform: Option<serde_json::Value>,
  /// https://ast-grep.github.io/guide/rule-config/utility-rule.html
  pub utils: Option<serde_json::Value>,
}

impl NapiConfig {
  pub fn parse_with(self, lang: NapiLang) -> NapiResult<RuleCore> {
    let rule = SerializableRuleCore {
      rule: serde_json::from_value(self.rule)?,
      constraints: self.constraints.map(serde_json::from_value).transpose()?,
      transform: self.transform.map(serde_json::from_value).transpose()?,
      utils: self.utils.map(serde_json::from_value).transpose()?,
      fix: None,
    };
    let env = DeserializeEnv::new(lang);
    rule.get_matcher(env).map_err(|e| {
      let error = Error::from(e)
        .chain()
        .map(ToString::to_string)
        .collect::<Vec<_>>();
      napi::Error::new(napi::Status::InvalidArg, error.join("\n |->"))
    })
  }
}

#[derive(Clone)]
pub struct Wrapper {
  inner: Vec<u16>,
}

impl Content for Wrapper {
  type Underlying = u16;
  fn get_range(&self, range: Range<usize>) -> &[Self::Underlying] {
    // the range is in byte offset, but our underlying is u16
    let start = range.start / 2;
    let end = range.end / 2;
    &self.inner.as_slice()[start..end]
  }
  fn decode_str(src: &str) -> Cow<'_, [Self::Underlying]> {
    let v: Vec<_> = src.encode_utf16().collect();
    Cow::Owned(v)
  }

  fn encode_bytes(bytes: &[Self::Underlying]) -> Cow<'_, str> {
    let s = String::from_utf16_lossy(bytes);
    Cow::Owned(s)
  }
  fn get_char_column(&self, column: usize, _offset: usize) -> usize {
    // utf-16 is 2 bytes per character, this is O(1) operation!
    column / 2
  }
}

impl ContentExt for Wrapper {
  fn accept_edit(&mut self, edit: &Edit<Self>) -> InputEdit {
    let start_byte = edit.position;
    let old_end_byte = edit.position + edit.deleted_length;
    let new_end_byte = edit.position + edit.inserted_text.len() * 2;
    let input = &mut self.inner;
    let start_position = pos_for_byte_offset(input, start_byte);
    let old_end_position = pos_for_byte_offset(input, old_end_byte);
    input.splice(start_byte / 2..old_end_byte / 2, edit.inserted_text.clone());
    let new_end_position = pos_for_byte_offset(input, new_end_byte);
    InputEdit {
      start_byte,
      old_end_byte,
      new_end_byte,
      start_position,
      old_end_position,
      new_end_position,
    }
  }
}

fn pos_for_byte_offset(input: &[u16], byte_offset: usize) -> Point {
  let offset = byte_offset / 2;
  debug_assert!(offset <= input.len());
  let (mut row, mut col) = (0, 0);
  for c in char::decode_utf16(input.iter().copied()).take(offset) {
    if let Ok('\n') = c {
      row += 1;
      col = 0;
    } else {
      col += 1;
    }
  }
  Point::new(row, col)
}

#[derive(Clone)]
pub struct JsDoc {
  lang: NapiLang,
  source: Wrapper,
  tree: tree_sitter::Tree,
}

fn parse(
  source: &Wrapper,
  lang: &NapiLang,
  old_tree: Option<&Tree>,
) -> std::result::Result<Tree, TSParseError> {
  let mut parser = Parser::new();
  let ts_lang = lang.get_ts_language();
  parser.set_language(&ts_lang)?;
  if let Some(tree) = parser.parse_utf16_le(source.inner.as_slice(), old_tree) {
    Ok(tree)
  } else {
    Err(TSParseError::TreeUnavailable)
  }
}

impl JsDoc {
  pub fn try_new(src: String, lang: NapiLang) -> napi::anyhow::Result<Self> {
    let source = Wrapper {
      inner: src.encode_utf16().collect(),
    };
    let tree = parse(&source, &lang, None)?;
    Ok(Self { source, lang, tree })
  }
}

impl Doc for JsDoc {
  type Lang = NapiLang;
  type Source = Wrapper;
  type Node<'r> = Node<'r>;
  fn get_lang(&self) -> &Self::Lang {
    &self.lang
  }
  fn get_source(&self) -> &Self::Source {
    &self.source
  }
  fn do_edit(&mut self, edit: &Edit<Self::Source>) -> Result<(), String> {
    let source = &mut self.source;
    let input_edit = source.accept_edit(edit);
    self.tree.edit(&input_edit);
    self.tree = parse(source, &self.lang, Some(&self.tree)).map_err(|e| e.to_string())?;
    Ok(())
  }
  fn root_node(&self) -> Node<'_> {
    self.tree.root_node()
  }
  fn get_node_text<'a>(&'a self, node: &Node) -> Cow<'a, str> {
    let slice = self.source.inner.as_slice();
    let start = node.start_byte() / 2;
    let end = node.end_byte() / 2;
    String::from_utf16_lossy(&slice[start..end]).into()
  }
}

#[cfg(test)]
mod test {
  use super::*;
  use ast_grep_core::AstGrep;
  use ast_grep_language::SupportLang;
  fn make_doc(src: &str) -> JsDoc {
    JsDoc::try_new(src.to_string(), SupportLang::JavaScript.into()).expect("should work")
  }
  #[test]
  fn test_js_doc() {
    let doc = make_doc("console.log(123)");
    let grep = AstGrep::doc(doc);
    assert_eq!(grep.root().text(), "console.log(123)");
    let node = grep.root().find("console");
    assert!(node.is_some());
  }

  #[test]
  fn test_js_doc_single_node_replace() {
    let doc = make_doc("console.log(1 + 2 + 3)");
    let mut grep = AstGrep::doc(doc);
    let edit = grep
      .root()
      .replace("console.log($SINGLE)", "log($SINGLE)")
      .expect("should exist");
    grep.edit(edit).expect("should work");
    assert_eq!(grep.root().text(), "log(1 + 2 + 3)");
  }

  #[test]
  fn test_js_doc_multiple_node_replace() {
    let doc = make_doc("console.log(1 + 2 + 3)");
    let mut grep = AstGrep::doc(doc);
    let edit = grep
      .root()
      .replace("console.log($$$MULTI)", "log($$$MULTI)")
      .expect("should exist");
    grep.edit(edit).expect("should work");
    assert_eq!(grep.root().text(), "log(1 + 2 + 3)");
  }
}



================================================
FILE: crates/napi/src/find_files.rs
================================================
use ast_grep_config::RuleCore;
use ast_grep_core::pinned::{NodeData, PinnedNodeData};
use ast_grep_core::{AstGrep, NodeMatch};
use ignore::{WalkBuilder, WalkParallel, WalkState};
use napi::anyhow::{anyhow, Context, Result as Ret};
use napi::bindgen_prelude::*;
use napi::threadsafe_function::{ThreadsafeFunction, ThreadsafeFunctionCallMode};
use napi::Task;
use napi_derive::napi;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU32, Ordering};

use crate::doc::{JsDoc, NapiConfig};
use crate::napi_lang::{build_files, LangOption, NapiLang};
use crate::sg_node::{SgNode, SgRoot};

pub struct ParseAsync {
  pub src: String,
  pub lang: NapiLang,
}

impl Task for ParseAsync {
  type Output = SgRoot;
  type JsValue = SgRoot;

  fn compute(&mut self) -> Result<Self::Output> {
    let src = std::mem::take(&mut self.src);
    let doc = JsDoc::try_new(src, self.lang)?;
    Ok(SgRoot(AstGrep::doc(doc), "anonymous".into()))
  }
  fn resolve(&mut self, _env: Env, output: Self::Output) -> Result<Self::JsValue> {
    Ok(output)
  }
}

type Entry = std::result::Result<ignore::DirEntry, ignore::Error>;

pub struct IterateFiles<D> {
  walk: WalkParallel,
  lang_option: LangOption,
  tsfn: D,
  producer: fn(&D, Entry, &LangOption) -> Ret<bool>,
}

impl<T: 'static + Send + Sync> Task for IterateFiles<T> {
  type Output = u32;
  type JsValue = u32;

  fn compute(&mut self) -> Result<Self::Output> {
    let tsfn = &self.tsfn;
    let file_count = AtomicU32::new(0);
    let producer = self.producer;
    let walker = std::mem::replace(&mut self.walk, WalkBuilder::new(".").build_parallel());
    walker.run(|| {
      let file_count = &file_count;
      let lang_option = &self.lang_option;
      Box::new(move |entry| match producer(tsfn, entry, lang_option) {
        Ok(succeed) => {
          if succeed {
            // file is sent to JS thread, increment file count
            file_count.fetch_add(1, Ordering::AcqRel);
          }
          WalkState::Continue
        }
        Err(_) => WalkState::Skip,
      })
    });
    Ok(file_count.load(Ordering::Acquire))
  }
  fn resolve(&mut self, _env: Env, output: Self::Output) -> Result<Self::JsValue> {
    Ok(output)
  }
}

// See https://github.com/ast-grep/ast-grep/issues/206
// NodeJS has a 1000 file limitation on sync iteration count.
// https://github.com/nodejs/node/blob/8ba54e50496a6a5c21d93133df60a9f7cb6c46ce/src/node_api.cc#L336
// const THREAD_FUNC_QUEUE_SIZE: usize = 1000;

type ParseFiles = IterateFiles<ThreadsafeFunction<SgRoot, ()>>;

#[napi(object)]
pub struct FileOption {
  pub paths: Vec<String>,
  pub language_globs: HashMap<String, Vec<String>>,
}

#[napi]
pub fn parse_files(
  paths: Either<Vec<String>, FileOption>,
  callback: Function<SgRoot, ()>,
) -> Result<AsyncTask<ParseFiles>> {
  let tsfn = callback
    .build_threadsafe_function()
    .callee_handled()
    .build()?;
  let (paths, globs) = match paths {
    Either::A(v) => (v, HashMap::new()),
    Either::B(FileOption {
      paths,
      language_globs,
    }) => (paths, NapiLang::lang_globs(language_globs)),
  };
  let walk = build_files(paths, &globs)?;
  Ok(AsyncTask::new(ParseFiles {
    walk,
    tsfn,
    lang_option: LangOption::infer(&globs),
    producer: call_sg_root,
  }))
}

// returns if the entry is a file and sent to JavaScript queue
fn call_sg_root(
  tsfn: &ThreadsafeFunction<SgRoot, ()>,
  entry: std::result::Result<ignore::DirEntry, ignore::Error>,
  lang_option: &LangOption,
) -> Ret<bool> {
  let entry = entry?;
  if !entry
    .file_type()
    .context("could not use stdin as file")?
    .is_file()
  {
    return Ok(false);
  }
  let (root, path) = get_root(entry, lang_option)?;
  let sg = SgRoot(root, path);
  tsfn.call(Ok(sg), ThreadsafeFunctionCallMode::Blocking);
  Ok(true)
}

fn get_root(entry: ignore::DirEntry, lang_option: &LangOption) -> Ret<(AstGrep<JsDoc>, String)> {
  let path = entry.into_path();
  let file_content = std::fs::read_to_string(&path)?;
  let lang = lang_option
    .get_lang(&path)
    .context(anyhow!("file not recognized"))?;
  let doc = JsDoc::try_new(file_content, lang)?;
  Ok((AstGrep::doc(doc), path.to_string_lossy().into()))
}

pub type FindInFiles = IterateFiles<(ThreadsafeFunction<PinnedNodes, (), Vec<SgNode>>, RuleCore)>;

pub struct PinnedNodes(
  PinnedNodeData<JsDoc, Vec<NodeMatch<'static, JsDoc>>>,
  String,
);
unsafe impl Send for PinnedNodes {}
unsafe impl Sync for PinnedNodes {}

#[napi(object)]
pub struct FindConfig {
  /// specify the file paths to recursively find files
  pub paths: Vec<String>,
  /// a Rule object to find what nodes will match
  pub matcher: NapiConfig,
  /// An list of pattern globs to treat of certain files in the specified language.
  /// eg. ['*.vue', '*.svelte'] for html.findFiles, or ['*.ts'] for tsx.findFiles.
  /// It is slightly different from https://ast-grep.github.io/reference/sgconfig.html#languageglobs
  pub language_globs: Option<Vec<String>>,
}

pub fn find_in_files_impl(
  lang: NapiLang,
  config: FindConfig,
  callback: Function<Vec<SgNode>, ()>,
) -> Result<AsyncTask<FindInFiles>> {
  let tsfn = callback
    .build_threadsafe_function()
    .callee_handled()
    .build_callback(|ctx| from_pinned_data(ctx.value, ctx.env))?;
  let FindConfig {
    paths,
    matcher,
    language_globs,
  } = config;
  let rule = matcher.parse_with(lang)?;
  let walk = lang.find_files(paths, language_globs)?;
  Ok(AsyncTask::new(FindInFiles {
    walk,
    tsfn: (tsfn, rule),
    lang_option: LangOption::Specified(lang),
    producer: call_sg_node,
  }))
}

// TODO: optimize
fn from_pinned_data(pinned: PinnedNodes, env: napi::Env) -> Result<Vec<SgNode>> {
  let (root, nodes) = pinned.0.into_raw();
  let sg_root = SgRoot(root, pinned.1);
  let reference = SgRoot::into_reference(sg_root, env)?;
  let mut v = vec![];
  for mut node in nodes {
    let root_ref = reference.clone(env)?;
    let sg_node = SgNode {
      inner: root_ref.share_with(env, |root| {
        let r = &root.0;
        node.visit_nodes(|n| unsafe { r.readopt(n) });
        Ok(node)
      })?,
    };
    v.push(sg_node);
  }
  Ok(v)
}

fn call_sg_node(
  (tsfn, rule): &(ThreadsafeFunction<PinnedNodes, (), Vec<SgNode>>, RuleCore),
  entry: std::result::Result<ignore::DirEntry, ignore::Error>,
  lang_option: &LangOption,
) -> Ret<bool> {
  let entry = entry?;
  if !entry
    .file_type()
    .context("could not use stdin as file")?
    .is_file()
  {
    return Ok(false);
  }
  let (root, path) = get_root(entry, lang_option)?;
  let mut pinned = PinnedNodeData::new(root, |r| r.root().find_all(rule).collect());
  let hits: &Vec<_> = pinned.get_data();
  if hits.is_empty() {
    return Ok(false);
  }
  let pinned = PinnedNodes(pinned, path);
  tsfn.call(Ok(pinned), ThreadsafeFunctionCallMode::Blocking);
  Ok(true)
}



================================================
FILE: crates/napi/src/lib.rs
================================================
#![cfg(not(feature = "napi-noop-in-unit-test"))]

mod doc;
mod find_files;
mod napi_lang;
mod sg_node;

use ast_grep_core::{AstGrep, Language};
use ast_grep_language::SupportLang;
use napi::bindgen_prelude::*;
use napi_derive::napi;
use napi_lang::register_dynamic_language as register_dynamic_language_impl;

use doc::{JsDoc, NapiConfig};
use find_files::{find_in_files_impl, FindConfig, FindInFiles, ParseAsync};
use napi_lang::NapiLang;
use sg_node::{SgNode, SgRoot};

pub use find_files::parse_files;

macro_rules! impl_lang_mod {
  ($name: ident, $lang: ident) => {
    #[napi]
    pub mod $name {
      use super::*;

      #[napi]
      pub fn parse(src: String) -> SgRoot {
        parse_with_lang(SupportLang::$lang.to_string(), src).expect("parse failed")
      }

      #[napi]
      pub fn parse_async(src: String) -> Result<AsyncTask<ParseAsync>> {
        parse_async_with_lang(SupportLang::$lang.to_string(), src)
      }
      #[napi]
      pub fn kind(kind_name: String) -> Result<u16> {
        kind_with_lang(SupportLang::$lang.to_string(), kind_name)
      }
      #[napi]
      pub fn pattern(pattern: String) -> NapiConfig {
        pattern_with_lang(SupportLang::$lang.to_string(), pattern)
      }
      #[napi]
      pub fn find_in_files(
        config: FindConfig,
        callback: Function<Vec<SgNode>, ()>,
      ) -> Result<AsyncTask<FindInFiles>> {
        find_in_files_impl(SupportLang::$lang.into(), config, callback)
      }
    }
  };
}

// for name conflict in mod
use kind as kind_with_lang;
use parse as parse_with_lang;
use parse_async as parse_async_with_lang;
use pattern as pattern_with_lang;
impl_lang_mod!(html, Html);
impl_lang_mod!(js, JavaScript);
impl_lang_mod!(jsx, JavaScript);
impl_lang_mod!(ts, TypeScript);
impl_lang_mod!(tsx, Tsx);
impl_lang_mod!(css, Css);

/// Parse a string to an ast-grep instance
#[napi]
pub fn parse(lang: String, src: String) -> Result<SgRoot> {
  let doc = JsDoc::try_new(src, lang.parse()?)?;
  Ok(SgRoot(AstGrep::doc(doc), "anonymous".into()))
}

/// Parse a string to an ast-grep instance asynchronously in threads.
/// It utilize multiple CPU cores when **concurrent processing sources**.
/// However, spawning excessive many threads may backfire.
/// Please refer to libuv doc, nodejs' underlying runtime
/// for its default behavior and performance tuning tricks.
#[napi]
pub fn parse_async(lang: String, src: String) -> Result<AsyncTask<ParseAsync>> {
  let lang = lang.parse()?;
  Ok(AsyncTask::new(ParseAsync { src, lang }))
}

/// Get the `kind` number from its string name.
#[napi]
pub fn kind(lang: String, kind_name: String) -> Result<u16> {
  let lang: NapiLang = lang.parse()?;
  let kind = lang.kind_to_id(&kind_name);
  Ok(kind)
}

/// Compile a string to ast-grep Pattern.
#[napi]
pub fn pattern(lang: String, pattern: String) -> NapiConfig {
  NapiConfig {
    rule: serde_json::json!({
      "pattern": pattern,
    }),
    constraints: None,
    language: Some(lang),
    utils: None,
    transform: None,
  }
}

/// Discover and parse multiple files in Rust.
/// `lang` specifies the language.
/// `config` specifies the file path and matcher.
/// `callback` will receive matching nodes found in a file.
#[napi]
pub fn find_in_files(
  lang: String,
  config: FindConfig,
  callback: Function<Vec<SgNode>, ()>,
) -> Result<AsyncTask<FindInFiles>> {
  let lang: NapiLang = lang.parse()?;
  find_in_files_impl(lang, config, callback)
}

/// Register a dynamic language to ast-grep.
/// `langs` is a Map of language name to its CustomLanguage registration.
#[napi]
pub fn register_dynamic_language(langs: serde_json::Value) -> Result<()> {
  let langs = serde_json::from_value(langs)?;
  register_dynamic_language_impl(langs)
}



================================================
FILE: crates/napi/src/napi_lang.rs
================================================
use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ast_grep_core::tree_sitter::{LanguageExt, TSLanguage};
use ast_grep_dynamic::{CustomLang, DynamicLang};
use ast_grep_language::{Language, SupportLang};
use ignore::types::{Types, TypesBuilder};
use ignore::{WalkBuilder, WalkParallel};
use napi::anyhow::anyhow;
use napi::anyhow::Error;
use napi::bindgen_prelude::Result;
use napi_derive::napi;

use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Debug, Display, Formatter};
use std::path::Path;
use std::str::FromStr;

#[napi(string_enum)]
#[derive(PartialEq, Eq, Hash, Debug)]
pub enum Lang {
  Html,
  JavaScript,
  Tsx,
  Css,
  TypeScript,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub enum NapiLang {
  // inlined support lang expando char
  Builtin(SupportLang),
  Custom(DynamicLang),
}

impl NapiLang {
  fn all_langs() -> Vec<Self> {
    use SupportLang as S;
    let builtin = [S::Html, S::JavaScript, S::Tsx, S::Css, S::TypeScript]
      .iter()
      .copied()
      .map(Self::Builtin);
    let customs = DynamicLang::all_langs().into_iter().map(Self::Custom);
    builtin.chain(customs).collect()
  }

  fn file_types(&self) -> Types {
    match self {
      Builtin(b) => b.file_types(),
      Custom(c) => c.file_types(),
    }
  }

  pub fn find_files(
    &self,
    paths: Vec<String>,
    language_globs: Option<Vec<String>>,
  ) -> Result<WalkParallel> {
    find_files_with_lang(self, paths, language_globs)
  }
  pub fn lang_globs(map: HashMap<String, Vec<String>>) -> LanguageGlobs {
    let mut ret = HashMap::new();
    for (name, patterns) in map {
      if let Ok(lang) = NapiLang::from_str(&name) {
        ret.insert(lang, patterns);
      }
    }
    ret
  }
}

impl Display for NapiLang {
  fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
    match self {
      Builtin(b) => write!(f, "{b}"),
      Custom(c) => write!(f, "{}", c.name()),
    }
  }
}

impl Debug for NapiLang {
  fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
    match self {
      Builtin(b) => write!(f, "{b:?}"),
      Custom(c) => write!(f, "{:?}", c.name()),
    }
  }
}

impl FromStr for NapiLang {
  type Err = Error;
  fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
    use SupportLang as S;
    // only support frontend languages to reduce binary size
    if let Ok(b) = S::from_str(s) {
      if matches!(b, S::Css | S::Html | S::JavaScript | S::Tsx | S::TypeScript) {
        return Ok(NapiLang::Builtin(b));
      }
    }

    if let Ok(c) = DynamicLang::from_str(s) {
      Ok(NapiLang::Custom(c))
    } else {
      Err(anyhow!(format!("{s} is not supported in napi")))
    }
  }
}

impl From<SupportLang> for NapiLang {
  fn from(val: SupportLang) -> Self {
    NapiLang::Builtin(val)
  }
}

use NapiLang::*;

use crate::doc::JsDoc;
impl Language for NapiLang {
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    match self {
      Builtin(b) => b.pre_process_pattern(query),
      Custom(c) => c.pre_process_pattern(query),
    }
  }

  #[inline]
  fn meta_var_char(&self) -> char {
    match self {
      Builtin(b) => b.meta_var_char(),
      Custom(c) => c.meta_var_char(),
    }
  }

  #[inline]
  fn expando_char(&self) -> char {
    match self {
      Builtin(b) => b.expando_char(),
      Custom(c) => c.expando_char(),
    }
  }

  fn kind_to_id(&self, kind: &str) -> u16 {
    match self {
      Builtin(b) => b.kind_to_id(kind),
      Custom(c) => c.kind_to_id(kind),
    }
  }
  fn field_to_id(&self, field: &str) -> Option<u16> {
    match self {
      Builtin(b) => b.field_to_id(field),
      Custom(c) => c.field_to_id(field),
    }
  }
  fn build_pattern(&self, builder: &PatternBuilder) -> std::result::Result<Pattern, PatternError> {
    builder.build(|src| JsDoc::try_new(src.to_string(), *self).map_err(|e| e.to_string()))
  }
}

impl LanguageExt for NapiLang {
  fn get_ts_language(&self) -> TSLanguage {
    match self {
      Builtin(b) => b.get_ts_language(),
      Custom(c) => c.get_ts_language(),
    }
  }
}

pub fn register_dynamic_language(langs: HashMap<String, CustomLang>) -> Result<()> {
  let base = std::env::current_dir()?;
  CustomLang::register(&base, langs).expect("TODO");
  Ok(())
}

pub type LanguageGlobs = HashMap<NapiLang, Vec<String>>;

pub enum LangOption {
  /// Used when language is inferred from file path
  /// e.g. in parse_files
  Inferred(Vec<(NapiLang, Types)>),
  /// Used when language is specified
  /// e.g. in frontend_lang.find_in_files
  Specified(NapiLang),
}

impl LangOption {
  pub fn get_lang(&self, path: &Path) -> Option<NapiLang> {
    use LangOption::*;
    match self {
      Specified(lang) => Some(*lang),
      Inferred(pairs) => pairs
        .iter()
        .find_map(|(lang, types)| types.matched(path, false).is_whitelist().then_some(*lang)),
    }
  }
  pub fn infer(language_globs: &LanguageGlobs) -> Self {
    let mut types = vec![];
    let empty = vec![];
    for lang in NapiLang::all_langs() {
      let mut builder = TypesBuilder::new();
      let tpe = lang.to_string();
      let file_types = lang.file_types();
      add_types(&mut builder, &file_types);
      for pattern in language_globs.get(&lang).unwrap_or(&empty) {
        builder.add(&tpe, pattern).expect("should build");
      }
      builder.select(&tpe);
      types.push((lang, builder.build().unwrap()));
    }
    Self::Inferred(types)
  }
}

pub fn build_files(paths: Vec<String>, language_globs: &LanguageGlobs) -> Result<WalkParallel> {
  if paths.is_empty() {
    return Err(anyhow!("paths cannot be empty.").into());
  }
  let mut types = TypesBuilder::new();
  let empty = vec![];
  for lang in NapiLang::all_langs() {
    let type_name = lang.to_string();
    let custom = language_globs.get(&lang).unwrap_or(&empty);
    let default_types = lang.file_types();
    select_custom(&mut types, &type_name, &default_types, custom);
  }
  let types = types.build().unwrap();
  let mut paths = paths.into_iter();
  let mut builder = WalkBuilder::new(paths.next().unwrap());
  for path in paths {
    builder.add(path);
  }
  let walk = builder.types(types).build_parallel();
  Ok(walk)
}

fn add_types(builder: &mut TypesBuilder, types: &Types) {
  for def in types.definitions() {
    let name = def.name();
    for glob in def.globs() {
      builder.add(name, glob).expect(name);
    }
  }
}

fn select_custom<'b>(
  builder: &'b mut TypesBuilder,
  file_type: &str,
  default_types: &Types,
  custom_suffix_list: &[String],
) -> &'b mut TypesBuilder {
  add_types(builder, default_types);
  for suffix in custom_suffix_list {
    builder
      .add(file_type, suffix)
      .expect("file pattern must compile");
  }
  builder.select(file_type)
}

fn find_files_with_lang(
  lang: &NapiLang,
  paths: Vec<String>,
  language_globs: Option<Vec<String>>,
) -> Result<WalkParallel> {
  if paths.is_empty() {
    return Err(anyhow!("paths cannot be empty.").into());
  }

  let mut types = TypesBuilder::new();
  let type_name = lang.to_string();
  let custom_file_type = language_globs.unwrap_or_default();
  let default_types = lang.file_types();
  let types = select_custom(&mut types, &type_name, &default_types, &custom_file_type)
    .build()
    .unwrap();
  let mut paths = paths.into_iter();
  let mut builder = WalkBuilder::new(paths.next().unwrap());
  for path in paths {
    builder.add(path);
  }
  let walk = builder.types(types).build_parallel();
  Ok(walk)
}

#[cfg(test)]
mod test {
  use super::*;

  fn lang_globs() -> LanguageGlobs {
    let mut lang = HashMap::new();
    lang.insert("html".into(), vec!["*.vue".into()]);
    NapiLang::lang_globs(lang)
  }

  #[test]
  fn test_lang_globs() {
    let globs = lang_globs();
    assert!(globs.contains_key(&SupportLang::Html.into()));
    assert!(!globs.contains_key(&SupportLang::Tsx.into()));
    assert_eq!(globs[&NapiLang::Builtin(SupportLang::Html)], vec!["*.vue"]);
  }

  #[test]
  fn test_lang_option() {
    let globs = lang_globs();
    let option = LangOption::infer(&globs);
    let lang = option.get_lang(Path::new("test.vue"));
    assert_eq!(lang, Some(SupportLang::Html.into()));
    let lang = option.get_lang(Path::new("test.html"));
    assert_eq!(lang, Some(SupportLang::Html.into()));
    let lang = option.get_lang(Path::new("test.js"));
    assert_eq!(lang, Some(SupportLang::JavaScript.into()));
    let lang = option.get_lang(Path::new("test.xss"));
    assert_eq!(lang, None);
  }

  #[test]
  fn test_from_str() {
    let lang = NapiLang::from_str("html");
    assert_eq!(lang.unwrap(), SupportLang::Html.into());
    let lang = NapiLang::from_str("Html");
    assert_eq!(lang.unwrap(), SupportLang::Html.into());
    let lang = NapiLang::from_str("htML");
    assert_eq!(lang.unwrap(), SupportLang::Html.into());
    let lang = NapiLang::from_str("ocaml");
    assert!(lang.is_err());
  }
}



================================================
FILE: crates/napi/src/sg_node.rs
================================================
use ast_grep_core::{matcher::KindMatcher, AstGrep, NodeMatch, Pattern, Position};
use napi::bindgen_prelude::*;
use napi_derive::napi;

use super::NapiConfig;
use crate::doc::{JsDoc, Wrapper};
use ast_grep_core::source::Content;

#[napi(object)]
pub struct Edit {
  /// The start position of the edit
  pub start_pos: u32,
  /// The end position of the edit
  pub end_pos: u32,
  /// The text to be inserted
  pub inserted_text: String,
}

#[napi(object)]
pub struct Pos {
  /// line number starting from 0
  pub line: u32,
  /// column number starting from 0
  pub column: u32,
  /// byte offset of the position
  pub index: u32,
}

#[napi(object)]
pub struct Range {
  /// starting position of the range
  pub start: Pos,
  /// ending position of the range
  pub end: Pos,
}

#[napi]
pub struct SgNode {
  pub(super) inner: SharedReference<SgRoot, NodeMatch<'static, JsDoc>>,
}

impl SgNode {
  fn to_pos(&self, pos: Position, offset: usize) -> Pos {
    Pos {
      line: pos.line() as u32,
      column: pos.column(self.inner.get_node()) as u32,
      index: offset as u32 / 2,
    }
  }
}

#[napi]
impl SgNode {
  #[napi]
  pub fn range(&self) -> Range {
    let byte_range = self.inner.range();
    let start_pos = self.inner.start_pos();
    let end_pos = self.inner.end_pos();
    Range {
      start: self.to_pos(start_pos, byte_range.start),
      end: self.to_pos(end_pos, byte_range.end),
    }
  }

  #[napi]
  pub fn is_leaf(&self) -> bool {
    self.inner.is_leaf()
  }
  #[napi]
  pub fn is_named(&self) -> bool {
    self.inner.is_named()
  }
  #[napi]
  pub fn is_named_leaf(&self) -> bool {
    self.inner.is_named_leaf()
  }
  /// Returns the string name of the node kind
  #[napi]
  pub fn kind(&self) -> String {
    self.inner.kind().to_string()
  }
  #[napi(getter)]
  pub fn kind_to_refine(&self) -> String {
    self.inner.kind().to_string()
  }
  /// Check if the node is the same kind as the given `kind` string
  #[napi]
  pub fn is(&self, kind: String) -> bool {
    self.inner.kind() == kind
  }
  #[napi]
  pub fn text(&self) -> String {
    self.inner.text().to_string()
  }
}

#[napi]
impl SgNode {
  #[napi]
  pub fn matches(&self, m: Either3<String, u16, NapiConfig>) -> Result<bool> {
    let lang = *self.inner.lang();
    match m {
      Either3::A(pattern) => Ok(self.inner.matches(Pattern::new(&pattern, lang))),
      Either3::B(kind) => Ok(self.inner.matches(KindMatcher::from_id(kind))),
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        Ok(self.inner.matches(pattern))
      }
    }
  }

  #[napi]
  pub fn inside(&self, m: Either3<String, u16, NapiConfig>) -> Result<bool> {
    let lang = *self.inner.lang();
    match m {
      Either3::A(pattern) => Ok(self.inner.inside(Pattern::new(&pattern, lang))),
      Either3::B(kind) => Ok(self.inner.inside(KindMatcher::from_id(kind))),
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        Ok(self.inner.inside(pattern))
      }
    }
  }

  #[napi]
  pub fn has(&self, m: Either3<String, u16, NapiConfig>) -> Result<bool> {
    let lang = *self.inner.lang();
    match m {
      Either3::A(pattern) => Ok(self.inner.has(Pattern::new(&pattern, lang))),
      Either3::B(kind) => Ok(self.inner.has(KindMatcher::from_id(kind))),
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        Ok(self.inner.has(pattern))
      }
    }
  }

  #[napi]
  pub fn precedes(&self, m: Either3<String, u16, NapiConfig>) -> Result<bool> {
    let lang = *self.inner.lang();
    match m {
      Either3::A(pattern) => Ok(self.inner.precedes(Pattern::new(&pattern, lang))),
      Either3::B(kind) => Ok(self.inner.precedes(KindMatcher::from_id(kind))),
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        Ok(self.inner.precedes(pattern))
      }
    }
  }

  #[napi]
  pub fn follows(&self, m: Either3<String, u16, NapiConfig>) -> bool {
    let lang = *self.inner.lang();
    match m {
      Either3::A(pattern) => self.inner.follows(Pattern::new(&pattern, lang)),
      Either3::B(kind) => self.inner.follows(KindMatcher::from_id(kind)),
      Either3::C(config) => self.inner.follows(config.parse_with(lang).unwrap()),
    }
  }

  #[napi]
  pub fn get_match(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    m: String,
  ) -> Result<Option<SgNode>> {
    let node = self
      .inner
      .get_env()
      .get_match(&m)
      .cloned()
      .map(NodeMatch::from);
    Self::transpose_option(reference, env, node)
  }
  #[napi]
  pub fn get_multiple_matches(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    m: String,
  ) -> Result<Vec<SgNode>> {
    let nodes = self
      .inner
      .get_env()
      .get_multiple_matches(&m)
      .into_iter()
      .map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, nodes)
  }
  #[napi]
  pub fn get_transformed(&self, m: String) -> Option<String> {
    let bytes = self.inner.get_env().get_transformed(&m)?;
    Some(String::from_utf16_lossy(bytes))
  }
}

/// tree traversal API
#[napi]
impl SgNode {
  /// Returns the node's SgRoot
  #[napi]
  pub fn get_root(&self, _: Reference<SgNode>, env: Env) -> Result<Reference<SgRoot>> {
    let root = self.inner.clone_owner(env)?;
    Ok(root)
  }
  #[napi]
  pub fn children(&self, reference: Reference<SgNode>, env: Env) -> Result<Vec<SgNode>> {
    let children = reference.inner.children().map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, children)
  }

  /// Returns the node's id
  #[napi]
  pub fn id(&self) -> Result<u32> {
    Ok(self.inner.node_id() as u32)
  }

  #[napi]
  pub fn find(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    matcher: Either3<String, u16, NapiConfig>,
  ) -> Result<Option<SgNode>> {
    let lang = *reference.inner.lang();
    let node_match = match matcher {
      Either3::A(pattern) => {
        let pattern = Pattern::new(&pattern, lang);
        reference.inner.find(pattern)
      }
      Either3::B(kind) => {
        let pattern = KindMatcher::from_id(kind);
        reference.inner.find(pattern)
      }
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        reference.inner.find(pattern)
      }
    };
    Self::transpose_option(reference, env, node_match)
  }

  fn transpose_option(
    reference: Reference<SgNode>,
    env: Env,
    node: Option<NodeMatch<'static, JsDoc>>,
  ) -> Result<Option<SgNode>> {
    if let Some(node) = node {
      let root_ref = reference.inner.clone_owner(env)?;
      let inner = root_ref.share_with(env, move |_| Ok(node))?;
      Ok(Some(SgNode { inner }))
    } else {
      Ok(None)
    }
  }

  #[napi]
  pub fn find_all(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    matcher: Either3<String, u16, NapiConfig>,
  ) -> Result<Vec<SgNode>> {
    let mut ret = vec![];
    let lang = *reference.inner.lang();
    let all_matches: Vec<_> = match matcher {
      Either3::A(pattern) => {
        let pattern = Pattern::new(&pattern, lang);
        reference.inner.find_all(pattern).collect()
      }
      Either3::B(kind) => {
        let pattern = KindMatcher::from_id(kind);
        reference.inner.find_all(pattern).collect()
      }
      Either3::C(config) => {
        let pattern = config.parse_with(lang)?;
        reference.inner.find_all(pattern).collect()
      }
    };
    for node_match in all_matches {
      let root_ref = reference.inner.clone_owner(env)?;
      let sg_node = SgNode {
        inner: root_ref.share_with(env, move |_| Ok(node_match))?,
      };
      ret.push(sg_node);
    }
    Ok(ret)
  }

  fn from_iter_to_vec(
    reference: &Reference<SgNode>,
    env: Env,
    iter: impl Iterator<Item = NodeMatch<'static, JsDoc>>,
  ) -> Result<Vec<SgNode>> {
    let mut ret = vec![];
    for node in iter {
      let root_ref = reference.inner.clone_owner(env)?;
      let sg_node = SgNode {
        inner: root_ref.share_with(env, move |_| Ok(node))?,
      };
      ret.push(sg_node);
    }
    Ok(ret)
  }

  /// Finds the first child node in the `field`
  #[napi]
  pub fn field(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    name: String,
  ) -> Result<Option<SgNode>> {
    let node = reference.inner.field(&name).map(NodeMatch::from);
    Self::transpose_option(reference, env, node)
  }

  /// Finds all the children nodes in the `field`
  #[napi]
  pub fn field_children(
    &self,
    reference: Reference<SgNode>,
    env: Env,
    name: String,
  ) -> Result<Vec<SgNode>> {
    let children = reference.inner.field_children(&name).map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, children)
  }

  #[napi]
  pub fn parent(&self, reference: Reference<SgNode>, env: Env) -> Result<Option<SgNode>> {
    let node = reference.inner.parent().map(NodeMatch::from);
    Self::transpose_option(reference, env, node)
  }

  #[napi]
  pub fn child(&self, reference: Reference<SgNode>, env: Env, nth: u32) -> Result<Option<SgNode>> {
    let inner = reference.inner.child(nth as usize).map(NodeMatch::from);
    Self::transpose_option(reference, env, inner)
  }

  #[napi]
  pub fn ancestors(&self, reference: Reference<SgNode>, env: Env) -> Result<Vec<SgNode>> {
    let ancestors = reference.inner.ancestors().map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, ancestors)
  }

  #[napi]
  pub fn next(&self, reference: Reference<SgNode>, env: Env) -> Result<Option<SgNode>> {
    let inner = reference.inner.next().map(NodeMatch::from);
    Self::transpose_option(reference, env, inner)
  }

  #[napi]
  pub fn next_all(&self, reference: Reference<SgNode>, env: Env) -> Result<Vec<SgNode>> {
    let inner = reference.inner.next_all().map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, inner)
  }

  #[napi]
  pub fn prev(&self, reference: Reference<SgNode>, env: Env) -> Result<Option<SgNode>> {
    let inner = reference.inner.prev().map(NodeMatch::from);
    Self::transpose_option(reference, env, inner)
  }

  #[napi]
  pub fn prev_all(&self, reference: Reference<SgNode>, env: Env) -> Result<Vec<SgNode>> {
    let inner = reference.inner.prev_all().map(NodeMatch::from);
    Self::from_iter_to_vec(&reference, env, inner)
  }
}

/// Edit API
#[napi]
impl SgNode {
  #[napi]
  pub fn replace(&self, text: String) -> Edit {
    let byte_range = self.inner.range();
    // the text is u16, need to convert to JS str length
    Edit {
      start_pos: (byte_range.start / 2) as u32,
      end_pos: (byte_range.end / 2) as u32,
      inserted_text: text,
    }
  }

  #[napi]
  pub fn commit_edits(&self, mut edits: Vec<Edit>) -> String {
    edits.sort_by_key(|edit| edit.start_pos);
    let mut new_content = Vec::new();
    let text = self.text();
    let old_content = Wrapper::decode_str(&text);
    let offset = self.inner.range().start / 2;
    let mut start = 0;
    for diff in edits {
      let pos = diff.start_pos as usize - offset;
      // skip overlapping edits
      if start > pos {
        continue;
      }
      new_content.extend(&old_content[start..pos]);
      let bytes = Wrapper::decode_str(&diff.inserted_text);
      new_content.extend(&*bytes);
      start = diff.end_pos as usize - offset;
    }
    // add trailing statements
    new_content.extend(&old_content[start..]);
    Wrapper::encode_bytes(&new_content).to_string()
  }
}

/// Represents the parsed tree of code.
#[napi]
pub struct SgRoot(pub(super) AstGrep<JsDoc>, pub(super) String);

#[napi]
impl SgRoot {
  /// Returns the root SgNode of the ast-grep instance.
  #[napi]
  pub fn root(&self, root_ref: Reference<SgRoot>, env: Env) -> Result<SgNode> {
    let inner = root_ref.share_with(env, |root| Ok(root.0.root().into()))?;
    Ok(SgNode { inner })
  }
  /// Returns the path of the file if it is discovered by ast-grep's `findInFiles`.
  /// Returns `"anonymous"` if the instance is created by `lang.parse(source)`.
  #[napi]
  pub fn filename(&self) -> Result<String> {
    Ok(self.1.clone())
  }
}



================================================
FILE: crates/napi/types/api.d.ts
================================================
import type { FileOption, FindConfig, NapiConfig } from './config'
import type { NapiLang } from './lang'
import type { SgNode, SgRoot } from './sgnode'
import type { NamedKinds, TypesMap } from './staticTypes'

export declare function parseFiles<M extends TypesMap>(
  paths: Array<string> | FileOption,
  callback: (err: null | Error, result: SgRoot<M>) => void,
): Promise<number>
/** Parse a string to an ast-grep instance */
export declare function parse<M extends TypesMap>(
  lang: NapiLang,
  src: string,
): SgRoot<M>
/**
 * Parse a string to an ast-grep instance asynchronously in threads.
 * It utilize multiple CPU cores when **concurrent processing sources**.
 * However, spawning excessive many threads may backfire.
 * Please refer to libuv doc, nodejs' underlying runtime
 * for its default behavior and performance tuning tricks.
 */
export declare function parseAsync<M extends TypesMap>(
  lang: NapiLang,
  src: string,
): Promise<SgRoot<M>>
/** Get the `kind` number from its string name. */
export declare function kind<M extends TypesMap>(
  lang: NapiLang,
  kindName: NamedKinds<M>,
): number
/** Compile a string to ast-grep Pattern. */
export declare function pattern<M extends TypesMap>(
  lang: NapiLang,
  pattern: string,
): NapiConfig<M>
/**
 * Discover and parse multiple files in Rust.
 * `lang` specifies the language.
 * `config` specifies the file path and matcher.
 * `callback` will receive matching nodes found in a file.
 */
export declare function findInFiles<M extends TypesMap>(
  lang: NapiLang,
  config: FindConfig<M>,
  callback: (err: null | Error, result: SgNode<M>[]) => void,
): Promise<number>



================================================
FILE: crates/napi/types/config.d.ts
================================================
import type { NapiLang } from './lang'
import type { Rule } from './rule'
import type { TypesMap } from './staticTypes'

/**
 * Rule configuration similar to YAML
 * See https://ast-grep.github.io/reference/yaml.html
 */
export interface NapiConfig<M extends TypesMap = TypesMap> {
  /** The rule object, see https://ast-grep.github.io/reference/rule.html */
  rule: Rule<M>
  /** See https://ast-grep.github.io/guide/rule-config.html#constraints */
  constraints?: Record<string, Rule<M>>
  /** Builtin Language or custom language */
  language?: NapiLang
  /**
   * transform is NOT useful in JavaScript. You can use JS code to directly transform the result.
   * https://ast-grep.github.io/reference/yaml.html#transform
   */
  transform?: unknown
  /** https://ast-grep.github.io/guide/rule-config/utility-rule.html */
  utils?: Record<string, Rule<M>>
}
export interface FileOption {
  paths: Array<string>
  languageGlobs: Record<string, Array<string>>
}
export interface FindConfig<M extends TypesMap = TypesMap> {
  /** specify the file paths to recursively find files */
  paths: Array<string>
  /** a Rule object to find what nodes will match */
  matcher: NapiConfig<M>
  /**
   * An list of pattern globs to treat of certain files in the specified language.
   * eg. ['*.vue', '*.svelte'] for html.findFiles, or ['*.ts'] for tsx.findFiles.
   * It is slightly different from https://ast-grep.github.io/reference/sgconfig.html#languageglobs
   */
  languageGlobs?: Array<string>
}



================================================
FILE: crates/napi/types/deprecated.d.ts
================================================
import type { FindConfig, NapiConfig } from './config'
import type { SgNode, SgRoot } from './sgnode'

/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace html {
  /** @deprecated use `parse(Lang.Html, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.Html, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.Html, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.Html, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.Html, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}
/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace js {
  /** @deprecated use `parse(Lang.JavaScript, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.JavaScript, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.JavaScript, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.JavaScript, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.JavaScript, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}
/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace jsx {
  /** @deprecated use `parse(Lang.JavaScript, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.JavaScript, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.JavaScript, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.JavaScript, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.JavaScript, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}
/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace ts {
  /** @deprecated use `parse(Lang.TypeScript, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.TypeScript, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.TypeScript, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.TypeScript, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.TypeScript, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}
/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace tsx {
  /** @deprecated use `parse(Lang.Tsx, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.Tsx, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.Tsx, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.Tsx, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.Tsx, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}
/**
 * @deprecated language specific objects are deprecated
 * use the equivalent functions like `parse` in @ast-grep/napi
 */
export declare namespace css {
  /** @deprecated use `parse(Lang.Css, src)` instead */
  export function parse(src: string): SgRoot
  /** @deprecated use `parseAsync(Lang.Css, src)` instead */
  export function parseAsync(src: string): Promise<SgRoot>
  /** @deprecated use `kind(Lang.Css, kindName)` instead */
  export function kind(kindName: string): number
  /** @deprecated use `pattern(Lang.Css, p)` instead */
  export function pattern(pattern: string): NapiConfig
  /** @deprecated use `findInFiles(Lang.Css, config, callback)` instead */
  export function findInFiles(
    config: FindConfig,
    callback: (err: null | Error, result: SgNode[]) => void,
  ): Promise<number>
}



================================================
FILE: crates/napi/types/lang.d.ts
================================================
export enum Lang {
  Html = 'Html',
  JavaScript = 'JavaScript',
  Tsx = 'Tsx',
  Css = 'Css',
  TypeScript = 'TypeScript',
}

type CustomLang = string & {}

export type NapiLang = Lang | CustomLang



================================================
FILE: crates/napi/types/registerDynamicLang.d.ts
================================================
/** The JSON object to register dynamic languages */
interface LangRegistration {
  /** the path to the dynamic library */
  libraryPath: string
  /** the file extensions of the language. e.g. mojo */
  extensions: string[]
  /** the dylib symbol to load ts-language, default is `tree_sitter_{name}` */
  languageSymbol?: string
  /** the meta variable leading character, default is $ */
  metaVarChar?: string
  /**
   * An optional char to replace $ in your pattern.
   * See https://ast-grep.github.io/advanced/custom-language.html#register-language-in-sgconfig-yml
   */
  expandoChar?: string
}

/** A map of language names to their registration information */
export interface DynamicLangRegistrations {
  [langName: string]: LangRegistration
}

/**
 * @experimental
 * Register dynamic languages. This function should be called exactly once in the program.
 */
export declare function registerDynamicLanguage(langs: DynamicLangRegistrations): void



================================================
FILE: crates/napi/types/rule.d.ts
================================================
import type { NamedKinds, TypesMap } from './staticTypes'

export type Strictness = 'cst' | 'smart' | 'ast' | 'relaxed' | 'signature'

export interface PatternObject<M extends TypesMap = TypesMap> {
  context: string
  selector?: NamedKinds<M> // only named node types
  strictness?: Strictness
}

export type PatternStyle<M extends TypesMap = TypesMap> =
  | string
  | PatternObject<M>

export interface Relation<M extends TypesMap = TypesMap> extends Rule<M> {
  /**
   * Specify how relational rule will stop relative to the target node.
   */
  stopBy?: 'neighbor' | 'end' | Rule<M>
  /** Specify the tree-sitter field in parent node. Only available in has/inside rule. */
  field?: string
}

export interface NthChildObject<M extends TypesMap = TypesMap> {
  /** The position in nodes' sibling list. It can be a number of An+B string */
  position: string | number
  ofRule?: Rule<M>
  reverse?: boolean
}

/**
 * NthChild can have these types:
 * * number: the position of the node in the sibling list.
 * * string: An + B style string like CSS nth-child selector.
 * * object: An object with `position` and `ofRule` fields.
 */
export type NthChild<M extends TypesMap = TypesMap> =
  | number
  | string
  | NthChildObject<M>

export interface Position {
  /** 0-indexed line number. */
  line: number
  /** 0-indexed column number. */
  column: number
}

export interface Range {
  start: Position
  end: Position
}

export interface Rule<M extends TypesMap = TypesMap> {
  /** A pattern string or a pattern object. */
  pattern?: PatternStyle<M>
  /** The kind name of the node to match. You can look up code's kind names in playground. */
  kind?: NamedKinds<M>
  /** The exact range of the node in the source code. */
  range?: Range
  /** A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax */
  regex?: string
  /**
   * `nthChild` accepts number, string or object.
   * It specifies the position in nodes' sibling list. */
  nthChild?: NthChild<M>

  // relational
  /**
   * `inside` accepts a relational rule object.
   * the target node must appear inside of another node matching the `inside` sub-rule. */
  inside?: Relation<M>
  /**
   * `has` accepts a relational rule object.
   * the target node must has a descendant node matching the `has` sub-rule. */
  has?: Relation<M>
  /**
   * `precedes` accepts a relational rule object.
   * the target node must appear before another node matching the `precedes` sub-rule. */
  precedes?: Relation<M>
  /**
   * `follows` accepts a relational rule object.
   * the target node must appear after another node matching the `follows` sub-rule. */
  follows?: Relation<M>
  // composite
  /**
   * A list of sub rules and matches a node if all of sub rules match.
   * The meta variables of the matched node contain all variables from the sub-rules. */
  all?: Array<Rule<M>>
  /**
   * A list of sub rules and matches a node if any of sub rules match.
   * The meta variables of the matched node only contain those of the matched sub-rule. */
  any?: Array<Rule<M>>
  /** A single sub-rule and matches a node if the sub rule does not match. */
  not?: Rule<M>
  /** A utility rule id and matches a node if the utility rule matches. */
  matches?: string
}



================================================
FILE: crates/napi/types/sgnode.d.ts
================================================
import type { NapiConfig } from './config'
import type {
  ChildKinds,
  ExtractField,
  FieldNames,
  Kinds,
  NamedChildKinds,
  NamedKinds,
  NodeFieldInfo,
  RootKind,
  TypesInField,
  TypesMap,
} from './staticTypes'

export interface Edit {
  /** The start position of the edit */
  startPos: number
  /** The end position of the edit */
  endPos: number
  /** The text to be inserted */
  insertedText: string
}
export interface Pos {
  /** line number starting from 0 */
  line: number
  /** column number starting from 0 */
  column: number
  /** byte offset of the position */
  index: number
}
export interface Range {
  /** starting position of the range */
  start: Pos
  /** ending position of the range */
  end: Pos
}

export declare class SgNode<
  M extends TypesMap = TypesMap,
  out T extends Kinds<M> = Kinds<M>,
> {
  /** Returns the node's id */
  id(): number
  range(): Range
  isLeaf(): boolean
  isNamed(): boolean
  isNamedLeaf(): boolean
  text(): string
  matches(m: string | number | NapiConfig<M>): boolean
  inside(m: string | number | NapiConfig<M>): boolean
  has(m: string | number | NapiConfig<M>): boolean
  precedes(m: string | number | NapiConfig<M>): boolean
  follows(m: string | number | NapiConfig<M>): boolean
  /** Returns the string name of the node kind */
  kind(): T
  readonly kindToRefine: T
  /** Check if the node is the same kind as the given `kind` string */
  is<K extends T>(kind: K): this is SgNode<M, K>
  // we need this override to allow string literal union
  is(kind: string): boolean

  getMatch: NodeMethod<M, [mv: string]>
  getMultipleMatches(m: string): Array<SgNode<M>>
  getTransformed(m: string): string | null
  /** Returns the node's SgRoot */
  getRoot(): SgRoot<M>
  children(): Array<SgNode<M>>
  find: NodeMethod<M, [matcher: string | number | NapiConfig<M>]>
  findAll<K extends Kinds<M>>(
    matcher: string | number | NapiConfig<M>,
  ): Array<RefineNode<M, K>>
  /** Finds the first child node in the `field` */
  field<F extends FieldNames<M[T]>>(name: F): FieldNode<M, T, F>
  /** Finds all the children nodes in the `field` */
  fieldChildren<F extends FieldNames<M[T]>>(
    name: F,
  ): Exclude<FieldNode<M, T, F>, null>[]
  parent: NodeMethod<M>
  child(nth: number): SgNode<M, ChildKinds<M, T>> | null
  child<K extends NamedChildKinds<M, T>>(nth: number): RefineNode<M, K> | null
  ancestors(): Array<SgNode<M>>
  next: NodeMethod<M>
  nextAll(): Array<SgNode<M>>
  prev: NodeMethod<M>
  prevAll(): Array<SgNode<M>>
  replace(text: string): Edit
  commitEdits(edits: Array<Edit>): string
}
/** Represents the parsed tree of code. */
export declare class SgRoot<M extends TypesMap = TypesMap> {
  /** Returns the root SgNode of the ast-grep instance. */
  root(): SgNode<M, RootKind<M>>
  /**
   * Returns the path of the file if it is discovered by ast-grep's `findInFiles`.
   * Returns `"anonymous"` if the instance is created by `lang.parse(source)`.
   */
  filename(): string
}

interface NodeMethod<M extends TypesMap, Args extends unknown[] = []> {
  (...args: Args): SgNode<M> | null
  <K extends NamedKinds<M>>(...args: Args): RefineNode<M, K> | null
}

/**
 * if K contains string, return general SgNode. Otherwise,
 * if K is a literal union, return a union of SgNode of each kind.
 */
type RefineNode<M extends TypesMap, K> = string extends K ? SgNode<M>
  : K extends Kinds<M> ? SgNode<M, K>
  : never

/**
 * return the SgNode of the field in the node.
 */
// F extends string is used to prevent noisy TS hover info
type FieldNode<
  M extends TypesMap,
  K extends Kinds<M>,
  F extends FieldNames<M[K]>,
> = F extends string ? FieldNodeImpl<M, ExtractField<M[K], F>> : never

type FieldNodeImpl<M extends TypesMap, I extends NodeFieldInfo> = I extends {
  required: true
} ? RefineNode<M, TypesInField<M, I>>
  : RefineNode<M, TypesInField<M, I>> | null



================================================
FILE: crates/napi/types/staticTypes.d.ts
================================================
/**
 * Reference
 * https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types
 * Rust CLI Impl
 * https://github.com/tree-sitter/tree-sitter/blob/f279d10aa2aca37c0004d84b2261685739f3cab8/cli/generate/src/node_types.rs#L35-L47
 */

export interface NodeBasicInfo {
  type: string
  named: boolean
}

export interface NodeFieldInfo {
  multiple: boolean
  required: boolean
  types: NodeBasicInfo[]
}

export interface NodeType extends NodeBasicInfo {
  root?: boolean
  fields?: {
    [fieldName: string]: NodeFieldInfo
  }
  children?: NodeFieldInfo
  subtypes?: NodeBasicInfo[]
}

/**
 * A map of key to NodeType.
 * Note, the key is not necessary node's kind.
 * it can be a rule representing a category of syntax nodes
 * (e.g. “expression”, “type”, “declaration”).
 * See reference above for more details.
 */
export interface TypesMap {
  [key: string]: NodeType
}

export type FieldNames<N extends NodeType> = N extends { fields: infer F } ? keyof F
  : string

export type ExtractField<
  N extends NodeType,
  F extends FieldNames<N>,
> = N['fields'] extends Record<F, NodeFieldInfo> ? N['fields'][F]
  : NodeFieldInfo

// in case of empty types array, return string as fallback
type NoNever<T, Fallback> = [T] extends [never] ? Fallback : T

export type TypesInField<M extends TypesMap, I extends NodeFieldInfo> = NoNever<
  ResolveType<M, I['types'][number]['type']>,
  Kinds<M>
>

export type NamedChildKinds<
  M extends TypesMap,
  T extends Kinds<M>,
> = M[T] extends { children: infer C extends NodeFieldInfo } ? TypesInField<M, C>
  : NamedKinds<M>
export type ChildKinds<M extends TypesMap, T extends Kinds<M>> =
  | NamedChildKinds<M, T>
  | LowPriorityKey

/**
 * resolve subtypes alias. see tree-sitter's reference
 * e.g. like `expression` => `binary_expression` | `unary_expression` | ...
 */
type ResolveType<M extends TypesMap, K> = K extends keyof M
  ? M[K] extends { subtypes: infer S extends NodeBasicInfo[] } ? ResolveType<M, S[number]['type']>
  : K
  : K

/**
 * All named nodes' kinds that are usable in ast-grep rule
 * NOTE: SgNode can return kind not in this list
 */
export type NamedKinds<M extends TypesMap> = ResolveType<M, keyof M>

/**
 * See open-ended unions / string literal completion in TypeScript
 * https://github.com/microsoft/TypeScript/issues/26277
 * https://github.com/microsoft/TypeScript/issues/33471
 */
type LowPriorityKey = string & {}

/**
 * A union of all named node kinds and a low priority key
 * tree-sitter Kinds also include unnamed nodes which is not usable in rule
 * NOTE: SgNode can return a string type if it is not a named node
 */
export type Kinds<M extends TypesMap = TypesMap> =
  | NamedKinds<M>
  | LowPriorityKey

/**
 * The root node kind of the tree.
 */
export type RootKind<M extends TypesMap> = NoNever<
  Extract<M[keyof M], { root: true }>['type'],
  Kinds<M>
>



================================================
FILE: crates/pyo3/README.md
================================================
# ast-grep python binding

[![PyPI](https://img.shields.io/pypi/v/ast-grep-py.svg?logo=PyPI)](https://pypi.org/project/ast-grep-py/)
[![Website](https://img.shields.io/badge/ast--grep-Ast--Grep_Website-red?logoColor=red)](https://ast-grep.github.io/)

<p align=center>
  <img src="https://ast-grep.github.io/logo.svg" alt="ast-grep"/>
</p>

## ast-grep

`ast-grep` is a tool for code structural search, lint, and rewriting. 

This crate intends to build a native python binding of ast-grep and provide a python API for programmatic usage.

## Installation

```bash
pip install ast-grep-py
```

## Usage

You can take our tests as examples. For example, [test_simple.py](./tests/test_simple.py) shows how to use ast-grep to search for a pattern in a file.

Please see the [API usage guide](https://ast-grep.github.io/guide/api-usage.html) and [API reference](https://ast-grep.github.io/reference/api.html) for more details.

Other resources include [ast-grep's official site](https://ast-grep.github.io/) and [repository](https://github.com/ast-grep/ast-grep).

## Development

### Setup virtualenv

```shell
python -m venv venv
```

### Activate venv

```shell
source venv/bin/activate
```

### Install `maturin`

```shell
pip install maturin[patchelf]
```

### MacOS: Install `patchelf` and `maturin`

```shell
brew install patchelf
pip install maturin
```

### Build bindings

```shell
maturin develop
```

### Run tests

```shell
pytest
```

All tests files are under [tests](./tests) directory.

## License

This project is licensed under the MIT license.



================================================
FILE: crates/pyo3/Cargo.toml
================================================
[package]
name = "ast-grep-py"
description = "Search and Rewrite code at large scale using precise AST pattern"
keywords = ["ast", "pattern", "codemod", "search", "rewrite"]

authors.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
version.workspace = true
edition.workspace = true
publish = false

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
name = "ast_grep_py"
crate-type = ["cdylib"]

[dependencies]
ast-grep-core.workspace = true
ast-grep-config.workspace = true
ast-grep-language.workspace = true
ast-grep-dynamic.workspace = true
anyhow.workspace = true
pyo3 = { version = "0.26.0", optional = true, features = ["anyhow", "py-clone"] }
pythonize = { version = "0.26.0", optional = true }
serde.workspace = true

# uncomment default features when developing pyo3
[features]
# default = ["python"]
python = ["pythonize", "pyo3", "pyo3/extension-module"]


================================================
FILE: crates/pyo3/pyproject.toml
================================================
[build-system]
requires = ["maturin>=1.1,<2.0"]
build-backend = "maturin"

[project]
name = "ast-grep-py"
requires-python = ">=3.8"
version = "0.39.5"
description = "Structural Search and Rewrite code at large scale using precise AST pattern."
authors = [{ name = "Herrington Darkholme", email = "2883231+HerringtonDarkholme@users.noreply.github.com" }]
maintainers = [{ name = "Herrington Darkholme", email = "2883231+HerringtonDarkholme@users.noreply.github.com" }]
readme = "README.md"
license = { text = "MIT" }
keywords = [
  "ast",
  "pattern",
  "codemod",
  "structural search",
  "rewrite"
]
classifiers = [
  "Development Status :: 3 - Alpha",
  "Environment :: Console",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Rust",
  "Topic :: Security",
  "Topic :: Software Development :: Quality Assurance",
  "Topic :: Software Development",
  "Topic :: Text Processing"
]

[project.urls]
Repository = "https://github.com/ast-grep/ast-grep"
Documentation = "https://ast-grep.github.io/"
Changelog = "https://github.com/ast-grep/ast-grep/blob/main/CHANGELOG.md"

[project.optional-dependencies]
test = [
  "pytest >= 7",
]

[tool.maturin]
features = ["python"]



================================================
FILE: crates/pyo3/ast_grep_py/__init__.py
================================================
from __future__ import annotations

from typing import List, TypedDict,  Literal, Dict, Union, Mapping, Optional
from .ast_grep_py import SgNode, SgRoot, Pos, Range, Edit, register_dynamic_language

Strictness = Union[Literal["cst"], Literal["smart"], Literal["ast"], Literal["relaxed"], Literal["signature"]]

class Pattern(TypedDict):
    selector: Optional[str]
    strictness: Optional[Strictness]
    context: str

class NthChild(TypedDict):
    position: int | str
    ofRule: Rule
    nth: int

class PosRule(TypedDict):
    line: int
    column: int

class RangeRule(TypedDict):
    start: PosRule
    end: PosRule

class RuleWithoutNot(TypedDict, total=False):
    # atomic rule
    pattern: str | Pattern
    kind: str
    regex: str
    nthChild: int | str | NthChild
    range: RangeRule

    # relational rule
    inside: "Relation" # pyright report error if forward reference here?
    has: Relation
    precedes: Relation
    follows: Relation

    # composite rule
    all: List[Rule]
    any: List[Rule]
    # cannot add here due to reserved keyword
    # not: Rule
    matches: str

# workaround
# Python's keyword requires `not` be a special case
class Rule(RuleWithoutNot, TypedDict("Not", {"not": "Rule"}, total=False)):
    pass

# Relational Rule Related
StopBy = Union[Literal["neighbor"], Literal["end"], Rule]

# Relation do NOT inherit from Rule due to pyright bug
# see tests/test_rule.py
class Relation(RuleWithoutNot, TypedDict("Not", {"not": "Rule"}, total=False), total=False):
    stopBy: StopBy
    field: str

class Config(TypedDict, total=False):
    rule: Rule
    constraints: Dict[str, Mapping]
    utils: Dict[str, Rule]
    transform: Dict[str, Mapping]

class CustomLang(TypedDict, total=False):
  library_path: str
  language_symbol: Optional[str]
  meta_var_char: Optional[str]
  expando_char: Optional[str]

__all__ = [
    "Rule",
    "Config",
    "Relation",
    "Pattern",
    "NthChild",
    "SgNode",
    "SgRoot",
    "Pos",
    "Range",
    "Edit",
    "register_dynamic_language",
]


================================================
FILE: crates/pyo3/ast_grep_py/ast_grep_py.pyi
================================================
from typing import List, Optional, overload, Unpack, Dict

from . import Rule, Config, CustomLang

class Pos:
    line: int
    column: int
    index: int

class Range:
    start: Pos
    end: Pos

class Edit:
    start_pos: int
    end_pos: int
    inserted_text: str

class SgRoot:
    def __init__(self, src: str, language: str) -> None: ...
    def root(self) -> SgNode: ...
    def filename(self) -> str: ...

class SgNode:
    # Node Inspection
    def range(self) -> Range: ...
    def is_leaf(self) -> bool: ...
    def is_named(self) -> bool: ...
    def is_named_leaf(self) -> bool: ...
    def kind(self) -> str: ...
    def text(self) -> str: ...

    # Refinement
    def matches(self, **rule: Unpack[Rule]) -> bool: ...
    def inside(self, **rule: Unpack[Rule]) -> bool: ...
    def has(self, **rule: Unpack[Rule]) -> bool: ...
    def precedes(self, **rule: Unpack[Rule]) -> bool: ...
    def follows(self, **rule: Unpack[Rule]) -> bool: ...
    def get_match(self, meta_var: str) -> Optional[SgNode]: ...
    def get_multiple_matches(self, meta_var: str) -> List[SgNode]: ...
    def get_transformed(self, meta_var: str) -> Optional[str]: ...
    def __getitem__(self, meta_var: str) -> SgNode: ...

    # Search
    @overload
    def find(self, config: Config) -> Optional[SgNode]: ...
    @overload
    def find(self, **kwargs: Unpack[Rule]) -> Optional[SgNode]: ...
    @overload
    def find_all(self, config: Config) -> List[SgNode]: ...
    @overload
    def find_all(self, **kwargs: Unpack[Rule]) -> List[SgNode]: ...

    # Tree Traversal
    def get_root(self) -> SgRoot: ...
    def field(self, name: str) -> Optional[SgNode]: ...
    def field_children(self, name: str) -> List[SgNode]: ...
    def parent(self) -> Optional[SgNode]: ...
    def child(self, nth: int) -> Optional[SgNode]: ...
    def children(self) -> List[SgNode]: ...
    def ancestors(self) -> List[SgNode]: ...
    def next(self) -> Optional[SgNode]: ...
    def next_all(self) -> List[SgNode]: ...
    def prev(self) -> Optional[SgNode]: ...
    def prev_all(self) -> List[SgNode]: ...

    # Edit
    def replace(self, new_text: str) -> Edit: ...
    def commit_edits(self, edits: List[Edit]) -> str: ...

def register_dynamic_language(langs: Dict[str, CustomLang]): ...


================================================
FILE: crates/pyo3/ast_grep_py/py.typed
================================================
[Empty file]


================================================
FILE: crates/pyo3/src/lib.rs
================================================
#![cfg(not(test))]
#![cfg(feature = "python")]
mod py_lang;
mod py_node;
mod range;
mod unicode_position;
use py_lang::register_dynamic_language;
use py_node::{Edit, SgNode};
use range::{Pos, Range};

use ast_grep_core::{
  tree_sitter::{LanguageExt, StrDoc},
  AstGrep, NodeMatch,
};
use py_lang::PyLang;
use pyo3::prelude::*;

use unicode_position::UnicodePosition;

/// A Python module implemented in Rust.
#[pymodule]
fn ast_grep_py(_py: Python, m: &Bound<PyModule>) -> PyResult<()> {
  m.add_class::<SgRoot>()?;
  m.add_class::<SgNode>()?;
  m.add_class::<Range>()?;
  m.add_class::<Pos>()?;
  m.add_class::<Edit>()?;
  m.add_function(wrap_pyfunction!(register_dynamic_language, m)?)?;
  Ok(())
}

#[pyclass]
struct SgRoot {
  inner: AstGrep<StrDoc<PyLang>>,
  filename: String,
  pub(crate) position: UnicodePosition,
}

#[pymethods]
impl SgRoot {
  #[new]
  fn new(src: &str, lang: &str) -> Self {
    let position = UnicodePosition::new(src);
    let lang: PyLang = lang.parse().unwrap();
    let inner = lang.ast_grep(src);
    Self {
      inner,
      filename: "anonymous".into(),
      position,
    }
  }

  fn root(slf: PyRef<Self>) -> SgNode {
    let tree = unsafe { &*(&slf.inner as *const AstGrep<_>) } as &'static AstGrep<_>;
    let inner = NodeMatch::from(tree.root());
    SgNode {
      inner,
      root: slf.into(),
    }
  }

  fn filename(&self) -> &str {
    &self.filename
  }
}



================================================
FILE: crates/pyo3/src/py_lang.rs
================================================
use anyhow::Context;
use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ast_grep_core::tree_sitter::{LanguageExt, StrDoc, TSLanguage};
use ast_grep_dynamic::{CustomLang, DynamicLang, LibraryPath};
use ast_grep_language::{Language, SupportLang};
use serde::{Deserialize, Serialize};

use pyo3::prelude::*;
use pyo3::types::PyDict;
use pythonize::depythonize;

use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Debug, Display, Formatter};
use std::str::FromStr;

// we need this because of different casing in python
// in Python, every field is in snake_case
// but in napi/YAML, every field is in camelCase
#[derive(Serialize, Deserialize, Clone)]
pub struct CustomPyLang {
  library_path: LibraryPath,
  /// the dylib symbol to load ts-language, default is `tree_sitter_{name}`
  language_symbol: Option<String>,
  meta_var_char: Option<char>,
  expando_char: Option<char>,
  extensions: Vec<String>,
}

impl From<CustomPyLang> for CustomLang {
  fn from(c: CustomPyLang) -> Self {
    CustomLang {
      library_path: c.library_path,
      language_symbol: c.language_symbol,
      meta_var_char: c.meta_var_char,
      expando_char: c.expando_char,
      extensions: c.extensions,
    }
  }
}

#[pyfunction]
pub fn register_dynamic_language(dict: Bound<PyDict>) -> PyResult<()> {
  let langs: HashMap<String, CustomPyLang> = depythonize(dict.as_any())?;
  let langs = langs
    .into_iter()
    .map(|(name, custom)| (name, CustomLang::from(custom)))
    .collect();
  let base = std::env::current_dir()?;
  CustomLang::register(&base, langs).context("registering dynamic language failed")?;
  Ok(())
}

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub enum PyLang {
  // inlined support lang expando char
  Builtin(SupportLang),
  Custom(DynamicLang),
}
#[derive(Debug)]
pub enum PyLangErr {
  LanguageNotSupported(String),
}

impl Display for PyLangErr {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    use PyLangErr::*;
    match self {
      LanguageNotSupported(lang) => write!(f, "{lang} is not supported!"),
    }
  }
}

impl std::error::Error for PyLangErr {}

impl FromStr for PyLang {
  type Err = PyLangErr;
  fn from_str(s: &str) -> Result<Self, Self::Err> {
    if let Ok(b) = SupportLang::from_str(s) {
      Ok(PyLang::Builtin(b))
    } else if let Ok(c) = DynamicLang::from_str(s) {
      Ok(PyLang::Custom(c))
    } else {
      Err(PyLangErr::LanguageNotSupported(s.into()))
    }
  }
}

use PyLang::*;
impl Language for PyLang {
  fn pre_process_pattern<'q>(&self, query: &'q str) -> Cow<'q, str> {
    match self {
      Builtin(b) => b.pre_process_pattern(query),
      Custom(c) => c.pre_process_pattern(query),
    }
  }

  #[inline]
  fn meta_var_char(&self) -> char {
    match self {
      Builtin(b) => b.meta_var_char(),
      Custom(c) => c.meta_var_char(),
    }
  }

  #[inline]
  fn expando_char(&self) -> char {
    match self {
      Builtin(b) => b.expando_char(),
      Custom(c) => c.expando_char(),
    }
  }

  fn kind_to_id(&self, kind: &str) -> u16 {
    match self {
      Builtin(b) => b.kind_to_id(kind),
      Custom(c) => c.kind_to_id(kind),
    }
  }
  fn field_to_id(&self, field: &str) -> Option<u16> {
    match self {
      Builtin(b) => b.field_to_id(field),
      Custom(c) => c.field_to_id(field),
    }
  }
  fn build_pattern(&self, builder: &PatternBuilder) -> Result<Pattern, PatternError> {
    builder.build(|src| StrDoc::try_new(src, *self))
  }
}
impl LanguageExt for PyLang {
  fn get_ts_language(&self) -> TSLanguage {
    match self {
      Builtin(b) => b.get_ts_language(),
      Custom(c) => c.get_ts_language(),
    }
  }
}



================================================
FILE: crates/pyo3/src/py_node.rs
================================================
use crate::py_lang::PyLang;
use crate::range::Range;
use crate::SgRoot;

use ast_grep_config::{DeserializeEnv, RuleCore, SerializableRuleCore};
use ast_grep_core::{tree_sitter::StrDoc, NodeMatch};

use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use anyhow::Context;
use pyo3::exceptions::{PyKeyError, PyValueError};
use pyo3::prelude::*;
use pyo3::types::PyDict;
use pythonize::depythonize;

#[pyclass(mapping)]
pub struct SgNode {
  pub inner: NodeMatch<'static, StrDoc<PyLang>>,
  // refcount SgRoot
  pub(crate) root: Py<SgRoot>,
}

// it is safe to send tree-sitter Node
// because it is refcnt and concurrency safe
unsafe impl Send for SgNode {}

#[pymethods]
impl SgNode {
  /*----------  Node Inspection ----------*/
  fn range(&self) -> Range {
    Python::attach(|py| {
      let root = self.root.bind(py);
      let root = root.borrow();
      Range::from(&self.inner, &root.position)
    })
  }

  fn is_leaf(&self) -> bool {
    self.inner.is_leaf()
  }

  fn is_named(&self) -> bool {
    self.inner.is_named()
  }

  fn is_named_leaf(&self) -> bool {
    self.inner.is_named_leaf()
  }

  fn kind(&self) -> String {
    self.inner.kind().to_string()
  }

  fn text(&self) -> String {
    self.inner.text().to_string()
  }

  /*---------- Search Refinement  ----------*/
  #[pyo3(signature = (**kwargs))]
  fn matches(&self, kwargs: Option<Bound<PyDict>>) -> PyResult<bool> {
    let matcher = get_matcher_from_rule(self.inner.lang(), kwargs)?;
    Ok(self.inner.matches(matcher))
  }

  #[pyo3(signature = (**kwargs))]
  fn inside(&self, kwargs: Option<Bound<PyDict>>) -> PyResult<bool> {
    let matcher = get_matcher_from_rule(self.inner.lang(), kwargs)?;
    Ok(self.inner.inside(matcher))
  }

  #[pyo3(signature = (**kwargs))]
  fn has(&self, kwargs: Option<Bound<PyDict>>) -> PyResult<bool> {
    let matcher = get_matcher_from_rule(self.inner.lang(), kwargs)?;
    Ok(self.inner.has(matcher))
  }

  #[pyo3(signature = (**kwargs))]
  fn precedes(&self, kwargs: Option<Bound<PyDict>>) -> PyResult<bool> {
    let matcher = get_matcher_from_rule(self.inner.lang(), kwargs)?;
    Ok(self.inner.precedes(matcher))
  }

  #[pyo3(signature = (**kwargs))]
  fn follows(&self, kwargs: Option<Bound<PyDict>>) -> PyResult<bool> {
    let matcher = get_matcher_from_rule(self.inner.lang(), kwargs)?;
    Ok(self.inner.follows(matcher))
  }

  fn get_match(&self, meta_var: &str) -> Option<Self> {
    self
      .inner
      .get_env()
      .get_match(meta_var)
      .cloned()
      .map(|n| Self {
        inner: NodeMatch::from(n),
        root: self.root.clone(),
      })
  }

  fn get_multiple_matches(&self, meta_var: &str) -> Vec<SgNode> {
    self
      .inner
      .get_env()
      .get_multiple_matches(meta_var)
      .into_iter()
      .map(|n| Self {
        inner: NodeMatch::from(n),
        root: self.root.clone(),
      })
      .collect()
  }

  fn get_transformed(&self, meta_var: &str) -> Option<String> {
    self
      .inner
      .get_env()
      .get_transformed(meta_var)
      .map(|n| String::from_utf8_lossy(n).to_string())
  }

  /*---------- Tree Traversal  ----------*/
  fn get_root(&self) -> Py<SgRoot> {
    self.root.clone()
  }

  #[pyo3(signature = (config=None, **rule))]
  fn find(
    &self,
    config: Option<Bound<PyDict>>,
    rule: Option<Bound<PyDict>>,
  ) -> PyResult<Option<Self>> {
    let matcher = self.get_matcher(config, rule)?;
    if let Some(inner) = self.inner.find(matcher) {
      Ok(Some(Self {
        inner,
        root: self.root.clone(),
      }))
    } else {
      Ok(None)
    }
  }

  #[pyo3(signature = (config=None, **rule))]
  fn find_all(
    &self,
    config: Option<Bound<PyDict>>,
    rule: Option<Bound<PyDict>>,
  ) -> PyResult<Vec<Self>> {
    let matcher = self.get_matcher(config, rule)?;
    Ok(
      self
        .inner
        .find_all(matcher)
        .map(|n| Self {
          inner: n,
          root: self.root.clone(),
        })
        .collect(),
    )
  }

  fn field(&self, name: &str) -> Option<SgNode> {
    self.inner.field(name).map(|inner| Self {
      inner: inner.into(),
      root: self.root.clone(),
    })
  }

  fn field_children(&self, name: &str) -> Vec<SgNode> {
    self
      .inner
      .field_children(name)
      .map(|inner| Self {
        inner: inner.into(),
        root: self.root.clone(),
      })
      .collect()
  }

  fn parent(&self) -> Option<SgNode> {
    self.inner.parent().map(|inner| Self {
      inner: inner.into(),
      root: self.root.clone(),
    })
  }

  fn child(&self, nth: usize) -> Option<SgNode> {
    self.inner.child(nth).map(|inner| Self {
      inner: inner.into(),
      root: self.root.clone(),
    })
  }

  fn ancestors(&self) -> Vec<SgNode> {
    self
      .inner
      .ancestors()
      .map(|inner| Self {
        inner: inner.into(),
        root: self.root.clone(),
      })
      .collect()
  }

  fn children(&self) -> Vec<SgNode> {
    self
      .inner
      .children()
      .map(|inner| Self {
        inner: inner.into(),
        root: self.root.clone(),
      })
      .collect()
  }

  fn next(&self) -> Option<SgNode> {
    self.inner.next().map(|inner| Self {
      inner: inner.into(),
      root: self.root.clone(),
    })
  }

  fn next_all(&self) -> Vec<SgNode> {
    self
      .inner
      .next_all()
      .map(|inner| Self {
        inner: inner.into(),
        root: self.root.clone(),
      })
      .collect()
  }

  fn prev(&self) -> Option<SgNode> {
    self.inner.prev().map(|inner| Self {
      inner: inner.into(),
      root: self.root.clone(),
    })
  }

  fn prev_all(&self) -> Vec<SgNode> {
    self
      .inner
      .prev_all()
      .map(|inner| Self {
        inner: inner.into(),
        root: self.root.clone(),
      })
      .collect()
  }

  /*---------- Edit  ----------*/
  fn replace(&self, text: &str) -> Edit {
    let byte_range = self.inner.range();
    Python::attach(|py| {
      let root = self.root.bind(py);
      let root = root.borrow();
      let start_pos = root.position.byte_to_char(byte_range.start);
      let end_pos = root.position.byte_to_char(byte_range.end);
      Edit {
        start_pos,
        end_pos,
        inserted_text: text.to_string(),
      }
    })
  }

  fn commit_edits(&self, mut edits: Vec<Edit>) -> String {
    edits.sort_by_key(|edit| edit.start_pos);
    let mut new_content = String::new();
    let old_content = self.text();
    let converted: Vec<_> = Python::attach(move |py| {
      let root = self.root.bind(py);
      let root = root.borrow();
      let conv = &root.position;
      edits
        .into_iter()
        .map(|mut e| {
          e.start_pos = conv.char_to_byte(e.start_pos);
          e.end_pos = conv.char_to_byte(e.end_pos);
          e
        })
        .collect()
    });
    let offset = self.inner.range().start;
    let mut start = 0;
    for diff in converted {
      let pos = diff.start_pos - offset;
      // skip overlapping edits
      if start > pos {
        continue;
      }
      new_content.push_str(&old_content[start..pos]);
      new_content.push_str(&diff.inserted_text);
      start = diff.end_pos - offset;
    }
    // add trailing statements
    new_content.push_str(&old_content[start..]);
    new_content
  }

  /*---------- Magic Method  ----------*/
  fn __hash__(&self) -> u64 {
    let mut s = DefaultHasher::new();
    self.inner.node_id().hash(&mut s);
    s.finish()
  }
  fn __eq__(&self, other: &Self) -> bool {
    self.inner.node_id() == other.inner.node_id()
  }
  fn __str__(&self) -> String {
    let range = self.range();
    format!("{}@{}", self.inner.kind(), range)
  }
  fn __repr__(&self) -> String {
    let range = self.range();
    let chars: Vec<_> = self.text().chars().take(10).collect();
    let src = if chars.len() > 9 {
      let s: String = chars.into_iter().take(5).collect();
      format!("{s}...")
    } else {
      chars.into_iter().collect()
    };
    format!("SgNode(`{src}`, kind={}, range={range})", self.inner.kind())
  }
  fn __getitem__(&self, key: &str) -> PyResult<Self> {
    if let Some(node) = self.get_match(key) {
      Ok(node)
    } else {
      Err(PyErr::new::<PyKeyError, _>(key.to_string()))
    }
  }
}

impl SgNode {
  fn get_matcher(
    &self,
    config: Option<Bound<PyDict>>,
    kwargs: Option<Bound<PyDict>>,
  ) -> PyResult<RuleCore> {
    let lang = self.inner.lang();
    let config = if let Some(config) = config {
      config_from_dict(config)?
    } else if let Some(rule) = kwargs {
      config_from_rule(rule)?
    } else {
      return Err(PyErr::new::<PyValueError, _>("rule must not be empty"));
    };
    let env = DeserializeEnv::new(*lang);
    let matcher = config.get_matcher(env).context("cannot get matcher")?;
    Ok(matcher)
  }
}

fn config_from_dict(dict: Bound<PyDict>) -> PyResult<SerializableRuleCore> {
  Ok(depythonize(dict.as_any())?)
}

fn config_from_rule(dict: Bound<PyDict>) -> PyResult<SerializableRuleCore> {
  let rule = depythonize(dict.as_any())?;
  Ok(SerializableRuleCore {
    rule,
    constraints: None,
    utils: None,
    transform: None,
    fix: None,
  })
}

fn get_matcher_from_rule(lang: &PyLang, dict: Option<Bound<PyDict>>) -> PyResult<RuleCore> {
  let rule = dict.ok_or_else(|| PyErr::new::<PyValueError, _>("rule must not be empty"))?;
  let env = DeserializeEnv::new(*lang);
  let config = config_from_rule(rule)?;
  let matcher = config.get_matcher(env).context("cannot get matcher")?;
  Ok(matcher)
}

#[pyclass(get_all, set_all)]
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Edit {
  /// The start position of the edit in character
  pub start_pos: usize,
  /// The end position of the edit in character
  pub end_pos: usize,
  /// The text to be inserted
  pub inserted_text: String,
}



================================================
FILE: crates/pyo3/src/range.rs
================================================
use crate::unicode_position::UnicodePosition;
use ast_grep_core::{Doc, Node, Position};
use pyo3::prelude::*;
use std::collections::hash_map::DefaultHasher;
use std::fmt::{self, Debug, Display, Formatter};
use std::hash::{Hash, Hasher};

#[pyclass(frozen, get_all)]
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Pos {
  /// line number starting from 0
  line: usize,
  /// column number starting from 0
  column: usize,
  /// char offset of the position
  index: usize,
}

impl Display for Pos {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
    write!(f, "({},{})", self.line, self.column)
  }
}

impl Debug for Pos {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
    write!(
      f,
      "Pos(line={}, col={}, index={})",
      self.line, self.column, self.index
    )
  }
}

#[pymethods]
impl Pos {
  fn __hash__(&self) -> u64 {
    let mut s = DefaultHasher::new();
    self.hash(&mut s);
    s.finish()
  }
  fn __eq__(&self, other: &Self) -> bool {
    self == other
  }
  fn __repr__(&self) -> String {
    format!("{self:?}")
  }
  fn __str__(&self) -> String {
    self.to_string()
  }
}

fn to_pos<D: Doc>(node: &Node<D>, pos: Position, offset: usize) -> Pos {
  Pos {
    line: pos.line(),
    column: pos.column(node),
    index: offset,
  }
}

#[pyclass(frozen, get_all)]
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Range {
  /// starting position of the range
  start: Pos,
  /// ending position of the range
  end: Pos,
}

impl Display for Range {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
    write!(f, "{}-{}", self.start, self.end)
  }
}

impl Debug for Range {
  fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
    write!(f, "Range(start={:?}, end={:?})", self.start, self.end)
  }
}

#[pymethods]
impl Range {
  fn __eq__(&self, other: &Self) -> bool {
    self == other
  }
  fn __hash__(&self) -> u64 {
    let mut s = DefaultHasher::new();
    self.hash(&mut s);
    s.finish()
  }
  fn __repr__(&self) -> String {
    format!("{self:?}")
  }
  fn __str__(&self) -> String {
    self.to_string()
  }
}

impl Range {
  pub fn from<D: Doc>(node: &Node<D>, positioner: &UnicodePosition) -> Self {
    let byte_range = node.range();
    let start_pos = node.start_pos();
    let end_pos = node.end_pos();
    let start = positioner.byte_to_char(byte_range.start);
    let end = positioner.byte_to_char(byte_range.end);
    Range {
      start: to_pos(node, start_pos, start),
      end: to_pos(node, end_pos, end),
    }
  }
}



================================================
FILE: crates/pyo3/src/unicode_position.rs
================================================
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Offset {
  char_offset: usize,
  byte_offset: usize,
  len: u8,
}

pub struct UnicodePosition {
  offsets: Box<[Offset]>,
}

impl UnicodePosition {
  pub fn new(s: &str) -> Self {
    let mut byte_offset = 0;
    let mut offsets = Vec::new();
    for (char_offset, ch) in s.chars().enumerate() {
      let len = ch.len_utf8();
      if len > 1 {
        offsets.push(Offset {
          char_offset,
          byte_offset,
          len: len as u8,
        });
      }
      byte_offset += len;
    }
    Self {
      offsets: offsets.into_boxed_slice(),
    }
  }

  pub fn char_to_byte(&self, char_offset: usize) -> usize {
    // use binary search to find the offsets
    let ret = self
      .offsets
      .binary_search_by(|o| o.char_offset.cmp(&char_offset));
    match ret {
      Ok(i) => self.offsets[i].byte_offset,
      Err(0) => char_offset,
      Err(i) => {
        let last = &self.offsets[i - 1];
        let end_offset = last.byte_offset + last.len as usize;
        let diff = char_offset - last.char_offset;
        end_offset + diff - 1
      }
    }
  }
  pub fn byte_to_char(&self, byte_offset: usize) -> usize {
    let ret = self
      .offsets
      .binary_search_by(|o| o.byte_offset.cmp(&byte_offset));
    match ret {
      Ok(i) => self.offsets[i].char_offset,
      Err(0) => byte_offset,
      Err(i) => {
        let last = &self.offsets[i - 1];
        let end_offset = last.byte_offset + last.len as usize;
        let diff = byte_offset - end_offset;
        last.char_offset + diff + 1
      }
    }
  }
}



================================================
FILE: crates/pyo3/tests/test_fix.py
================================================
[Binary file]


================================================
FILE: crates/pyo3/tests/test_range.py
================================================
from ast_grep_py import SgRoot, Range, Pos

source = """
function test() {
  let a = 123
}
""".strip()

sg = SgRoot(source, "javascript")
root = sg.root()
node1 = root.find(pattern="let $A = $B")
assert node1 is not None
node2 = root.find(pattern="let $A = 123")
assert node2 is not None


def test_pos():
    r1 = node1.range()
    r2 = node2.range()
    pos = r1.start
    pos2 = r2.start
    assert isinstance(pos, Pos)
    assert pos.line == 1
    assert pos.column == 2
    assert pos.index == 20
    assert pos == pos2
    assert hash(pos) == hash(pos2)


def test_range():
    r1 = node1.range()
    r2 = node2.range()
    assert isinstance(r1, Range)
    assert r1.start.line == 1
    assert r1.end.line == 1
    assert r1.start.column == 2
    assert r1.end.column == 13
    assert r1.start.index == 20
    assert r1.end.index == 31
    assert r1 == r2
    assert hash(r1) == hash(r2)

def test_unicode():
    source = "ハロ = console.log(世界)".strip()
    sg = SgRoot(source, "javascript")
    root = sg.root()
    node = root.find(pattern="console.log($A)")
    assert node is not None
    assert node.range().start.index == 5
    assert node.range().start.line == 0
    assert node.range().start.column == 5

def test_unicode_range_rule():
    source = "ハロ = console.log(世界)".strip()
    sg = SgRoot(source, "javascript")
    root = sg.root()
    node = root.find(range={"start": {"line": 0, "column": 17}, "end": {"line": 0, "column": 19}})
    assert node
    assert node.range().start.index == 17
    assert node.range().start.line == 0
    assert node.range().start.column == 17
    assert node.range().end.index == 19
    assert node.range().end.line == 0
    assert node.range().end.column == 19


================================================
FILE: crates/pyo3/tests/test_register_lang.py
================================================
from ast_grep_py import SgRoot, register_dynamic_language
import platform

source = """
{
  "test": 123
}
""".strip()

# at the moment only test darwin arm64
def is_arm_mac():
    return platform.system() == 'Darwin' and platform.processor() == 'arm'

def is_x64_linux():
    return platform.system() == 'Linux' and platform.machine() == 'x86_64'

def register_lang():
    if is_arm_mac():
        register_dynamic_language({
            "myjson": {
                "library_path": "../../fixtures/json-mac.so",
                "language_symbol": "tree_sitter_json",
                "extensions": ["myjson"],
            }
        })
    if is_x64_linux():
        register_dynamic_language({
            "myjson": {
                "library_path": "../../fixtures/json-linux.so",
                "language_symbol": "tree_sitter_json",
                "extensions": ["myjson"],
            }
        })

register_lang()

def test_load_json_lang():
    if not is_arm_mac() and not is_x64_linux():
        return
    sg = SgRoot(source, "myjson")
    root = sg.root()
    node = root.find(pattern="123")
    assert node
    assert node.kind() == "number"
    node = root.find(pattern="456")
    assert not node


================================================
FILE: crates/pyo3/tests/test_rule.py
================================================
from ast_grep_py import SgRoot, Rule, Config, Relation, Pattern

source = """
function test() {
  let a = 123
}
""".strip()

sg = SgRoot(source, "javascript")
root = sg.root()

def test_simple():
    node = root.find(pattern="let $A = $B")
    assert node is not None

def test_config():
    node = root.find(
        Config(
            rule={"pattern": "let a = 123"},
        )
    )
    assert node is not None

def test_config_literal():
    node = root.find({
        "rule": {"pattern": "let a = 123"},
    })
    assert node is not None

def test_rule():
    rule = Rule(pattern = "let $A = $B")
    node = root.find(**rule)
    assert node is not None

def test_dict_literal():
    # pyright is not smart to infer dict.
    # We have to annotate Rule here
    rule: Rule = {"pattern": "let $A = $B"}
    node = root.find(**rule)
    assert node is not None

def test_not_rule():
    rule = {"pattern": "let $A = $B", "not": Rule(pattern="let a = 123")}
    node = root.find(**rule)
    assert not node
    rule = {"pattern": "let $A = $B", "not": Rule(pattern="let b = 123")}
    node = root.find(**rule)
    assert node

def test_relational_dict():
    relation: Relation = {"kind": "function_declaration", "stopBy": "end"}
    node = root.find(
        pattern="let a = 123\n",
        inside=relation,
    )
    assert node
    node = root.find(
        pattern="let a = 123\n",
        inside={"kind": "function_declaration", "stopBy": "end"},
    )
    assert node

def test_relational_rule():
    node = root.find(
        pattern="let a = 123\n",
        inside=Relation(kind="function_declaration", stopBy="end"),
    )
    assert node

def test_complex_config_dict():
    node = root.find({
        "rule": {
            "pattern": "let $A = $B",
            "regex": "123",
            "not": {
                "regex": "456"
            },
        },
        "constraints": {
            "A": {
                "pattern": "a"
            }
        },
        "transform": {
            "C": {
                "substring": {
                    "source": "$B",
                    "startChar": 1,
                    "endChar": -1,
                }
            }
        }
    })
    assert node
    assert node.get_transformed("C") == "2"

def test_complex_config_dict_not_found():
    node = root.find({
        "rule": {
            "pattern": "let $A = $B",
            "regex": "123",
            "not": {
                "regex": "456"
            },
        },
        "constraints": {
            "A": {
                "pattern": "a"
            },
            "B": {
                "regex": "222"
            },
        },
        "transform": {
            "C": {
                "substring": {
                    "source": "$B",
                    "startChar": 1,
                    "endChar": -1,
                }
            }
        }
    })
    assert not node

def test_complex_config():
    node = root.find(Config(
        rule=Rule(pattern="let $A = $B", regex="123"),
        constraints=dict(A=Rule(pattern="a")),
        transform=dict(C={
            "substring": {
                "source": "$B",
                "startChar": 1,
            }
        })
    ))
    assert node
    assert node.text() == "let a = 123"
    assert node.get_transformed("C") == "23"

def test_pattern():
    node = root.find(pattern={
        "context": "let a = 123",
        "selector": "variable_declarator"
    })
    assert node
    assert node.text() == "a = 123"
    node2 = root.find(pattern=Pattern(
        context="let a = 123",
        selector="variable_declarator",
    ))
    assert node == node2

def test_range_rule():
    node = root.find(range={
        "start": {"line": 0, "column": 9},
        "end": {"line": 0, "column": 13},
    })
    assert node
    assert node.text() == "test"
    node = root.find(range={
        "start": {"line": 0, "column": 9},
        "end": {"line": 0, "column": 12},
    })
    assert not node

def test_strictness():
    node = root.find(pattern={
        "context": "let b = 456",
        "strictness": "signature",
    })


================================================
FILE: crates/pyo3/tests/test_simple.py
================================================
from ast_grep_py import SgRoot, Rule

source = """
function test() {
  let a = 123
  let b = 456
  let c = 789
}
""".strip()
sg = SgRoot(source, "javascript")
root = sg.root()

def test_is_leaf():
    node = root.find(pattern="let $A = $B")
    assert node
    assert not node.is_leaf()
    node = root.find(pattern="123")
    assert node
    assert node.is_leaf()

def test_is_named():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.is_named()
    node = root.find(pattern="123")
    assert node
    assert node.is_named()

def test_kind():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.kind() == "lexical_declaration"
    node = root.find(pattern="123")
    assert node
    assert node.kind() == "number"

def test_text():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.text() == "let a = 123"
    node = root.find(kind="number")
    assert node
    assert node.text() == "123"

def test_matches():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.matches(kind="lexical_declaration")
    assert not node.matches(kind="number")
    assert node.matches(pattern="let a = 123")
    assert not node.matches(pattern="let b = 456")
    assert node.matches(has=Rule(
        kind="variable_declarator",
        has=Rule(
            kind="number",
            pattern="123"
        )
    ))

def test_inside():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.inside(kind="function_declaration")
    assert not node.inside(kind="function_expression")

def test_has():
    node = root.find(pattern="let $A = $B")
    assert node
    assert node.has(pattern="123")
    assert node.has(kind="number")
    assert not node.has(kind="function_expression")

def test_precedes():
    node = root.find(pattern="let $A = $B\n")
    assert node
    assert node.precedes(pattern="let b = 456\n")
    assert node.precedes(pattern="let c = 789\n")
    assert not node.precedes(pattern="notExist")

def test_follows():
    node = root.find(pattern="let b = 456\n")
    assert node
    assert node.follows(pattern="let a = 123\n")
    assert not node.follows(pattern="let c = 789\n")

def test_get_match():
    node = root.find(pattern="let $A = $B")
    assert node
    a = node.get_match("A")
    assert a is not None
    assert a.text() == "a"
    rng = a.range()
    assert rng.start.line == 1
    assert rng.start.column == 6

def test_must_get_match():
    node = root.find(pattern="let $A = $B")
    assert node
    a = node["A"]
    assert a is not None
    assert a.text() == "a"
    rng = a.range()
    assert rng.start.line == 1
    assert rng.start.column == 6


def test_get_multi_match():
    node = root.find(pattern="function test() { $$$STMT }")
    assert node
    stmts = node.get_multiple_matches("STMT")
    assert len(stmts) == 3
    assert stmts[0] == root.find(pattern="let a = 123")

def test_hash():
    node1 = root.find(pattern="let $A = $B")
    node2 = root.find(pattern="let $A = 123")
    assert hash(node1) == hash(node2)

def test_eq():
    node1 = root.find(pattern="let $A = $B")
    node2 = root.find(pattern="let $A = 123")
    assert node1 == node2

def test_str():
    node1 = root.find(pattern="let $A = $B")
    assert str(node1) == "lexical_declaration@(1,2)-(1,13)"

def test_repr_short():
    node1 = root.find(pattern="let $A = $B")
    assert repr(node1) == "SgNode(`let a...`, kind=lexical_declaration, range=(1,2)-(1,13))"

def test_repr_long():
    node1 = root.find(pattern="123")
    assert repr(node1) == "SgNode(`123`, kind=number, range=(1,10)-(1,13))"


================================================
FILE: crates/pyo3/tests/test_traversal.py
================================================
from typing import Optional, TypeVar
from ast_grep_py import SgNode, SgRoot

source = """
function test() {
  let a = 123
  let b = 456
  let c = 789
}
""".strip()
sg = SgRoot(source, "javascript")
root = sg.root()

def test_get_root():
    node = root.find(pattern="let a = $A")
    assert node is not None
    root2 = node.get_root()
    assert root2.filename() == "anonymous"
    # assert root2 == root


def test_find_all():
    nodes = root.find_all(pattern="let $N = $V")
    assert len(nodes) == 3

    def assert_name(node: SgNode, text: str):
        n = node.get_match("N")
        assert n is not None
        assert n.text() == text

    assert_name(nodes[0], "a")
    assert_name(nodes[1], "b")
    assert_name(nodes[2], "c")

def test_field():
    node = root.find(kind="variable_declarator")
    assert node
    name = node.field("name")
    assert name is not None
    assert name.text() == "a"
    value = node.field("value")
    assert value is not None
    assert value.text() == "123"
    non = node.field("notexist")
    assert non is None

def test_field_children():
    source = 'const el = <div id="foo" className="bar" />'
    sg = SgRoot(source, "tsx")
    root = sg.root()
    node = root.find(kind="jsx_self_closing_element")
    assert node
    attributes = node.field_children("attribute")
    assert len(attributes) == 2
    assert attributes[0].text() == 'id="foo"'
    assert attributes[1].text() == 'className="bar"'

def test_parent():
    node = root.find(kind="variable_declarator")
    assert node
    parent = node.parent()
    assert parent is not None
    assert parent.kind() == "lexical_declaration"
    assert root.parent() is None

T = TypeVar('T')
def unwrap(n: Optional[T]) -> T:
    assert n is not None
    return n

def test_child():
    node = root.find(kind="variable_declarator")
    assert node
    assert unwrap(node.child(0)).text() == "a"
    assert unwrap(node.child(2)).text() == "123"
    assert node.child(3) is None

def test_children():
    node = root.find(kind="variable_declarator")
    assert node
    children = node.children()
    assert len(children) == 3
    assert children[0].text() == "a"
    assert children[2].text() == "123"
    assert not children[0].children()

def test_ancestors():
    node = root.find(kind="variable_declarator")
    assert node
    ancestors = node.ancestors()
    assert len(ancestors) == 4
    assert not root.ancestors()

def test_next():
    node = root.find(pattern="let a = $A\n")
    assert node is not None
    neighbor = node.next()
    assert neighbor is not None
    assert neighbor.text() == "let b = 456"
    node = root.find(pattern="let c = $A\n")
    assert node
    node = node.next()
    assert node # `}` is the last node
    assert not node.next()

def test_next_all():
    node = root.find(pattern="let a = $A\n")
    assert node is not None
    next_all = node.next_all()
    assert len(next_all) == 3
    assert len(next_all[0].next_all()) == 2
    assert not next_all[2].next_all()

def test_prev():
    node = root.find(pattern="let c = $A\n")
    assert node is not None
    neighbor = node.prev()
    assert neighbor is not None
    assert neighbor.text() == "let b = 456"
    node = unwrap(root.find(pattern="let a = $A\n")).prev()
    assert node # `{` is the first node
    assert not node.prev()

def test_prev_all():
    node = root.find(pattern="let c = $A\n")
    assert node is not None
    prev_all = node.prev_all()
    assert len(prev_all) == 3
    assert len(prev_all[0].prev_all()) == 2
    assert prev_all[0].text() == "let b = 456"
    assert not prev_all[2].prev_all()


================================================
FILE: crates/pyo3/tests/test_wrong_usage.py
================================================
from ast_grep_py import SgRoot
import pytest

source = """
function test() {
  let a = 123
  let b = 456
  let c = 789
}
""".strip()
sg = SgRoot(source, "javascript")
root = sg.root()

def test_wrong_use_pattern_as_dict():
    with pytest.raises(TypeError):
        root.find("let $A = 123") # type: ignore

def test_get_unfound_match():
    node = root.find(pattern="let $A = 123")
    assert node is not None
    with pytest.raises(KeyError):
        node["B"]

# TODO: remove BaseException
def test_wrong_rule_key():
    with pytest.raises(Exception):
        root.find(pat="not") # type: ignore

def test_no_rule_key():
    with pytest.raises(ValueError):
        root.matches()
    with pytest.raises(ValueError):
        root.inside()
    with pytest.raises(ValueError):
        root.has()
    with pytest.raises(ValueError):
        root.follows()
    with pytest.raises(ValueError):
        root.follows()

def test_error_for_invalid_kind():
    with pytest.raises(RuntimeError):
        root.find(kind="nonsense")

def test_no_error_for_invalid_pattern():
    with pytest.raises(RuntimeError):
        root.find(pattern="$@!!--l3**+no//nsense")
    # but not this
    assert not root.find(pattern="@test")


================================================
FILE: npm/README.md
================================================
# @ast-grep/cli

<p align=center>
  <img src="https://ast-grep.github.io/logo.svg" alt="ast-grep"/>
</p>

## ast-grep(sg)

ast-grep(sg) is a CLI tool for code structural search, lint, and rewriting.

Please see [ast-grep's official site](https://ast-grep.github.io/) and [repository](https://github.com/ast-grep/ast-grep)
for more information.


================================================
FILE: npm/ast-grep
================================================
echo "ast-grep shim file was executed. This file exists so that npm tries to create the binary. It should be replaced after the 'postinstall' script is executed."
echo "Did your package manager execute the post-install script? (N.B. not all of them do)"
exit 1



================================================
FILE: npm/package.json
================================================
{
  "name": "@ast-grep/cli",
  "version": "0.39.5",
  "publishConfig": {
    "access": "public"
  },
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "homepage": "https://ast-grep.github.io",
  "repository": "https://github.com/ast-grep/ast-grep",
  "engines": {
    "node": ">= 12.0.0"
  },
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "files": [
    "sg",
    "ast-grep",
    "postinstall.js"
  ],
  "dependencies": {
    "detect-libc": "2.1.0"
  },
  "scripts": {
    "postinstall": "node postinstall.js"
  },
  "optionalDependencies": {
    "@ast-grep/cli-win32-arm64-msvc": "0.39.5",
    "@ast-grep/cli-win32-ia32-msvc": "0.39.5",
    "@ast-grep/cli-win32-x64-msvc": "0.39.5",
    "@ast-grep/cli-darwin-arm64": "0.39.5",
    "@ast-grep/cli-darwin-x64": "0.39.5",
    "@ast-grep/cli-linux-arm64-gnu": "0.39.5",
    "@ast-grep/cli-linux-x64-gnu": "0.39.5"
  },
  "bin": {
    "sg": "sg",
    "ast-grep": "ast-grep"
  }
}


================================================
FILE: npm/postinstall.js
================================================
let fs = require('fs');
let path = require('path');

let parts = [process.platform, process.arch];
if (process.platform === 'linux') {
  const {MUSL, familySync} = require('detect-libc');
  if (familySync() === MUSL) {
    parts.push('musl');
  } else if (process.arch === 'arm') {
    parts.push('gnueabihf');
  } else {
    parts.push('gnu');
  }
} else if (process.platform === 'win32') {
  parts.push('msvc');
}

let binary = process.platform === 'win32' ? 'ast-grep.exe' : 'ast-grep';
let alternative = process.platform === 'win32' ? 'sg.exe' : 'sg';

let pkgPath;
try {
  pkgPath = path.dirname(require.resolve(`@ast-grep/cli-${parts.join('-')}/package.json`));
} catch (err) {
  pkgPath = path.join(__dirname, '..', 'target', 'release');
  if (!fs.existsSync(path.join(pkgPath, binary))) {
    pkgPath = path.join(__dirname, '..', 'target', 'debug');
  }
}

try {
  fs.linkSync(path.join(pkgPath, binary), path.join(__dirname, binary));
  fs.linkSync(path.join(pkgPath, binary), path.join(__dirname, alternative));
} catch (err) {
  try {
    fs.copyFileSync(path.join(pkgPath, binary), path.join(__dirname, binary));
    fs.copyFileSync(path.join(pkgPath, binary), path.join(__dirname, alternative));
  } catch (err) {
    console.error('Failed to move @ast-grep/cli binary into place.');
    process.exit(1);
  }
}

if (process.platform === 'win32') {
  try {
    fs.unlinkSync(path.join(__dirname, 'sg'));
    fs.unlinkSync(path.join(__dirname, 'ast-grep'));
  } catch (err) {}
}



================================================
FILE: npm/sg
================================================
This file is required so that dumb npm creates the sg binary.
N.B. pnpm does not have this issue.



================================================
FILE: npm/platforms/darwin-arm64/README.md
================================================
# `@ast-grep/cli-darwin-arm64`

This is the **aarch64-apple-darwin** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/darwin-arm64/package.json
================================================
{
  "name": "@ast-grep/cli-darwin-arm64",
  "version": "0.39.5",
  "os": [
    "darwin"
  ],
  "cpu": [
    "arm64"
  ],
  "files": [
    "ast-grep"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/darwin-x64/README.md
================================================
# `@ast-grep/cli-darwin-x64`

This is the **x86_64-apple-darwin** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/darwin-x64/package.json
================================================
{
  "name": "@ast-grep/cli-darwin-x64",
  "version": "0.39.5",
  "os": [
    "darwin"
  ],
  "cpu": [
    "x64"
  ],
  "files": [
    "ast-grep"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/linux-arm64-gnu/README.md
================================================
# `@ast-grep/cli-linux-arm64-gnu`

This is the **aarch64-unknown-linux-gnu** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/linux-arm64-gnu/package.json
================================================
{
  "name": "@ast-grep/cli-linux-arm64-gnu",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "arm64"
  ],
  "libc": [
    "glibc"
  ],
  "files": [
    "ast-grep"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/linux-x64-gnu/README.md
================================================
# `@ast-grep/cli-linux-x64-gnu`

This is the **x86_64-unknown-linux-gnu** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/linux-x64-gnu/package.json
================================================
{
  "name": "@ast-grep/cli-linux-x64-gnu",
  "version": "0.39.5",
  "os": [
    "linux"
  ],
  "cpu": [
    "x64"
  ],
  "libc": [
    "glibc"
  ],
  "files": [
    "ast-grep"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/win32-arm64-msvc/README.md
================================================
# `@ast-grep/cli-win32-arm64-msvc`

This is the **aarch64-pc-windows-msvc** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/win32-arm64-msvc/package.json
================================================
{
  "name": "@ast-grep/cli-win32-arm64-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "arm64"
  ],
  "files": [
    "ast-grep.exe"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/win32-ia32-msvc/README.md
================================================
# `@ast-grep/cli-win32-ia32-msvc`

This is the **i686-pc-windows-msvc** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/win32-ia32-msvc/package.json
================================================
{
  "name": "@ast-grep/cli-win32-ia32-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "ia32"
  ],
  "files": [
    "ast-grep.exe"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: npm/platforms/win32-x64-msvc/README.md
================================================
# `@ast-grep/cli-win32-x64-msvc`

This is the **x86_64-pc-windows-msvc** binary for `@ast-grep/cli`



================================================
FILE: npm/platforms/win32-x64-msvc/package.json
================================================
{
  "name": "@ast-grep/cli-win32-x64-msvc",
  "version": "0.39.5",
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ],
  "files": [
    "ast-grep.exe"
  ],
  "description": "Search and Rewrite code at large scale using precise AST pattern",
  "keywords": [
    "ast",
    "pattern",
    "codemod",
    "search",
    "rewrite"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "repository": "https://github.com/ast-grep/ast-grep"
}


================================================
FILE: schemas/bash_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for bash",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "ansi_c_string",
            "arithmetic_expansion",
            "array",
            "binary_expression",
            "brace_expression",
            "c_style_for_statement",
            "case_item",
            "case_statement",
            "command",
            "command_name",
            "command_substitution",
            "comment",
            "compound_statement",
            "concatenation",
            "declaration_command",
            "do_group",
            "elif_clause",
            "else_clause",
            "expansion",
            "extglob_pattern",
            "file_descriptor",
            "file_redirect",
            "for_statement",
            "function_definition",
            "heredoc_body",
            "heredoc_content",
            "heredoc_end",
            "heredoc_redirect",
            "heredoc_start",
            "herestring_redirect",
            "if_statement",
            "list",
            "negated_command",
            "number",
            "parenthesized_expression",
            "pipeline",
            "postfix_expression",
            "process_substitution",
            "program",
            "raw_string",
            "redirected_statement",
            "regex",
            "simple_expansion",
            "special_variable_name",
            "string",
            "string_content",
            "subscript",
            "subshell",
            "ternary_expression",
            "test_command",
            "test_operator",
            "translated_string",
            "unary_expression",
            "unset_command",
            "variable_assignment",
            "variable_assignments",
            "variable_name",
            "while_statement",
            "word"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "ansi_c_string",
            "arithmetic_expansion",
            "array",
            "binary_expression",
            "brace_expression",
            "c_style_for_statement",
            "case_item",
            "case_statement",
            "command",
            "command_name",
            "command_substitution",
            "comment",
            "compound_statement",
            "concatenation",
            "declaration_command",
            "do_group",
            "elif_clause",
            "else_clause",
            "expansion",
            "extglob_pattern",
            "file_descriptor",
            "file_redirect",
            "for_statement",
            "function_definition",
            "heredoc_body",
            "heredoc_content",
            "heredoc_end",
            "heredoc_redirect",
            "heredoc_start",
            "herestring_redirect",
            "if_statement",
            "list",
            "negated_command",
            "number",
            "parenthesized_expression",
            "pipeline",
            "postfix_expression",
            "process_substitution",
            "program",
            "raw_string",
            "redirected_statement",
            "regex",
            "simple_expansion",
            "special_variable_name",
            "string",
            "string_content",
            "subscript",
            "subshell",
            "ternary_expression",
            "test_command",
            "test_operator",
            "translated_string",
            "unary_expression",
            "unset_command",
            "variable_assignment",
            "variable_assignments",
            "variable_name",
            "while_statement",
            "word"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "argument",
            "body",
            "condition",
            "consequence",
            "descriptor",
            "destination",
            "fallthrough",
            "index",
            "initializer",
            "left",
            "name",
            "operator",
            "redirect",
            "right",
            "termination",
            "update",
            "value"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "bash",
        "Bash"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/c_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for c",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_array_declarator",
            "abstract_function_declarator",
            "abstract_parenthesized_declarator",
            "abstract_pointer_declarator",
            "alignas_qualifier",
            "alignof_expression",
            "argument_list",
            "array_declarator",
            "assignment_expression",
            "attribute",
            "attribute_declaration",
            "attribute_specifier",
            "attributed_declarator",
            "attributed_statement",
            "binary_expression",
            "bitfield_clause",
            "break_statement",
            "call_expression",
            "case_statement",
            "cast_expression",
            "char_literal",
            "character",
            "comma_expression",
            "comment",
            "compound_literal_expression",
            "compound_statement",
            "concatenated_string",
            "conditional_expression",
            "continue_statement",
            "declaration",
            "declaration_list",
            "do_statement",
            "else_clause",
            "enum_specifier",
            "enumerator",
            "enumerator_list",
            "escape_sequence",
            "expression_statement",
            "extension_expression",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_designator",
            "field_expression",
            "field_identifier",
            "for_statement",
            "function_declarator",
            "function_definition",
            "generic_expression",
            "gnu_asm_clobber_list",
            "gnu_asm_expression",
            "gnu_asm_goto_list",
            "gnu_asm_input_operand",
            "gnu_asm_input_operand_list",
            "gnu_asm_output_operand",
            "gnu_asm_output_operand_list",
            "gnu_asm_qualifier",
            "goto_statement",
            "identifier",
            "if_statement",
            "init_declarator",
            "initializer_list",
            "initializer_pair",
            "labeled_statement",
            "linkage_specification",
            "macro_type_specifier",
            "ms_based_modifier",
            "ms_call_modifier",
            "ms_declspec_modifier",
            "ms_pointer_modifier",
            "ms_restrict_modifier",
            "ms_signed_ptr_modifier",
            "ms_unaligned_ptr_modifier",
            "ms_unsigned_ptr_modifier",
            "null",
            "number_literal",
            "offsetof_expression",
            "parameter_declaration",
            "parameter_list",
            "parenthesized_declarator",
            "parenthesized_expression",
            "pointer_declarator",
            "pointer_expression",
            "preproc_arg",
            "preproc_call",
            "preproc_def",
            "preproc_defined",
            "preproc_directive",
            "preproc_elif",
            "preproc_elifdef",
            "preproc_else",
            "preproc_function_def",
            "preproc_if",
            "preproc_ifdef",
            "preproc_include",
            "preproc_params",
            "primitive_type",
            "return_statement",
            "seh_except_clause",
            "seh_finally_clause",
            "seh_leave_statement",
            "seh_try_statement",
            "sized_type_specifier",
            "sizeof_expression",
            "statement_identifier",
            "storage_class_specifier",
            "string_content",
            "string_literal",
            "struct_specifier",
            "subscript_designator",
            "subscript_expression",
            "subscript_range_designator",
            "switch_statement",
            "system_lib_string",
            "translation_unit",
            "true",
            "type_definition",
            "type_descriptor",
            "type_identifier",
            "type_qualifier",
            "unary_expression",
            "union_specifier",
            "update_expression",
            "variadic_parameter",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_array_declarator",
            "abstract_function_declarator",
            "abstract_parenthesized_declarator",
            "abstract_pointer_declarator",
            "alignas_qualifier",
            "alignof_expression",
            "argument_list",
            "array_declarator",
            "assignment_expression",
            "attribute",
            "attribute_declaration",
            "attribute_specifier",
            "attributed_declarator",
            "attributed_statement",
            "binary_expression",
            "bitfield_clause",
            "break_statement",
            "call_expression",
            "case_statement",
            "cast_expression",
            "char_literal",
            "character",
            "comma_expression",
            "comment",
            "compound_literal_expression",
            "compound_statement",
            "concatenated_string",
            "conditional_expression",
            "continue_statement",
            "declaration",
            "declaration_list",
            "do_statement",
            "else_clause",
            "enum_specifier",
            "enumerator",
            "enumerator_list",
            "escape_sequence",
            "expression_statement",
            "extension_expression",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_designator",
            "field_expression",
            "field_identifier",
            "for_statement",
            "function_declarator",
            "function_definition",
            "generic_expression",
            "gnu_asm_clobber_list",
            "gnu_asm_expression",
            "gnu_asm_goto_list",
            "gnu_asm_input_operand",
            "gnu_asm_input_operand_list",
            "gnu_asm_output_operand",
            "gnu_asm_output_operand_list",
            "gnu_asm_qualifier",
            "goto_statement",
            "identifier",
            "if_statement",
            "init_declarator",
            "initializer_list",
            "initializer_pair",
            "labeled_statement",
            "linkage_specification",
            "macro_type_specifier",
            "ms_based_modifier",
            "ms_call_modifier",
            "ms_declspec_modifier",
            "ms_pointer_modifier",
            "ms_restrict_modifier",
            "ms_signed_ptr_modifier",
            "ms_unaligned_ptr_modifier",
            "ms_unsigned_ptr_modifier",
            "null",
            "number_literal",
            "offsetof_expression",
            "parameter_declaration",
            "parameter_list",
            "parenthesized_declarator",
            "parenthesized_expression",
            "pointer_declarator",
            "pointer_expression",
            "preproc_arg",
            "preproc_call",
            "preproc_def",
            "preproc_defined",
            "preproc_directive",
            "preproc_elif",
            "preproc_elifdef",
            "preproc_else",
            "preproc_function_def",
            "preproc_if",
            "preproc_ifdef",
            "preproc_include",
            "preproc_params",
            "primitive_type",
            "return_statement",
            "seh_except_clause",
            "seh_finally_clause",
            "seh_leave_statement",
            "seh_try_statement",
            "sized_type_specifier",
            "sizeof_expression",
            "statement_identifier",
            "storage_class_specifier",
            "string_content",
            "string_literal",
            "struct_specifier",
            "subscript_designator",
            "subscript_expression",
            "subscript_range_designator",
            "switch_statement",
            "system_lib_string",
            "translation_unit",
            "true",
            "type_definition",
            "type_descriptor",
            "type_identifier",
            "type_qualifier",
            "unary_expression",
            "union_specifier",
            "update_expression",
            "variadic_parameter",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "argument",
            "arguments",
            "assembly_code",
            "body",
            "clobbers",
            "condition",
            "consequence",
            "constraint",
            "declarator",
            "designator",
            "directive",
            "end",
            "field",
            "filter",
            "function",
            "goto_labels",
            "index",
            "initializer",
            "input_operands",
            "label",
            "left",
            "member",
            "name",
            "operand",
            "operator",
            "output_operands",
            "parameters",
            "path",
            "prefix",
            "register",
            "right",
            "size",
            "start",
            "symbol",
            "type",
            "underlying_type",
            "update"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "c",
        "C"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/cpp_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for cpp",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_array_declarator",
            "abstract_function_declarator",
            "abstract_parenthesized_declarator",
            "abstract_pointer_declarator",
            "abstract_reference_declarator",
            "access_specifier",
            "alias_declaration",
            "alignas_qualifier",
            "alignof_expression",
            "argument_list",
            "array_declarator",
            "assignment_expression",
            "attribute",
            "attribute_declaration",
            "attribute_specifier",
            "attributed_declarator",
            "attributed_statement",
            "auto",
            "base_class_clause",
            "binary_expression",
            "bitfield_clause",
            "break_statement",
            "call_expression",
            "case_statement",
            "cast_expression",
            "catch_clause",
            "char_literal",
            "character",
            "class_specifier",
            "co_await_expression",
            "co_return_statement",
            "co_yield_statement",
            "comma_expression",
            "comment",
            "compound_literal_expression",
            "compound_requirement",
            "compound_statement",
            "concatenated_string",
            "concept_definition",
            "condition_clause",
            "conditional_expression",
            "constraint_conjunction",
            "constraint_disjunction",
            "continue_statement",
            "declaration",
            "declaration_list",
            "decltype",
            "default_method_clause",
            "delete_expression",
            "delete_method_clause",
            "dependent_name",
            "dependent_type",
            "destructor_name",
            "do_statement",
            "else_clause",
            "enum_specifier",
            "enumerator",
            "enumerator_list",
            "escape_sequence",
            "explicit_function_specifier",
            "expression_statement",
            "extension_expression",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_designator",
            "field_expression",
            "field_identifier",
            "field_initializer",
            "field_initializer_list",
            "fold_expression",
            "for_range_loop",
            "for_statement",
            "friend_declaration",
            "function_declarator",
            "function_definition",
            "generic_expression",
            "gnu_asm_clobber_list",
            "gnu_asm_expression",
            "gnu_asm_goto_list",
            "gnu_asm_input_operand",
            "gnu_asm_input_operand_list",
            "gnu_asm_output_operand",
            "gnu_asm_output_operand_list",
            "gnu_asm_qualifier",
            "goto_statement",
            "identifier",
            "if_statement",
            "init_declarator",
            "init_statement",
            "initializer_list",
            "initializer_pair",
            "labeled_statement",
            "lambda_capture_initializer",
            "lambda_capture_specifier",
            "lambda_default_capture",
            "lambda_expression",
            "linkage_specification",
            "literal_suffix",
            "ms_based_modifier",
            "ms_call_modifier",
            "ms_declspec_modifier",
            "ms_pointer_modifier",
            "ms_restrict_modifier",
            "ms_signed_ptr_modifier",
            "ms_unaligned_ptr_modifier",
            "ms_unsigned_ptr_modifier",
            "namespace_alias_definition",
            "namespace_definition",
            "namespace_identifier",
            "nested_namespace_specifier",
            "new_declarator",
            "new_expression",
            "noexcept",
            "null",
            "number_literal",
            "offsetof_expression",
            "operator_cast",
            "operator_name",
            "optional_parameter_declaration",
            "optional_type_parameter_declaration",
            "parameter_declaration",
            "parameter_list",
            "parameter_pack_expansion",
            "parenthesized_declarator",
            "parenthesized_expression",
            "placeholder_type_specifier",
            "pointer_declarator",
            "pointer_expression",
            "pointer_type_declarator",
            "preproc_arg",
            "preproc_call",
            "preproc_def",
            "preproc_defined",
            "preproc_directive",
            "preproc_elif",
            "preproc_elifdef",
            "preproc_else",
            "preproc_function_def",
            "preproc_if",
            "preproc_ifdef",
            "preproc_include",
            "preproc_params",
            "primitive_type",
            "pure_virtual_clause",
            "qualified_identifier",
            "raw_string_content",
            "raw_string_delimiter",
            "raw_string_literal",
            "ref_qualifier",
            "reference_declarator",
            "requirement_seq",
            "requires_clause",
            "requires_expression",
            "return_statement",
            "seh_except_clause",
            "seh_finally_clause",
            "seh_leave_statement",
            "seh_try_statement",
            "simple_requirement",
            "sized_type_specifier",
            "sizeof_expression",
            "statement_identifier",
            "static_assert_declaration",
            "storage_class_specifier",
            "string_content",
            "string_literal",
            "struct_specifier",
            "structured_binding_declarator",
            "subscript_argument_list",
            "subscript_designator",
            "subscript_expression",
            "subscript_range_designator",
            "switch_statement",
            "system_lib_string",
            "template_argument_list",
            "template_declaration",
            "template_function",
            "template_instantiation",
            "template_method",
            "template_parameter_list",
            "template_template_parameter_declaration",
            "template_type",
            "this",
            "throw_specifier",
            "throw_statement",
            "trailing_return_type",
            "translation_unit",
            "true",
            "try_statement",
            "type_definition",
            "type_descriptor",
            "type_identifier",
            "type_parameter_declaration",
            "type_qualifier",
            "type_requirement",
            "unary_expression",
            "union_specifier",
            "update_expression",
            "user_defined_literal",
            "using_declaration",
            "variadic_declarator",
            "variadic_parameter_declaration",
            "variadic_type_parameter_declaration",
            "virtual_specifier",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_array_declarator",
            "abstract_function_declarator",
            "abstract_parenthesized_declarator",
            "abstract_pointer_declarator",
            "abstract_reference_declarator",
            "access_specifier",
            "alias_declaration",
            "alignas_qualifier",
            "alignof_expression",
            "argument_list",
            "array_declarator",
            "assignment_expression",
            "attribute",
            "attribute_declaration",
            "attribute_specifier",
            "attributed_declarator",
            "attributed_statement",
            "auto",
            "base_class_clause",
            "binary_expression",
            "bitfield_clause",
            "break_statement",
            "call_expression",
            "case_statement",
            "cast_expression",
            "catch_clause",
            "char_literal",
            "character",
            "class_specifier",
            "co_await_expression",
            "co_return_statement",
            "co_yield_statement",
            "comma_expression",
            "comment",
            "compound_literal_expression",
            "compound_requirement",
            "compound_statement",
            "concatenated_string",
            "concept_definition",
            "condition_clause",
            "conditional_expression",
            "constraint_conjunction",
            "constraint_disjunction",
            "continue_statement",
            "declaration",
            "declaration_list",
            "decltype",
            "default_method_clause",
            "delete_expression",
            "delete_method_clause",
            "dependent_name",
            "dependent_type",
            "destructor_name",
            "do_statement",
            "else_clause",
            "enum_specifier",
            "enumerator",
            "enumerator_list",
            "escape_sequence",
            "explicit_function_specifier",
            "expression_statement",
            "extension_expression",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_designator",
            "field_expression",
            "field_identifier",
            "field_initializer",
            "field_initializer_list",
            "fold_expression",
            "for_range_loop",
            "for_statement",
            "friend_declaration",
            "function_declarator",
            "function_definition",
            "generic_expression",
            "gnu_asm_clobber_list",
            "gnu_asm_expression",
            "gnu_asm_goto_list",
            "gnu_asm_input_operand",
            "gnu_asm_input_operand_list",
            "gnu_asm_output_operand",
            "gnu_asm_output_operand_list",
            "gnu_asm_qualifier",
            "goto_statement",
            "identifier",
            "if_statement",
            "init_declarator",
            "init_statement",
            "initializer_list",
            "initializer_pair",
            "labeled_statement",
            "lambda_capture_initializer",
            "lambda_capture_specifier",
            "lambda_default_capture",
            "lambda_expression",
            "linkage_specification",
            "literal_suffix",
            "ms_based_modifier",
            "ms_call_modifier",
            "ms_declspec_modifier",
            "ms_pointer_modifier",
            "ms_restrict_modifier",
            "ms_signed_ptr_modifier",
            "ms_unaligned_ptr_modifier",
            "ms_unsigned_ptr_modifier",
            "namespace_alias_definition",
            "namespace_definition",
            "namespace_identifier",
            "nested_namespace_specifier",
            "new_declarator",
            "new_expression",
            "noexcept",
            "null",
            "number_literal",
            "offsetof_expression",
            "operator_cast",
            "operator_name",
            "optional_parameter_declaration",
            "optional_type_parameter_declaration",
            "parameter_declaration",
            "parameter_list",
            "parameter_pack_expansion",
            "parenthesized_declarator",
            "parenthesized_expression",
            "placeholder_type_specifier",
            "pointer_declarator",
            "pointer_expression",
            "pointer_type_declarator",
            "preproc_arg",
            "preproc_call",
            "preproc_def",
            "preproc_defined",
            "preproc_directive",
            "preproc_elif",
            "preproc_elifdef",
            "preproc_else",
            "preproc_function_def",
            "preproc_if",
            "preproc_ifdef",
            "preproc_include",
            "preproc_params",
            "primitive_type",
            "pure_virtual_clause",
            "qualified_identifier",
            "raw_string_content",
            "raw_string_delimiter",
            "raw_string_literal",
            "ref_qualifier",
            "reference_declarator",
            "requirement_seq",
            "requires_clause",
            "requires_expression",
            "return_statement",
            "seh_except_clause",
            "seh_finally_clause",
            "seh_leave_statement",
            "seh_try_statement",
            "simple_requirement",
            "sized_type_specifier",
            "sizeof_expression",
            "statement_identifier",
            "static_assert_declaration",
            "storage_class_specifier",
            "string_content",
            "string_literal",
            "struct_specifier",
            "structured_binding_declarator",
            "subscript_argument_list",
            "subscript_designator",
            "subscript_expression",
            "subscript_range_designator",
            "switch_statement",
            "system_lib_string",
            "template_argument_list",
            "template_declaration",
            "template_function",
            "template_instantiation",
            "template_method",
            "template_parameter_list",
            "template_template_parameter_declaration",
            "template_type",
            "this",
            "throw_specifier",
            "throw_statement",
            "trailing_return_type",
            "translation_unit",
            "true",
            "try_statement",
            "type_definition",
            "type_descriptor",
            "type_identifier",
            "type_parameter_declaration",
            "type_qualifier",
            "type_requirement",
            "unary_expression",
            "union_specifier",
            "update_expression",
            "user_defined_literal",
            "using_declaration",
            "variadic_declarator",
            "variadic_parameter_declaration",
            "variadic_type_parameter_declaration",
            "virtual_specifier",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "argument",
            "arguments",
            "assembly_code",
            "base",
            "body",
            "captures",
            "clobbers",
            "condition",
            "consequence",
            "constraint",
            "declarator",
            "default_type",
            "default_value",
            "delimiter",
            "designator",
            "directive",
            "end",
            "field",
            "filter",
            "function",
            "goto_labels",
            "indices",
            "initializer",
            "input_operands",
            "label",
            "left",
            "length",
            "member",
            "message",
            "name",
            "operand",
            "operator",
            "output_operands",
            "parameters",
            "path",
            "pattern",
            "placement",
            "prefix",
            "register",
            "requirements",
            "right",
            "scope",
            "size",
            "start",
            "symbol",
            "template_parameters",
            "type",
            "update"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "cc",
        "c++",
        "cpp",
        "cxx",
        "Cpp"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/csharp_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for csharp",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "accessor_declaration",
            "accessor_list",
            "alias_qualified_name",
            "and_pattern",
            "anonymous_method_expression",
            "anonymous_object_creation_expression",
            "argument",
            "argument_list",
            "array_creation_expression",
            "array_rank_specifier",
            "array_type",
            "arrow_expression_clause",
            "as_expression",
            "assignment_expression",
            "attribute",
            "attribute_argument",
            "attribute_argument_list",
            "attribute_list",
            "attribute_target_specifier",
            "await_expression",
            "base_list",
            "binary_expression",
            "block",
            "boolean_literal",
            "bracketed_argument_list",
            "bracketed_parameter_list",
            "break_statement",
            "calling_convention",
            "cast_expression",
            "catch_clause",
            "catch_declaration",
            "catch_filter_clause",
            "character_literal",
            "character_literal_content",
            "checked_expression",
            "checked_statement",
            "class_declaration",
            "comment",
            "compilation_unit",
            "conditional_access_expression",
            "conditional_expression",
            "constant_pattern",
            "constructor_constraint",
            "constructor_declaration",
            "constructor_initializer",
            "continue_statement",
            "conversion_operator_declaration",
            "declaration_expression",
            "declaration_list",
            "declaration_pattern",
            "default_expression",
            "delegate_declaration",
            "destructor_declaration",
            "discard",
            "do_statement",
            "element_access_expression",
            "element_binding_expression",
            "empty_statement",
            "enum_declaration",
            "enum_member_declaration",
            "enum_member_declaration_list",
            "escape_sequence",
            "event_declaration",
            "event_field_declaration",
            "explicit_interface_specifier",
            "expression_statement",
            "extern_alias_directive",
            "field_declaration",
            "file_scoped_namespace_declaration",
            "finally_clause",
            "fixed_statement",
            "for_statement",
            "foreach_statement",
            "from_clause",
            "function_pointer_parameter",
            "function_pointer_type",
            "generic_name",
            "global_attribute",
            "global_statement",
            "goto_statement",
            "group_clause",
            "identifier",
            "if_statement",
            "implicit_array_creation_expression",
            "implicit_object_creation_expression",
            "implicit_parameter",
            "implicit_stackalloc_expression",
            "implicit_type",
            "indexer_declaration",
            "initializer_expression",
            "integer_literal",
            "interface_declaration",
            "interpolated_string_expression",
            "interpolation",
            "interpolation_alignment_clause",
            "interpolation_brace",
            "interpolation_format_clause",
            "interpolation_quote",
            "interpolation_start",
            "invocation_expression",
            "is_expression",
            "is_pattern_expression",
            "join_clause",
            "join_into_clause",
            "labeled_statement",
            "lambda_expression",
            "let_clause",
            "list_pattern",
            "local_declaration_statement",
            "local_function_statement",
            "lock_statement",
            "makeref_expression",
            "member_access_expression",
            "member_binding_expression",
            "method_declaration",
            "modifier",
            "namespace_declaration",
            "negated_pattern",
            "null_literal",
            "nullable_type",
            "object_creation_expression",
            "operator_declaration",
            "or_pattern",
            "order_by_clause",
            "parameter",
            "parameter_list",
            "parenthesized_expression",
            "parenthesized_pattern",
            "parenthesized_variable_designation",
            "pointer_type",
            "positional_pattern_clause",
            "postfix_unary_expression",
            "predefined_type",
            "prefix_unary_expression",
            "preproc_arg",
            "preproc_define",
            "preproc_elif",
            "preproc_else",
            "preproc_endregion",
            "preproc_error",
            "preproc_if",
            "preproc_line",
            "preproc_nullable",
            "preproc_pragma",
            "preproc_region",
            "preproc_undef",
            "preproc_warning",
            "primary_constructor_base_type",
            "property_declaration",
            "property_pattern_clause",
            "qualified_name",
            "query_expression",
            "range_expression",
            "raw_string_content",
            "raw_string_end",
            "raw_string_literal",
            "raw_string_start",
            "real_literal",
            "record_declaration",
            "recursive_pattern",
            "ref_expression",
            "ref_type",
            "reftype_expression",
            "refvalue_expression",
            "relational_pattern",
            "return_statement",
            "scoped_type",
            "select_clause",
            "shebang_directive",
            "sizeof_expression",
            "stackalloc_expression",
            "string_content",
            "string_literal",
            "string_literal_content",
            "string_literal_encoding",
            "struct_declaration",
            "subpattern",
            "switch_body",
            "switch_expression",
            "switch_expression_arm",
            "switch_section",
            "switch_statement",
            "throw_expression",
            "throw_statement",
            "try_statement",
            "tuple_element",
            "tuple_expression",
            "tuple_pattern",
            "tuple_type",
            "type_argument_list",
            "type_parameter",
            "type_parameter_constraint",
            "type_parameter_constraints_clause",
            "type_parameter_list",
            "type_pattern",
            "typeof_expression",
            "unary_expression",
            "unsafe_statement",
            "using_directive",
            "using_statement",
            "var_pattern",
            "variable_declaration",
            "variable_declarator",
            "verbatim_string_literal",
            "when_clause",
            "where_clause",
            "while_statement",
            "with_expression",
            "with_initializer",
            "yield_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "accessor_declaration",
            "accessor_list",
            "alias_qualified_name",
            "and_pattern",
            "anonymous_method_expression",
            "anonymous_object_creation_expression",
            "argument",
            "argument_list",
            "array_creation_expression",
            "array_rank_specifier",
            "array_type",
            "arrow_expression_clause",
            "as_expression",
            "assignment_expression",
            "attribute",
            "attribute_argument",
            "attribute_argument_list",
            "attribute_list",
            "attribute_target_specifier",
            "await_expression",
            "base_list",
            "binary_expression",
            "block",
            "boolean_literal",
            "bracketed_argument_list",
            "bracketed_parameter_list",
            "break_statement",
            "calling_convention",
            "cast_expression",
            "catch_clause",
            "catch_declaration",
            "catch_filter_clause",
            "character_literal",
            "character_literal_content",
            "checked_expression",
            "checked_statement",
            "class_declaration",
            "comment",
            "compilation_unit",
            "conditional_access_expression",
            "conditional_expression",
            "constant_pattern",
            "constructor_constraint",
            "constructor_declaration",
            "constructor_initializer",
            "continue_statement",
            "conversion_operator_declaration",
            "declaration_expression",
            "declaration_list",
            "declaration_pattern",
            "default_expression",
            "delegate_declaration",
            "destructor_declaration",
            "discard",
            "do_statement",
            "element_access_expression",
            "element_binding_expression",
            "empty_statement",
            "enum_declaration",
            "enum_member_declaration",
            "enum_member_declaration_list",
            "escape_sequence",
            "event_declaration",
            "event_field_declaration",
            "explicit_interface_specifier",
            "expression_statement",
            "extern_alias_directive",
            "field_declaration",
            "file_scoped_namespace_declaration",
            "finally_clause",
            "fixed_statement",
            "for_statement",
            "foreach_statement",
            "from_clause",
            "function_pointer_parameter",
            "function_pointer_type",
            "generic_name",
            "global_attribute",
            "global_statement",
            "goto_statement",
            "group_clause",
            "identifier",
            "if_statement",
            "implicit_array_creation_expression",
            "implicit_object_creation_expression",
            "implicit_parameter",
            "implicit_stackalloc_expression",
            "implicit_type",
            "indexer_declaration",
            "initializer_expression",
            "integer_literal",
            "interface_declaration",
            "interpolated_string_expression",
            "interpolation",
            "interpolation_alignment_clause",
            "interpolation_brace",
            "interpolation_format_clause",
            "interpolation_quote",
            "interpolation_start",
            "invocation_expression",
            "is_expression",
            "is_pattern_expression",
            "join_clause",
            "join_into_clause",
            "labeled_statement",
            "lambda_expression",
            "let_clause",
            "list_pattern",
            "local_declaration_statement",
            "local_function_statement",
            "lock_statement",
            "makeref_expression",
            "member_access_expression",
            "member_binding_expression",
            "method_declaration",
            "modifier",
            "namespace_declaration",
            "negated_pattern",
            "null_literal",
            "nullable_type",
            "object_creation_expression",
            "operator_declaration",
            "or_pattern",
            "order_by_clause",
            "parameter",
            "parameter_list",
            "parenthesized_expression",
            "parenthesized_pattern",
            "parenthesized_variable_designation",
            "pointer_type",
            "positional_pattern_clause",
            "postfix_unary_expression",
            "predefined_type",
            "prefix_unary_expression",
            "preproc_arg",
            "preproc_define",
            "preproc_elif",
            "preproc_else",
            "preproc_endregion",
            "preproc_error",
            "preproc_if",
            "preproc_line",
            "preproc_nullable",
            "preproc_pragma",
            "preproc_region",
            "preproc_undef",
            "preproc_warning",
            "primary_constructor_base_type",
            "property_declaration",
            "property_pattern_clause",
            "qualified_name",
            "query_expression",
            "range_expression",
            "raw_string_content",
            "raw_string_end",
            "raw_string_literal",
            "raw_string_start",
            "real_literal",
            "record_declaration",
            "recursive_pattern",
            "ref_expression",
            "ref_type",
            "reftype_expression",
            "refvalue_expression",
            "relational_pattern",
            "return_statement",
            "scoped_type",
            "select_clause",
            "shebang_directive",
            "sizeof_expression",
            "stackalloc_expression",
            "string_content",
            "string_literal",
            "string_literal_content",
            "string_literal_encoding",
            "struct_declaration",
            "subpattern",
            "switch_body",
            "switch_expression",
            "switch_expression_arm",
            "switch_section",
            "switch_statement",
            "throw_expression",
            "throw_statement",
            "try_statement",
            "tuple_element",
            "tuple_expression",
            "tuple_pattern",
            "tuple_type",
            "type_argument_list",
            "type_parameter",
            "type_parameter_constraint",
            "type_parameter_constraints_clause",
            "type_parameter_list",
            "type_pattern",
            "typeof_expression",
            "unary_expression",
            "unsafe_statement",
            "using_directive",
            "using_statement",
            "var_pattern",
            "variable_declaration",
            "variable_declarator",
            "verbatim_string_literal",
            "when_clause",
            "where_clause",
            "while_statement",
            "with_expression",
            "with_initializer",
            "yield_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "accessors",
            "alias",
            "alternative",
            "argument",
            "arguments",
            "body",
            "condition",
            "consequence",
            "content",
            "expression",
            "function",
            "initializer",
            "left",
            "name",
            "operator",
            "parameters",
            "pattern",
            "qualifier",
            "rank",
            "returns",
            "right",
            "subscript",
            "type",
            "type_parameters",
            "update"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "cs",
        "csharp",
        "CSharp"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/css_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for css",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "adjacent_sibling_selector",
            "arguments",
            "at_keyword",
            "at_rule",
            "attribute_name",
            "attribute_selector",
            "binary_expression",
            "binary_query",
            "block",
            "call_expression",
            "charset_statement",
            "child_selector",
            "class_name",
            "class_selector",
            "color_value",
            "comment",
            "declaration",
            "descendant_selector",
            "escape_sequence",
            "feature_name",
            "feature_query",
            "float_value",
            "from",
            "function_name",
            "grid_value",
            "id_name",
            "id_selector",
            "identifier",
            "import_statement",
            "important",
            "integer_value",
            "js_comment",
            "keyframe_block",
            "keyframe_block_list",
            "keyframes_name",
            "keyframes_statement",
            "keyword_query",
            "media_statement",
            "namespace_name",
            "namespace_selector",
            "namespace_statement",
            "nesting_selector",
            "parenthesized_query",
            "parenthesized_value",
            "plain_value",
            "postcss_statement",
            "property_name",
            "pseudo_class_selector",
            "pseudo_element_selector",
            "rule_set",
            "selector_query",
            "selectors",
            "sibling_selector",
            "string_content",
            "string_value",
            "stylesheet",
            "supports_statement",
            "tag_name",
            "to",
            "unary_query",
            "unit",
            "universal_selector"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "adjacent_sibling_selector",
            "arguments",
            "at_keyword",
            "at_rule",
            "attribute_name",
            "attribute_selector",
            "binary_expression",
            "binary_query",
            "block",
            "call_expression",
            "charset_statement",
            "child_selector",
            "class_name",
            "class_selector",
            "color_value",
            "comment",
            "declaration",
            "descendant_selector",
            "escape_sequence",
            "feature_name",
            "feature_query",
            "float_value",
            "from",
            "function_name",
            "grid_value",
            "id_name",
            "id_selector",
            "identifier",
            "import_statement",
            "important",
            "integer_value",
            "js_comment",
            "keyframe_block",
            "keyframe_block_list",
            "keyframes_name",
            "keyframes_statement",
            "keyword_query",
            "media_statement",
            "namespace_name",
            "namespace_selector",
            "namespace_statement",
            "nesting_selector",
            "parenthesized_query",
            "parenthesized_value",
            "plain_value",
            "postcss_statement",
            "property_name",
            "pseudo_class_selector",
            "pseudo_element_selector",
            "rule_set",
            "selector_query",
            "selectors",
            "sibling_selector",
            "string_content",
            "string_value",
            "stylesheet",
            "supports_statement",
            "tag_name",
            "to",
            "unary_query",
            "unit",
            "universal_selector"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": []
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "css",
        "Css"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/elixir_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for elixir",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "access_call",
            "after_block",
            "alias",
            "anonymous_function",
            "arguments",
            "atom",
            "binary_operator",
            "bitstring",
            "block",
            "body",
            "boolean",
            "call",
            "catch_block",
            "char",
            "charlist",
            "comment",
            "do_block",
            "dot",
            "else_block",
            "escape_sequence",
            "float",
            "identifier",
            "integer",
            "interpolation",
            "keyword",
            "keywords",
            "list",
            "map",
            "map_content",
            "nil",
            "operator_identifier",
            "pair",
            "quoted_atom",
            "quoted_content",
            "quoted_keyword",
            "rescue_block",
            "sigil",
            "sigil_modifiers",
            "sigil_name",
            "source",
            "stab_clause",
            "string",
            "struct",
            "tuple",
            "unary_operator"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "access_call",
            "after_block",
            "alias",
            "anonymous_function",
            "arguments",
            "atom",
            "binary_operator",
            "bitstring",
            "block",
            "body",
            "boolean",
            "call",
            "catch_block",
            "char",
            "charlist",
            "comment",
            "do_block",
            "dot",
            "else_block",
            "escape_sequence",
            "float",
            "identifier",
            "integer",
            "interpolation",
            "keyword",
            "keywords",
            "list",
            "map",
            "map_content",
            "nil",
            "operator_identifier",
            "pair",
            "quoted_atom",
            "quoted_content",
            "quoted_keyword",
            "rescue_block",
            "sigil",
            "sigil_modifiers",
            "sigil_name",
            "source",
            "stab_clause",
            "string",
            "struct",
            "tuple",
            "unary_operator"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "key",
            "left",
            "operand",
            "operator",
            "quoted_end",
            "quoted_start",
            "right",
            "target"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "ex",
        "elixir",
        "Elixir"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/go_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for go",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "argument_list",
            "array_type",
            "assignment_statement",
            "binary_expression",
            "blank_identifier",
            "block",
            "break_statement",
            "call_expression",
            "channel_type",
            "comment",
            "communication_case",
            "composite_literal",
            "const_declaration",
            "const_spec",
            "continue_statement",
            "dec_statement",
            "default_case",
            "defer_statement",
            "dot",
            "empty_statement",
            "escape_sequence",
            "expression_case",
            "expression_list",
            "expression_statement",
            "expression_switch_statement",
            "fallthrough_statement",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_identifier",
            "float_literal",
            "for_clause",
            "for_statement",
            "func_literal",
            "function_declaration",
            "function_type",
            "generic_type",
            "go_statement",
            "goto_statement",
            "identifier",
            "if_statement",
            "imaginary_literal",
            "implicit_length_array_type",
            "import_declaration",
            "import_spec",
            "import_spec_list",
            "inc_statement",
            "index_expression",
            "int_literal",
            "interface_type",
            "interpreted_string_literal",
            "interpreted_string_literal_content",
            "iota",
            "keyed_element",
            "label_name",
            "labeled_statement",
            "literal_element",
            "literal_value",
            "map_type",
            "method_declaration",
            "method_elem",
            "negated_type",
            "nil",
            "package_clause",
            "package_identifier",
            "parameter_declaration",
            "parameter_list",
            "parenthesized_expression",
            "parenthesized_type",
            "pointer_type",
            "qualified_type",
            "range_clause",
            "raw_string_literal",
            "raw_string_literal_content",
            "receive_statement",
            "return_statement",
            "rune_literal",
            "select_statement",
            "selector_expression",
            "send_statement",
            "short_var_declaration",
            "slice_expression",
            "slice_type",
            "source_file",
            "struct_type",
            "true",
            "type_alias",
            "type_arguments",
            "type_assertion_expression",
            "type_case",
            "type_constraint",
            "type_conversion_expression",
            "type_declaration",
            "type_elem",
            "type_identifier",
            "type_instantiation_expression",
            "type_parameter_declaration",
            "type_parameter_list",
            "type_spec",
            "type_switch_statement",
            "unary_expression",
            "var_declaration",
            "var_spec",
            "var_spec_list",
            "variadic_argument",
            "variadic_parameter_declaration"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "argument_list",
            "array_type",
            "assignment_statement",
            "binary_expression",
            "blank_identifier",
            "block",
            "break_statement",
            "call_expression",
            "channel_type",
            "comment",
            "communication_case",
            "composite_literal",
            "const_declaration",
            "const_spec",
            "continue_statement",
            "dec_statement",
            "default_case",
            "defer_statement",
            "dot",
            "empty_statement",
            "escape_sequence",
            "expression_case",
            "expression_list",
            "expression_statement",
            "expression_switch_statement",
            "fallthrough_statement",
            "false",
            "field_declaration",
            "field_declaration_list",
            "field_identifier",
            "float_literal",
            "for_clause",
            "for_statement",
            "func_literal",
            "function_declaration",
            "function_type",
            "generic_type",
            "go_statement",
            "goto_statement",
            "identifier",
            "if_statement",
            "imaginary_literal",
            "implicit_length_array_type",
            "import_declaration",
            "import_spec",
            "import_spec_list",
            "inc_statement",
            "index_expression",
            "int_literal",
            "interface_type",
            "interpreted_string_literal",
            "interpreted_string_literal_content",
            "iota",
            "keyed_element",
            "label_name",
            "labeled_statement",
            "literal_element",
            "literal_value",
            "map_type",
            "method_declaration",
            "method_elem",
            "negated_type",
            "nil",
            "package_clause",
            "package_identifier",
            "parameter_declaration",
            "parameter_list",
            "parenthesized_expression",
            "parenthesized_type",
            "pointer_type",
            "qualified_type",
            "range_clause",
            "raw_string_literal",
            "raw_string_literal_content",
            "receive_statement",
            "return_statement",
            "rune_literal",
            "select_statement",
            "selector_expression",
            "send_statement",
            "short_var_declaration",
            "slice_expression",
            "slice_type",
            "source_file",
            "struct_type",
            "true",
            "type_alias",
            "type_arguments",
            "type_assertion_expression",
            "type_case",
            "type_constraint",
            "type_conversion_expression",
            "type_declaration",
            "type_elem",
            "type_identifier",
            "type_instantiation_expression",
            "type_parameter_declaration",
            "type_parameter_list",
            "type_spec",
            "type_switch_statement",
            "unary_expression",
            "var_declaration",
            "var_spec",
            "var_spec_list",
            "variadic_argument",
            "variadic_parameter_declaration"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "arguments",
            "body",
            "capacity",
            "channel",
            "communication",
            "condition",
            "consequence",
            "element",
            "end",
            "field",
            "function",
            "index",
            "initializer",
            "key",
            "label",
            "left",
            "length",
            "name",
            "operand",
            "operator",
            "package",
            "parameters",
            "path",
            "receiver",
            "result",
            "right",
            "start",
            "tag",
            "type",
            "type_arguments",
            "type_parameters",
            "update"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "go",
        "golang",
        "Go"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/haskell_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for haskell",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_family",
            "all_names",
            "alternative",
            "alternatives",
            "annotated",
            "apply",
            "arithmetic_sequence",
            "as",
            "associated_type",
            "bind",
            "binding_list",
            "boolean",
            "calling_convention",
            "case",
            "char",
            "children",
            "class",
            "class_declarations",
            "comment",
            "conditional",
            "constructor",
            "constructor_operator",
            "constructor_synonym",
            "constructor_synonyms",
            "context",
            "cpp",
            "data_constructor",
            "data_constructors",
            "data_family",
            "data_instance",
            "data_type",
            "declarations",
            "default_signature",
            "default_types",
            "deriving",
            "deriving_instance",
            "deriving_strategy",
            "do",
            "do_module",
            "empty_list",
            "entity",
            "equation",
            "equations",
            "error_sentinel",
            "exp",
            "explicit_type",
            "export",
            "exports",
            "field",
            "field_name",
            "field_path",
            "field_pattern",
            "field_update",
            "fields",
            "fixity",
            "float",
            "forall",
            "forall_required",
            "foreign_export",
            "foreign_import",
            "function",
            "function_head_parens",
            "fundep",
            "fundeps",
            "gadt_constructor",
            "gadt_constructors",
            "generator",
            "group",
            "guards",
            "haddock",
            "haskell",
            "header",
            "implicit_parameter",
            "implicit_variable",
            "import",
            "import_list",
            "import_name",
            "import_package",
            "imports",
            "inferred",
            "infix",
            "infix_id",
            "instance",
            "instance_declarations",
            "integer",
            "invisible",
            "irrefutable",
            "kind_application",
            "kind_signature",
            "label",
            "lambda",
            "lambda_case",
            "lambda_cases",
            "lazy_field",
            "left_section",
            "let",
            "let_in",
            "linear_function",
            "list",
            "list_comprehension",
            "literal",
            "local_binds",
            "match",
            "modifier",
            "module",
            "module_export",
            "module_id",
            "multi_way_if",
            "name",
            "namespace",
            "negation",
            "newtype",
            "newtype_constructor",
            "operator",
            "parens",
            "pattern_guard",
            "pattern_synonym",
            "patterns",
            "pragma",
            "prefix",
            "prefix_id",
            "prefix_list",
            "prefix_tuple",
            "prefix_unboxed_sum",
            "prefix_unboxed_tuple",
            "projection",
            "projection_selector",
            "promoted",
            "qualified",
            "qualifiers",
            "quantified_variables",
            "quasiquote",
            "quasiquote_body",
            "quote",
            "quoted_decls",
            "quoted_expression",
            "quoted_pattern",
            "quoted_type",
            "quoter",
            "rec",
            "record",
            "right_section",
            "role_annotation",
            "safety",
            "signature",
            "special",
            "splice",
            "star",
            "strict",
            "strict_field",
            "string",
            "th_quoted_name",
            "top_splice",
            "transform",
            "tuple",
            "type_application",
            "type_binder",
            "type_family",
            "type_family_injectivity",
            "type_family_result",
            "type_instance",
            "type_params",
            "type_patterns",
            "type_role",
            "type_synomym",
            "typed_quote",
            "unboxed_sum",
            "unboxed_tuple",
            "unboxed_unit",
            "unit",
            "variable",
            "via",
            "view_pattern",
            "wildcard"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_family",
            "all_names",
            "alternative",
            "alternatives",
            "annotated",
            "apply",
            "arithmetic_sequence",
            "as",
            "associated_type",
            "bind",
            "binding_list",
            "boolean",
            "calling_convention",
            "case",
            "char",
            "children",
            "class",
            "class_declarations",
            "comment",
            "conditional",
            "constructor",
            "constructor_operator",
            "constructor_synonym",
            "constructor_synonyms",
            "context",
            "cpp",
            "data_constructor",
            "data_constructors",
            "data_family",
            "data_instance",
            "data_type",
            "declarations",
            "default_signature",
            "default_types",
            "deriving",
            "deriving_instance",
            "deriving_strategy",
            "do",
            "do_module",
            "empty_list",
            "entity",
            "equation",
            "equations",
            "error_sentinel",
            "exp",
            "explicit_type",
            "export",
            "exports",
            "field",
            "field_name",
            "field_path",
            "field_pattern",
            "field_update",
            "fields",
            "fixity",
            "float",
            "forall",
            "forall_required",
            "foreign_export",
            "foreign_import",
            "function",
            "function_head_parens",
            "fundep",
            "fundeps",
            "gadt_constructor",
            "gadt_constructors",
            "generator",
            "group",
            "guards",
            "haddock",
            "haskell",
            "header",
            "implicit_parameter",
            "implicit_variable",
            "import",
            "import_list",
            "import_name",
            "import_package",
            "imports",
            "inferred",
            "infix",
            "infix_id",
            "instance",
            "instance_declarations",
            "integer",
            "invisible",
            "irrefutable",
            "kind_application",
            "kind_signature",
            "label",
            "lambda",
            "lambda_case",
            "lambda_cases",
            "lazy_field",
            "left_section",
            "let",
            "let_in",
            "linear_function",
            "list",
            "list_comprehension",
            "literal",
            "local_binds",
            "match",
            "modifier",
            "module",
            "module_export",
            "module_id",
            "multi_way_if",
            "name",
            "namespace",
            "negation",
            "newtype",
            "newtype_constructor",
            "operator",
            "parens",
            "pattern_guard",
            "pattern_synonym",
            "patterns",
            "pragma",
            "prefix",
            "prefix_id",
            "prefix_list",
            "prefix_tuple",
            "prefix_unboxed_sum",
            "prefix_unboxed_tuple",
            "projection",
            "projection_selector",
            "promoted",
            "qualified",
            "qualifiers",
            "quantified_variables",
            "quasiquote",
            "quasiquote_body",
            "quote",
            "quoted_decls",
            "quoted_expression",
            "quoted_pattern",
            "quoted_type",
            "quoter",
            "rec",
            "record",
            "right_section",
            "role_annotation",
            "safety",
            "signature",
            "special",
            "splice",
            "star",
            "strict",
            "strict_field",
            "string",
            "th_quoted_name",
            "top_splice",
            "transform",
            "tuple",
            "type_application",
            "type_binder",
            "type_family",
            "type_family_injectivity",
            "type_family_result",
            "type_instance",
            "type_params",
            "type_patterns",
            "type_role",
            "type_synomym",
            "typed_quote",
            "unboxed_sum",
            "unboxed_tuple",
            "unboxed_unit",
            "unit",
            "variable",
            "via",
            "view_pattern",
            "wildcard"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "alternatives",
            "argument",
            "arrow",
            "associativity",
            "bind",
            "binds",
            "body",
            "calling_convention",
            "children",
            "classes",
            "classifier",
            "closed_family",
            "constraint",
            "constructor",
            "constructors",
            "context",
            "decl",
            "declaration",
            "declarations",
            "deriving",
            "determined",
            "element",
            "else",
            "entity",
            "equation",
            "export",
            "exports",
            "expression",
            "field",
            "fields",
            "forall",
            "from",
            "function",
            "fundep",
            "fundeps",
            "guard",
            "guards",
            "id",
            "if",
            "implicit",
            "import",
            "imports",
            "key",
            "kind",
            "left_operand",
            "match",
            "matched",
            "minus",
            "module",
            "multiplicity",
            "name",
            "names",
            "namespace",
            "number",
            "operator",
            "package",
            "parameter",
            "parens",
            "pattern",
            "patterns",
            "precedence",
            "qualifier",
            "qualifiers",
            "quantifier",
            "quoter",
            "result",
            "right_operand",
            "role",
            "safety",
            "signature",
            "statement",
            "step",
            "strategy",
            "subfield",
            "synonym",
            "then",
            "to",
            "transformation",
            "type",
            "variable",
            "variables"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "hs",
        "haskell",
        "Haskell"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/html_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for html",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "attribute",
            "attribute_name",
            "attribute_value",
            "comment",
            "doctype",
            "document",
            "element",
            "end_tag",
            "entity",
            "erroneous_end_tag",
            "erroneous_end_tag_name",
            "quoted_attribute_value",
            "raw_text",
            "script_element",
            "self_closing_tag",
            "start_tag",
            "style_element",
            "tag_name",
            "text"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "attribute",
            "attribute_name",
            "attribute_value",
            "comment",
            "doctype",
            "document",
            "element",
            "end_tag",
            "entity",
            "erroneous_end_tag",
            "erroneous_end_tag_name",
            "quoted_attribute_value",
            "raw_text",
            "script_element",
            "self_closing_tag",
            "start_tag",
            "style_element",
            "tag_name",
            "text"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": []
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "html",
        "Html"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/java_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for java",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "annotated_type",
            "annotation",
            "annotation_argument_list",
            "annotation_type_body",
            "annotation_type_declaration",
            "annotation_type_element_declaration",
            "argument_list",
            "array_access",
            "array_creation_expression",
            "array_initializer",
            "array_type",
            "assert_statement",
            "assignment_expression",
            "asterisk",
            "binary_expression",
            "binary_integer_literal",
            "block",
            "block_comment",
            "boolean_type",
            "break_statement",
            "cast_expression",
            "catch_clause",
            "catch_formal_parameter",
            "catch_type",
            "character_literal",
            "class_body",
            "class_declaration",
            "class_literal",
            "compact_constructor_declaration",
            "constant_declaration",
            "constructor_body",
            "constructor_declaration",
            "continue_statement",
            "decimal_floating_point_literal",
            "decimal_integer_literal",
            "dimensions",
            "dimensions_expr",
            "do_statement",
            "element_value_array_initializer",
            "element_value_pair",
            "enhanced_for_statement",
            "enum_body",
            "enum_body_declarations",
            "enum_constant",
            "enum_declaration",
            "escape_sequence",
            "explicit_constructor_invocation",
            "exports_module_directive",
            "expression_statement",
            "extends_interfaces",
            "false",
            "field_access",
            "field_declaration",
            "finally_clause",
            "floating_point_type",
            "for_statement",
            "formal_parameter",
            "formal_parameters",
            "generic_type",
            "guard",
            "hex_floating_point_literal",
            "hex_integer_literal",
            "identifier",
            "if_statement",
            "import_declaration",
            "inferred_parameters",
            "instanceof_expression",
            "integral_type",
            "interface_body",
            "interface_declaration",
            "labeled_statement",
            "lambda_expression",
            "line_comment",
            "local_variable_declaration",
            "marker_annotation",
            "method_declaration",
            "method_invocation",
            "method_reference",
            "modifiers",
            "module_body",
            "module_declaration",
            "multiline_string_fragment",
            "null_literal",
            "object_creation_expression",
            "octal_integer_literal",
            "opens_module_directive",
            "package_declaration",
            "parenthesized_expression",
            "pattern",
            "permits",
            "program",
            "provides_module_directive",
            "receiver_parameter",
            "record_declaration",
            "record_pattern",
            "record_pattern_body",
            "record_pattern_component",
            "requires_modifier",
            "requires_module_directive",
            "resource",
            "resource_specification",
            "return_statement",
            "scoped_identifier",
            "scoped_type_identifier",
            "spread_parameter",
            "static_initializer",
            "string_fragment",
            "string_interpolation",
            "string_literal",
            "super",
            "super_interfaces",
            "superclass",
            "switch_block",
            "switch_block_statement_group",
            "switch_expression",
            "switch_label",
            "switch_rule",
            "synchronized_statement",
            "template_expression",
            "ternary_expression",
            "this",
            "throw_statement",
            "throws",
            "true",
            "try_statement",
            "try_with_resources_statement",
            "type_arguments",
            "type_bound",
            "type_identifier",
            "type_list",
            "type_parameter",
            "type_parameters",
            "type_pattern",
            "unary_expression",
            "underscore_pattern",
            "update_expression",
            "uses_module_directive",
            "variable_declarator",
            "void_type",
            "while_statement",
            "wildcard",
            "yield_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "annotated_type",
            "annotation",
            "annotation_argument_list",
            "annotation_type_body",
            "annotation_type_declaration",
            "annotation_type_element_declaration",
            "argument_list",
            "array_access",
            "array_creation_expression",
            "array_initializer",
            "array_type",
            "assert_statement",
            "assignment_expression",
            "asterisk",
            "binary_expression",
            "binary_integer_literal",
            "block",
            "block_comment",
            "boolean_type",
            "break_statement",
            "cast_expression",
            "catch_clause",
            "catch_formal_parameter",
            "catch_type",
            "character_literal",
            "class_body",
            "class_declaration",
            "class_literal",
            "compact_constructor_declaration",
            "constant_declaration",
            "constructor_body",
            "constructor_declaration",
            "continue_statement",
            "decimal_floating_point_literal",
            "decimal_integer_literal",
            "dimensions",
            "dimensions_expr",
            "do_statement",
            "element_value_array_initializer",
            "element_value_pair",
            "enhanced_for_statement",
            "enum_body",
            "enum_body_declarations",
            "enum_constant",
            "enum_declaration",
            "escape_sequence",
            "explicit_constructor_invocation",
            "exports_module_directive",
            "expression_statement",
            "extends_interfaces",
            "false",
            "field_access",
            "field_declaration",
            "finally_clause",
            "floating_point_type",
            "for_statement",
            "formal_parameter",
            "formal_parameters",
            "generic_type",
            "guard",
            "hex_floating_point_literal",
            "hex_integer_literal",
            "identifier",
            "if_statement",
            "import_declaration",
            "inferred_parameters",
            "instanceof_expression",
            "integral_type",
            "interface_body",
            "interface_declaration",
            "labeled_statement",
            "lambda_expression",
            "line_comment",
            "local_variable_declaration",
            "marker_annotation",
            "method_declaration",
            "method_invocation",
            "method_reference",
            "modifiers",
            "module_body",
            "module_declaration",
            "multiline_string_fragment",
            "null_literal",
            "object_creation_expression",
            "octal_integer_literal",
            "opens_module_directive",
            "package_declaration",
            "parenthesized_expression",
            "pattern",
            "permits",
            "program",
            "provides_module_directive",
            "receiver_parameter",
            "record_declaration",
            "record_pattern",
            "record_pattern_body",
            "record_pattern_component",
            "requires_modifier",
            "requires_module_directive",
            "resource",
            "resource_specification",
            "return_statement",
            "scoped_identifier",
            "scoped_type_identifier",
            "spread_parameter",
            "static_initializer",
            "string_fragment",
            "string_interpolation",
            "string_literal",
            "super",
            "super_interfaces",
            "superclass",
            "switch_block",
            "switch_block_statement_group",
            "switch_expression",
            "switch_label",
            "switch_rule",
            "synchronized_statement",
            "template_expression",
            "ternary_expression",
            "this",
            "throw_statement",
            "throws",
            "true",
            "try_statement",
            "try_with_resources_statement",
            "type_arguments",
            "type_bound",
            "type_identifier",
            "type_list",
            "type_parameter",
            "type_parameters",
            "type_pattern",
            "unary_expression",
            "underscore_pattern",
            "update_expression",
            "uses_module_directive",
            "variable_declarator",
            "void_type",
            "while_statement",
            "wildcard",
            "yield_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "arguments",
            "array",
            "body",
            "condition",
            "consequence",
            "constructor",
            "declarator",
            "dimensions",
            "element",
            "field",
            "index",
            "init",
            "interfaces",
            "key",
            "left",
            "modifiers",
            "module",
            "modules",
            "name",
            "object",
            "operand",
            "operator",
            "package",
            "parameters",
            "pattern",
            "permits",
            "provided",
            "provider",
            "resources",
            "right",
            "scope",
            "superclass",
            "template_argument",
            "template_processor",
            "type",
            "type_arguments",
            "type_parameters",
            "update"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "java",
        "Java"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/javascript_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for javascript",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "arguments",
            "array",
            "array_pattern",
            "arrow_function",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "do_statement",
            "else_clause",
            "empty_statement",
            "escape_sequence",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "false",
            "field_definition",
            "finally_clause",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "generator_function",
            "generator_function_declaration",
            "hash_bang_line",
            "html_character_reference",
            "html_comment",
            "identifier",
            "if_statement",
            "import",
            "import_attribute",
            "import_clause",
            "import_specifier",
            "import_statement",
            "jsx_attribute",
            "jsx_closing_element",
            "jsx_element",
            "jsx_expression",
            "jsx_namespace_name",
            "jsx_opening_element",
            "jsx_self_closing_element",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "member_expression",
            "meta_property",
            "method_definition",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "new_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "optional_chain",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "private_property_identifier",
            "program",
            "property_identifier",
            "regex",
            "regex_flags",
            "regex_pattern",
            "rest_pattern",
            "return_statement",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_string",
            "template_substitution",
            "ternary_expression",
            "this",
            "throw_statement",
            "true",
            "try_statement",
            "unary_expression",
            "undefined",
            "update_expression",
            "using_declaration",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "arguments",
            "array",
            "array_pattern",
            "arrow_function",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "do_statement",
            "else_clause",
            "empty_statement",
            "escape_sequence",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "false",
            "field_definition",
            "finally_clause",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "generator_function",
            "generator_function_declaration",
            "hash_bang_line",
            "html_character_reference",
            "html_comment",
            "identifier",
            "if_statement",
            "import",
            "import_attribute",
            "import_clause",
            "import_specifier",
            "import_statement",
            "jsx_attribute",
            "jsx_closing_element",
            "jsx_element",
            "jsx_expression",
            "jsx_namespace_name",
            "jsx_opening_element",
            "jsx_self_closing_element",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "member_expression",
            "meta_property",
            "method_definition",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "new_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "optional_chain",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "private_property_identifier",
            "program",
            "property_identifier",
            "regex",
            "regex_flags",
            "regex_pattern",
            "rest_pattern",
            "return_statement",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_string",
            "template_substitution",
            "ternary_expression",
            "this",
            "throw_statement",
            "true",
            "try_statement",
            "unary_expression",
            "undefined",
            "update_expression",
            "using_declaration",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "attribute",
            "body",
            "close_tag",
            "condition",
            "consequence",
            "constructor",
            "declaration",
            "decorator",
            "finalizer",
            "flags",
            "function",
            "handler",
            "increment",
            "index",
            "initializer",
            "key",
            "kind",
            "label",
            "left",
            "member",
            "name",
            "object",
            "open_tag",
            "operator",
            "optional_chain",
            "parameter",
            "parameters",
            "pattern",
            "property",
            "right",
            "source"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "javascript",
        "js",
        "jsx",
        "JavaScript"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/json_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for json",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "array",
            "comment",
            "document",
            "escape_sequence",
            "false",
            "null",
            "number",
            "object",
            "pair",
            "string",
            "string_content",
            "true"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "array",
            "comment",
            "document",
            "escape_sequence",
            "false",
            "null",
            "number",
            "object",
            "pair",
            "string",
            "string_content",
            "true"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "key"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "json",
        "Json"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/kotlin_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for kotlin",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "additive_expression",
            "annotated_lambda",
            "annotation",
            "anonymous_function",
            "anonymous_initializer",
            "as_expression",
            "assignment",
            "bin_literal",
            "binding_pattern_kind",
            "boolean_literal",
            "call_expression",
            "call_suffix",
            "callable_reference",
            "catch_block",
            "character_escape_seq",
            "character_literal",
            "check_expression",
            "class_body",
            "class_declaration",
            "class_modifier",
            "class_parameter",
            "collection_literal",
            "companion_object",
            "comparison_expression",
            "conjunction_expression",
            "constructor_delegation_call",
            "constructor_invocation",
            "control_structure_body",
            "delegation_specifier",
            "directly_assignable_expression",
            "disjunction_expression",
            "do_while_statement",
            "elvis_expression",
            "enum_class_body",
            "enum_entry",
            "equality_expression",
            "explicit_delegation",
            "file_annotation",
            "finally_block",
            "for_statement",
            "function_body",
            "function_declaration",
            "function_modifier",
            "function_type",
            "function_type_parameters",
            "function_value_parameters",
            "getter",
            "hex_literal",
            "identifier",
            "if_expression",
            "import_alias",
            "import_header",
            "import_list",
            "indexing_expression",
            "indexing_suffix",
            "infix_expression",
            "inheritance_modifier",
            "integer_literal",
            "interpolated_expression",
            "interpolated_identifier",
            "jump_expression",
            "label",
            "lambda_literal",
            "lambda_parameters",
            "line_comment",
            "long_literal",
            "member_modifier",
            "modifiers",
            "multi_variable_declaration",
            "multiline_comment",
            "multiplicative_expression",
            "navigation_expression",
            "navigation_suffix",
            "not_nullable_type",
            "null_literal",
            "nullable_type",
            "object_declaration",
            "object_literal",
            "package_header",
            "parameter",
            "parameter_modifier",
            "parameter_modifiers",
            "parameter_with_optional_type",
            "parenthesized_expression",
            "parenthesized_type",
            "parenthesized_user_type",
            "platform_modifier",
            "postfix_expression",
            "prefix_expression",
            "primary_constructor",
            "property_declaration",
            "property_delegate",
            "property_modifier",
            "range_expression",
            "range_test",
            "real_literal",
            "reification_modifier",
            "secondary_constructor",
            "setter",
            "shebang_line",
            "simple_identifier",
            "source_file",
            "spread_expression",
            "statements",
            "string_content",
            "string_literal",
            "super_expression",
            "this_expression",
            "try_expression",
            "type_alias",
            "type_arguments",
            "type_constraint",
            "type_constraints",
            "type_identifier",
            "type_modifiers",
            "type_parameter",
            "type_parameter_modifiers",
            "type_parameters",
            "type_projection",
            "type_projection_modifiers",
            "type_test",
            "unsigned_literal",
            "use_site_target",
            "user_type",
            "value_argument",
            "value_arguments",
            "variable_declaration",
            "variance_modifier",
            "visibility_modifier",
            "when_condition",
            "when_entry",
            "when_expression",
            "when_subject",
            "while_statement",
            "wildcard_import"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "additive_expression",
            "annotated_lambda",
            "annotation",
            "anonymous_function",
            "anonymous_initializer",
            "as_expression",
            "assignment",
            "bin_literal",
            "binding_pattern_kind",
            "boolean_literal",
            "call_expression",
            "call_suffix",
            "callable_reference",
            "catch_block",
            "character_escape_seq",
            "character_literal",
            "check_expression",
            "class_body",
            "class_declaration",
            "class_modifier",
            "class_parameter",
            "collection_literal",
            "companion_object",
            "comparison_expression",
            "conjunction_expression",
            "constructor_delegation_call",
            "constructor_invocation",
            "control_structure_body",
            "delegation_specifier",
            "directly_assignable_expression",
            "disjunction_expression",
            "do_while_statement",
            "elvis_expression",
            "enum_class_body",
            "enum_entry",
            "equality_expression",
            "explicit_delegation",
            "file_annotation",
            "finally_block",
            "for_statement",
            "function_body",
            "function_declaration",
            "function_modifier",
            "function_type",
            "function_type_parameters",
            "function_value_parameters",
            "getter",
            "hex_literal",
            "identifier",
            "if_expression",
            "import_alias",
            "import_header",
            "import_list",
            "indexing_expression",
            "indexing_suffix",
            "infix_expression",
            "inheritance_modifier",
            "integer_literal",
            "interpolated_expression",
            "interpolated_identifier",
            "jump_expression",
            "label",
            "lambda_literal",
            "lambda_parameters",
            "line_comment",
            "long_literal",
            "member_modifier",
            "modifiers",
            "multi_variable_declaration",
            "multiline_comment",
            "multiplicative_expression",
            "navigation_expression",
            "navigation_suffix",
            "not_nullable_type",
            "null_literal",
            "nullable_type",
            "object_declaration",
            "object_literal",
            "package_header",
            "parameter",
            "parameter_modifier",
            "parameter_modifiers",
            "parameter_with_optional_type",
            "parenthesized_expression",
            "parenthesized_type",
            "parenthesized_user_type",
            "platform_modifier",
            "postfix_expression",
            "prefix_expression",
            "primary_constructor",
            "property_declaration",
            "property_delegate",
            "property_modifier",
            "range_expression",
            "range_test",
            "real_literal",
            "reification_modifier",
            "secondary_constructor",
            "setter",
            "shebang_line",
            "simple_identifier",
            "source_file",
            "spread_expression",
            "statements",
            "string_content",
            "string_literal",
            "super_expression",
            "this_expression",
            "try_expression",
            "type_alias",
            "type_arguments",
            "type_constraint",
            "type_constraints",
            "type_identifier",
            "type_modifiers",
            "type_parameter",
            "type_parameter_modifiers",
            "type_parameters",
            "type_projection",
            "type_projection_modifiers",
            "type_test",
            "unsigned_literal",
            "use_site_target",
            "user_type",
            "value_argument",
            "value_arguments",
            "variable_declaration",
            "variance_modifier",
            "visibility_modifier",
            "when_condition",
            "when_entry",
            "when_expression",
            "when_subject",
            "while_statement",
            "wildcard_import"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "condition"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "kotlin",
        "kt",
        "Kotlin"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/lua_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for lua",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "arguments",
            "assignment_statement",
            "attribute",
            "binary_expression",
            "block",
            "bracket_index_expression",
            "break_statement",
            "chunk",
            "comment",
            "comment_content",
            "do_statement",
            "dot_index_expression",
            "else_statement",
            "elseif_statement",
            "empty_statement",
            "escape_sequence",
            "expression_list",
            "false",
            "field",
            "for_generic_clause",
            "for_numeric_clause",
            "for_statement",
            "function_call",
            "function_declaration",
            "function_definition",
            "goto_statement",
            "hash_bang_line",
            "identifier",
            "if_statement",
            "label_statement",
            "method_index_expression",
            "nil",
            "number",
            "parameters",
            "parenthesized_expression",
            "repeat_statement",
            "return_statement",
            "string",
            "string_content",
            "table_constructor",
            "true",
            "unary_expression",
            "vararg_expression",
            "variable_declaration",
            "variable_list",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "arguments",
            "assignment_statement",
            "attribute",
            "binary_expression",
            "block",
            "bracket_index_expression",
            "break_statement",
            "chunk",
            "comment",
            "comment_content",
            "do_statement",
            "dot_index_expression",
            "else_statement",
            "elseif_statement",
            "empty_statement",
            "escape_sequence",
            "expression_list",
            "false",
            "field",
            "for_generic_clause",
            "for_numeric_clause",
            "for_statement",
            "function_call",
            "function_declaration",
            "function_definition",
            "goto_statement",
            "hash_bang_line",
            "identifier",
            "if_statement",
            "label_statement",
            "method_index_expression",
            "nil",
            "number",
            "parameters",
            "parenthesized_expression",
            "repeat_statement",
            "return_statement",
            "string",
            "string_content",
            "table_constructor",
            "true",
            "unary_expression",
            "vararg_expression",
            "variable_declaration",
            "variable_list",
            "while_statement"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alternative",
            "arguments",
            "attribute",
            "body",
            "clause",
            "condition",
            "consequence",
            "content",
            "end",
            "field",
            "left",
            "local_declaration",
            "method",
            "name",
            "operand",
            "parameters",
            "right",
            "start",
            "step",
            "table"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "lua",
        "Lua"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/php_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for php",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_modifier",
            "anonymous_class",
            "anonymous_function",
            "anonymous_function_use_clause",
            "argument",
            "arguments",
            "array_creation_expression",
            "array_element_initializer",
            "arrow_function",
            "assignment_expression",
            "attribute",
            "attribute_group",
            "attribute_list",
            "augmented_assignment_expression",
            "base_clause",
            "binary_expression",
            "boolean",
            "bottom_type",
            "break_statement",
            "by_ref",
            "case_statement",
            "cast_expression",
            "cast_type",
            "catch_clause",
            "class_constant_access_expression",
            "class_declaration",
            "class_interface_clause",
            "clone_expression",
            "colon_block",
            "comment",
            "compound_statement",
            "conditional_expression",
            "const_declaration",
            "const_element",
            "continue_statement",
            "declaration_list",
            "declare_directive",
            "declare_statement",
            "default_statement",
            "disjunctive_normal_form_type",
            "do_statement",
            "dynamic_variable_name",
            "echo_statement",
            "else_clause",
            "else_if_clause",
            "empty_statement",
            "encapsed_string",
            "enum_case",
            "enum_declaration",
            "enum_declaration_list",
            "error_suppression_expression",
            "escape_sequence",
            "exit_statement",
            "expression_statement",
            "final_modifier",
            "finally_clause",
            "float",
            "for_statement",
            "foreach_statement",
            "formal_parameters",
            "function_call_expression",
            "function_definition",
            "function_static_declaration",
            "global_declaration",
            "goto_statement",
            "heredoc",
            "heredoc_body",
            "heredoc_end",
            "heredoc_start",
            "if_statement",
            "include_expression",
            "include_once_expression",
            "integer",
            "interface_declaration",
            "intersection_type",
            "list_literal",
            "match_block",
            "match_condition_list",
            "match_conditional_expression",
            "match_default_expression",
            "match_expression",
            "member_access_expression",
            "member_call_expression",
            "method_declaration",
            "name",
            "named_label_statement",
            "named_type",
            "namespace_definition",
            "namespace_name",
            "namespace_use_clause",
            "namespace_use_declaration",
            "namespace_use_group",
            "nowdoc",
            "nowdoc_body",
            "nowdoc_string",
            "null",
            "nullsafe_member_access_expression",
            "nullsafe_member_call_expression",
            "object_creation_expression",
            "operation",
            "optional_type",
            "pair",
            "parenthesized_expression",
            "php_end_tag",
            "php_tag",
            "primitive_type",
            "print_intrinsic",
            "program",
            "property_declaration",
            "property_element",
            "property_hook",
            "property_hook_list",
            "property_promotion_parameter",
            "qualified_name",
            "readonly_modifier",
            "reference_assignment_expression",
            "reference_modifier",
            "relative_name",
            "relative_scope",
            "require_expression",
            "require_once_expression",
            "return_statement",
            "scoped_call_expression",
            "scoped_property_access_expression",
            "sentinel_error",
            "sequence_expression",
            "shell_command_expression",
            "simple_parameter",
            "static_modifier",
            "static_variable_declaration",
            "string",
            "string_content",
            "subscript_expression",
            "switch_block",
            "switch_statement",
            "throw_expression",
            "trait_declaration",
            "try_statement",
            "type_list",
            "unary_op_expression",
            "union_type",
            "unset_statement",
            "update_expression",
            "use_as_clause",
            "use_declaration",
            "use_instead_of_clause",
            "use_list",
            "var_modifier",
            "variable_name",
            "variadic_parameter",
            "variadic_placeholder",
            "variadic_unpacking",
            "visibility_modifier",
            "while_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_modifier",
            "anonymous_class",
            "anonymous_function",
            "anonymous_function_use_clause",
            "argument",
            "arguments",
            "array_creation_expression",
            "array_element_initializer",
            "arrow_function",
            "assignment_expression",
            "attribute",
            "attribute_group",
            "attribute_list",
            "augmented_assignment_expression",
            "base_clause",
            "binary_expression",
            "boolean",
            "bottom_type",
            "break_statement",
            "by_ref",
            "case_statement",
            "cast_expression",
            "cast_type",
            "catch_clause",
            "class_constant_access_expression",
            "class_declaration",
            "class_interface_clause",
            "clone_expression",
            "colon_block",
            "comment",
            "compound_statement",
            "conditional_expression",
            "const_declaration",
            "const_element",
            "continue_statement",
            "declaration_list",
            "declare_directive",
            "declare_statement",
            "default_statement",
            "disjunctive_normal_form_type",
            "do_statement",
            "dynamic_variable_name",
            "echo_statement",
            "else_clause",
            "else_if_clause",
            "empty_statement",
            "encapsed_string",
            "enum_case",
            "enum_declaration",
            "enum_declaration_list",
            "error_suppression_expression",
            "escape_sequence",
            "exit_statement",
            "expression_statement",
            "final_modifier",
            "finally_clause",
            "float",
            "for_statement",
            "foreach_statement",
            "formal_parameters",
            "function_call_expression",
            "function_definition",
            "function_static_declaration",
            "global_declaration",
            "goto_statement",
            "heredoc",
            "heredoc_body",
            "heredoc_end",
            "heredoc_start",
            "if_statement",
            "include_expression",
            "include_once_expression",
            "integer",
            "interface_declaration",
            "intersection_type",
            "list_literal",
            "match_block",
            "match_condition_list",
            "match_conditional_expression",
            "match_default_expression",
            "match_expression",
            "member_access_expression",
            "member_call_expression",
            "method_declaration",
            "name",
            "named_label_statement",
            "named_type",
            "namespace_definition",
            "namespace_name",
            "namespace_use_clause",
            "namespace_use_declaration",
            "namespace_use_group",
            "nowdoc",
            "nowdoc_body",
            "nowdoc_string",
            "null",
            "nullsafe_member_access_expression",
            "nullsafe_member_call_expression",
            "object_creation_expression",
            "operation",
            "optional_type",
            "pair",
            "parenthesized_expression",
            "php_end_tag",
            "php_tag",
            "primitive_type",
            "print_intrinsic",
            "program",
            "property_declaration",
            "property_element",
            "property_hook",
            "property_hook_list",
            "property_promotion_parameter",
            "qualified_name",
            "readonly_modifier",
            "reference_assignment_expression",
            "reference_modifier",
            "relative_name",
            "relative_scope",
            "require_expression",
            "require_once_expression",
            "return_statement",
            "scoped_call_expression",
            "scoped_property_access_expression",
            "sentinel_error",
            "sequence_expression",
            "shell_command_expression",
            "simple_parameter",
            "static_modifier",
            "static_variable_declaration",
            "string",
            "string_content",
            "subscript_expression",
            "switch_block",
            "switch_statement",
            "throw_expression",
            "trait_declaration",
            "try_statement",
            "type_list",
            "unary_op_expression",
            "union_type",
            "unset_statement",
            "update_expression",
            "use_as_clause",
            "use_declaration",
            "use_instead_of_clause",
            "use_list",
            "var_modifier",
            "variable_name",
            "variadic_parameter",
            "variadic_placeholder",
            "variadic_unpacking",
            "visibility_modifier",
            "while_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "attributes",
            "body",
            "condition",
            "conditional_expressions",
            "default_value",
            "end_tag",
            "final",
            "function",
            "identifier",
            "initialize",
            "left",
            "name",
            "object",
            "operator",
            "parameters",
            "prefix",
            "readonly",
            "reference_modifier",
            "return_expression",
            "return_type",
            "right",
            "scope",
            "static_modifier",
            "type",
            "update",
            "value"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "php",
        "Php"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/project.json
================================================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/definitions/Project",
  "definitions": {
    "Project": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ruleDirs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Rule directories",
          "description": "A list of string instructing where to discover ast-grep's YAML rules."
        },
        "testConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TestConfig"
          },
          "title": "Test configurations",
          "description": "A list of object to configure ast-grep's test cases. Each object can have two fields."
        },
        "utilDirs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Utility directories",
          "description": "A list of string instructing where to discover ast-grep's global utility rules."
        }
      },
      "required": ["ruleDirs"],
      "title": "ast-grep project configuration"
    },
    "TestConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "testDir": {
          "type": "string",
          "description": "A string specifies where to discover test cases for ast-grep."
        },
        "snapshotDir": {
          "type": "string",
          "description": "A string path relative to testDir that specifies where to store test snapshots for ast-grep. You can think it like __snapshots___ in popular test framework like jest. If this option is not specified, ast-grep will store the snapshot under the __snapshots__ folder under the testDir."
        }
      },
      "required": ["testDir"],
      "title": "Test configuration"
    }
  }
}



================================================
FILE: schemas/python_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for python",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "aliased_import",
            "argument_list",
            "as_pattern",
            "as_pattern_target",
            "assert_statement",
            "assignment",
            "attribute",
            "augmented_assignment",
            "await",
            "binary_operator",
            "block",
            "boolean_operator",
            "break_statement",
            "call",
            "case_clause",
            "case_pattern",
            "chevron",
            "class_definition",
            "class_pattern",
            "comment",
            "comparison_operator",
            "complex_pattern",
            "concatenated_string",
            "conditional_expression",
            "constrained_type",
            "continue_statement",
            "decorated_definition",
            "decorator",
            "default_parameter",
            "delete_statement",
            "dict_pattern",
            "dictionary",
            "dictionary_comprehension",
            "dictionary_splat",
            "dictionary_splat_pattern",
            "dotted_name",
            "elif_clause",
            "ellipsis",
            "else_clause",
            "escape_interpolation",
            "escape_sequence",
            "except_clause",
            "except_group_clause",
            "exec_statement",
            "expression_list",
            "expression_statement",
            "false",
            "finally_clause",
            "float",
            "for_in_clause",
            "for_statement",
            "format_expression",
            "format_specifier",
            "function_definition",
            "future_import_statement",
            "generator_expression",
            "generic_type",
            "global_statement",
            "identifier",
            "if_clause",
            "if_statement",
            "import_from_statement",
            "import_prefix",
            "import_statement",
            "integer",
            "interpolation",
            "keyword_argument",
            "keyword_pattern",
            "keyword_separator",
            "lambda",
            "lambda_parameters",
            "line_continuation",
            "list",
            "list_comprehension",
            "list_pattern",
            "list_splat",
            "list_splat_pattern",
            "match_statement",
            "member_type",
            "module",
            "named_expression",
            "none",
            "nonlocal_statement",
            "not_operator",
            "pair",
            "parameters",
            "parenthesized_expression",
            "parenthesized_list_splat",
            "pass_statement",
            "pattern_list",
            "positional_separator",
            "print_statement",
            "raise_statement",
            "relative_import",
            "return_statement",
            "set",
            "set_comprehension",
            "slice",
            "splat_pattern",
            "splat_type",
            "string",
            "string_content",
            "string_end",
            "string_start",
            "subscript",
            "true",
            "try_statement",
            "tuple",
            "tuple_pattern",
            "type",
            "type_alias_statement",
            "type_conversion",
            "type_parameter",
            "typed_default_parameter",
            "typed_parameter",
            "unary_operator",
            "union_pattern",
            "union_type",
            "while_statement",
            "wildcard_import",
            "with_clause",
            "with_item",
            "with_statement",
            "yield"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "aliased_import",
            "argument_list",
            "as_pattern",
            "as_pattern_target",
            "assert_statement",
            "assignment",
            "attribute",
            "augmented_assignment",
            "await",
            "binary_operator",
            "block",
            "boolean_operator",
            "break_statement",
            "call",
            "case_clause",
            "case_pattern",
            "chevron",
            "class_definition",
            "class_pattern",
            "comment",
            "comparison_operator",
            "complex_pattern",
            "concatenated_string",
            "conditional_expression",
            "constrained_type",
            "continue_statement",
            "decorated_definition",
            "decorator",
            "default_parameter",
            "delete_statement",
            "dict_pattern",
            "dictionary",
            "dictionary_comprehension",
            "dictionary_splat",
            "dictionary_splat_pattern",
            "dotted_name",
            "elif_clause",
            "ellipsis",
            "else_clause",
            "escape_interpolation",
            "escape_sequence",
            "except_clause",
            "except_group_clause",
            "exec_statement",
            "expression_list",
            "expression_statement",
            "false",
            "finally_clause",
            "float",
            "for_in_clause",
            "for_statement",
            "format_expression",
            "format_specifier",
            "function_definition",
            "future_import_statement",
            "generator_expression",
            "generic_type",
            "global_statement",
            "identifier",
            "if_clause",
            "if_statement",
            "import_from_statement",
            "import_prefix",
            "import_statement",
            "integer",
            "interpolation",
            "keyword_argument",
            "keyword_pattern",
            "keyword_separator",
            "lambda",
            "lambda_parameters",
            "line_continuation",
            "list",
            "list_comprehension",
            "list_pattern",
            "list_splat",
            "list_splat_pattern",
            "match_statement",
            "member_type",
            "module",
            "named_expression",
            "none",
            "nonlocal_statement",
            "not_operator",
            "pair",
            "parameters",
            "parenthesized_expression",
            "parenthesized_list_splat",
            "pass_statement",
            "pattern_list",
            "positional_separator",
            "print_statement",
            "raise_statement",
            "relative_import",
            "return_statement",
            "set",
            "set_comprehension",
            "slice",
            "splat_pattern",
            "splat_type",
            "string",
            "string_content",
            "string_end",
            "string_start",
            "subscript",
            "true",
            "try_statement",
            "tuple",
            "tuple_pattern",
            "type",
            "type_alias_statement",
            "type_conversion",
            "type_parameter",
            "typed_default_parameter",
            "typed_parameter",
            "unary_operator",
            "union_pattern",
            "union_type",
            "while_statement",
            "wildcard_import",
            "with_clause",
            "with_item",
            "with_statement",
            "yield"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "attribute",
            "body",
            "cause",
            "code",
            "condition",
            "consequence",
            "definition",
            "expression",
            "format_specifier",
            "function",
            "guard",
            "key",
            "left",
            "module_name",
            "name",
            "object",
            "operator",
            "operators",
            "parameters",
            "return_type",
            "right",
            "subject",
            "subscript",
            "superclasses",
            "type",
            "type_conversion",
            "type_parameters"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "py",
        "python",
        "Python"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/ruby_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for ruby",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "alias",
            "alternative_pattern",
            "argument_list",
            "array",
            "array_pattern",
            "as_pattern",
            "assignment",
            "bare_string",
            "bare_symbol",
            "begin",
            "begin_block",
            "binary",
            "block",
            "block_argument",
            "block_body",
            "block_parameter",
            "block_parameters",
            "body_statement",
            "break",
            "call",
            "case",
            "case_match",
            "chained_string",
            "character",
            "class",
            "class_variable",
            "comment",
            "complex",
            "conditional",
            "constant",
            "delimited_symbol",
            "destructured_left_assignment",
            "destructured_parameter",
            "do",
            "do_block",
            "element_reference",
            "else",
            "elsif",
            "empty_statement",
            "encoding",
            "end_block",
            "ensure",
            "escape_sequence",
            "exception_variable",
            "exceptions",
            "expression_reference_pattern",
            "false",
            "file",
            "find_pattern",
            "float",
            "for",
            "forward_argument",
            "forward_parameter",
            "global_variable",
            "hash",
            "hash_key_symbol",
            "hash_pattern",
            "hash_splat_argument",
            "hash_splat_nil",
            "hash_splat_parameter",
            "heredoc_beginning",
            "heredoc_body",
            "heredoc_content",
            "heredoc_end",
            "identifier",
            "if",
            "if_guard",
            "if_modifier",
            "in",
            "in_clause",
            "instance_variable",
            "integer",
            "interpolation",
            "keyword_parameter",
            "keyword_pattern",
            "lambda",
            "lambda_parameters",
            "left_assignment_list",
            "line",
            "match_pattern",
            "method",
            "method_parameters",
            "module",
            "next",
            "nil",
            "operator",
            "operator_assignment",
            "optional_parameter",
            "pair",
            "parenthesized_pattern",
            "parenthesized_statements",
            "pattern",
            "program",
            "range",
            "rational",
            "redo",
            "regex",
            "rescue",
            "rescue_modifier",
            "rest_assignment",
            "retry",
            "return",
            "right_assignment_list",
            "scope_resolution",
            "self",
            "setter",
            "simple_symbol",
            "singleton_class",
            "singleton_method",
            "splat_argument",
            "splat_parameter",
            "string",
            "string_array",
            "string_content",
            "subshell",
            "super",
            "superclass",
            "symbol_array",
            "test_pattern",
            "then",
            "true",
            "unary",
            "undef",
            "uninterpreted",
            "unless",
            "unless_guard",
            "unless_modifier",
            "until",
            "until_modifier",
            "variable_reference_pattern",
            "when",
            "while",
            "while_modifier",
            "yield"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "alias",
            "alternative_pattern",
            "argument_list",
            "array",
            "array_pattern",
            "as_pattern",
            "assignment",
            "bare_string",
            "bare_symbol",
            "begin",
            "begin_block",
            "binary",
            "block",
            "block_argument",
            "block_body",
            "block_parameter",
            "block_parameters",
            "body_statement",
            "break",
            "call",
            "case",
            "case_match",
            "chained_string",
            "character",
            "class",
            "class_variable",
            "comment",
            "complex",
            "conditional",
            "constant",
            "delimited_symbol",
            "destructured_left_assignment",
            "destructured_parameter",
            "do",
            "do_block",
            "element_reference",
            "else",
            "elsif",
            "empty_statement",
            "encoding",
            "end_block",
            "ensure",
            "escape_sequence",
            "exception_variable",
            "exceptions",
            "expression_reference_pattern",
            "false",
            "file",
            "find_pattern",
            "float",
            "for",
            "forward_argument",
            "forward_parameter",
            "global_variable",
            "hash",
            "hash_key_symbol",
            "hash_pattern",
            "hash_splat_argument",
            "hash_splat_nil",
            "hash_splat_parameter",
            "heredoc_beginning",
            "heredoc_body",
            "heredoc_content",
            "heredoc_end",
            "identifier",
            "if",
            "if_guard",
            "if_modifier",
            "in",
            "in_clause",
            "instance_variable",
            "integer",
            "interpolation",
            "keyword_parameter",
            "keyword_pattern",
            "lambda",
            "lambda_parameters",
            "left_assignment_list",
            "line",
            "match_pattern",
            "method",
            "method_parameters",
            "module",
            "next",
            "nil",
            "operator",
            "operator_assignment",
            "optional_parameter",
            "pair",
            "parenthesized_pattern",
            "parenthesized_statements",
            "pattern",
            "program",
            "range",
            "rational",
            "redo",
            "regex",
            "rescue",
            "rescue_modifier",
            "rest_assignment",
            "retry",
            "return",
            "right_assignment_list",
            "scope_resolution",
            "self",
            "setter",
            "simple_symbol",
            "singleton_class",
            "singleton_method",
            "splat_argument",
            "splat_parameter",
            "string",
            "string_array",
            "string_content",
            "subshell",
            "super",
            "superclass",
            "symbol_array",
            "test_pattern",
            "then",
            "true",
            "unary",
            "undef",
            "uninterpreted",
            "unless",
            "unless_guard",
            "unless_modifier",
            "until",
            "until_modifier",
            "variable_reference_pattern",
            "when",
            "while",
            "while_modifier",
            "yield"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "alternatives",
            "arguments",
            "begin",
            "block",
            "body",
            "class",
            "clauses",
            "condition",
            "consequence",
            "else",
            "end",
            "exceptions",
            "guard",
            "handler",
            "key",
            "left",
            "locals",
            "method",
            "name",
            "object",
            "operand",
            "operator",
            "parameters",
            "pattern",
            "receiver",
            "right",
            "scope",
            "superclass",
            "value"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "rb",
        "ruby",
        "Ruby"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string"
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string"
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript"
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/rust_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for rust",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_type",
            "arguments",
            "array_expression",
            "array_type",
            "assignment_expression",
            "associated_type",
            "async_block",
            "attribute",
            "attribute_item",
            "await_expression",
            "base_field_initializer",
            "binary_expression",
            "block",
            "block_comment",
            "boolean_literal",
            "bounded_type",
            "bracketed_type",
            "break_expression",
            "call_expression",
            "captured_pattern",
            "char_literal",
            "closure_expression",
            "closure_parameters",
            "compound_assignment_expr",
            "const_block",
            "const_item",
            "const_parameter",
            "continue_expression",
            "crate",
            "declaration_list",
            "doc_comment",
            "dynamic_type",
            "else_clause",
            "empty_statement",
            "enum_item",
            "enum_variant",
            "enum_variant_list",
            "escape_sequence",
            "expression_statement",
            "extern_crate_declaration",
            "extern_modifier",
            "field_declaration",
            "field_declaration_list",
            "field_expression",
            "field_identifier",
            "field_initializer",
            "field_initializer_list",
            "field_pattern",
            "float_literal",
            "for_expression",
            "for_lifetimes",
            "foreign_mod_item",
            "fragment_specifier",
            "function_item",
            "function_modifiers",
            "function_signature_item",
            "function_type",
            "gen_block",
            "generic_function",
            "generic_pattern",
            "generic_type",
            "generic_type_with_turbofish",
            "higher_ranked_trait_bound",
            "identifier",
            "if_expression",
            "impl_item",
            "index_expression",
            "inner_attribute_item",
            "inner_doc_comment_marker",
            "integer_literal",
            "label",
            "let_chain",
            "let_condition",
            "let_declaration",
            "lifetime",
            "lifetime_parameter",
            "line_comment",
            "loop_expression",
            "macro_definition",
            "macro_invocation",
            "macro_rule",
            "match_arm",
            "match_block",
            "match_expression",
            "match_pattern",
            "metavariable",
            "mod_item",
            "mut_pattern",
            "mutable_specifier",
            "negative_literal",
            "never_type",
            "or_pattern",
            "ordered_field_declaration_list",
            "outer_doc_comment_marker",
            "parameter",
            "parameters",
            "parenthesized_expression",
            "pointer_type",
            "primitive_type",
            "qualified_type",
            "range_expression",
            "range_pattern",
            "raw_string_literal",
            "ref_pattern",
            "reference_expression",
            "reference_pattern",
            "reference_type",
            "remaining_field_pattern",
            "removed_trait_bound",
            "return_expression",
            "scoped_identifier",
            "scoped_type_identifier",
            "scoped_use_list",
            "self",
            "self_parameter",
            "shebang",
            "shorthand_field_identifier",
            "shorthand_field_initializer",
            "slice_pattern",
            "source_file",
            "static_item",
            "string_content",
            "string_literal",
            "struct_expression",
            "struct_item",
            "struct_pattern",
            "super",
            "token_binding_pattern",
            "token_repetition",
            "token_repetition_pattern",
            "token_tree",
            "token_tree_pattern",
            "trait_bounds",
            "trait_item",
            "try_block",
            "try_expression",
            "tuple_expression",
            "tuple_pattern",
            "tuple_struct_pattern",
            "tuple_type",
            "type_arguments",
            "type_binding",
            "type_cast_expression",
            "type_identifier",
            "type_item",
            "type_parameter",
            "type_parameters",
            "unary_expression",
            "union_item",
            "unit_expression",
            "unit_type",
            "unsafe_block",
            "use_as_clause",
            "use_bounds",
            "use_declaration",
            "use_list",
            "use_wildcard",
            "variadic_parameter",
            "visibility_modifier",
            "where_clause",
            "where_predicate",
            "while_expression",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_type",
            "arguments",
            "array_expression",
            "array_type",
            "assignment_expression",
            "associated_type",
            "async_block",
            "attribute",
            "attribute_item",
            "await_expression",
            "base_field_initializer",
            "binary_expression",
            "block",
            "block_comment",
            "boolean_literal",
            "bounded_type",
            "bracketed_type",
            "break_expression",
            "call_expression",
            "captured_pattern",
            "char_literal",
            "closure_expression",
            "closure_parameters",
            "compound_assignment_expr",
            "const_block",
            "const_item",
            "const_parameter",
            "continue_expression",
            "crate",
            "declaration_list",
            "doc_comment",
            "dynamic_type",
            "else_clause",
            "empty_statement",
            "enum_item",
            "enum_variant",
            "enum_variant_list",
            "escape_sequence",
            "expression_statement",
            "extern_crate_declaration",
            "extern_modifier",
            "field_declaration",
            "field_declaration_list",
            "field_expression",
            "field_identifier",
            "field_initializer",
            "field_initializer_list",
            "field_pattern",
            "float_literal",
            "for_expression",
            "for_lifetimes",
            "foreign_mod_item",
            "fragment_specifier",
            "function_item",
            "function_modifiers",
            "function_signature_item",
            "function_type",
            "gen_block",
            "generic_function",
            "generic_pattern",
            "generic_type",
            "generic_type_with_turbofish",
            "higher_ranked_trait_bound",
            "identifier",
            "if_expression",
            "impl_item",
            "index_expression",
            "inner_attribute_item",
            "inner_doc_comment_marker",
            "integer_literal",
            "label",
            "let_chain",
            "let_condition",
            "let_declaration",
            "lifetime",
            "lifetime_parameter",
            "line_comment",
            "loop_expression",
            "macro_definition",
            "macro_invocation",
            "macro_rule",
            "match_arm",
            "match_block",
            "match_expression",
            "match_pattern",
            "metavariable",
            "mod_item",
            "mut_pattern",
            "mutable_specifier",
            "negative_literal",
            "never_type",
            "or_pattern",
            "ordered_field_declaration_list",
            "outer_doc_comment_marker",
            "parameter",
            "parameters",
            "parenthesized_expression",
            "pointer_type",
            "primitive_type",
            "qualified_type",
            "range_expression",
            "range_pattern",
            "raw_string_literal",
            "ref_pattern",
            "reference_expression",
            "reference_pattern",
            "reference_type",
            "remaining_field_pattern",
            "removed_trait_bound",
            "return_expression",
            "scoped_identifier",
            "scoped_type_identifier",
            "scoped_use_list",
            "self",
            "self_parameter",
            "shebang",
            "shorthand_field_identifier",
            "shorthand_field_initializer",
            "slice_pattern",
            "source_file",
            "static_item",
            "string_content",
            "string_literal",
            "struct_expression",
            "struct_item",
            "struct_pattern",
            "super",
            "token_binding_pattern",
            "token_repetition",
            "token_repetition_pattern",
            "token_tree",
            "token_tree_pattern",
            "trait_bounds",
            "trait_item",
            "try_block",
            "try_expression",
            "tuple_expression",
            "tuple_pattern",
            "tuple_struct_pattern",
            "tuple_type",
            "type_arguments",
            "type_binding",
            "type_cast_expression",
            "type_identifier",
            "type_item",
            "type_parameter",
            "type_parameters",
            "unary_expression",
            "union_item",
            "unit_expression",
            "unit_type",
            "unsafe_block",
            "use_as_clause",
            "use_bounds",
            "use_declaration",
            "use_list",
            "use_wildcard",
            "variadic_parameter",
            "visibility_modifier",
            "where_clause",
            "where_predicate",
            "while_expression",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "body",
            "bounds",
            "condition",
            "consequence",
            "default_type",
            "doc",
            "element",
            "field",
            "function",
            "inner",
            "left",
            "length",
            "list",
            "macro",
            "name",
            "operator",
            "outer",
            "parameters",
            "path",
            "pattern",
            "return_type",
            "right",
            "trait",
            "type",
            "type_arguments",
            "type_parameters"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "rs",
        "rust",
        "Rust"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/scala_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for scala",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "access_modifier",
            "access_qualifier",
            "alternative_pattern",
            "annotated_type",
            "annotation",
            "arguments",
            "arrow_renamed_identifier",
            "as_renamed_identifier",
            "ascription_expression",
            "assignment_expression",
            "binding",
            "bindings",
            "block",
            "block_comment",
            "boolean_literal",
            "call_expression",
            "capture_pattern",
            "case_block",
            "case_class_pattern",
            "case_clause",
            "catch_clause",
            "character_literal",
            "class_definition",
            "class_parameter",
            "class_parameters",
            "colon_argument",
            "comment",
            "compilation_unit",
            "compound_type",
            "context_bound",
            "contravariant_type_parameter",
            "covariant_type_parameter",
            "derives_clause",
            "do_while_expression",
            "enum_body",
            "enum_case_definitions",
            "enum_definition",
            "enumerator",
            "enumerators",
            "error_sentinel",
            "escape_sequence",
            "export_declaration",
            "extends_clause",
            "extension_definition",
            "field_expression",
            "finally_clause",
            "floating_point_literal",
            "for_expression",
            "full_enum_case",
            "function_declaration",
            "function_definition",
            "function_type",
            "generic_function",
            "generic_type",
            "given_conditional",
            "given_definition",
            "given_pattern",
            "guard",
            "identifier",
            "identifiers",
            "if_expression",
            "import_declaration",
            "indented_block",
            "indented_cases",
            "infix_expression",
            "infix_modifier",
            "infix_pattern",
            "infix_type",
            "inline_modifier",
            "instance_expression",
            "integer_literal",
            "interpolated_string",
            "interpolated_string_expression",
            "interpolation",
            "lambda_expression",
            "lazy_parameter_type",
            "literal_type",
            "lower_bound",
            "macro_body",
            "match_expression",
            "match_type",
            "modifiers",
            "name_and_type",
            "named_pattern",
            "named_tuple_pattern",
            "named_tuple_type",
            "namespace_selectors",
            "namespace_wildcard",
            "null_literal",
            "object_definition",
            "opaque_modifier",
            "open_modifier",
            "operator_identifier",
            "package_clause",
            "package_identifier",
            "package_object",
            "parameter",
            "parameter_types",
            "parameters",
            "parenthesized_expression",
            "postfix_expression",
            "prefix_expression",
            "projected_type",
            "quote_expression",
            "refinement",
            "repeat_pattern",
            "repeated_parameter_type",
            "return_expression",
            "self_type",
            "simple_enum_case",
            "singleton_type",
            "splice_expression",
            "stable_identifier",
            "stable_type_identifier",
            "string",
            "structural_type",
            "template_body",
            "throw_expression",
            "trait_definition",
            "transparent_modifier",
            "try_expression",
            "tuple_expression",
            "tuple_pattern",
            "tuple_type",
            "type_arguments",
            "type_case_clause",
            "type_definition",
            "type_identifier",
            "type_lambda",
            "type_parameters",
            "typed_pattern",
            "unit",
            "upper_bound",
            "using_directive",
            "using_directive_key",
            "using_directive_value",
            "val_declaration",
            "val_definition",
            "var_declaration",
            "var_definition",
            "view_bound",
            "while_expression",
            "wildcard",
            "with_template_body"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "access_modifier",
            "access_qualifier",
            "alternative_pattern",
            "annotated_type",
            "annotation",
            "arguments",
            "arrow_renamed_identifier",
            "as_renamed_identifier",
            "ascription_expression",
            "assignment_expression",
            "binding",
            "bindings",
            "block",
            "block_comment",
            "boolean_literal",
            "call_expression",
            "capture_pattern",
            "case_block",
            "case_class_pattern",
            "case_clause",
            "catch_clause",
            "character_literal",
            "class_definition",
            "class_parameter",
            "class_parameters",
            "colon_argument",
            "comment",
            "compilation_unit",
            "compound_type",
            "context_bound",
            "contravariant_type_parameter",
            "covariant_type_parameter",
            "derives_clause",
            "do_while_expression",
            "enum_body",
            "enum_case_definitions",
            "enum_definition",
            "enumerator",
            "enumerators",
            "error_sentinel",
            "escape_sequence",
            "export_declaration",
            "extends_clause",
            "extension_definition",
            "field_expression",
            "finally_clause",
            "floating_point_literal",
            "for_expression",
            "full_enum_case",
            "function_declaration",
            "function_definition",
            "function_type",
            "generic_function",
            "generic_type",
            "given_conditional",
            "given_definition",
            "given_pattern",
            "guard",
            "identifier",
            "identifiers",
            "if_expression",
            "import_declaration",
            "indented_block",
            "indented_cases",
            "infix_expression",
            "infix_modifier",
            "infix_pattern",
            "infix_type",
            "inline_modifier",
            "instance_expression",
            "integer_literal",
            "interpolated_string",
            "interpolated_string_expression",
            "interpolation",
            "lambda_expression",
            "lazy_parameter_type",
            "literal_type",
            "lower_bound",
            "macro_body",
            "match_expression",
            "match_type",
            "modifiers",
            "name_and_type",
            "named_pattern",
            "named_tuple_pattern",
            "named_tuple_type",
            "namespace_selectors",
            "namespace_wildcard",
            "null_literal",
            "object_definition",
            "opaque_modifier",
            "open_modifier",
            "operator_identifier",
            "package_clause",
            "package_identifier",
            "package_object",
            "parameter",
            "parameter_types",
            "parameters",
            "parenthesized_expression",
            "postfix_expression",
            "prefix_expression",
            "projected_type",
            "quote_expression",
            "refinement",
            "repeat_pattern",
            "repeated_parameter_type",
            "return_expression",
            "self_type",
            "simple_enum_case",
            "singleton_type",
            "splice_expression",
            "stable_identifier",
            "stable_type_identifier",
            "string",
            "structural_type",
            "template_body",
            "throw_expression",
            "trait_definition",
            "transparent_modifier",
            "try_expression",
            "tuple_expression",
            "tuple_pattern",
            "tuple_type",
            "type_arguments",
            "type_case_clause",
            "type_definition",
            "type_identifier",
            "type_lambda",
            "type_parameters",
            "typed_pattern",
            "unit",
            "upper_bound",
            "using_directive",
            "using_directive_key",
            "using_directive_value",
            "val_declaration",
            "val_definition",
            "var_declaration",
            "var_definition",
            "view_bound",
            "while_expression",
            "wildcard",
            "with_template_body"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "arguments",
            "base",
            "body",
            "bound",
            "class_parameters",
            "condition",
            "consequence",
            "default_value",
            "derive",
            "enumerators",
            "extend",
            "extra",
            "field",
            "function",
            "interpolator",
            "lambda_start",
            "left",
            "name",
            "operator",
            "parameter_types",
            "parameters",
            "path",
            "pattern",
            "return_type",
            "right",
            "selector",
            "type",
            "type_arguments",
            "type_parameters"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "scala",
        "Scala"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/swift_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for swift",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "_expression",
            "additive_expression",
            "array_literal",
            "array_type",
            "as_expression",
            "as_operator",
            "assignment",
            "associatedtype_declaration",
            "attribute",
            "availability_condition",
            "await_expression",
            "bang",
            "bin_literal",
            "bitwise_operation",
            "boolean_literal",
            "call_expression",
            "call_suffix",
            "capture_list",
            "capture_list_item",
            "catch_block",
            "catch_keyword",
            "check_expression",
            "class_body",
            "class_declaration",
            "comment",
            "comparison_expression",
            "computed_getter",
            "computed_modify",
            "computed_property",
            "computed_setter",
            "conjunction_expression",
            "constructor_expression",
            "constructor_suffix",
            "control_transfer_statement",
            "custom_operator",
            "default_keyword",
            "deinit_declaration",
            "deprecated_operator_declaration_body",
            "diagnostic",
            "dictionary_literal",
            "dictionary_type",
            "didset_clause",
            "directive",
            "directly_assignable_expression",
            "disjunction_expression",
            "do_statement",
            "else",
            "enum_class_body",
            "enum_entry",
            "enum_type_parameters",
            "equality_constraint",
            "equality_expression",
            "existential_type",
            "external_macro_definition",
            "for_statement",
            "fully_open_range",
            "function_body",
            "function_declaration",
            "function_modifier",
            "function_type",
            "getter_specifier",
            "guard_statement",
            "hex_literal",
            "identifier",
            "if_statement",
            "import_declaration",
            "infix_expression",
            "inheritance_constraint",
            "inheritance_modifier",
            "inheritance_specifier",
            "init_declaration",
            "integer_literal",
            "interpolated_expression",
            "key_path_expression",
            "key_path_string_expression",
            "lambda_function_type",
            "lambda_function_type_parameters",
            "lambda_literal",
            "lambda_parameter",
            "line_str_text",
            "line_string_literal",
            "macro_declaration",
            "macro_definition",
            "macro_invocation",
            "member_modifier",
            "metatype",
            "modifiers",
            "modify_specifier",
            "multi_line_str_text",
            "multi_line_string_literal",
            "multiline_comment",
            "multiplicative_expression",
            "mutation_modifier",
            "navigation_expression",
            "navigation_suffix",
            "nil_coalescing_expression",
            "oct_literal",
            "opaque_type",
            "open_end_range_expression",
            "open_start_range_expression",
            "operator_declaration",
            "optional_type",
            "ownership_modifier",
            "parameter",
            "parameter_modifier",
            "parameter_modifiers",
            "pattern",
            "playground_literal",
            "postfix_expression",
            "precedence_group_attribute",
            "precedence_group_attributes",
            "precedence_group_declaration",
            "prefix_expression",
            "property_behavior_modifier",
            "property_declaration",
            "property_modifier",
            "protocol_body",
            "protocol_composition_type",
            "protocol_declaration",
            "protocol_function_declaration",
            "protocol_property_declaration",
            "protocol_property_requirements",
            "range_expression",
            "raw_str_continuing_indicator",
            "raw_str_end_part",
            "raw_str_interpolation",
            "raw_str_interpolation_start",
            "raw_str_part",
            "raw_string_literal",
            "real_literal",
            "regex_literal",
            "repeat_while_statement",
            "selector_expression",
            "self_expression",
            "setter_specifier",
            "shebang_line",
            "simple_identifier",
            "source_file",
            "special_literal",
            "statement_label",
            "statements",
            "str_escaped_char",
            "subscript_declaration",
            "super_expression",
            "suppressed_constraint",
            "switch_entry",
            "switch_pattern",
            "switch_statement",
            "ternary_expression",
            "throw_keyword",
            "throws",
            "try_expression",
            "try_operator",
            "tuple_expression",
            "tuple_type",
            "tuple_type_item",
            "type_annotation",
            "type_arguments",
            "type_constraint",
            "type_constraints",
            "type_identifier",
            "type_modifiers",
            "type_pack_expansion",
            "type_parameter",
            "type_parameter_modifiers",
            "type_parameter_pack",
            "type_parameters",
            "typealias_declaration",
            "user_type",
            "value_argument",
            "value_argument_label",
            "value_arguments",
            "value_binding_pattern",
            "value_pack_expansion",
            "value_parameter_pack",
            "visibility_modifier",
            "where_clause",
            "where_keyword",
            "while_statement",
            "wildcard_pattern",
            "willset_clause",
            "willset_didset_block"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "_expression",
            "additive_expression",
            "array_literal",
            "array_type",
            "as_expression",
            "as_operator",
            "assignment",
            "associatedtype_declaration",
            "attribute",
            "availability_condition",
            "await_expression",
            "bang",
            "bin_literal",
            "bitwise_operation",
            "boolean_literal",
            "call_expression",
            "call_suffix",
            "capture_list",
            "capture_list_item",
            "catch_block",
            "catch_keyword",
            "check_expression",
            "class_body",
            "class_declaration",
            "comment",
            "comparison_expression",
            "computed_getter",
            "computed_modify",
            "computed_property",
            "computed_setter",
            "conjunction_expression",
            "constructor_expression",
            "constructor_suffix",
            "control_transfer_statement",
            "custom_operator",
            "default_keyword",
            "deinit_declaration",
            "deprecated_operator_declaration_body",
            "diagnostic",
            "dictionary_literal",
            "dictionary_type",
            "didset_clause",
            "directive",
            "directly_assignable_expression",
            "disjunction_expression",
            "do_statement",
            "else",
            "enum_class_body",
            "enum_entry",
            "enum_type_parameters",
            "equality_constraint",
            "equality_expression",
            "existential_type",
            "external_macro_definition",
            "for_statement",
            "fully_open_range",
            "function_body",
            "function_declaration",
            "function_modifier",
            "function_type",
            "getter_specifier",
            "guard_statement",
            "hex_literal",
            "identifier",
            "if_statement",
            "import_declaration",
            "infix_expression",
            "inheritance_constraint",
            "inheritance_modifier",
            "inheritance_specifier",
            "init_declaration",
            "integer_literal",
            "interpolated_expression",
            "key_path_expression",
            "key_path_string_expression",
            "lambda_function_type",
            "lambda_function_type_parameters",
            "lambda_literal",
            "lambda_parameter",
            "line_str_text",
            "line_string_literal",
            "macro_declaration",
            "macro_definition",
            "macro_invocation",
            "member_modifier",
            "metatype",
            "modifiers",
            "modify_specifier",
            "multi_line_str_text",
            "multi_line_string_literal",
            "multiline_comment",
            "multiplicative_expression",
            "mutation_modifier",
            "navigation_expression",
            "navigation_suffix",
            "nil_coalescing_expression",
            "oct_literal",
            "opaque_type",
            "open_end_range_expression",
            "open_start_range_expression",
            "operator_declaration",
            "optional_type",
            "ownership_modifier",
            "parameter",
            "parameter_modifier",
            "parameter_modifiers",
            "pattern",
            "playground_literal",
            "postfix_expression",
            "precedence_group_attribute",
            "precedence_group_attributes",
            "precedence_group_declaration",
            "prefix_expression",
            "property_behavior_modifier",
            "property_declaration",
            "property_modifier",
            "protocol_body",
            "protocol_composition_type",
            "protocol_declaration",
            "protocol_function_declaration",
            "protocol_property_declaration",
            "protocol_property_requirements",
            "range_expression",
            "raw_str_continuing_indicator",
            "raw_str_end_part",
            "raw_str_interpolation",
            "raw_str_interpolation_start",
            "raw_str_part",
            "raw_string_literal",
            "real_literal",
            "regex_literal",
            "repeat_while_statement",
            "selector_expression",
            "self_expression",
            "setter_specifier",
            "shebang_line",
            "simple_identifier",
            "source_file",
            "special_literal",
            "statement_label",
            "statements",
            "str_escaped_char",
            "subscript_declaration",
            "super_expression",
            "suppressed_constraint",
            "switch_entry",
            "switch_pattern",
            "switch_statement",
            "ternary_expression",
            "throw_keyword",
            "throws",
            "try_expression",
            "try_operator",
            "tuple_expression",
            "tuple_type",
            "tuple_type_item",
            "type_annotation",
            "type_arguments",
            "type_constraint",
            "type_constraints",
            "type_identifier",
            "type_modifiers",
            "type_pack_expansion",
            "type_parameter",
            "type_parameter_modifiers",
            "type_parameter_pack",
            "type_parameters",
            "typealias_declaration",
            "user_type",
            "value_argument",
            "value_argument_label",
            "value_arguments",
            "value_binding_pattern",
            "value_pack_expansion",
            "value_parameter_pack",
            "visibility_modifier",
            "where_clause",
            "where_keyword",
            "while_statement",
            "wildcard_pattern",
            "willset_clause",
            "willset_didset_block"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "body",
            "bound_identifier",
            "captures",
            "collection",
            "computed_value",
            "condition",
            "constrained_type",
            "constructed_type",
            "data_contents",
            "declaration_kind",
            "default_value",
            "definition",
            "element",
            "end",
            "error",
            "expr",
            "external_name",
            "if_false",
            "if_nil",
            "if_true",
            "inherits_from",
            "interpolation",
            "item",
            "key",
            "lhs",
            "must_equal",
            "must_inherit",
            "mutability",
            "name",
            "op",
            "operation",
            "operator",
            "params",
            "raw_value",
            "reference_specifier",
            "result",
            "return_type",
            "rhs",
            "start",
            "suffix",
            "suppressed",
            "target",
            "text",
            "type",
            "value"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "swift",
        "Swift"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/tsx_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for tsx",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_class_declaration",
            "abstract_method_signature",
            "accessibility_modifier",
            "adding_type_annotation",
            "ambient_declaration",
            "arguments",
            "array",
            "array_pattern",
            "array_type",
            "arrow_function",
            "as_expression",
            "asserts",
            "asserts_annotation",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "call_signature",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "conditional_type",
            "constraint",
            "construct_signature",
            "constructor_type",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "default_type",
            "do_statement",
            "else_clause",
            "empty_statement",
            "enum_assignment",
            "enum_body",
            "enum_declaration",
            "escape_sequence",
            "existential_type",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "extends_clause",
            "extends_type_clause",
            "false",
            "finally_clause",
            "flow_maybe_type",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "function_signature",
            "function_type",
            "generator_function",
            "generator_function_declaration",
            "generic_type",
            "hash_bang_line",
            "html_character_reference",
            "html_comment",
            "identifier",
            "if_statement",
            "implements_clause",
            "import",
            "import_alias",
            "import_attribute",
            "import_clause",
            "import_require_clause",
            "import_specifier",
            "import_statement",
            "index_signature",
            "index_type_query",
            "infer_type",
            "instantiation_expression",
            "interface_body",
            "interface_declaration",
            "internal_module",
            "intersection_type",
            "jsx_attribute",
            "jsx_closing_element",
            "jsx_element",
            "jsx_expression",
            "jsx_namespace_name",
            "jsx_opening_element",
            "jsx_self_closing_element",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "literal_type",
            "lookup_type",
            "mapped_type_clause",
            "member_expression",
            "meta_property",
            "method_definition",
            "method_signature",
            "module",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "nested_identifier",
            "nested_type_identifier",
            "new_expression",
            "non_null_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "object_type",
            "omitting_type_annotation",
            "opting_type_annotation",
            "optional_chain",
            "optional_parameter",
            "optional_type",
            "override_modifier",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "parenthesized_type",
            "predefined_type",
            "private_property_identifier",
            "program",
            "property_identifier",
            "property_signature",
            "public_field_definition",
            "readonly_type",
            "regex",
            "regex_flags",
            "regex_pattern",
            "required_parameter",
            "rest_pattern",
            "rest_type",
            "return_statement",
            "satisfies_expression",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_literal_type",
            "template_string",
            "template_substitution",
            "template_type",
            "ternary_expression",
            "this",
            "this_type",
            "throw_statement",
            "true",
            "try_statement",
            "tuple_type",
            "type_alias_declaration",
            "type_annotation",
            "type_arguments",
            "type_identifier",
            "type_parameter",
            "type_parameters",
            "type_predicate",
            "type_predicate_annotation",
            "type_query",
            "unary_expression",
            "undefined",
            "union_type",
            "update_expression",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_class_declaration",
            "abstract_method_signature",
            "accessibility_modifier",
            "adding_type_annotation",
            "ambient_declaration",
            "arguments",
            "array",
            "array_pattern",
            "array_type",
            "arrow_function",
            "as_expression",
            "asserts",
            "asserts_annotation",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "call_signature",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "conditional_type",
            "constraint",
            "construct_signature",
            "constructor_type",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "default_type",
            "do_statement",
            "else_clause",
            "empty_statement",
            "enum_assignment",
            "enum_body",
            "enum_declaration",
            "escape_sequence",
            "existential_type",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "extends_clause",
            "extends_type_clause",
            "false",
            "finally_clause",
            "flow_maybe_type",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "function_signature",
            "function_type",
            "generator_function",
            "generator_function_declaration",
            "generic_type",
            "hash_bang_line",
            "html_character_reference",
            "html_comment",
            "identifier",
            "if_statement",
            "implements_clause",
            "import",
            "import_alias",
            "import_attribute",
            "import_clause",
            "import_require_clause",
            "import_specifier",
            "import_statement",
            "index_signature",
            "index_type_query",
            "infer_type",
            "instantiation_expression",
            "interface_body",
            "interface_declaration",
            "internal_module",
            "intersection_type",
            "jsx_attribute",
            "jsx_closing_element",
            "jsx_element",
            "jsx_expression",
            "jsx_namespace_name",
            "jsx_opening_element",
            "jsx_self_closing_element",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "literal_type",
            "lookup_type",
            "mapped_type_clause",
            "member_expression",
            "meta_property",
            "method_definition",
            "method_signature",
            "module",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "nested_identifier",
            "nested_type_identifier",
            "new_expression",
            "non_null_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "object_type",
            "omitting_type_annotation",
            "opting_type_annotation",
            "optional_chain",
            "optional_parameter",
            "optional_type",
            "override_modifier",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "parenthesized_type",
            "predefined_type",
            "private_property_identifier",
            "program",
            "property_identifier",
            "property_signature",
            "public_field_definition",
            "readonly_type",
            "regex",
            "regex_flags",
            "regex_pattern",
            "required_parameter",
            "rest_pattern",
            "rest_type",
            "return_statement",
            "satisfies_expression",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_literal_type",
            "template_string",
            "template_substitution",
            "template_type",
            "ternary_expression",
            "this",
            "this_type",
            "throw_statement",
            "true",
            "try_statement",
            "tuple_type",
            "type_alias_declaration",
            "type_annotation",
            "type_arguments",
            "type_identifier",
            "type_parameter",
            "type_parameters",
            "type_predicate",
            "type_predicate_annotation",
            "type_query",
            "unary_expression",
            "undefined",
            "union_type",
            "update_expression",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "attribute",
            "body",
            "close_tag",
            "condition",
            "consequence",
            "constraint",
            "constructor",
            "declaration",
            "decorator",
            "finalizer",
            "flags",
            "function",
            "handler",
            "increment",
            "index",
            "index_type",
            "initializer",
            "key",
            "kind",
            "label",
            "left",
            "module",
            "name",
            "object",
            "open_tag",
            "operator",
            "optional_chain",
            "parameter",
            "parameters",
            "pattern",
            "property",
            "return_type",
            "right",
            "sign",
            "source",
            "type",
            "type_arguments",
            "type_parameters"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "tsx",
        "Tsx"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/typescript_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for typescript",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_class_declaration",
            "abstract_method_signature",
            "accessibility_modifier",
            "adding_type_annotation",
            "ambient_declaration",
            "arguments",
            "array",
            "array_pattern",
            "array_type",
            "arrow_function",
            "as_expression",
            "asserts",
            "asserts_annotation",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "call_signature",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "conditional_type",
            "constraint",
            "construct_signature",
            "constructor_type",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "default_type",
            "do_statement",
            "else_clause",
            "empty_statement",
            "enum_assignment",
            "enum_body",
            "enum_declaration",
            "escape_sequence",
            "existential_type",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "extends_clause",
            "extends_type_clause",
            "false",
            "finally_clause",
            "flow_maybe_type",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "function_signature",
            "function_type",
            "generator_function",
            "generator_function_declaration",
            "generic_type",
            "hash_bang_line",
            "html_comment",
            "identifier",
            "if_statement",
            "implements_clause",
            "import",
            "import_alias",
            "import_attribute",
            "import_clause",
            "import_require_clause",
            "import_specifier",
            "import_statement",
            "index_signature",
            "index_type_query",
            "infer_type",
            "instantiation_expression",
            "interface_body",
            "interface_declaration",
            "internal_module",
            "intersection_type",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "literal_type",
            "lookup_type",
            "mapped_type_clause",
            "member_expression",
            "meta_property",
            "method_definition",
            "method_signature",
            "module",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "nested_identifier",
            "nested_type_identifier",
            "new_expression",
            "non_null_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "object_type",
            "omitting_type_annotation",
            "opting_type_annotation",
            "optional_chain",
            "optional_parameter",
            "optional_type",
            "override_modifier",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "parenthesized_type",
            "predefined_type",
            "private_property_identifier",
            "program",
            "property_identifier",
            "property_signature",
            "public_field_definition",
            "readonly_type",
            "regex",
            "regex_flags",
            "regex_pattern",
            "required_parameter",
            "rest_pattern",
            "rest_type",
            "return_statement",
            "satisfies_expression",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_literal_type",
            "template_string",
            "template_substitution",
            "template_type",
            "ternary_expression",
            "this",
            "this_type",
            "throw_statement",
            "true",
            "try_statement",
            "tuple_type",
            "type_alias_declaration",
            "type_annotation",
            "type_arguments",
            "type_assertion",
            "type_identifier",
            "type_parameter",
            "type_parameters",
            "type_predicate",
            "type_predicate_annotation",
            "type_query",
            "unary_expression",
            "undefined",
            "union_type",
            "update_expression",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "abstract_class_declaration",
            "abstract_method_signature",
            "accessibility_modifier",
            "adding_type_annotation",
            "ambient_declaration",
            "arguments",
            "array",
            "array_pattern",
            "array_type",
            "arrow_function",
            "as_expression",
            "asserts",
            "asserts_annotation",
            "assignment_expression",
            "assignment_pattern",
            "augmented_assignment_expression",
            "await_expression",
            "binary_expression",
            "break_statement",
            "call_expression",
            "call_signature",
            "catch_clause",
            "class",
            "class_body",
            "class_declaration",
            "class_heritage",
            "class_static_block",
            "comment",
            "computed_property_name",
            "conditional_type",
            "constraint",
            "construct_signature",
            "constructor_type",
            "continue_statement",
            "debugger_statement",
            "decorator",
            "default_type",
            "do_statement",
            "else_clause",
            "empty_statement",
            "enum_assignment",
            "enum_body",
            "enum_declaration",
            "escape_sequence",
            "existential_type",
            "export_clause",
            "export_specifier",
            "export_statement",
            "expression_statement",
            "extends_clause",
            "extends_type_clause",
            "false",
            "finally_clause",
            "flow_maybe_type",
            "for_in_statement",
            "for_statement",
            "formal_parameters",
            "function_declaration",
            "function_expression",
            "function_signature",
            "function_type",
            "generator_function",
            "generator_function_declaration",
            "generic_type",
            "hash_bang_line",
            "html_comment",
            "identifier",
            "if_statement",
            "implements_clause",
            "import",
            "import_alias",
            "import_attribute",
            "import_clause",
            "import_require_clause",
            "import_specifier",
            "import_statement",
            "index_signature",
            "index_type_query",
            "infer_type",
            "instantiation_expression",
            "interface_body",
            "interface_declaration",
            "internal_module",
            "intersection_type",
            "jsx_text",
            "labeled_statement",
            "lexical_declaration",
            "literal_type",
            "lookup_type",
            "mapped_type_clause",
            "member_expression",
            "meta_property",
            "method_definition",
            "method_signature",
            "module",
            "named_imports",
            "namespace_export",
            "namespace_import",
            "nested_identifier",
            "nested_type_identifier",
            "new_expression",
            "non_null_expression",
            "null",
            "number",
            "object",
            "object_assignment_pattern",
            "object_pattern",
            "object_type",
            "omitting_type_annotation",
            "opting_type_annotation",
            "optional_chain",
            "optional_parameter",
            "optional_type",
            "override_modifier",
            "pair",
            "pair_pattern",
            "parenthesized_expression",
            "parenthesized_type",
            "predefined_type",
            "private_property_identifier",
            "program",
            "property_identifier",
            "property_signature",
            "public_field_definition",
            "readonly_type",
            "regex",
            "regex_flags",
            "regex_pattern",
            "required_parameter",
            "rest_pattern",
            "rest_type",
            "return_statement",
            "satisfies_expression",
            "sequence_expression",
            "shorthand_property_identifier",
            "shorthand_property_identifier_pattern",
            "spread_element",
            "statement_block",
            "statement_identifier",
            "string",
            "string_fragment",
            "subscript_expression",
            "super",
            "switch_body",
            "switch_case",
            "switch_default",
            "switch_statement",
            "template_literal_type",
            "template_string",
            "template_substitution",
            "template_type",
            "ternary_expression",
            "this",
            "this_type",
            "throw_statement",
            "true",
            "try_statement",
            "tuple_type",
            "type_alias_declaration",
            "type_annotation",
            "type_arguments",
            "type_assertion",
            "type_identifier",
            "type_parameter",
            "type_parameters",
            "type_predicate",
            "type_predicate_annotation",
            "type_query",
            "unary_expression",
            "undefined",
            "union_type",
            "update_expression",
            "variable_declaration",
            "variable_declarator",
            "while_statement",
            "with_statement",
            "yield_expression"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "alias",
            "alternative",
            "argument",
            "arguments",
            "body",
            "condition",
            "consequence",
            "constraint",
            "constructor",
            "declaration",
            "decorator",
            "finalizer",
            "flags",
            "function",
            "handler",
            "increment",
            "index",
            "index_type",
            "initializer",
            "key",
            "kind",
            "label",
            "left",
            "module",
            "name",
            "object",
            "operator",
            "optional_chain",
            "parameter",
            "parameters",
            "pattern",
            "property",
            "return_type",
            "right",
            "sign",
            "source",
            "type",
            "type_arguments",
            "type_parameters"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "ts",
        "typescript",
        "TypeScript"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: schemas/yaml_rule.json
================================================
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ast-grep rule for yaml",
  "description": "Used for global rules, rewriters, and pyo3/napi",
  "type": "object",
  "properties": {
    "rule": {
      "description": "A rule object to find matching AST nodes",
      "$ref": "#/$defs/SerializableRule"
    },
    "constraints": {
      "description": "Additional meta variables pattern to filter matching",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "utils": {
      "description": "Utility rules that can be used in `matches`",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/SerializableRule"
      }
    },
    "transform": {
      "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Transformation"
      }
    },
    "fix": {
      "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
      "anyOf": [
        {
          "$ref": "#/$defs/SerializableFixer"
        },
        {
          "type": "null"
        }
      ]
    },
    "id": {
      "description": "Unique, descriptive identifier, e.g., no-unused-variable",
      "type": "string"
    },
    "language": {
      "description": "Specify the language to parse and the file extension to include in matching.",
      "$ref": "#/$defs/Language"
    },
    "rewriters": {
      "description": "Rewrite rules for `rewrite` transformation",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/$defs/SerializableRewriter"
      }
    },
    "message": {
      "description": "Main message highlighting why this rule fired. It should be single line and concise,\nbut specific enough to be understood without additional context.",
      "type": "string",
      "default": ""
    },
    "note": {
      "description": "Additional notes to elaborate the message and provide potential fix to the issue.\n`notes` can contain markdown syntax, but it cannot reference meta-variables.",
      "type": [
        "string",
        "null"
      ]
    },
    "severity": {
      "description": "One of: hint, info, warning, or error",
      "$ref": "#/$defs/Severity",
      "default": "hint"
    },
    "labels": {
      "description": "Custom label dictionary to configure reporting. Key is the meta-variable name and\nvalue is the label message and label style.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "$ref": "#/$defs/LabelConfig"
      }
    },
    "files": {
      "description": "Glob patterns to specify that the rule only applies to matching files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "ignores": {
      "description": "Glob patterns that exclude rules from applying to files",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      }
    },
    "url": {
      "description": "Documentation link to this rule",
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "description": "Extra information for the rule",
      "anyOf": [
        {
          "$ref": "#/$defs/Metadata"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "rule",
    "id",
    "language"
  ],
  "$defs": {
    "SerializableRule": {
      "description": "A rule object to find matching AST nodes. We have three categories of rules in ast-grep.\n\n* Atomic: the most basic rule to match AST. We have two variants: Pattern and Kind.\n\n* Relational: filter matched target according to their position relative to other nodes.\n\n* Composite: use logic operation all/any/not to compose the above rules to larger rules.\n\nEvery rule has it's unique name so we can combine several rules in one object.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "alias",
            "alias_name",
            "anchor",
            "anchor_name",
            "block_mapping",
            "block_mapping_pair",
            "block_node",
            "block_scalar",
            "block_sequence",
            "block_sequence_item",
            "boolean_scalar",
            "comment",
            "directive_name",
            "directive_parameter",
            "document",
            "double_quote_scalar",
            "escape_sequence",
            "float_scalar",
            "flow_mapping",
            "flow_node",
            "flow_pair",
            "flow_sequence",
            "integer_scalar",
            "null_scalar",
            "plain_scalar",
            "reserved_directive",
            "single_quote_scalar",
            "stream",
            "string_scalar",
            "tag",
            "tag_directive",
            "tag_handle",
            "tag_prefix",
            "timestamp_scalar",
            "yaml_directive",
            "yaml_version"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PatternStyle": {
      "description": "A String pattern will match one single AST node according to pattern syntax.\nOr an object with field `context`, `selector` and optionally `strictness`.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "object",
          "properties": {
            "context": {
              "description": "The surrounding code that helps to resolve any ambiguity in the syntax.",
              "type": "string"
            },
            "selector": {
              "description": "The sub-syntax node kind that is the actual matcher of the pattern.",
              "type": [
                "string",
                "null"
              ]
            },
            "strictness": {
              "description": "Strictness of the pattern. More strict pattern matches fewer nodes.",
              "anyOf": [
                {
                  "$ref": "#/$defs/Strictness"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": [
            "context"
          ]
        }
      ]
    },
    "Strictness": {
      "oneOf": [
        {
          "description": "all nodes are matched",
          "type": "string",
          "const": "cst"
        },
        {
          "description": "all nodes except source trivial nodes are matched.",
          "type": "string",
          "const": "smart"
        },
        {
          "description": "only ast nodes are matched",
          "type": "string",
          "const": "ast"
        },
        {
          "description": "ast-nodes excluding comments are matched",
          "type": "string",
          "const": "relaxed"
        },
        {
          "description": "ast-nodes excluding comments, without text",
          "type": "string",
          "const": "signature"
        },
        {
          "description": "similar to smart, but node kinds are ignored, only text is matched.",
          "type": "string",
          "const": "template"
        }
      ]
    },
    "SerializableNthChild": {
      "description": "`nthChild` accepts either a number, a string or an object.",
      "anyOf": [
        {
          "description": "Simple syntax",
          "$ref": "#/$defs/NthChildSimple"
        },
        {
          "description": "Object style syntax",
          "type": "object",
          "properties": {
            "position": {
              "description": "nth-child syntax",
              "$ref": "#/$defs/NthChildSimple"
            },
            "ofRule": {
              "description": "select the nth node that matches the rule, like CSS's of syntax",
              "anyOf": [
                {
                  "$ref": "#/$defs/SerializableRule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reverse": {
              "description": "matches from the end instead like CSS's nth-last-child",
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "position"
          ]
        }
      ]
    },
    "NthChildSimple": {
      "description": "A string or number describing the indices of matching nodes in a list of siblings.",
      "anyOf": [
        {
          "description": "A number indicating the precise element index",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        {
          "description": "Functional notation like CSS's An + B",
          "type": "string"
        }
      ]
    },
    "SerializableRange": {
      "description": "Represents a position in source code using 0-based line and column numbers",
      "type": "object",
      "properties": {
        "start": {
          "description": "start position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        },
        "end": {
          "description": "end position in the source code",
          "$ref": "#/$defs/SerializablePosition"
        }
      },
      "required": [
        "start",
        "end"
      ]
    },
    "SerializablePosition": {
      "description": "Represents a zero-based character-wise position in a document",
      "type": "object",
      "properties": {
        "line": {
          "description": "0-based line number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        },
        "column": {
          "description": "0-based column number in the source code",
          "type": "integer",
          "format": "uint",
          "minimum": 0
        }
      },
      "required": [
        "line",
        "column"
      ]
    },
    "Relation": {
      "description": "A relational rule object, which is a Rule object with two additional fields stopBy and field.",
      "type": "object",
      "properties": {
        "pattern": {
          "description": "A pattern string or a pattern object.",
          "$ref": "#/$defs/PatternStyle"
        },
        "kind": {
          "description": "The kind name of the node to match. You can look up code's kind names in playground.",
          "type": "string",
          "enum": [
            "alias",
            "alias_name",
            "anchor",
            "anchor_name",
            "block_mapping",
            "block_mapping_pair",
            "block_node",
            "block_scalar",
            "block_sequence",
            "block_sequence_item",
            "boolean_scalar",
            "comment",
            "directive_name",
            "directive_parameter",
            "document",
            "double_quote_scalar",
            "escape_sequence",
            "float_scalar",
            "flow_mapping",
            "flow_node",
            "flow_pair",
            "flow_sequence",
            "integer_scalar",
            "null_scalar",
            "plain_scalar",
            "reserved_directive",
            "single_quote_scalar",
            "stream",
            "string_scalar",
            "tag",
            "tag_directive",
            "tag_handle",
            "tag_prefix",
            "timestamp_scalar",
            "yaml_directive",
            "yaml_version"
          ]
        },
        "regex": {
          "description": "A Rust regular expression to match the node's text. https://docs.rs/regex/latest/regex/#syntax",
          "type": "string"
        },
        "nthChild": {
          "description": "`nth_child` accepts number, string or object.\nIt specifies the position in nodes' sibling list.",
          "$ref": "#/$defs/SerializableNthChild"
        },
        "range": {
          "description": "`range` accepts a range object.\nthe target node must exactly appear in the range.",
          "$ref": "#/$defs/SerializableRange"
        },
        "inside": {
          "description": "`inside` accepts a relational rule object.\nthe target node must appear inside of another node matching the `inside` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "has": {
          "description": "`has` accepts a relational rule object.\nthe target node must has a descendant node matching the `has` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "precedes": {
          "description": "`precedes` accepts a relational rule object.\nthe target node must appear before another node matching the `precedes` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "follows": {
          "description": "`follows` accepts a relational rule object.\nthe target node must appear after another node matching the `follows` sub-rule.",
          "$ref": "#/$defs/Relation"
        },
        "all": {
          "description": "A list of sub rules and matches a node if all of sub rules match.\nThe meta variables of the matched node contain all variables from the sub-rules.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "any": {
          "description": "A list of sub rules and matches a node if any of sub rules match.\nThe meta variables of the matched node only contain those of the matched sub-rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "not": {
          "description": "A single sub-rule and matches a node if the sub rule does not match.",
          "$ref": "#/$defs/SerializableRule"
        },
        "matches": {
          "description": "A utility rule id and matches a node if the utility rule matches.",
          "type": "string"
        },
        "stopBy": {
          "$ref": "#/$defs/SerializableStopBy",
          "default": "neighbor"
        },
        "field": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "key"
          ]
        }
      }
    },
    "SerializableStopBy": {
      "description": "Control how the relational rule search should stop",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "neighbor",
            "end"
          ]
        },
        {
          "$ref": "#/$defs/SerializableRule"
        }
      ]
    },
    "Transformation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/Trans"
        }
      ]
    },
    "Trans": {
      "description": "Represents a transformation that can be applied to a matched AST node.\nAvailable transformations are `substring`, `replace` and `convert`.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "substring": {
              "$ref": "#/$defs/Substring"
            }
          },
          "required": [
            "substring"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "replace": {
              "$ref": "#/$defs/Replace"
            }
          },
          "required": [
            "replace"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "convert": {
              "$ref": "#/$defs/Convert"
            }
          },
          "required": [
            "convert"
          ],
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "rewrite": {
              "$ref": "#/$defs/Rewrite"
            }
          },
          "required": [
            "rewrite"
          ],
          "additionalProperties": false
        }
      ]
    },
    "Substring": {
      "description": "Extracts a substring from the meta variable's text content.\n\nBoth `start_char` and `end_char` support negative indexing,\nwhich counts character from the end of an array, moving backwards.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "startChar": {
          "description": "optional starting character index of the substring, defaults to 0.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "endChar": {
          "description": "optional ending character index of the substring, defaults to the end of the string.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      },
      "required": [
        "source"
      ]
    },
    "Replace": {
      "description": "Replaces a substring in the meta variable's text content with another string.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "replace": {
          "description": "a regex to find substring to be replaced",
          "type": "string"
        },
        "by": {
          "description": "the replacement string",
          "type": "string"
        }
      },
      "required": [
        "source",
        "replace",
        "by"
      ]
    },
    "Convert": {
      "description": "Converts the source meta variable's text content to a specified case format.",
      "type": "object",
      "properties": {
        "source": {
          "description": "source meta variable to be transformed",
          "type": "string"
        },
        "toCase": {
          "description": "the target case format to convert the text content to",
          "$ref": "#/$defs/StringCase"
        },
        "separatedBy": {
          "description": "optional separators to specify how to separate word",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Separator"
          }
        }
      },
      "required": [
        "source",
        "toCase"
      ]
    },
    "StringCase": {
      "description": "An enumeration representing different cases for strings.",
      "type": "string",
      "enum": [
        "lowerCase",
        "upperCase",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "pascalCase"
      ]
    },
    "Separator": {
      "description": "Separator to split string. e.g. `user_accountName` -> `user`, `accountName`\nIt will be rejoin according to `StringCase`.",
      "type": "string",
      "enum": [
        "caseChange",
        "dash",
        "dot",
        "slash",
        "space",
        "underscore"
      ]
    },
    "Rewrite": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "rewriters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "joinBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "source",
        "rewriters"
      ]
    },
    "SerializableFixer": {
      "description": "A pattern string or fix object to auto fix the issue.\nIt can reference metavariables appeared in rule.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/$defs/SerializableFixConfig"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SerializableFixConfig"
          }
        }
      ]
    },
    "SerializableFixConfig": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string"
        },
        "expandEnd": {
          "$ref": "#/$defs/Relation"
        },
        "expandStart": {
          "$ref": "#/$defs/Relation"
        },
        "title": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "template"
      ]
    },
    "Language": {
      "description": "Placeholder for language, used in JSON schema only.",
      "type": "string",
      "example": "typescript",
      "enum": [
        "yaml",
        "yml",
        "Yaml"
      ]
    },
    "SerializableRewriter": {
      "description": "Used for global rules, rewriters, and pyo3/napi",
      "type": "object",
      "properties": {
        "rule": {
          "description": "A rule object to find matching AST nodes",
          "$ref": "#/$defs/SerializableRule"
        },
        "constraints": {
          "description": "Additional meta variables pattern to filter matching",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "utils": {
          "description": "Utility rules that can be used in `matches`",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/SerializableRule"
          }
        },
        "transform": {
          "description": "A dictionary for metavariable manipulation. Dict key is the new variable name.\nDict value is a [transformation] that specifies how meta var is processed.\nSee [transformation doc](https://ast-grep.github.io/reference/yaml/transformation.html).",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/$defs/Transformation"
          }
        },
        "fix": {
          "description": "A pattern string or a FixConfig object to auto fix the issue.\nIt can reference metavariables appeared in rule.\nSee details in fix [object reference](https://ast-grep.github.io/reference/yaml/fix.html#fixconfig).",
          "anyOf": [
            {
              "$ref": "#/$defs/SerializableFixer"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "description": "Unique, descriptive identifier, e.g., no-unused-variable",
          "type": "string"
        }
      },
      "required": [
        "rule",
        "id"
      ]
    },
    "Severity": {
      "oneOf": [
        {
          "description": "A kind reminder for code with potential improvement.",
          "type": "string",
          "const": "hint"
        },
        {
          "description": "A suggestion that code can be improved or optimized.",
          "type": "string",
          "const": "info"
        },
        {
          "description": "A warning that code might produce bugs or does not follow best practice.",
          "type": "string",
          "const": "warning"
        },
        {
          "description": "An error that code produces bugs or has logic errors.",
          "type": "string",
          "const": "error"
        },
        {
          "description": "Turns off the rule.",
          "type": "string",
          "const": "off"
        }
      ]
    },
    "LabelConfig": {
      "type": "object",
      "properties": {
        "style": {
          "$ref": "#/$defs/LabelStyle"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "style"
      ]
    },
    "LabelStyle": {
      "oneOf": [
        {
          "description": "Labels that describe the primary cause of a diagnostic.",
          "type": "string",
          "const": "primary"
        },
        {
          "description": "Labels that provide additional context for a diagnostic.",
          "type": "string",
          "const": "secondary"
        }
      ]
    },
    "Metadata": {
      "description": "Additional metadata for the rule, can be used to store extra information.",
      "type": "object",
      "additionalProperties": true
    }
  }
}


================================================
FILE: xtask/Cargo.toml
================================================
[package]
publish = false
name = "xtask"
version = "0.0.0"

authors.workspace = true
edition.workspace = true

[dependencies]
ast-grep-core.workspace = true
ast-grep-config.workspace = true
ast-grep-language.workspace = true

anyhow.workspace = true
serde_json = { version = "1.0.116", features = ["preserve_order"] }
toml_edit = "0.23.0"
schemars.workspace = true


================================================
FILE: xtask/src/main.rs
================================================
mod schema;
use anyhow::{bail, Context, Result};
use serde_json::{from_str as parse_json, to_string_pretty, Value as JSON};
use std::env::args;
use std::fs::{self, read_dir, read_to_string};
use std::path::Path;
use std::process::{Command, Stdio};
use toml_edit::{value as to_toml, DocumentMut};

enum Task {
  Schema,
  Release(String),
}

fn get_task() -> Result<Task> {
  let message = "argument is missing. Example usage: \ncargo xtask 0.1.3\ncargo xtask schema";
  let arg = args().nth(1).context(message)?;
  if arg == "schema" {
    Ok(Task::Schema)
  } else {
    Ok(Task::Release(arg))
  }
}

fn main() -> Result<()> {
  match get_task()? {
    Task::Schema => schema::generate_schema(),
    Task::Release(version) => release_new_version(&version),
  }
}

fn release_new_version(version: &str) -> Result<()> {
  check_git_status()?;
  schema::generate_schema()?;
  bump_version(version)?;
  update_and_commit_changelog()?;
  commit_and_tag(version)?;
  Ok(())
}

fn check_git_status() -> Result<()> {
  let git = Command::new("git")
    .arg("status")
    .arg("--porcelain")
    .stdout(Stdio::piped())
    .spawn()?
    .wait_with_output()?;
  if !git.stdout.is_empty() {
    bail!("The git working directory has uncommitted changes. Please commit or abandon them before release!")
  } else {
    Ok(())
  }
}

fn bump_version(version: &str) -> Result<()> {
  update_npm(version)?;
  update_napi(version)?;
  update_python(version)?;
  update_crates(version)?;
  update_cargo_lock()?;
  Ok(())
}

fn update_npm(version: &str) -> Result<()> {
  let npm_path = "npm/package.json";
  let root_json = read_to_string(npm_path)?;
  let mut root_json: JSON = parse_json(&root_json)?;
  root_json["version"] = version.into();
  let deps = root_json["optionalDependencies"]
    .as_object_mut()
    .context("parse json error")?;
  for val in deps.values_mut() {
    *val = version.into();
  }
  fs::write(npm_path, to_string_pretty(&root_json)?)?;
  for entry in read_dir("npm/platforms")? {
    let path = entry?.path();
    if !path.is_dir() {
      continue;
    }
    let path = path.join("package.json");
    edit_json(path, version)?;
  }
  Ok(())
}

fn edit_json<P: AsRef<Path>>(path: P, version: &str) -> Result<()> {
  let json_str = read_to_string(&path)?;
  let mut json: JSON = parse_json(&json_str)?;
  json["version"] = version.into();
  fs::write(path, to_string_pretty(&json)?)?;
  Ok(())
}

fn update_napi(version: &str) -> Result<()> {
  let napi_path = "crates/napi/package.json";
  edit_json(napi_path, version)?;
  for entry in read_dir("crates/napi/npm")? {
    let path = entry?.path();
    if !path.is_dir() {
      continue;
    }
    let path = path.join("package.json");
    edit_json(path, version)?;
  }
  Ok(())
}

fn edit_root_toml<P: AsRef<Path>>(path: P, version: &str) -> Result<()> {
  let mut toml: DocumentMut = read_to_string(&path)?.parse()?;
  toml["workspace"]["package"]["version"] = to_toml(version);
  let deps = toml["workspace"]["dependencies"]
    .as_table_mut()
    .context("dep should be table")?;
  for (key, value) in deps.iter_mut() {
    if !key.starts_with("ast-grep-") {
      continue;
    }
    if value.is_str() {
      *value = to_toml(version);
      continue;
    }
    if let Some(inline) = value.as_inline_table_mut() {
      inline["version"] = version.into();
    }
  }
  fs::write(path, toml.to_string())?;
  Ok(())
}

fn update_crates(version: &str) -> Result<()> {
  // update root toml
  let root_toml = Path::new("Cargo.toml");
  edit_root_toml(root_toml, version)?;
  // no need to update crates or benches
  Ok(())
}

fn update_python(version: &str) -> Result<()> {
  // update pypi pyproject.toml and pyo3 bindings
  for path in ["pyproject.toml", "crates/pyo3/pyproject.toml"] {
    let pyproject = Path::new(path);
    let mut toml: DocumentMut = read_to_string(pyproject)?.parse()?;
    toml["project"]["version"] = to_toml(version);
    fs::write(pyproject, toml.to_string())?;
  }
  Ok(())
}

fn update_cargo_lock() -> Result<()> {
  if Command::new("cargo").args(["build"]).status()?.success() {
    Ok(())
  } else {
    bail!("cargo build fail! cannot update Cargo.lock")
  }
}

fn commit_and_tag(version: &str) -> Result<()> {
  // NB: napi needs line break to decide npm tag
  // https://github.com/ast-grep/ast-grep/blob/998691d36b477766be92f1ede3c0bc153d0cca42/.github/workflows/napi.yml#L164
  let message = format!("{version}\nbump version");
  let commit = Command::new("git")
    .arg("commit")
    .arg("-am")
    .arg(message)
    .spawn()?
    .wait()?;
  if !commit.success() {
    bail!("commit failed");
  }
  let tag = Command::new("git")
    .arg("tag")
    .arg(version)
    .spawn()?
    .wait()?;
  if !tag.success() {
    bail!("create tag failed");
  }
  Ok(())
}

fn update_and_commit_changelog() -> Result<()> {
  Command::new("auto-changelog")
    .arg("-p")
    .arg("npm/package.json")
    .arg("--breaking-pattern")
    .arg("BREAKING CHANGE")
    .spawn()
    .context("cannot run command `auto-changelog`. Please install it.")?
    .wait()?;
  Ok(())
}



================================================
FILE: xtask/src/schema.rs
================================================
use anyhow::{Context, Result};
use ast_grep_config::SerializableRuleConfig;
use ast_grep_core::matcher::{Pattern, PatternBuilder, PatternError};
use ast_grep_core::tree_sitter::{LanguageExt, TSLanguage};
use ast_grep_core::Language;
use ast_grep_language::{
  Alias, Bash, CSharp, Cpp, Css, Elixir, Go, Haskell, Html, Java, JavaScript, Json, Kotlin, Lua,
  Php, Python, Ruby, Rust, Scala, Swift, Tsx, TypeScript, Yaml, C,
};
use schemars::{json_schema, schema_for, JsonSchema, Schema, SchemaGenerator};
use serde_json::{to_writer_pretty, Value};

use std::borrow::Cow;
use std::{collections::BTreeSet, fs::File};

pub fn generate_schema() -> Result<()> {
  let schema = schema_for!(SerializableRuleConfig<PlaceholderLang>);
  generate_lang_schemas()?;
  // use manifest to locate schema. "schemas/rule.json" only works when cwd is root dir
  // however, pwd is set to manifest dir, xtask in this case, during cargo test
  let xtask_path = std::env::var("CARGO_MANIFEST_DIR")?;
  let rule_path = std::fs::canonicalize(format!("{xtask_path}/../schemas/rule.json"))?;
  let mut file = File::create(rule_path)?;
  to_writer_pretty(&mut file, &schema).context("cannot print JSON schema")
}

fn generate_lang_schemas() -> Result<()> {
  generate_lang_schema(Bash, "bash")?;
  generate_lang_schema(C, "c")?;
  generate_lang_schema(Cpp, "cpp")?;
  generate_lang_schema(CSharp, "csharp")?;
  generate_lang_schema(Css, "css")?;
  generate_lang_schema(Go, "go")?;
  generate_lang_schema(Elixir, "elixir")?;
  generate_lang_schema(Haskell, "haskell")?;
  generate_lang_schema(Html, "html")?;
  generate_lang_schema(Java, "java")?;
  generate_lang_schema(JavaScript, "javascript")?;
  generate_lang_schema(Json, "json")?;
  generate_lang_schema(Kotlin, "kotlin")?;
  generate_lang_schema(Lua, "lua")?;
  generate_lang_schema(Php, "php")?;
  generate_lang_schema(Python, "python")?;
  generate_lang_schema(Ruby, "ruby")?;
  generate_lang_schema(Rust, "rust")?;
  generate_lang_schema(Scala, "scala")?;
  generate_lang_schema(Swift, "swift")?;
  generate_lang_schema(Tsx, "tsx")?;
  generate_lang_schema(TypeScript, "typescript")?;
  generate_lang_schema(Yaml, "yaml")
}

fn generate_lang_schema<T: LanguageExt + Alias>(lang: T, name: &str) -> Result<()> {
  let mut schema = schema_for!(SerializableRuleConfig<PlaceholderLang>);
  add_lang_info_to_schema(&mut schema, lang, name)?;
  let xtask_path = std::env::var("CARGO_MANIFEST_DIR")?;
  let rule_path = std::fs::canonicalize(format!("{xtask_path}/../schemas/{name}_rule.json"))?;
  let mut file = File::create(rule_path)?;
  to_writer_pretty(&mut file, &schema).context("cannot print JSON schema")
}

fn add_lang_info_to_schema<T: LanguageExt + Alias>(
  schema: &mut Schema,
  lang: T,
  name: &str,
) -> Result<()> {
  // change rule title
  let title = schema.get_mut("title").context("must have title")?;
  *title = Value::String(format!("ast-grep rule for {name}"));

  let definitions = schema.get_mut("$defs").context("must have definitions")?;

  // insert field to relation
  let relation = definitions
    .get_mut("Relation")
    .context("must have relation")?;
  let relation_props = relation
    .get_mut("properties")
    .context("must have properties")?;
  let field = relation_props
    .get_mut("field")
    .context("must have field")?
    .as_object_mut()
    .context("field must be an object")?;
  field.insert(
    "enum".to_string(),
    Value::Array(get_fields(&lang.get_ts_language())),
  );

  // insert kind to relation and rule
  insert_kind(relation_props, &lang)?;
  let rule = definitions
    .get_mut("SerializableRule")
    .context("must have SerializableRule")?;
  let rule_props = rule.get_mut("properties").context("must have properties")?;
  insert_kind(rule_props, &lang)?;

  // insert language
  let language = definitions
    .get_mut("Language")
    .context("must have Language")?
    .as_object_mut()
    .context("Language must be an object")?;
  language.insert(
    "enum".to_string(),
    Value::Array(
      T::ALIAS
        .iter()
        .map(|alias| Value::String(alias.to_string()))
        .chain(std::iter::once(Value::String(lang.to_string())))
        .collect(),
    ),
  );
  Ok(())
}

fn insert_kind<L: LanguageExt>(schema: &mut Value, lang: &L) -> Result<()> {
  let named_nodes = get_named_nodes(&lang.get_ts_language());
  let kind = schema
    .get_mut("kind")
    .context("must have kind")?
    .as_object_mut()
    .context("kind must be an object")?;
  kind.insert("enum".to_string(), Value::Array(named_nodes));
  Ok(())
}

fn get_named_nodes(lang: &TSLanguage) -> Vec<Value> {
  let enum_values = BTreeSet::from_iter((0..lang.node_kind_count()).filter_map(|id| {
    if lang.node_kind_is_named(id as u16) {
      lang
        .node_kind_for_id(id as u16)
        .map(|kind| kind.to_string())
    } else {
      None
    }
  }));

  enum_values
    .into_iter()
    .map(serde_json::Value::String)
    .collect()
}

fn get_fields(lang: &TSLanguage) -> Vec<Value> {
  let enum_values = BTreeSet::from_iter(
    // Field IDs start from 1 in tree-sitter.
    (1..lang.field_count())
      .filter_map(|id| lang.field_name_for_id(id as u16).map(|s| s.to_string())),
  );

  enum_values
    .into_iter()
    .map(serde_json::Value::String)
    .collect()
}

#[derive(Clone)]
struct PlaceholderLang;
// reference: https://github.com/GREsau/schemars/blob/9415fcb57b85f12e07afeb1dd16184bab0e26a84/schemars/src/json_schema_impls/primitives.rs#L8
impl JsonSchema for PlaceholderLang {
  fn schema_id() -> Cow<'static, str> {
    Cow::Borrowed("Language")
  }
  fn schema_name() -> Cow<'static, str> {
    Cow::Borrowed("Language")
  }
  fn json_schema(_gen: &mut SchemaGenerator) -> Schema {
    json_schema!({
      "type": "string",
      "description": "Placeholder for language, used in JSON schema only.",
      "example": "typescript"
    })
  }
}

impl Language for PlaceholderLang {
  fn kind_to_id(&self, _kind: &str) -> u16 {
    unreachable!("PlaceholderLang is only for json schema")
  }
  fn field_to_id(&self, _field: &str) -> Option<u16> {
    unreachable!("PlaceholderLang is only for json schema")
  }
  fn build_pattern(&self, _b: &PatternBuilder) -> Result<Pattern, PatternError> {
    unreachable!("PlaceholderLang is only for json schema")
  }
}
impl LanguageExt for PlaceholderLang {
  fn get_ts_language(&self) -> TSLanguage {
    unreachable!("PlaceholderLang is only for json schema")
  }
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_json_schema() {
    let ret = generate_schema();
    assert!(ret.is_ok());
  }
}



================================================
FILE: .cargo/config.toml
================================================
[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"

[target.armv7-unknown-linux-gnueabihf]
linker = "arm-linux-gnueabihf-gcc"

[target.x86_64-unknown-linux-musl]
rustflags = [
  "-C",
  "target-feature=-crt-static",
]

[target.aarch64-unknown-linux-musl]
linker = "aarch64-linux-musl-gcc"
rustflags = ["-C", "target-feature=-crt-static"]

[alias]
xtask = "run --manifest-path ./xtask/Cargo.toml --"



================================================
FILE: .github/CONTRIBUTING.md
================================================
# Contributing

:tada: _**We are thrilled that you are interested in contributing to the ast-grep project!**_ :tada:

You can see the contributing guide in [the official website](https://ast-grep.github.io/).

* [General contributing guide](https://ast-grep.github.io/contributing/how-to.html)
* [How to develop](https://ast-grep.github.io/contributing/development.html)
* [How to add a new language to ast-grep](https://ast-grep.github.io/contributing/add-lang.html)


================================================
FILE: .github/copilot-instructions.md
================================================
# ast-grep Development Instructions

ast-grep is a CLI tool for structural search, lint, and code rewriting using abstract syntax trees. It's written in Rust with TypeScript/Node.js (NAPI) and Python bindings.

**Always reference these instructions first and fallback to search or bash commands only when you encounter unexpected information that does not match the info here.**

## Working Effectively

### Essential Setup and Build Commands
Run these commands in the repository root (the top-level directory of your local clone, e.g. `<repo-root>`) in order:

- Check Rust toolchain: `rustc --version && cargo --version`
- Quick validation: `cargo check` - takes 2m 40s, validates dependencies and compilation
- Debug build: `cargo build` - takes 42 seconds. **NEVER CANCEL.** Set timeout to 120+ seconds.
- Release build: `cargo build --release` - takes 2m 26s. **NEVER CANCEL.** Set timeout to 180+ seconds.
- Test suite: `cargo test` - takes 48 seconds, runs 94+ tests. **NEVER CANCEL.** Set timeout to 120+ seconds.

### Linting and Formatting
- Format check: `cargo fmt --all -- --check` - takes <1 second
- Lint check: `cargo clippy --all-targets --all-features --workspace --release --locked -- -D clippy::all` - takes 30 seconds. **NEVER CANCEL.** Set timeout to 60+ seconds.

### Running the CLI
- Main binary: `./target/release/ast-grep --help`
- Short alias: `./target/debug/sg --version` (requires ast-grep in PATH: `PATH="$(pwd)/target/debug:$PATH"`)
- Test pattern matching: `./target/release/ast-grep -p 'console.log($MSG)' -l js /path/to/file.js`
- Test rewriting: `./target/release/ast-grep -p 'var $VAR = $VALUE' -r 'let $VAR = $VALUE' -l js /path/to/file.js`

## Node.js/NAPI Bindings

### Setup and Build
- Navigate to: `cd crates/napi`
- Install dependencies: `yarn install` - takes 41 seconds. **NEVER CANCEL.** Set timeout to 90+ seconds.
- Debug build: `yarn build:debug` - takes 37 seconds. **NEVER CANCEL.** Set timeout to 90+ seconds.
- Test suite: `yarn test` - takes 5 seconds, runs 42 tests. **NEVER CANCEL.** Set timeout to 30+ seconds.
- Lint (requires network): `yarn lint` - may fail due to network restrictions, this is expected

**Note:** The NAPI bindings require Node.js >= 10. Tested with Node.js v20.19.4 and yarn 1.22.22.

## Python Bindings

### Setup and Build
- Install maturin: `pip install maturin`
- Build wheel: `maturin build -m crates/pyo3/Cargo.toml` - takes 21 seconds. **NEVER CANCEL.** Set timeout to 60+ seconds.
- Install wheel: `pip install target/wheels/ast_grep_py-*.whl`
- Test import: `python3 -c "import ast_grep_py; print('Python bindings work!')"`

**Note:** Python tests require module to be built in development mode, which needs virtualenv. Use wheel installation instead.

## Validation Scenarios

### After Making Changes - ALWAYS run these scenarios:
1. **Basic CLI functionality test:**
   ```bash
   echo 'console.log("hello world")' > /tmp/test.js
   ./target/release/ast-grep -p 'console.log($MSG)' -l js /tmp/test.js
   # Should output: /tmp/test.js with line match
   ```

2. **Rewrite functionality test:**
   ```bash
   echo 'var x = 5;' > /tmp/test.js
   ./target/release/ast-grep -p 'var $VAR = $VALUE' -r 'let $VAR = $VALUE' -l js /tmp/test.js
   # Should show diff replacing var with let
   ```

3. **Configuration-based scanning test:**
   ```bash
   mkdir -p /tmp/test-project/src && cd /tmp/test-project
   echo 'var y = 10;' > src/test.js
   cat > sgconfig.yml << 'EOF'
   rule:
     id: no-var
     message: Use let or const instead of var
     severity: error
     language: javascript
     rule:
       pattern: var $VAR = $VALUE
     fix: let $VAR = $VALUE
   EOF
   ./target/release/ast-grep scan src/
   ```

4. **LSP server startup test:**
   ```bash
   timeout 5 ./target/release/ast-grep lsp || echo "LSP started and stopped as expected"
   # Should show configuration error (expected) or start LSP server
   ```

### Pre-commit validation checklist:
- [ ] `cargo fmt --all -- --check` (format check)
- [ ] `cargo clippy --all-targets --all-features --workspace --release --locked -- -D clippy::all` (lint check)
- [ ] `cargo test` (test suite)
- [ ] Run validation scenarios above
- [ ] If touching NAPI code: `cd crates/napi && yarn test`

## Common Issues and Solutions

### Build Issues
- **"No such file or directory" for sg binary:** Ensure ast-grep is in PATH or use full path to sg binary
- **Network errors during yarn lint:** Expected in restricted environments, dprint needs internet access
- **Python test failures:** Expected, tests require development build which needs virtualenv

### Performance Expectations
- **CRITICAL:** Builds can take 2+ minutes - **NEVER CANCEL** build or test commands
- Set timeouts: Debug build (120s+), Release build (180s+), Tests (120s+), Clippy (60s+)
- Large dependency downloads on first build are normal

## Repository Structure

### Key Directories
- `crates/cli/` - Main CLI application
- `crates/core/` - Core AST processing logic
- `crates/config/` - Configuration handling
- `crates/language/` - Language-specific parsers
- `crates/napi/` - Node.js bindings
- `crates/pyo3/` - Python bindings
- `crates/lsp/` - Language Server Protocol implementation
- `fixtures/` - Test fixtures
- `npm/` - NPM package distribution

### Important Files
- `Cargo.toml` - Workspace configuration
- `crates/cli/Cargo.toml` - Main CLI package config
- `crates/napi/package.json` - Node.js package config
- `pyproject.toml` - Python package config
- `.github/workflows/` - CI/CD pipelines

## Supported Languages
ast-grep supports 20+ programming languages including JavaScript, TypeScript, Python, Rust, Go, Java, C/C++, and more through tree-sitter parsers.

## Additional Notes
- The project uses tree-sitter for parsing
- Multiple output formats supported: colored terminal, JSON, etc.
- Interactive mode available for applying fixes
- LSP server for editor integration
- WASM version available for web usage


================================================
FILE: .github/FUNDING.yml
================================================
# These are supported funding model platforms

github: HerringtonDarkholme



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.yml
================================================
name: 'Bug report'
description: 'Create a report to help us improve ast-grep'
title: '[bug]'
labels: [bug]
body:
  - type: markdown
    attributes:
      value: |
        🔍 Please read [ast-grep FAQ](https://ast-grep.github.io/advanced/faq.html) before reporting a new bug as most bugs are very likely to be questions. Please fill in each section completely. Thank you!

  - type: checkboxes
    attributes:
      label: Please read the FAQ for the bug you encountered.
      description: https://ast-grep.github.io/advanced/faq.html
      options:
      - label: I have read the existing FAQ
        required: true

  - type: input
    id: playground_link
    attributes:
      label: ⏯ Playground Link
      description: |
        A link to a ast-grep Playground "Share" link which shows this behavior.
        This should have the same code as the code snippet below.
        As a last resort, you can link to a repo, but these will be slower for us to investigate.
      placeholder: 'Playground link with relevant code: https://ast-grep.github.io/playground.html'
    validations:
      required: true

  - type: textarea
    id: code
    attributes:
      label: 💻 Code
      description: |
        Please post the relevant code sample here as well.

        This code and the Playground code should be the same, do not use separate examples.

        We can quickly address your report if:
          - The code sample is short. Nearly all ast-grep issues can be demonstrated in 20-30 lines of code!
          - Remove unnecessary code/configuration. The simpler the code, the faster we can help.
          - The incorrectness of the behavior is readily apparent from reading the sample.

        Reports are slower to investigate if:
          - We have to pare too much extraneous code.
          - The sample is confusing or doesn't clearly demonstrate what's wrong.
      value: |
        ```
        // Your code here
        ```
    validations:
      required: false
  - type: textarea
    id: actual_behavior
    attributes:
      label: 🙁 Actual behavior
      description: 'What happened, and why it was wrong.'
    validations:
      required: true
  - type: textarea
    id: expected_behavior
    attributes:
      label: 🙂 Expected behavior
      description: What you expected to happen instead, and why
    validations:
      required: true
  - type: textarea
    id: additional_info
    attributes:
      label: Additional information about the issue


================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
---
blank_issues_enabled: true
contact_links:
  -
    about: "Please check the FAQ before filing new issues"
    name: "ast-grep FAQ"
    url: "https://ast-grep.github.io/advanced/faq.html"
  -
    about: "Please ask pattern/rule questions on StackOverflow."
    name: StackOverflow
    url: "https://stackoverflow.com/questions/tagged/ast-grep"
  -
    about: "Please ask and answer usage questions on GitHub Discussion."
    name: Question
    url: "https://github.com/ast-grep/ast-grep/discussions/categories/q-a"
  -
    about: "Alternatively, you can use the ast-grep Community Discord."
    name: Chat
    url: "https://discord.gg/4YZjf6htSQ"


================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature Request
about: Suggest an idea
title: '[feature]'
labels: 'enhancement'
assignees: ''

---

# ⭐ Suggestion

<!-- A summary of what you'd like to see added or changed -->

# 💻 Use Cases

<!--
  What do you want to use this for?
  What shortcomings exist with current approaches?
  What workarounds are you using in the meantime?
-->



================================================
FILE: .github/workflows/coverage.yaml
================================================
name: coverage
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  coverage:
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Install Rust
        run: rustup update stable
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      - name: Upload to codecov.io
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos
          files: lcov.info
          fail_ci_if_error: true
  check:
    name: Lint/Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Clone repository
        uses: actions/checkout@v5
        with:
          submodules: true
      - name: Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
          key: ${{ runner.os }}-${{ github.sha }}
          restore-keys: ${{ runner.os }}-
      - name: Format
        run: cargo fmt --all -- --check
      - name: Lint
        run: cargo clippy --all-targets --all-features --workspace --release --locked -- -D clippy::all
  napi:
    name: NAPI Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Setup Node.js
        uses: actions/setup-node@v5
      - name: Lint NAPI
        run: |-
          cd crates/napi
          yarn install
          yarn lint


================================================
FILE: .github/workflows/napi.yml
================================================
name: Build NAPI
env:
  DEBUG: napi:*
  APP_NAME: ast-grep-napi
  MACOSX_DEPLOYMENT_TARGET: '10.13'
on:
  workflow_dispatch: null
  push:
    tags:
      - "[0-9]+.*"
  schedule:
    # run napi every day 9 am
    - cron: '0 9 * * *'

defaults:
  run:
    working-directory: ./crates/napi
jobs:
  build:
    if: "!contains(github.event.head_commit.message, 'skip ci')"
    strategy:
      fail-fast: false
      matrix:
        settings:
          - host: macos-latest
            target: x86_64-apple-darwin
            # no test
            build: |
              yarn build --target x86_64-apple-darwin
              strip -x *.node
          - host: windows-latest
            build: |
              yarn build
              yarn test
            target: x86_64-pc-windows-msvc
          - host: windows-latest
            target: aarch64-pc-windows-msvc
            build: yarn build --target aarch64-pc-windows-msvc
          - host: windows-latest
            build: |
              yarn build --target i686-pc-windows-msvc
              yarn test
            target: i686-pc-windows-msvc
          - host: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            build: |-
              set -e &&
              yarn build --target x86_64-unknown-linux-gnu &&
              strip *.node &&
              yarn test
          - host: ubuntu-22.04
            target: x86_64-unknown-linux-musl
            docker: ghcr.io/napi-rs/napi-rs/nodejs-rust:lts-alpine-zig
            build: |-
              set -e &&
              cd crates/napi &&
              yarn build --target x86_64-unknown-linux-musl &&
              strip *.node &&
              yarn test
          - host: ubuntu-22.04
            target: aarch64-unknown-linux-musl
            docker: ghcr.io/napi-rs/napi-rs/nodejs-rust:lts-alpine
            build: |-
              set -e &&
              cd crates/napi &&
              rustup target add aarch64-unknown-linux-musl &&
              yarn build --target aarch64-unknown-linux-musl
          - host: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            docker: ghcr.io/ast-grep/ast-grep/napi-aarch64-linux-gnu:latest
            # tree-sitter does not build using its official docker image
            # we have to roll our own and source the rustup
            build: |-
              set -e &&
              . "$HOME/.cargo/env" &&
              cd crates/napi &&
              yarn build --target aarch64-unknown-linux-gnu &&
              aarch64-unknown-linux-gnu-strip *.node
          - host: macos-latest
            target: aarch64-apple-darwin
            build: |
              yarn build --target aarch64-apple-darwin
              strip -x *.node
              yarn test
    name: stable - ${{ matrix.settings.target }} - node@20
    runs-on: ${{ matrix.settings.host }}
    steps:
      - uses: actions/checkout@v5
      - name: Setup node
        uses: actions/setup-node@v5
        if: ${{ !matrix.settings.docker }}
        with:
          node-version: 20
          check-latest: true
          cache: yarn
          cache-dependency-path: ./crates/napi/yarn.lock
      - name: Install
        uses: actions-rs/toolchain@v1
        if: ${{ !matrix.settings.docker }}
        with:
          profile: minimal
          override: true
          toolchain: stable
          target: ${{ matrix.settings.target }}
      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            .cargo-cache
            target/
          key: ${{ matrix.settings.target }}-cargo-registry
      - name: Cache NPM dependencies
        uses: actions/cache@v4
        with:
          path: .yarn/cache
          key: npm-cache-build-${{ matrix.settings.target }}-node@20
      - name: Setup toolchain
        run: ${{ matrix.settings.setup }}
        if: ${{ matrix.settings.setup }}
        shell: bash
      - name: Setup node x86
        if: matrix.settings.target == 'i686-pc-windows-msvc'
        run: yarn config set supportedArchitectures.cpu "ia32"
        shell: bash
      - name: Install dependencies
        run: yarn install
      - name: Setup node x86
        uses: actions/setup-node@v5
        if: matrix.settings.target == 'i686-pc-windows-msvc'
        with:
          node-version: 20
          check-latest: true
          cache: yarn
          architecture: x86
          cache-dependency-path: ./crates/napi/yarn.lock
      - name: Build in docker
        uses: addnab/docker-run-action@v3
        if: ${{ matrix.settings.docker }}
        with:
          image: ${{ matrix.settings.docker }}
          options: --user 0:0 -v ${{ github.workspace }}/.cargo-cache/git/db:/usr/local/cargo/git/db -v ${{ github.workspace }}/.cargo/registry/cache:/usr/local/cargo/registry/cache -v ${{ github.workspace }}/.cargo/registry/index:/usr/local/cargo/registry/index -v ${{ github.workspace }}:/build -w /build
          run: ${{ matrix.settings.build }}
      - name: Build
        run: ${{ matrix.settings.build }}
        if: ${{ !matrix.settings.docker }}
        shell: bash
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: bindings-${{ matrix.settings.target }}
          path: crates/napi/${{ env.APP_NAME }}.*.node
          if-no-files-found: error
  publish:
    name: Publish
    runs-on: ubuntu-22.04
    needs:
      - build
    steps:
      - uses: actions/checkout@v5
      - name: Setup node
        uses: actions/setup-node@v5
        with:
          node-version: 20
          check-latest: true
          cache: yarn
          cache-dependency-path: ./crates/napi/yarn.lock
      - name: Cache NPM dependencies
        uses: actions/cache@v4
        with:
          path: .yarn/cache
          key: npm-cache-ubuntu-22.04-publish
          restore-keys: |
            npm-cache-
      - name: Install dependencies
        run: yarn install
      - name: Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: crates/napi/artifacts
      - name: Generate Types
        run: |-
          yarn typegen
      - name: Move artifacts
        run: yarn artifacts
      - name: List packages
        run: ls -R ./npm
        shell: bash
      - name: Publish
        run: |
          if git log -1 --pretty=%B | grep "^[0-9]\+\.[0-9]\+\.[0-9]\+$";
          then
            echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" >> ~/.npmrc
            npm publish --access public
          elif git log -1 --pretty=%B | grep "^[0-9]\+\.[0-9]\+\.[0-9]\+";
          then
            echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" >> ~/.npmrc
            npm publish --tag next --access public
          else
            echo "Not a release, skipping publish"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}


================================================
FILE: .github/workflows/pyo3.yml
================================================
name: PyO3

env:
  PACKAGE_NAME: ast_grep_py # note: maturin package name only accepts underscore
  PYTHON_VERSION: '3.9 3.10 3.11 3.12 3.13'
  CARGO_INCREMENTAL: 0
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUSTUP_MAX_RETRIES: 10


defaults:
  run:
    working-directory: ./crates/pyo3
on:
  workflow_dispatch:
    inputs:
      need_release:
        description: "Select this for publish. If not selected, it will be a dry run (no uploads)."
        type: boolean
  push:
    tags:
      - "[0-9]+.*"
  schedule:
    # run pypi every day 9 am
    - cron: '0 9 * * *'

permissions:
  contents: read

jobs:
  linux:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-gnu
          - aarch64-unknown-linux-gnu
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          # python-version: ${{ env.PYTHON_VERSION }}
          python-version: '3.13'
          architecture: x64
      - name: Build wheels
        uses: PyO3/maturin-action@v1
        with:
          target: ${{ matrix.target }}
          # manylinux by default uses old linux so tree-sitter does not compile
          # https://github.com/woodruffw/zizmor/pull/603
          manylinux: "2_28"
          args: --release --out dist -i ${{env.PYTHON_VERSION}}
          working-directory: crates/pyo3
      - name: Test sdist
        # GH action only has x86 runner
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          pip install pytest
          pip install --no-index --find-links=dist ${{env.PACKAGE_NAME}} --force-reinstall
          pytest
      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.target }}
          path: crates/pyo3/dist

  windows:
    runs-on: windows-latest
    strategy:
      matrix:
        target: [x64, x86]
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          # python-version: ${{ env.PYTHON_VERSION }}
          python-version: '3.13'
          architecture: ${{ matrix.target }}
      - name: Build wheels
        uses: PyO3/maturin-action@v1
        with:
          target: ${{ matrix.target }}
          args: --release --out dist -i ${{env.PYTHON_VERSION}}
          working-directory: crates/pyo3
      - name: Test sdist
        run: |
          pip install pytest
          pip install --no-index --find-links=dist ${{env.PACKAGE_NAME}} --force-reinstall
          pytest
      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.target }}
          path: crates/pyo3/dist

  macos:
    runs-on: macos-latest
    strategy:
      matrix:
        target: [x86_64, aarch64]
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'
        #   python-version: ${{ env.PYTHON_VERSION }}
      - name: Build wheels
        uses: PyO3/maturin-action@v1
        with:
          target: ${{ matrix.target }}
          args: --release --out dist --find-interpreter
          working-directory: crates/pyo3
      - name: Test sdist
        if: matrix.target == 'aarch64'
        run: |
          pip install pytest
          pip install --no-index --find-links=dist ${{env.PACKAGE_NAME}} --force-reinstall
          pytest
      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.target }}
          path: crates/pyo3/dist

  sdist:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Build sdist
        uses: PyO3/maturin-action@v1
        with:
          command: sdist
          args: --out dist
          working-directory: crates/pyo3
      - name: Upload sdist
        uses: actions/upload-artifact@v4
        with:
          name: wheels
          path: crates/pyo3/dist

  release:
    name: Release
    runs-on: ubuntu-latest
    if: "startsWith(github.event.ref, 'refs/tags') || inputs.need_release"
    permissions:
      # For pypi trusted publishing
      id-token: write
    needs: [linux, windows, macos, sdist]
    steps:
      - uses: actions/download-artifact@v5
        with:
          pattern: wheels*
          merge-multiple: true
      - name: Publish to PyPI
        uses: PyO3/maturin-action@v1
        with:
          command: upload
          args: --skip-existing *
          # note, release does not need working-directory
          # because artifacts are stored under the root dir
          # and it does not involve pyproject.toml


================================================
FILE: .github/workflows/pypi.yml
================================================
name: "PyPi Release"

on:
  workflow_dispatch:
    inputs:
      need_release:
        description: "Select this for publish. If not selected, it will be a dry run (no uploads)."
        type: boolean
  push:
    tags:
      - "[0-9]+.*"
  schedule:
    # run pypi every day 9 am
    - cron: '0 9 * * *'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PACKAGE_NAME: ast_grep_cli # note: maturin package name only accepts underscore
  PYTHON_VERSION: "3.9" # to build abi3 wheels
  CARGO_INCREMENTAL: 0
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUSTUP_MAX_RETRIES: 10

jobs:
  sdist:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: "Build sdist"
        uses: PyO3/maturin-action@v1.49.4
        with:
          command: sdist
          args: --out dist
      - name: "Test sdist"
        run: |
          pip install dist/${{ env.PACKAGE_NAME }}-*.tar.gz --force-reinstall
          sg --help
      - name: "Upload sdist"
        uses: actions/upload-artifact@v4
        with:
          name: wheels
          path: dist

  macos-x86_64:
    # use old macos due to https://github.com/actions/setup-python/issues/852
    runs-on: macos-13
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: x64
      # https://github.com/actions/runner-images/issues/658#issuecomment-611921753
      - name: "Build wheels - x86_64"
        uses: PyO3/maturin-action@v1
        env:
          # old llvm does not support libc++ by default
          CXXFLAGS: "-stdlib=libc++"
        with:
          target: x86_64
          args: --release --out dist
      - name: "Test wheel - x86_64"
        run: |
          pip install dist/${{ env.PACKAGE_NAME }}-*.whl --force-reinstall
          sg --help
      - name: "Upload wheels"
        uses: actions/upload-artifact@v4
        with:
          name: wheels-macos-x86_64
          path: dist

  macos-universal:
    # use old macos due to https://github.com/actions/setup-python/issues/852
    runs-on: macos-13
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: x64
      - name: "Build wheels - universal2"
        uses: PyO3/maturin-action@v1
        env:
          # instruct old llvm to support libc++
          CXXFLAGS: "-stdlib=libc++"
        with:
          args: --release --target universal2-apple-darwin --out dist
      - name: "Test wheel - universal2"
        run: |
          pip install dist/${{ env.PACKAGE_NAME }}-*universal2.whl --force-reinstall
          sg --help
      - name: "Upload wheels"
        uses: actions/upload-artifact@v4
        with:
          name: wheels-aarch64-apple-darwin
          path: dist

  windows:
    runs-on: windows-latest
    strategy:
      matrix:
        platform:
          - target: x86_64-pc-windows-msvc
            arch: x64
          - target: i686-pc-windows-msvc
            arch: x86
          - target: aarch64-pc-windows-msvc
            arch: x64
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: ${{ matrix.platform.arch }}
      - name: "Build wheels"
        uses: PyO3/maturin-action@v1
        env:
          # https://github.com/rust-cross/cargo-xwin/issues/108
          XWIN_VERSION: "16"
        with:
          target: ${{ matrix.platform.target }}
          args: --release --out dist
      - name: "Test wheel"
        if: ${{ !startsWith(matrix.platform.target, 'aarch64') }}
        shell: bash
        run: |
          python -m pip install dist/${{ env.PACKAGE_NAME }}-*.whl --force-reinstall
          sg --help
      - name: "Upload wheels"
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.platform.target }}
          path: dist

  linux:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-gnu
          - aarch64-unknown-linux-gnu
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: x64
      - name: "Build wheels"
        uses: PyO3/maturin-action@v1
        env:
          CFLAGS: "-std=c11"
          CXXFLAGS: "-std=c++11"
        with:
          target: ${{ matrix.target }}
          # manylinux by default uses old linux so tree-sitter does not compile
          # https://github.com/woodruffw/zizmor/pull/603
          manylinux: "2_28"
          args: --release --out dist
      - name: "Test wheel"
        if: ${{ startsWith(matrix.target, 'x86_64') }}
        run: |
          pip install dist/${{ env.PACKAGE_NAME }}-*.whl --force-reinstall
          sg --help
      - name: "Upload wheels"
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.target }}
          path: dist

  upload-release:
    name: Upload to PyPI
    runs-on: ubuntu-latest
    needs:
      - macos-universal
      - macos-x86_64
      - windows
      - linux
      # - linux-cross I would want to support linux-cross but it is too hard for me to compile c projects for tree-sitter-languages
    # If you don't set release flag, it's a dry run (no uploads).
    if: "startsWith(github.event.ref, 'refs/tags') || inputs.need_release"
    environment:
      name: release
    permissions:
      # For pypi trusted publishing
      id-token: write
    steps:
      - name: "Install uv"
        uses: astral-sh/setup-uv@v6
      - uses: actions/download-artifact@v5
        with:
          pattern: wheels*
          merge-multiple: true
          path: wheels
      - name: Publish to PyPi
        run: uv publish -v wheels/*
      # - name: Publish to PyPi
      #   uses: pypa/gh-action-pypi-publish@release/v1
      #   with:
      #     skip-existing: true
      #     packages-dir: wheels
      #     verbose: true


================================================
FILE: .github/workflows/release.yml
================================================
name: Release

permissions:
  contents: write

on:
  # enable workflow_dispatch when debugging
  workflow_dispatch: null
  push:
    tags:
      - "[0-9]+.*"
jobs:
  push_crates_io:
    # If you don't set an input tag, it's a dry run (no uploads).
    if: "startsWith(github.event.ref, 'refs/tags')"
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v5
      - uses: katyo/publish-crates@v2
        with:
          registry-token: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          publish-delay: 5000

  create-release:
    # If you don't set an input tag, it's a dry run (no uploads).
    if: "startsWith(github.event.ref, 'refs/tags')"
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v5
      - uses: taiki-e/create-gh-release-action@v1
        with:
          changelog: CHANGELOG.md
          token: ${{ secrets.GITHUB_TOKEN }}

  upload-assets:
    strategy:
      matrix:
        include:
          - target: x86_64-pc-windows-msvc
            os: windows-latest
          - target: i686-pc-windows-msvc
            os: windows-latest
          - target: aarch64-pc-windows-msvc
            os: windows-latest
          - target: aarch64-apple-darwin
            os: macos-latest
          - target: x86_64-apple-darwin
            os: macos-latest
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-22.04
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-22.04
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v5
      - uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: sg,ast-grep
          tar: none
          # (optional) On which platform to distribute the `.zip` file.
          # [default value: windows]
          # [possible values: all, unix, windows, none]
          zip: all
          target: ${{ matrix.target }}
          archive: app-$target
          # uncomment this for debug
          # ref: refs/tags/debug_release
        env:
          # (required)
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  release-npm:
    runs-on: ubuntu-22.04
    name: Release npm cli
    needs:
      - upload-assets
    steps:
      - uses: actions/checkout@v5
      - name: Setup node
        uses: actions/setup-node@v5
      - name: Download artifacts
        uses: robinraju/release-downloader@v1.12
        with:
          latest: true
          fileName: "*.zip"
          out-file-path: artifacts
      - name: Unzip packages
        run: |
          files=(aarch64-apple-darwin x86_64-apple-darwin x86_64-unknown-linux-gnu aarch64-unknown-linux-gnu)
          target_dir=(darwin-arm64 darwin-x64 linux-x64-gnu linux-arm64-gnu)
          length=${#files[@]}
          for (( i=0; i<${length}; i++ ));
          do
            unzip "artifacts/app-${files[$i]}.zip" -d "npm/platforms/${target_dir[$i]}/"
          done
          # windows
          files=(x86_64-pc-windows-msvc i686-pc-windows-msvc aarch64-pc-windows-msvc)
          target_dir=(win32-x64-msvc win32-ia32-msvc win32-arm64-msvc)
          length=${#files[@]}
          for (( i=0; i<${length}; i++ ));
          do
            unzip "artifacts/app-${files[$i]}.zip" -d "npm/platforms/${target_dir[$i]}/"
          done
      - run: echo //registry.npmjs.org/:_authToken=${NPM_TOKEN} > ~/.npmrc
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      - name: Publish to npm
        run: |
          cd npm
          for pkg in platforms/*; do
            echo "Publishing $pkg..."
            cd $pkg;
            npm publish;
            cd ../..;
          done
          echo "Publishing @ast-grep/cli...";
          npm publish
  changelog:
    runs-on: ubuntu-22.04
    steps:
      - name: "✏️ Generate release changelog"
        uses: heinrichreimer/action-github-changelog-generator@v2.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

