src_lib_rs-calculate_sum-fn-HASH123456
      ^          ^        ^      ^
  filepath    name     type   unique ID

  CRUD Operations Analysis

  | Operation    | Current Format              | Your Proposed Format                       | Winner   |
  |--------------|-----------------------------|--------------------------------------------|----------|
  | Create (0,1) | ❌ Can't generate - no lines | ✅ Generate hash from (file+name+timestamp) | Proposed |
  | Read (1,1)   | ✅ Works                     | ✅ Works                                    | Tie      |
  | Edit (1,1)   | ⚠️ Lines might change       | ✅ Hash stable across edits                 | Proposed |
  | Delete (1,0) | ✅ Works                     | ✅ Works                                    | Tie      |

  Critical Insight from Earlier Research

  Remember what we discovered about rust-analyzer:
  "rust-analyzer avoids using text offsets because offsets change after edits. It uses positional IDs (ModuleId + ItemIndex)."

  Your hash ID proposal aligns with this! You're essentially creating a stable positional ID.

  Validation of Your Approach

  ✅ Pros of Hash-Based Keys

  1. New entity creation works:
  // LLM says: "Create fn new_feature in src/lib.rs"
  key = hash("src/lib.rs" + "new_feature" + "fn" + timestamp)
  // ✅ Can generate immediately without line numbers!
  2. Stability across code movement:
  // Move function from line 42 to line 350
  // Hash stays same: HASH123456
  // ✅ Entity identity preserved!
  3. Collision avoidance:
  // Two "calculate" functions in same file?
  hash1 = hash("src/lib.rs" + "calculate" + "fn" + "timestamp1")
  hash2 = hash("src/lib.rs" + "calculate" + "fn" + "timestamp2")
  // ✅ Different hashes = different entities

  ⚠️ Concerns to Address

  Concern 1: Line numbers still needed for Tool 5 (CodeDiff.json)

  Even with hash keys, Tool 5 needs to tell LLM WHERE to write:
  {
    "isgl1_key": "src_lib_rs-calculate-fn-abc123",
    "operation": "Edit",
    "current_line_range": {"start": 42, "end": 56},  // ← Still need this!
    "future_code": "..."
  }

  Solution: Line numbers are metadata, not identity.
  - Key (identity): filepath-name-type-hash (stable)
  - Metadata (location): line_range field (mutable, updated on re-index)

  Concern 2: Hash generation for new entities

  // What goes into the hash for new entities?
  // Option A: hash(filepath + name + type + creation_timestamp)
  // Option B: hash(filepath + name + type + random_uuid)
  // Option C: hash(filepath + name + type + counter)

  Recommendation: Option A (timestamp) - deterministic but unique per creation time.

  Concern 3: Tool 1 needs to update

  Current Tool 1 generates:
  format!("{}:{}:{}:{}:{}-{}", lang, type, name, path, start, end)

  New Tool 1 should generate:
  let hash = generate_hash(path, name, type, line_start); // Include line for existing
  format!("{}-{}-{}-{}", path, name, type, hash)

  Recommended Architecture

  Primary Key Structure

  <sanitized_filepath>-<interface_name>-<interface_type>-<collision_hash>

  Hash Generation Strategy

  fn generate_isgl1_key(
      filepath: &str,
      name: &str,
      entity_type: &str,
      line_start: Option<u32>  // None for new entities
  ) -> String {
      let hash = match line_start {
          Some(line) => {
              // Existing entity: hash includes line for uniqueness
              hash(filepath, name, entity_type, line)
          }
          None => {
              // New entity: hash includes timestamp
              hash(filepath, name, entity_type, timestamp())
          }
      };

      format!("{}-{}-{}-{}",
          sanitize_path(filepath),
          name,
          entity_type,
          &hash[..8]  // First 8 chars
      )
  }

  CodeEntity Structure

  pub struct CodeEntity {
      pub isgl1_key: String,  // PRIMARY KEY: stable hash-based

      // Location metadata (mutable, updated on re-index)
      pub file_path: PathBuf,
      pub line_range: Option<LineRange>,  // None for new entities

      // Temporal state
      pub current_ind: bool,
      pub future_ind: bool,
      pub future_action: Option<FutureAction>,

      // Code content
      pub current_code: Option<String>,
      pub future_code: Option<String>,
      pub interface_signature: String,
  }

  Answer to Your Question

  "Will that be a problem?"

  No, it won't be a problem IF:
  1. ✅ Use hash-based keys (your proposal is correct)
  2. ✅ Keep line numbers as metadata (not identity)
  3. ✅ Tool 5 includes line_range in CodeDiff.json for LLM guidance
  4. ✅ Tool 1 updates to generate hash-based keys

  "Do we need hash ID and remove line numbers from key?"

  Yes to hash ID. Line numbers should be:
  - ❌ NOT in the key (for stability)
  - ✅ IN the metadata (for location guidance)

  What's Missing in Tool 1 (folder-to-cozodb-streamer)?

  Based on this analysis:

  1. ❌ Hash-based key generation - currently uses line numbers in key
  2. ❌ Separate identity from location - line_range should be metadata field
  3. ✅ Tree-sitter parsing - already works
  4. ✅ CozoDB integration - already works
  5. ⚠️ Entity validation - needs to handle new vs existing entities

  Should I create a detailed implementation plan for updating Tool 1 with hash-based keys?

## Implementation Summary (2025-10-30)

### Decision: Dual-Key Strategy Implementation

After extensive analysis and discussion, we implemented a **dual-key strategy** where:
- **Tool 1** (folder-to-cozodb-streamer): Continues using line-based ISGL1 keys for existing entities
- **Tool 2** (LLM-to-cozodb-writer): Generates hash-based ISGL1 keys for new entities (Create operations)

This decision was based on the critical insight that **Tool 1 is not the problem** - it indexes existing code that already has line numbers. The problem occurs in **Tool 2** when the LLM creates new entities that don't exist in the codebase yet.

### Implementation Details

#### 1. Documentation Updates

**P01PRDL1Minimal.md** (3 edits):
- Added dual ISGL1 key format specification (lines 81-90)
- Updated Step A01 with hash generation details for Create operations (lines 133-135)
- Updated Step A02 with hash generation details (line 140)

**P02PRDL2Detailed.md** (3 edits):
- Added dual key format to Entity 2 schema (lines 181-183)
- Expanded Tool Responsibilities section with key format details (lines 208-217)
- Added comprehensive "Hash-Based Key Generation Specification" section (lines 219-278)
  - Function signature
  - Algorithm details (SHA-256)
  - Type abbreviations
  - Path sanitization rules
  - Collision handling
  - Examples
  - Dependencies
- Updated temporal versioning section with key format by state (lines 286-301)

#### 2. Core Implementation (parseltongue-core)

**Cargo.toml**:
- Added `sha2 = "0.10"` dependency (chrono already existed)

**entities.rs** (1 new function + 6 comprehensive tests):
- Implemented `CodeEntity::generate_new_entity_key()` function (lines 713-789)
  - Takes: file_path, entity_name, entity_type, timestamp
  - Returns: String in format `{sanitized_filepath}-{entity_name}-{type_abbrev}-{hash8}`
  - Path sanitization: replaces `/`, `\`, `.` with `_`
  - SHA-256 hash of (filepath + name + type + timestamp), first 8 chars
  - Comprehensive type abbreviation mapping for all EntityType variants

**Tests Written (TDD RED → GREEN)**:
1. `test_generate_new_entity_key_basic`: Verifies format and hash length
2. `test_generate_new_entity_key_different_types`: Tests all entity types (Function, Struct, Enum, Trait, Module)
3. `test_generate_new_entity_key_path_sanitization`: Validates path cleaning (slashes, dots, backslashes)
4. `test_generate_new_entity_key_uniqueness`: Confirms timestamp-based uniqueness
5. `test_generate_new_entity_key_format`: Strict format validation (4 parts, hexadecimal hash)
6. `test_generate_new_entity_key_impl_block`: Tests ImplBlock type edge case

**All tests pass**: 24 tests in parseltongue-core (6 new + 18 existing)

#### 3. Tool 2 Integration (llm-to-cozodb-writer)

**Cargo.toml**:
- Added `chrono = { version = "0.4", features = ["serde"] }` dependency

**llm_client.rs** (3 changes):
- Extended `GeneratedChange` struct with optional fields (lines 95-97):
  - `file_path: Option<String>`
  - `entity_name: Option<String>`
  - `entity_type: Option<EntityType>`
- Updated `parse_response` to detect Create operations and generate hash-based keys (lines 200-244):
  - Detects `TemporalAction::Create` from LLM response
  - If LLM provides file_path/entity_name/entity_type, generates hash-based key
  - Falls back to LLM-provided key for backward compatibility
  - Uses `Utc::now()` for timestamp uniqueness
- Enhanced system prompt to instruct LLM about required fields for Create operations (lines 160-166)

**Compilation**: ✅ `cargo check --package llm-to-cozodb-writer` passes

### Key Architectural Insights

1. **CRUD Operations Analysis Validated**: The original analysis (lines 5-12) was correct - Create operations cannot use line-based keys because line numbers don't exist yet.

2. **Rust-Analyzer Alignment**: This approach aligns with rust-analyzer's design principle (lines 16-17): "rust-analyzer avoids using text offsets because offsets change after edits. It uses positional IDs (ModuleId + ItemIndex)." Our hash-based keys provide stable positional IDs.

3. **Separation of Concerns**:
   - **Line numbers** = mutable metadata (updated on re-index)
   - **ISGL1 keys** = immutable identity (stable across edits)

4. **Lifecycle of Hash-Based Keys**:
   - **Creation**: Tool 2 generates hash-based key for new entity
   - **Writing**: Tool 5 generates CodeDiff.json, LLM writes code to files
   - **Re-indexing**: Tool 6 resets DB, Tool 1 re-indexes with line-based keys
   - **Transition**: Hash-based keys → Line-based keys after code enters codebase

### Example Key Formats

**Existing Entities** (Tool 1):
```
rust:fn:calculate_sum:src_lib_rs:42-56
```

**New Entities** (Tool 2):
```
src_lib_rs-new_feature-fn-abc12345
src_models_user_rs-UserProfile-struct-def67890
```

### Files Modified

1. `.prdArchDocs/P01PRDL1Minimal.md` (3 edits)
2. `.prdArchDocs/P02PRDL2Detailed.md` (3 edits)
3. `crates/parseltongue-core/Cargo.toml` (1 addition)
4. `crates/parseltongue-core/src/entities.rs` (1 function + 6 tests)
5. `crates/llm-to-cozodb-writer/Cargo.toml` (1 addition)
6. `crates/llm-to-cozodb-writer/src/llm_client.rs` (3 changes)

### Testing Status

- **parseltongue-core**: 24/24 tests passing ✅
- **Hash generation tests**: 6/6 passing ✅
- **Tool 2 compilation**: Success ✅

### Next Steps (If Needed)

1. **Integration Testing**: Full system test with Tool 1 → Tool 2 → database
2. **Dogfooding**: Test on parseltongue codebase itself
3. **Production Validation**: Verify LLM correctly provides file_path/entity_name/entity_type in responses

### Technical Decisions

**Why SHA-256?**
- Cryptographically strong (overkill but safe)
- Available in `sha2` crate (widely used, audited)
- 8-character prefix provides 4.3 billion unique values (sufficient for typical codebases)

**Why Timestamp in Hash?**
- Ensures uniqueness when multiple entities have same name/path/type
- Simple and deterministic
- No need for global counter or UUID generation

**Why Optional Fields in GeneratedChange?**
- Backward compatibility with existing LLM responses
- Graceful degradation if LLM doesn't provide fields
- Follows Rust Option<T> pattern for nullable data

### Validation Against Requirements

✅ **No changes to Tool 1** (user explicitly clarified this)
✅ **Hash-based keys for Create operations in Tool 2**
✅ **Dual-key format coexistence in same database**
✅ **TDD approach** (RED → GREEN → REFACTOR)
✅ **Documentation updated** (PRD files comprehensive)
✅ **All tests passing**
✅ **Follows S01-README-MOSTIMP.md principles** (executable specifications, layered architecture)

### Implementation Complete

This implementation resolves GAP-T1-05 (Hash-based ISGL1 Key Generation) and enables Tool 2 to create new entities without requiring line numbers. The system now supports the full entity lifecycle: Create (hash-based) → Index (line-based) → Edit/Delete (line-based).
