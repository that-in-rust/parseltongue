# PRD Creation Exercise: Two-Factor Authentication Feature

Let me draft both versions and map to architecture.

---

## Version 1: Human PRD (Traditional Format)

### **Executive Summary**

**Problem Statement**: Users frequently report unauthorized account access, leading to data breaches and loss of trust. Our current single-password authentication is insufficient for protecting sensitive user data.

**Proposed Solution**: Implement two-factor authentication (2FA) using time-based one-time passwords (TOTP) and SMS backup. Users will be required to enable 2FA for accounts handling sensitive operations (payments, data exports).

**Success Metrics**:

- Security: 90% reduction in unauthorized access incidents within 3 months
- Adoption: 60% of active users enable 2FA within 6 months
- UX: <10% support ticket increase related to authentication
- Technical: 99.9% 2FA verification success rate

**Scope**:

- IN SCOPE: TOTP (Google Authenticator, Authy), SMS fallback, recovery codes
- OUT OF SCOPE: Hardware tokens (YubiKey), biometric authentication, SSO integration

---

### **User Journeys & Actors**

**Primary Actors**:

1. **End User**: Wants secure account access without friction
2. **Admin User**: Needs to enforce 2FA policies for teams
3. **Support Agent**: Must help users recover locked accounts
4. **External Systems**: SMS Gateway (Twilio), TOTP validators

**Journey 1: First-Time 2FA Setup**

1. User navigates to Security Settings
2. User clicks "Enable 2FA"
3. System generates QR code with TOTP secret
4. User scans QR with authenticator app
5. User enters 6-digit code to verify setup
6. System generates 10 recovery codes
7. User downloads/prints recovery codes
8. System marks 2FA as enabled

**Critical Path**: Steps 3-6 must complete without page refresh

**Journey 2: Login with 2FA**

1. User enters email/password
2. System validates credentials
3. System prompts for 2FA code
4. User enters 6-digit TOTP code (30s window)
5. System validates code
6. System creates authenticated session

**Critical Path**: Step 5 validation <200ms

**Journey 3: Account Recovery**

1. User cannot access authenticator app
2. User clicks "Use recovery code"
3. User enters one-time recovery code
4. System validates and burns the code
5. User gains temporary access
6. System prompts to reconfigure 2FA

**Failure Scenarios**:

- Invalid TOTP code → Show error, allow 3 attempts before 5-min lockout
- SMS delivery fails → Allow TOTP retry or recovery code
- All recovery codes used → Must contact support with ID verification

---

### **Functional Requirements**

#### **Capability 1: 2FA Enrollment**

**Requirements**:

- FR1.1: System SHALL generate cryptographically secure TOTP secrets (32-byte base32)
- FR1.2: System SHALL display QR code encoded with `otpauth://totp/` URI
- FR1.3: System SHALL validate first TOTP code before enabling 2FA
- FR1.4: System SHALL generate exactly 10 single-use recovery codes (16-char alphanumeric)
- FR1.5: System SHALL allow users to download recovery codes as .txt file
- FR1.6: System SHALL prevent disabling 2FA without re-authentication

**Data Requirements**:

```
User2FAConfig
├── user_id (FK, unique)
├── totp_secret (encrypted at rest)
├── backup_phone (encrypted, optional)
├── recovery_codes[] (hashed)
├── enabled_at (timestamp)
├── last_verified_at (timestamp)
└── status (enrolled/disabled/locked)
```

**Business Rules**:

- TOTP secrets must be encrypted with user-specific key
- Recovery codes are single-use and bcrypt-hashed
- Phone numbers must be verified before use
- Maximum 3 failed attempts within 5 minutes triggers account lock

**Dependencies**:

- READS FROM: User Service (user profile, preferences)
- WRITES TO: 2FA Database (PostgreSQL)
- PUBLISHES: `User2FAEnabled`, `User2FADisabled` events
- SUBSCRIBES TO: `UserDeleted` event (cleanup)
- CALLS: Encryption Service (for secret storage)

**API Surface**:

```
POST /api/auth/2fa/enroll
  Request: { method: "totp" }
  Response: { qr_code_data_url, secret_backup, recovery_codes[] }

POST /api/auth/2fa/verify-enrollment
  Request: { totp_code }
  Response: { success, enabled_at }

GET /api/auth/2fa/status
  Response: { enabled, methods[], last_verified }
```

---

#### **Capability 2: 2FA Authentication**

**Requirements**:

- FR2.1: System SHALL validate TOTP codes within ±1 time window (90s tolerance)
- FR2.2: System SHALL prevent code reuse within same time window
- FR2.3: System SHALL support SMS backup codes (6-digit, 10-min expiry)
- FR2.4: System SHALL accept recovery codes and mark as used
- FR2.5: System SHALL rate-limit verification attempts (3 per 5 minutes)

**Data Requirements**:

```
2FAVerificationAttempt
├── attempt_id (PK)
├── user_id (FK)
├── method (totp/sms/recovery)
├── success (boolean)
├── ip_address
├── user_agent
└── attempted_at (timestamp, indexed)

UsedTOTPCode
├── user_id (FK)
├── code_hash
├── used_at (timestamp)
└── expires_at (timestamp, TTL index)
```

**Business Rules**:

- TOTP validation uses HMAC-SHA1 algorithm per RFC 6238
- SMS codes cost $0.0075/message, budget $500/month (66,666 SMS)
- After 3 failed attempts, enforce 5-minute cooldown
- Successful recovery code use triggers warning email

**Dependencies**:

- READS FROM: User2FAConfig, RateLimitCache (Redis)
- WRITES TO: 2FAVerificationAttempt log
- CALLS: Twilio API (SMS delivery), synchronous with 5s timeout
- PUBLISHES: `2FAVerificationFailed` event (for security monitoring)

**API Surface**:

```
POST /api/auth/2fa/verify
  Request: { session_token, code, method }
  Response: { success, auth_token? }

POST /api/auth/2fa/send-sms
  Request: { session_token }
  Response: { sent, expires_at }
```

---

#### **Capability 3: Account Recovery**

**Requirements**:

- FR3.1: System SHALL allow regenerating recovery codes (invalidates old ones)
- FR3.2: System SHALL send email alert when recovery code used
- FR3.3: System SHALL provide admin override for locked accounts (audit logged)
- FR3.4: System SHALL automatically disable 2FA if user proves identity to support

**Dependencies**:

- WRITES TO: AuditLog (immutable, append-only)
- CALLS: Email Service (async via queue)
- CALLS: Identity Verification Service (support workflow)

---

### **Non-Functional Requirements**

**Performance**:

- TOTP verification: p95 <100ms, p99 <200ms (cryptographic operation)
- QR code generation: <500ms
- SMS delivery: <5s (Twilio SLA)

**Scalability**:

- 100K daily active users, 20% use 2FA = 20K verifications/day
- Peak: 50 verifications/second
- Storage: ~500 bytes/user × 1M users = 500MB

**Availability**:

- 99.9% uptime requirement
- Graceful degradation: If SMS fails, TOTP still works
- If 2FA service down, allow password-only with forced 2FA setup on next login

**Security**:

- TOTP secrets encrypted with AES-256-GCM
- Recovery codes hashed with bcrypt (cost factor 12)
- Rate limiting at API gateway + application layer
- Audit all 2FA events for 2 years (compliance)
- Time-constant comparison for code validation (prevent timing attacks)

**Data Residency**:

- Phone numbers are PII, follow existing GDPR policies
- Audit logs retained 2 years, then anonymized

**Observability**:

- Track: 2FA adoption rate, verification success/failure rates
- Alert: Verification failure rate >5%, SMS delivery failure >2%
- Dashboard: Real-time 2FA usage by method (TOTP vs SMS vs recovery)

---

### **Integration Requirements**

**Twilio SMS Gateway**:

- **Type**: REST API, synchronous
- **Auth**: Account SID + Auth Token
- **Operations**: Send verification SMS
- **SLA**: 95% delivered within 5 seconds
- **Failure Handling**: Retry once, then show user "SMS unavailable, use TOTP"
- **Rate Limits**: 100 SMS/second (our tier)
- **Cost**: Track monthly usage, alert at 80% of budget

**Email Service (Internal)**:

- **Type**: RabbitMQ, asynchronous
- **Events**: `2FAEnabled`, `RecoveryCodeUsed`, `2FADisabled`
- **SLA**: Best effort, 5-minute delivery
- **Templates**: Reuse existing notification templates

---

### **Data Model**

```
User (existing table)
├── user_id (PK)
├── email
├── password_hash
└── 2fa_required (boolean, new column)

User2FAConfig (new table)
├── config_id (PK)
├── user_id (FK unique, indexed)
├── totp_secret (bytea, encrypted)
├── backup_phone_encrypted (text, nullable)
├── recovery_codes_hash (text[10])
├── recovery_codes_used (integer[], tracks which codes)
├── enabled_at (timestamptz)
├── last_verified_at (timestamptz)
├── status (enum: disabled/enabled/locked)
├── created_at
└── updated_at

2FAVerificationAttempt (new table, hot partition)
├── attempt_id (PK)
├── user_id (FK, indexed)
├── method (enum)
├── success (boolean)
├── ip_address (inet)
├── user_agent (text)
└── attempted_at (timestamptz, indexed for time-series queries)

UsedTOTPCode (Redis with TTL)
Key: "totp:used:{user_id}:{code_hash}"
TTL: 90 seconds
Value: timestamp
```

**Data Retention**:

- User2FAConfig: Delete immediately on user deletion
- 2FAVerificationAttempt: Partition by month, retain 12 months
- UsedTOTPCode: Auto-expire via Redis TTL

**Estimated Volume**:

- User2FAConfig: 1M users × 500 bytes = 500MB
- 2FAVerificationAttempt: 20K/day × 365 days × 200 bytes = 1.5GB/year

---

### **State Machine: 2FA Enrollment**

```
States:
- NOT_ENROLLED
- SECRET_GENERATED
- AWAITING_VERIFICATION
- ENROLLED
- DISABLED
- LOCKED

Transitions:
NOT_ENROLLED → [Generate Secret] → SECRET_GENERATED
SECRET_GENERATED → [Verify First Code] → ENROLLED
ENROLLED → [Disable 2FA] → DISABLED
ENROLLED → [3 Failed Attempts] → LOCKED
LOCKED → [Admin Unlock] → ENROLLED
* → [User Deleted] → (cascade delete)

Rollback:
- If verification fails during enrollment, allow retry (don't burn secret)
- Secrets older than 10 minutes without verification → expire
```

---

### **User Interface Requirements**

**Security Settings Page**:

- **New Section**: "Two-Factor Authentication"
- **Components**:
  - Toggle switch (enable/disable)
  - QR code display (canvas-based)
  - Recovery codes modal
  - Test 2FA button
- **State**: React Context + backend sync
- **Real-time**: None needed

**Login Flow Modification**:

- **Existing**: Email → Password → Dashboard
- **New**: Email → Password → 2FA Code → Dashboard
- **Components**: 2FA input (6-digit, auto-submit), "Use recovery code" link, "Send SMS" button

**Responsive**:

- Mobile: QR code scannable, large input fields
- Tablet/Desktop: Side-by-side QR and instructions

**Accessibility**:

- ARIA labels on all inputs
- Screen reader support for QR alternative (manual secret entry)
- Keyboard navigation for all flows

---

### **Migration & Rollout Strategy**

**Phase 1: Opt-in Beta (Week 1-2)**

- Deploy to 5% of users via feature flag `2fa_enabled`
- Only accounts with <$100 transaction history
- Monitor: Setup completion rate, support tickets
- Success: >70% completion rate, <5% support increase

**Phase 2: Recommended (Week 3-4)**

- Banner on dashboard: "Secure your account with 2FA"
- Enable for all users, keep optional
- Incentivize: $5 credit for enabling 2FA

**Phase 3: Mandatory for Sensitive Actions (Week 5-6)**

- Require 2FA for:
  - Transactions >$500
  - Data exports
  - API key generation
- Soft enforcement: Prompt to enable, don't block

**Phase 4: Full Enforcement (Week 8+)**

- All users must enable 2FA within 30 days
- Send 3 reminder emails
- Grace period: 60 days for users who haven't logged in recently

**Backwards Compatibility**:

- Existing auth endpoints unchanged
- New `/2fa/*` endpoints are additive
- Old mobile app versions (<3.0) show "Update required" message

---

## Version 2: AI-Native PRD (Structured for Architecture Parsing)

```yaml
feature:
  id: "2FA_AUTH_001"
  name: "Two-Factor Authentication"
  version: "1.0"
  owner_team: "security_team"
  priority: "P0"
  estimated_effort: "8 weeks"

problem:
  current_state: "Single-factor password authentication"
  pain_points:
    - unauthorized_access_incidents: 45/month
    - user_trust_score: 6.2/10
    - compliance_risk: "Medium (SOC2 audit gap)"
  desired_state: "Multi-factor authentication with 90% incident reduction"

success_criteria:
  metrics:
    - name: "unauthorized_access_incidents"
      current: 45
      target: 4.5
      timeframe: "3 months"
    - name: "2fa_adoption_rate"
      target: 60
      unit: "percent"
      timeframe: "6 months"
    - name: "2fa_verification_success_rate"
      target: 99.9
      unit: "percent"
  constraints:
    - type: "support_ticket_increase"
      max_threshold: "10%"
    - type: "monthly_sms_budget"
      max_value: 500
      currency: "USD"

scope:
  in_scope:
    - "TOTP authentication (RFC 6238)"
    - "SMS backup codes"
    - "Recovery codes (10 per user)"
    - "Admin enforcement policies"
  out_of_scope:
    - "Hardware tokens (YubiKey, FIDO2)"
    - "Biometric authentication"
    - "SSO integration (Okta, Auth0)"

actors:
  - id: "end_user"
    type: "human"
    interactions: ["enroll_2fa", "verify_2fa", "use_recovery"]
  - id: "admin_user"
    type: "human"
    interactions: ["enforce_policy", "unlock_account"]
  - id: "support_agent"
    type: "human"
    interactions: ["manual_verification", "reset_2fa"]
  - id: "twilio_sms"
    type: "external_system"
    sla: "95% delivery <5s"
    cost_per_call: 0.0075

architecture:
  new_services:
    - name: "2fa-service"
      type: "microservice"
      language: "Go"
      reason: "Performance for cryptographic operations, high throughput"
      responsibilities:
        - "Generate TOTP secrets"
        - "Validate TOTP/SMS/recovery codes"
        - "Manage recovery codes"
        - "Rate limiting"
      scaling:
        strategy: "horizontal"
        target_rps: 50
        instances_min: 2
        instances_max: 10

  modified_services:
    - name: "auth-service"
      changes:
        - type: "add_endpoint"
          endpoint: "POST /auth/login"
          modification: "Add 2FA check after password validation"
        - type: "add_middleware"
          name: "2fa_required_middleware"
          applies_to: ["sensitive_actions"]

    - name: "user-service"
      changes:
        - type: "add_column"
          table: "users"
          column: "2fa_required"
          datatype: "boolean"
          default: false
        - type: "subscribe_event"
          event: "User2FAEnabled"
          action: "Update user preferences"

  new_datastores:
    - name: "2fa_config_db"
      type: "PostgreSQL"
      schema:
        tables:
          - name: "user_2fa_config"
            primary_key: "config_id"
            indexes:
              - columns: ["user_id"]
                unique: true
              - columns: ["enabled_at"]
            columns:
              - name: "user_id"
                type: "UUID"
                foreign_key: "users.user_id"
              - name: "totp_secret"
                type: "BYTEA"
                encrypted: true
                encryption_method: "AES-256-GCM"
              - name: "recovery_codes_hash"
                type: "TEXT[]"
                size: 10
          - name: "2fa_verification_attempt"
            partitioning:
              type: "time"
              interval: "monthly"
              retention: "12 months"

    - name: "totp_code_cache"
      type: "Redis"
      purpose: "Prevent code reuse"
      ttl: 90
      key_pattern: "totp:used:{user_id}:{code_hash}"
      estimated_keys: 100000
      eviction: "ttl"

  integrations:
    - name: "twilio_sms"
      type: "external"
      protocol: "REST"
      sync: true
      auth: "api_key"
      endpoints:
        - method: "POST"
          url: "https://api.twilio.com/2010-04-01/Accounts/{AccountSid}/Messages.json"
          timeout: 5000
          retry:
            max_attempts: 1
            backoff: "none"
      fallback: "Show user TOTP option if SMS fails"
      circuit_breaker:
        failure_threshold: 5
        timeout: 30000

    - name: "email_service"
      type: "internal"
      protocol: "amqp"
      sync: false
      queue: "notifications"
      events_published:
        - "User2FAEnabled"
        - "RecoveryCodeUsed"
        - "2FAAccountLocked"

  data_flow:
    - flow_id: "enrollment_flow"
      trigger: "User clicks Enable 2FA"
      steps:
        - service: "frontend"
          action: "POST /api/auth/2fa/enroll"
          target: "2fa-service"
        - service: "2fa-service"
          action: "Generate TOTP secret"
          calls: "encryption-service"
        - service: "2fa-service"
          action: "Write to user_2fa_config"
          target: "2fa_config_db"
        - service: "2fa-service"
          action: "Return QR code + recovery codes"
          target: "frontend"
        - service: "frontend"
          action: "Display QR code, wait for verification"
        - service: "frontend"
          action: "POST /api/auth/2fa/verify-enrollment"
          payload: "{ totp_code }"
          target: "2fa-service"
        - service: "2fa-service"
          action: "Validate TOTP"
          logic: "HMAC-SHA1, ±1 window tolerance"
        - service: "2fa-service"
          action: "Publish User2FAEnabled event"
          target: "event_bus"
        - service: "user-service"
          action: "Update user.2fa_required = true"
          trigger: "Subscribe to User2FAEnabled"

    - flow_id: "login_with_2fa"
      trigger: "User submits login form"
      critical_path: true
      max_latency: 3000
      steps:
        - service: "frontend"
          action: "POST /api/auth/login"
          payload: "{ email, password }"
          target: "auth-service"
        - service: "auth-service"
          action: "Validate password"
          target: "user-service"
        - service: "auth-service"
          action: "Check if 2FA enabled"
          query: "SELECT 2fa_required FROM users"
        - service: "auth-service"
          action: "Return session_token (partial auth)"
          target: "frontend"
        - service: "frontend"
          action: "Show 2FA prompt"
        - service: "frontend"
          action: "POST /api/auth/2fa/verify"
          payload: "{ session_token, totp_code }"
          target: "2fa-service"
        - service: "2fa-service"
          action: "Validate TOTP"
          checks:
            - "Check rate limit (Redis)"
            - "Validate code (cryptographic)"
            - "Check not reused (Redis)"
          max_latency: 200
        - service: "2fa-service"
          action: "Return auth_token (full auth)"
          target: "frontend"
        - service: "frontend"
          action: "Redirect to dashboard"

capabilities:
  - id: "2fa_enrollment"
    requirements:
      - id: "FR1.1"
        text: "Generate cryptographically secure TOTP secrets"
        acceptance:
          - "Secret is 32-byte base32 encoded"
          - "Uses crypto/rand for generation"
          - "Stored encrypted at rest"
        test_approach: "Unit test secret generation, integration test encryption"

      - id: "FR1.2"
        text: "Display QR code with otpauth:// URI"
        acceptance:
          - "QR contains otpauth://totp/{issuer}:{email}?secret={secret}&issuer={issuer}"
          - "QR scannable by Google Authenticator, Authy"
        test_approach: "E2E test with actual authenticator apps"

      - id: "FR1.3"
        text: "Validate first TOTP code before enabling"
        acceptance:
          - "Code must match within ±1 time window"
          - "Enrollment fails if invalid"
        test_approach: "Unit test with mock time, E2E test with real codes"

      - id: "FR1.4"
        text: "Generate 10 single-use recovery codes"
        acceptance:
          - "Codes are 16-char alphanumeric"
          - "Stored as bcrypt hash (cost 12)"
        test_approach: "Unit test generation and hashing"

    dependencies:
      reads_from:
        - service: "user-service"
          data: "user profile"
      writes_to:
        - service: "2fa_config_db"
          data: "user_2fa_config table"
      publishes:
        - event: "User2FAEnabled"
          schema:
            user_id: "UUID"
            enabled_at: "timestamp"
            method: "totp"
      subscribes:
        - event: "UserDeleted"
          action: "Cascade delete 2fa_config"
      calls:
        - service: "encryption-service"
          operation: "encrypt"
          sync: true

    api:
      - method: "POST"
        path: "/api/auth/2fa/enroll"
        request:
          method: "totp"
        response:
          qr_code_data_url: "string"
          secret_backup: "string"
          recovery_codes: "string[]"
        errors:
          - code: 409
            condition: "2FA already enabled"
          - code: 500
            condition: "Encryption service unavailable"
        rate_limit: "10 per hour per user"

      - method: "POST"
        path: "/api/auth/2fa/verify-enrollment"
        request:
          totp_code: "string (6 digits)"
        response:
          success: "boolean"
          enabled_at: "timestamp"
        errors:
          - code: 400
            condition: "Invalid code format"
          - code: 401
            condition: "Code validation failed"
        rate_limit: "5 per minute per user"

  - id: "2fa_authentication"
    requirements:
      - id: "FR2.1"
        text: "Validate TOTP codes within ±1 time window"
        acceptance:
          - "Accepts codes from t-30s to t+30s"
          - "Uses RFC 6238 HMAC-SHA1 algorithm"
        technical_spec:
          algorithm: "HMAC-SHA1"
          time_step: 30
          code_digits: 6
          window: 1
        test_approach: "Unit test with frozen time, fuzz test boundaries"

      - id: "FR2.2"
        text: "Prevent code reuse within same time window"
        acceptance:
          - "Store used code hash in Redis with 90s TTL"
          - "Reject duplicate code submissions"
        test_approach: "Integration test with Redis"

      - id: "FR2.3"
        text: "Support SMS backup codes"
        acceptance:
          - "Generate 6-digit random code"
          - "Send via Twilio"
          - "Expire after 10 minutes"
        cost_model:
          per_sms: 0.0075
          monthly_budget: 500
          max_sms_per_month: 66666
        test_approach: "Integration test with Twilio sandbox"

      - id: "FR2.5"
        text: "Rate-limit verification attempts"
        acceptance:
          - "Max 3 attempts per 5 minutes per user"
          - "Trigger account lock on 4th attempt"
        test_approach: "Load test rate limiting, unit test lock logic"

    business_rules:
      - rule: "After 3 failed attempts, enforce 5-minute cooldown"
        enforcement: "application_layer"
      - rule: "SMS codes cost tracked against monthly budget"
        enforcement: "emit_metric_on_send"
      - rule: "Successful recovery code use triggers email alert"
        enforcement: "async_event"

    performance:
      - operation: "TOTP validation"
        target_p95: 100
        target_p99: 200
        unit: "ms"
        rationale: "Cryptographic operation should be fast"

      - operation: "SMS delivery"
        target_p95: 5000
        target_p99: 10000
        unit: "ms"
        sla_dependency: "Twilio (95% <5s)"

  - id: "account_recovery"
    requirements:
      - id: "FR3.1"
        text: "Allow regenerating recovery codes"
        acceptance:
          - "Invalidates all old codes"
          - "Generates new set of 10"
        test_approach: "E2E test old codes rejected"

      - id: "FR3.2"
        text: "Send email alert when recovery code used"
        acceptance:
          - "Email sent within 5 minutes"
          - "Contains: timestamp, IP, user agent"
        test_approach: "Integration test with email queue"

      - id: "FR3.3"
        text: "Provide admin override for locked accounts"
        acceptance:
          - "Admin can unlock via dashboard"
          - "Action logged to audit table"
        audit:
          table: "admin_actions"
          retention: "7 years"
        test_approach: "E2E test with admin role"

non_functional_requirements:
  performance:
    - metric: "2fa_verification_latency_p95"
      target: 100
      unit: "ms"
      measurement: "Server-side, TOTP validation only"

    - metric: "qr_code_generation_latency_p99"
      target: 500
      unit: "ms"
      measurement: "End-to-end from API call to response"

  scalability:
    - dimension: "concurrent_users"
      target: 100000
      calculation: "1M users × 20% 2FA adoption × 50% daily active"

    - dimension: "verifications_per_second"
      target: 50
      peak_multiplier: 2
      calculation: "20K daily logins / 86400s × 10x peak hour"

    - dimension: "storage"
      target: "500MB for 1M users"
      calculation: "500 bytes per user (config + attempts)"

  availability:
    - target: 99.9
      unit: "percent"
      allowed_downtime: "43 minutes/month"

    - degradation_strategy:
        - condition: "Twilio unavailable"
          fallback: "TOTP and recovery codes still work"
        - condition: "2FA service unavailable"
          fallback: "Allow password-only, force 2FA setup on next login"

  security:
    - requirement: "Encrypt TOTP secrets at rest"
      method: "AES-256-GCM"
      key_management: "Per-user encryption keys derived from master key"

    - requirement: "Hash recovery codes"
      method: "bcrypt"
      cost_factor: 12

    - requirement: "Prevent timing attacks"
      implementation: "Use time-constant comparison for code validation"

    - requirement: "Audit all 2FA events"
      retention: "2 years"
      events: ["enrollment", "verification", "failure", "admin_action"]

  observability:
    dashboards:
      - name: "2FA Adoption & Usage"
        metrics:
          - "2fa_enabled_users_count"
          - "2fa_verification_attempts_total"
          - "2fa_verification_success_rate"
          - "2fa_method_distribution (totp/sms/recovery)"

    alerts:
      - name: "High 2FA verification failure rate"
        condition: "2fa_verification_failure_rate > 5%"
        window: "5 minutes"
        severity: "warning"
        action: "Page on-call engineer"

      - name: "SMS delivery failure spike"
        condition: "twilio_delivery_failure_rate > 2%"
        window: "5 minutes"
        severity: "critical"
        action: "Check Twilio status page, switch to failover provider"

      - name: "SMS budget threshold"
        condition: "monthly_sms_spend > 400"
        severity: "info"
        action: "Notify finance team"

    logs:
      - event: "2fa_verification_attempt"
        level: "info"
        fields: ["user_id", "method", "success", "ip", "user_agent"]
        sampling: "100%"

      - event: "2fa_rate_limit_triggered"
        level: "warning"
        fields: ["user_id", "ip", "attempt_count"]
        sampling: "100%"

deployment:
  phases:
    - name: "internal_beta"
      duration: "2 weeks"
      rollout:
        percentage: 5
        targeting: "internal_users_only"
        feature_flag: "2fa_enabled"
      success_criteria:
        - metric: "setup_completion_rate"
          threshold: 70
        - metric: "2fa_verification_success_rate"
          threshold: 99.0
        - metric: "support_tickets_increase"
          threshold: 5
          comparison: "less_than"
      rollback_triggers:
        - condition: "critical_bugs > 0"
        - condition: "setup_completion_rate < 50%"

    - name: "public_beta"
      duration: "2 weeks"
      rollout:
        percentage: 20
        targeting: "users_with_low_transaction_volume"
        feature_flag: "2fa_enabled"
      success_criteria:
        - metric: "2fa_verification_success_rate"
          threshold: 99.0
        - metric: "support_tickets_increase"
          threshold: 10
          comparison: "less_than"
      monitoring:
        - "Real-time dashboard for verification failures"
        - "SMS delivery rate tracking"
        - "User drop-off in enrollment funnel"

    - name: "recommended_adoption"
      duration: "2 weeks"
      rollout:
        percentage: 100
        enforcement: "optional"
      ui_changes:
        - "Banner on dashboard: 'Secure your account with 2FA'"
        - "Email campaign to all users"
      incentives:
        - type: "account_credit"
          amount: 5
          currency: "USD"
          condition: "Complete 2FA setup within 14 days"

    - name: "mandatory_for_sensitive"
      duration: "2 weeks"
      rollout:
        enforcement: "conditional"
        conditions:
          - "transaction_amount > 500"
          - "data_export_requested"
          - "api_key_generation"
      ui_changes:
        - "Soft block: Prompt to enable 2FA, show 'Skip for now' option"
      grace_period: "3 skips allowed before hard block"

    - name: "full_enforcement"
      duration: "ongoing"
      rollout:
        enforcement: "mandatory"
        grace_period: "30 days"
      communication:
        - timeline: "T-30 days"
          channel: "email"
          message: "2FA will be required in 30 days"
        - timeline: "T-14 days"
          channel: "email + in-app banner"
        - timeline: "T-7 days"
          channel: "email + modal on login"
        - timeline: "T-0"
          channel: "hard block on login"
          action: "Redirect to 2FA setup, no skip option"
      exceptions:
        - user_type: "dormant_accounts"
          condition: "last_login > 180 days ago"
          handling: "Enforce on next login"

  infrastructure:
    new_components:
      - name: "2fa-service"
        deployment:
          type: "kubernetes"
          replicas_min: 2
          replicas_max: 10
          autoscaling:
            metric: "cpu_utilization"
            target: 70
          resource_limits:
            cpu: "500m"
            memory: "512Mi"
          health_checks:
            liveness: "GET /health/live"
            readiness: "GET /health/ready"
        load_balancer:
          type: "application"
          health_check_path: "/health"
          timeout: 5

      - name: "2fa-postgres"
        deployment:
          type: "managed_rds"
          instance_type: "db.t3.small"
          storage: "100GB"
          backup_retention: "30 days"
          multi_az: true
          encryption: "enabled"
        monitoring:
          - "CPU utilization < 80%"
          - "Storage < 80% capacity"
          - "Connection count < 80% max"

      - name: "totp-redis"
        deployment:
          type: "elasticache"
          node_type: "cache.t3.micro"
          num_nodes: 2
          replication: true
        configuration:
          maxmemory_policy: "volatile-ttl"
          eviction: "enabled"

    modified_components:
      - name: "auth-service"
        changes:
          - type: "code_change"
            file: "internal/handlers/login.go"
            description: "Add 2FA check after password validation"
            estimated_loc: 150
          - type: "dependency_added"
            package: "github.com/company/2fa-client"
            version: "v1.0.0"
        deployment:
          strategy: "rolling_update"
          rollback_on_error: true

      - name: "user-service"
        changes:
          - type: "database_migration"
            migration: "20241109_add_2fa_required_column.sql"
            reversible: true
            estimated_downtime: "0s (online DDL)"
        deployment:
          strategy: "blue_green"
          cutover: "after_migration_verified"

  backwards_compatibility:
    - component: "mobile_app"
      minimum_version: "3.0.0"
      handling:
        - version: "< 3.0.0"
          behavior: "Show 'Update Required' dialog"
          reason: "No 2FA UI support"

    - component: "api"
      versioning:
        - version: "v1"
          support: "Continues to work, returns 2fa_required flag"
        - version: "v2"
          support: "New endpoints for 2FA enrollment/verification"
      deprecation:
        - endpoint: "POST /v1/auth/login"
          timeline: "12 months"
          replacement: "POST /v2/auth/login (with 2FA support)"

testing:
  unit_tests:
    - component: "totp_generator"
      coverage_target: 95
      critical_tests:
        - "Secret generation randomness"
        - "TOTP code validation with time windows"
        - "Time-constant comparison"

    - component: "recovery_code_manager"
      coverage_target: 90
      critical_tests:
        - "Code generation uniqueness"
        - "Bcrypt hashing"
        - "Single-use enforcement"

  integration_tests:
    - scenario: "End-to-end 2FA enrollment"
      steps:
        - "Generate secret"
        - "Store encrypted in database"
        - "Validate first TOTP code"
        - "Verify recovery codes stored"
      assertions:
        - "Secret encrypted at rest"
        - "Recovery codes are bcrypt hashed"
        - "User2FAEnabled event published"

    - scenario: "Login with 2FA"
      steps:
        - "Submit valid credentials"
        - "Receive session token"
        - "Submit TOTP code"
        - "Receive auth token"
      assertions:
        - "TOTP code validated correctly"
        - "Code marked as used in Redis"
        - "Auth token includes 2fa_verified claim"

    - scenario: "SMS fallback"
      steps:
        - "Request SMS code"
        - "Verify Twilio API called"
        - "Submit SMS code"
        - "Verify authentication succeeds"
      mocks:
        - service: "twilio"
          response: "SMS sent successfully"

    - scenario: "Rate limiting"
      steps:
        - "Submit 3 invalid codes rapidly"
        - "Verify account locked"
        - "Verify 4th attempt rejected"
      assertions:
        - "Rate limit enforced at application layer"
        - "User receives lockout notification"

  e2e_tests:
    - scenario: "Full user journey with real authenticator"
      tools: ["Cypress", "Google Authenticator browser extension"]
      steps:
        - "Navigate to security settings"
        - "Enable 2FA"
        - "Scan QR code with authenticator"
        - "Enter code from authenticator"
        - "Download recovery codes"
        - "Logout and login again"
        - "Verify 2FA prompt appears"
        - "Enter code from authenticator"
        - "Verify dashboard access"

    - scenario: "Recovery code usage"
      steps:
        - "Login with credentials"
        - "Click 'Use recovery code' link"
        - "Enter valid recovery code"
        - "Verify authentication succeeds"
        - "Verify recovery code marked as used"
        - "Verify email alert sent"

  load_tests:
    - scenario: "Peak verification load"
      tool: "k6"
      parameters:
        virtual_users: 500
        duration: "5m"
        ramp_up: "30s"
      requests:
        - endpoint: "POST /api/auth/2fa/verify"
          rate: "50 rps"
      success_criteria:
        - "p95_latency < 100ms"
        - "p99_latency < 200ms"
        - "error_rate < 0.1%"

    - scenario: "Enrollment spike"
      parameters:
        virtual_users: 200
        duration: "10m"
      requests:
        - endpoint: "POST /api/auth/2fa/enroll"
          rate: "20 rps"
      success_criteria:
        - "qr_generation_p99 < 500ms"
        - "database_write_success_rate > 99.9%"

  security_tests:
    - type: "penetration_testing"
      focus:
        - "TOTP secret extraction attempts"
        - "Timing attack on code validation"
        - "Rate limit bypass attempts"
        - "Recovery code enumeration"
      tool: "OWASP ZAP + manual testing"

    - type: "cryptographic_validation"
      checks:
        - "TOTP implementation matches RFC 6238"
        - "Secrets use cryptographically secure RNG"
        - "Encryption keys properly rotated"
      tool: "Custom test suite"

risks:
  technical:
    - risk: "TOTP secret encryption key compromise"
      severity: "critical"
      probability: "low"
      mitigation:
        - "Use hardware security module (HSM) for master key"
        - "Implement key rotation every 90 days"
        - "Monitor key access with alerting"
      contingency: "Force all users to re-enroll if key compromised"

    - risk: "Twilio service outage"
      severity: "medium"
      probability: "medium"
      mitigation:
        - "Fallback to TOTP and recovery codes"
        - "Display clear error message to users"
      contingency: "Partner with backup SMS provider (e.g., MessageBird)"

    - risk: "Redis cache failure"
      severity: "medium"
      probability: "low"
      mitigation:
        - "Use Redis replication"
        - "Fail open: Allow TOTP validation even if Redis down"
      contingency: "Accept risk of code reuse for short period"

    - risk: "Database migration failure"
      severity: "high"
      probability: "low"
      mitigation:
        - "Test migration on staging with production data clone"
        - "Use online DDL (no locks)"
        - "Have rollback script ready"
      contingency: "Revert to previous version, postpone feature"

  product:
    - risk: "Low user adoption (<40%)"
      severity: "high"
      probability: "medium"
      mitigation:
        - "Offer incentive ($5 credit)"
        - "Clear UX with educational content"
        - "Gradual enforcement strategy"
      contingency: "Increase incentive amount, extend timeline"

    - risk: "Support ticket spike (>20%)"
      severity: "medium"
      probability: "medium"
      mitigation:
        - "Comprehensive FAQ and help docs"
        - "In-app tooltips and guided setup"
        - "Train support team before launch"
      contingency: "Add dedicated 2FA support queue"

    - risk: "Users locked out without recovery codes"
      severity: "high"
      probability: "medium"
      mitigation:
        - "Force users to download recovery codes before enabling"
        - "Allow admin override with identity verification"
      contingency: "Manual support process with enhanced verification"

  compliance:
    - risk: "GDPR violation (phone numbers not properly protected)"
      severity: "critical"
      probability: "low"
      mitigation:
        - "Encrypt phone numbers at rest"
        - "Allow users to delete 2FA config"
        - "Anonymize audit logs after retention period"
      contingency: "Disable SMS feature, TOTP-only"

dependencies:
  upstream:
    - team: "infrastructure"
      deliverable: "Redis Elasticache cluster provisioned"
      deadline: "Week 1"
      status: "in_progress"

    - team: "platform"
      deliverable: "Encryption service supports per-user keys"
      deadline: "Week 2"
      status: "not_started"
      risk: "medium (new feature for encryption service)"

    - team: "legal"
      deliverable: "Review and approve Twilio DPA"
      deadline: "Week 1"
      status: "completed"

  downstream:
    - team: "mobile"
      impact: "Must add 2FA UI to iOS and Android apps"
      coordination: "Weekly sync meetings"
      timeline: "Parallel development, launch together"

    - team: "support"
      impact: "New support workflows for 2FA issues"
      coordination: "Training session in Week 6"
      deliverable: "Updated runbooks by Week 5"

success_measurement:
  quantitative:
    - metric: "2fa_adoption_rate"
      measurement: "COUNT(users WHERE 2fa_enabled) / COUNT(users)"
      target: "60% in 6 months"
      tracking: "Weekly dashboard update"

    - metric: "unauthorized_access_incidents"
      measurement: "COUNT(security_incidents WHERE type='unauthorized_access')"
      target: "90% reduction in 3 months"
      baseline: 45
      tracking: "Monthly security report"

    - metric: "2fa_setup_completion_rate"
      measurement: "COUNT(completed_setups) / COUNT(started_setups)"
      target: ">80%"
      tracking: "Real-time funnel analysis"

    - metric: "average_setup_time"
      measurement: "AVG(completed_at - started_at)"
      target: "<3 minutes"
      tracking: "Product analytics"

  qualitative:
    - metric: "user_satisfaction"
      measurement: "Post-setup survey (1-5 scale)"
      target: ">4.0 average"
      tracking: "Survey sent 24 hours after setup"

    - metric: "support_feedback"
      measurement: "Support ticket sentiment analysis"
      target: "<10% negative sentiment"
      tracking: "Weekly review of ticket tags"

post_launch:
  monitoring_period: "90 days"
  review_cadence: "Weekly for first month, then bi-weekly"

  iteration_backlog:
    - feature: "Hardware token support (YubiKey)"
      priority: "P2"
      estimated_effort: "4 weeks"
      condition: "If user requests >50"

    - feature: "Biometric authentication (fingerprint, Face ID)"
      priority: "P2"
      estimated_effort: "6 weeks"
      condition: "Mobile app v4.0 launch"

    - feature: "Backup phone number"
      priority: "P3"
      estimated_effort: "2 weeks"
      condition: "If SMS usage >40% of verifications"

    - feature: "Admin dashboard for 2FA analytics"
      priority: "P3"
      estimated_effort: "3 weeks"
      condition: "Enterprise customers request visibility"

  sunset_criteria:
    - condition: "Industry moves to passwordless (WebAuthn)"
      timeline: "2-3 years"
      migration_path: "Transition to passkeys"
```

---

## Architecture Mapping & Change Analysis

Now let me map this PRD to your existing architecture and identify what's NEW, UPDATED, or DELETED:

### **Architecture Change Map**

```yaml
architecture_changes:
  ## NEW COMPONENTS
  new:
    services:
      - name: "2fa-service"
        type: "microservice"
        language: "Go"
        reason: "New capability, isolated for security and performance"
        architecture_tier: "application"
        communication:
          inbound: ["auth-service via REST", "frontend via REST"]
          outbound:
            [
              "encryption-service via gRPC",
              "twilio via REST",
              "event-bus via AMQP",
            ]
        diagram_placement: "Between auth-service and external integrations"

    databases:
      - name: "2fa_config_db"
        type: "PostgreSQL"
        reason: "Structured data with ACID requirements"
        connection_pool: "Max 50 connections"
        replication: "Primary with 1 read replica"
        diagram_placement: "Data layer, connected to 2fa-service"

      - name: "totp_code_cache"
        type: "Redis"
        reason: "Fast lookups for code reuse prevention"
        persistence: "No (TTL-based eviction)"
        diagram_placement: "Cache layer, connected to 2fa-service"

    integrations:
      - name: "twilio_sms_gateway"
        type: "external_rest_api"
        direction: "outbound"
        sync: true
        diagram_representation: "External system box with REST arrow"

    infrastructure:
      - name: "2fa-k8s-deployment"
        type: "kubernetes_deployment"
        replicas: "2-10 (autoscaling)"
        diagram_placement: "Container orchestration layer"

      - name: "2fa-alb"
        type: "application_load_balancer"
        reason: "Health checks and traffic distribution"
        diagram_placement: "Edge layer, in front of 2fa-service"

  ## MODIFIED COMPONENTS
  modified:
    services:
      - name: "auth-service"
        existing_function: "Handle login, session management"
        changes:
          code:
            - file: "internal/handlers/login.go"
              change_type: "add_logic"
              description: "After password validation, check if user has 2FA enabled. If yes, return partial auth token and require 2FA verification."
              pseudocode: |
                func Login(email, password) {
                  user := validateCredentials(email, password)
                  if user.2fa_required {
                    sessionToken := createPartialAuthToken(user.id)
                    return { requires_2fa: true, session_token: sessionToken }
                  }
                  return { auth_token: createFullAuthToken(user.id) }
                }

            - file: "internal/middleware/auth.go"
              change_type: "add_middleware"
              description: "New middleware to check if 2FA is required for sensitive actions"
              pseudocode: |
                func Require2FA(next http.Handler) http.Handler {
                  return http.HandlerFunc(func(w, r) {
                    user := getUserFromToken(r)
                    if !user.2fa_verified && isSensitiveAction(r) {
                      return error("2FA required")
                    }
                    next.ServeHTTP(w, r)
                  })
                }

          dependencies:
            added:
              - "2fa-service client library (gRPC)"
            removed: []

          api_changes:
            - endpoint: "POST /api/auth/login"
              change: "Response schema updated"
              old_response: |
                { "auth_token": "string" }
              new_response: |
                {
                  "auth_token": "string" (if 2FA not required),
                  "requires_2fa": boolean,
                  "session_token": "string" (if 2FA required)
                }
              backwards_compatible: true
              reason: "New fields added, old field still present when 2FA not enabled"

        diagram_changes:
          - type: "add_connection"
            from: "auth-service"
            to: "2fa-service"
            protocol: "gRPC"
            purpose: "Check 2FA status"

      - name: "user-service"
        existing_function: "User profile management, CRUD operations"
        changes:
          database:
            - table: "users"
              migration: "20241109_add_2fa_required.sql"
              change_type: "add_column"
              column_definition: |
                ALTER TABLE users 
                ADD COLUMN 2fa_required BOOLEAN DEFAULT FALSE;
              reversible: true
              estimated_rows_affected: "1M"
              downtime: "0s (online DDL)"

          event_handling:
            subscriptions_added:
              - event: "User2FAEnabled"
                action: "Update users.2fa_required = TRUE"
                handler: "internal/subscribers/2fa_events.go"
              - event: "User2FADisabled"
                action: "Update users.2fa_required = FALSE"
              - event: "UserDeleted"
                publish_to: "2fa-service"
                action: "Trigger 2FA config cleanup"

        diagram_changes:
          - type: "add_event_subscription"
            subscribes_to: "event_bus"
            events: ["User2FAEnabled", "User2FADisabled"]

      - name: "frontend-web-app"
        existing_function: "User interface, API calls"
        changes:
          components_added:
            - path: "src/components/Security/TwoFactorSetup.tsx"
              description: "QR code display, verification input"
            - path: "src/components/Auth/TwoFactorPrompt.tsx"
              description: "2FA code input during login"
            - path: "src/components/Security/RecoveryCodesModal.tsx"
              description: "Display and download recovery codes"

          routing_added:
            - path: "/security/2fa"
              component: "TwoFactorSetup"
            - path: "/login/2fa"
              component: "TwoFactorPrompt"

          state_management:
            - store: "auth"
              changes: "Add 2FA enrollment status, session tokens"

          api_calls_added:
            - "POST /api/auth/2fa/enroll"
            - "POST /api/auth/2fa/verify-enrollment"
            - "POST /api/auth/2fa/verify"
            - "POST /api/auth/2fa/send-sms"

        diagram_changes:
          - type: "add_connection"
            from: "frontend"
            to: "2fa-service"
            protocol: "HTTPS"
            purpose: "2FA enrollment and verification"

      - name: "email-service"
        existing_function: "Send transactional emails"
        changes:
          templates_added:
            - name: "2fa_enabled_notification"
              trigger: "User2FAEnabled event"
            - name: "recovery_code_used_alert"
              trigger: "RecoveryCodeUsed event"
            - name: "2fa_required_reminder"
              trigger: "Scheduled job (before enforcement deadline)"

          event_subscriptions:
            added: ["User2FAEnabled", "RecoveryCodeUsed", "2FAAccountLocked"]

        diagram_changes:
          - type: "add_event_subscription"
            subscribes_to: "event_bus"
            events: ["User2FAEnabled", "RecoveryCodeUsed", "2FAAccountLocked"]

  ## UPDATED COMPONENTS (Configuration/Infrastructure)
  updated:
    infrastructure:
      - name: "api-gateway"
        changes:
          rate_limits:
            added:
              - path: "/api/auth/2fa/*"
                limit: "10 requests/hour per user"
                reason: "Prevent brute force attacks"

          cors_rules:
            updated:
              - allow_origins: "Add 2FA-specific origins if needed"

        diagram_changes:
          - type: "update_annotation"
            note: "Add rate limiting rules for 2FA endpoints"

      - name: "monitoring-stack"
        changes:
          dashboards_added:
            - "2FA Adoption & Usage Dashboard"
            - "2FA Security Metrics Dashboard"

          alerts_added:
            - "High 2FA verification failure rate"
            - "SMS delivery failure spike"
            - "SMS budget threshold"

          metrics_collected:
            - "2fa_verification_attempts_total"
            - "2fa_verification_success_rate"
            - "2fa_enrollment_started_total"
            - "2fa_enrollment_completed_total"
            - "twilio_sms_sent_total"
            - "twilio_sms_cost_dollars_total"

        diagram_changes:
          - type: "add_metrics_flow"
            from: "2fa-service"
            to: "prometheus"
            metrics: "Listed above"

      - name: "event-bus"
        changes:
          topics_added:
            - "user.2fa.enabled"
            - "user.2fa.disabled"
            - "user.2fa.recovery_code_used"
            - "user.2fa.account_locked"

          consumers_added:
            - topic: "user.2fa.enabled"
              consumers: ["user-service", "email-service", "analytics-service"]

        diagram_changes:
          - type: "add_topics"
            topics: ["user.2fa.* namespace"]

  ## DELETED/DEPRECATED (Nothing for this feature)
  deleted: []

  deprecated:
    - component: "POST /v1/auth/login"
      timeline: "12 months"
      reason: "Will be replaced by /v2/auth/login with native 2FA support"
      migration_path: "Use /v2/auth/login, handle requires_2fa response"

## ARCHITECTURE DIAGRAM UPDATES

diagram_changes:
  system_context:
    additions:
      - entity: "User with Authenticator App"
        type: "external_actor"
        interaction: "Scans QR code, provides TOTP codes"
      - entity: "Twilio SMS Gateway"
        type: "external_system"
        interaction: "Receives SMS requests, delivers codes"

    connections:
      - from: "User"
        to: "System"
        label: "Enrolls in 2FA, provides codes"

  component_diagram:
    additions:
      - component: "2FA Service"
        box_color: "blue (new service)"
        position: "Between Auth Service and External Integrations"
      - component: "2FA Config DB"
        type: "database"
        position: "Data layer, under 2FA Service"
      - component: "TOTP Code Cache"
        type: "cache"
        position: "Cache layer, next to 2FA Service"
      - component: "Twilio Gateway"
        type: "external"
        position: "Right side (external systems)"

    connections_added:
      - from: "Frontend"
        to: "2FA Service"
        protocol: "HTTPS/REST"
        endpoints: ["/2fa/enroll", "/2fa/verify"]
      - from: "Auth Service"
        to: "2FA Service"
        protocol: "gRPC"
        purpose: "Check 2FA status"
      - from: "2FA Service"
        to: "2FA Config DB"
        protocol: "SQL"
        operations: ["READ", "WRITE"]
      - from: "2FA Service"
        to: "TOTP Code Cache"
        protocol: "Redis Protocol"
        operations: ["GET", "SET with TTL"]
      - from: "2FA Service"
        to: "Twilio Gateway"
        protocol: "REST"
        operations: ["POST /Messages"]
        sync: true
      - from: "2FA Service"
        to: "Event Bus"
        protocol: "AMQP"
        events: ["User2FAEnabled", "User2FADisabled"]
      - from: "2FA Service"
        to: "Encryption Service"
        protocol: "gRPC"
        purpose: "Encrypt/decrypt TOTP secrets"

    connections_modified:
      - from: "Frontend"
        to: "Auth Service"
        change: "POST /auth/login response now includes requires_2fa field"
      - from: "Auth Service"
        to: "User Service"
        change: "Reads new 2fa_required column"

  sequence_diagrams:
    new:
      - name: "2FA Enrollment Flow"
        actors:
          ["User", "Frontend", "2FA Service", "Encryption Service", "2FA DB"]
        steps:
          - "User clicks Enable 2FA"
          - "Frontend → 2FA Service: POST /2fa/enroll"
          - "2FA Service → Encryption Service: Encrypt secret"
          - "2FA Service → 2FA DB: INSERT user_2fa_config"
          - "2FA Service → Frontend: Return QR code + recovery codes"
          - "User scans QR with authenticator app"
          - "Frontend → 2FA Service: POST /2fa/verify-enrollment {code}"
          - "2FA Service: Validate TOTP code"
          - "2FA Service → Event Bus: Publish User2FAEnabled"
          - "2FA Service → Frontend: Success"

      - name: "Login with 2FA Flow"
        actors:
          ["User", "Frontend", "Auth Service", "2FA Service", "TOTP Cache"]
        steps:
          - "User submits email/password"
          - "Frontend → Auth Service: POST /auth/login"
          - "Auth Service: Validate credentials"
          - "Auth Service → User Service: Check 2fa_required"
          - "Auth Service → Frontend: {requires_2fa: true, session_token}"
          - "Frontend: Show 2FA prompt"
          - "User enters TOTP code"
          - "Frontend → 2FA Service: POST /2fa/verify {session_token, code}"
          - "2FA Service → TOTP Cache: Check code not reused"
          - "2FA Service: Validate TOTP (RFC 6238)"
          - "2FA Service → TOTP Cache: Mark code as used (TTL 90s)"
          - "2FA Service → Frontend: {auth_token}"
          - "Frontend: Redirect to dashboard"

      - name: "SMS Fallback Flow"
        actors: ["User", "Frontend", "2FA Service", "Twilio"]
        steps:
          - "User clicks 'Send SMS code'"
          - "Frontend → 2FA Service: POST /2fa/send-sms"
          - "2FA Service: Generate 6-digit code"
          - "2FA Service → Twilio: POST /Messages {to, body}"
          - "Twilio → User's phone: SMS delivered"
          - "2FA Service → Frontend: {sent: true, expires_at}"
          - "User receives SMS, enters code"
          - "Frontend → 2FA Service: POST /2fa/verify {code, method: 'sms'}"
          - "2FA Service: Validate SMS code"
          - "2FA Service → Frontend: {auth_token}"

  deployment_diagram:
    additions:
      - component: "2FA Service Pods"
        type: "kubernetes_deployment"
        replicas: "2-10"
        region: "us-east-1, eu-west-1"
      - component: "2FA PostgreSQL RDS"
        type: "managed_database"
        instance: "db.t3.small"
        multi_az: true
      - component: "TOTP Redis Elasticache"
        type: "managed_cache"
        nodes: 2
        replication: true
      - component: "2FA ALB"
        type: "load_balancer"
        health_check: "/health"

    network_connections:
      - from: "API Gateway"
        to: "2FA ALB"
        port: 443
      - from: "2FA ALB"
        to: "2FA Service Pods"
        port: 8080
      - from: "2FA Service Pods"
        to: "2FA PostgreSQL RDS"
        port: 5432
        security_group: "2fa-db-sg"
      - from: "2FA Service Pods"
        to: "TOTP Redis Elasticache"
        port: 6379
        security_group: "2fa-cache-sg"
      - from: "2FA Service Pods"
        to: "Twilio API"
        port: 443
        egress: true
        nat_gateway: "required"

    security_groups:
      new:
        - name: "2fa-service-sg"
          inbound:
            - source: "alb-sg"
              port: 8080
              protocol: "tcp"
            - source: "auth-service-sg"
              port: 9090
              protocol: "tcp (gRPC)"
          outbound:
            - destination: "2fa-db-sg"
              port: 5432
            - destination: "2fa-cache-sg"
              port: 6379
            - destination: "0.0.0.0/0"
              port: 443
              description: "Twilio API, Encryption Service"

        - name: "2fa-db-sg"
          inbound:
            - source: "2fa-service-sg"
              port: 5432

        - name: "2fa-cache-sg"
          inbound:
            - source: "2fa-service-sg"
              port: 6379

  data_flow_diagram:
    additions:
      - flow: "2FA Enrollment Data Flow"
        steps:
          - source: "User Input"
            data: "Enable 2FA request"
            destination: "Frontend"
          - source: "Frontend"
            data: "HTTP POST /2fa/enroll"
            destination: "2FA Service"
            protocol: "HTTPS"
          - source: "2FA Service"
            data: "Random 32-byte secret"
            destination: "Encryption Service"
            classification: "PII"
          - source: "Encryption Service"
            data: "Encrypted secret"
            destination: "2FA Service"
            classification: "Encrypted PII"
          - source: "2FA Service"
            data: "INSERT user_2fa_config (totp_secret_encrypted)"
            destination: "PostgreSQL"
            classification: "Encrypted PII at rest"
          - source: "2FA Service"
            data: "QR code (data URL) + recovery codes"
            destination: "Frontend"
            classification: "Sensitive (one-time display)"
          - source: "Frontend"
            data: "QR code image"
            destination: "User Display"
            classification: "Sensitive"

      - flow: "2FA Verification Data Flow"
        steps:
          - source: "User"
            data: "6-digit TOTP code"
            destination: "Frontend"
            classification: "Sensitive"
          - source: "Frontend"
            data: "HTTP POST /2fa/verify {code}"
            destination: "2FA Service"
            protocol: "HTTPS"
            classification: "Sensitive"
          - source: "2FA Service"
            data: "GET user_2fa_config WHERE user_id"
            destination: "PostgreSQL"
          - source: "PostgreSQL"
            data: "Encrypted TOTP secret"
            destination: "2FA Service"
            classification: "Encrypted PII"
          - source: "2FA Service"
            data: "Decrypt request"
            destination: "Encryption Service"
          - source: "Encryption Service"
            data: "Plaintext TOTP secret"
            destination: "2FA Service"
            classification: "PII (in memory only)"
          - source: "2FA Service"
            data: "CHECK EXISTS totp:used:{user}:{hash}"
            destination: "Redis"
          - source: "2FA Service"
            data: "HMAC-SHA1(secret, current_time)"
            destination: "In-memory validation"
            note: "RFC 6238 algorithm"
          - source: "2FA Service"
            data: "SET totp:used:{user}:{hash} TTL 90s"
            destination: "Redis"
          - source: "2FA Service"
            data: "Auth token (JWT)"
            destination: "Frontend"
            classification: "Authentication credential"

      - flow: "SMS Data Flow"
        steps:
          - source: "User"
            data: "Request SMS code"
            destination: "Frontend"
          - source: "Frontend"
            data: "POST /2fa/send-sms"
            destination: "2FA Service"
          - source: "2FA Service"
            data: "Generate random 6-digit code"
            destination: "In-memory"
          - source: "2FA Service"
            data: "Store code with TTL 10min"
            destination: "Redis"
            key_pattern: "sms:{user_id}:{code_hash}"
          - source: "2FA Service"
            data: "POST /Messages {to, body}"
            destination: "Twilio API"
            protocol: "HTTPS"
            classification: "PII (phone number)"
          - source: "Twilio"
            data: "SMS message"
            destination: "User's phone"
            classification: "OOB (out-of-band)"
          - source: "User"
            data: "6-digit SMS code"
            destination: "Frontend"
          - source: "Frontend"
            data: "POST /2fa/verify {code, method: sms}"
            destination: "2FA Service"
          - source: "2FA Service"
            data: "Validate code from Redis"
            destination: "Redis"
          - source: "2FA Service"
            data: "DELETE sms:{user_id}:{code_hash}"
            destination: "Redis"

  entity_relationship_diagram:
    new_entities:
      - entity: "User2FAConfig"
        attributes:
          - config_id: "UUID PK"
          - user_id: "UUID FK → users.user_id (UNIQUE)"
          - totp_secret: "BYTEA (encrypted)"
          - backup_phone_encrypted: "TEXT (nullable)"
          - recovery_codes_hash: "TEXT[] (size 10)"
          - recovery_codes_used: "INTEGER[] (tracks indices)"
          - enabled_at: "TIMESTAMP"
          - last_verified_at: "TIMESTAMP"
          - status: "ENUM(disabled, enabled, locked)"
        relationships:
          - type: "one-to-one"
            target: "users"
            cardinality: "1:1"
            cascade: "DELETE"

      - entity: "2FAVerificationAttempt"
        attributes:
          - attempt_id: "UUID PK"
          - user_id: "UUID FK → users.user_id"
          - method: "ENUM(totp, sms, recovery)"
          - success: "BOOLEAN"
          - ip_address: "INET"
          - user_agent: "TEXT"
          - attempted_at: "TIMESTAMP"
        relationships:
          - type: "many-to-one"
            target: "users"
            cardinality: "N:1"
        indexes:
          - columns: ["user_id", "attempted_at"]
            type: "btree"
            purpose: "Time-series queries"
          - columns: ["attempted_at"]
            type: "btree"
            purpose: "Partition pruning"
        partitioning:
          strategy: "range"
          column: "attempted_at"
          interval: "1 month"

    modified_entities:
      - entity: "users"
        added_columns:
          - name: "2fa_required"
            type: "BOOLEAN"
            default: "FALSE"
            nullable: false
            index: false
        migration:
          script: |
            BEGIN;
            ALTER TABLE users
              ADD COLUMN 2fa_required BOOLEAN DEFAULT FALSE NOT NULL;
            COMMIT;
          rollback: |
            BEGIN;
            ALTER TABLE users
              DROP COLUMN 2fa_required;
            COMMIT;
        relationships_added:
          - type: "one-to-one"
            target: "user_2fa_config"
            via: "user_id"

## INTEGRATION POINTS MAPPING

integration_mapping:
  new_integrations:
    - name: "2FA Service ↔ Encryption Service"
      type: "internal"
      protocol: "gRPC"
      direction: "bidirectional"
      operations:
        - name: "EncryptTOTPSecret"
          request: "{ user_id, plaintext_secret }"
          response: "{ encrypted_secret, key_version }"
        - name: "DecryptTOTPSecret"
          request: "{ user_id, encrypted_secret, key_version }"
          response: "{ plaintext_secret }"
      sla:
        latency_p99: "50ms"
        availability: "99.9%"
      error_handling:
        - error: "EncryptionServiceUnavailable"
          action: "Return 503, user retries"
        - error: "KeyNotFound"
          action: "Return 500, alert ops team"
      diagram_representation: "gRPC arrow from 2FA Service to Encryption Service"

    - name: "2FA Service ↔ Twilio"
      type: "external"
      protocol: "REST over HTTPS"
      direction: "outbound"
      operations:
        - name: "SendSMS"
          method: "POST"
          url: "https://api.twilio.com/2010-04-01/Accounts/{AccountSid}/Messages.json"
          request:
            To: "E.164 formatted phone"
            From: "Twilio number"
            Body: "Your verification code is: {code}"
          response: "{ sid, status, error_code? }"
      authentication:
        type: "basic_auth"
        credentials: "AccountSid:AuthToken"
        storage: "AWS Secrets Manager"
      rate_limits:
        twilio_side: "100 requests/second"
        our_budget: "66,666 SMS/month ($500)"
      error_handling:
        - error: "TwilioRateLimit (429)"
          action: "Exponential backoff, show user 'Try again in 1 minute'"
        - error: "InvalidPhoneNumber (400)"
          action: "Return error to user, suggest alternate method"
        - error: "Timeout (>5s)"
          action: "Return error, allow TOTP retry"
      circuit_breaker:
        failure_threshold: 5
        timeout_seconds: 30
        half_open_attempts: 3
      diagram_representation: "External system box, REST arrow"

    - name: "2FA Service → Event Bus"
      type: "internal"
      protocol: "AMQP"
      direction: "publish"
      events_published:
        - event: "User2FAEnabled"
          schema:
            user_id: "UUID"
            enabled_at: "ISO8601 timestamp"
            method: "totp"
          consumers: ["user-service", "email-service", "analytics-service"]

        - event: "User2FADisabled"
          schema:
            user_id: "UUID"
            disabled_at: "ISO8601 timestamp"
            reason: "user_initiated | admin_override | account_deleted"
          consumers: ["user-service", "email-service"]

        - event: "RecoveryCodeUsed"
          schema:
            user_id: "UUID"
            used_at: "ISO8601 timestamp"
            codes_remaining: "integer"
            ip_address: "string"
          consumers: ["email-service", "security-monitoring-service"]

        - event: "2FAAccountLocked"
          schema:
            user_id: "UUID"
            locked_at: "ISO8601 timestamp"
            reason: "rate_limit_exceeded"
            failed_attempts: "integer"
          consumers: ["email-service", "security-monitoring-service"]
      reliability:
        delivery_guarantee: "at-least-once"
        retry_policy: "Exponential backoff, max 10 attempts"
      diagram_representation: "Publish arrows to Event Bus (RabbitMQ)"

    - name: "Event Bus → User Service"
      type: "internal"
      protocol: "AMQP"
      direction: "subscribe"
      events_consumed:
        - event: "User2FAEnabled"
          handler: "internal/subscribers/2fa_subscriber.go:HandleUser2FAEnabled"
          action: "UPDATE users SET 2fa_required = TRUE WHERE user_id = $1"

        - event: "User2FADisabled"
          handler: "internal/subscribers/2fa_subscriber.go:HandleUser2FADisabled"
          action: "UPDATE users SET 2fa_required = FALSE WHERE user_id = $1"
      diagram_representation: "Subscribe arrows from Event Bus"

  modified_integrations:
    - name: "Frontend ↔ Auth Service"
      existing_endpoint: "POST /api/auth/login"
      modification:
        request: "No change (email, password)"
        response_old: |
          {
            "auth_token": "jwt_string"
          }
        response_new: |
          {
            "auth_token": "jwt_string (if 2FA not required)",
            "requires_2fa": boolean,
            "session_token": "partial_auth_jwt (if 2FA required)"
          }
      backwards_compatibility: "YES"
      reason: "Old clients ignore new fields, still receive auth_token when 2FA disabled"
      client_upgrade_path: "Check requires_2fa field, if true show 2FA prompt"
      diagram_change: "Annotate arrow with 'Response schema updated'"

    - name: "Auth Service ↔ User Service"
      existing_query: "SELECT user_id, email, password_hash FROM users WHERE email = $1"
      modification:
        query_new: "SELECT user_id, email, password_hash, 2fa_required FROM users WHERE email = $1"
      impact: "Minimal - adds one column to SELECT"
      diagram_change: "No visual change (same connection)"

## CHANGE SUMMARY TABLE

change_summary:
  components:
    total: 14
    new: 7
    modified: 6
    deleted: 0
    deprecated: 1

  breakdown:
    new_services: 1 # 2FA Service
    new_databases: 2 # PostgreSQL + Redis
    new_integrations: 3 # Twilio, Encryption Service, Event subscriptions
    new_infrastructure: 1 # K8s deployment, ALB

    modified_services: 4 # Auth, User, Frontend, Email
    modified_databases: 1 # Users table schema
    modified_infrastructure: 2 # API Gateway, Monitoring

    deprecated_apis: 1 # /v1/auth/login (12-month timeline)

  effort_estimation:
    development:
      2fa_service: "4 weeks (Go, TOTP library, tests)"
      auth_service_changes: "1 week"
      user_service_changes: "3 days"
      frontend_changes: "2 weeks (React components, flows)"
      email_service_changes: "2 days"
      infrastructure_setup: "1 week (K8s, RDS, Elasticache)"
      testing: "2 weeks (unit, integration, E2E, load)"
      documentation: "3 days"
      total: "8 weeks (with parallelization)"

    dependencies_critical_path:
      week_1: "Infrastructure team provisions Redis and RDS"
      week_2: "Platform team adds per-user key support to Encryption Service"
      week_3-5: "Core 2FA Service development"
      week_4-6: "Frontend and Auth Service changes (parallel)"
      week_6: "Integration testing begins"
      week_7: "Load testing and security review"
      week_8: "Internal beta launch"

  risk_areas:
    high:
      - "TOTP secret encryption key management"
      - "Twilio integration stability"
      - "User adoption rate"
    medium:
      - "Redis cache failures"
      - "Database migration on large users table"
      - "Support ticket volume"
    low:
      - "Frontend performance"
      - "API versioning"

## ARCHITECTURE DIAGRAM ANNOTATIONS

diagram_annotations:
  color_coding:
    new_components: "blue"
    modified_components: "orange"
    deprecated_components: "gray strikethrough"
    external_systems: "green"
    data_stores: "yellow"

  legend:
    - symbol: "solid_arrow"
      meaning: "synchronous call"
    - symbol: "dashed_arrow"
      meaning: "asynchronous event"
    - symbol: "thick_arrow"
      meaning: "high-volume traffic"
    - symbol: "dotted_arrow"
      meaning: "conditional/optional"
    - symbol: "padlock_icon"
      meaning: "encrypted data"
    - symbol: "lightning_icon"
      meaning: "real-time/low-latency requirement"

  component_boxes:
    2fa_service:
      label: "2FA Service (NEW)"
      color: "blue"
      annotations:
        - "TOTP validation (RFC 6238)"
        - "Recovery code management"
        - "Rate limiting"
      metrics:
        - "50 RPS target"
        - "p99 < 200ms"

    auth_service:
      label: "Auth Service (MODIFIED)"
      color: "orange"
      annotations:
        - "Added: 2FA check in login flow"
        - "Added: 2FA required middleware"
      changes_summary: "+150 LOC, +1 dependency"

    user_service:
      label: "User Service (MODIFIED)"
      color: "orange"
      annotations:
        - "Added: 2fa_required column"
        - "Subscribes: User2FAEnabled event"

    frontend:
      label: "Web Frontend (MODIFIED)"
      color: "orange"
      annotations:
        - "New: 2FA setup flow"
        - "New: 2FA login prompt"
        - "+3 React components"

    twilio:
      label: "Twilio SMS Gateway (EXTERNAL)"
      color: "green"
      annotations:
        - "REST API"
        - "SLA: 95% < 5s"
        - "Cost: $0.0075/SMS"

    event_bus:
      label: "Event Bus (RabbitMQ)"
      color: "gray"
      annotations:
        - "New topics: user.2fa.*"
      changes: "4 new event types"

  connection_annotations:
    frontend_to_2fa:
      label: "HTTPS/REST"
      note: "Enrollment & verification"
      latency: "< 500ms target"

    auth_to_2fa:
      label: "gRPC"
      note: "Check 2FA status"
      latency: "< 50ms"
      volume: "Low (1 call per login)"

    2fa_to_twilio:
      label: "HTTPS/REST"
      note: "Send SMS"
      sync: true
      timeout: "5s"
      circuit_breaker: "enabled"

    2fa_to_event_bus:
      label: "AMQP publish"
      note: "User2FA* events"
      async: true
      guarantee: "at-least-once"

## PARSELTONGUE PREPARATION

parseltongue_mapping:
  description: "Map PRD components to code generation targets"

  service_scaffolding:
    - service: "2fa-service"
      language: "Go"
      framework: "net/http + gorilla/mux"
      structure:
        - "cmd/2fa-service/main.go (entry point)"
        - "internal/handlers/ (HTTP handlers)"
        - "internal/totp/ (TOTP logic)"
        - "internal/recovery/ (recovery code logic)"
        - "internal/storage/ (database layer)"
        - "internal/cache/ (Redis layer)"
        - "internal/encryption/ (encryption client)"
        - "internal/sms/ (Twilio client)"
        - "pkg/models/ (data models)"
      dependencies:
        - "github.com/pquerna/otp (TOTP library)"
        - "github.com/go-redis/redis/v8"
        - "github.com/lib/pq (PostgreSQL driver)"
        - "google.golang.org/grpc (encryption service client)"

      key_files:
        - path: "internal/totp/validator.go"
          purpose: "TOTP validation logic (RFC 6238)"
          key_functions:
            - "GenerateSecret() (string, error)"
            - "ValidateCode(secret, code string, window int) (bool, error)"
            - "GenerateQRCode(secret, issuer, account string) (string, error)"
          requirements:
            - "FR1.1: Use crypto/rand for secret generation"
            - "FR2.1: Validate within ±1 time window"
            - "FR2.2: Prevent code reuse via Redis"

        - path: "internal/recovery/manager.go"
          purpose: "Recovery code generation and validation"
          key_functions:
            - "GenerateCodes(count int) ([]string, error)"
            - "HashCode(code string) (string, error)"
            - "ValidateCode(userID string, code string) (bool, error)"
          requirements:
            - "FR1.4: Generate 16-char alphanumeric codes"
            - "FR1.4: Bcrypt hash with cost 12"
            - "FR3.1: Mark codes as used"

        - path: "internal/handlers/enroll.go"
          purpose: "Handle 2FA enrollment endpoint"
          endpoint: "POST /api/auth/2fa/enroll"
          requirements:
            - "FR1.1-FR1.5: Complete enrollment flow"
          pseudocode: |
            func EnrollHandler(w http.ResponseWriter, r *http.Request) {
              userID := getUserFromSession(r)

              // Check if already enrolled
              if isEnrolled(userID) {
                respondError(w, 409, "2FA already enabled")
                return
              }

              // Generate secret
              secret, _ := totp.GenerateSecret()

              // Encrypt secret
              encryptedSecret, _ := encryptionClient.Encrypt(userID, secret)

              // Generate recovery codes
              codes, _ := recovery.GenerateCodes(10)
              hashedCodes := hashCodes(codes)

              // Store in database
              db.Insert(User2FAConfig{
                UserID: userID,
                TOTPSecret: encryptedSecret,
                RecoveryCodes: hashedCodes,
              })

              // Generate QR code
              qrCode, _ := totp.GenerateQRCode(secret, "YourApp", userEmail)

              respondJSON(w, 200, {
                "qr_code_data_url": qrCode,
                "secret_backup": secret,
                "recovery_codes": codes,
              })
            }

        - path: "internal/handlers/verify.go"
          purpose: "Handle 2FA verification endpoint"
          endpoint: "POST /api/auth/2fa/verify"
          requirements:
            - "FR2.1-FR2.5: Verification with rate limiting"
          pseudocode: |
            func VerifyHandler(w http.ResponseWriter, r *http.Request) {
              sessionToken := r.Header.Get("X-Session-Token")
              code := r.Body["code"]
              method := r.Body["method"] // totp, sms, recovery

              userID := getUserFromSessionToken(sessionToken)

              // Check rate limit
              if isRateLimited(userID) {
                respondError(w, 429, "Too many attempts")
                return
              }

              var valid bool
              switch method {
              case "totp":
                valid = validateTOTPCode(userID, code)
              case "sms":
                valid = validateSMSCode(userID, code)
              case "recovery":
                valid = validateRecoveryCode(userID, code)
              }

              // Log attempt
              logVerificationAttempt(userID, method, valid)

              if !valid {
                incrementFailedAttempts(userID)
                respondError(w, 401, "Invalid code")
                return
              }

              // Generate full auth token
              authToken := generateAuthToken(userID, true) // 2fa_verified=true

              respondJSON(w, 200, {"auth_token": authToken})
            }

  database_migrations:
    - migration: "20241109_create_2fa_tables.sql"
      direction: "up"
      sql: |
        CREATE TABLE user_2fa_config (
          config_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id UUID NOT NULL UNIQUE REFERENCES users(user_id) ON DELETE CASCADE,
          totp_secret BYTEA NOT NULL,
          backup_phone_encrypted TEXT,
          recovery_codes_hash TEXT[] NOT NULL,
          recovery_codes_used INTEGER[] DEFAULT '{}',
          enabled_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
          last_verified_at TIMESTAMP WITH TIME ZONE,
          status TEXT NOT NULL CHECK (status IN ('disabled', 'enabled', 'locked')) DEFAULT 'enabled',
          created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
        );

        CREATE INDEX idx_user_2fa_config_user_id ON user_2fa_config(user_id);
        CREATE INDEX idx_user_2fa_config_enabled_at ON user_2fa_config(enabled_at);

        CREATE TABLE "2fa_verification_attempt" (
          attempt_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
          method TEXT NOT NULL CHECK (method IN ('totp', 'sms', 'recovery')),
          success BOOLEAN NOT NULL,
          ip_address INET,
          user_agent TEXT,
          attempted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
        ) PARTITION BY RANGE (attempted_at);

        CREATE INDEX idx_2fa_attempt_user_time ON "2fa_verification_attempt"(user_id, attempted_at);

        -- Create initial partition for current month
        CREATE TABLE "2fa_verification_attempt_202411" PARTITION OF "2fa_verification_attempt"
        FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');

      rollback_sql: |
        DROP TABLE IF EXISTS "2fa_verification_attempt_202411";
        DROP TABLE IF EXISTS "2fa_verification_attempt";
        DROP TABLE IF EXISTS user_2fa_config;

    - migration: "20241109_add_2fa_required_column.sql"
      target: "user-service database"
      direction: "up"
      sql: |
        ALTER TABLE users
        ADD COLUMN 2fa_required BOOLEAN NOT NULL DEFAULT FALSE;

      rollback_sql: |
        ALTER TABLE users
        DROP COLUMN IF EXISTS 2fa_required;

  frontend_components:
    - component: "TwoFactorSetup.tsx"
      path: "src/components/Security/TwoFactorSetup.tsx"
      framework: "React + TypeScript"
      dependencies:
        - "qrcode.react (QR code generation)"
        - "lucide-react (icons)"
      props: |
        interface TwoFactorSetupProps {
          onComplete: () => void;
          onCancel: () => void;
        }
      state: |
        const [step, setStep] = useState<'intro' | 'qr' | 'verify' | 'recovery'>('intro');
        const [qrCodeDataUrl, setQrCodeDataUrl] = useState<string>('');
        const [recoveryCodes, setRecoveryCodes] = useState<string[]>([]);
        const [verificationCode, setVerificationCode] = useState<string>('');
      key_methods: |
        const handleEnroll = async () => {
          const response = await fetch('/api/auth/2fa/enroll', { method: 'POST' });
          const data = await response.json();
          setQrCodeDataUrl(data.qr_code_data_url);
          setRecoveryCodes(data.recovery_codes);
          setStep('qr');
        };

        const handleVerify = async () => {
          const response = await fetch('/api/auth/2fa/verify-enrollment', {
            method: 'POST',
            body: JSON.stringify({ totp_code: verificationCode }),
          });
          if (response.ok) {
            setStep('recovery');
          }
        };
      requirements:
        - "FR1.2: Display QR code"
        - "FR1.3: Verify first code"
        - "FR1.5: Allow recovery code download"

    - component: "TwoFactorPrompt.tsx"
      path: "src/components/Auth/TwoFactorPrompt.tsx"
      props: |
        interface TwoFactorPromptProps {
          sessionToken: string;
          onSuccess: (authToken: string) => void;
          onCancel: () => void;
        }
      state: |
        const [code, setCode] = useState<string>('');
        const [method, setMethod] = useState<'totp' | 'sms' | 'recovery'>('totp');
        const [error, setError] = useState<string>('');
      key_methods: |
        const handleSubmit = async () => {
          const response = await fetch('/api/auth/2fa/verify', {
            method: 'POST',
            headers: { 'X-Session-Token': sessionToken },
            body: JSON.stringify({ code, method }),
          });

          if (response.ok) {
            const { auth_token } = await response.json();
            onSuccess(auth_token);
          } else {
            setError('Invalid code. Please try again.');
          }
        };

        const handleSendSMS = async () => {
          await fetch('/api/auth/2fa/send-sms', {
            method: 'POST',
            headers: { 'X-Session-Token': sessionToken },
          });
          setMethod('sms');
        };
      requirements:
        - "FR2.1: Accept TOTP codes"
        - "FR2.3: Support SMS fallback"
        - "FR2.4: Accept recovery codes"

  api_contracts:
    - endpoint: "POST /api/auth/2fa/enroll"
      openapi_spec: |
        /api/auth/2fa/enroll:
          post:
            summary: Enroll user in 2FA
            security:
              - bearerAuth: []
            responses:
              '200':
                description: Enrollment successful
                content:
                  application/json:
                    schema:
                      type: object
                      properties:
                        qr_code_data_url:
                          type: string
                          description: Base64-encoded QR code image
                        secret_backup:
                          type: string
                          description: TOTP secret for manual entry
                        recovery_codes:
                          type: array
                          items:
                            type: string
                          minItems: 10
                          maxItems: 10
              '409':
                description: 2FA already enabled
              '500':
                description: Server error

    - endpoint: "POST /api/auth/2fa/verify"
      openapi_spec: |
        /api/auth/2fa/verify:
          post:
            summary: Verify 2FA code
            parameters:
              - in: header
                name: X-Session-Token
                required: true
                schema:
                  type: string
            requestBody:
              required: true
              content:
                application/json:
                  schema:
                    type: object
                    properties:
                      code:
                        type: string
                        pattern: '^[0-9]{6}$'
                      method:
                        type: string
                        enum: [totp, sms, recovery]
            responses:
              '200':
                description: Verification successful
                content:
                  application/json:
                    schema:
                      type: object
                      properties:
                        auth_token:
                          type: string
                          description: Full authentication JWT token
              '400':
                description: Invalid request format
              '401':
                description: Invalid code
              '429':
                description: Rate limit exceeded
                content:
                  application/json:
                    schema:
                      type: object
                      properties:
                        retry_after:
                          type: integer
                          description: Seconds until rate limit resets

  configuration_files:
    - file: "k8s/2fa-service-deployment.yaml"
      type: "kubernetes_manifest"
      content: |
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: 2fa-service
          namespace: production
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: 2fa-service
          template:
            metadata:
              labels:
                app: 2fa-service
            spec:
              containers:
              - name: 2fa-service
                image: company/2fa-service:latest
                ports:
                - containerPort: 8080
                  name: http
                - containerPort: 9090
                  name: grpc
                env:
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: 2fa-db-credentials
                      key: url
                - name: REDIS_URL
                  valueFrom:
                    configMapKeyRef:
                      name: 2fa-config
                      key: redis_url
                - name: TWILIO_ACCOUNT_SID
                  valueFrom:
                    secretKeyRef:
                      name: twilio-credentials
                      key: account_sid
                - name: TWILIO_AUTH_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: twilio-credentials
                      key: auth_token
                resources:
                  requests:
                    cpu: 250m
                    memory: 256Mi
                  limits:
                    cpu: 500m
                    memory: 512Mi
                livenessProbe:
                  httpGet:
                    path: /health/live
                    port: 8080
                  initialDelaySeconds: 10
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health/ready
                    port: 8080
                  initialDelaySeconds: 5
                  periodSeconds: 5
          ---
          apiVersion: autoscaling/v2
          kind: HorizontalPodAutoscaler
          metadata:
            name: 2fa-service-hpa
          spec:
            scaleTargetRef:
              apiVersion: apps/v1
              kind: Deployment
              name: 2fa-service
            minReplicas: 2
            maxReplicas: 10
            metrics:
            - type: Resource
              resource:
                name: cpu
                target:
                  type: Utilization
                  averageUtilization: 70

    - file: "terraform/2fa-infrastructure.tf"
      type: "terraform"
      content: |
        # PostgreSQL RDS for 2FA config
        resource "aws_db_instance" "2fa_postgres" {
          identifier           = "2fa-config-db"
          engine               = "postgres"
          engine_version       = "15.4"
          instance_class       = "db.t3.small"
          allocated_storage    = 100
          storage_encrypted    = true
          multi_az             = true
          db_name              = "2fa_config"
          username             = var.db_username
          password             = var.db_password
          vpc_security_group_ids = [aws_security_group.2fa_db_sg.id]
          db_subnet_group_name = aws_db_subnet_group.2fa_db_subnet.name
          backup_retention_period = 30
          skip_final_snapshot  = false
          final_snapshot_identifier = "2fa-db-final-snapshot"

          tags = {
            Name = "2FA Config Database"
            Service = "2fa-service"
          }
        }

        # Redis Elasticache for TOTP code tracking
        resource "aws_elasticache_replication_group" "totp_cache" {
          replication_group_id       = "totp-code-cache"
          replication_group_description = "Cache for TOTP code deduplication"
          engine                     = "redis"
          engine_version             = "7.0"
          node_type                  = "cache.t3.micro"
          number_cache_clusters      = 2
          port                       = 6379
          parameter_group_name       = "default.redis7"
          subnet_group_name          = aws_elasticache_subnet_group.totp_cache_subnet.name
          security_group_ids         = [aws_security_group.2fa_cache_sg.id]
          automatic_failover_enabled = true
          at_rest_encryption_enabled = true
          transit_encryption_enabled = true

          tags = {
            Name = "TOTP Code Cache"
            Service = "2fa-service"
          }
        }

        # Security group for 2FA service
        resource "aws_security_group" "2fa_service_sg" {
          name        = "2fa-service-sg"
          description = "Security group for 2FA service"
          vpc_id      = var.vpc_id

          ingress {
            from_port   = 8080
            to_port     = 8080
            protocol    = "tcp"
            security_groups = [aws_security_group.alb_sg.id]
          }

          ingress {
            from_port   = 9090
            to_port     = 9090
            protocol    = "tcp"
            security_groups = [aws_security_group.auth_service_sg.id]
          }

          egress {
            from_port   = 0
            to_port     = 0
            protocol    = "-1"
            cidr_blocks = ["0.0.0.0/0"]
          }
        }

  test_specifications:
    - test: "TOTP Validation Unit Test"
      file: "internal/totp/validator_test.go"
      framework: "Go testing + testify"
      test_cases: |
        func TestGenerateSecret(t *testing.T) {
          secret1, _ := GenerateSecret()
          secret2, _ := GenerateSecret()

          assert.NotEqual(t, secret1, secret2, "Secrets should be unique")
          assert.Len(t, secret1, 32, "Secret should be 32 bytes base32")
        }

        func TestValidateCode_ValidCode(t *testing.T) {
          secret := "JBSWY3DPEHPK3PXP"
          currentTime := time.Unix(1699564800, 0) // Fixed time

          code := generateTOTPCode(secret, currentTime)

          valid, _ := ValidateCode(secret, code, 1)
          assert.True(t, valid, "Valid code should pass")
        }

        func TestValidateCode_TimeWindow(t *testing.T) {
          secret := "JBSWY3DPEHPK3PXP"
          currentTime := time.Unix(1699564800, 0)

          // Generate code for t-30s
          pastCode := generateTOTPCode(secret, currentTime.Add(-30*time.Second))

          // Should be valid with window=1
          valid, _ := ValidateCodeAtTime(secret, pastCode, currentTime, 1)
          assert.True(t, valid, "Code from previous window should be valid")

          // Generate code for t-60s
          oldCode := generateTOTPCode(secret, currentTime.Add(-60*time.Second))

          // Should be invalid (outside window)
          valid, _ = ValidateCodeAtTime(secret, oldCode, currentTime, 1)
          assert.False(t, valid, "Code from t-60s should be invalid")
        }

        func TestValidateCode_CodeReuse(t *testing.T) {
          redis := setupTestRedis()
          defer redis.FlushDB()

          secret := "JBSWY3DPEHPK3PXP"
          userID := "user123"
          code := "123456"

          // First validation
          valid, _ := ValidateCodeWithCache(redis, userID, secret, code, 1)
          assert.True(t, valid)

          // Second validation (reuse)
          valid, _ = ValidateCodeWithCache(redis, userID, secret, code, 1)
          assert.False(t, valid, "Code reuse should be prevented")
        }

    - test: "2FA Enrollment E2E Test"
      file: "e2e/2fa_enrollment_test.ts"
      framework: "Cypress"
      test_cases: |
        describe('2FA Enrollment', () => {
          beforeEach(() => {
            cy.login('user@example.com', 'password123');
            cy.visit('/security');
          });

          it('should complete full enrollment flow', () => {
            // Click enable 2FA
            cy.contains('Enable Two-Factor Authentication').click();

            // Verify QR code displayed
            cy.get('[data-testid="qr-code"]').should('be.visible');
            cy.get('[data-testid="secret-backup"]').should('contain', 'Secret: ');

            // Simulate scanning QR code with authenticator
            cy.get('[data-testid="qr-code"]').invoke('attr', 'data-secret')
              .then((secret) => {
                // Generate TOTP code from secret
                const code = generateTOTPCode(secret);

                // Enter verification code
                cy.get('[data-testid="verification-code-input"]').type(code);
                cy.contains('Verify').click();
              });

            // Should show recovery codes
            cy.contains('Save Your Recovery Codes').should('be.visible');
            cy.get('[data-testid="recovery-code"]').should('have.length', 10);

            // Download recovery codes
            cy.contains('Download Codes').click();
            cy.readFile('cypress/downloads/recovery-codes.txt')
              .should('contain', 'Recovery Codes');

            // Complete setup
            cy.contains('I\'ve Saved My Codes').click();

            // Verify 2FA is enabled
            cy.contains('Two-Factor Authentication: Enabled').should('be.visible');
          });

          it('should reject invalid verification code', () => {
            cy.contains('Enable Two-Factor Authentication').click();

            cy.get('[data-testid="verification-code-input"]').type('000000');
            cy.contains('Verify').click();

            cy.contains('Invalid code').should('be.visible');
            cy.get('[data-testid="qr-code"]').should('be.visible'); // Still on same step
          });
        });

    - test: "2FA Login Integration Test"
      file: "integration/2fa_login_test.go"
      framework: "Go testing + httptest"
      test_cases: |
        func TestLogin_With2FA_Success(t *testing.T) {
          // Setup
          db := setupTestDB()
          redis := setupTestRedis()
          server := setupTestServer(db, redis)
          defer cleanupTest(db, redis, server)

          // Create user with 2FA enabled
          userID := createTestUser(db, "test@example.com", "password", true)
          secret := "JBSWY3DPEHPK3PXP"
          store2FAConfig(db, userID, secret)

          // Step 1: Login with password
          req := httptest.NewRequest("POST", "/api/auth/login",
            strings.NewReader(`{"email":"test@example.com","password":"password"}`))
          w := httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 200, w.Code)

          var loginResp map[string]interface{}
          json.Unmarshal(w.Body.Bytes(), &loginResp)

          assert.True(t, loginResp["requires_2fa"].(bool))
          sessionToken := loginResp["session_token"].(string)
          assert.NotEmpty(t, sessionToken)

          // Step 2: Verify 2FA
          code := generateTOTPCode(secret, time.Now())

          req = httptest.NewRequest("POST", "/api/auth/2fa/verify",
            strings.NewReader(fmt.Sprintf(`{"code":"%s","method":"totp"}`, code)))
          req.Header.Set("X-Session-Token", sessionToken)
          w = httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 200, w.Code)

          var verifyResp map[string]interface{}
          json.Unmarshal(w.Body.Bytes(), &verifyResp)

          authToken := verifyResp["auth_token"].(string)
          assert.NotEmpty(t, authToken)

          // Verify auth token has 2fa_verified claim
          claims := parseJWT(authToken)
          assert.True(t, claims["2fa_verified"].(bool))
        }

        func TestLogin_With2FA_RateLimit(t *testing.T) {
          // Setup
          db := setupTestDB()
          redis := setupTestRedis()
          server := setupTestServer(db, redis)
          defer cleanupTest(db, redis, server)

          userID := createTestUser(db, "test@example.com", "password", true)
          secret := "JBSWY3DPEHPK3PXP"
          store2FAConfig(db, userID, secret)

          // Get session token
          sessionToken := loginAndGetSessionToken(server, "test@example.com", "password")

          // Attempt 3 invalid verifications
          for i := 0; i < 3; i++ {
            req := httptest.NewRequest("POST", "/api/auth/2fa/verify",
              strings.NewReader(`{"code":"000000","method":"totp"}`))
            req.Header.Set("X-Session-Token", sessionToken)
            w := httptest.NewRecorder()

            server.ServeHTTP(w, req)
            assert.Equal(t, 401, w.Code)
          }

          // 4th attempt should be rate limited
          req := httptest.NewRequest("POST", "/api/auth/2fa/verify",
            strings.NewReader(`{"code":"000000","method":"totp"}`))
          req.Header.Set("X-Session-Token", sessionToken)
          w := httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 429, w.Code)

          var resp map[string]interface{}
          json.Unmarshal(w.Body.Bytes(), &resp)
          assert.Equal(t, 300, int(resp["retry_after"].(float64))) // 5 minutes
        }

    - test: "SMS Fallback Integration Test"
      file: "integration/sms_fallback_test.go"
      test_cases: |
        func TestSMSFallback_Success(t *testing.T) {
          // Setup with mocked Twilio
          mockTwilio := setupMockTwilio()
          db := setupTestDB()
          redis := setupTestRedis()
          server := setupTestServerWithTwilio(db, redis, mockTwilio)
          defer cleanupTest(db, redis, server)

          userID := createTestUser(db, "test@example.com", "password", true)
          store2FAConfig(db, userID, "secret", "+11234567890")

          sessionToken := loginAndGetSessionToken(server, "test@example.com", "password")

          // Request SMS code
          req := httptest.NewRequest("POST", "/api/auth/2fa/send-sms", nil)
          req.Header.Set("X-Session-Token", sessionToken)
          w := httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 200, w.Code)

          // Verify Twilio was called
          assert.Equal(t, 1, mockTwilio.CallCount())
          smsBody := mockTwilio.LastSMSBody()
          assert.Contains(t, smsBody, "Your verification code is:")

          // Extract code from mock Twilio
          code := extractCodeFromSMS(smsBody)

          // Verify with SMS code
          req = httptest.NewRequest("POST", "/api/auth/2fa/verify",
            strings.NewReader(fmt.Sprintf(`{"code":"%s","method":"sms"}`, code)))
          req.Header.Set("X-Session-Token", sessionToken)
          w = httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 200, w.Code)
        }

        func TestSMSFallback_TwilioFailure(t *testing.T) {
          // Setup with failing Twilio
          mockTwilio := setupFailingTwilio()
          db := setupTestDB()
          redis := setupTestRedis()
          server := setupTestServerWithTwilio(db, redis, mockTwilio)
          defer cleanupTest(db, redis, server)

          userID := createTestUser(db, "test@example.com", "password", true)
          store2FAConfig(db, userID, "secret", "+11234567890")

          sessionToken := loginAndGetSessionToken(server, "test@example.com", "password")

          // Request SMS code
          req := httptest.NewRequest("POST", "/api/auth/2fa/send-sms", nil)
          req.Header.Set("X-Session-Token", sessionToken)
          w := httptest.NewRecorder()

          server.ServeHTTP(w, req)

          assert.Equal(t, 503, w.Code)

          var resp map[string]interface{}
          json.Unmarshal(w.Body.Bytes(), &resp)
          assert.Contains(t, resp["error"].(string), "SMS unavailable")
        }

## NEXT STEPS: PARSELTONGUE INTEGRATION

parseltongue_integration_plan:
  description: "How to use this PRD structure with Parseltongue for code generation"

  workflow:
    step_1:
      name: "PRD → Architecture Diagram"
      input: "AI-native PRD (YAML structure above)"
      process: "Extract architecture.new_services, architecture.modified_services, integrations"
      output: "Mermaid/PlantUML architecture diagrams"
      tool: "Claude + artifacts (we can build this)"

    step_2:
      name: "Architecture → Code Structure"
      input: "Architecture diagram + parseltongue_mapping section"
      process: "Generate file/directory structure for each service"
      output: "Scaffold commands for Parseltongue"
      example: |
        parseltongue scaffold service \
          --name 2fa-service \
          --language go \
          --structure internal/handlers,internal/totp,internal/recovery \
          --dependencies github.com/pquerna/otp,github.com/go-redis/redis

    step_3:
      name: "PRD Requirements → Code Implementation"
      input: "Functional requirements (FR1.1, FR2.1, etc.) + pseudocode"
      process: "Parseltongue generates implementation for each requirement"
      output: "Actual Go/TypeScript/SQL files"
      example: |
        parseltongue implement requirement \
          --id FR1.1 \
          --file internal/totp/validator.go \
          --function GenerateSecret \
          --spec "Generate cryptographically secure 32-byte base32 secret using crypto/rand"

    step_4:
      name: "API Contracts → Interface Code"
      input: "OpenAPI specs from api_contracts section"
      process: "Generate HTTP handlers, request/response structs, validation"
      output: "API endpoint implementations"
      example: |
        parseltongue generate api \
          --spec api_contracts.openapi_spec \
          --output internal/handlers/ \
          --validation enabled

    step_5:
      name: "Test Specs → Test Code"
      input: "test_specifications section with test cases"
      process: "Generate unit/integration/e2e tests"
      output: "Complete test files"
      example: |
        parseltongue generate tests \
          --spec test_specifications \
          --framework go-testing \
          --output internal/totp/validator_test.go

    step_6:
      name: "Infrastructure → IaC"
      input: "deployment section + infrastructure requirements"
      process: "Generate Terraform, Kubernetes manifests, Helm charts"
      output: "Deployable infrastructure code"
      example: |
        parseltongue generate infrastructure \
          --type kubernetes \
          --service 2fa-service \
          --spec deployment.infrastructure.new_components

  parseltongue_commands:
    analyze_prd:
      description: "Parse PRD and extract architecture changes"
      command: |
        parseltongue analyze prd \
          --input 2fa_prd.yaml \
          --output analysis.json \
          --highlight-changes new,modified,deleted
      output_format: |
        {
          "new_services": ["2fa-service"],
          "modified_services": ["auth-service", "user-service", "frontend"],
          "new_databases": ["2fa_config_db", "totp_code_cache"],
          "new_integrations": ["twilio"],
          "estimated_changes": {
            "lines_of_code": 3500,
            "files": 28,
            "migrations": 2
          }
        }

    generate_diagram:
      description: "Create architecture diagram from PRD"
      command: |
        parseltongue generate diagram \
          --input 2fa_prd.yaml \
          --type component \
          --format mermaid \
          --output architecture.mmd
      output_sample: |
        graph TB
          subgraph "Application Layer"
            Frontend[Web Frontend<br/>MODIFIED]
            AuthService[Auth Service<br/>MODIFIED]
            TwoFAService[2FA Service<br/>NEW]:::new
            UserService[User Service<br/>MODIFIED]
          end

          subgraph "Data Layer"
            UsersDB[(Users DB)]
            TwoFADB[(2FA Config DB<br/>NEW)]:::new
            RedisCache[(TOTP Cache<br/>NEW)]:::new
          end

          subgraph "External"
            Twilio[Twilio SMS<br/>NEW]:::external
          end

          Frontend -->|HTTPS/REST| TwoFAService
          Frontend -->|HTTPS/REST| AuthService
          AuthService -->|gRPC| TwoFAService
          TwoFAService -->|SQL| TwoFADB
          TwoFAService -->|Redis| RedisCache
          TwoFAService -->|REST| Twilio
          AuthService -->|SQL| UsersDB
          UserService -->|SQL| UsersDB

          classDef new fill:#6366f1,stroke:#4f46e5,color:#fff
          classDef external fill:#10b981,stroke:#059669,color:#fff

    scaffold_service:
      description: "Create service structure from PRD"
      command: |
        parseltongue scaffold \
          --input 2fa_prd.yaml \
          --service 2fa-service \
          --output ./2fa-service/
      generated_structure: |
        2fa-service/
        ├── cmd/
        │   └── 2fa-service/
        │       └── main.go
        ├── internal/
        │   ├── handlers/
        │   │   ├── enroll.go
        │   │   ├── verify.go
        │   │   └── recovery.go
        │   ├── totp/
        │   │   ├── validator.go
        │   │   └── validator_test.go
        │   ├── recovery/
        │   │   ├── manager.go
        │   │   └── manager_test.go
        │   ├── storage/
        │   │   ├── postgres.go
        │   │   └── redis.go
        │   └── clients/
        │       ├── encryption.go
        │       └── twilio.go
        ├── pkg/
        │   └── models/
        │       └── 2fa.go
        ├── migrations/
        │   └── 20241109_create_2fa_tables.sql
        ├── k8s/
        │   ├── deployment.yaml
        │   └── service.yaml
        ├── go.mod
        ├── go.sum
        └── README.md

    implement_requirement:
      description: "Generate code for specific functional requirement"
      command: |
        parseltongue implement \
          --prd 2fa_prd.yaml \
          --requirement FR1.1 \
          --output internal/totp/validator.go \
          --test internal/totp/validator_test.go
      generated_code_sample: |
        // internal/totp/validator.go
        package totp

        import (
          "crypto/rand"
          "encoding/base32"
          "fmt"
        )

        // GenerateSecret generates a cryptographically secure TOTP secret.
        // Requirement: FR1.1 - System SHALL generate cryptographically secure TOTP secrets (32-byte base32)
        func GenerateSecret() (string, error) {
          // Generate 32 random bytes
          secret := make([]byte, 32)
          _, err := rand.Read(secret)
          if err != nil {
            return "", fmt.Errorf("failed to generate random bytes: %w", err)
          }

          // Encode as base32 (RFC 4648)
          encoded := base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(secret)

          return encoded, nil
        }

    generate_migration:
      description: "Create database migration from data model"
      command: |
        parseltongue generate migration \
          --prd 2fa_prd.yaml \
          --entity user_2fa_config \
          --output migrations/20241109_create_2fa_tables.sql
      generated_migration: "(See database_migrations section above)"

    generate_tests:
      description: "Create tests from test specifications"
      command: |
        parseltongue generate tests \
          --prd 2fa_prd.yaml \
          --test-type unit \
          --component totp_validator \
          --output internal/totp/validator_test.go
      generated_tests: "(See test_specifications section above)"

    deploy_infrastructure:
      description: "Generate and apply infrastructure code"
      command: |
        parseltongue deploy infrastructure \
          --prd 2fa_prd.yaml \
          --environment staging \
          --dry-run
      output: |
        [Plan] Will create:
          - AWS RDS PostgreSQL instance (db.t3.small)
          - AWS Elasticache Redis cluster (2 nodes)
          - Kubernetes Deployment (2 replicas)
          - Kubernetes Service (ClusterIP)
          - AWS ALB (Application Load Balancer)
          - Security Groups (3 new)

        Estimated cost: $120/month
        Estimated setup time: 15 minutes

        Run without --dry-run to apply.

## FINAL MAPPING SUMMARY

final_summary:
  human_prd_to_ai_prd:
    transformation: "Human prose → Structured YAML with explicit architecture signals"
    benefits:
      - "Machine-parseable for automated code generation"
      - "Architecture changes explicitly marked (NEW/MODIFIED/DELETED)"
      - "Direct mapping to code artifacts (files, functions, tables)"
      - "Test specifications embedded with requirements"
      - "Deployment and infrastructure as code"

  ai_prd_to_architecture:
    extraction_points:
      - "architecture.new_services → Component diagram boxes (blue)"
      - "architecture.modified_services → Component diagram boxes (orange)"
      - "integrations → Arrows in diagram with protocols"
      - "data_flow → Sequence diagrams"
      - "deployment.infrastructure → Deployment diagram"
    automated: "Yes, via parseltongue analyze/generate commands"

  architecture_to_code:
    mapping:
      - "Service definitions → Directory structure + scaffolding"
      - "API endpoints → HTTP handlers + request/response structs"
      - "Database schemas → SQL migrations"
      - "Data flows → Business logic implementation"
      - "Infrastructure specs → Terraform/K8s manifests"
    automated: "Partially - scaffold 100%, logic 60-80% (needs review)"

  change_detection:
    existing_architecture:
      services: ["auth-service", "user-service", "frontend", "email-service"]
      databases: ["users_db", "sessions_db"]
      integrations: ["internal event bus"]

    changes_identified:
      new:
        - "2fa-service (microservice)"
        - "2fa_config_db (PostgreSQL)"
        - "totp_code_cache (Redis)"
        - "Twilio integration (external REST)"

      modified:
        - "auth-service: +150 LOC, +1 dependency (2fa-client)"
        - "user-service: +1 column (2fa_required), +2 event subscriptions"
        - "frontend: +3 React components, +2 routes"
        - "email-service: +3 email templates"

      deleted: []

      deprecated:
        - "/v1/auth/login API (12-month sunset)"

    impact_analysis:
      high_risk:
        - "Users table schema change (1M rows)"
        - "Auth service login flow modification (critical path)"

      medium_risk:
        - "New external dependency (Twilio uptime)"
        - "Redis cache failure scenarios"

      low_risk:
        - "Frontend UI changes (isolated components)"
        - "Email template additions"

  parseltongue_integration:
    current_state: "We have comprehensive PRD structure ready"
    next_steps:
      1: "Implement parseltongue commands to parse YAML PRD"
      2: "Generate architecture diagrams automatically"
      3: "Scaffold service structures"
      4: "Implement core business logic from requirements"
      5: "Generate tests from specifications"
      6: "Create infrastructure code"

    human_review_points:
      - "After scaffolding (verify structure makes sense)"
      - "After logic generation (review algorithms, especially crypto)"
      - "After test generation (add edge cases)"
      - "Before deployment (security review)"
```

---

## Summary

We've now created:

1. **Human PRD**: Traditional format with prose, user journeys, requirements
2. **AI-Native PRD**: Structured YAML with explicit architecture mappings
3. **Architecture Change Map**: Detailed NEW/MODIFIED/DELETED analysis
4. **Parseltongue Integration Plan**: Commands and workflows for code generation

The key innovation is the `parseltongue_mapping` section which bridges PRD → Architecture → Code. Each requirement (FR1.1, FR2.1, etc.) has:

- Exact file path where code goes
- Function signatures
- Pseudocode/implementation hints
- Test specifications
- Database schemas

This allows Parseltongue to:

1. **Analyze** the PRD and detect architecture changes
2. **Generate** diagrams showing NEW (blue), MODIFIED (orange), DELETED (gray) components
3. **Scaffold** the entire codebase structure
4. **Implement** business logic from functional requirements
5. **Create** tests from specifications
6. **Deploy** infrastructure from deployment specs

---

## COMPLETE WORKFLOW DEMONSTRATION

Let me now show you the complete end-to-end workflow from PRD to running code:

```yaml
complete_workflow:
  ## PHASE 1: PRD ANALYSIS
  phase_1_analysis:
    input: "2fa_feature_prd.yaml"

    step_1_parse_prd:
      command: "parseltongue analyze prd --input 2fa_feature_prd.yaml --output analysis.json"
      output: |
        {
          "feature_id": "2FA_AUTH_001",
          "complexity_score": 7.5,
          "estimated_effort_weeks": 8,
          "architecture_impact": "medium-high",
          "changes_summary": {
            "new_components": 7,
            "modified_components": 6,
            "deleted_components": 0,
            "new_integrations": 3,
            "database_migrations": 2
          },
          "risk_score": 6.2,
          "critical_path": [
            "infrastructure_provisioning",
            "encryption_service_enhancement",
            "2fa_service_development",
            "auth_service_integration"
          ]
        }

    step_2_validate_prd:
      command: "parseltongue validate prd --input 2fa_feature_prd.yaml --strict"
      checks:
        - completeness: "All required sections present ✓"
        - consistency: "FR references match capability IDs ✓"
        - feasibility: "All dependencies available ✓"
        - testability: "All FRs have test specs ✓"
        - deployability: "Infrastructure defined ✓"
      warnings:
        - "FR2.3 SMS budget may be exceeded if adoption >80%"
        - "FR3.3 admin override requires audit compliance review"
      errors: []
      result: "PASS"

    step_3_dependency_check:
      command: "parseltongue check dependencies --prd 2fa_feature_prd.yaml --repo-url https://github.com/company/platform"
      found:
        - service: "encryption-service"
          status: "EXISTS"
          version: "v2.1.0"
          required_enhancement: "per-user key derivation"
          effort: "1 week"
        - service: "event-bus"
          status: "EXISTS"
          version: "v1.5.0"
          capability: "sufficient"
        - service: "user-service"
          status: "EXISTS"
          version: "v3.2.0"
          modification_needed: "add 2fa_required column"
      missing:
        - service: "2fa-service"
          status: "NEW"
          action: "CREATE"
      external_dependencies:
        - name: "Twilio"
          status: "REQUIRES_ACCOUNT_SETUP"
          documentation: "https://www.twilio.com/docs/sms"
          estimated_setup_time: "1 day"
      result: "Dependencies satisfied with 1 week upstream work"

  ## PHASE 2: ARCHITECTURE GENERATION
  phase_2_architecture:
    step_1_generate_system_context:
      command: "parseltongue generate diagram --type system-context --prd 2fa_feature_prd.yaml --output diagrams/system-context.mmd"
      output: |
        graph TB
          User((User))
          AuthApp[Authentication System]
          Twilio[Twilio SMS Gateway]
          AuthApp -.->|Sends SMS codes| Twilio
          Twilio -.->|Delivers SMS| User
          User -->|Scans QR code| AuthApp
          User -->|Enters TOTP code| AuthApp
          User -->|Enters recovery code| AuthApp

          style AuthApp fill:#6366f1,stroke:#4f46e5,color:#fff
          style Twilio fill:#10b981,stroke:#059669,color:#fff

    step_2_generate_component_diagram:
      command: "parseltongue generate diagram --type component --prd 2fa_feature_prd.yaml --output diagrams/components.mmd"
      output: |
        graph TB
          subgraph "Frontend Layer"
            WebApp[Web Frontend<br/><b>MODIFIED</b>]:::modified
          end

          subgraph "Application Layer"
            AuthSvc[Auth Service<br/><b>MODIFIED</b>]:::modified
            UserSvc[User Service<br/><b>MODIFIED</b>]:::modified
            TwoFASvc[2FA Service<br/><b>NEW</b>]:::new
            EmailSvc[Email Service<br/><b>MODIFIED</b>]:::modified
            EncryptSvc[Encryption Service]
          end

          subgraph "Data Layer"
            UsersDB[(Users DB<br/><b>MODIFIED</b>)]:::modified
            TwoFADB[(2FA Config DB<br/><b>NEW</b>)]:::new
            TwoFACache[(TOTP Cache<br/><b>NEW</b>)]:::new
          end

          subgraph "Integration Layer"
            EventBus[Event Bus<br/><b>MODIFIED</b>]:::modified
          end

          subgraph "External Systems"
            Twilio[Twilio<br/><b>NEW</b>]:::new
          end

          WebApp -->|REST| AuthSvc
          WebApp -->|REST| TwoFASvc
          AuthSvc -->|gRPC| TwoFASvc
          TwoFASvc -->|SQL| TwoFADB
          TwoFASvc -->|Redis| TwoFACache
          TwoFASvc -->|gRPC| EncryptSvc
          TwoFASvc -->|REST| Twilio
          TwoFASvc -->|AMQP pub| EventBus
          UserSvc -->|AMQP sub| EventBus
          EmailSvc -->|AMQP sub| EventBus
          AuthSvc -->|SQL| UsersDB
          UserSvc -->|SQL| UsersDB

          classDef new fill:#6366f1,stroke:#4f46e5,color:#fff
          classDef modified fill:#f59e0b,stroke:#d97706,color:#fff

    step_3_generate_sequence_diagrams:
      command: "parseltongue generate diagram --type sequence --flow enrollment_flow --prd 2fa_feature_prd.yaml --output diagrams/seq-enrollment.mmd"
      output: |
        sequenceDiagram
          actor User
          participant Frontend
          participant TwoFASvc as 2FA Service
          participant EncryptSvc as Encryption Service
          participant DB as 2FA Config DB
          participant EventBus

          User->>Frontend: Click "Enable 2FA"
          Frontend->>TwoFASvc: POST /api/auth/2fa/enroll
          TwoFASvc->>TwoFASvc: Generate TOTP secret
          TwoFASvc->>EncryptSvc: Encrypt(secret)
          EncryptSvc-->>TwoFASvc: encrypted_secret
          TwoFASvc->>TwoFASvc: Generate 10 recovery codes
          TwoFASvc->>DB: INSERT user_2fa_config
          DB-->>TwoFASvc: Success
          TwoFASvc->>TwoFASvc: Generate QR code
          TwoFASvc-->>Frontend: {qr_code, recovery_codes}
          Frontend->>User: Display QR code
          User->>User: Scan with authenticator app
          User->>Frontend: Enter verification code
          Frontend->>TwoFASvc: POST /api/auth/2fa/verify-enrollment
          TwoFASvc->>TwoFASvc: Validate TOTP (RFC 6238)
          alt Valid code
            TwoFASvc->>DB: UPDATE status = 'enabled'
            TwoFASvc->>EventBus: Publish User2FAEnabled
            TwoFASvc-->>Frontend: {success: true}
            Frontend->>User: Show recovery codes
          else Invalid code
            TwoFASvc-->>Frontend: {error: "Invalid code"}
            Frontend->>User: Show error, allow retry
          end

    step_4_generate_data_flow_diagram:
      command: "parseltongue generate diagram --type data-flow --prd 2fa_feature_prd.yaml --output diagrams/data-flow.mmd"
      output: |
        graph LR
          subgraph "User Input"
            UserEmail[Email/Password]
            UserTOTP[TOTP Code]
          end

          subgraph "Application Processing"
            AuthSvc[Auth Service]
            TwoFASvc[2FA Service]
            EncryptSvc[Encryption Service]
          end

          subgraph "Data Storage"
            UsersDB[(Users DB<br/>PII)]
            TwoFADB[(2FA Config DB<br/>Encrypted PII)]
            RedisCache[(Redis<br/>Ephemeral)]
          end

          UserEmail -->|HTTPS| AuthSvc
          AuthSvc -->|Query: email, 2fa_required| UsersDB
          UsersDB -->|User data| AuthSvc
          AuthSvc -->|Session token| UserTOTP
          UserTOTP -->|HTTPS| TwoFASvc
          TwoFASvc -->|Query: totp_secret_encrypted| TwoFADB
          TwoFADB -->|Encrypted secret| TwoFASvc
          TwoFASvc -->|Decrypt request| EncryptSvc
          EncryptSvc -->|Plaintext secret| TwoFASvc
          TwoFASvc -->|Check: code reuse| RedisCache
          TwoFASvc -->|Validate HMAC-SHA1| TwoFASvc
          TwoFASvc -->|SET: used code| RedisCache

          style TwoFADB fill:#fef3c7,stroke:#f59e0b
          style UsersDB fill:#fef3c7,stroke:#f59e0b
          style RedisCache fill:#dbeafe,stroke:#3b82f6

    step_5_generate_deployment_diagram:
      command: "parseltongue generate diagram --type deployment --prd 2fa_feature_prd.yaml --output diagrams/deployment.mmd"
      output: |
        graph TB
          subgraph "AWS us-east-1"
            subgraph "VPC"
              subgraph "Public Subnets"
                ALB[Application<br/>Load Balancer]
                NAT[NAT Gateway]
              end

              subgraph "Private Subnets - AZ1"
                EKS1[EKS Node 1]
                TwoFAPod1[2FA Service Pod]
                AuthPod1[Auth Service Pod]
              end

              subgraph "Private Subnets - AZ2"
                EKS2[EKS Node 2]
                TwoFAPod2[2FA Service Pod]
                AuthPod2[Auth Service Pod]
              end

              subgraph "Database Subnets"
                RDS_Primary[(RDS Primary<br/>2FA Config DB)]
                RDS_Replica[(RDS Replica)]
                Elasticache1[(Redis Primary)]
                Elasticache2[(Redis Replica)]
              end
            end
          end

          subgraph "External"
            Twilio[Twilio API]
          end

          Internet((Internet)) --> ALB
          ALB --> TwoFAPod1
          ALB --> TwoFAPod2
          ALB --> AuthPod1
          ALB --> AuthPod2

          TwoFAPod1 --> RDS_Primary
          TwoFAPod2 --> RDS_Primary
          RDS_Primary -.->|Replication| RDS_Replica

          TwoFAPod1 --> Elasticache1
          TwoFAPod2 --> Elasticache1
          Elasticache1 -.->|Replication| Elasticache2

          TwoFAPod1 --> NAT
          TwoFAPod2 --> NAT
          NAT --> Twilio

          style TwoFAPod1 fill:#6366f1,stroke:#4f46e5,color:#fff
          style TwoFAPod2 fill:#6366f1,stroke:#4f46e5,color:#fff
          style RDS_Primary fill:#fef3c7,stroke:#f59e0b
          style Twilio fill:#10b981,stroke:#059669,color:#fff

    step_6_generate_erd:
      command: "parseltongue generate diagram --type entity-relationship --prd 2fa_feature_prd.yaml --output diagrams/erd.mmd"
      output: |
        erDiagram
          users ||--o| user_2fa_config : "has"
          users ||--o{ 2fa_verification_attempt : "performs"
          user_2fa_config ||--o{ recovery_codes : "contains"

          users {
            uuid user_id PK
            string email
            string password_hash
            boolean 2fa_required "NEW COLUMN"
            timestamp created_at
          }

          user_2fa_config {
            uuid config_id PK
            uuid user_id FK "UNIQUE"
            bytea totp_secret "ENCRYPTED"
            text backup_phone_encrypted "NULLABLE"
            text_array recovery_codes_hash "SIZE 10"
            integer_array recovery_codes_used
            timestamp enabled_at
            timestamp last_verified_at
            enum status "disabled/enabled/locked"
          }

          2fa_verification_attempt {
            uuid attempt_id PK
            uuid user_id FK
            enum method "totp/sms/recovery"
            boolean success
            inet ip_address
            text user_agent
            timestamp attempted_at "PARTITION KEY"
          }

  ## PHASE 3: CODE GENERATION
  phase_3_code_generation:
    step_1_scaffold_project:
      command: "parseltongue scaffold service --prd 2fa_feature_prd.yaml --service 2fa-service --output ./2fa-service/"
      created_files: |
        Created 28 files:
        ✓ cmd/2fa-service/main.go
        ✓ internal/handlers/enroll.go
        ✓ internal/handlers/verify.go
        ✓ internal/handlers/recovery.go
        ✓ internal/handlers/sms.go
        ✓ internal/totp/validator.go
        ✓ internal/totp/validator_test.go
        ✓ internal/totp/qrcode.go
        ✓ internal/recovery/manager.go
        ✓ internal/recovery/manager_test.go
        ✓ internal/storage/postgres.go
        ✓ internal/storage/redis.go
        ✓ internal/clients/encryption_client.go
        ✓ internal/clients/twilio_client.go
        ✓ internal/middleware/auth.go
        ✓ internal/middleware/ratelimit.go
        ✓ pkg/models/2fa_config.go
        ✓ pkg/models/verification_attempt.go
        ✓ migrations/20241109_create_2fa_tables.sql
        ✓ migrations/20241109_create_2fa_tables_down.sql
        ✓ k8s/deployment.yaml
        ✓ k8s/service.yaml
        ✓ k8s/configmap.yaml
        ✓ k8s/secrets.yaml.template
        ✓ Dockerfile
        ✓ go.mod
        ✓ go.sum
        ✓ README.md

      file_preview: |
        // cmd/2fa-service/main.go
        package main

        import (
          "context"
          "log"
          "net/http"
          "os"
          "os/signal"
          "syscall"
          "time"

          "github.com/company/2fa-service/internal/handlers"
          "github.com/company/2fa-service/internal/storage"
          "github.com/gorilla/mux"
        )

        func main() {
          // Initialize dependencies
          db, err := storage.NewPostgresDB(os.Getenv("DATABASE_URL"))
          if err != nil {
            log.Fatalf("Failed to connect to database: %v", err)
          }
          defer db.Close()

          cache, err := storage.NewRedisCache(os.Getenv("REDIS_URL"))
          if err != nil {
            log.Fatalf("Failed to connect to Redis: %v", err)
          }
          defer cache.Close()

          // Setup router
          r := mux.NewRouter()

          // Health checks
          r.HandleFunc("/health/live", handlers.LivenessCheck).Methods("GET")
          r.HandleFunc("/health/ready", handlers.ReadinessCheck(db, cache)).Methods("GET")

          // 2FA endpoints
          api := r.PathPrefix("/api/auth/2fa").Subrouter()
          api.HandleFunc("/enroll", handlers.EnrollHandler(db, cache)).Methods("POST")
          api.HandleFunc("/verify-enrollment", handlers.VerifyEnrollmentHandler(db, cache)).Methods("POST")
          api.HandleFunc("/verify", handlers.VerifyHandler(db, cache)).Methods("POST")
          api.HandleFunc("/send-sms", handlers.SendSMSHandler(db, cache)).Methods("POST")

          // Start server
          srv := &http.Server{
            Addr:         ":8080",
            Handler:      r,
            ReadTimeout:  15 * time.Second,
            WriteTimeout: 15 * time.Second,
            IdleTimeout:  60 * time.Second,
          }

          // Graceful shutdown
          go func() {
            if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
              log.Fatalf("Server failed: %v", err)
            }
          }()

          log.Println("2FA Service started on :8080")

          quit := make(chan os.Signal, 1)
          signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
          <-quit

          log.Println("Shutting down server...")
          ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
          defer cancel()

          if err := srv.Shutdown(ctx); err != nil {
            log.Fatalf("Server forced to shutdown: %v", err)
          }

          log.Println("Server exited")
        }

    step_2_implement_core_logic:
      command: "parseltongue implement requirement --prd 2fa_feature_prd.yaml --requirement FR1.1 --output internal/totp/validator.go"
      generated_code: |
        // internal/totp/validator.go
        package totp

        import (
          "crypto/hmac"
          "crypto/rand"
          "crypto/sha1"
          "encoding/base32"
          "encoding/binary"
          "fmt"
          "math"
          "time"
        )

        const (
          // TimeStep is the duration of each time window (30 seconds per RFC 6238)
          TimeStep = 30
          // CodeDigits is the number of digits in generated codes
          CodeDigits = 6
        )

        // GenerateSecret generates a cryptographically secure TOTP secret.
        // Implements FR1.1: System SHALL generate cryptographically secure TOTP secrets (32-byte base32)
        func GenerateSecret() (string, error) {
          // Generate 32 random bytes using crypto/rand (cryptographically secure)
          secret := make([]byte, 32)
          if _, err := rand.Read(secret); err != nil {
            return "", fmt.Errorf("failed to generate random bytes: %w", err)
          }

          // Encode as base32 without padding (RFC 4648)
          encoded := base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(secret)

          return encoded, nil
        }

        // ValidateCode validates a TOTP code against a secret with time window tolerance.
        // Implements FR2.1: System SHALL validate TOTP codes within ±1 time window (90s tolerance)
        func ValidateCode(secret, code string, window int) (bool, error) {
          return ValidateCodeAtTime(secret, code, time.Now(), window)
        }

        // ValidateCodeAtTime validates a TOTP code at a specific time (for testing).
        func ValidateCodeAtTime(secret, code string, t time.Time, window int) (bool, error) {
          // Decode base32 secret
          secretBytes, err := base32.StdEncoding.WithPadding(base32.NoPadding).DecodeString(secret)
          if err != nil {
            return false, fmt.Errorf("invalid secret format: %w", err)
          }

          // Calculate current time counter (number of TimeSteps since Unix epoch)
          counter := uint64(t.Unix()) / TimeStep

          // Check current window and ±window range
          for i := -window; i <= window; i++ {
            testCounter := counter + uint64(i)
            expectedCode := generateTOTPCode(secretBytes, testCounter)

            // Use constant-time comparison to prevent timing attacks
            if secureCompare(code, expectedCode) {
              return true, nil
            }
          }

          return false, nil
        }

        // generateTOTPCode generates a 6-digit TOTP code using HMAC-SHA1 (RFC 6238)
        func generateTOTPCode(secret []byte, counter uint64) string {
          // Convert counter to 8-byte big-endian
          buf := make([]byte, 8)
          binary.BigEndian.PutUint64(buf, counter)

          // HMAC-SHA1 hash
          h := hmac.New(sha1.New, secret)
          h.Write(buf)
          hash := h.Sum(nil)

          // Dynamic truncation (RFC 4226 section 5.3)
          offset := hash[len(hash)-1] & 0x0f
          truncated := binary.BigEndian.Uint32(hash[offset:offset+4]) & 0x7fffffff

          // Generate 6-digit code
          code := truncated % uint32(math.Pow10(CodeDigits))

          // Format with leading zeros
          return fmt.Sprintf("%0*d", CodeDigits, code)
        }

        // secureCompare performs constant-time string comparison to prevent timing attacks.
        // Implements security requirement: "Use time-constant comparison for code validation"
        func secureCompare(a, b string) bool {
          if len(a) != len(b) {
            return false
          }

          var result byte
          for i := 0; i < len(a); i++ {
            result |= a[i] ^ b[i]
          }

          return result == 0
        }

    step_3_implement_handlers:
      command: "parseltongue implement requirement --prd 2fa_feature_prd.yaml --requirement FR1.1,FR1.2,FR1.3,FR1.4,FR1.5 --output internal/handlers/enroll.go"
      generated_code: |
        // internal/handlers/enroll.go
        package handlers

        import (
          "encoding/json"
          "net/http"

          "github.com/company/2fa-service/internal/recovery"
          "github.com/company/2fa-service/internal/storage"
          "github.com/company/2fa-service/internal/totp"
          "github.com/company/2fa-service/pkg/models"
        )

        type EnrollRequest struct {
          Method string `json:"method"` // Currently only "totp" supported
        }

        type EnrollResponse struct {
          QRCodeDataURL string   `json:"qr_code_data_url"`
          SecretBackup  string   `json:"secret_backup"`
          RecoveryCodes []string `json:"recovery_codes"`
        }

        // EnrollHandler handles 2FA enrollment requests.
        // Implements FR1.1-FR1.5: Complete enrollment flow
        func EnrollHandler(db *storage.PostgresDB, cache *storage.RedisCache) http.HandlerFunc {
          return func(w http.ResponseWriter, r *http.Request) {
            // Get user from authenticated session
            userID := getUserIDFromContext(r.Context())
            if userID == "" {
              respondError(w, http.StatusUnauthorized, "Unauthorized")
              return
            }

            // FR1.6: Check if 2FA is already enabled
            existing, err := db.Get2FAConfig(r.Context(), userID)
            if err != nil && err != storage.ErrNotFound {
              respondError(w, http.StatusInternalServerError, "Database error")
              return
            }
            if existing != nil && existing.Status == models.StatusEnabled {
              respondError(w, http.StatusConflict, "2FA already enabled")
              return
            }

            // FR1.1: Generate cryptographically secure TOTP secret
            secret, err := totp.GenerateSecret()
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to generate secret")
              return
            }

            // FR1.4: Generate 10 single-use recovery codes (16-char alphanumeric)
            recoveryCodes, err := recovery.GenerateCodes(10)
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to generate recovery codes")
              return
            }

            // Hash recovery codes with bcrypt (cost factor 12)
            hashedCodes, err := recovery.HashCodes(recoveryCodes)
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to hash recovery codes")
              return
            }

            // Encrypt TOTP secret before storage
            encryptedSecret, err := encryptSecret(userID, secret)
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to encrypt secret")
              return
            }

            // Store in database with status = 'disabled' (pending verification)
            config := &models.User2FAConfig{
              UserID:             userID,
              TOTPSecretEncrypted: encryptedSecret,
              RecoveryCodesHash:  hashedCodes,
              Status:             models.StatusDisabled,
            }

            if err := db.Create2FAConfig(r.Context(), config); err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to save configuration")
              return
            }

            // FR1.2: Generate QR code with otpauth:// URI
            userEmail, _ := getUserEmail(userID)
            qrCodeDataURL, err := totp.GenerateQRCode(secret, "YourApp", userEmail)
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to generate QR code")
              return
            }

            // FR1.5: Return QR code and recovery codes (one-time display)
            response := EnrollResponse{
              QRCodeDataURL: qrCodeDataURL,
              SecretBackup:  secret, // For manual entry if QR scan fails
              RecoveryCodes: recoveryCodes,
            }

            respondJSON(w, http.StatusOK, response)
          }
        }

        type VerifyEnrollmentRequest struct {
          TOTPCode string `json:"totp_code"`
        }

        type VerifyEnrollmentResponse struct {
          Success   bool   `json:"success"`
          EnabledAt string `json:"enabled_at,omitempty"`
        }

        // VerifyEnrollmentHandler verifies the first TOTP code before enabling 2FA.
        // Implements FR1.3: System SHALL validate first TOTP code before enabling 2FA
        func VerifyEnrollmentHandler(db *storage.PostgresDB, cache *storage.RedisCache) http.HandlerFunc {
          return func(w http.ResponseWriter, r *http.Request) {
            userID := getUserIDFromContext(r.Context())
            if userID == "" {
              respondError(w, http.StatusUnauthorized, "Unauthorized")
              return
            }

            var req VerifyEnrollmentRequest
            if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
              respondError(w, http.StatusBadRequest, "Invalid request")
              return
            }

            // Get pending 2FA config
            config, err := db.Get2FAConfig(r.Context(), userID)
            if err != nil {
              respondError(w, http.StatusNotFound, "No pending 2FA enrollment")
              return
            }

            if config.Status == models.StatusEnabled {
              respondError(w, http.StatusConflict, "2FA already enabled")
              return
            }

            // Decrypt secret
            secret, err := decryptSecret(userID, config.TOTPSecretEncrypted)
            if err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to decrypt secret")
              return
            }

            // FR1.3: Validate TOTP code within ±1 time window
            valid, err := totp.ValidateCode(secret, req.TOTPCode, 1)
            if err != nil || !valid {
              respondError(w, http.StatusUnauthorized, "Invalid verification code")
              return
            }

            // Enable 2FA (update status to 'enabled')
            if err := db.Enable2FA(r.Context(), userID); err != nil {
              respondError(w, http.StatusInternalServerError, "Failed to enable 2FA")
              return
            }

            // Publish User2FAEnabled event
            publishEvent("User2FAEnabled", map[string]interface{}{
              "user_id":    userID,
              "enabled_at": time.Now().Format(time.RFC3339),
              "method":     "totp",
            })

            response := VerifyEnrollmentResponse{
              Success:   true,
              EnabledAt: time.Now().Format(time.RFC3339),
            }

            respondJSON(w, http.StatusOK, response)
          }
        }

    step_4_generate_migrations:
      command: "parseltongue generate migration --prd 2fa_feature_prd.yaml --output migrations/"
      created_files: |
        ✓ migrations/20241109000001_create_2fa_tables_up.sql
        ✓ migrations/20241109000001_create_2fa_tables_down.sql
        ✓ migrations/20241109000002_add_2fa_required_column_up.sql
        ✓ migrations/20241109000002_add_2fa_required_column_down.sql

      migration_preview: |
        -- migrations/20241109000001_create_2fa_tables_up.sql
        BEGIN;

        -- Create 2FA configuration table
        CREATE TABLE user_2fa_config (
          config_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id UUID NOT NULL UNIQUE REFERENCES users(user_id) ON DELETE CASCADE,
          totp_secret BYTEA NOT NULL,
```
