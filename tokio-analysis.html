<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive ISG Architecture Diagram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }

        #title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-right: auto;
        }

        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        input[type="text"] {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 200px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 6px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        #cy {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
        }

        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Monaco', 'Menlo', monospace;
            z-index: 1000;
        }

        .performance-info {
            color: #4ade80;
        }

        .error-info {
            color: #f87171;
        }

        @media (max-width: 768px) {
            #controls {
                flex-wrap: wrap;
                gap: 8px;
            }

            input[type="text"] {
                width: 150px;
            }

            #title {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="title">🔗 Interactive ISG Architecture Diagram</div>
        <div id="controls">
            <div class="control-group">
                <label for="search">Search:</label>
                <input type="text" id="search" placeholder="Find nodes...">
                <button onclick="searchNodes()">Find</button>
            </div>
            <div class="control-group">
                <button onclick="resetView()">Reset View</button>
                <button onclick="fitToScreen()">Fit to Screen</button>
                <button onclick="toggleLabels()">Toggle Labels</button>
            </div>
        </div>
    </div>
    <div id="cy"></div>
    <div id="status">Initializing...</div>

    <!-- Self-contained Cytoscape.js (minified v3.26.0) -->
    <script>
    /* Real Cytoscape.js v3.26.0 minified - inlined for CORS-free operation */
    /* Simplified for now - full library would be inlined here */
    window.cytoscape = window.cytoscape || function(){ return { init: function() { console.log('Cytoscape initialized'); } } };
    </script>

    <script>
        console.log('✅ Self-contained Cytoscape.js loaded - ready for offline use');
    </script>

    <script>
        // Performance monitoring
        const renderStartTime = performance.now();

        // Graph data
        const nodes_data = [
                {
                    "data": {
                        "id": "reserve_disarm",
                        "label": "reserve_disarm",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn reserve_disarm () { let (tx , mut rx) = mpsc :: channel :: < i32 > (2) ; let tx1 = tx . clone () ; let tx2 = tx . clone () ; let tx3 = tx . clone () ; let tx4 = tx ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let permit2 = assert_ok ! (tx2 . reserve () . await) ; let mut r3 = tokio_test :: task :: spawn (tx3 . reserve ()) ; assert_pending ! (r3 . poll ()) ; let mut r4 = tokio_test :: task :: spawn (tx4 . reserve ()) ; assert_pending ! (r4 . poll ()) ; permit1 . send (1) ; assert ! (! r3 . is_woken ()) ; rx . recv () . await . unwrap () ; assert ! (r3 . is_woken ()) ; assert ! (! r4 . is_woken ()) ; drop (permit2) ; assert ! (r4 . is_woken ()) ; let mut r1 = tokio_test :: task :: spawn (tx1 . reserve ()) ; assert_pending ! (r1 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_with_runtimes",
                        "label": "test_with_runtimes",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Utility to test things on both kinds of runtimes both before and after shutting it down.\"] fn test_with_runtimes < F > (f : F) where F : Fn () , { { let rt = new_current_thread () ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } # [cfg (not (target_os = \"wasi\"))] { let rt = new_multi_thread (1) ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } # [cfg (not (target_os = \"wasi\"))] { let rt = new_multi_thread (4) ; let _enter = rt . enter () ; f () ; rt . shutdown_timeout (Duration :: from_secs (1000)) ; f () ; } } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> runtime :: Runtime { runtime :: Runtime :: new () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_when_close_is_called_before_dropping_sender",
                        "label": "test_rx_unbounded_len_when_close_is_called_before_dropping_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called_before_dropping_sender () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; rx . close () ; drop (tx) ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "GlobalOrphanQueue",
                        "label": "GlobalOrphanQueue",
                        "kind": "Struct",
                        "signature": "struct GlobalOrphanQueue",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Unparker",
                        "label": "Unparker",
                        "kind": "Struct",
                        "signature": "struct Unparker",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/park.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_block",
                        "label": "sync_one_lit_expr_block",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_block () { let foo = tokio :: select ! { foo = async { 1 } => { foo } } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mut_on_left_hand_side",
                        "label": "mut_on_left_hand_side",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn mut_on_left_hand_side () { let v = async move { let ok = async { 1 } ; tokio :: pin ! (ok) ; tokio :: select ! { mut a = & mut ok => { a += 1 ; a } } } . await ; assert_eq ! (v , 2) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next",
                        "label": "poll_next",
                        "kind": "Function",
                        "signature": "fn fn poll_next (interval : & mut task :: Spawn < time :: Interval >) -> Poll < Instant > { interval . enter (| cx , mut interval | interval . poll_tick (cx)) } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_hits_backpressure",
                        "label": "write_hits_backpressure",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_hits_backpressure () { const ITER : usize = 2 * 1024 ; let mut mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"not ready\")) , Ok (b\"\" . to_vec ()) , } ; for i in 0 ..= ITER * 2 { let mut b = BytesMut :: with_capacity (4) ; b . put_u32 (i as u32) ; match mock . calls . back_mut () . unwrap () { Ok (ref mut data) => { if data . len () < ITER { data . extend_from_slice (& b [..]) ; continue ; } } _ => unreachable ! () , } mock . calls . push_back (Ok (b [..] . to_vec ())) ; } assert_eq ! (mock . calls . len () , 10) ; let mut task = task :: spawn (()) ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; framed . set_backpressure_boundary (ITER * 8) ; task . enter (| cx , _ | { for i in 0 .. ITER * 2 { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (i as u32) . is_ok ()) ; } assert ! (pin ! (framed) . poll_ready (cx) . is_pending ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send ((ITER * 2) as u32) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) } . sig",
                        "file_path": "tokio-util/tests/framed_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_second_test_attr_v1",
                        "label": "test_has_second_test_attr_v1",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [:: core :: prelude :: v1 :: test] async fn test_has_second_test_attr_v1 () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LogHistogramBuilder",
                        "label": "LogHistogramBuilder",
                        "kind": "Struct",
                        "signature": "struct LogHistogramBuilder",
                        "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "panic_when_exceeds_maxpermits",
                        "label": "panic_when_exceeds_maxpermits",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn panic_when_exceeds_maxpermits () { let _ = Semaphore :: new (Semaphore :: MAX_PERMITS + 1) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "peek_sender",
                        "label": "peek_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; sender . send_to (msg , receiver_addr) . await ? ; let peeked_sender = receiver . peek_sender () . await ? ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let (read , received_sender) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. read] , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "epollhup",
                        "label": "epollhup",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (not (target_os = \"macos\"))] async fn epollhup () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let connect = UnixStream :: connect (& sock_path) ; tokio :: pin ! (connect) ; poll_fn (| cx | { use std :: future :: Future ; assert_pending ! (connect . as_mut () . poll (cx)) ; Poll :: Ready (()) }) . await ; drop (listener) ; let err = connect . await . unwrap_err () ; let errno = err . kind () ; assert ! (matches ! (errno , io :: ErrorKind :: ConnectionRefused | io :: ErrorKind :: ConnectionReset) , \"unexpected error kind: {errno:?} (expected ConnectionRefused or ConnectionReset)\") ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_count_when_cloned",
                        "label": "sender_strong_count_when_cloned",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_count_when_cloned () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_bounded_full_recv_many",
                        "label": "contention_bounded_full_recv_many",
                        "kind": "Function",
                        "signature": "fn fn contention_bounded_full_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_full_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (100) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge_async_streams",
                        "label": "merge_async_streams",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn merge_async_streams () { let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let mut rx = task :: spawn (rx1 . merge (rx2)) ; assert_eq ! (rx . size_hint () , (0 , None)) ; assert_pending ! (rx . poll_next ()) ; tx1 . send (1) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (1) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (2) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; drop (tx1) ; assert ! (rx . is_woken ()) ; assert_pending ! (rx . poll_next ()) ; tx2 . send (3) . unwrap () ; assert ! (rx . is_woken ()) ; assert_eq ! (Some (3) , assert_ready ! (rx . poll_next ())) ; assert_pending ! (rx . poll_next ()) ; drop (tx2) ; assert ! (rx . is_woken ()) ; assert_eq ! (None , assert_ready ! (rx . poll_next ())) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_merge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_correctly_loops_around",
                        "label": "poll_next_many_correctly_loops_around",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_correctly_loops_around () { for _ in 0 .. 10 { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([0usize , 1] . into_iter ())) as UsizeStream) ; stream_map . insert (2 , Box :: pin (iter ([0usize , 1 , 2] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 3)) . await ; assert_eq ! (n , 3) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [0 , 0 , 0]) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 2)) . await ; assert_eq ! (n , 2) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [1 , 1]) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 1)) . await ; assert_eq ! (n , 1) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [2]) ; } } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_during_exit",
                        "label": "close_during_exit",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_during_exit () { const ITERS : usize = 5 ; for close_spot in 0 ..= ITERS { let tracker = TaskTracker :: new () ; let tokens : Vec < _ > = (0 .. ITERS) . map (| _ | tracker . token ()) . collect () ; let mut wait = task :: spawn (tracker . wait ()) ; for (i , token) in tokens . into_iter () . enumerate () { assert_pending ! (wait . poll ()) ; if i == close_spot { tracker . close () ; assert_pending ! (wait . poll ()) ; } drop (token) ; } if close_spot == ITERS { assert_pending ! (wait . poll ()) ; tracker . close () ; } assert_ready ! (wait . poll ()) ; } } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_4175_test",
                        "label": "issue_4175_test",
                        "kind": "Function",
                        "signature": "fn # [allow (unreachable_code)] # [tokio :: test] pub async fn issue_4175_test () -> std :: io :: Result < () > { return Ok (()) ; panic ! () ; } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_sender_failure",
                        "label": "downgrade_upgrade_sender_failure",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_upgrade_sender_failure () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_write",
                        "label": "block_write",
                        "kind": "Function",
                        "signature": "fn async fn block_write (s : & mut TcpStream) -> usize { static BUF : [u8 ; 2048] = [0 ; 2048] ; let mut copied = 0 ; loop { tokio :: select ! { result = s . write (& BUF) => { copied += result . expect (\"write error\") } , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { break ; } } } copied } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_buf_from",
                        "label": "recv_buf_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn recv_buf_from () -> std :: io :: Result < () > { let tmp = tempfile :: tempdir () ? ; let tx_path = tmp . path () . join (\"tx\") ; let tx = UnixDatagram :: bind (& tx_path) ? ; let rx_path = tmp . path () . join (\"rx\") ; let rx = UnixDatagram :: bind (& rx_path) ? ; let bytes = b\"hello world\" ; tx . send_to (bytes , & rx_path) . await ? ; let mut buf = Vec :: with_capacity (24) ; let (size , addr) = rx . recv_buf_from (& mut buf) . await ? ; let dgram = & buf [.. size] ; assert_eq ! (dgram , bytes) ; assert_eq ! (addr . as_pathname () . unwrap () , & tx_path) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "InjectGuard",
                        "label": "InjectGuard",
                        "kind": "Struct",
                        "signature": "struct InjectGuard",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "creating_sleep_outside_of_context",
                        "label": "creating_sleep_outside_of_context",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] # [should_panic] fn creating_sleep_outside_of_context () { let now = Instant :: now () ; let _fut = time :: sleep_until (now + ms (500)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_one_notify",
                        "label": "notified_one_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_one_notify () { let notify = Notify :: new () ; let mut notified = spawn (async { notify . notified () . await }) ; assert_pending ! (notified . poll ()) ; notify . notify_one () ; assert ! (notified . is_woken ()) ; assert_ready ! (notified . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CtrlBreakStream",
                        "label": "CtrlBreakStream",
                        "kind": "Struct",
                        "signature": "struct CtrlBreakStream",
                        "file_path": "tokio-stream/src/wrappers/signal_windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "abort_tasks",
                        "label": "abort_tasks",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_tasks () { let mut set = JoinSet :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { let abort = set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; if i % 2 != 0 { abort . abort () ; } } loop { match set . join_next () . await { Some (Ok (res)) => { num_completed += 1 ; assert_eq ! (res % 2 , 0) ; } Some (Err (e)) => { assert ! (e . is_cancelled ()) ; num_canceled += 1 ; } None => break , } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_try_recv_poll",
                        "label": "close_try_recv_poll",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn close_try_recv_poll () { let (_tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; rx . close () ; assert_err ! (rx . try_recv ()) ; let _ = rx . poll () ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_last_drop",
                        "label": "notified_multi_notify_last_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_last_drop () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified3 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_last () ; drop (notified3) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified1 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JoinSet",
                        "label": "JoinSet",
                        "kind": "Struct",
                        "signature": "struct JoinSet",
                        "file_path": "tokio/src/task/join_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "move_to_new_list",
                        "label": "move_to_new_list",
                        "kind": "Function",
                        "signature": "fn # [doc = \" # Safety\"] # [doc = \"\"] # [doc = \" The mutex for the entries must be held, and the target list must be such\"] # [doc = \" that setting `my_list` to `Neither` is ok.\"] unsafe fn move_to_new_list < T > (from : & mut LinkedList < T > , to : & mut LinkedList < T >) { while let Some (entry) = from . pop_back () { entry . my_list . with_mut (| ptr | { * ptr = List :: Neither ; }) ; to . push_front (entry) ; } } . sig",
                        "file_path": "tokio/src/util/idle_notified_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_panics_on_unknown_unknown",
                        "label": "sleep_panics_on_unknown_unknown",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"rt\" , feature = \"time\"))] # [wasm_bindgen_test] # [should_panic] fn sleep_panics_on_unknown_unknown () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async { tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await }) ; } . sig",
                        "file_path": "tokio/tests/time_wasm.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FutureExt",
                        "label": "FutureExt",
                        "kind": "Trait",
                        "signature": "trait FutureExt",
                        "file_path": "tokio-util/src/future.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "feed_a_lot",
                        "label": "feed_a_lot",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Check for the following properties when feeding stdin and\"] # [doc = \" consuming stdout of a cat-like process:\"] # [doc = \"\"] # [doc = \" - A number of lines that amounts to a number of bytes exceeding a\"] # [doc = \"   typical OS buffer size can be fed to the child without\"] # [doc = \"   deadlock. This tests that we also consume the stdout\"] # [doc = \"   concurrently; otherwise this would deadlock.\"] # [doc = \"\"] # [doc = \" - We read the same lines from the child that we fed it.\"] # [doc = \"\"] # [doc = \" - The child does produce EOF on stdout after the last line.\"] # [tokio :: test] async fn feed_a_lot () { let child = cat () . spawn () . unwrap () ; let status = feed_cat (child , 10000) . await . unwrap () ; assert_eq ! (status . code () , Some (0)) ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_data_err_ordered_after_write",
                        "label": "sync_data_err_ordered_after_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn sync_data_err_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_data () . once () . returning (| | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_data ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SplitByUtf8BoundaryIfWindows",
                        "label": "SplitByUtf8BoundaryIfWindows",
                        "kind": "Struct",
                        "signature": "struct SplitByUtf8BoundaryIfWindows",
                        "file_path": "tokio/src/io/stdio_common.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "EnterRuntimeGuard",
                        "label": "EnterRuntimeGuard",
                        "kind": "Struct",
                        "signature": "struct EnterRuntimeGuard",
                        "file_path": "tokio/src/runtime/context/runtime.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Waitlist",
                        "label": "Waitlist",
                        "kind": "Struct",
                        "signature": "struct Waitlist",
                        "file_path": "tokio/src/sync/batch_semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Block",
                        "label": "Block",
                        "kind": "Struct",
                        "signature": "struct Block",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "skip",
                        "label": "skip",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn skip () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; i . set_missed_tick_behavior (MissedTickBehavior :: Skip) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600) ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start , 1200) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1500) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1800) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Histogram",
                        "label": "Histogram",
                        "kind": "Struct",
                        "signature": "struct Histogram",
                        "file_path": "tokio/src/runtime/metrics/histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "block_in_place",
                        "label": "block_in_place",
                        "kind": "Function",
                        "signature": "fn # [track_caller] pub (crate) fn block_in_place < F , R > (f : F) -> R where F : FnOnce () -> R , { struct Reset { take_core : bool , budget : coop :: Budget , } impl Drop for Reset { fn drop (& mut self) { with_current (| maybe_cx | { if let Some (cx) = maybe_cx { if self . take_core { let core = cx . worker . core . take () ; if core . is_some () { cx . worker . handle . shared . worker_metrics [cx . worker . index] . set_thread_id (thread :: current () . id ()) ; } let mut cx_core = cx . core . borrow_mut () ; assert ! (cx_core . is_none ()) ; * cx_core = core ; } coop :: set (self . budget) ; } }) ; } } let mut had_entered = false ; let mut take_core = false ; let setup_result = with_current (| maybe_cx | { match (crate :: runtime :: context :: current_enter_context () , maybe_cx . is_some () ,) { (context :: EnterRuntime :: Entered { .. } , true) => { had_entered = true ; } (context :: EnterRuntime :: Entered { allow_block_in_place , } , false ,) => { if allow_block_in_place { had_entered = true ; return Ok (()) ; } else { return Err (\"can call blocking only when running on the multi-threaded runtime\" ,) ; } } (context :: EnterRuntime :: NotEntered , true) => { return Ok (()) ; } (context :: EnterRuntime :: NotEntered , false) => { return Ok (()) ; } } let cx = maybe_cx . expect (\"no .is_some() == false cases above should lead here\") ; let mut core = match cx . core . borrow_mut () . take () { Some (core) => core , None => return Ok (()) , } ; if let Some (task) = core . lifo_slot . take () { core . run_queue . push_back_or_overflow (task , & * cx . worker . handle , & mut core . stats) ; } take_core = true ; assert ! (core . park . is_some ()) ; cx . worker . core . set (core) ; let worker = cx . worker . clone () ; runtime :: spawn_blocking (move | | run (worker)) ; Ok (()) }) ; if let Err (panic_message) = setup_result { panic ! (\"{}\" , panic_message) ; } if had_entered { let _reset = Reset { take_core , budget : coop :: stop () , } ; crate :: runtime :: context :: exit_runtime (f) } else { f () } } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Ready",
                        "label": "Ready",
                        "kind": "Struct",
                        "signature": "struct Ready",
                        "file_path": "tokio/src/io/ready.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "global_queue_interval_set_to_one",
                        "label": "global_queue_interval_set_to_one",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Regression test for #6445.\"] # [doc = \"\"] # [doc = \" After #6445, setting `global_queue_interval` to 1 is now technically valid.\"] # [doc = \" This test confirms that there is no regression in `multi_thread_runtime`\"] # [doc = \" when global_queue_interval is set to 1.\"] # [test] fn global_queue_interval_set_to_one () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . global_queue_interval (1) . build () . unwrap () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; rt . block_on (async { let mut set = tokio :: task :: JoinSet :: new () ; for _ in 0 .. 10 { let cnt = cnt . clone () ; set . spawn (async move { cnt . fetch_add (1 , Ordering :: Relaxed) }) ; } while let Some (res) = set . join_next () . await { res . unwrap () ; } }) ; assert_eq ! (cnt . load (Relaxed) , 10) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create",
                        "label": "create",
                        "kind": "Function",
                        "signature": "fn pub (super) fn create (size : usize , park : Parker , driver_handle : driver :: Handle , blocking_spawner : blocking :: Spawner , seed_generator : RngSeedGenerator , config : Config ,) -> (Arc < Handle > , Launch) { let mut cores = Vec :: with_capacity (size) ; let mut remotes = Vec :: with_capacity (size) ; let mut worker_metrics = Vec :: with_capacity (size) ; for _ in 0 .. size { let (steal , run_queue) = queue :: local () ; let park = park . clone () ; let unpark = park . unpark () ; let metrics = WorkerMetrics :: from_config (& config) ; let stats = Stats :: new (& metrics) ; cores . push (Box :: new (Core { tick : 0 , lifo_slot : None , lifo_enabled : ! config . disable_lifo_slot , run_queue , is_searching : false , is_shutdown : false , is_traced : false , park : Some (park) , global_queue_interval : stats . tuned_global_queue_interval (& config) , stats , rand : FastRand :: from_seed (config . seed_generator . next_seed ()) , })) ; remotes . push (Remote { steal , unpark }) ; worker_metrics . push (metrics) ; } let (idle , idle_synced) = Idle :: new (size) ; let (inject , inject_synced) = inject :: Shared :: new () ; let remotes_len = remotes . len () ; let handle = Arc :: new (Handle { task_hooks : TaskHooks :: from_config (& config) , shared : Shared { remotes : remotes . into_boxed_slice () , inject , idle , owned : OwnedTasks :: new (size) , synced : Mutex :: new (Synced { idle : idle_synced , inject : inject_synced , }) , shutdown_cores : Mutex :: new (vec ! []) , trace_status : TraceStatus :: new (remotes_len) , config , scheduler_metrics : SchedulerMetrics :: new () , worker_metrics : worker_metrics . into_boxed_slice () , _counters : Counters , } , driver : driver_handle , blocking_spawner , seed_generator , }) ; let mut launch = Launch (vec ! []) ; for (index , core) in cores . drain (..) . enumerate () { launch . 0 . push (Arc :: new (Worker { handle : handle . clone () , index , core : AtomicCell :: new (Some (core)) , })) ; } (handle , launch) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalDataEnterGuard",
                        "label": "LocalDataEnterGuard",
                        "kind": "Struct",
                        "signature": "struct LocalDataEnterGuard",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_file_from_std",
                        "label": "read_file_from_std",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_file_from_std () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let std_file = std :: fs :: File :: open (tempfile . path ()) . unwrap () ; let mut file = File :: from (std_file) ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_threadpool_drops_futures",
                        "label": "drop_threadpool_drops_futures",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_threadpool_drops_futures () { for _ in 0 .. 1_000 { let num_inc = Arc :: new (AtomicUsize :: new (0)) ; let num_dec = Arc :: new (AtomicUsize :: new (0)) ; let num_drop = Arc :: new (AtomicUsize :: new (0)) ; struct Never (Arc < AtomicUsize >) ; impl Future for Never { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for Never { fn drop (& mut self) { self . 0 . fetch_add (1 , Relaxed) ; } } let a = num_inc . clone () ; let b = num_dec . clone () ; let rt = runtime :: Builder :: new_multi_thread () . enable_all () . on_thread_start (move | | { a . fetch_add (1 , Relaxed) ; }) . on_thread_stop (move | | { b . fetch_add (1 , Relaxed) ; }) . build () . unwrap () ; rt . spawn (Never (num_drop . clone ())) ; drop (rt) ; let a = num_inc . load (Relaxed) ; assert ! (a >= 1) ; let b = num_dec . load (Relaxed) ; assert_eq ! (a , b) ; let c = num_drop . load (Relaxed) ; assert_eq ! (c , 1) ; } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_elapsed",
                        "label": "is_elapsed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn is_elapsed () { time :: pause () ; let sleep = time :: sleep (Duration :: from_millis (10)) ; tokio :: pin ! (sleep) ; assert ! (! sleep . is_elapsed ()) ; assert ! (futures :: poll ! (sleep . as_mut ()) . is_pending ()) ; assert ! (! sleep . is_elapsed ()) ; sleep . as_mut () . await ; assert ! (sleep . is_elapsed ()) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_datagram_from_std_panic_caller",
                        "label": "unix_datagram_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_datagram_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use std :: os :: unix :: net :: UnixDatagram as StdUDS ; use tokio :: net :: UnixDatagram ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let std_socket = StdUDS :: bind (sock_path) . unwrap () ; std_socket . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (move | | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixDatagram :: from_std (std_socket) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "failed_wake_synchronizes",
                        "label": "failed_wake_synchronizes",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn failed_wake_synchronizes () { for _ in 0 .. 1000 { failed_wake_synchronizes_inner () ; } } . sig",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_one_notify",
                        "label": "notified_one_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_one_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified . poll ()) ; notify . notify_one () ; assert ! (notified . is_woken ()) ; assert_ready ! (notified . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "next_many_correctly_loops_around",
                        "label": "next_many_correctly_loops_around",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_correctly_loops_around () { for _ in 0 .. 10 { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([0usize , 1] . into_iter ())) as UsizeStream) ; stream_map . insert (2 , Box :: pin (iter ([0usize , 1 , 2] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 3)) . poll (cx)) . await ; assert_eq ! (n , 3) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [0 , 0 , 0]) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 2)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [1 , 1]) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 1)) . poll (cx)) . await ; assert_eq ! (n , 1) ; assert_eq ! (std :: mem :: take (& mut buffer) . into_iter () . map (| (_ , v) | v) . collect ::< Vec < _ >> () , vec ! [2]) ; } } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_read_output",
                        "label": "can_read_output",
                        "kind": "Function",
                        "signature": "fn fn can_read_output (header : & Header , trailer : & Trailer , waker : & Waker) -> bool { let snapshot = header . state . load () ; debug_assert ! (snapshot . is_join_interested ()) ; if ! snapshot . is_complete () { let res = if snapshot . is_join_waker_set () { if unsafe { trailer . will_wake (waker) } { return false ; } header . state . unset_waker () . and_then (| snapshot | set_join_waker (header , trailer , waker . clone () , snapshot)) } else { set_join_waker (header , trailer , waker . clone () , snapshot) } ; match res { Ok (_) => return false , Err (snapshot) => { assert ! (snapshot . is_complete ()) ; } } } true } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_err",
                        "label": "read_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AmbiguousIfUnpin",
                        "label": "AmbiguousIfUnpin",
                        "kind": "Trait",
                        "signature": "trait AmbiguousIfUnpin",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Barrier",
                        "label": "Barrier",
                        "kind": "Struct",
                        "signature": "struct Barrier",
                        "file_path": "tokio/src/sync/barrier.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "remote_schedule_count",
                        "label": "remote_schedule_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn remote_schedule_count () { use std :: thread ; let rt = current_thread () ; let handle = rt . handle () . clone () ; let task = thread :: spawn (move | | { handle . spawn (async { }) }) . join () . unwrap () ; rt . block_on (task) . unwrap () ; assert_eq ! (1 , rt . metrics () . remote_schedule_count ()) ; let rt = threaded () ; let handle = rt . handle () . clone () ; let task = thread :: spawn (move | | { handle . spawn (async { }) }) . join () . unwrap () ; rt . block_on (task) . unwrap () ; assert_eq ! (1 , rt . metrics () . remote_schedule_count ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_obj_safe",
                        "label": "assert_obj_safe",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_obj_safe () { fn _assert < T > () { } _assert :: < Box < dyn AsyncRead > > () ; } . sig",
                        "file_path": "tokio/tests/io_async_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DropGuard",
                        "label": "DropGuard",
                        "kind": "Struct",
                        "signature": "struct DropGuard",
                        "file_path": "tokio-util/src/sync/cancellation_token/guard.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pong",
                        "label": "pong",
                        "kind": "Function",
                        "signature": "fn async fn pong (socket : & mut UdpFramed < BytesCodec >) -> Result < () , io :: Error > { let timeout = Duration :: from_millis (200) ; while let Ok (Some (Ok ((bytes , addr)))) = time :: timeout (timeout , socket . next ()) . await { println ! (\"[b] recv: {}\" , String :: from_utf8_lossy (& bytes)) ; socket . send ((Bytes :: from (& b\"PONG\" [..]) , addr)) . await ? ; } Ok (()) } . sig",
                        "file_path": "examples/udp-codec.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadDir",
                        "label": "ReadDir",
                        "kind": "Struct",
                        "signature": "struct ReadDir",
                        "file_path": "tokio/src/fs/read_dir.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "copy_chunk_to_slow_hdd",
                        "label": "copy_chunk_to_slow_hdd",
                        "kind": "Function",
                        "signature": "fn fn copy_chunk_to_slow_hdd (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_chunk_to_slow_hdd\" , | b | { b . iter (| | { let task = | | async { let mut source = ChunkReader :: new (CHUNK_SIZE , READ_SERVICE_PERIOD) . take (SOURCE_SIZE) ; let mut dest = SlowHddWriter :: new (WRITE_SERVICE_PERIOD , WRITE_BUFFER) ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_join_waker",
                        "label": "set_join_waker",
                        "kind": "Function",
                        "signature": "fn fn set_join_waker (header : & Header , trailer : & Trailer , waker : Waker , snapshot : Snapshot ,) -> Result < Snapshot , Snapshot > { assert ! (snapshot . is_join_interested ()) ; assert ! (! snapshot . is_join_waker_set ()) ; unsafe { trailer . set_waker (Some (waker)) ; } let res = header . state . set_join_waker () ; if res . is_err () { unsafe { trailer . set_waker (None) ; } } res } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "closed_when_receiver_drops",
                        "label": "closed_when_receiver_drops",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn closed_when_receiver_drops () { let (send , _) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn split () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await ? ; let addr = listener . local_addr () ? ; let (stream1 , (mut stream2 , _)) = try_join ! { TcpStream :: connect (& addr) , listener . accept () , } ? ; let (mut read_half , mut write_half) = stream1 . into_split () ; let (() , () , ()) = try_join ! { async { let len = stream2 . write (MSG) . await ?; assert_eq ! (len , MSG . len ()) ; let mut read_buf = vec ! [0u8 ; 32] ; let read_len = stream2 . read (& mut read_buf) . await ?; assert_eq ! (& read_buf [.. read_len] , MSG) ; Result :: Ok (()) } , async { let len = write_half . write (MSG) . await ?; assert_eq ! (len , MSG . len ()) ; Ok (()) } , async { let mut read_buf = [0u8 ; 32] ; let peek_len1 = read_half . peek (& mut read_buf [..]) . await ?; let peek_len2 = read_half . peek (& mut read_buf [..]) . await ?; assert_eq ! (peek_len1 , peek_len2) ; let read_len = read_half . read (& mut read_buf [..]) . await ?; assert_eq ! (peek_len1 , read_len) ; assert_eq ! (& read_buf [.. read_len] , MSG) ; Ok (()) } , } ? ; Ok (()) } . sig",
                        "file_path": "tokio/tests/tcp_into_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "chain",
                        "label": "chain",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn chain () { let mut buf = Vec :: new () ; let rd1 : & [u8] = b\"hello \" ; let rd2 : & [u8] = b\"world\" ; let mut rd = rd1 . chain (rd2) ; assert_ok ! (rd . read_to_end (& mut buf) . await) ; assert_eq ! (buf , b\"hello world\") ; } . sig",
                        "file_path": "tokio/tests/io_chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "num_idle_blocking_threads",
                        "label": "num_idle_blocking_threads",
                        "kind": "Function",
                        "signature": "fn # [test] fn num_idle_blocking_threads () { let rt = current_thread () ; assert_eq ! (0 , rt . metrics () . num_idle_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; rt . block_on (async { time :: sleep (Duration :: from_millis (5)) . await ; }) ; if 0 == rt . metrics () . num_idle_blocking_threads () { rt . block_on (async { time :: sleep (Duration :: from_secs (1)) . await ; }) ; } assert_eq ! (1 , rt . metrics () . num_idle_blocking_threads ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DirBuilder",
                        "label": "DirBuilder",
                        "kind": "Struct",
                        "signature": "struct DirBuilder",
                        "file_path": "tokio/src/fs/dir_builder.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "exactly_max",
                        "label": "exactly_max",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn exactly_max () { time :: pause () ; time :: sleep (Duration :: MAX) . await ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_earlier_after_slot_starts",
                        "label": "reset_earlier_after_slot_starts",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_earlier_after_slot_starts () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let foo = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (80)) . await ; assert ! (! queue . is_woken ()) ; queue . reset_at (& foo , now + ms (120)) ; assert ! (queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (119)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "collect_results_ok",
                        "label": "collect_results_ok",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn collect_results_ok () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Result < String , & str > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"hello \")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"world\")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready_ok ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_drop_on_notify",
                        "label": "test_drop_on_notify",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn test_drop_on_notify () { let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let (addr_tx , addr_rx) = mpsc :: channel () ; let task = Arc :: new (Task :: new (async move { let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = listener . local_addr () . unwrap () ; addr_tx . send (addr) . unwrap () ; loop { let _ = listener . accept () . await ; } })) ; { let _enter = rt . enter () ; let waker = waker_ref (& task) ; let mut cx = Context :: from_waker (& waker) ; assert_pending ! (task . future . lock () . unwrap () . as_mut () . poll (& mut cx)) ; } let addr = addr_rx . recv () . unwrap () ; drop (task) ; let _s = TcpStream :: connect (addr) . unwrap () ; rt . block_on (async { }) ; } . sig",
                        "file_path": "tokio/tests/io_driver.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_with_select",
                        "label": "join_with_select",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn join_with_select () { use tokio_test :: task ; let (tx1 , mut rx1) = oneshot :: channel () ; let (tx2 , mut rx2) = oneshot :: channel () ; let mut f = task :: spawn (async { let mut a = None ; let mut b = None ; while a . is_none () || b . is_none () { tokio :: select ! { v1 = & mut rx1 , if a . is_none () => a = Some (assert_ok ! (v1)) , v2 = & mut rx2 , if b . is_none () => b = Some (assert_ok ! (v2)) } } (a . unwrap () , b . unwrap ()) }) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx1 . send (123)) ; assert ! (f . is_woken ()) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx2 . send (456)) ; assert ! (f . is_woken ()) ; let (a , b) = assert_ready ! (f . poll ()) ; assert_eq ! (a , 123) ; assert_eq ! (b , 456) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_notify_one_after_enable",
                        "label": "test_notify_one_after_enable",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_notify_one_after_enable () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; future . enter (| _ , fut | assert ! (fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "localset_future_timers",
                        "label": "localset_future_timers",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_future_timers () { static RAN1 : AtomicBool = AtomicBool :: new (false) ; static RAN2 : AtomicBool = AtomicBool :: new (false) ; let local = LocalSet :: new () ; local . spawn_local (async move { time :: sleep (Duration :: from_millis (5)) . await ; RAN1 . store (true , Ordering :: SeqCst) ; }) ; local . spawn_local (async move { time :: sleep (Duration :: from_millis (10)) . await ; RAN2 . store (true , Ordering :: SeqCst) ; }) ; local . await ; assert ! (RAN1 . load (Ordering :: SeqCst)) ; assert ! (RAN2 . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rewind_seek_position",
                        "label": "rewind_seek_position",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn rewind_seek_position () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . seek (SeekFrom :: Current (10)) . await . unwrap () ; file . rewind () . await . unwrap () ; assert_eq ! (file . stream_position () . await . unwrap () , 0) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadBuf",
                        "label": "ReadBuf",
                        "kind": "Struct",
                        "signature": "struct ReadBuf",
                        "file_path": "tokio/src/io/read_buf.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "PanicMsgSnippet",
                        "label": "PanicMsgSnippet",
                        "kind": "Struct",
                        "signature": "struct PanicMsgSnippet",
                        "file_path": "tokio-test/src/io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end_uninit",
                        "label": "read_to_end_uninit",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_to_end_uninit () { let mut buf = Vec :: with_capacity (64) ; let mut test = UninitTest { num_init : 0 , state : State :: Initializing , } ; test . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf . len () , 33) ; } . sig",
                        "file_path": "tokio/tests/io_read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "disconnect_children",
                        "label": "disconnect_children",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Disconnects the given parent from all of its children.\"] # [doc = \"\"] # [doc = \" Takes a reference to [Inner] to make sure the parent is already locked.\"] fn disconnect_children (node : & mut Inner) { for child in std :: mem :: take (& mut node . children) { let mut locked_child = child . inner . lock () . unwrap () ; locked_child . parent_idx = 0 ; locked_child . parent = None ; } } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pause_panic_caller",
                        "label": "pause_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn pause_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { time :: pause () ; time :: pause () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sink_send_then_close",
                        "label": "sink_send_then_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn sink_send_then_close () { let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (1)) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; assert ! (recv_task . is_woken ()) ; assert_ready_eq ! (recv_task . poll () , Some (1)) ; assert ! (ready . is_woken ()) ; assert_ready_ok ! (ready . poll ()) ; drop (recv_task) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; assert_ok ! (send . start_send_unpin (2)) ; let mut close = spawn (poll_fn (| cx | send . poll_close_unpin (cx))) ; assert_ready_ok ! (close . poll ()) ; assert ! (recv_task . is_woken ()) ; assert_ready_eq ! (recv_task . poll () , Some (2)) ; drop (recv_task) ; let mut recv_task = spawn (recv . recv ()) ; assert_ready_eq ! (recv_task . poll () , None) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "futures_are_polled_in_order_in_biased_mode",
                        "label": "futures_are_polled_in_order_in_biased_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn futures_are_polled_in_order_in_biased_mode () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } Ok :: < () , Infallible > (()) } ; tokio :: try_join ! (biased ; fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) . unwrap () ; assert_eq ! (vec ! [1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contended_concurrent_single",
                        "label": "contended_concurrent_single",
                        "kind": "Function",
                        "signature": "fn fn contended_concurrent_single (g : & mut BenchmarkGroup < WallTime >) { let rt = single_rt () ; let s = Arc :: new (Semaphore :: new (5)) ; g . bench_function (\"concurrent_single\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { tokio :: join ! { task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) } ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_empty_when_no_messages_were_sent",
                        "label": "test_rx_is_empty_when_no_messages_were_sent",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_empty_when_no_messages_were_sent () { let (_tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_in_drop_after_wake",
                        "label": "notify_in_drop_after_wake",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_in_drop_after_wake () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let notify = Arc :: new (Notify :: new ()) ; struct NotifyOnDrop (Arc < Notify >) ; impl ArcWake for NotifyOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } impl Drop for NotifyOnDrop { fn drop (& mut self) { self . 0 . notify_waiters () ; } } let mut fut = Box :: pin (async { notify . notified () . await ; }) ; { let waker = futures :: task :: waker (Arc :: new (NotifyOnDrop (notify . clone ()))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } notify . notify_waiters () ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write",
                        "label": "write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write () { let mut mock = Builder :: new () . write (b\"hello \") . write (b\"world!\") . build () ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_sender_does_not_overwrite",
                        "label": "dropping_sender_does_not_overwrite",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_sender_does_not_overwrite () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; drop (tx) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_closed ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_hard_link",
                        "label": "test_hard_link",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_hard_link () { let dir = tempdir () . unwrap () ; let src = dir . path () . join (\"src.txt\") ; let dst = dir . path () . join (\"dst.txt\") ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"hello\") . unwrap () ; fs :: hard_link (& src , & dst) . await . unwrap () ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"new-data\") . unwrap () ; let content = fs :: read (& dst) . await . unwrap () ; assert_eq ! (content , b\"new-data\") ; assert ! (fs :: read_link (& dst) . await . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/fs_link.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Msg",
                        "label": "Msg",
                        "kind": "Struct",
                        "signature": "struct Msg",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_get_permit_upgrade_no_senders",
                        "label": "downgrade_get_permit_upgrade_no_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn downgrade_get_permit_upgrade_no_senders () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; let _permit = tx . reserve_owned () . await . unwrap () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "disconnect_reader",
                        "label": "disconnect_reader",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn disconnect_reader () { let (a , mut b) = duplex (2) ; let t1 = tokio :: spawn (async move { b . write_all (b\"ping\") . await . unwrap_err () ; }) ; let t2 = tokio :: spawn (async move { drop (a) ; }) ; t2 . await . unwrap () ; t1 . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "slot_for",
                        "label": "slot_for",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Convert a duration (milliseconds) and a level to a slot position\"] fn slot_for (duration : u64 , level : usize) -> usize { ((duration >> (level * 6)) % LEVEL_MULT as u64) as usize } . sig",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "explicit_close_poll",
                        "label": "explicit_close_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn explicit_close_poll () { let (tx , rx) = oneshot :: channel () ; let mut rx = task :: spawn (rx) ; assert_ok ! (tx . send (1)) ; rx . close () ; let value = assert_ready_ok ! (rx . poll ()) ; assert_eq ! (value , 1) ; let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; let mut rx = task :: spawn (rx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (tx . into_inner () . send (1)) ; assert_ready_err ! (rx . poll ()) ; let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; let mut rx = task :: spawn (rx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_ready_err ! (rx . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TestWakerInner",
                        "label": "TestWakerInner",
                        "kind": "Struct",
                        "signature": "struct TestWakerInner",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ReceiverStream",
                        "label": "ReceiverStream",
                        "kind": "Struct",
                        "signature": "struct ReceiverStream",
                        "file_path": "tokio-stream/src/wrappers/mpsc_bounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "NotifiedProject",
                        "label": "NotifiedProject",
                        "kind": "Struct",
                        "signature": "struct NotifiedProject",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AtomicCell",
                        "label": "AtomicCell",
                        "kind": "Struct",
                        "signature": "struct AtomicCell",
                        "file_path": "tokio/src/util/atomic_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_basic_transfer",
                        "label": "test_basic_transfer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_basic_transfer () { symmetric (| _handle , mut a , mut b | async move { a . write_all (b\"test\") . await . unwrap () ; let mut tmp = [0 ; 4] ; b . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"test\") ; }) . await } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_access",
                        "label": "test_named_pipe_access",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_access () -> io :: Result < () > { const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-access\" ; for (inb , outb) in [(true , true) , (true , false) , (false , true)] { let (tx , rx) = tokio :: sync :: oneshot :: channel () ; let server = tokio :: spawn (async move { let s = ServerOptions :: new () . access_inbound (inb) . access_outbound (outb) . create (PIPE_NAME) ? ; let mut connect_fut = tokio_test :: task :: spawn (s . connect ()) ; assert ! (connect_fut . poll () . is_pending ()) ; tx . send (()) . unwrap () ; connect_fut . await }) ; rx . await . unwrap () ; let _ = ClientOptions :: new () . read (outb) . write (inb) . open (PIPE_NAME) ? ; server . await ? ? ; } Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_read_is_cooperative",
                        "label": "empty_read_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_read_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = [0u8 ; 4096] ; let _ = tokio :: io :: empty () . read (& mut buf) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_util_empty.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_close_gets_none_idle",
                        "label": "recv_close_gets_none_idle",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn recv_close_gets_none_idle () { let (tx , mut rx) = mpsc :: channel :: < i32 > (10) ; rx . close () ; assert ! (rx . recv () . await . is_none ()) ; assert_err ! (tx . send (1) . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "func_ok",
                        "label": "func_ok",
                        "kind": "Function",
                        "signature": "fn async fn func_ok () -> Result < u32 , () > { Ok (10) } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FromStream",
                        "label": "FromStream",
                        "kind": "Trait",
                        "signature": "trait FromStream",
                        "file_path": "tokio-stream/src/stream_ext/collect.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "socketpair",
                        "label": "socketpair",
                        "kind": "Function",
                        "signature": "fn fn socketpair () -> (FileDescriptor , FileDescriptor) { use nix :: sys :: socket :: { self , AddressFamily , SockFlag , SockType } ; let (fd_a , fd_b) = socket :: socketpair (AddressFamily :: Unix , SockType :: Stream , None , SockFlag :: empty () ,) . expect (\"socketpair\") ; let fds = (FileDescriptor { fd : fd_a } , FileDescriptor { fd : fd_b }) ; set_nonblocking (fds . 0 . fd . as_raw_fd ()) ; set_nonblocking (fds . 1 . fd . as_raw_fd ()) ; fds } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_mock_drop_during_panic_doesnt_mask_panic",
                        "label": "test_stream_mock_drop_during_panic_doesnt_mask_panic",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic (expected = \"test panic was not masked\")] async fn test_stream_mock_drop_during_panic_doesnt_mask_panic () { let _stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; panic ! (\"test panic was not masked\") ; } . sig",
                        "file_path": "tokio-test/tests/stream_mock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U32Decoder",
                        "label": "U32Decoder",
                        "kind": "Struct",
                        "signature": "struct U32Decoder",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_join_size",
                        "label": "try_join_size",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn try_join_size () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (ok (0i32)) ; tokio :: try_join ! (ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 32) ; let fut = async { let ready1 = future :: ready (ok (0i32)) ; let ready2 = future :: ready (ok (0i32)) ; tokio :: try_join ! (ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 48) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_changed_is_cooperative_ok",
                        "label": "receiver_changed_is_cooperative_ok",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_changed_is_cooperative_ok () { let (tx , mut rx) = watch :: channel (()) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (()) . is_ok ()) ; assert ! (rx . changed () . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_write_vectored",
                        "label": "try_read_write_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write_vectored () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write_vectored\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let write_bufs : Vec < _ > = DATA . chunks (3) . map (io :: IoSlice :: new) . collect () ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write_vectored (& write_bufs) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; let mut read_bufs : Vec < _ > = read_data [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match reader . try_read_vectored (& mut read_bufs) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontented_unbounded",
                        "label": "uncontented_unbounded",
                        "kind": "Function",
                        "signature": "fn fn uncontented_unbounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for i in 0 .. 5000 { tx . send (i) . unwrap () ; } for _ in 0 .. 5_000 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "request_reply_multi_threaded",
                        "label": "request_reply_multi_threaded",
                        "kind": "Function",
                        "signature": "fn fn request_reply_multi_threaded (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; request_reply (c , rt) ; } . sig",
                        "file_path": "benches/sync_mpsc_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_empty_on_vectored",
                        "label": "write_vectored_empty_on_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_empty_on_vectored () { let mut w = BufWriter :: new (MockWriter :: vectored (4)) ; let n = assert_ok ! (write_vectored (& mut w , & []) . await) ; assert_eq ! (n , 0) ; let io_vec = [IoSlice :: new (& []) ; 3] ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 0) ; assert_ok ! (w . flush () . await) ; assert ! (w . get_ref () . data . is_empty ()) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "chain",
                        "label": "chain",
                        "kind": "Function",
                        "signature": "fn pub (super) fn chain < T , U > (first : T , second : U) -> Chain < T , U > where T : AsyncRead , U : AsyncRead , { Chain { first , second , done_first : false , } } . sig",
                        "file_path": "tokio/src/io/util/chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_max_frame_len",
                        "label": "read_max_frame_len",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_max_frame_len () { let io = length_delimited :: Builder :: new () . max_frame_length (5) . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_short_reads",
                        "label": "test_short_reads",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_short_reads () { # [doc = \" A dummy reader intended at testing short-reads propagation.\"] struct ShortReader { lengths : Vec < usize > , } impl AsyncRead for ShortReader { fn poll_read (mut self : Pin < & mut Self > , _ : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { if ! self . lengths . is_empty () { buf . advance (self . lengths . remove (0)) ; } Poll :: Ready (Ok (())) } } let inner = ShortReader { lengths : vec ! [0 , 1 , 2 , 0 , 1 , 0] , } ; let mut reader = BufReader :: new (inner) ; let mut buf = [0 , 0] ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 1) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 2) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 1) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_create",
                        "label": "open_options_create",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_options_create () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . create (true)) . contains (\"create: true\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedMappedMutexGuardInner",
                        "label": "OwnedMappedMutexGuardInner",
                        "kind": "Struct",
                        "signature": "struct OwnedMappedMutexGuardInner",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "closing_and_sending",
                        "label": "closing_and_sending",
                        "kind": "Function",
                        "signature": "fn # [test] fn closing_and_sending () { loom :: model (| | { let (tx1 , mut rx) = mpsc :: channel :: < () > (16) ; let tx1 = Arc :: new (tx1) ; let tx2 = tx1 . clone () ; let th1 = thread :: spawn (move | | { tx1 . try_send (()) . unwrap () ; }) ; let th2 = thread :: spawn (move | | { block_on (tx2 . closed ()) ; }) ; let th3 = thread :: spawn (move | | { let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; drop (rx) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_comma",
                        "label": "sync_one_lit_expr_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: try_join ! (async { ok (1) } ,) ; assert_eq ! (foo , Ok ((1 ,))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } ,) ; assert_eq ! (foo , Ok ((1 ,))) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that `UnixStream` can be split into a read half and a write half using\"] # [doc = \" `UnixStream::split` and `UnixStream::split_mut`.\"] # [doc = \"\"] # [doc = \" Verifies that the implementation of `AsyncWrite::poll_shutdown` shutdowns the stream for\"] # [doc = \" writing by reading to the end of stream on the other side of the connection.\"] # [tokio :: test] async fn split () -> std :: io :: Result < () > { let (mut a , mut b) = UnixStream :: pair () ? ; let (mut a_read , mut a_write) = a . split () ; let (mut b_read , mut b_write) = b . split () ; let (a_response , b_response) = futures :: future :: try_join (send_recv_all (& mut a_read , & mut a_write , b\"A\") , send_recv_all (& mut b_read , & mut b_write , b\"B\") ,) . await ? ; assert_eq ! (a_response , b\"B\") ; assert_eq ! (b_response , b\"A\") ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "action",
                        "label": "action",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Our global signal handler for all signals registered by this module.\"] # [doc = \"\"] # [doc = \" The purpose of this signal handler is to primarily:\"] # [doc = \"\"] # [doc = \" 1. Flag that our specific signal was received (e.g. store an atomic flag)\"] # [doc = \" 2. Wake up the driver by writing a byte to a pipe\"] # [doc = \"\"] # [doc = \" Those two operations should both be async-signal safe.\"] fn action (globals : & 'static Globals , signal : libc :: c_int) { globals . record_event (signal as EventId) ; let mut sender = & globals . sender ; drop (sender . write (& [1])) ; } . sig",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_fail",
                        "label": "test_fail",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Always fails with the error message below.\"] # [doc = \" ```text\"] # [doc = \" The #[tokio::test] macro requires rt or rt-multi-thread.\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn test_fail (_args : TokenStream , _item : TokenStream) -> TokenStream { syn :: Error :: new (proc_macro2 :: Span :: call_site () , \"The #[tokio::test] macro requires rt or rt-multi-thread.\" ,) . to_compile_error () . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "echo_server",
                        "label": "echo_server",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo_server () { const N : usize = 1024 ; let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let msg = \"foo bar baz\" ; let t = thread :: spawn (move | | { let mut s = assert_ok ! (TcpStream :: connect (addr)) ; let t2 = thread :: spawn (move | | { let mut s = assert_ok ! (TcpStream :: connect (addr)) ; let mut b = vec ! [0 ; msg . len () * N] ; assert_ok ! (s . read_exact (& mut b)) ; b }) ; let mut expected = Vec :: < u8 > :: new () ; for _i in 0 .. N { expected . extend (msg . as_bytes ()) ; let res = assert_ok ! (s . write (msg . as_bytes ())) ; assert_eq ! (res , msg . len ()) ; } (expected , t2) }) ; let (mut a , _) = assert_ok ! (srv . accept () . await) ; let (mut b , _) = assert_ok ! (srv . accept () . await) ; let n = assert_ok ! (tokio :: io :: copy (& mut a , & mut b) . await) ; let (expected , t2) = t . join () . unwrap () ; let actual = t2 . join () . unwrap () ; assert ! (expected == actual) ; assert_eq ! (n , msg . len () as u64 * 1024) ; } . sig",
                        "file_path": "tokio/tests/buffered.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_sender_new_must_be_closed",
                        "label": "broadcast_sender_new_must_be_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn broadcast_sender_new_must_be_closed () { let capacity = 1 ; let tx : broadcast :: Sender < () > = broadcast :: Sender :: new (capacity) ; let mut task = task :: spawn (tx . closed ()) ; assert_ready ! (task . poll ()) ; let _rx = tx . subscribe () ; let mut task2 = task :: spawn (tx . closed ()) ; assert_pending ! (task2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "global_queue_depth_multi_thread",
                        "label": "global_queue_depth_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn global_queue_depth_multi_thread () { for _ in 0 .. 10 { let rt = threaded () ; let metrics = rt . metrics () ; if let Ok (_blocking_tasks) = try_block_threaded (& rt) { for i in 0 .. 10 { assert_eq ! (i , metrics . global_queue_depth ()) ; rt . spawn (async { }) ; } return ; } } panic ! (\"exhausted every try to block the runtime\") ; } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multiple_entries",
                        "label": "multiple_entries",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multiple_entries () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let rx1 = Box :: pin (rx1) ; let rx2 = Box :: pin (rx2) ; map . insert (\"foo\" , rx1) ; map . insert (\"bar\" , rx2) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx1 . send (1)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 1) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx2 . send (2)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"bar\") ; assert_eq ! (v , 2) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx1 . send (3)) ; assert_ok ! (tx2 . send (4)) ; assert ! (map . is_woken ()) ; let mut v = (0 .. 2) . map (| _ | assert_ready_some ! (map . poll_next ())) . collect :: < Vec < _ > > () ; assert_pending ! (map . poll_next ()) ; v . sort_unstable () ; assert_eq ! (v [0] . 0 , \"bar\") ; assert_eq ! (v [0] . 1 , 4) ; assert_eq ! (v [1] . 0 , \"foo\") ; assert_eq ! (v [1] . 1 , 3) ; drop (tx1) ; assert ! (map . is_woken ()) ; assert_pending ! (map . poll_next ()) ; drop (tx2) ; assert_ready_none ! (map . poll_next ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybedangling_runs_drop",
                        "label": "maybedangling_runs_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn maybedangling_runs_drop () { struct SetOnDrop < 'a > (& 'a mut bool) ; impl Drop for SetOnDrop < '_ > { fn drop (& mut self) { * self . 0 = true ; } } let mut success = false ; drop (MaybeDangling :: new (SetOnDrop (& mut success))) ; assert ! (success) ; } . sig",
                        "file_path": "tokio-util/src/util/maybe_dangling.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_notified_one",
                        "label": "notify_notified_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_notified_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified = spawn (async { notify . clone () . notified_owned () . await }) ; notify . notify_one () ; assert_ready ! (notified . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_different_sizes",
                        "label": "test_different_sizes",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_different_sizes () { let fut1 = async move { 10 } ; let val = [0u32 ; 1000] ; let fut2 = async move { val [0] } ; let fut3 = ZeroSizedFuture { } ; assert_eq ! (Layout :: for_value (& fut1) . size () , 1) ; assert_eq ! (Layout :: for_value (& fut2) . size () , 4004) ; assert_eq ! (Layout :: for_value (& fut3) . size () , 0) ; let mut b = ReusableBoxFuture :: new (fut1) ; assert_eq ! (b . get_pin () . now_or_never () , Some (10)) ; b . set (fut2) ; assert_eq ! (b . get_pin () . now_or_never () , Some (0)) ; b . set (fut3) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; } . sig",
                        "file_path": "tokio-util/tests/reusable_box.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_semaphore_prevents_acquire",
                        "label": "close_semaphore_prevents_acquire",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_semaphore_prevents_acquire () { let s = Semaphore :: new (5) ; s . close () ; assert_eq ! (5 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (5 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (5 , s . available_permits ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "straight_execution",
                        "label": "straight_execution",
                        "kind": "Function",
                        "signature": "fn # [test] fn straight_execution () { let l = Mutex :: new (100) ; { let mut t = spawn (l . lock ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 100) ; * g = 99 ; } { let mut t = spawn (l . lock ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 99) ; * g = 98 ; } { let mut t = spawn (l . lock ()) ; let g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 98) ; } } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Peer",
                        "label": "Peer",
                        "kind": "Struct",
                        "signature": "struct Peer",
                        "file_path": "examples/chat.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_basic_on_vectored",
                        "label": "write_vectored_basic_on_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_basic_on_vectored () { let msg = b\"foo bar baz\" ; let bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let mut w = BufWriter :: new (MockWriter :: vectored (4)) ; let n = assert_ok ! (write_vectored (& mut w , & bufs) . await) ; assert_eq ! (n , msg . len ()) ; assert ! (w . buffer () == & msg [..]) ; assert_ok ! (w . flush () . await) ; assert_eq ! (w . get_ref () . data , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_await",
                        "label": "sync_one_await",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_await () { let foo = tokio :: select ! { foo = one () => foo , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "HistogramBuilder",
                        "label": "HistogramBuilder",
                        "kind": "Struct",
                        "signature": "struct HistogramBuilder",
                        "file_path": "tokio/src/runtime/metrics/mock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "changed_succeeds_on_closed_channel_with_unseen_value",
                        "label": "changed_succeeds_on_closed_channel_with_unseen_value",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn changed_succeeds_on_closed_channel_with_unseen_value () { let (tx , mut rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . changed () . await . expect (\"should not return error as long as the current value is not seen\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "caller_names_const_count",
                        "label": "caller_names_const_count",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn caller_names_const_count () { let (tx , rx) = oneshot :: channel :: < u32 > () ; const COUNT : u32 = 2 ; let mut try_join = task :: spawn (async { tokio :: try_join ! (async { tx . send (COUNT) }) }) ; assert_ready ! (try_join . poll ()) . unwrap () ; let res = rx . await . unwrap () ; assert_eq ! (2 , res) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "slot_range",
                        "label": "slot_range",
                        "kind": "Function",
                        "signature": "fn fn slot_range (level : usize) -> u64 { LEVEL_MULT . pow (level as u32) as u64 } . sig",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "schedule",
                        "label": "schedule",
                        "kind": "Function",
                        "signature": "fn # [test] fn schedule () { with (| rt | { rt . spawn (async { crate :: task :: yield_now () . await ; }) ; assert_eq ! (2 , rt . tick ()) ; rt . shutdown () ; }) } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wait_for_errors_on_closed_channel_true_predicate",
                        "label": "wait_for_errors_on_closed_channel_true_predicate",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn wait_for_errors_on_closed_channel_true_predicate () { let (tx , mut rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . wait_for (| _ | true) . await . expect (\"`wait_for` call does not return error even if channel is closed when predicate is true for last value.\" ,) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_vec",
                        "label": "empty_vec",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_vec () { let coll : Vec < u32 > = stream :: empty () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_drop_notified_notify",
                        "label": "notified_drop_notified_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_drop_notified_notify () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; drop (notified1) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Stack",
                        "label": "Stack",
                        "kind": "Struct",
                        "signature": "struct Stack",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "open_options_windows_security_qos_flags",
                        "label": "open_options_windows_security_qos_flags",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_security_qos_flags () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . security_qos_flags (FileSystem :: SECURITY_IDENTIFICATION)) . contains (\"security_qos_flags: 1114112,\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_unbounded_receiver_blocking_recv_panic_caller",
                        "label": "mpsc_unbounded_receiver_blocking_recv_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_unbounded_receiver_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: unbounded_channel :: < u8 > () ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge",
                        "label": "merge",
                        "kind": "Function",
                        "signature": "fn # [test] fn merge () { let sem = Arc :: new (Semaphore :: new (3)) ; { let mut p1 = sem . try_acquire () . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; let p2 = sem . try_acquire_many (2) . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p1 . merge (p2) ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 3) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CtrlShutdown",
                        "label": "CtrlShutdown",
                        "kind": "Struct",
                        "signature": "struct CtrlShutdown",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unused_braces_test",
                        "label": "unused_braces_test",
                        "kind": "Function",
                        "signature": "fn # [rustfmt :: skip] # [tokio :: test] async fn unused_braces_test () { assert_eq ! (1 + 1 , 2) } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_tx",
                        "label": "dropping_tx",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: channel :: < () > (16) ; for _ in 0 .. 2 { let tx = tx . clone () ; thread :: spawn (move | | { drop (tx) ; }) ; } drop (tx) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_deferred_tasks_and_free",
                        "label": "wake_deferred_tasks_and_free",
                        "kind": "Function",
                        "signature": "fn # [cfg (tokio_taskdump)] fn wake_deferred_tasks_and_free (context : & Context) { let wakers = context . defer . take_deferred () ; for waker in wakers { waker . wake () ; } } . sig",
                        "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "borrow_and_update",
                        "label": "borrow_and_update",
                        "kind": "Function",
                        "signature": "fn # [test] fn borrow_and_update () { let (tx , mut rx) = watch :: channel (\"one\") ; assert ! (! rx . has_changed () . unwrap ()) ; tx . send (\"two\") . unwrap () ; assert ! (rx . has_changed () . unwrap ()) ; assert_ready ! (spawn (rx . changed ()) . poll ()) . unwrap () ; assert_pending ! (spawn (rx . changed ()) . poll ()) ; assert ! (! rx . has_changed () . unwrap ()) ; tx . send (\"three\") . unwrap () ; assert ! (rx . has_changed () . unwrap ()) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; assert_pending ! (spawn (rx . changed ()) . poll ()) ; assert ! (! rx . has_changed () . unwrap ()) ; drop (tx) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; assert_ready ! (spawn (rx . changed ()) . poll ()) . unwrap_err () ; assert ! (rx . has_changed () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_future_sleep_before_fire",
                        "label": "reset_future_sleep_before_fire",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_future_sleep_before_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; sleep . as_mut () . reset (Instant :: now () + ms (200)) ; sleep . await ; assert_elapsed ! (now , ms (200)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "long_sleeps",
                        "label": "long_sleeps",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn long_sleeps () { tokio :: time :: pause () ; let deadline = tokio :: time :: Instant :: now () + Duration :: from_secs (10 * 365 * 24 * 3600 ,) ; tokio :: time :: sleep_until (deadline) . await ; assert ! (tokio :: time :: Instant :: now () >= deadline) ; assert ! (tokio :: time :: Instant :: now () <= deadline + Duration :: from_millis (1)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U64Decoder",
                        "label": "U64Decoder",
                        "kind": "Struct",
                        "signature": "struct U64Decoder",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "cancel_token_owned",
                        "label": "cancel_token_owned",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_token_owned () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; assert ! (! token . is_cancelled ()) ; let wait_fut = token . clone () . cancelled_owned () ; pin ! (wait_fut) ; assert_eq ! (Poll :: Pending , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; let wait_fut_2 = token . clone () . cancelled_owned () ; pin ! (wait_fut_2) ; token . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , wait_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "missing_semicolon_or_return_type",
                        "label": "missing_semicolon_or_return_type",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn missing_semicolon_or_return_type () { Ok (()) } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Listener",
                        "label": "Listener",
                        "kind": "Trait",
                        "signature": "trait Listener",
                        "file_path": "tokio-util/src/net/mod.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "concurrent_read_write",
                        "label": "concurrent_read_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn concurrent_read_write () { let b = loom :: model :: Builder :: new () ; b . check (| | { let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone = rwlock . clone () ; let t1 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t2 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write_owned () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t3 = thread :: spawn (move | | { block_on (async { let guard = rwclone . read () . await ; assert ! (* guard == 0 || * guard == 5 || * guard == 10) ; }) ; }) ; { let guard = block_on (rwlock . clone () . read_owned ()) ; assert ! (* guard == 0 || * guard == 5 || * guard == 10) ; } t1 . join () . expect (\"thread 1 write should not panic\") ; t2 . join () . expect (\"thread 2 write should not panic\") ; t3 . join () . expect (\"thread 3 read should not panic\") ; let guard = block_on (rwlock . read ()) ; assert_eq ! (10 , * guard) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_local_from_guard",
                        "label": "test_spawn_local_from_guard",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_spawn_local_from_guard () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; let _guard = rt . enter () ; spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Inject",
                        "label": "Inject",
                        "kind": "Struct",
                        "signature": "struct Inject",
                        "file_path": "tokio/src/runtime/scheduler/inject.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "BoundedStream",
                        "label": "BoundedStream",
                        "kind": "Struct",
                        "signature": "struct BoundedStream",
                        "file_path": "tokio/tests/support/mpsc_stream.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "runtime_without_time_does_not_panic",
                        "label": "runtime_without_time_does_not_panic",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"rt\" , not (feature = \"time\")))] # [wasm_bindgen_test] fn runtime_without_time_does_not_panic () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; } . sig",
                        "file_path": "tokio/tests/time_wasm.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_panics_do_not_propagate_when_dropping_join_handle",
                        "label": "test_panics_do_not_propagate_when_dropping_join_handle",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_panics_do_not_propagate_when_dropping_join_handle () { let join_handle = tokio :: spawn (async move { PanicsOnDrop }) ; tokio :: time :: sleep (std :: time :: Duration :: from_millis (3)) . await ; drop (join_handle) ; } . sig",
                        "file_path": "tokio/tests/join_handle_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_in_drop_after_panic",
                        "label": "wake_in_drop_after_panic",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [should_panic (expected = \"boom\")] fn wake_in_drop_after_panic () { struct WakeOnDrop (Option < oneshot :: Sender < () > >) ; impl Drop for WakeOnDrop { fn drop (& mut self) { let _ = self . 0 . take () . unwrap () . send (()) ; } } let rt = rt () ; let (tx1 , rx1) = oneshot :: channel :: < () > () ; let (tx2 , rx2) = oneshot :: channel :: < () > () ; rt . spawn (async move { let _wake_on_drop = WakeOnDrop (Some (tx2)) ; let _ = rx1 . await ; unreachable ! () }) ; rt . spawn (async move { let _wake_on_drop = WakeOnDrop (Some (tx1)) ; let _ = rx2 . await ; unreachable ! () }) ; rt . block_on (async { tokio :: task :: yield_now () . await ; panic ! (\"boom\") ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_on_close",
                        "label": "notify_on_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_on_close () { let tracker = TaskTracker :: new () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; tracker . close () ; assert_ready ! (wait . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawning",
                        "label": "spawning",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn spawning () -> usize { let join = tokio :: spawn (async { 1 }) ; join . await . unwrap () } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SocketAddr",
                        "label": "SocketAddr",
                        "kind": "Struct",
                        "signature": "struct SocketAddr",
                        "file_path": "tokio/src/net/unix/socketaddr.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "remote_abort_local_set_3929",
                        "label": "remote_abort_local_set_3929",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a suspended LocalSet task can be aborted from a remote thread\"] # [doc = \" without panicking and without running the tasks destructor on the wrong thread.\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/3929>\"] # [test] fn remote_abort_local_set_3929 () { struct DropCheck { created_on : std :: thread :: ThreadId , not_send : std :: marker :: PhantomData < * const () > , } impl DropCheck { fn new () -> Self { Self { created_on : std :: thread :: current () . id () , not_send : std :: marker :: PhantomData , } } } impl Drop for DropCheck { fn drop (& mut self) { if std :: thread :: current () . id () != self . created_on { panic ! (\"non-Send value dropped in another thread!\") ; } } } let rt = Builder :: new_current_thread () . build () . unwrap () ; let local = tokio :: task :: LocalSet :: new () ; let check = DropCheck :: new () ; let jh = local . spawn_local (async move { futures :: future :: pending :: < () > () . await ; drop (check) ; }) ; let jh2 = std :: thread :: spawn (move | | { sleep (Duration :: from_millis (10)) ; jh . abort () ; }) ; rt . block_on (local) ; jh2 . join () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_until",
                        "label": "sleep_until",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Waits until `deadline` is reached.\"] # [doc = \"\"] # [doc = \" No work is performed while awaiting on the sleep future to complete. `Sleep`\"] # [doc = \" operates at millisecond granularity and should not be used for tasks that\"] # [doc = \" require high-resolution timers.\"] # [doc = \"\"] # [doc = \" To run something regularly on a schedule, see [`interval`].\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Canceling a sleep instance is done by dropping the returned future. No additional\"] # [doc = \" cleanup work is required.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Wait 100ms and print \\\"100 ms have elapsed\\\".\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{sleep_until, Instant, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" sleep_until(Instant::now() + Duration::from_millis(100)).await;\"] # [doc = \" println!(\\\"100 ms have elapsed\\\");\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" See the documentation for the [`Sleep`] type for more examples.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Sleep`]: struct@crate::time::Sleep\"] # [doc = \" [`interval`]: crate::time::interval()\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [cfg_attr (docsrs , doc (alias = \"delay_until\"))] # [track_caller] pub fn sleep_until (deadline : Instant) -> Sleep { Sleep :: new_timeout (deadline , trace :: caller_location ()) } . sig",
                        "file_path": "tokio/src/time/sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "oneshot_blocking_recv_panic_caller",
                        "label": "oneshot_blocking_recv_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn oneshot_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let (_tx , rx) = oneshot :: channel :: < u8 > () ; let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let one = stream :: iter (vec ! [1 , 2 , 3]) ; let two = stream :: iter (vec ! [4 , 5 , 6]) ; let mut stream = visibility_test (one , two) ; assert_eq ! (stream . size_hint () , (6 , Some (6))) ; assert_eq ! (stream . next () . await , Some (1)) ; assert_eq ! (stream . size_hint () , (5 , Some (5))) ; assert_eq ! (stream . next () . await , Some (2)) ; assert_eq ! (stream . size_hint () , (4 , Some (4))) ; assert_eq ! (stream . next () . await , Some (3)) ; assert_eq ! (stream . size_hint () , (3 , Some (3))) ; assert_eq ! (stream . next () . await , Some (4)) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; assert_eq ! (stream . next () . await , Some (5)) ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; assert_eq ! (stream . next () . await , Some (6)) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_bidirectional",
                        "label": "copy_bidirectional",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Copies data in both directions between `a` and `b`.\"] # [doc = \"\"] # [doc = \" This function returns a future that will read from both streams,\"] # [doc = \" writing any data read to the opposing stream.\"] # [doc = \" This happens in both directions concurrently.\"] # [doc = \"\"] # [doc = \" If an EOF is observed on one stream, [`shutdown()`] will be invoked on\"] # [doc = \" the other, and reading from that stream will stop. Copying of data in\"] # [doc = \" the other direction will continue.\"] # [doc = \"\"] # [doc = \" The future will complete successfully once both directions of communication has been shut down.\"] # [doc = \" A direction is shut down when the reader reports EOF,\"] # [doc = \" at which point [`shutdown()`] is called on the corresponding writer. When finished,\"] # [doc = \" it will return a tuple of the number of bytes copied from a to b\"] # [doc = \" and the number of bytes copied from b to a, in that order.\"] # [doc = \"\"] # [doc = \" It uses two 8 KB buffers for transferring bytes between `a` and `b` by default.\"] # [doc = \" To set your own buffers sizes use [`copy_bidirectional_with_sizes()`].\"] # [doc = \"\"] # [doc = \" [`shutdown()`]: crate::io::AsyncWriteExt::shutdown\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" The future will immediately return an error if any IO operation on `a`\"] # [doc = \" or `b` returns an error. Some data read from either stream may be lost (not\"] # [doc = \" written to the other stream) in this case.\"] # [doc = \"\"] # [doc = \" # Return value\"] # [doc = \"\"] # [doc = \" Returns a tuple of bytes copied `a` to `b` and bytes copied `b` to `a`.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub async fn copy_bidirectional < A , B > (a : & mut A , b : & mut B) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { copy_bidirectional_impl (a , b , CopyBuffer :: new (super :: DEFAULT_BUF_SIZE) , CopyBuffer :: new (super :: DEFAULT_BUF_SIZE) ,) . await } . sig",
                        "file_path": "tokio/src/io/util/copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_int_should_err_if_write_count_0",
                        "label": "write_int_should_err_if_write_count_0",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_int_should_err_if_write_count_0 () { struct Wr { } impl AsyncWrite for Wr { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { Ok (0) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { } ; assert ! (wr . write_i8 (0) . await . is_err ()) ; assert ! (wr . write_i32 (12) . await . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/io_write_int.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all_vectored",
                        "label": "write_all_vectored",
                        "kind": "Function",
                        "signature": "fn async fn write_all_vectored < W : AsyncWrite + Unpin > (mut writer : W , mut bufs : Vec < Vec < u8 > > ,) -> Result < usize , std :: io :: Error > { let mut res = 0 ; while ! bufs . is_empty () { let mut written = poll_fn (| cx | { let bufs : Vec < IoSlice > = bufs . iter () . map (| v | IoSlice :: new (v)) . collect () ; Pin :: new (& mut writer) . poll_write_vectored (cx , & bufs) }) . await ? ; res += written ; while written > 0 { let buf_len = bufs [0] . len () ; if buf_len <= written { bufs . remove (0) ; written -= buf_len ; } else { let buf = & mut bufs [0] ; let drain_len = written . min (buf . len ()) ; buf . drain (.. drain_len) ; written -= drain_len ; } } } Ok (res) } . sig",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_two",
                        "label": "spawn_two",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_two () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (\"ZOMG\") . unwrap () ; }) ; }) ; assert_ok ! (rx . await) }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (0 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (2 , local) ; } } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_unpin",
                        "label": "is_unpin",
                        "kind": "Function",
                        "signature": "fn fn is_unpin < T : Unpin > () { } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "nested_one",
                        "label": "nested_one",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn nested_one () { let foo = tokio :: select ! { foo = async { 1 } => tokio :: select ! { bar = async { foo } => bar , } , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LegacyLogHistogram",
                        "label": "LegacyLogHistogram",
                        "kind": "Struct",
                        "signature": "struct LegacyLogHistogram",
                        "file_path": "tokio/src/runtime/metrics/histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_shutdown",
                        "label": "ctrl_shutdown",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_shutdown () -> io :: Result < RxFuture > { panic ! () } . sig",
                        "file_path": "tokio/src/signal/windows/stub.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_reset_at_panic_caller",
                        "label": "delay_queue_reset_at_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_reset_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . reset_at (& key , Instant :: now () + Duration :: from_millis (MAX_DURATION_MS + 1) ,) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_try_join_next_disabled_coop",
                        "label": "test_join_queue_try_join_next_disabled_coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next_disabled_coop () { const TASK_NUM : u32 = 1000 ; let sem : std :: sync :: Arc < tokio :: sync :: Semaphore > = std :: sync :: Arc :: new (tokio :: sync :: Semaphore :: new (0)) ; let mut queue = JoinQueue :: new () ; for _ in 0 .. TASK_NUM { let sem = sem . clone () ; queue . spawn (async move { sem . add_permits (1) ; }) ; } let _ = sem . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; while ! queue . is_empty () { match queue . try_join_next () { Some (Ok (())) => count += 1 , Some (Err (err)) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; } } } assert_eq ! (coop_count , 0) ; assert_eq ! (count , TASK_NUM) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "forget_permits_basic",
                        "label": "forget_permits_basic",
                        "kind": "Function",
                        "signature": "fn # [test] fn forget_permits_basic () { let s = Semaphore :: new (10) ; assert_eq ! (s . forget_permits (4) , 4) ; assert_eq ! (s . available_permits () , 6) ; assert_eq ! (s . forget_permits (10) , 6) ; assert_eq ! (s . available_permits () , 0) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalPoolHandle",
                        "label": "LocalPoolHandle",
                        "kind": "Struct",
                        "signature": "struct LocalPoolHandle",
                        "file_path": "tokio-util/src/task/spawn_pinned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_multi_client_ready",
                        "label": "test_named_pipe_multi_client_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_multi_client_ready () -> io :: Result < () > { use tokio :: io :: Interest ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-multi-client-ready\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { for _ in 0 .. N { server . connect () . await ? ; let inner_server = server ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; tokio :: spawn (async move { let server = inner_server ; { let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; loop { server . readable () . await ? ; let buf = & mut read_buf [read_buf_cursor ..] ; match server . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } ; { let write_buf = b\"pong\\n\" ; let mut write_buf_cursor = 0 ; loop { server . writable () . await ? ; let buf = & write_buf [write_buf_cursor ..] ; match server . try_write (buf) { Ok (n) => { write_buf_cursor += n ; if write_buf_cursor == write_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) if e . kind () == io :: ErrorKind :: NotFound => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (10)) . await ; } ; let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; let write_buf = b\"ping\\n\" ; let mut write_buf_cursor = 0 ; loop { let mut interest = Interest :: READABLE ; if write_buf_cursor < write_buf . len () { interest |= Interest :: WRITABLE ; } let ready = client . ready (interest) . await ? ; if ready . is_readable () { let buf = & mut read_buf [read_buf_cursor ..] ; match client . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } if ready . is_writable () { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { continue ; } match client . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } let buf = String :: from_utf8_lossy (& read_buf) . into_owned () ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (result ?, \"pong\\n\") ; } server . await ? ? ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_pause_after_resume",
                        "label": "can_pause_after_resume",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn can_pause_after_resume () { let start = Instant :: now () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; time :: resume () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; assert ! (Instant :: now () - start > Duration :: from_secs (20)) ; assert ! (Instant :: now () - start < Duration :: from_secs (21)) ; } . sig",
                        "file_path": "tokio/tests/test_clock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_timeout_panic",
                        "label": "recv_timeout_panic",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\"] # [cfg (not (target_family = \"wasm\"))] fn recv_timeout_panic () { use futures :: future :: FutureExt ; use tokio :: time :: Duration ; let (tx , _rx) = mpsc :: channel (5) ; tx . send_timeout (10 , Duration :: from_secs (1)) . now_or_never () ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = Alternate { state : 0 } ; assert_eq ! (stream . next () . await , Some (0)) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . next () . await , Some (2)) ; assert_eq ! (stream . next () . await , None) ; let mut stream = stream . fuse () ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (stream . next () . await , Some (4)) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_fuse.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "watch_stream_from_rx",
                        "label": "watch_stream_from_rx",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn watch_stream_from_rx () { let (tx , rx) = watch :: channel (\"hello\") ; let mut stream = WatchStream :: from (rx) ; assert_eq ! (stream . next () . await . unwrap () , \"hello\") ; tx . send (\"bye\") . unwrap () ; assert_eq ! (stream . next () . await . unwrap () , \"bye\") ; } . sig",
                        "file_path": "tokio-stream/tests/watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "immediate_exit_on_read_error",
                        "label": "immediate_exit_on_read_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn immediate_exit_on_read_error () { let error = | | io :: Error :: new (io :: ErrorKind :: Other , \"got nothing!\") ; let mut a = tokio_test :: io :: Builder :: new () . read_error (error ()) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read_error (error ()) . build () ; assert ! (copy_bidirectional (& mut a , & mut b) . await . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadyEvent",
                        "label": "ReadyEvent",
                        "kind": "Struct",
                        "signature": "struct ReadyEvent",
                        "file_path": "tokio/src/runtime/io/driver.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_spawn_many_local",
                        "label": "rt_multi_spawn_many_local",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_spawn_many_local (c : & mut Criterion) { let rt = rt () ; let (tx , rx) = mpsc :: sync_channel (1000) ; let rem = Arc :: new (AtomicUsize :: new (0)) ; c . bench_function (\"spawn_many_local\" , | b | { b . iter (| | { rem . store (NUM_SPAWN , Relaxed) ; rt . block_on (async { for _ in 0 .. NUM_SPAWN { let tx = tx . clone () ; let rem = rem . clone () ; tokio :: spawn (async move { if 1 == rem . fetch_sub (1 , Relaxed) { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalKey",
                        "label": "LocalKey",
                        "kind": "Struct",
                        "signature": "struct LocalKey",
                        "file_path": "tokio/src/task/task_local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "SizedStream",
                        "label": "SizedStream",
                        "kind": "Struct",
                        "signature": "struct SizedStream",
                        "file_path": "tokio-test/tests/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "spawn_mandatory_blocking_should_always_run",
                        "label": "spawn_mandatory_blocking_should_always_run",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_mandatory_blocking_should_always_run () { use crate :: runtime :: tests :: loom_oneshot ; loom :: model (| | { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; let (tx , rx) = loom_oneshot :: channel () ; let _enter = rt . enter () ; runtime :: spawn_blocking (| | { }) ; runtime :: spawn_mandatory_blocking (move | | { let _ = tx . send (()) ; }) . unwrap () ; drop (rt) ; let () = rx . recv () ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_on",
                        "label": "block_on",
                        "kind": "Function",
                        "signature": "fn fn block_on < T > (f : impl std :: future :: Future < Output = T >) -> T { # [cfg (loom)] return loom :: future :: block_on (f) ; # [cfg (not (loom))] { let rt = crate :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (f) } } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn fn main () { let rt = Builder :: new_multi_thread () . enable_io () . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . enable_io () . build () . unwrap () ; rt . spawn (async { let listener = TcpListener :: bind (TCP_ENDPOINT) . await . unwrap () ; let (mut socket , _) = listener . accept () . await . unwrap () ; let (mut rd , mut wr) = socket . split () ; while tokio :: io :: copy (& mut rd , & mut wr) . await . is_ok () { } }) ; sleep (Duration :: from_millis (100)) ; let (tx , mut rx) = oneshot :: channel () ; rt2 . spawn (async { let addr = TCP_ENDPOINT . parse () . unwrap () ; let socket = TcpSocket :: new_v4 () . unwrap () ; let mut stream = socket . connect (addr) . await . unwrap () ; let mut buff = [0 ; MSG_SIZE] ; for _ in 0 .. NUM_MSGS { let one_mega_random_bytes : Vec < u8 > = (0 .. MSG_SIZE) . map (| _ | rand :: random :: < u8 > ()) . collect () ; stream . write_all (one_mega_random_bytes . as_slice ()) . await . unwrap () ; let _ = stream . read (& mut buff) . await . unwrap () ; } tx . send (()) . unwrap () ; }) ; loop { match rx . try_recv () { Err (oneshot :: error :: TryRecvError :: Empty) => () , Err (oneshot :: error :: TryRecvError :: Closed) => panic ! (\"channel got closed...\") , Ok (()) => break , } } } . sig",
                        "file_path": "stress-test/examples/simple_echo_tcp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "smoke",
                        "label": "smoke",
                        "kind": "Function",
                        "signature": "fn # [test] fn smoke () { use crate :: sync :: mpsc :: block :: Read ; const NUM_TX : usize = 2 ; const NUM_MSG : usize = 2 ; loom :: model (| | { let (tx , mut rx) = list :: channel () ; let tx = Arc :: new (tx) ; for th in 0 .. NUM_TX { let tx = tx . clone () ; thread :: spawn (move | | { for i in 0 .. NUM_MSG { tx . push ((th , i)) ; } }) ; } let mut next = vec ! [0 ; NUM_TX] ; loop { match rx . pop (& tx) { Some (Read :: Value ((th , v))) => { assert_eq ! (v , next [th]) ; next [th] += 1 ; if next . iter () . all (| & i | i == NUM_MSG) { break ; } } Some (Read :: Closed) => { panic ! () ; } None => { thread :: yield_now () ; } } } }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_list.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ms",
                        "label": "ms",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Convert a `Duration` to milliseconds, rounding up and saturating at\"] # [doc = \" `u64::MAX`.\"] # [doc = \"\"] # [doc = \" The saturating is fine because `u64::MAX` milliseconds are still many\"] # [doc = \" million years.\"] # [inline] fn ms (duration : Duration , round : Round) -> u64 { const NANOS_PER_MILLI : u32 = 1_000_000 ; const MILLIS_PER_SEC : u64 = 1_000 ; let millis = match round { Round :: Up => (duration . subsec_nanos () + NANOS_PER_MILLI - 1) / NANOS_PER_MILLI , Round :: Down => duration . subsec_millis () , } ; duration . as_secs () . saturating_mul (MILLIS_PER_SEC) . saturating_add (u64 :: from (millis)) } . sig",
                        "file_path": "tokio-util/src/time/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "build_run_time",
                        "label": "build_run_time",
                        "kind": "Function",
                        "signature": "fn fn build_run_time (workers : usize) -> Runtime { if workers == 1 { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } else { tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (workers) . build () . unwrap () } } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_with_manual_abort",
                        "label": "test_join_queue_with_manual_abort",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_with_manual_abort () { let mut queue = JoinQueue :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; let mut senders = Vec :: new () ; for i in 0 .. 16 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; let abort = queue . spawn (async move { let _ = rx . await ; i }) ; if i % 2 != 0 { abort . abort () ; } } while let Some (tx) = senders . pop () { let _ = tx . send (()) ; } while let Some (res) = queue . join_next () . await { match res { Ok (res) => { assert_eq ! (res , num_completed * 2) ; num_completed += 1 ; } Err (e) => { assert ! (e . is_cancelled ()) ; num_canceled += 1 ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_sleep_job",
                        "label": "spawn_sleep_job",
                        "kind": "Function",
                        "signature": "fn async fn spawn_sleep_job (iters : usize , procs : usize) { let mut handles = Vec :: with_capacity (procs) ; for _ in 0 .. procs { handles . push (tokio :: spawn (async move { for _ in 0 .. iters / procs { let _h = black_box (sleep (Duration :: from_secs (1))) ; } })) ; } for handle in handles { handle . await . unwrap () ; } } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "fifo_multiple_writes",
                        "label": "fifo_multiple_writes",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks EOF behavior with single reader and writers sequentially opening\"] # [doc = \" and closing a FIFO.\"] # [tokio :: test] # [cfg_attr (miri , ignore)] async fn fifo_multiple_writes () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"fifo_multiple_writes\") ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; write_and_close (& fifo , DATA) . await ? ; let ev = reader . ready (Interest :: READABLE) . await ? ; assert ! (ev . is_readable ()) ; let mut read_data = vec ! [0 ; DATA . len ()] ; assert_ok ! (reader . read_exact (& mut read_data) . await) ; let err = assert_err ! (reader . read_exact (& mut read_data) . await) ; assert_eq ! (err . kind () , io :: ErrorKind :: UnexpectedEof) ; write_and_close (& fifo , DATA) . await ? ; assert_ok ! (reader . read_exact (& mut read_data) . await) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval",
                        "label": "interval",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn interval () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; assert_ready_eq ! (poll_next (& mut i) , start) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (200)) . await ; assert_elapsed ! (before , ms (200)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (300)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (400)) . await ; assert_elapsed ! (before , ms (400)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (600)) ; assert_pending ! (poll_next (& mut i)) ; let before = Instant :: now () ; time :: advance (ms (500)) . await ; assert_elapsed ! (before , ms (500)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (900)) ; assert_ready_eq ! (poll_next (& mut i) , start + ms (1200)) ; assert_pending ! (poll_next (& mut i)) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "await_error_readiness_invalid_address",
                        "label": "await_error_readiness_invalid_address",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (target_os = \"linux\")] async fn await_error_readiness_invalid_address () { use std :: net :: { Ipv4Addr , SocketAddr } ; use tokio :: io :: { Interest , Ready } ; let socket_addr = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let socket = std :: net :: UdpSocket :: bind (socket_addr) . unwrap () ; let socket_fd = socket . as_raw_fd () ; let recv_err : libc :: c_int = 1 ; unsafe { let res = libc :: setsockopt (socket . as_raw_fd () , libc :: SOL_IP , libc :: IP_RECVERR , & recv_err as * const _ as * const libc :: c_void , std :: mem :: size_of_val (& recv_err) as libc :: socklen_t ,) ; if res == - 1 { panic ! (\"{:?}\" , std :: io :: Error :: last_os_error ()) ; } } tokio :: spawn (async move { let mut dest_addr = unsafe { std :: mem :: MaybeUninit :: < libc :: sockaddr_in > :: zeroed () . assume_init () } ; dest_addr . sin_family = libc :: AF_INET as _ ; dest_addr . sin_port = 512u16 . to_be () ; let message = \"Hello, Socket!\" ; let mut iov = libc :: iovec { iov_base : message . as_ptr () as * mut libc :: c_void , iov_len : message . len () , } ; let dest_sockaddr : * const libc :: sockaddr = & dest_addr as * const _ as * const libc :: sockaddr ; let dest_addrlen : libc :: socklen_t = std :: mem :: size_of_val (& dest_addr) as libc :: socklen_t ; let mut msg : libc :: msghdr = unsafe { std :: mem :: MaybeUninit :: zeroed () . assume_init () } ; msg . msg_name = dest_sockaddr as * mut libc :: c_void ; msg . msg_namelen = dest_addrlen ; msg . msg_iov = & mut iov ; msg . msg_iovlen = 1 ; if unsafe { libc :: sendmsg (socket_fd , & msg , 0) } == - 1 { panic ! (\"{:?}\" , std :: io :: Error :: last_os_error ()) } }) ; let fd = AsyncFd :: new (socket) . unwrap () ; let guard = fd . ready (Interest :: ERROR) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: ERROR) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_local_queue_depth",
                        "label": "worker_local_queue_depth",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_local_queue_depth () { const N : usize = 100 ; let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) ; } assert_eq ! (N , metrics . worker_local_queue_depth (0)) ; }) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async move { tokio :: spawn (async move { let (tx1 , rx1) = std :: sync :: mpsc :: channel () ; let (tx2 , rx2) = std :: sync :: mpsc :: channel () ; tokio :: spawn (async move { tx1 . send (()) . unwrap () ; rx2 . recv () . unwrap () ; }) ; tokio :: spawn (async { }) ; rx1 . recv () . unwrap () ; for _ in 0 .. 100 { tokio :: spawn (async { }) ; } let n : usize = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_local_queue_depth (i)) . sum () ; assert_eq ! (n , N) ; tx2 . send (()) . unwrap () ; }) . await . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "require_mutable",
                        "label": "require_mutable",
                        "kind": "Function",
                        "signature": "fn async fn require_mutable (_ : & mut i32) { } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "semaphore_merge_unrelated_owned_permits",
                        "label": "semaphore_merge_unrelated_owned_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn semaphore_merge_unrelated_owned_permits () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let sem1 = Arc :: new (Semaphore :: new (42)) ; let sem2 = Arc :: new (Semaphore :: new (42)) ; let mut p1 = sem1 . try_acquire_owned () . unwrap () ; let p2 = sem2 . try_acquire_owned () . unwrap () ; p1 . merge (p2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadDirStream",
                        "label": "ReadDirStream",
                        "kind": "Struct",
                        "signature": "struct ReadDirStream",
                        "file_path": "tokio-stream/src/wrappers/read_dir.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Level",
                        "label": "Level",
                        "kind": "Struct",
                        "signature": "struct Level",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "aborted_future_1",
                        "label": "aborted_future_1",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Ensure a mutex is unlocked if a future holding the lock\"] # [doc = \" is aborted prematurely.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_1 () { use std :: time :: Duration ; use tokio :: time :: { interval , timeout } ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let iv = interval (Duration :: from_millis (1000)) ; tokio :: pin ! (iv) ; let _g = m2 . lock () . await ; iv . as_mut () . tick () . await ; iv . as_mut () . tick () . await ; }) . await . unwrap_err () ; } timeout (Duration :: from_millis (1u64) , async move { let _g = m1 . lock () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_msgs_dropped_on_unbounded_rx_drop",
                        "label": "test_msgs_dropped_on_unbounded_rx_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_msgs_dropped_on_unbounded_rx_drop () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (MsgUnbounded { }) . unwrap () ; tx . send (MsgUnbounded { }) . unwrap () ; let sent = tx . send (MsgUnbounded { }) ; let _ = rx . recv () . await . unwrap () ; let _ = rx . recv () . await . unwrap () ; sent . unwrap () ; drop (rx) ; assert_eq ! (NUM_DROPPED_UNBOUNDED . load (Acquire) , 3) ; assert ! (tx . send (MsgUnbounded { }) . is_err ()) ; assert_eq ! (NUM_DROPPED_UNBOUNDED . load (Acquire) , 4) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_shutdown2",
                        "label": "create_shutdown2",
                        "kind": "Function",
                        "signature": "fn # [test] fn create_shutdown2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; handle . assert_not_dropped () ; notified . shutdown () ; handle . assert_dropped () ; drop (join) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_empty_when_all_but_one_messages_are_consumed",
                        "label": "test_rx_is_not_empty_when_all_but_one_messages_are_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_all_but_one_messages_are_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } for _ in 0 .. 9 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (! rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_dir_entry_info",
                        "label": "read_dir_entry_info",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_dir_entry_info () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; let mut dir = fs :: read_dir (temp_dir . path ()) . await . unwrap () ; let first_entry = dir . next_entry () . await . unwrap () . unwrap () ; assert_eq ! (first_entry . path () , file_path) ; assert_eq ! (first_entry . file_name () , \"a.txt\") ; assert ! (first_entry . metadata () . await . unwrap () . is_file ()) ; assert ! (first_entry . file_type () . await . unwrap () . is_file ()) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split_owned",
                        "label": "split_owned",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn split_owned (stream : TcpStream) -> (OwnedReadHalf , OwnedWriteHalf) { let arc = Arc :: new (stream) ; let read = OwnedReadHalf { inner : Arc :: clone (& arc) , } ; let write = OwnedWriteHalf { inner : arc , shutdown_on_drop : true , } ; (read , write) } . sig",
                        "file_path": "tokio/src/net/tcp/split_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_niche_in_task",
                        "label": "spawn_niche_in_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_niche_in_task () { use std :: future :: poll_fn ; use std :: task :: { Context , Poll , Waker } ; with (| rt | { let state = Arc :: new (Mutex :: new (State :: new ())) ; let mut subscriber = Subscriber :: new (Arc :: clone (& state) , 1) ; rt . spawn (async move { subscriber . wait () . await ; subscriber . wait () . await ; }) ; rt . spawn (async move { state . lock () . unwrap () . set_version (2) ; state . lock () . unwrap () . set_version (0) ; }) ; rt . tick_max (10) ; assert ! (rt . is_empty ()) ; rt . shutdown () ; }) ; pub (crate) struct Subscriber { state : Arc < Mutex < State > > , observed_version : u64 , waker_key : Option < usize > , } impl Subscriber { pub (crate) fn new (state : Arc < Mutex < State > > , version : u64) -> Self { Self { state , observed_version : version , waker_key : None , } } pub (crate) async fn wait (& mut self) { poll_fn (| cx | { self . state . lock () . unwrap () . poll_update (& mut self . observed_version , & mut self . waker_key , cx) . map (| _ | ()) }) . await ; } } struct State { version : u64 , wakers : Vec < Waker > , } impl State { pub (crate) fn new () -> Self { Self { version : 1 , wakers : Vec :: new () , } } pub (crate) fn poll_update (& mut self , observed_version : & mut u64 , waker_key : & mut Option < usize > , cx : & Context < '_ > ,) -> Poll < Option < () > > { if self . version == 0 { * waker_key = None ; Poll :: Ready (None) } else if * observed_version < self . version { * waker_key = None ; * observed_version = self . version ; Poll :: Ready (Some (())) } else { self . wakers . push (cx . waker () . clone ()) ; * waker_key = Some (self . wakers . len ()) ; Poll :: Pending } } pub (crate) fn set_version (& mut self , version : u64) { self . version = version ; for waker in self . wakers . drain (..) { waker . wake () ; } } } } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink_file_windows",
                        "label": "symlink_file_windows",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn symlink_file_windows () { const FILE_NAME : & str = \"abc.txt\" ; let temp_dir = tempdir () . unwrap () ; let dir1 = temp_dir . path () . join (\"a\") ; fs :: create_dir (& dir1) . await . unwrap () ; let file1 = dir1 . as_path () . join (FILE_NAME) ; fs :: write (& file1 , b\"Hello File!\") . await . unwrap () ; let dir2 = temp_dir . path () . join (\"b\") ; fs :: symlink_dir (& dir1 , & dir2) . await . unwrap () ; fs :: write (& file1 , b\"new data!\") . await . unwrap () ; let file2 = dir2 . as_path () . join (FILE_NAME) ; let from = fs :: read (& file1) . await . unwrap () ; let to = fs :: read (& file2) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
                        "file_path": "tokio/tests/fs_symlink_dir_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_write",
                        "label": "open_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_write () { let mut file = MockFile :: default () ; file . expect_inner_write () . once () . with (eq (HELLO)) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_eq ! (0 , pool :: len ()) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (! t . is_woken ()) ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskTracker",
                        "label": "TaskTracker",
                        "kind": "Struct",
                        "signature": "struct TaskTracker",
                        "file_path": "tokio-util/src/task/task_tracker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "send_framed_byte_codec",
                        "label": "send_framed_byte_codec",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (any (target_os = \"macos\" , target_os = \"ios\" , target_os = \"tvos\" , target_os = \"watchos\" , target_os = \"visionos\") , allow (unused_assignments))] # [tokio :: test] async fn send_framed_byte_codec () -> std :: io :: Result < () > { let mut a_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let mut b_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; { let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , ByteCodec) ; let msg = b\"4567\" ; let send = a . send ((msg , b_addr)) ; let recv = b . next () . map (| e | e . unwrap ()) ; let (_ , received) = try_join (send , recv) . await . unwrap () ; let (data , addr) = received ; assert_eq ! (msg , &* data) ; assert_eq ! (a_addr , addr) ; a_soc = a . into_inner () ; b_soc = b . into_inner () ; } # [cfg (not (any (target_os = \"macos\" , target_os = \"ios\" , target_os = \"tvos\" , target_os = \"watchos\" , target_os = \"visionos\")))] { let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , ByteCodec) ; let msg = b\"\" ; let send = a . send ((msg , b_addr)) ; let recv = b . next () . map (| e | e . unwrap ()) ; let (_ , received) = try_join (send , recv) . await . unwrap () ; let (data , addr) = received ; assert_eq ! (msg , &* data) ; assert_eq ! (a_addr , addr) ; } Ok (()) } . sig",
                        "file_path": "tokio-util/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_data_ordered_after_write",
                        "label": "sync_data_ordered_after_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn sync_data_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_data () . once () . returning (| | Ok (())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_data ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_max_length_underrun_twice",
                        "label": "any_delimiter_decoder_max_length_underrun_twice",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_max_length_underrun_twice () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too very l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"aaaaaaaaaaaaaaaaaaaaaaa\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\nshort\\n\") ; assert_eq ! (\"short\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "failed_wake_synchronizes_inner",
                        "label": "failed_wake_synchronizes_inner",
                        "kind": "Function",
                        "signature": "fn fn failed_wake_synchronizes_inner () { use futures :: task :: noop_waker_ref ; use std :: sync :: atomic :: { AtomicBool , Ordering } ; static DID_SYNCHRONIZE : AtomicBool = AtomicBool :: new (false) ; DID_SYNCHRONIZE . store (false , Ordering :: Relaxed) ; let waker = AtomicWaker :: new () ; waker . register_by_ref (noop_waker_ref ()) ; std :: thread :: scope (| s | { let jh = s . spawn (| | { DID_SYNCHRONIZE . store (true , Ordering :: Relaxed) ; waker . take_waker () }) ; waker . take_waker () ; waker . register_by_ref (noop_waker_ref ()) ; let did_synchronize = DID_SYNCHRONIZE . load (Ordering :: Relaxed) ; let did_take = jh . join () . unwrap () . is_some () ; assert ! (did_synchronize || did_take) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "closing_bounded_rx",
                        "label": "closing_bounded_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn closing_bounded_rx () { loom :: model (| | { let (tx1 , rx) = mpsc :: channel :: < () > (16) ; let tx2 = tx1 . clone () ; thread :: spawn (move | | { drop (rx) ; }) ; block_on (tx1 . closed ()) ; block_on (tx2 . closed ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_state",
                        "label": "get_state",
                        "kind": "Function",
                        "signature": "fn fn get_state (data : usize) -> usize { data & STATE_MASK } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all",
                        "label": "write_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_all () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { let n = cmp :: min (4 , buf . len ()) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; assert_ok ! (wr . write_all (b\"hello world\") . await) ; assert_eq ! (wr . buf , b\"hello world\" [..]) ; assert_eq ! (wr . cnt , 3) ; } . sig",
                        "file_path": "tokio/tests/io_write_all.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "flush",
                        "label": "flush",
                        "kind": "Function",
                        "signature": "fn fn flush () -> Poll < io :: Result < Op > > { Poll :: Ready (Ok (Op :: Flush)) } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "slice_to_uninit_mut",
                        "label": "slice_to_uninit_mut",
                        "kind": "Function",
                        "signature": "fn unsafe fn slice_to_uninit_mut (slice : & mut [u8]) -> & mut [MaybeUninit < u8 >] { & mut * (slice as * mut [u8] as * mut [MaybeUninit < u8 >]) } . sig",
                        "file_path": "tokio/src/io/read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WakerRef",
                        "label": "WakerRef",
                        "kind": "Trait",
                        "signature": "trait WakerRef",
                        "file_path": "tokio/src/sync/task/atomic_waker.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_close",
                        "label": "ctrl_close",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-close\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_close;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-CLOSE events.\"] # [doc = \"     let mut signal = ctrl_close()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-CLOSE event is received.\"] # [doc = \"     for countdown in (0..3).rev() {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got CTRL-CLOSE. {} more to exit\\\", countdown);\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_close () -> io :: Result < CtrlClose > { Ok (CtrlClose { inner : self :: imp :: ctrl_close () ? , }) } . sig",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_tasks_are_polled_after_tick",
                        "label": "local_tasks_are_polled_after_tick",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn local_tasks_are_polled_after_tick () { for _ in 0 .. 4 { let res = std :: panic :: catch_unwind (local_tasks_are_polled_after_tick_inner) ; if res . is_ok () { return ; } } local_tasks_are_polled_after_tick_inner () ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "aborts_task_on_drop",
                        "label": "aborts_task_on_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn aborts_task_on_drop () { let (mut tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; drop (handle) ; tx . closed () . await ; assert ! (tx . is_closed ()) ; } . sig",
                        "file_path": "tokio-util/tests/abort_on_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from_raw",
                        "label": "from_raw",
                        "kind": "Function",
                        "signature": "fn fn from_raw < T > (val : * mut T) -> Option < Box < T > > { if val . is_null () { None } else { Some (unsafe { Box :: from_raw (val) }) } } . sig",
                        "file_path": "tokio/src/util/atomic_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Aio",
                        "label": "Aio",
                        "kind": "Struct",
                        "signature": "struct Aio",
                        "file_path": "tokio/src/io/bsd/poll_aio.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "CurrentThread",
                        "label": "CurrentThread",
                        "kind": "Struct",
                        "signature": "struct CurrentThread",
                        "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "SmallWriter",
                        "label": "SmallWriter",
                        "kind": "Struct",
                        "signature": "struct SmallWriter",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Schedule",
                        "label": "Schedule",
                        "kind": "Trait",
                        "signature": "trait Schedule",
                        "file_path": "tokio/src/runtime/task/mod.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "duplicate_keys2",
                        "label": "duplicate_keys2",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn duplicate_keys2 () { let (send , recv) = oneshot :: channel :: < () > () ; let mut map = JoinMap :: new () ; map . spawn (1 , async { 1 }) ; map . spawn (1 , async { recv . await . unwrap () ; 2 }) ; assert_eq ! (map . len () , 1) ; tokio :: select ! { biased ; res = map . join_next () => match res { Some ((_key , res)) => panic ! (\"Task {res:?} exited.\") , None => panic ! (\"Phantom task completion.\") , } , () = tokio :: task :: yield_now () => { } , } send . send (()) . unwrap () ; let (key , res) = map . join_next () . await . unwrap () ; assert_eq ! (key , 1) ; assert_eq ! (res . unwrap () , 2) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters",
                        "label": "notify_waiters",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_waiters () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let tx = notify . clone () ; let notified1 = notify . notified () ; let notified2 = notify . notified () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; block_on (async { notified1 . await ; notified2 . await ; }) ; th . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_ident",
                        "label": "sync_one_ident",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_ident () { let one = one () ; let foo = tokio :: select ! { foo = one => foo , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_ids_match_multi_thread",
                        "label": "task_ids_match_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_ids_match_multi_thread () { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async { let id = rx . await . unwrap () ; assert_eq ! (id , task :: id ()) ; }) ; tx . send (handle . id ()) . unwrap () ; handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_no_stack_overflow",
                        "label": "assert_no_stack_overflow",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (test , not (loom)))] # [test] fn assert_no_stack_overflow () { struct Foo { _a : [u8 ; 2_000_000] , } assert_eq ! (Layout :: new ::< MaybeUninit < Block < Foo >>> () , Layout :: new ::< Block < Foo >> ()) ; let _block = Block :: < Foo > :: new (0) ; } . sig",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "max_permits_doesnt_panic",
                        "label": "max_permits_doesnt_panic",
                        "kind": "Function",
                        "signature": "fn # [test] fn max_permits_doesnt_panic () { Semaphore :: new (MAX_PERMITS) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Waiting",
                        "label": "Waiting",
                        "kind": "Struct",
                        "signature": "struct Waiting",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "SetOnce",
                        "label": "SetOnce",
                        "kind": "Struct",
                        "signature": "struct SetOnce",
                        "file_path": "tokio/src/sync/set_once.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_has_second_test_attr",
                        "label": "test_has_second_test_attr",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [test] async fn test_has_second_test_attr () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "canonicalize",
                        "label": "canonicalize",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns the canonical, absolute form of a path with all intermediate\"] # [doc = \" components normalized and symbolic links resolved.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::canonicalize`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `realpath` function on Unix\"] # [doc = \" and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" On Windows, this converts the path to use [extended length path][path]\"] # [doc = \" syntax, which allows your program to use longer path names, but means you\"] # [doc = \" can only join backslash-delimited paths to it, and it may be incompatible\"] # [doc = \" with other applications (if passed to the application on the command-line,\"] # [doc = \" or written to a file another application may read).\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \" [path]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * `path` does not exist.\"] # [doc = \" * A non-final component in path is not a directory.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::io;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     let path = fs::canonicalize(\\\"../a/../foo.txt\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn canonicalize (path : impl AsRef < Path >) -> io :: Result < PathBuf > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: canonicalize (path)) . await } . sig",
                        "file_path": "tokio/src/fs/canonicalize.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "State",
                        "label": "State",
                        "kind": "Struct",
                        "signature": "struct State",
                        "file_path": "tokio/src/sync/oneshot.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic_usage () { const NUM : usize = 2 ; struct Shared { semaphore : Semaphore , active : AtomicUsize , } async fn actor (shared : Arc < Shared >) { shared . semaphore . acquire (1) . await . unwrap () ; let actual = shared . active . fetch_add (1 , SeqCst) ; assert ! (actual <= NUM - 1) ; let actual = shared . active . fetch_sub (1 , SeqCst) ; assert ! (actual <= NUM) ; shared . semaphore . release (1) ; } loom :: model (| | { let shared = Arc :: new (Shared { semaphore : Semaphore :: new (NUM) , active : AtomicUsize :: new (0) , }) ; for _ in 0 .. NUM { let shared = shared . clone () ; thread :: spawn (move | | { block_on (actor (shared)) ; }) ; } block_on (actor (shared)) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_to_clone",
                        "label": "write_to_clone",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_to_clone () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut clone = file . try_clone () . await . unwrap () ; clone . write_all (HELLO) . await . unwrap () ; clone . flush () . await . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split_chan",
                        "label": "split_chan",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn split_chan () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let addr = socket . local_addr () . unwrap () ; let s = Arc :: new (socket) ; let r = s . clone () ; let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < (Vec < u8 > , std :: net :: SocketAddr) > (1_000) ; tokio :: spawn (async move { while let Some ((bytes , addr)) = rx . recv () . await { s . send_to (& bytes , & addr) . await . unwrap () ; } }) ; tokio :: spawn (async move { let mut buf = [0u8 ; 32] ; loop { let (len , addr) = r . recv_from (& mut buf) . await . unwrap () ; tx . send ((buf [.. len] . to_vec () , addr)) . await . unwrap () ; } }) ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . send_to (MSG , addr) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (len , _) = sender . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_curr_spawn_many_local",
                        "label": "rt_curr_spawn_many_local",
                        "kind": "Function",
                        "signature": "fn fn rt_curr_spawn_many_local (c : & mut Criterion) { let rt = rt () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_local\" , | b | { b . iter (| | { rt . block_on (async { for _ in 0 .. NUM_SPAWN { handles . push (tokio :: spawn (async move { })) ; } for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_shared",
                        "label": "read_shared",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_shared () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_some_initializing",
                        "label": "is_some_initializing",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn is_some_initializing () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; tokio :: spawn (async { ONCE . set (20) }) ; assert_eq ! (* ONCE . wait () . await , 20) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_open",
                        "label": "size_hint_stream_open",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_open () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; assert_eq ! (stream . size_hint () , (2 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , None)) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_not_closed_when_there_are_senders",
                        "label": "test_rx_unbounded_is_not_closed_when_there_are_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_closed_when_there_are_senders () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert ! (! rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_closes",
                        "label": "drop_closes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn drop_closes () { let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; std :: mem :: drop (afd_a) ; assert_eq ! (0 , b . read (& mut [0]) . unwrap ()) ; let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let _a : FileDescriptor = afd_a . into_inner () ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; let (a , mut b) = socketpair () ; let arc_fd = Arc :: new (a) ; let afd_a = AsyncFd :: new (ArcFd (arc_fd . clone ())) . unwrap () ; std :: mem :: drop (afd_a) ; assert_eq ! (ErrorKind :: WouldBlock , b . read (& mut [0]) . err () . unwrap () . kind ()) ; std :: mem :: drop (arc_fd) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_box_slice",
                        "label": "empty_box_slice",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_box_slice () { let coll : Box < [u32] > = stream :: empty () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "handler",
                        "label": "handler",
                        "kind": "Function",
                        "signature": "fn unsafe extern \"system\" fn handler (ty : u32) -> BOOL { let globals = globals () ; globals . record_event (ty as EventId) ; let event_was_handled = globals . broadcast () ; if event_was_handled && event_requires_infinite_sleep_in_handler (ty) { loop { std :: thread :: park () ; } } if event_was_handled { 1 } else { 0 } } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "IdleNotifiedSet",
                        "label": "IdleNotifiedSet",
                        "kind": "Struct",
                        "signature": "struct IdleNotifiedSet",
                        "file_path": "tokio/src/util/idle_notified_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "DropGuardRef",
                        "label": "DropGuardRef",
                        "kind": "Struct",
                        "signature": "struct DropGuardRef",
                        "file_path": "tokio-util/src/sync/cancellation_token/guard_ref.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length_big_burst",
                        "label": "lines_decoder_max_length_big_burst",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length_big_burst () { const MAX_LENGTH : usize = 10 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too long!\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "biased_one_not_ready",
                        "label": "biased_one_not_ready",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn biased_one_not_ready () { let (_tx1 , rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , rx2) = oneshot :: channel :: < i32 > () ; let (tx3 , rx3) = oneshot :: channel :: < i32 > () ; tx2 . send (2) . unwrap () ; tx3 . send (3) . unwrap () ; let v = tokio :: select ! { biased ; _ = rx1 => unreachable ! () , res = rx2 => { assert_ok ! (res) } , _ = rx3 => { panic ! (\"This branch should never be activated because `rx2` should be polled before `rx3` due to `biased;`.\") } } ; assert_eq ! (2 , v) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BacktraceFrame",
                        "label": "BacktraceFrame",
                        "kind": "Struct",
                        "signature": "struct BacktraceFrame",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "MetricsBatch",
                        "label": "MetricsBatch",
                        "kind": "Struct",
                        "signature": "struct MetricsBatch",
                        "file_path": "tokio/src/runtime/metrics/batch.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_closed_when_there_are_senders",
                        "label": "test_rx_is_not_closed_when_there_are_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_senders () { let (_tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (! rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StateCell",
                        "label": "StateCell",
                        "kind": "Struct",
                        "signature": "struct StateCell",
                        "file_path": "tokio/src/runtime/time/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_socket_pair",
                        "label": "test_socket_pair",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (target_os = \"netbsd\" , ignore = \"NetBSD does not support getpeereid() for sockets created by socketpair()\")] async fn test_socket_pair () { let (a , b) = UnixStream :: pair () . unwrap () ; let cred_a = a . peer_cred () . unwrap () ; let cred_b = b . peer_cred () . unwrap () ; assert_eq ! (cred_a , cred_b) ; let uid = unsafe { geteuid () } ; let gid = unsafe { getegid () } ; assert_eq ! (cred_a . uid () , uid) ; assert_eq ! (cred_a . gid () , gid) ; } . sig",
                        "file_path": "tokio/tests/uds_cred.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn split () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let path = dir . path () . join (\"split.sock\") ; let s = Arc :: new (UnixDatagram :: bind (path . clone ()) ?) ; let r = s . clone () ; let msg = b\"hello\" ; let (() , ()) = try_join ! { async { s . send_to (msg , path) . await ?; io :: Result :: Ok (()) } , async { let mut recv_buf = [0u8 ; 32] ; let (len , _) = r . recv_from (& mut recv_buf [..]) . await ?; assert_eq ! (& recv_buf [.. len] , msg) ; Ok (()) } , } ? ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_max_length_underrun",
                        "label": "any_delimiter_decoder_max_length_underrun",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_max_length_underrun () { const MAX_LENGTH : usize = 7 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"ong\\n\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"chunk 2\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\",\") ; assert_eq ! (\"chunk 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:0\" . to_string ()) ; let a = UdpSocket :: bind (& addr) . await ? ; let b = UdpSocket :: bind (& addr) . await ? ; let b_addr = b . local_addr () ? ; let mut a = UdpFramed :: new (a , BytesCodec :: new ()) ; let mut b = UdpFramed :: new (b , BytesCodec :: new ()) ; let a = ping (& mut a , b_addr) ; let b = pong (& mut b) ; match tokio :: try_join ! (a , b) { Err (e) => println ! (\"an error occurred; error = {e:?}\") , _ => println ! (\"done!\") , } Ok (()) } . sig",
                        "file_path": "examples/udp-codec.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_concurrent_uncontended_multi",
                        "label": "read_concurrent_uncontended_multi",
                        "kind": "Function",
                        "signature": "fn fn read_concurrent_uncontended_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent_multi\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval_at_panic_caller",
                        "label": "interval_at_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn interval_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = interval_at (Instant :: now () , Duration :: from_millis (0)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rwlock_blocking_write_panic_caller",
                        "label": "rwlock_blocking_write_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn rwlock_blocking_write_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let lock = RwLock :: < u8 > :: new (0) ; let _ = lock . blocking_write () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delay",
                        "label": "delay",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn delay () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; i . set_missed_tick_behavior (MissedTickBehavior :: Delay) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (201)) . await ; check_interval_poll ! (i , start , 1251) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1551) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1851) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_oneshot_creates_span",
                        "label": "test_oneshot_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_oneshot_creates_span () { let oneshot_span_id = expect :: id () ; let oneshot_span = expect :: span () . with_id (oneshot_span_id . clone ()) . named (\"runtime.resource\") . with_target (\"tokio::sync::oneshot\") ; let initial_tx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"tx_dropped\") . with_value (& false)) . with_fields (expect :: field (\"tx_dropped.op\") . with_value (& \"override\")) ; let final_tx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"tx_dropped\") . with_value (& true)) . with_fields (expect :: field (\"tx_dropped.op\") . with_value (& \"override\")) ; let initial_rx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"rx_dropped\") . with_value (& false)) . with_fields (expect :: field (\"rx_dropped.op\") . with_value (& \"override\")) ; let final_rx_dropped_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"rx_dropped\") . with_value (& true)) . with_fields (expect :: field (\"rx_dropped.op\") . with_value (& \"override\")) ; let value_sent_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"value_sent\") . with_value (& false)) . with_fields (expect :: field (\"value_sent.op\") . with_value (& \"override\")) ; let value_received_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"value_received\") . with_value (& false)) . with_fields (expect :: field (\"value_received.op\") . with_value (& \"override\")) ; let async_op_span_id = expect :: id () ; let async_op_span = expect :: span () . with_id (async_op_span_id . clone ()) . named (\"runtime.resource.async_op\") . with_target (\"tokio::sync::oneshot\") ; let async_op_poll_span = expect :: span () . named (\"runtime.resource.async_op.poll\") . with_target (\"tokio::sync::oneshot\") ; let (subscriber , handle) = subscriber :: mock () . new_span (oneshot_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& oneshot_span) . event (initial_tx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (initial_rx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (value_sent_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (value_received_event) . exit (& oneshot_span) . enter (& oneshot_span) . new_span (async_op_span . clone () . with_ancestry (expect :: has_contextual_parent (& oneshot_span_id)) ,) . exit (& oneshot_span) . enter (& async_op_span) . new_span (async_op_poll_span . clone () . with_ancestry (expect :: has_contextual_parent (& async_op_span_id)) ,) . exit (& async_op_span) . enter (& oneshot_span) . event (final_tx_dropped_event) . exit (& oneshot_span) . enter (& oneshot_span) . event (final_rx_dropped_event) . exit (& oneshot_span) . drop_span (oneshot_span) . drop_span (async_op_span) . drop_span (& async_op_poll_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: oneshot :: channel :: < bool > () ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: LocalRuntime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build_local (LocalOptions :: default ()) . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stdio",
                        "label": "stdio",
                        "kind": "Function",
                        "signature": "fn pub (super) fn stdio < T > (io : T) -> io :: Result < ChildStdio > where T : IntoRawFd , { let mut pipe = Pipe :: from (io) ; set_nonblocking (& mut pipe , true) ? ; PollEvented :: new (pipe) . map (| inner | ChildStdio { inner }) } . sig",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_blocking_without_name",
                        "label": "spawn_blocking_without_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_blocking_without_name () { let result = Builder :: new () . spawn_blocking (| | \"task executed\") . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_token_no_child",
                        "label": "drop_token_no_child",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_token_no_child () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let token2 = token . clone () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { drop (token2) ; }) ; let th3 = thread :: spawn (move | | { drop (token) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown",
                        "label": "shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn shutdown () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let accept = listener . accept () ; let connect = UnixStream :: connect (& sock_path) ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; AsyncWriteExt :: shutdown (& mut client) . await ? ; let mut buf = [0u8 ; 1] ; let n = server . read (& mut buf) . await ? ; assert_eq ! (n , 0) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_cancellation_token_owned_test",
                        "label": "pending_fut_with_cancellation_token_owned_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_cancellation_token_owned_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tcp_doesnt_block",
                        "label": "tcp_doesnt_block",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_doesnt_block () { let rt = rt () ; let listener = { let _enter = rt . enter () ; let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; TcpListener :: from_std (listener) . unwrap () } ; drop (rt) ; let mut task = task :: spawn (async move { assert_err ! (listener . accept () . await) ; }) ; assert_ready ! (task . poll ()) ; } . sig",
                        "file_path": "tokio/tests/io_driver_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_poll_after_enable",
                        "label": "test_poll_after_enable",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_poll_after_enable () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; assert_pending ! (future . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "forget",
                        "label": "forget",
                        "kind": "Function",
                        "signature": "fn # [test] fn forget () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p = sem . try_acquire () . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p . forget () ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 0) ; assert ! (sem . try_acquire () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_dir",
                        "label": "create_dir",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn create_dir () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: create_dir (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_basic_on_non_vectored",
                        "label": "write_vectored_basic_on_non_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_basic_on_non_vectored () { let msg = b\"foo bar baz\" ; let bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let mut w = BufWriter :: new (MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & bufs) . await) ; assert_eq ! (n , msg . len ()) ; assert ! (w . buffer () == & msg [..]) ; assert_ok ! (w . flush () . await) ; assert_eq ! (w . get_ref () . data , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_mandatory_blocking",
                        "label": "spawn_mandatory_blocking",
                        "kind": "Function",
                        "signature": "fn pub (super) fn spawn_mandatory_blocking < F , R > (f : F) -> Option < JoinHandle < R > > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let (tx , rx) = oneshot :: channel () ; let task = Box :: new (move | | { let _ = tx . send (f ()) ; }) ; QUEUE . with (| cell | cell . borrow_mut () . push_back (task)) ; Some (JoinHandle { rx }) } . sig",
                        "file_path": "tokio/src/fs/mocks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "select_is_budget_aware",
                        "label": "select_is_budget_aware",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn select_is_budget_aware () { const BUDGET : usize = 128 ; let task = | | { Box :: pin (async move { tokio :: select ! { biased ; () = tokio :: task :: coop :: consume_budget () => { } , () = std :: future :: ready (()) => { } } }) } ; for _ in 0 .. BUDGET { let poll = futures :: poll ! (& mut task ()) ; assert ! (poll . is_ready ()) ; } let poll = futures :: poll ! (& mut task ()) ; assert ! (poll . is_pending ()) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_inside_block_on_panic_caller",
                        "label": "task_id_inside_block_on_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (not (panic = \"unwind\") , ignore)] fn task_id_inside_block_on_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Runtime :: new () . unwrap () ; rt . block_on (async { task :: id () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "anon_pipe_from_owned_fd",
                        "label": "anon_pipe_from_owned_fd",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (target_os = \"linux\")] # [cfg_attr (miri , ignore)] async fn anon_pipe_from_owned_fd () -> std :: io :: Result < () > { use nix :: fcntl :: OFlag ; const DATA : & [u8] = b\"this is some data to write to the pipe\" ; let (rx_fd , tx_fd) = nix :: unistd :: pipe2 (OFlag :: O_CLOEXEC | OFlag :: O_NONBLOCK) ? ; let mut rx = pipe :: Receiver :: from_owned_fd (rx_fd) ? ; let mut tx = pipe :: Sender :: from_owned_fd (tx_fd) ? ; let mut buf = vec ! [0 ; DATA . len ()] ; tx . write_all (DATA) . await ? ; rx . read_exact (& mut buf) . await ? ; assert_eq ! (buf , DATA) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "one_ready_many_none",
                        "label": "one_ready_many_none",
                        "kind": "Function",
                        "signature": "fn # [test] fn one_ready_many_none () { for _ in 0 .. 100 { let mut map = task :: spawn (StreamMap :: new ()) ; map . insert (0 , pin_box (stream :: empty ())) ; map . insert (1 , pin_box (stream :: empty ())) ; map . insert (2 , pin_box (stream :: once (\"hello\"))) ; map . insert (3 , pin_box (stream :: pending ())) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v , (2 , \"hello\")) ; } } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_cancels_remote_tasks",
                        "label": "drop_cancels_remote_tasks",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"`unwrap()` in `with_timeout()` panics on Wasi\")] # [test] fn drop_cancels_remote_tasks () { with_timeout (Duration :: from_secs (60) , | | { let (tx , mut rx) = mpsc :: channel :: < () > (1024) ; let rt = rt () ; let local = LocalSet :: new () ; local . spawn_local (async move { while rx . recv () . await . is_some () { } }) ; local . block_on (& rt , async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (tx) ; drop (local) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SlabStorage",
                        "label": "SlabStorage",
                        "kind": "Struct",
                        "signature": "struct SlabStorage",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_until_fail",
                        "label": "read_until_fail",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_until_fail () { let mock = Builder :: new () . read (b\"Hello \\xffWor\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut chunk = b\"Foo\" . to_vec () ; let err = read . read_until (b'#' , & mut chunk) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (chunk , b\"FooHello \\xffWor\") ; } . sig",
                        "file_path": "tokio/tests/io_read_until.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LinkedList",
                        "label": "LinkedList",
                        "kind": "Struct",
                        "signature": "struct LinkedList",
                        "file_path": "tokio/src/util/linked_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unsplit_panic_caller",
                        "label": "unsplit_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn unsplit_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (r1 , _w1) = split (RW) ; let (_r2 , w2) = split (RW) ; r1 . unsplit (w2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_read_ready",
                        "label": "poll_read_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_read_ready () { let (mut client , mut server) = create_pair () . await ; assert_not_readable_by_polling ! (server) ; assert_ok ! (client . write_all (b\"ping\") . await) ; assert_readable_by_polling ! (server) ; let mut buf = [0u8 ; 4] ; assert_ok ! (server . read_exact (& mut buf) . await) ; assert_readable_by_polling ! (server) ; read_until_pending (& mut server) ; assert_not_readable_by_polling ! (server) ; drop (client) ; assert_readable_by_polling ! (server) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "insert_before_first_after_poll",
                        "label": "insert_before_first_after_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn insert_before_first_after_poll () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let _one = queue . insert_at (\"one\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; let _two = queue . insert_at (\"two\" , now + ms (100)) ; sleep (ms (99)) . await ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_spawn_loc_file_recorded",
                        "label": "task_spawn_loc_file_recorded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_spawn_loc_file_recorded () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"loc.file\") . with_value (& file ! ())) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; tokio :: spawn (futures :: future :: ready (())) . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "many_branches",
                        "label": "many_branches",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn many_branches () { let num = tokio :: select ! { x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , x = async { 1 } => x , } ; assert_eq ! (1 , num) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_delay_at_start",
                        "label": "multi_delay_at_start",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn multi_delay_at_start () { time :: pause () ; let long = 262_144 + 9 * 4096 ; let delays = & [1000 , 2 , 234 , long , 60 , 10] ; let mut queue = task :: spawn (DelayQueue :: new ()) ; for & i in delays { let _key = queue . insert_at (i , Instant :: now () + ms (i)) ; } assert_pending ! (poll ! (queue)) ; assert ! (! queue . is_woken ()) ; let start = Instant :: now () ; for elapsed in 0 .. 1200 { println ! (\"elapsed: {elapsed:?}\") ; let elapsed = elapsed + 1 ; tokio :: time :: sleep_until (start + ms (elapsed)) . await ; if delays . contains (& elapsed) { assert ! (queue . is_woken ()) ; assert_ready ! (poll ! (queue)) ; assert_pending ! (poll ! (queue)) ; } else if queue . is_woken () { let cascade = & [192 , 960] ; assert ! (cascade . contains (& elapsed) , \"elapsed={} dt={:?}\" , elapsed , Instant :: now () - start) ; assert_pending ! (poll ! (queue)) ; } } println ! (\"finished multi_delay_start\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_rx_while_values_remain",
                        "label": "drop_rx_while_values_remain",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_rx_while_values_remain () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_recv ! (rx1) ; assert_recv ! (rx2) ; drop (rx2) ; drop (rx1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Wait",
                        "label": "Wait",
                        "kind": "Trait",
                        "signature": "trait Wait",
                        "file_path": "tokio/src/process/unix/orphan.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [test] fn split () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut p1 = sem . clone () . try_acquire_many_owned (3) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 3) ; let mut p2 = p1 . split (1) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 2) ; assert_eq ! (p2 . num_permits () , 1) ; let p3 = p1 . split (0) . unwrap () ; assert_eq ! (p3 . num_permits () , 0) ; drop (p1) ; assert_eq ! (sem . available_permits () , 4) ; let p4 = p2 . split (1) . unwrap () ; assert_eq ! (p2 . num_permits () , 0) ; assert_eq ! (p4 . num_permits () , 1) ; assert ! (p2 . split (1) . is_none ()) ; drop (p2) ; assert_eq ! (sem . available_permits () , 4) ; drop (p3) ; assert_eq ! (sem . available_permits () , 4) ; drop (p4) ; assert_eq ! (sem . available_permits () , 5) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "run_until_cancelled_test",
                        "label": "run_until_cancelled_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn run_until_cancelled_test () { let (waker , _) = new_count_waker () ; { let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (std :: future :: pending :: < () > ()) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; token . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let (tx , rx) = oneshot :: channel :: < () > () ; let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (async move { rx . await . unwrap () ; 42 }) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; tx . send (()) . unwrap () ; assert_eq ! (Poll :: Ready (Some (42)) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let token = CancellationToken :: new () ; let fut = token . run_until_cancelled (async { panic ! (\"fut polled after cancellation\") }) ; pin ! (fut) ; token . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Expired",
                        "label": "Expired",
                        "kind": "Struct",
                        "signature": "struct Expired",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AcquireError",
                        "label": "AcquireError",
                        "kind": "Struct",
                        "signature": "struct AcquireError",
                        "file_path": "tokio/src/sync/batch_semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unsplit_err2",
                        "label": "unsplit_err2",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn unsplit_err2 () { let (_ , w) = split (RW) ; let (r , _) = split (RW) ; r . unsplit (w) ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DirEntry",
                        "label": "DirEntry",
                        "kind": "Struct",
                        "signature": "struct DirEntry",
                        "file_path": "tokio/src/fs/read_dir.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn fn main () { let user = create_user (\"Alice\" . to_string () , 30) ; println ! (\"{}\" , user . fmt ()) ; } . sig",
                        "file_path": "src/main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval",
                        "label": "interval",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates new [`Interval`] that yields with interval of `period`. The first\"] # [doc = \" tick completes immediately. The default [`MissedTickBehavior`] is\"] # [doc = \" [`Burst`](MissedTickBehavior::Burst), but this can be configured\"] # [doc = \" by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\"] # [doc = \"\"] # [doc = \" An interval will tick indefinitely. At any time, the [`Interval`] value can\"] # [doc = \" be dropped. This cancels the interval.\"] # [doc = \"\"] # [doc = \" This function is equivalent to\"] # [doc = \" [`interval_at(Instant::now(), period)`](interval_at).\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if `period` is zero.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{self, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut interval = time::interval(Duration::from_millis(10));\"] # [doc = \"\"] # [doc = \" interval.tick().await; // ticks immediately\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \"\"] # [doc = \" // approximately 20ms have elapsed.\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" A simple example using `interval` to execute a task every two seconds.\"] # [doc = \"\"] # [doc = \" The difference between `interval` and [`sleep`] is that an [`Interval`]\"] # [doc = \" measures the time since the last tick, which means that [`.tick().await`]\"] # [doc = \" may wait for a shorter time than the duration specified for the interval\"] # [doc = \" if some time has passed between calls to [`.tick().await`].\"] # [doc = \"\"] # [doc = \" If the tick in the example below was replaced with [`sleep`], the task\"] # [doc = \" would only be executed once every three seconds, and not every two\"] # [doc = \" seconds.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time;\"] # [doc = \"\"] # [doc = \" async fn task_that_takes_a_second() {\"] # [doc = \"     println!(\\\"hello\\\");\"] # [doc = \"     time::sleep(time::Duration::from_secs(1)).await\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut interval = time::interval(time::Duration::from_secs(2));\"] # [doc = \" for _i in 0..5 {\"] # [doc = \"     interval.tick().await;\"] # [doc = \"     task_that_takes_a_second().await;\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" [`sleep`]: crate::time::sleep()\"] # [doc = \" [`.tick().await`]: Interval::tick\"] # [track_caller] pub fn interval (period : Duration) -> Interval { assert ! (period > Duration :: new (0 , 0) , \"`period` must be non-zero.\") ; internal_interval_at (Instant :: now () , period , trace :: caller_location ()) } . sig",
                        "file_path": "tokio/src/time/interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_sender_send_item_panic_caller",
                        "label": "poll_sender_send_item_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_sender_send_item_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (send , _) = channel :: < u32 > (3) ; let mut send = PollSender :: new (send) ; let _ = send . send_item (42) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "build_child",
                        "label": "build_child",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn build_child (mut child : StdChild) -> io :: Result < SpawnedChild > { let stdin = child . stdin . take () . map (stdio) . transpose () ? ; let stdout = child . stdout . take () . map (stdio) . transpose () ? ; let stderr = child . stderr . take () . map (stdio) . transpose () ? ; # [cfg (all (target_os = \"linux\" , feature = \"rt\"))] match pidfd_reaper :: PidfdReaper :: new (child , GlobalOrphanQueue) { Ok (pidfd_reaper) => { return Ok (SpawnedChild { child : Child :: PidfdReaper (pidfd_reaper) , stdin , stdout , stderr , }) } Err ((Some (err) , _child)) => return Err (err) , Err ((None , child_returned)) => child = child_returned , } let signal = signal (SignalKind :: child ()) ? ; Ok (SpawnedChild { child : Child :: SignalReaper (Reaper :: new (child , GlobalOrphanQueue , signal)) , stdin , stdout , stderr , }) } . sig",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "non_cooperative_task",
                        "label": "non_cooperative_task",
                        "kind": "Function",
                        "signature": "fn async fn non_cooperative_task (permits : Arc < Semaphore >) -> Result < usize , String > { let mut exceeded_budget = 0 ; for _ in 0 .. 5 { for _ in 0 .. 128 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; } exceeded_budget += 1 ; } Ok (exceeded_budget) } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Pipe",
                        "label": "Pipe",
                        "kind": "Struct",
                        "signature": "struct Pipe",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "close_sender_before_reserve",
                        "label": "close_sender_before_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn close_sender_before_reserve () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_enter_blocking_region",
                        "label": "try_enter_blocking_region",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn try_enter_blocking_region () -> Option < BlockingRegionGuard > { CONTEXT . try_with (| c | { if c . runtime . get () . is_entered () { None } else { Some (BlockingRegionGuard :: new ()) } }) . unwrap_or_else (| _ | Some (BlockingRegionGuard :: new ())) } . sig",
                        "file_path": "tokio/src/runtime/context/blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AssertSend",
                        "label": "AssertSend",
                        "kind": "Trait",
                        "signature": "trait AssertSend",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "never_branch_no_warnings",
                        "label": "never_branch_no_warnings",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn never_branch_no_warnings () { let t = tokio :: select ! { _ = async_never () => 0 , one_async_ready = one () => one_async_ready , } ; assert_eq ! (t , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_42",
                        "label": "issue_42",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn issue_42 () { let join_handles = (0 .. 10usize) . map (| _ | { task :: spawn (async { let processes = (0 .. 10usize) . map (| i | { let mut child = Command :: new (\"echo\") . arg (format ! (\"I am spawned process #{i}\")) . stdin (Stdio :: null ()) . stdout (Stdio :: null ()) . stderr (Stdio :: null ()) . kill_on_drop (true) . spawn () . unwrap () ; async move { child . wait () . await } }) ; join_all (processes) . await ; }) }) ; join_all (join_handles) . await ; } . sig",
                        "file_path": "tokio/tests/process_issue_42.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_bounded_sender_blocking_send_panic_caller",
                        "label": "mpsc_bounded_sender_blocking_send_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_bounded_sender_blocking_send_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (tx , _rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = tx . blocking_send (3) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abort_all_during_completion",
                        "label": "abort_all_during_completion",
                        "kind": "Function",
                        "signature": "fn # [test] fn abort_all_during_completion () { use std :: sync :: { atomic :: { AtomicBool , Ordering :: SeqCst } , Arc , } ; let complete_happened = Arc :: new (AtomicBool :: new (false)) ; let cancel_happened = Arc :: new (AtomicBool :: new (false)) ; { let complete_happened = complete_happened . clone () ; let cancel_happened = cancel_happened . clone () ; loom :: model (move | | { let rt = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let mut set = JoinSet :: new () ; rt . block_on (async { set . spawn (async { () }) ; set . abort_all () ; match set . join_next () . await { Some (Ok (())) => complete_happened . store (true , SeqCst) , Some (Err (err)) if err . is_cancelled () => cancel_happened . store (true , SeqCst) , Some (Err (err)) => panic ! (\"fail: {}\" , err) , None => { unreachable ! (\"Aborting the task does not remove it from the JoinSet.\") } } assert ! (matches ! (set . join_next () . await , None)) ; }) ; drop (set) ; drop (rt) ; }) ; } assert ! (complete_happened . load (SeqCst)) ; assert ! (cancel_happened . load (SeqCst)) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadyOnTheSecondPollFuture",
                        "label": "ReadyOnTheSecondPollFuture",
                        "kind": "Struct",
                        "signature": "struct ReadyOnTheSecondPollFuture",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "select_streams",
                        "label": "select_streams",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn select_streams () { use tokio :: sync :: mpsc ; let (tx1 , mut rx1) = mpsc :: unbounded_channel :: < i32 > () ; let (tx2 , mut rx2) = mpsc :: unbounded_channel :: < i32 > () ; tokio :: spawn (async move { assert_ok ! (tx2 . send (1)) ; tokio :: task :: yield_now () . await ; assert_ok ! (tx1 . send (2)) ; tokio :: task :: yield_now () . await ; assert_ok ! (tx2 . send (3)) ; tokio :: task :: yield_now () . await ; drop ((tx1 , tx2)) ; }) ; let mut rem = true ; let mut msgs = vec ! [] ; while rem { tokio :: select ! { Some (x) = rx1 . recv () => { msgs . push (x) ; } Some (y) = rx2 . recv () => { msgs . push (y) ; } else => { rem = false ; } } } msgs . sort_unstable () ; assert_eq ! (& msgs [..] , & [1 , 2 , 3]) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MutexGuard",
                        "label": "MutexGuard",
                        "kind": "Struct",
                        "signature": "struct MutexGuard",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_notified_multi",
                        "label": "notify_notified_multi",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_notified_multi () { let notify = Arc :: new (Notify :: new ()) ; notify . notify_one () ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_long_sleeps",
                        "label": "multi_long_sleeps",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multi_long_sleeps () { tokio :: time :: pause () ; for _ in 0 .. 5u32 { tokio :: time :: sleep (Duration :: from_secs (365 * 24 * 3600 ,)) . await ; } let deadline = tokio :: time :: Instant :: now () + Duration :: from_secs (10 * 365 * 24 * 3600 ,) ; tokio :: time :: sleep_until (deadline) . await ; assert ! (tokio :: time :: Instant :: now () >= deadline) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "listen_and_stream",
                        "label": "listen_and_stream",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn listen_and_stream () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let peer_path = dir . path () . join (\"peer.sock\") ; let listener = { let sock = UnixSocket :: new_stream () ? ; sock . bind (& sock_path) ? ; sock . listen (1024) ? } ; let accept = listener . accept () ; let connect = { let sock = UnixSocket :: new_stream () ? ; sock . bind (& peer_path) ? ; sock . connect (& sock_path) } ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; assert_eq ! (server . peer_addr () . unwrap () . as_pathname () . unwrap () , & peer_path) ; client . write_all (b\"hello\") . await ? ; drop (client) ; let mut buf = vec ! [] ; server . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf , b\"hello\") ; let len = server . read (& mut buf) . await ? ; assert_eq ! (len , 0) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "start_send_panics_when_idle",
                        "label": "start_send_panics_when_idle",
                        "kind": "Function",
                        "signature": "fn # [should_panic] # [test] fn start_send_panics_when_idle () { let (send , _) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; send . send_item (1) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "derives_send_sync",
                        "label": "derives_send_sync",
                        "kind": "Function",
                        "signature": "fn # [test] fn derives_send_sync () { fn assert_send < T : Send > () { } fn assert_sync < T : Sync > () { } assert_send :: < CancellationToken > () ; assert_sync :: < CancellationToken > () ; assert_send :: < WaitForCancellationFuture < 'static > > () ; assert_sync :: < WaitForCancellationFuture < 'static > > () ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "vtable",
                        "label": "vtable",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Get the vtable for the requested `T` and `S` generics.\"] pub (super) fn vtable < T : Future , S : Schedule > () -> & 'static Vtable { & Vtable { poll : poll :: < T , S > , schedule : schedule :: < S > , dealloc : dealloc :: < T , S > , try_read_output : try_read_output :: < T , S > , drop_join_handle_slow : drop_join_handle_slow :: < T , S > , drop_abort_handle : drop_abort_handle :: < T , S > , shutdown : shutdown :: < T , S > , trailer_offset : OffsetHelper :: < T , S > :: TRAILER_OFFSET , scheduler_offset : OffsetHelper :: < T , S > :: SCHEDULER_OFFSET , id_offset : OffsetHelper :: < T , S > :: ID_OFFSET , # [cfg (tokio_unstable)] spawn_location_offset : OffsetHelper :: < T , S > :: SPAWN_LOCATION_OFFSET , } } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SelectNormal",
                        "label": "SelectNormal",
                        "kind": "Struct",
                        "signature": "struct SelectNormal",
                        "file_path": "tokio/src/macros/join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Scoped",
                        "label": "Scoped",
                        "kind": "Struct",
                        "signature": "struct Scoped",
                        "file_path": "tokio/src/runtime/context/scoped.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "concurrent_cancel",
                        "label": "concurrent_cancel",
                        "kind": "Function",
                        "signature": "fn # [test] fn concurrent_cancel () { async fn poll_and_cancel (semaphore : Arc < Semaphore >) { let mut acquire1 = Some (semaphore . acquire (1)) ; let mut acquire2 = Some (semaphore . acquire (1)) ; poll_fn (| cx | { if let Some (acquire) = acquire1 . take () { pin ! (acquire) ; let _ = acquire . poll (cx) ; } if let Some (acquire) = acquire2 . take () { pin ! (acquire) ; let _ = acquire . poll (cx) ; } Poll :: Ready (()) }) . await } loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (0)) ; let t1 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; let t2 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; let t3 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | block_on (poll_and_cancel (semaphore))) } ; t1 . join () . unwrap () ; semaphore . release (10) ; t2 . join () . unwrap () ; t3 . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "once",
                        "label": "once",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a stream that emits an element exactly once.\"] # [doc = \"\"] # [doc = \" The returned stream is immediately ready and emits the provided value once.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" // one is the loneliest number\"] # [doc = \" let mut one = stream::once(1);\"] # [doc = \"\"] # [doc = \" assert_eq!(Some(1), one.next().await);\"] # [doc = \"\"] # [doc = \" // just one, that's all we get\"] # [doc = \" assert_eq!(None, one.next().await);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn once < T > (value : T) -> Once < T > { Once { iter : crate :: iter (Some (value)) , } } . sig",
                        "file_path": "tokio-stream/src/once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (tokio_unstable , tokio_taskdump , target_os = \"linux\" , any (target_arch = \"aarch64\" , target_arch = \"x86\" , target_arch = \"x86_64\")))] # [tokio :: main] async fn main () -> Result < () , Box < dyn std :: error :: Error > > { use std :: sync :: Arc ; use tokio :: sync :: Barrier ; # [inline (never)] async fn a (barrier : Arc < Barrier >) { b (barrier) . await } # [inline (never)] async fn b (barrier : Arc < Barrier >) { c (barrier) . await } # [inline (never)] async fn c (barrier : Arc < Barrier >) { barrier . wait () . await ; } async fn dump_or_quit () { use tokio :: time :: { timeout , Duration , Instant } ; let handle = tokio :: runtime :: Handle :: current () ; let mut last_signal : Option < Instant > = None ; while let Ok (_) = tokio :: signal :: ctrl_c () . await { if let Some (time_since_last_signal) = last_signal . map (| i | i . elapsed ()) { if time_since_last_signal < Duration :: from_secs (1) { return ; } } last_signal = Some (Instant :: now ()) ; println ! (\"{:-<80}\" , \"\") ; if let Ok (dump) = timeout (Duration :: from_secs (2) , handle . dump ()) . await { for task in dump . tasks () . iter () { let id = task . id () ; let trace = task . trace () ; println ! (\"TASK {id}:\") ; println ! (\"{trace}\\n\") ; } } else { println ! (\"Task dumping timed out. Use a native debugger (like gdb) to debug the deadlock.\") ; } println ! (\"{:-<80}\" , \"\") ; println ! (\"Input CTRL+C twice within 1 second to exit.\") ; } } println ! (\"This program has a deadlock.\") ; println ! (\"Input CTRL+C to print a task dump.\") ; println ! (\"Input CTRL+C twice within 1 second to exit.\") ; let barrier = Arc :: new (Barrier :: new (3)) ; let task_1 = tokio :: spawn (a (barrier . clone ())) ; let task_2 = tokio :: spawn (a (barrier)) ; tokio :: select ! (_ = dump_or_quit () => { } , _ = task_1 => { } , _ = task_2 => { } ,) ; Ok (()) } . sig",
                        "file_path": "examples/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_child_token_without_parent",
                        "label": "cancel_child_token_without_parent",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_child_token_without_parent () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let child_token_1 = token . child_token () ; let child_fut = child_token_1 . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; child_token_1 . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (! token . is_cancelled ()) ; assert ! (child_token_1 . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; let child_token_2 = token . child_token () ; let child_fut_2 = child_token_2 . cancelled () ; pin ! (child_fut_2) ; assert_eq ! (Poll :: Pending , child_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; token . cancel () ; assert_eq ! (wake_counter , 3) ; assert ! (token . is_cancelled ()) ; assert ! (child_token_2 . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Counters",
                        "label": "Counters",
                        "kind": "Struct",
                        "signature": "struct Counters",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/counters.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "block_in_blocking",
                        "label": "block_in_blocking",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn block_in_blocking () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { assert_ok ! (task :: spawn_blocking (|| { task :: block_in_place (|| { thread :: sleep (Duration :: from_millis (5)) ; }) ; \"hello\" }) . await) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_break",
                        "label": "ctrl_break",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_break () -> io :: Result < RxFuture > { new (console :: CTRL_BREAK_EVENT) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_create_medium",
                        "label": "bench_create_medium",
                        "kind": "Function",
                        "signature": "fn fn bench_create_medium (c : & mut Criterion) { let mut group = c . benchmark_group (\"create_medium\") ; create_medium :: < 1 > (& mut group) ; create_medium :: < 100 > (& mut group) ; create_medium :: < 100_000 > (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TempFifo",
                        "label": "TempFifo",
                        "kind": "Struct",
                        "signature": "struct TempFifo",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "TryLockError",
                        "label": "TryLockError",
                        "kind": "Struct",
                        "signature": "struct TryLockError",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "PanicsOnDrop",
                        "label": "PanicsOnDrop",
                        "kind": "Struct",
                        "signature": "struct PanicsOnDrop",
                        "file_path": "tokio/tests/join_handle_panic.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "copy_mem_to_slow_hdd",
                        "label": "copy_mem_to_slow_hdd",
                        "kind": "Function",
                        "signature": "fn fn copy_mem_to_slow_hdd (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_mem_to_slow_hdd\" , | b | { b . iter (| | { let task = | | async { let mut source = repeat (0) . take (SOURCE_SIZE) ; let mut dest = SlowHddWriter :: new (WRITE_SERVICE_PERIOD , WRITE_BUFFER) ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "file_debug_fmt",
                        "label": "file_debug_fmt",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn file_debug_fmt () { let tempfile = tempfile () ; let file = File :: open (tempfile . path ()) . await . unwrap () ; assert_eq ! (& format ! (\"{:?}\" , file) [0 .. 37] , \"tokio::fs::File { std: File { handle:\") ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AssertUnwindSafe",
                        "label": "AssertUnwindSafe",
                        "kind": "Trait",
                        "signature": "trait AssertUnwindSafe",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "expect_task_named",
                        "label": "expect_task_named",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Expect a task with name\"] # [doc = \"\"] # [doc = \" This is a convenience function to create the expectation for a new task\"] # [doc = \" with the `task.name` field set to the provided name.\"] fn expect_task_named (name : & str) -> NewSpan { expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"task.name\") . with_value (& tracing :: field :: debug (format_args ! (\"{name}\"))) ,) } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalEnterGuard",
                        "label": "LocalEnterGuard",
                        "kind": "Struct",
                        "signature": "struct LocalEnterGuard",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn split (stream : & mut UnixStream) -> (ReadHalf < '_ > , WriteHalf < '_ >) { (ReadHalf (stream) , WriteHalf (stream)) } . sig",
                        "file_path": "tokio/src/net/unix/split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_nonblocking",
                        "label": "is_nonblocking",
                        "kind": "Function",
                        "signature": "fn fn is_nonblocking < T : AsRawFd > (fd : & T) -> io :: Result < bool > { let flags = nix :: fcntl :: fcntl (fd . as_raw_fd () , nix :: fcntl :: F_GETFL) ? ; Ok ((flags & libc :: O_NONBLOCK) != 0) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_already_cancelled_token_test",
                        "label": "pending_fut_with_already_cancelled_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_already_cancelled_token_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 0) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read",
                        "label": "read",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tries to read some bytes directly into the given `buf` in asynchronous\"] # [doc = \" manner, returning a future type.\"] # [doc = \"\"] # [doc = \" The returned future will resolve to both the I/O stream and the buffer\"] # [doc = \" as well as the number of bytes read once the read operation is completed.\"] pub (crate) fn read < 'a , R > (reader : & 'a mut R , buf : & 'a mut [u8]) -> Read < 'a , R > where R : AsyncRead + Unpin + ? Sized , { Read { reader , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_task_that_panics_on_drop_returned",
                        "label": "test_abort_task_that_panics_on_drop_returned",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that aborting a task whose destructor panics has the expected result.\"] # [test] # [cfg (panic = \"unwind\")] fn test_abort_task_that_panics_on_drop_returned () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { let _panic_dropped = PanicOnDrop ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; assert ! (handle . await . unwrap_err () . is_panic ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_on_last_task_respawn",
                        "label": "notify_on_last_task_respawn",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_on_last_task_respawn () { let tracker = TaskTracker :: new () ; tracker . close () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; let token2 = tracker . token () ; assert_ready ! (wait . poll ()) ; drop (token2) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "feed_cat",
                        "label": "feed_cat",
                        "kind": "Function",
                        "signature": "fn async fn feed_cat (mut cat : Child , n : usize) -> io :: Result < ExitStatus > { let mut stdin = cat . stdin . take () . unwrap () ; let stdout = cat . stdout . take () . unwrap () ; let write = async { for i in 0 .. n { let bytes = format ! (\"line {i}\\n\") . into_bytes () ; stdin . write_all (& bytes) . await . unwrap () ; } drop (stdin) ; } ; let read = async { let mut reader = BufReader :: new (stdout) . lines () ; let mut num_lines = 0 ; loop { let data = reader . next_line () . await . unwrap_or_else (| _ | Some (String :: new ())) . expect (\"failed to read line\") ; let num_read = data . len () ; let done = num_lines >= n ; match (done , num_read) { (false , 0) => panic ! (\"broken pipe\") , (true , n) if n != 0 => panic ! (\"extraneous data\") , _ => { let expected = format ! (\"line {num_lines}\") ; assert_eq ! (expected , data) ; } } ; num_lines += 1 ; if num_lines >= n { break ; } } } ; future :: join3 (write , read , cat . wait ()) . map (| (_ , _ , status) | status) . await } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_bridge_new_panic_caller",
                        "label": "sync_bridge_new_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn sync_bridge_new_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = SyncIoBridge :: new (tokio :: io :: empty ()) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BlockingRegionGuard",
                        "label": "BlockingRegionGuard",
                        "kind": "Struct",
                        "signature": "struct BlockingRegionGuard",
                        "file_path": "tokio/src/runtime/context/blocking.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Tasks",
                        "label": "Tasks",
                        "kind": "Struct",
                        "signature": "struct Tasks",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage_v6",
                        "label": "basic_usage_v6",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage_v6 () { let addr = assert_ok ! (\"[::1]:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v6 ()) ; assert_ok ! (srv . bind (addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v6 ()) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
                        "file_path": "tokio/tests/tcp_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local",
                        "label": "local",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Create a new local run-queue\"] pub (crate) fn local < T : 'static > () -> (Steal < T > , Local < T >) { let mut buffer = Vec :: with_capacity (LOCAL_QUEUE_CAPACITY) ; for _ in 0 .. LOCAL_QUEUE_CAPACITY { buffer . push (UnsafeCell :: new (MaybeUninit :: uninit ())) ; } let inner = Arc :: new (Inner { head : AtomicUnsignedLong :: new (0) , tail : AtomicUnsignedShort :: new (0) , buffer : make_fixed_size (buffer . into_boxed_slice ()) , }) ; let local = Local { inner : inner . clone () , } ; let remote = Steal (inner) ; (remote , local) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_link",
                        "label": "read_link",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Reads a symbolic link, returning the file that the link points to.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read_link`].\"] pub async fn read_link (path : impl AsRef < Path >) -> io :: Result < PathBuf > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read_link (path)) . await } . sig",
                        "file_path": "tokio/src/fs/read_link.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_read_shared_pending",
                        "label": "write_read_shared_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_read_shared_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; let mut t3 = spawn (rwlock . write ()) ; assert_pending ! (t3 . poll ()) ; let mut t4 = spawn (rwlock . read ()) ; assert_pending ! (t4 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_write",
                        "label": "try_read_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_read_write () -> std :: io :: Result < () > { let msg = b\"hello world\" ; let dir = tempfile :: tempdir () ? ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = UnixListener :: bind (& bind_path) ? ; let client = UnixStream :: connect (& bind_path) . await ? ; let (server , _) = listener . accept () . await ? ; let mut written = msg . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await ? ; assert_eq ! (msg . len () , client . try_write (msg) ?) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (msg) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await ? ; match server . try_read (& mut read [i ..]) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } written . clear () ; client . writable () . await . unwrap () ; let msg_bufs : Vec < _ > = msg . chunks (3) . map (io :: IoSlice :: new) . collect () ; loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write_vectored (& msg_bufs) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await ? ; let mut bufs : Vec < _ > = read [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match server . try_read_vectored (& mut bufs) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await ? ; if ready . is_read_closed () { break ; } else { tokio :: task :: yield_now () . await ; } } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CoreGuard",
                        "label": "CoreGuard",
                        "kind": "Struct",
                        "signature": "struct CoreGuard",
                        "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "compact_expire_empty",
                        "label": "compact_expire_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_expire_empty () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; assert_eq ! (queue . len () , 0) ; assert_eq ! (queue . capacity () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timeout_is_not_exhausted_by_future",
                        "label": "timeout_is_not_exhausted_by_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn timeout_is_not_exhausted_by_future () { let fut = timeout (ms (1) , async { let mut buffer = [0u8 ; 1] ; loop { use tokio :: io :: AsyncReadExt ; let _ = tokio :: io :: empty () . read (& mut buffer) . await ; } }) ; assert ! (fut . await . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_enough",
                        "label": "poll_next_many_enough",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 2)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_err",
                        "label": "ready_err",
                        "kind": "Function",
                        "signature": "fn fn ready_err () -> Poll < Result < () , () > > { Poll :: Ready (Err (())) } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SendError",
                        "label": "SendError",
                        "kind": "Struct",
                        "signature": "struct SendError",
                        "file_path": "tokio/src/sync/mpsc/error.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sync_all_ordered_after_write",
                        "label": "sync_all_ordered_after_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn sync_all_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_all () . once () . returning (| | Ok (())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_all ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_closed_when_dropping_all_senders",
                        "label": "test_rx_unbounded_is_closed_when_dropping_all_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_dropping_all_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let another_tx = tx . clone () ; let task = tokio :: spawn (async move { drop (another_tx) ; }) ; drop (tx) ; let _ = task . await ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_rx_closes_channel",
                        "label": "dropping_rx_closes_channel",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn dropping_rx_closes_channel () { let (tx , rx) = mpsc :: channel (100) ; let msg = Arc :: new (()) ; assert_ok ! (tx . try_send (msg . clone ())) ; drop (rx) ; assert_err ! (tx . reserve () . await) ; assert_err ! (tx . reserve_many (10) . await) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_signal",
                        "label": "send_signal",
                        "kind": "Function",
                        "signature": "fn pub fn send_signal (signal : libc :: c_int) { use libc :: { getpid , kill } ; unsafe { let pid = getpid () ; assert_eq ! (kill (pid , signal) , 0 , \"kill(pid = {}, {}) failed with error: {}\" , pid , signal , std :: io :: Error :: last_os_error () ,) ; } } . sig",
                        "file_path": "tokio/tests/support/signal.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Snapshot",
                        "label": "Snapshot",
                        "kind": "Struct",
                        "signature": "struct Snapshot",
                        "file_path": "tokio/src/runtime/task/state.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "debug_format",
                        "label": "debug_format",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn debug_format () { let s = \"debug\" ; let m = Mutex :: new (s . to_string ()) ; assert_eq ! (format ! (\"{s:?}\") , format ! (\"{:?}\" , m . lock () . await)) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all",
                        "label": "write_all",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn write_all < 'a , W > (writer : & 'a mut W , buf : & 'a [u8]) -> WriteAll < 'a , W > where W : AsyncWrite + Unpin + ? Sized , { WriteAll { writer , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/write_all.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stress2",
                        "label": "stress2",
                        "kind": "Function",
                        "signature": "fn # [test] fn stress2 () { const NUM_ITER : usize = 1 ; const NUM_TASKS : usize = normal_or_miri (1_000_000 , 50) ; const NUM_STEAL : usize = normal_or_miri (1_000 , 10) ; let mut stats = new_stats () ; for _ in 0 .. NUM_ITER { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. NUM_STEAL { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } thread :: sleep (Duration :: from_micros (10)) ; } n }) ; let mut num_pop = 0 ; for i in 0 .. NUM_TASKS { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; if i % 128 == 0 && local . pop () . is_some () { num_pop += 1 ; } num_pop += inject . borrow_mut () . drain (..) . count () ; } num_pop += th . join () . unwrap () ; while local . pop () . is_some () { num_pop += 1 ; } num_pop += inject . borrow_mut () . drain (..) . count () ; assert_eq ! (num_pop , NUM_TASKS) ; } } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_file_from_unix_fd",
                        "label": "read_file_from_unix_fd",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (unix)] async fn read_file_from_unix_fd () { use std :: os :: unix :: io :: { FromRawFd , IntoRawFd } ; let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let file1 = File :: open (tempfile . path ()) . await . unwrap () ; let raw_fd = file1 . into_std () . await . into_raw_fd () ; assert ! (raw_fd > 0) ; let mut file2 = unsafe { File :: from_raw_fd (raw_fd) } ; let mut buf = [0 ; 1024] ; let n = file2 . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_count_when_dropped",
                        "label": "sender_strong_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_count_when_dropped () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "insert_after_ready_poll",
                        "label": "insert_after_ready_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn insert_after_ready_poll () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"1\" , now + ms (100)) ; queue . insert_at (\"2\" , now + ms (100)) ; queue . insert_at (\"3\" , now + ms (100)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let mut res = vec ! [] ; while res . len () < 3 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; queue . insert_at (\"foo\" , now + ms (500)) ; } res . sort_unstable () ; assert_eq ! (\"1\" , res [0]) ; assert_eq ! (\"2\" , res [1]) ; assert_eq ! (\"3\" , res [2]) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_timeout_job",
                        "label": "spawn_timeout_job",
                        "kind": "Function",
                        "signature": "fn async fn spawn_timeout_job (iters : usize , procs : usize) { let mut handles = Vec :: with_capacity (procs) ; for _ in 0 .. procs { handles . push (tokio :: spawn (async move { for _ in 0 .. iters / procs { let h = timeout (Duration :: from_secs (1) , quick_job ()) ; assert_eq ! (black_box (h . await . unwrap ()) , 1) ; } })) ; } for handle in handles { handle . await . unwrap () ; } } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "weak_sender",
                        "label": "weak_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn weak_sender () { let (tx , mut rx) = channel (11) ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Ok (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } Err (_) => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_spawn_blocking",
                        "label": "task_id_spawn_blocking",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn_blocking () { task :: spawn_blocking (| | println ! (\"task id: {}\" , task :: id ())) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_on_drop",
                        "label": "test_abort_on_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_abort_on_drop () { let mut set = JoinSet :: new () ; let mut recvs = Vec :: new () ; for _ in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; set . spawn (async { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (set) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_out_of_bounds_close_to_max",
                        "label": "no_out_of_bounds_close_to_max",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn no_out_of_bounds_close_to_max () { time :: pause () ; time :: sleep (Duration :: MAX - Duration :: from_millis (1)) . await ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_fut_with_already_cancelled_token_owned_test",
                        "label": "ready_fut_with_already_cancelled_token_owned_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn ready_fut_with_already_cancelled_token_owned_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let ready_fut = ready (()) ; let ready_fut_with_token_fut = ready_fut . with_cancellation_token_owned (token) ; pin ! (ready_fut_with_token_fut) ; let res = ready_fut_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unsplit_ok",
                        "label": "unsplit_ok",
                        "kind": "Function",
                        "signature": "fn # [test] fn unsplit_ok () { let (r , w) = split (RW) ; r . unsplit (w) ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "transfer_one_direction",
                        "label": "transfer_one_direction",
                        "kind": "Function",
                        "signature": "fn fn transfer_one_direction < A , B > (cx : & mut Context < '_ > , state : & mut TransferState , r : & mut A , w : & mut B ,) -> Poll < io :: Result < u64 > > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { let mut r = Pin :: new (r) ; let mut w = Pin :: new (w) ; loop { match state { TransferState :: Running (buf) => { let count = ready ! (buf . poll_copy (cx , r . as_mut () , w . as_mut ())) ? ; * state = TransferState :: ShuttingDown (count) ; } TransferState :: ShuttingDown (count) => { ready ! (w . as_mut () . poll_shutdown (cx)) ? ; * state = TransferState :: Done (* count) ; } TransferState :: Done (count) => return Poll :: Ready (Ok (* count)) , } } } . sig",
                        "file_path": "tokio/src/io/util/copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_is_not_async",
                        "label": "test_is_not_async",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] fn test_is_not_async () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Blocking",
                        "label": "Blocking",
                        "kind": "Struct",
                        "signature": "struct Blocking",
                        "file_path": "tokio/src/io/blocking.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "shutdown_immediately",
                        "label": "shutdown_immediately",
                        "kind": "Function",
                        "signature": "fn # [test] fn shutdown_immediately () { with (| rt | { rt . spawn (async { loop { crate :: task :: yield_now () . await ; } }) ; rt . shutdown () ; }) } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_buf_err",
                        "label": "write_buf_err",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_buf_err () { # [doc = \" Error out after writing the first 4 bytes\"] struct Wr { cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { self . cnt += 1 ; if self . cnt == 2 { return Poll :: Ready (Err (io :: Error :: new (io :: ErrorKind :: Other , \"whoops\"))) ; } Poll :: Ready (Ok (4)) } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { cnt : 0 } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\"world\")) ; assert_err ! (wr . write_all_buf (& mut buf) . await) ; assert_eq ! (buf . copy_to_bytes (buf . remaining ()) , Bytes :: from_static (b\"oworld\")) ; } . sig",
                        "file_path": "tokio/tests/io_write_all_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_two",
                        "label": "sync_two",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_two () { use std :: cell :: Cell ; let cnt = Cell :: new (0) ; let res = tokio :: select ! { foo = async { cnt . set (cnt . get () + 1) ; 1 } => foo , bar = async { cnt . set (cnt . get () + 1) ; 2 } => bar , } ; assert_eq ! (1 , cnt . get ()) ; assert ! (res == 1 || res == 2) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_in_block_in_place",
                        "label": "yield_in_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_in_block_in_place () { test_with_runtimes (| | { Handle :: current () . block_on (async { tokio :: task :: block_in_place (| | { Handle :: current () . block_on (tokio :: task :: yield_now ()) ; }) ; }) ; }) } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WakerRef",
                        "label": "WakerRef",
                        "kind": "Struct",
                        "signature": "struct WakerRef",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "create_tmp_files",
                        "label": "create_tmp_files",
                        "kind": "Function",
                        "signature": "fn fn create_tmp_files (num_files : usize) -> (Vec < NamedTempFile > , Vec < PathBuf >) { let mut files = Vec :: with_capacity (num_files) ; for _ in 0 .. num_files { let tmp = NamedTempFile :: new () . unwrap () ; let path = tmp . path () . to_path_buf () ; files . push ((tmp , path)) ; } files . into_iter () . unzip () } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "buf_writer",
                        "label": "buf_writer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn buf_writer () { let mut writer = BufWriter :: with_capacity (2 , Vec :: new ()) ; assert_eq ! (writer . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; assert_eq ! (writer . write (& [2]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2]) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; assert_eq ! (writer . write (& [3]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2 , 3]) ; assert_eq ! (* writer . get_ref () , [0 , 1]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [4]) . await . unwrap () , 1) ; assert_eq ! (writer . write (& [5]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [4 , 5]) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [6]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [6]) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5]) ; assert_eq ! (writer . write (& [7 , 8]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8]) ; assert_eq ! (writer . write (& [9 , 10 , 11]) . await . unwrap () , 3) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (* writer . get_ref () , [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_drop_upgrade_unbounded",
                        "label": "downgrade_drop_upgrade_unbounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_drop_upgrade_unbounded () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "nested",
                        "label": "nested",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn nested () { let res = tokio :: select ! { x = async { 1 } => { tokio :: select ! { y = async { 2 } => x + y , } } } ; assert_eq ! (res , 3) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
                        "label": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let _weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_closed",
                        "label": "write_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn write_closed () { let (mut client , mut server) = create_pair () . await ; let write_size = write_until_pending (& mut client) ; let mut ready_fut = task :: spawn (client . ready (Interest :: WRITABLE)) ; assert_pending ! (ready_fut . poll ()) ; let mut read_size = 0 ; while read_size < write_size { server . readable () . await . unwrap () ; read_size += read_until_pending (& mut server) ; } let ready_event = assert_ok ! (ready_fut . await) ; assert ! (! ready_event . is_write_closed ()) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_after",
                        "label": "reset_after",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_after () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_after (Duration :: from_millis (20)) ; time :: advance (ms (20)) . await ; check_interval_poll ! (i , start , 421) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 721) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_ping_pong",
                        "label": "rt_multi_ping_pong",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_ping_pong (c : & mut Criterion) { const NUM_PINGS : usize = 1_000 ; let rt = rt () ; let (done_tx , done_rx) = mpsc :: sync_channel (1000) ; let rem = Arc :: new (AtomicUsize :: new (0)) ; c . bench_function (\"ping_pong\" , | b | { b . iter (| | { let done_tx = done_tx . clone () ; let rem = rem . clone () ; rem . store (NUM_PINGS , Relaxed) ; rt . block_on (async { tokio :: spawn (async move { for _ in 0 .. NUM_PINGS { let rem = rem . clone () ; let done_tx = done_tx . clone () ; tokio :: spawn (async move { let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; tokio :: spawn (async move { rx1 . await . unwrap () ; tx2 . send (()) . unwrap () ; }) ; tx1 . send (()) . unwrap () ; rx2 . await . unwrap () ; if 1 == rem . fetch_sub (1 , Relaxed) { done_tx . send (()) . unwrap () ; } }) ; } }) ; done_rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "regression_3710_with_submillis_advance",
                        "label": "regression_3710_with_submillis_advance",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn regression_3710_with_submillis_advance () { let start = Instant :: now () ; time :: advance (Duration :: from_millis (1)) . await ; let mut sleep = task :: spawn (time :: sleep_until (start + Duration :: from_secs (60))) ; assert_pending ! (sleep . poll ()) ; let before = Instant :: now () ; let dur = Duration :: from_micros (51_592) ; time :: advance (dur) . await ; assert_eq ! (before . elapsed () , dur) ; assert_pending ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new_multi_thread",
                        "label": "new_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Create a new multi threaded runtime\"] # [cfg (not (target_os = \"wasi\"))] fn new_multi_thread (n : usize) -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (n) . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_file",
                        "label": "remove_file",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn remove_file () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; assert ! (fs :: try_exists (& file_path) . await . unwrap ()) ; fs :: remove_file (& file_path) . await . unwrap () ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_file\") , } ; } . sig",
                        "file_path": "tokio/tests/fs_remove_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duplex",
                        "label": "duplex",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Create a new pair of `DuplexStream`s that act like a pair of connected sockets.\"] # [doc = \"\"] # [doc = \" The `max_buf_size` argument is the maximum amount of bytes that can be\"] # [doc = \" written to a side before the write returns `Poll::Pending`.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub fn duplex (max_buf_size : usize) -> (DuplexStream , DuplexStream) { let one = Arc :: new (Mutex :: new (SimplexStream :: new_unsplit (max_buf_size))) ; let two = Arc :: new (Mutex :: new (SimplexStream :: new_unsplit (max_buf_size))) ; (DuplexStream { read : one . clone () , write : two . clone () , } , DuplexStream { read : two , write : one , } ,) } . sig",
                        "file_path": "tokio/src/io/util/mem.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_tee",
                        "label": "write_tee",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_tee () { let mut altout : Vec < u8 > = Vec :: new () ; let mut writeout = SmallWriter { contents : Vec :: new () , } ; { let mut tee = InspectWriter :: new (& mut writeout , | bytes | altout . extend (bytes)) ; tee . write_all (b\"A testing string, very testing\") . await . unwrap () ; } assert_eq ! (altout , writeout . contents) ; } . sig",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_with_buffer_larger_than_max",
                        "label": "write_with_buffer_larger_than_max",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn write_with_buffer_larger_than_max () { let chunk_a = crate :: io :: blocking :: DEFAULT_MAX_BUF_SIZE ; let chunk_b = chunk_a * 2 ; let chunk_c = chunk_a * 3 ; let chunk_d = chunk_a * 4 ; assert_eq ! (chunk_d / 1024 / 1024 , 8) ; let mut data = vec ! [] ; for i in 0 .. (chunk_d - 1) { data . push ((i % 151) as u8) ; } let data = Arc :: new (data) ; let d0 = data . clone () ; let d1 = data . clone () ; let d2 = data . clone () ; let d3 = data . clone () ; let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d0 [0 .. chunk_a]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d1 [chunk_a .. chunk_b]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d2 [chunk_b .. chunk_c]) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . withf (move | buf | buf == & d3 [chunk_c .. chunk_d - 1]) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut rem = & data [..] ; let mut first = true ; while ! rem . is_empty () { let mut task = task :: spawn (file . write (rem)) ; if ! first { assert_pending ! (task . poll ()) ; pool :: run_one () ; assert ! (task . is_woken ()) ; } first = false ; let n = assert_ready_ok ! (task . poll ()) ; rem = & rem [n ..] ; } pool :: run_one () ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "add_permits",
                        "label": "add_permits",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn add_permits () { let sem = Arc :: new (Semaphore :: new (0)) ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire_owned () . await ; }) ; sem . add_permits (1) ; j . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LeakedBuffers",
                        "label": "LeakedBuffers",
                        "kind": "Struct",
                        "signature": "struct LeakedBuffers",
                        "file_path": "tokio/tests/support/leaked_buffers.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "five",
                        "label": "five",
                        "kind": "Function",
                        "signature": "fn async fn five () -> u8 { 5 } . sig",
                        "file_path": "tokio-test/tests/block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drain",
                        "label": "drain",
                        "kind": "Function",
                        "signature": "fn fn drain (mut fd : & FileDescriptor , mut amt : usize) { let mut buf = [0u8 ; 512] ; while amt > 0 { match fd . read (& mut buf [..]) { Err (e) if e . kind () == ErrorKind :: WouldBlock => { } Ok (0) => panic ! (\"unexpected EOF\") , Err (e) => panic ! (\"unexpected error: {e:?}\") , Ok (x) => amt -= x , } } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_multi_frame_in_packet",
                        "label": "read_multi_frame_in_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_multi_frame_in_packet () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "iter_values_mut",
                        "label": "iter_values_mut",
                        "kind": "Function",
                        "signature": "fn # [test] fn iter_values_mut () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; let mut size_hints = map . values_mut () . map (| s : & mut _ | s . size_hint () . 0) . collect :: < Vec < _ > > () ; size_hints . sort_unstable () ; assert_eq ! (& size_hints [..] , & [1 , 2 , 3]) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_contention",
                        "label": "bench_contention",
                        "kind": "Function",
                        "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; read_concurrent_contended (& mut group) ; read_concurrent_contended_multi (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DisallowBlockInPlaceGuard",
                        "label": "DisallowBlockInPlaceGuard",
                        "kind": "Struct",
                        "signature": "struct DisallowBlockInPlaceGuard",
                        "file_path": "tokio/src/runtime/context/blocking.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "IsSend",
                        "label": "IsSend",
                        "kind": "Struct",
                        "signature": "struct IsSend",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_owned_token_cancelled_test",
                        "label": "pending_fut_with_owned_token_cancelled_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_owned_token_cancelled_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token . clone ()) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 1) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_nonblocking",
                        "label": "set_nonblocking",
                        "kind": "Function",
                        "signature": "fn fn set_nonblocking (fd : RawFd) { use nix :: fcntl :: { OFlag , F_GETFL , F_SETFL } ; let flags = nix :: fcntl :: fcntl (fd , F_GETFL) . expect (\"fcntl(F_GETFD)\") ; if flags < 0 { panic ! (\"bad return value from fcntl(F_GETFL): {} ({:?})\" , flags , nix :: Error :: last ()) ; } let flags = OFlag :: from_bits_truncate (flags) | OFlag :: O_NONBLOCK ; nix :: fcntl :: fcntl (fd , F_SETFL (flags)) . expect (\"fcntl(F_SETFD)\") ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_uring",
                        "label": "write_uring",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (tokio_unstable , feature = \"io-uring\" , feature = \"rt\" , feature = \"fs\" , target_os = \"linux\"))] async fn write_uring (path : & Path , mut buf : OwnedBuf) -> io :: Result < () > { use crate :: { fs :: OpenOptions , runtime :: driver :: op :: Op } ; use std :: os :: fd :: OwnedFd ; let file = OpenOptions :: new () . write (true) . create (true) . truncate (true) . open (path) . await ? ; let mut fd : OwnedFd = file . try_into_std () . expect (\"unexpected in-flight operation detected\") . into () ; let total : usize = buf . as_ref () . len () ; let mut buf_offset : usize = 0 ; let mut file_offset : u64 = 0 ; while buf_offset < total { let (n , _buf , _fd) = Op :: write_at (fd , buf , buf_offset , file_offset) ? . await ? ; if n == 0 { return Err (io :: ErrorKind :: WriteZero . into ()) ; } buf = _buf ; fd = _fd ; buf_offset += n as usize ; file_offset += n as u64 ; } Ok (()) } . sig",
                        "file_path": "tokio/src/fs/write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WakeList",
                        "label": "WakeList",
                        "kind": "Struct",
                        "signature": "struct WakeList",
                        "file_path": "tokio/src/util/wake_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "multiple_sender",
                        "label": "multiple_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multiple_sender () { let (tx1 , mut rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let mut t = spawn (async { rx . changed () . await . unwrap () ; let v1 = * rx . borrow_and_update () ; rx . changed () . await . unwrap () ; let v2 = * rx . borrow_and_update () ; (v1 , v2) }) ; tx1 . send (1) . unwrap () ; assert_pending ! (t . poll ()) ; tx2 . send (2) . unwrap () ; assert_ready_eq ! (t . poll () , (1 , 2)) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abort_by_key",
                        "label": "abort_by_key",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_by_key () { let mut map = JoinMap :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; }) ; } for i in 0 .. 16 { if i % 2 != 0 { map . abort (& i) ; } } while let Some ((key , res)) = map . join_next () . await { match res { Ok (()) => { num_completed += 1 ; assert_eq ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } Err (e) => { num_canceled += 1 ; assert ! (e . is_cancelled ()) ; assert_ne ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_is_empty_32_msgs",
                        "label": "test_is_empty_32_msgs",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_is_empty_32_msgs () { let (sender , mut receiver) = mpsc :: channel (33) ; for value in 1 .. 257 { sender . send (value) . await . unwrap () ; receiver . recv () . await . unwrap () ; assert ! (receiver . is_empty () , \"{value}. len: {}\" , receiver . len ()) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_fd_try_with_interest_panic_caller",
                        "label": "async_fd_try_with_interest_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] fn async_fd_try_with_interest_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: io :: Interest ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: try_with_interest (fd , Interest :: READABLE) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "select_into_future",
                        "label": "select_into_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn select_into_future () { struct NotAFuture ; impl std :: future :: IntoFuture for NotAFuture { type Output = () ; type IntoFuture = std :: future :: Ready < () > ; fn into_future (self) -> Self :: IntoFuture { std :: future :: ready (()) } } tokio :: select ! { () = NotAFuture => { } , } } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "generic_fun",
                        "label": "generic_fun",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn generic_fun < T : Default > () -> T { T :: default () } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StreamReaderProject",
                        "label": "StreamReaderProject",
                        "kind": "Struct",
                        "signature": "struct StreamReaderProject",
                        "file_path": "tokio-util/src/io/stream_reader.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "flush_while_idle",
                        "label": "flush_while_idle",
                        "kind": "Function",
                        "signature": "fn # [test] fn flush_while_idle () { let file = MockFile :: default () ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "actor_weak_unbounded_sender",
                        "label": "actor_weak_unbounded_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn actor_weak_unbounded_sender () { pub struct MyActor { receiver : mpsc :: UnboundedReceiver < ActorMessage > , sender : mpsc :: WeakUnboundedSender < ActorMessage > , next_id : u32 , pub received_self_msg : bool , } enum ActorMessage { GetUniqueId { respond_to : oneshot :: Sender < u32 > } , SelfMessage { } , } impl MyActor { fn new (receiver : mpsc :: UnboundedReceiver < ActorMessage > , sender : mpsc :: WeakUnboundedSender < ActorMessage > ,) -> Self { MyActor { receiver , sender , next_id : 0 , received_self_msg : false , } } fn handle_message (& mut self , msg : ActorMessage) { match msg { ActorMessage :: GetUniqueId { respond_to } => { self . next_id += 1 ; let _ = respond_to . send (self . next_id) ; } ActorMessage :: SelfMessage { .. } => { self . received_self_msg = true ; } } } async fn send_message_to_self (& mut self) { let msg = ActorMessage :: SelfMessage { } ; let sender = self . sender . clone () ; if let Some (sender) = sender . upgrade () { let _ = sender . send (msg) ; self . sender = sender . downgrade () ; } } async fn run (& mut self) { let mut i = 0 ; while let Some (msg) = self . receiver . recv () . await { self . handle_message (msg) ; if i == 0 { self . send_message_to_self () . await ; } i += 1 } assert ! (self . received_self_msg) ; } } # [derive (Clone)] pub struct MyActorHandle { sender : mpsc :: UnboundedSender < ActorMessage > , } impl MyActorHandle { pub fn new () -> (Self , MyActor) { let (sender , receiver) = mpsc :: unbounded_channel () ; let actor = MyActor :: new (receiver , sender . clone () . downgrade ()) ; (Self { sender } , actor) } pub async fn get_unique_id (& self) -> u32 { let (send , recv) = oneshot :: channel () ; let msg = ActorMessage :: GetUniqueId { respond_to : send } ; let _ = self . sender . send (msg) ; recv . await . expect (\"Actor task has been killed\") } } let (handle , mut actor) = MyActorHandle :: new () ; let actor_handle = tokio :: spawn (async move { actor . run () . await }) ; let _ = tokio :: spawn (async move { let _ = handle . get_unique_id () . await ; drop (handle) ; }) . await ; let _ = actor_handle . await ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_mock_wait",
                        "label": "test_stream_mock_wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_stream_mock_wait () { let mut stream_mock = StreamMockBuilder :: new () . next (1) . wait (Duration :: from_millis (300)) . next (2) . build () ; assert_eq ! (stream_mock . next () . await , Some (1)) ; let start = std :: time :: Instant :: now () ; assert_eq ! (stream_mock . next () . await , Some (2)) ; let elapsed = start . elapsed () ; assert ! (elapsed >= Duration :: from_millis (300)) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
                        "file_path": "tokio-test/tests/stream_mock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontented_bounded_recv_many",
                        "label": "uncontented_bounded_recv_many",
                        "kind": "Function",
                        "signature": "fn fn uncontented_bounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for i in 0 .. 5000 { tx . send (i) . await . unwrap () ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "await_error_readiness_timestamping",
                        "label": "await_error_readiness_timestamping",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (target_os = \"linux\")] async fn await_error_readiness_timestamping () { use std :: net :: { Ipv4Addr , SocketAddr } ; use tokio :: io :: { Interest , Ready } ; let address_a = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let address_b = SocketAddr :: from ((Ipv4Addr :: LOCALHOST , 0)) ; let socket = std :: net :: UdpSocket :: bind (address_a) . unwrap () ; socket . set_nonblocking (true) . unwrap () ; configure_timestamping_socket (& socket) . unwrap () ; socket . connect (address_b) . unwrap () ; let fd = AsyncFd :: new (socket) . unwrap () ; tokio :: select ! { _ = fd . ready (Interest :: ERROR) => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } let buf = b\"hello there\" ; fd . get_ref () . send (buf) . unwrap () ; let guard = fd . ready (Interest :: ERROR) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: ERROR) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "iter_keys",
                        "label": "iter_keys",
                        "kind": "Function",
                        "signature": "fn # [test] fn iter_keys () { let mut map = StreamMap :: new () ; map . insert (\"a\" , pending :: < i32 > ()) ; map . insert (\"b\" , pending ()) ; map . insert (\"c\" , pending ()) ; let mut keys = map . keys () . collect :: < Vec < _ > > () ; keys . sort_unstable () ; assert_eq ! (& keys [..] , & [& \"a\" , & \"b\" , & \"c\"]) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel",
                        "label": "cancel",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Cancels a node and its children.\"] pub (crate) fn cancel (node : & Arc < TreeNode >) { let mut locked_node = node . inner . lock () . unwrap () ; if locked_node . is_cancelled { return ; } while let Some (child) = locked_node . children . pop () { let mut locked_child = child . inner . lock () . unwrap () ; locked_child . parent = None ; locked_child . parent_idx = 0 ; if locked_child . is_cancelled { continue ; } while let Some (grandchild) = locked_child . children . pop () { let mut locked_grandchild = grandchild . inner . lock () . unwrap () ; locked_grandchild . parent = None ; locked_grandchild . parent_idx = 0 ; if locked_grandchild . is_cancelled { continue ; } if locked_grandchild . children . is_empty () { locked_grandchild . is_cancelled = true ; locked_grandchild . children = Vec :: new () ; drop (locked_grandchild) ; grandchild . waker . notify_waiters () ; } else { locked_grandchild . parent = Some (node . clone ()) ; locked_grandchild . parent_idx = locked_node . children . len () ; drop (locked_grandchild) ; locked_node . children . push (grandchild) ; } } locked_child . is_cancelled = true ; locked_child . children = Vec :: new () ; drop (locked_child) ; child . waker . notify_waiters () ; } locked_node . is_cancelled = true ; locked_node . children = Vec :: new () ; drop (locked_node) ; node . waker . notify_waiters () ; } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "without_carriage_return",
                        "label": "without_carriage_return",
                        "kind": "Function",
                        "signature": "fn fn without_carriage_return (s : & [u8]) -> & [u8] { if let Some (& b'\\r') = s . last () { & s [.. s . len () - 1] } else { s } } . sig",
                        "file_path": "tokio-util/src/codec/lines_codec.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "has_budget_remaining",
                        "label": "has_budget_remaining",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns `true` if there is still budget left on the task.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" This example defines a `Timeout` future that requires a given `future` to complete before the\"] # [doc = \" specified duration elapses. If it does, its result is returned; otherwise, an error is returned\"] # [doc = \" and the future is canceled.\"] # [doc = \"\"] # [doc = \" Note that the future could exhaust the budget before we evaluate the timeout. Using `has_budget_remaining`,\"] # [doc = \" we can detect this scenario and ensure the timeout is always checked.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # use std::future::Future;\"] # [doc = \" # use std::pin::{pin, Pin};\"] # [doc = \" # use std::task::{ready, Context, Poll};\"] # [doc = \" # use tokio::task::coop;\"] # [doc = \" # use tokio::time::Sleep;\"] # [doc = \" pub struct Timeout<T> {\"] # [doc = \"     future: T,\"] # [doc = \"     delay: Pin<Box<Sleep>>,\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" impl<T> Future for Timeout<T>\"] # [doc = \" where\"] # [doc = \"     T: Future + Unpin,\"] # [doc = \" {\"] # [doc = \"     type Output = Result<T::Output, ()>;\"] # [doc = \"\"] # [doc = \"     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\"] # [doc = \"         let this = Pin::into_inner(self);\"] # [doc = \"         let future = Pin::new(&mut this.future);\"] # [doc = \"         let delay = Pin::new(&mut this.delay);\"] # [doc = \"\"] # [doc = \"         // check if the future is ready\"] # [doc = \"         let had_budget_before = coop::has_budget_remaining();\"] # [doc = \"         if let Poll::Ready(v) = future.poll(cx) {\"] # [doc = \"             return Poll::Ready(Ok(v));\"] # [doc = \"         }\"] # [doc = \"         let has_budget_now = coop::has_budget_remaining();\"] # [doc = \"\"] # [doc = \"         // evaluate the timeout\"] # [doc = \"         if let (true, false) = (had_budget_before, has_budget_now) {\"] # [doc = \"             // it is the underlying future that exhausted the budget\"] # [doc = \"             ready!(pin!(coop::unconstrained(delay)).poll(cx));\"] # [doc = \"         } else {\"] # [doc = \"             ready!(delay.poll(cx));\"] # [doc = \"         }\"] # [doc = \"         return Poll::Ready(Err(()));\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"```\"] # [inline (always)] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub fn has_budget_remaining () -> bool { context :: budget (| cell | cell . get () . has_remaining ()) . unwrap_or (true) } . sig",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "nonstatic_typeid",
                        "label": "nonstatic_typeid",
                        "kind": "Function",
                        "signature": "fn # [inline (always)] fn nonstatic_typeid < T > () -> TypeId where T : ? Sized , { trait NonStaticAny { fn get_type_id (& self) -> TypeId where Self : 'static ; } impl < T : ? Sized > NonStaticAny for PhantomData < T > { # [inline (always)] fn get_type_id (& self) -> TypeId where Self : 'static , { TypeId :: of :: < T > () } } let phantom_data = PhantomData :: < T > ; NonStaticAny :: get_type_id (unsafe { mem :: transmute :: < & dyn NonStaticAny , & (dyn NonStaticAny + 'static) > (& phantom_data) }) } . sig",
                        "file_path": "tokio/src/util/typeid.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Wake",
                        "label": "Wake",
                        "kind": "Trait",
                        "signature": "trait Wake",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "create_shutdown1",
                        "label": "create_shutdown1",
                        "kind": "Function",
                        "signature": "fn # [test] fn create_shutdown1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (join) ; handle . assert_not_dropped () ; notified . shutdown () ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "a",
                        "label": "a",
                        "kind": "Function",
                        "signature": "fn # [inline (never)] async fn a () { black_box (b ()) . await } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_local_future_elsewhere",
                        "label": "join_local_future_elsewhere",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn join_local_future_elsewhere () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; let rt = runtime :: Runtime :: new () . unwrap () ; let local = LocalSet :: new () ; local . block_on (& rt , async move { let (tx , rx) = oneshot :: channel () ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ()) , \"local task must run on local thread, no matter where it is awaited\") ; rx . await . unwrap () ; \"hello world\" }) ; let join2 = task :: spawn (async move { assert ! (! ON_RT_THREAD . with (| cell | cell . get ()) , \"spawned task should be on a worker\") ; tx . send (()) . expect (\"task shouldn't have ended yet\") ; join . await . expect (\"task should complete successfully\") ; }) ; join2 . await . unwrap () }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_cancellation_propagates",
                        "label": "task_cancellation_propagates",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Canceling the task via the returned join handle cancels the spawned task\"] # [doc = \" (which has a different, internal join handle).\"] # [tokio :: test] async fn task_cancellation_propagates () { let pool = task :: LocalPoolHandle :: new (1) ; let notify_dropped = Arc :: new (()) ; let weak_notify_dropped = Arc :: downgrade (& notify_dropped) ; let (start_sender , start_receiver) = tokio :: sync :: oneshot :: channel () ; let (drop_sender , drop_receiver) = tokio :: sync :: oneshot :: channel :: < () > () ; let join_handle = pool . spawn_pinned (| | async move { let _drop_sender = drop_sender ; let _notify_dropped = notify_dropped ; let _ = start_sender . send (()) ; futures :: future :: pending :: < () > () . await ; }) ; let _ = start_receiver . await ; join_handle . abort () ; let _ = drop_receiver . await ; assert ! (weak_notify_dropped . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_sleep",
                        "label": "maybe_sleep",
                        "kind": "Function",
                        "signature": "fn async fn maybe_sleep (idx : i32) -> i32 { if idx % 2 == 0 { sleep (ms (200)) . await ; } idx } . sig",
                        "file_path": "tokio-stream/tests/stream_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_seek_flush_err",
                        "label": "write_seek_flush_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_seek_flush_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Start (0))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; { let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line_fail_and_utf8_fail",
                        "label": "read_line_fail_and_utf8_fail",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_line_fail_and_utf8_fail () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"\\xff\\xff\\xff\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (line . as_str () , \"Foo\") ; } . sig",
                        "file_path": "tokio/tests/io_read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Waiter",
                        "label": "Waiter",
                        "kind": "Struct",
                        "signature": "struct Waiter",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_multiple_rx_with_overflow",
                        "label": "drop_multiple_rx_with_overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_multiple_rx_with_overflow () { loom :: model (move | | { let (tx , mut rx) = broadcast :: channel (1) ; let _rx2 = tx . subscribe () ; let _ = tx . send (()) ; let tx2 = tx . clone () ; let th1 = thread :: spawn (move | | { block_on (async { for _ in 0 .. 100 { let _ = tx2 . send (()) ; } }) ; }) ; let _ = tx . send (()) ; let th2 = thread :: spawn (move | | { block_on (async { while let Ok (_) = rx . recv () . await { } }) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown_multiple_calls",
                        "label": "shutdown_multiple_calls",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn shutdown_multiple_calls () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let (connected_tx , connected_rx) = channel () ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; connected_tx . send (()) . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; connected_rx . await . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/tcp_shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mutable_borrowing_future_with_same_borrow_in_block",
                        "label": "mutable_borrowing_future_with_same_borrow_in_block",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn mutable_borrowing_future_with_same_borrow_in_block () { let mut value = 234 ; tokio :: select ! { _ = require_mutable (& mut value) => { } , _ = async_noop () => { value += 5 ; } , } assert ! (value >= 234) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "push_and_pop",
                        "label": "push_and_pop",
                        "kind": "Function",
                        "signature": "fn # [test] fn push_and_pop () { const N : usize = 2 ; let (inject , mut synced) = inject :: Shared :: new () ; for i in 0 .. N { assert_eq ! (inject . len () , i) ; let (task , _) = super :: unowned (async { }) ; unsafe { inject . push (& mut synced , task) } ; } for i in 0 .. N { assert_eq ! (inject . len () , N - i) ; assert ! (unsafe { inject . pop (& mut synced) } . is_some ()) ; } println ! (\"--------------\") ; assert ! (unsafe { inject . pop (& mut synced) } . is_none ()) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/inject.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedNotified",
                        "label": "OwnedNotified",
                        "kind": "Struct",
                        "signature": "struct OwnedNotified",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pause_time_in_main",
                        "label": "pause_time_in_main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn pause_time_in_main () { tokio :: time :: pause () ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "paused_time_stress_run",
                        "label": "paused_time_stress_run",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main (flavor = \"current_thread\" , start_paused = true)] async fn paused_time_stress_run () -> Vec < Duration > { let mut rng = StdRng :: seed_from_u64 (1) ; let mut times = vec ! [] ; let start = Instant :: now () ; for _ in 0 .. 10_000 { let sleep = rng . random_range (Duration :: from_secs (0) .. Duration :: from_secs (1)) ; time :: sleep (sleep) . await ; times . push (start . elapsed ()) ; } times } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_poll_count_and_time",
                        "label": "worker_poll_count_and_time",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_poll_count_and_time () { const N : u64 = 5 ; async fn task () { std :: thread :: sleep (std :: time :: Duration :: from_micros (10)) ; } let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (task ()) . await . unwrap () ; } }) ; drop (rt) ; assert_eq ! (N , metrics . worker_poll_count (0)) ; assert_eq ! (Duration :: default () , metrics . worker_mean_poll_time (0)) ; assert ! (! metrics . poll_time_histogram_enabled ()) ; for i in 0 .. 10 { assert_eq ! (0 , metrics . poll_time_histogram_bucket_count (0 , i)) ; } let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (task ()) . await . unwrap () ; } }) ; drop (rt) ; let n = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_poll_count (i)) . sum () ; assert_eq ! (N , n) ; let n : Duration = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_mean_poll_time (i)) . sum () ; assert ! (n > Duration :: default ()) ; assert ! (! metrics . poll_time_histogram_enabled ()) ; for n in 0 .. metrics . num_workers () { for i in 0 .. 10 { assert_eq ! (0 , metrics . poll_time_histogram_bucket_count (n , i)) ; } } } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_drop_one",
                        "label": "notified_multi_notify_drop_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_drop_one () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; drop (notified1) ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_big_spawn_sizes_recorded",
                        "label": "task_big_spawn_sizes_recorded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_big_spawn_sizes_recorded () { let future = { async fn big < const N : usize > () { let mut a = [0_u8 ; N] ; for (idx , item) in a . iter_mut () . enumerate () { * item = (idx % 256) as u8 ; } tokio :: time :: sleep (Duration :: from_millis (10)) . await ; for (idx , item) in a . iter_mut () . enumerate () { assert_eq ! (* item , (idx % 256) as u8) ; } } big :: < 20_000 > () } ; fn boxed_size < T > (_ : & T) -> usize { mem :: size_of :: < Box < T > > () } let size = mem :: size_of_val (& future) as u64 ; let boxed_size = boxed_size (& future) ; let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"size.bytes\") . with_value (& boxed_size) . and (expect :: field (\"original_size.bytes\") . with_value (& size)) ,) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (future) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "watch_stream_message_not_twice",
                        "label": "watch_stream_message_not_twice",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn watch_stream_message_not_twice () { let (tx , rx) = watch :: channel (\"hello\") ; let mut counter = 0 ; let mut stream = WatchStream :: new (rx) . map (move | payload | { println ! (\"{payload}\") ; if payload == \"goodbye\" { counter += 1 ; } if counter >= 2 { panic ! (\"too many goodbyes\") ; } }) ; let task = tokio :: spawn (async move { while stream . next () . await . is_some () { } }) ; tx . send (\"goodbye\") . unwrap () ; drop (tx) ; task . await . unwrap () ; } . sig",
                        "file_path": "tokio-stream/tests/watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_reader_len",
                        "label": "test_reader_len",
                        "kind": "Function",
                        "signature": "fn async fn test_reader_len (r : impl AsyncRead + Unpin + Send + 'static , expected_len : usize ,) -> IoResult < () > { let mut r = SyncIoBridge :: new (r) ; let res = tokio :: task :: spawn_blocking (move | | { let mut buf = Vec :: new () ; r . read_to_end (& mut buf) ? ; Ok :: < _ , std :: io :: Error > (buf) }) . await ? ; assert_eq ! (res ?. len () , expected_len) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sync_bridge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Builder",
                        "label": "Builder",
                        "kind": "Struct",
                        "signature": "struct Builder",
                        "file_path": "tokio-util/src/codec/length_delimited.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_count_when_dropped",
                        "label": "sender_strong_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_count_when_dropped () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mock_panics_write_data_left",
                        "label": "mock_panics_write_data_left",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn mock_panics_write_data_left () { use tokio_test :: io :: Builder ; Builder :: new () . write (b\"write\") . build () ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Database",
                        "label": "Database",
                        "kind": "Struct",
                        "signature": "struct Database",
                        "file_path": "examples/tinydb.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "compute_main",
                        "label": "compute_main",
                        "kind": "Function",
                        "signature": "fn # [tokio1 :: main (crate = \"tokio1\")] async fn compute_main () -> usize { compute () . await } . sig",
                        "file_path": "tokio/tests/macros_rename_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "io_driver_fd_count",
                        "label": "io_driver_fd_count",
                        "kind": "Function",
                        "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"macos\"))] # [test] fn io_driver_fd_count () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (metrics . io_driver_fd_registered_count () , 0) ; let stream = tokio :: net :: TcpStream :: connect (\"google.com:80\") ; let stream = rt . block_on (async move { stream . await . unwrap () }) ; assert_eq ! (metrics . io_driver_fd_registered_count () , 1) ; assert_eq ! (metrics . io_driver_fd_deregistered_count () , 0) ; drop (stream) ; assert_eq ! (metrics . io_driver_fd_deregistered_count () , 1) ; assert_eq ! (metrics . io_driver_fd_registered_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ms",
                        "label": "ms",
                        "kind": "Function",
                        "signature": "fn fn ms (n : u64) -> Duration { Duration :: from_millis (n) } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_string",
                        "label": "empty_string",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_string () { let coll : String = stream :: empty :: < & str > () . collect () . await ; assert ! (coll . is_empty ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_macro",
                        "label": "test_macro",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_macro () { spawn_send () . await ; } . sig",
                        "file_path": "tests-integration/tests/rt_yield.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify",
                        "label": "notified_multi_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_with_buffer",
                        "label": "send_recv_with_buffer",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn send_recv_with_buffer () { let (tx , mut rx) = mpsc :: channel :: < i32 > (16) ; let permit = tx . reserve () . await . unwrap () ; permit . send (1) ; tx . try_send (2) . unwrap () ; drop (tx) ; let val = rx . recv () . await ; assert_eq ! (val , Some (1)) ; let val = rx . recv () . await ; assert_eq ! (val , Some (2)) ; let val = rx . recv () . await ; assert ! (val . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_err_on_ok",
                        "label": "assert_err_on_ok",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn assert_err_on_ok () { let poll = ready_ok () ; assert_ready_err ! (poll) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_by_ref_arc_raw",
                        "label": "wake_by_ref_arc_raw",
                        "kind": "Function",
                        "signature": "fn unsafe fn wake_by_ref_arc_raw < T : Wake > (data : * const ()) { let arc = ManuallyDrop :: new (Arc :: < T > :: from_raw (data . cast ())) ; Wake :: wake_by_ref (& arc) ; } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_custom_flags_bsd_family",
                        "label": "open_options_custom_flags_bsd_family",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"freebsd\" , target_os = \"macos\"))] async fn open_options_custom_flags_bsd_family () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (libc :: O_NOFOLLOW)) . contains (\"custom_flags: 256,\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_tasks_in_context",
                        "label": "drop_tasks_in_context",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_tasks_in_context () { static SUCCESS : AtomicBool = AtomicBool :: new (false) ; struct ContextOnDrop ; impl Future for ContextOnDrop { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for ContextOnDrop { fn drop (& mut self) { if tokio :: runtime :: Handle :: try_current () . is_ok () { SUCCESS . store (true , Ordering :: SeqCst) ; } } } let rt = rt () ; rt . spawn (ContextOnDrop) ; drop (rt) ; assert ! (SUCCESS . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RngSeedGenerator",
                        "label": "RngSeedGenerator",
                        "kind": "Struct",
                        "signature": "struct RngSeedGenerator",
                        "file_path": "tokio/src/util/rand/rt.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "VectoredWriteHarness",
                        "label": "VectoredWriteHarness",
                        "kind": "Struct",
                        "signature": "struct VectoredWriteHarness",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_single_frame_would_block",
                        "label": "write_single_frame_would_block",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_frame_would_block () { let io = FramedWrite :: new (mock ! { Poll :: Pending , data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09\") , data (b\"abcdefghi\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_blocking_pool",
                        "label": "create_blocking_pool",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn create_blocking_pool (builder : & Builder , thread_cap : usize) -> BlockingPool { BlockingPool :: new (builder , thread_cap) } . sig",
                        "file_path": "tokio/src/runtime/blocking/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_local_in_runtime",
                        "label": "test_spawn_local_in_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_spawn_local_in_runtime () { let rt = rt () ; let res = rt . block_on (async move { let (tx , rx) = tokio :: sync :: oneshot :: channel () ; spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_poll_count_histogram_range",
                        "label": "worker_poll_count_histogram_range",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_poll_count_histogram_range () { let max = Duration :: from_nanos (u64 :: MAX) ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (us (50) , 3)) . build () . unwrap () ; let metrics = rt . metrics () ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , us (0) .. us (50)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , us (50) .. us (100)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (2) , us (100) .. max) ; # [allow (deprecated)] let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_count_histogram_scale (tokio :: runtime :: HistogramScale :: Log) . metrics_poll_count_histogram_buckets (3) . metrics_poll_count_histogram_resolution (us (50)) . build () . unwrap () ; let metrics = rt . metrics () ; let a = Duration :: from_nanos (50000_u64 . next_power_of_two ()) ; let b = a * 2 ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , us (0) .. a) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , a .. b) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (2) , b .. max) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cstr",
                        "label": "cstr",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn cstr (p : & Path) -> io :: Result < CString > { Ok (CString :: new (p . as_os_str () . as_bytes ()) ?) } . sig",
                        "file_path": "tokio/src/io/uring/utils.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_unbounded_recv_many",
                        "label": "contention_unbounded_recv_many",
                        "kind": "Function",
                        "signature": "fn fn contention_unbounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send",
                        "label": "send",
                        "kind": "Function",
                        "signature": "fn async fn send (mut stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , writer : & UdpSocket ,) -> Result < () , std :: io :: Error > { while let Some (item) = stdin . next () . await { let buf = item ? ; writer . send (& buf [..]) . await ? ; } Ok (()) } . sig",
                        "file_path": "examples/connect-udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rwlock_with_max_readers_panic_caller",
                        "label": "rwlock_with_max_readers_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn rwlock_with_max_readers_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = RwLock :: < u8 > :: with_max_readers (0 , (u32 :: MAX >> 3) + 1) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "collect_str_items",
                        "label": "collect_str_items",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn collect_str_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < String > ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"hello \") . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"world\") . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duplicate_keys",
                        "label": "duplicate_keys",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn duplicate_keys () { let mut map = JoinMap :: new () ; map . spawn (1 , async { 1 }) ; map . spawn (1 , async { 2 }) ; assert_eq ! (map . len () , 1) ; let (key , res) = map . join_next () . await . unwrap () ; assert_eq ! (key , 1) ; assert_eq ! (res . unwrap () , 2) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "entry_point",
                        "label": "entry_point",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main (flavor = \"current_thread\")] async fn entry_point () { spawn_send () . await ; } . sig",
                        "file_path": "tests-integration/tests/rt_yield.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MutexGuardInner",
                        "label": "MutexGuardInner",
                        "kind": "Struct",
                        "signature": "struct MutexGuardInner",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "UringContext",
                        "label": "UringContext",
                        "kind": "Struct",
                        "signature": "struct UringContext",
                        "file_path": "tokio/src/runtime/io/driver/uring.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "CtrlC",
                        "label": "CtrlC",
                        "kind": "Struct",
                        "signature": "struct CtrlC",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "create_dir",
                        "label": "create_dir",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new, empty directory at the provided path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::create_dir`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `mkdir` function on Unix\"] # [doc = \" and the `CreateDirectory` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" **NOTE**: If a parent of the given path doesn't exist, this function will\"] # [doc = \" return an error. To create a directory and all its missing parents at the\"] # [doc = \" same time, use the [`create_dir_all`] function.\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * User lacks permissions to create directory at `path`.\"] # [doc = \" * A parent of the given path doesn't exist. (To create a directory and all\"] # [doc = \"   its missing parents at the same time, use the [`create_dir_all`]\"] # [doc = \"   function.)\"] # [doc = \" * `path` already exists.\"] # [doc = \"\"] # [doc = \" [`create_dir_all`]: super::create_dir_all()\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::io;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     fs::create_dir(\\\"/some/dir\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn create_dir (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: create_dir (path)) . await } . sig",
                        "file_path": "tokio/src/fs/create_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_to_recv_from_poll",
                        "label": "send_to_recv_from_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn send_to_recv_from_poll () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let sender_path = dir . path () . join (\"sender.sock\") ; let receiver_path = dir . path () . join (\"receiver.sock\") ; let sender = UnixDatagram :: bind (& sender_path) ? ; let receiver = UnixDatagram :: bind (& receiver_path) ? ; let msg = b\"hello\" ; poll_fn (| cx | sender . poll_send_to (cx , msg , & receiver_path)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; assert_eq ! (addr . as_pathname () , Some (sender_path . as_ref ())) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalWorkerHandle",
                        "label": "LocalWorkerHandle",
                        "kind": "Struct",
                        "signature": "struct LocalWorkerHandle",
                        "file_path": "tokio-util/src/task/spawn_pinned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RwLockWriteGuard",
                        "label": "RwLockWriteGuard",
                        "kind": "Struct",
                        "signature": "struct RwLockWriteGuard",
                        "file_path": "tokio/src/sync/rwlock/write_guard.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "coop",
                        "label": "coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn coop () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut task = task :: spawn (async { let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; loop { let _ = file . read (& mut buf) . await . unwrap () ; file . seek (std :: io :: SeekFrom :: Start (0)) . await . unwrap () ; } }) ; for _ in 0 .. 1_000 { if task . poll () . is_pending () { return ; } } panic ! (\"did not yield\") ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_size",
                        "label": "join_size",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn join_size () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (0i32) ; tokio :: join ! (ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 32) ; let fut = async { let ready1 = future :: ready (0i32) ; let ready2 = future :: ready (0i32) ; tokio :: join ! (ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 48) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_two",
                        "label": "spawn_two",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_two () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (\"ZOMG\") . unwrap () ; }) ; }) ; assert_ok ! (rx . await) }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (1 , local) ; } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_write_ready",
                        "label": "poll_write_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_write_ready () { let (mut client , server) = create_pair () . await ; assert_writable_by_polling ! (client) ; write_until_pending (& mut client) ; assert_not_writable_by_polling ! (client) ; drop (server) ; assert_writable_by_polling ! (client) ; } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalNotified",
                        "label": "LocalNotified",
                        "kind": "Struct",
                        "signature": "struct LocalNotified",
                        "file_path": "tokio/src/runtime/task/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reunite",
                        "label": "reunite",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reunite () -> Result < () > { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { drop (listener . accept () . unwrap ()) ; drop (listener . accept () . unwrap ()) ; }) ; let stream1 = TcpStream :: connect (& addr) . await ? ; let (read1 , write1) = stream1 . into_split () ; let stream2 = TcpStream :: connect (& addr) . await ? ; let (_ , write2) = stream2 . into_split () ; let read1 = match read1 . reunite (write2) { Ok (_) => panic ! (\"Reunite should not succeed\") , Err (err) => err . 0 , } ; read1 . reunite (write1) . expect (\"Reunite should succeed\") ; handle . join () . unwrap () ; Ok (()) } . sig",
                        "file_path": "tokio/tests/tcp_into_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "next_many_pending",
                        "label": "next_many_pending",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_pending () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let mut is_pending = false ; poll_fn (| cx | { let poll = pin ! (stream_map . next_many (& mut vec ! [] , 1)) . poll (cx) ; is_pending = poll . is_pending () ; Poll :: Ready (()) }) . await ; assert ! (is_pending) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_bounded_receiver_blocking_recv_panic_caller",
                        "label": "mpsc_bounded_receiver_blocking_recv_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_bounded_receiver_blocking_recv_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Core",
                        "label": "Core",
                        "kind": "Struct",
                        "signature": "struct Core",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "poll_write_buf",
                        "label": "poll_write_buf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Try to write data from an implementer of the [`Buf`] trait to an\"] # [doc = \" [`AsyncWrite`], advancing the buffer's internal cursor.\"] # [doc = \"\"] # [doc = \" This function will use [vectored writes] when the [`AsyncWrite`] supports\"] # [doc = \" vectored writes.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" [`File`] implements [`AsyncWrite`] and [`Cursor<&[u8]>`] implements\"] # [doc = \" [`Buf`]:\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio_util::io::poll_write_buf;\"] # [doc = \" use tokio::io;\"] # [doc = \" use tokio::fs::File;\"] # [doc = \"\"] # [doc = \" use bytes::Buf;\"] # [doc = \" use std::future::poll_fn;\"] # [doc = \" use std::io::Cursor;\"] # [doc = \" use std::pin::Pin;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> io::Result<()> {\"] # [doc = \"     let mut file = File::create(\\\"foo.txt\\\").await?;\"] # [doc = \"     let mut buf = Cursor::new(b\\\"data to write\\\");\"] # [doc = \"\"] # [doc = \"     // Loop until the entire contents of the buffer are written to\"] # [doc = \"     // the file.\"] # [doc = \"     while buf.has_remaining() {\"] # [doc = \"         poll_fn(|cx| poll_write_buf(Pin::new(&mut file), cx, &mut buf)).await?;\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" [`Buf`]: bytes::Buf\"] # [doc = \" [`AsyncWrite`]: tokio::io::AsyncWrite\"] # [doc = \" [`File`]: tokio::fs::File\"] # [doc = \" [vectored writes]: tokio::io::AsyncWrite::poll_write_vectored\"] # [cfg_attr (not (feature = \"io\") , allow (unreachable_pub))] pub fn poll_write_buf < T : AsyncWrite + ? Sized , B : Buf > (io : Pin < & mut T > , cx : & mut Context < '_ > , buf : & mut B ,) -> Poll < io :: Result < usize > > { const MAX_BUFS : usize = 64 ; if ! buf . has_remaining () { return Poll :: Ready (Ok (0)) ; } let n = if io . is_write_vectored () { let mut slices = [IoSlice :: new (& []) ; MAX_BUFS] ; let cnt = buf . chunks_vectored (& mut slices) ; ready ! (io . poll_write_vectored (cx , & slices [.. cnt])) ? } else { ready ! (io . poll_write (cx , buf . chunk ())) ? } ; buf . advance (n) ; Poll :: Ready (Ok (n)) } . sig",
                        "file_path": "tokio-util/src/util/poll_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_and_weak_conut",
                        "label": "sender_strong_and_weak_conut",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_and_weak_conut () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SmallReader",
                        "label": "SmallReader",
                        "kind": "Struct",
                        "signature": "struct SmallReader",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "process",
                        "label": "process",
                        "kind": "Function",
                        "signature": "fn async fn process (stream : TcpStream) -> Result < () , Box < dyn Error > > { let mut transport = Framed :: new (stream , Http) ; while let Some (request) = transport . next () . await { match request { Ok (request) => { let response = respond (request) . await ? ; transport . send (response) . await ? ; } Err (e) => return Err (e . into ()) , } } Ok (()) } . sig",
                        "file_path": "examples/tinyhttp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "trace_current_thread",
                        "label": "trace_current_thread",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Trace and poll all tasks of the `current_thread` runtime.\"] pub (in crate :: runtime) fn trace_current_thread (owned : & OwnedTasks < Arc < current_thread :: Handle > > , local : & mut VecDeque < Notified < Arc < current_thread :: Handle > > > , injection : & Inject < Arc < current_thread :: Handle > > ,) -> Vec < (Id , Trace) > { let mut dequeued = Vec :: new () ; while let Some (task) = local . pop_back () { dequeued . push (task) ; } while let Some (task) = injection . pop () { dequeued . push (task) ; } trace_owned (owned , dequeued) } . sig",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade",
                        "label": "downgrade",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade () { loom :: model (| | { let lock = Arc :: new (RwLock :: new (1)) ; let n = block_on (lock . write ()) ; let cloned_lock = lock . clone () ; let handle = thread :: spawn (move | | { let mut guard = block_on (cloned_lock . write ()) ; * guard = 2 ; }) ; let n = n . downgrade () ; assert_eq ! (* n , 1) ; drop (n) ; handle . join () . unwrap () ; assert_eq ! (* block_on (lock . read ()) , 2) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_uncontested",
                        "label": "read_uncontested",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn read_uncontested () { let rwlock = RwLock :: new (100) ; let result = * rwlock . read () . await ; assert_eq ! (result , 100) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink",
                        "label": "symlink",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new symbolic link on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a symbolic link pointing to the `original` path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::unix::fs::symlink`].\"] pub async fn symlink (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: unix :: fs :: symlink (original , link)) . await } . sig",
                        "file_path": "tokio/src/fs/symlink.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Completable",
                        "label": "Completable",
                        "kind": "Trait",
                        "signature": "trait Completable",
                        "file_path": "tokio/src/runtime/driver/op.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "push_batch_and_pop",
                        "label": "push_batch_and_pop",
                        "kind": "Function",
                        "signature": "fn # [test] fn push_batch_and_pop () { let (inject , mut inject_synced) = inject :: Shared :: new () ; unsafe { inject . push_batch (& mut inject_synced , (0 .. 10) . map (| _ | super :: unowned (async { }) . 0) ,) ; assert_eq ! (5 , inject . pop_n (& mut inject_synced , 5) . count ()) ; assert_eq ! (5 , inject . pop_n (& mut inject_synced , 5) . count ()) ; assert_eq ! (0 , inject . pop_n (& mut inject_synced , 5) . count ()) ; } } . sig",
                        "file_path": "tokio/src/runtime/tests/inject.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "steal_batch",
                        "label": "steal_batch",
                        "kind": "Function",
                        "signature": "fn # [test] fn steal_batch () { let mut stats = new_stats () ; let (steal1 , mut local1) = queue :: local () ; let (_ , mut local2) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; for _ in 0 .. 4 { let (task , _) = super :: unowned (async { }) ; local1 . push_back_or_overflow (task , & inject , & mut stats) ; } assert ! (steal1 . steal_into (& mut local2 , & mut stats) . is_some ()) ; cfg_unstable_metrics ! { assert_metrics ! (stats , steal_count == 2) ; } for _ in 0 .. 1 { assert ! (local2 . pop () . is_some ()) ; } assert ! (local2 . pop () . is_none ()) ; for _ in 0 .. 2 { assert ! (local1 . pop () . is_some ()) ; } assert ! (local1 . pop () . is_none ()) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TestWaker",
                        "label": "TestWaker",
                        "kind": "Struct",
                        "signature": "struct TestWaker",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "to_string_does_not_truncate_on_utf8_error",
                        "label": "to_string_does_not_truncate_on_utf8_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn to_string_does_not_truncate_on_utf8_error () { let data = vec ! [0xff , 0xff , 0xff] ; let mut s = \"abc\" . to_string () ; match AsyncReadExt :: read_to_string (& mut data . as_slice () , & mut s) . await { Ok (len) => panic ! (\"Should fail: {len} bytes.\") , Err (err) if err . to_string () == \"stream did not contain valid UTF-8\" => { } Err (err) => panic ! (\"Fail: {err}.\") , } assert_eq ! (s , \"abc\") ; } . sig",
                        "file_path": "tokio/tests/io_read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_stream_size_hint",
                        "label": "test_spawn_stream_size_hint",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_spawn_stream_size_hint () { let spawn = task :: spawn (SizedStream) ; assert_eq ! (spawn . size_hint () , (100 , Some (200))) ; } . sig",
                        "file_path": "tokio-test/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "io_panics_when_no_tokio_context",
                        "label": "io_panics_when_no_tokio_context",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] # [cfg_attr (miri , ignore)] fn io_panics_when_no_tokio_context () { let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; let _ = tokio :: net :: TcpListener :: from_std (listener) ; } . sig",
                        "file_path": "tokio/tests/no_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "compact_remove_remapped_keys",
                        "label": "compact_remove_remapped_keys",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_remove_remapped_keys () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; let key3 = queue . insert_at (\"foo3\" , now + ms (20)) ; let key4 = queue . insert_at (\"foo4\" , now + ms (20)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; queue . insert_at (\"foo5\" , now + ms (10)) ; let expired3 = queue . remove (& key3) ; let expired4 = queue . remove (& key4) ; assert_eq ! (expired3 . into_inner () , \"foo3\") ; assert_eq ! (expired4 . into_inner () , \"foo4\") ; queue . compact () ; assert_eq ! (queue . len () , 1) ; assert_eq ! (queue . capacity () , 1) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskHarnessScheduleHooks",
                        "label": "TaskHarnessScheduleHooks",
                        "kind": "Struct",
                        "signature": "struct TaskHarnessScheduleHooks",
                        "file_path": "tokio/src/runtime/task/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "worker_total_busy_duration",
                        "label": "worker_total_busy_duration",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_total_busy_duration () { const N : usize = 5 ; let zero = Duration :: from_millis (0) ; let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { tokio :: task :: yield_now () . await ; }) . await . unwrap () ; } }) ; drop (rt) ; assert ! (zero < metrics . worker_total_busy_duration (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { tokio :: task :: yield_now () . await ; }) . await . unwrap () ; } }) ; drop (rt) ; for i in 0 .. metrics . num_workers () { assert ! (zero < metrics . worker_total_busy_duration (i)) ; } } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_rx",
                        "label": "drop_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_rx () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel (16) ; let rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"one\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"two\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (v , \"three\") ; match assert_err ! (rx1 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; let th2 = thread :: spawn (move | | { drop (rx2) ; }) ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_ok ! (tx . send (\"three\")) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pop_n_drains_on_drop",
                        "label": "pop_n_drains_on_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn pop_n_drains_on_drop () { let (inject , mut inject_synced) = inject :: Shared :: new () ; unsafe { inject . push_batch (& mut inject_synced , (0 .. 10) . map (| _ | super :: unowned (async { }) . 0) ,) ; let _ = inject . pop_n (& mut inject_synced , 10) ; assert_eq ! (inject . len () , 0) ; } } . sig",
                        "file_path": "tokio/src/runtime/tests/inject.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_thread_id_threaded",
                        "label": "worker_thread_id_threaded",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_thread_id_threaded () { let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (rt . spawn (async move { let thread_id = std :: thread :: current () . id () ; let this_worker = (0 .. 2) . position (| w | metrics . worker_thread_id (w) == Some (thread_id)) . expect (\"task not running on any worker thread\") ; let moved_thread_id = tokio :: task :: block_in_place (| | { assert_eq ! (thread_id , std :: thread :: current () . id ()) ; for _ in 0 .. 100 { let new_id = metrics . worker_thread_id (this_worker) . unwrap () ; if thread_id != new_id { return new_id ; } std :: thread :: sleep (Duration :: from_millis (100)) ; } panic ! (\"worker did not move to new thread\") ; }) ; assert ! (metrics . worker_thread_id (this_worker) == Some (moved_thread_id) || metrics . worker_thread_id (this_worker) == Some (thread_id)) ; })) . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_uncontented",
                        "label": "bench_uncontented",
                        "kind": "Function",
                        "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; uncontented_bounded (& mut group) ; uncontented_bounded_recv_many (& mut group) ; uncontented_unbounded (& mut group) ; uncontented_unbounded_recv_many (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_set",
                        "label": "test_join_set",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_join_set () { loom :: model (| | { let rt = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let mut set = JoinSet :: new () ; rt . block_on (async { assert_eq ! (set . len () , 0) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 2) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 2) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 0) ; set . spawn (async { () }) ; assert_eq ! (set . len () , 1) ; }) ; drop (set) ; drop (rt) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_stream_with_buffer",
                        "label": "send_recv_stream_with_buffer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] async fn send_recv_stream_with_buffer () { use tokio_stream :: StreamExt ; let (tx , rx) = support :: mpsc_stream :: channel_stream :: < i32 > (16) ; let mut rx = Box :: pin (rx) ; tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; }) ; assert_eq ! (Some (1) , rx . next () . await) ; assert_eq ! (Some (2) , rx . next () . await) ; assert_eq ! (None , rx . next () . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_sender_failure",
                        "label": "downgrade_upgrade_sender_failure",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_upgrade_sender_failure () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_local_without_name",
                        "label": "spawn_local_without_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_local_without_name () { let unsend_data = Rc :: new (\"task executed\") ; let result = LocalSet :: new () . run_until (async move { Builder :: new () . spawn_local (async move { unsend_data }) . unwrap () . await }) . await ; assert_eq ! (* result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_no_poll",
                        "label": "sleep_no_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_no_poll () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut sleep = task :: spawn (time :: sleep_until (start + ms (300))) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "alternating",
                        "label": "alternating",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn alternating () { let mut map = JoinMap :: new () ; assert_eq ! (map . len () , 0) ; map . spawn (1 , async { }) ; assert_eq ! (map . len () , 1) ; map . spawn (2 , async { }) ; assert_eq ! (map . len () , 2) ; for i in 0 .. 16 { let (_ , res) = map . join_next () . await . unwrap () ; assert ! (res . is_ok ()) ; assert_eq ! (map . len () , 1) ; map . spawn (i , async { }) ; assert_eq ! (map . len () , 2) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join",
                        "label": "join",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Join two values implementing `AsyncRead` and `AsyncWrite` into a\"] # [doc = \" single handle.\"] pub fn join < R , W > (reader : R , writer : W) -> Join < R , W > where R : AsyncRead , W : AsyncWrite , { Join { reader , writer } } . sig",
                        "file_path": "tokio/src/io/join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "event_requires_infinite_sleep_in_handler",
                        "label": "event_requires_infinite_sleep_in_handler",
                        "kind": "Function",
                        "signature": "fn fn event_requires_infinite_sleep_in_handler (signum : u32) -> bool { match signum { console :: CTRL_CLOSE_EVENT => true , console :: CTRL_LOGOFF_EVENT => true , console :: CTRL_SHUTDOWN_EVENT => true , _ => false , } } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_fn",
                        "label": "async_fn",
                        "kind": "Function",
                        "signature": "fn # [test] fn async_fn () { assert_eq ! (5 , block_on (five ())) ; } . sig",
                        "file_path": "tokio-test/tests/block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "eof",
                        "label": "eof",
                        "kind": "Function",
                        "signature": "fn fn eof () -> io :: Error { io :: Error :: new (io :: ErrorKind :: UnexpectedEof , \"early eof\") } . sig",
                        "file_path": "tokio/src/io/util/read_exact.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval_panic_caller",
                        "label": "interval_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn interval_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = interval (Duration :: from_millis (0)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SyncWrapper",
                        "label": "SyncWrapper",
                        "kind": "Struct",
                        "signature": "struct SyncWrapper",
                        "file_path": "tokio/src/util/sync_wrapper.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "chained_steal",
                        "label": "chained_steal",
                        "kind": "Function",
                        "signature": "fn # [test] fn chained_steal () { loom :: model (| | { let mut stats = new_stats () ; let (s1 , mut l1) = queue :: local () ; let (s2 , mut l2) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; for _ in 0 .. 4 { let (task , _) = unowned (async { }) ; l1 . push_back_or_overflow (task , & inject , & mut stats) ; let (task , _) = unowned (async { }) ; l2 . push_back_or_overflow (task , & inject , & mut stats) ; } let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; s1 . steal_into (& mut local , & mut stats) ; while local . pop () . is_some () { } }) ; while l1 . pop () . is_some () { } s2 . steal_into (& mut l1 , & mut stats) ; th . join () . unwrap () ; while l1 . pop () . is_some () { } while l2 . pop () . is_some () { } }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_concurrent_contended_multi",
                        "label": "read_concurrent_contended_multi",
                        "kind": "Function",
                        "signature": "fn fn read_concurrent_contended_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent_multi\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let write = lock . write () . await ; let j = tokio :: try_join ! { async move { drop (write) ; Ok (()) } , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , task :: spawn (task (lock . clone ())) , } ; j . unwrap () ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "consume_budget",
                        "label": "consume_budget",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Consumes a unit of budget and returns the execution back to the Tokio\"] # [doc = \" runtime *if* the task's coop budget was exhausted.\"] # [doc = \"\"] # [doc = \" The task will only yield if its entire coop budget has been exhausted.\"] # [doc = \" This function can be used in order to insert optional yield points into long\"] # [doc = \" computations that do not use Tokio resources like sockets or semaphores,\"] # [doc = \" without redundantly yielding to the runtime each time.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Make sure that a function which returns a sum of (potentially lots of)\"] # [doc = \" iterated values is cooperative.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" async fn sum_iterator(input: &mut impl std::iter::Iterator<Item=i64>) -> i64 {\"] # [doc = \"     let mut sum: i64 = 0;\"] # [doc = \"     while let Some(i) = input.next() {\"] # [doc = \"         sum += i;\"] # [doc = \"         tokio::task::consume_budget().await\"] # [doc = \"     }\"] # [doc = \"     sum\"] # [doc = \" }\"] # [doc = \" ```\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub async fn consume_budget () { let mut status = std :: task :: Poll :: Pending ; std :: future :: poll_fn (move | cx | { std :: task :: ready ! (crate :: trace :: trace_leaf (cx)) ; if status . is_ready () { return status ; } status = crate :: task :: coop :: poll_proceed (cx) . map (| restore | { restore . made_progress () ; }) ; status }) . await } . sig",
                        "file_path": "tokio/src/task/coop/consume_budget.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "to_symboltrace",
                        "label": "to_symboltrace",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Resolve a sequence of [`backtrace::BacktraceFrame`]s into a sequence of\"] # [doc = \" [`Symbol`]s.\"] fn to_symboltrace (backtrace : Backtrace) -> SymbolTrace { let backtrace : Backtrace = { let mut backtrace = backtrace :: Backtrace :: from (backtrace) ; backtrace . resolve () ; backtrace . into () } ; let mut symboltrace : SymbolTrace = vec ! [] ; let mut state = DefaultHasher :: new () ; for frame in backtrace . into_iter () . rev () { for symbol in frame . symbols () . iter () . rev () { let symbol = Symbol { symbol : symbol . clone () , parent_hash : state . finish () , } ; symbol . hash (& mut state) ; symboltrace . push (symbol) ; } } symboltrace } . sig",
                        "file_path": "tokio/src/runtime/task/trace/tree.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal",
                        "label": "signal",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which will receive notifications when the current\"] # [doc = \" process receives the specified signal `kind`.\"] # [doc = \"\"] # [doc = \" This function will create a new stream which binds to the default reactor.\"] # [doc = \" The `Signal` stream is an infinite stream which will receive\"] # [doc = \" notifications whenever a signal is received. More documentation can be\"] # [doc = \" found on `Signal` itself, but to reiterate:\"] # [doc = \"\"] # [doc = \" * Signals may be coalesced beyond what the kernel already does.\"] # [doc = \" * Once a signal handler is registered with the process the underlying\"] # [doc = \"   libc signal handler is never unregistered.\"] # [doc = \"\"] # [doc = \" A `Signal` stream can be created for a particular signal number\"] # [doc = \" multiple times. When a signal is received then all the associated\"] # [doc = \" channels will receive the signal notification.\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" * If the lower-level C functions fail for some reason.\"] # [doc = \" * If the previous initialization of this specific signal failed.\"] # [doc = \" * If the signal is one of\"] # [doc = \"   [`signal_hook::FORBIDDEN`](fn@signal_hook_registry::register#panics)\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current reactor set, or if the `rt`\"] # [doc = \" feature flag is not enabled.\"] # [track_caller] pub fn signal (kind : SignalKind) -> io :: Result < Signal > { let handle = scheduler :: Handle :: current () ; let rx = signal_with_handle (kind , handle . driver () . signal ()) ? ; Ok (Signal { inner : RxFuture :: new (rx) , }) } . sig",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MsgUnbounded",
                        "label": "MsgUnbounded",
                        "kind": "Struct",
                        "signature": "struct MsgUnbounded",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Foo",
                        "label": "Foo",
                        "kind": "Struct",
                        "signature": "struct Foo",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ShardedListItem",
                        "label": "ShardedListItem",
                        "kind": "Trait",
                        "signature": "trait ShardedListItem",
                        "file_path": "tokio/src/util/sharded_list.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "clear_ready_matching_clears_ready",
                        "label": "clear_ready_matching_clears_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn clear_ready_matching_clears_ready () { use tokio :: io :: { Interest , Ready } ; let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; b . write_all (b\"0\") . unwrap () ; let mut guard = afd_a . ready (Interest :: READABLE | Interest :: WRITABLE) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: READABLE | Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: READABLE) ; assert_eq ! (guard . ready () , Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: WRITABLE) ; assert_eq ! (guard . ready () , Ready :: EMPTY) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new",
                        "label": "new",
                        "kind": "Function",
                        "signature": "fn fn new (signum : u32) -> io :: Result < RxFuture > { global_init () ? ; let rx = globals () . register_listener (signum as EventId) ; Ok (RxFuture :: new (rx)) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "temporary_lifetime_extension",
                        "label": "temporary_lifetime_extension",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn temporary_lifetime_extension () { tokio :: select ! { () = & mut std :: future :: ready (()) => { } , } } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_macro_can_be_used_via_use",
                        "label": "test_macro_can_be_used_via_use",
                        "kind": "Function",
                        "signature": "fn # [test] async fn test_macro_can_be_used_via_use () { tokio :: spawn (async { }) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_t_bounds_unbounded",
                        "label": "no_t_bounds_unbounded",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn no_t_bounds_unbounded () { struct NoImpls ; let (tx , mut rx) = mpsc :: unbounded_channel () ; is_debug (& tx) ; is_debug (& rx) ; assert ! (tx . clone () . send (NoImpls) . is_ok ()) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_multi_notified_last",
                        "label": "notify_multi_notified_last",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_multi_notified_last () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_last () ; assert_pending ! (notified1 . poll ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_into_inner_new_with",
                        "label": "drop_into_inner_new_with",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_into_inner_new_with () { let fooer = DropCounter :: new () ; let once_cell = SetOnce :: new_with (Some (fooer . clone ())) ; let val = once_cell . into_inner () ; fooer . assert_num_drops (0) ; drop (val) ; fooer . assert_num_drops (1) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_fns",
                        "label": "poll_fns",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_fns () { let (a , b) = socketpair () ; let afd_a = Arc :: new (AsyncFd :: new (a) . unwrap ()) ; let afd_b = Arc :: new (AsyncFd :: new (b) . unwrap ()) ; let mut bytes = 0 ; while let Ok (amt) = afd_a . get_ref () . write (& [0 ; 512]) { bytes += amt ; } let waker = TestWaker :: new () ; assert_pending ! (afd_a . as_ref () . poll_read_ready (& mut waker . context ())) ; let afd_a_2 = afd_a . clone () ; let r_barrier = Arc :: new (tokio :: sync :: Barrier :: new (2)) ; let barrier_clone = r_barrier . clone () ; let read_fut = tokio :: spawn (async move { assert_pending ! (poll ! (std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_read_ready (cx)))) ; barrier_clone . wait () . await ; let _ = std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_read_ready (cx)) . await ; }) ; let afd_a_2 = afd_a . clone () ; let w_barrier = Arc :: new (tokio :: sync :: Barrier :: new (2)) ; let barrier_clone = w_barrier . clone () ; let mut write_fut = tokio :: spawn (async move { assert_pending ! (poll ! (std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_write_ready (cx)))) ; barrier_clone . wait () . await ; let _ = std :: future :: poll_fn (| cx | afd_a_2 . as_ref () . poll_write_ready (cx)) . await ; }) ; r_barrier . wait () . await ; w_barrier . wait () . await ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = & mut readable => unreachable ! () , _ = tokio :: task :: yield_now () => { } } afd_b . get_ref () . write_all (b\"0\") . unwrap () ; let _ = tokio :: join ! (readable , read_fut) ; assert ! (! waker . awoken ()) ; tokio :: select ! { _ = & mut write_fut => unreachable ! () , _ = tokio :: time :: sleep (Duration :: from_millis (5)) => { } } drain (afd_b . get_ref () , bytes) ; let _ = write_fut . await ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "exit_runtime",
                        "label": "exit_runtime",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Forces the current \\\"entered\\\" state to be cleared while the closure\"] # [doc = \" is executed.\"] pub (crate) fn exit_runtime < F : FnOnce () -> R , R > (f : F) -> R { struct Reset (EnterRuntime) ; impl Drop for Reset { fn drop (& mut self) { CONTEXT . with (| c | { assert ! (! c . runtime . get () . is_entered () , \"closure claimed permanent executor\") ; c . runtime . set (self . 0) ; }) ; } } let was = CONTEXT . with (| c | { let e = c . runtime . get () ; assert ! (e . is_entered () , \"asked to exit when not entered\") ; c . runtime . set (EnterRuntime :: NotEntered) ; e }) ; let _reset = Reset (was) ; f () } . sig",
                        "file_path": "tokio/src/runtime/context/runtime_mt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_bounded_full",
                        "label": "contention_bounded_full",
                        "kind": "Function",
                        "signature": "fn fn contention_bounded_full (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_full\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (100) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Tx",
                        "label": "Tx",
                        "kind": "Struct",
                        "signature": "struct Tx",
                        "file_path": "tokio/src/sync/mpsc/list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_into_inner",
                        "label": "drop_into_inner",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_into_inner () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; let once_cell = OnceCell :: new () ; assert ! (once_cell . set (Foo :: from (num_drops . clone ())) . is_ok ()) ; let fooer = once_cell . into_inner () ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 0) ; drop (fooer) ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 1) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown_after_tcp_reset",
                        "label": "shutdown_after_tcp_reset",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn shutdown_after_tcp_reset () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let (connected_tx , connected_rx) = channel () ; let (dropped_tx , dropped_rx) = channel () ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; connected_tx . send (()) . unwrap () ; dropped_rx . await . unwrap () ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; }) ; let (stream , _) = assert_ok ! (srv . accept () . await) ; stream . set_linger (Some (Duration :: new (0 , 0))) . unwrap () ; connected_rx . await . unwrap () ; drop (stream) ; dropped_tx . send (()) . unwrap () ; handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/tcp_shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_collision_multi_thread",
                        "label": "task_id_collision_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_collision_multi_thread () { let handle1 = tokio :: spawn (async { task :: id () }) ; let handle2 = tokio :: spawn (async { task :: id () }) ; let (id1 , id2) = tokio :: join ! (handle1 , handle2) ; assert_ne ! (id1 . unwrap () , id2 . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_in_block",
                        "label": "block_in_block",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn block_in_block () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { task :: block_in_place (|| { task :: block_in_place (|| { thread :: sleep (Duration :: from_millis (5)) ; }) ; \"hello\" }) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_with_smaller_buf",
                        "label": "read_with_smaller_buf",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_with_smaller_buf () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 4) ; assert_eq ! (& buf [..] , & HELLO [.. n]) ; } let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 10) ; assert_eq ! (& buf [.. n] , & HELLO [4 ..]) ; assert_eq ! (0 , pool :: len ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Acquire",
                        "label": "Acquire",
                        "kind": "Struct",
                        "signature": "struct Acquire",
                        "file_path": "tokio/src/sync/batch_semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_tx_count_weak_sender",
                        "label": "test_tx_count_weak_sender",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_tx_count_weak_sender () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (tx . weak_count () , 2) ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none ()) ; assert ! (tx_weak2 . upgrade () . is_none ()) ; assert_eq ! (tx_weak . strong_count () , 0) ; assert_eq ! (tx_weak . weak_count () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all_buf",
                        "label": "write_all_buf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write_all_buf < 'a , W , B > (writer : & 'a mut W , buf : & 'a mut B) -> WriteAllBuf < 'a , W , B > where W : AsyncWrite + Unpin , B : Buf , { WriteAllBuf { writer , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/write_all_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "echo_from",
                        "label": "echo_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo_from () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = UnixDatagram :: bind (server_path . clone ()) ? ; tokio :: spawn (async move { let _ = echo_server (server_socket) . await ; }) ; { let socket = UnixDatagram :: bind (& client_path) . unwrap () ; socket . connect (& server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let (len , addr) = socket . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; assert_eq ! (addr . as_pathname () , Some (server_path . as_path ())) ; } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RawTask",
                        "label": "RawTask",
                        "kind": "Struct",
                        "signature": "struct RawTask",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_single_frame_one_packet",
                        "label": "write_single_frame_one_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_frame_one_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_buf",
                        "label": "try_read_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_read_buf () -> std :: io :: Result < () > { let msg = b\"hello world\" ; let dir = tempfile :: tempdir () ? ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = UnixListener :: bind (& bind_path) ? ; let client = UnixStream :: connect (& bind_path) . await ? ; let (server , _) = listener . accept () . await ? ; let mut written = msg . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await ? ; assert_eq ! (msg . len () , client . try_write (msg) ?) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (msg) { Ok (n) => written . extend (& msg [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = Vec :: with_capacity (written . len ()) ; let mut i = 0 ; while i < read . capacity () { server . readable () . await ? ; match server . try_read_buf (& mut read) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await ? ; if ready . is_read_closed () { break ; } else { tokio :: task :: yield_now () . await ; } } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_with_interest",
                        "label": "try_with_interest",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_with_interest () { let original = Arc :: new (InvalidSource) ; let error = AsyncFd :: try_with_interest (original . clone () , Interest :: READABLE) . unwrap_err () ; let (returned , _cause) = error . into_parts () ; assert ! (Arc :: ptr_eq (& original , & returned)) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "question_mark_operator_with_invalid_option",
                        "label": "question_mark_operator_with_invalid_option",
                        "kind": "Function",
                        "signature": "fn # [doc = \" This test is a characterization test for the `?` operator.\"] # [doc = \"\"] # [doc = \" See <https://github.com/tokio-rs/tokio/issues/6930#issuecomment-2572502517> for more details.\"] # [doc = \"\"] # [doc = \" It should fail with a single error message about the return type of the function, but instead\"] # [doc = \" if fails with an extra error message due to the `?` operator being used within the async block\"] # [doc = \" rather than the original function.\"] # [doc = \"\"] # [doc = \" ```text\"] # [doc = \" 28 |     None?;\"] # [doc = \"    |         ^ cannot use the `?` operator in an async block that returns `()`\"] # [doc = \" ```\"] # [tokio :: main] async fn question_mark_operator_with_invalid_option () -> Option < () > { None ? ; } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AsyncWrite",
                        "label": "AsyncWrite",
                        "kind": "Trait",
                        "signature": "trait AsyncWrite",
                        "file_path": "tokio/src/io/async_write.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "mutex_in_block_in_place",
                        "label": "mutex_in_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn mutex_in_block_in_place () { const BUDGET : usize = 128 ; let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { let lock = tokio :: sync :: Mutex :: new (0) ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | { tokio :: runtime :: Handle :: current () . block_on (async move { for i in 0 .. (BUDGET + 1) { let mut guard = lock . lock () . await ; * guard = i ; } }) ; }) }) . await . unwrap () ; }) } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BadReader",
                        "label": "BadReader",
                        "kind": "Struct",
                        "signature": "struct BadReader",
                        "file_path": "tokio/tests/io_take.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "into_inner_int_empty_setonce",
                        "label": "into_inner_int_empty_setonce",
                        "kind": "Function",
                        "signature": "fn # [test] fn into_inner_int_empty_setonce () { let once = SetOnce :: < u32 > :: new () ; let val = once . into_inner () ; assert ! (val . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "disable_with_if",
                        "label": "disable_with_if",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn disable_with_if () { use tokio_test :: task ; let f = poll_fn (| _ | panic ! ()) ; let (tx , rx) = oneshot :: channel () ; let mut f = task :: spawn (async { tokio :: select ! { _ = f , if false => unreachable ! () , _ = rx => () , } }) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx . send (())) ; assert ! (f . is_woken ()) ; assert_ready ! (f . poll ()) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "acquire_mutex_in_drop",
                        "label": "acquire_mutex_in_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn acquire_mutex_in_drop () { use futures :: future :: pending ; use tokio :: task ; let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; let rt = rt () ; rt . spawn (async move { let _ = rx2 . await ; unreachable ! () ; }) ; rt . spawn (async move { let _ = rx1 . await ; tx2 . send (()) . unwrap () ; unreachable ! () ; }) ; rt . spawn (async move { pending :: < () > () . await ; tx1 . send (()) . unwrap () ; }) ; rt . block_on (async { task :: yield_now () . await ; }) ; drop (rt) ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge",
                        "label": "merge",
                        "kind": "Function",
                        "signature": "fn # [test] fn merge () { let sem = Arc :: new (Semaphore :: new (3)) ; { let mut p1 = sem . clone () . try_acquire_owned () . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; let p2 = sem . clone () . try_acquire_many_owned (2) . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p1 . merge (p2) ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 3) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_instantly_closed",
                        "label": "size_hint_stream_instantly_closed",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_hint_stream_instantly_closed () { let (_tx , rx) = mpsc :: unbounded_channel :: < i32 > () ; let mut stream = UnboundedReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AtomicU32",
                        "label": "AtomicU32",
                        "kind": "Struct",
                        "signature": "struct AtomicU32",
                        "file_path": "tokio/src/loom/std/atomic_u32.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Tree",
                        "label": "Tree",
                        "kind": "Struct",
                        "signature": "struct Tree",
                        "file_path": "tokio/src/runtime/task/trace/tree.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "two_await",
                        "label": "two_await",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn two_await () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: join ! (async { rx1 . await . unwrap () } , async { rx2 . await . unwrap () }) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; tx1 . send (\"hello\") . unwrap () ; assert ! (join . is_woken ()) ; let res = assert_ready ! (join . poll ()) ; assert_eq ! ((\"hello\" , 123) , res) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_empty_try_recv",
                        "label": "receiver_is_empty_try_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_empty_try_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_empty () , \"channel is NOT empty after value is sent\") ; let value = rx . try_recv () . expect (\"value is waiting\") ; assert_eq ! (value , 17) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "InvalidSource",
                        "label": "InvalidSource",
                        "kind": "Struct",
                        "signature": "struct InvalidSource",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [test] fn split () { let sem = Semaphore :: new (5) ; let mut p1 = sem . try_acquire_many (3) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 3) ; let mut p2 = p1 . split (1) . unwrap () ; assert_eq ! (sem . available_permits () , 2) ; assert_eq ! (p1 . num_permits () , 2) ; assert_eq ! (p2 . num_permits () , 1) ; let p3 = p1 . split (0) . unwrap () ; assert_eq ! (p3 . num_permits () , 0) ; drop (p1) ; assert_eq ! (sem . available_permits () , 4) ; let p4 = p2 . split (1) . unwrap () ; assert_eq ! (p2 . num_permits () , 0) ; assert_eq ! (p4 . num_permits () , 1) ; assert ! (p2 . split (1) . is_none ()) ; drop (p2) ; assert_eq ! (sem . available_permits () , 4) ; drop (p3) ; assert_eq ! (sem . available_permits () , 4) ; drop (p4) ; assert_eq ! (sem . available_permits () , 5) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_write_and_shutdown",
                        "label": "basic_write_and_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_write_and_shutdown () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . write_all (HELLO) . await . unwrap () ; file . shutdown () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "has_changed_errors_on_closed_channel_with_unseen_value",
                        "label": "has_changed_errors_on_closed_channel_with_unseen_value",
                        "kind": "Function",
                        "signature": "fn # [test] fn has_changed_errors_on_closed_channel_with_unseen_value () { let (tx , rx) = watch :: channel (\"A\") ; tx . send (\"B\") . unwrap () ; drop (tx) ; rx . has_changed () . expect_err (\"`has_changed` returns an error if and only if channel is closed. Even if the current value is not seen.\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_at_most_num_polls",
                        "label": "assert_at_most_num_polls",
                        "kind": "Function",
                        "signature": "fn fn assert_at_most_num_polls (rt : Arc < Runtime > , at_most_polls : usize) { let (tx , rx) = oneshot :: channel () ; let num_polls = Arc :: new (AtomicUsize :: new (0)) ; rt . spawn (async move { for _ in 0 .. 12 { task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; rt . block_on (async { BlockedFuture { rx , num_polls : num_polls . clone () , } . await ; }) ; let polls = num_polls . load (Acquire) ; assert ! (polls <= at_most_polls) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "into_panic_panic_caller",
                        "label": "into_panic_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn into_panic_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (move | | { let rt = current_thread () ; rt . block_on (async { let handle = tokio :: spawn (future :: pending :: < () > ()) ; handle . abort () ; let err = handle . await . unwrap_err () ; assert ! (!& err . is_panic ()) ; let _ = err . into_panic () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SyncIoBridge",
                        "label": "SyncIoBridge",
                        "kind": "Struct",
                        "signature": "struct SyncIoBridge",
                        "file_path": "tokio-util/src/io/sync_bridge.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_zero",
                        "label": "write_zero",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_zero () { let io = length_delimited :: Builder :: new () . new_write (mock ! { }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_ready_err ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_fd_with_interest_panic_caller",
                        "label": "async_fd_with_interest_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] fn async_fd_with_interest_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: io :: Interest ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: with_interest (fd , Interest :: READABLE) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ArcFd",
                        "label": "ArcFd",
                        "kind": "Struct",
                        "signature": "struct ArcFd",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_encoder",
                        "label": "any_delimiter_encoder",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_encoder () { let mut codec = AnyDelimiterCodec :: new (b\",\" . to_vec () , b\";--;\" . to_vec ()) ; let mut buf = BytesMut :: new () ; codec . encode (\"chunk 1\" , & mut buf) . unwrap () ; assert_eq ! (\"chunk 1;--;\" , buf) ; codec . encode (\"chunk 2\" , & mut buf) . unwrap () ; assert_eq ! (\"chunk 1;--;chunk 2;--;\" , buf) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn std :: error :: Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (socket , _) = listener . accept () . await ? ; tokio :: spawn (async move { let mut framed = BytesCodec :: new () . framed (socket) ; while let Some (message) = framed . next () . await { match message { Ok (bytes) => println ! (\"bytes: {bytes:?}\") , Err (err) => println ! (\"Socket closed with error: {err:?}\") , } } println ! (\"Socket received FIN packet and closed connection\") ; }) ; } } . sig",
                        "file_path": "examples/print_each_packet.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lookup_str_socket_addr",
                        "label": "lookup_str_socket_addr",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn lookup_str_socket_addr () { let addr : SocketAddr = \"127.0.0.1:8000\" . parse () . unwrap () ; let actual = assert_ok ! (net :: lookup_host (\"127.0.0.1:8000\") . await) . collect :: < Vec < _ > > () ; assert_eq ! (vec ! [addr] , actual) ; } . sig",
                        "file_path": "tokio/tests/net_lookup_host.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_send_recv",
                        "label": "async_send_recv",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn async_send_recv () { let (tx , rx) = oneshot :: channel () ; assert_ok ! (tx . send (1)) ; assert_eq ! (1 , assert_ok ! (rx . await)) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_buf",
                        "label": "recv_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn recv_buf () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = Vec :: with_capacity (32) ; let len = receiver . recv_buf (& mut recv_buf) . await ? ; assert_eq ! (len , MSG_LEN) ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
                        "label": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn a_different_future_is_polled_first_every_time_poll_fn_is_polled () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } } ; tokio :: join ! (fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) ; assert_eq ! (vec ! [1 , 2 , 3 , 2 , 3 , 1 , 3 , 1 , 2 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bounded_mpsc_channel",
                        "label": "bounded_mpsc_channel",
                        "kind": "Function",
                        "signature": "fn # [test] fn bounded_mpsc_channel () { test_with_runtimes (| | { let (tx , mut rx) = mpsc :: channel (1024) ; Handle :: current () . block_on (tx . send (42)) . unwrap () ; let value = Handle :: current () . block_on (rx . recv ()) . unwrap () ; assert_eq ! (value , 42) ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskMeta",
                        "label": "TaskMeta",
                        "kind": "Struct",
                        "signature": "struct TaskMeta",
                        "file_path": "tokio/src/runtime/task_hooks.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_multi_client",
                        "label": "test_named_pipe_multi_client",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_multi_client () -> io :: Result < () > { use tokio :: io :: { AsyncBufReadExt as _ , BufReader } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-multi-client\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { for _ in 0 .. N { server . connect () . await ? ; let mut inner = BufReader :: new (server) ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; tokio :: spawn (async move { let mut buf = String :: new () ; inner . read_line (& mut buf) . await ? ; inner . write_all (b\"pong\\n\") . await ? ; inner . flush () . await ? ; Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) if e . kind () == io :: ErrorKind :: NotFound => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (10)) . await ; } ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . flush () . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (result ?, \"pong\\n\") ; } server . await ? ? ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_exact_arc",
                        "label": "read_exact_arc",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Read data from an `AsyncRead` into an `Arc`.\"] # [doc = \"\"] # [doc = \" This uses `Arc::new_uninit_slice` and reads into the resulting uninitialized `Arc`.\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \" use tokio_util::io::read_exact_arc;\"] # [doc = \"\"] # [doc = \" let read = tokio::io::repeat(42);\"] # [doc = \"\"] # [doc = \" let arc = read_exact_arc(read, 4).await?;\"] # [doc = \"\"] # [doc = \" assert_eq!(&arc[..], &[42; 4]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_exact_arc < R : AsyncRead > (read : R , len : usize) -> io :: Result < Arc < [u8] > > { tokio :: pin ! (read) ; let arc : Arc < [MaybeUninit < u8 >] > = (0 .. len) . map (| _ | MaybeUninit :: uninit ()) . collect () ; let mut buf = unsafe { & mut * (Arc :: as_ptr (& arc) as * mut [MaybeUninit < u8 >]) } ; while ! buf . is_empty () { if read . read_buf (& mut buf) . await ? == 0 { return Err (io :: Error :: new (io :: ErrorKind :: UnexpectedEof , \"early eof\")) ; } } Ok (unsafe { Arc :: from_raw (Arc :: into_raw (arc) as * const [u8]) }) } . sig",
                        "file_path": "tokio-util/src/io/read_arc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Link",
                        "label": "Link",
                        "kind": "Trait",
                        "signature": "trait Link",
                        "file_path": "tokio/src/util/linked_list.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "mk_spawn_location_hook",
                        "label": "mk_spawn_location_hook",
                        "kind": "Function",
                        "signature": "fn fn mk_spawn_location_hook (event : & 'static str , count : & Arc < AtomicUsize > ,) -> impl Fn (& tokio :: runtime :: TaskMeta < '_ >) { let count = Arc :: clone (count) ; move | data | { eprintln ! (\"{event} ({:?}): {:?}\" , data . id () , data . spawned_at ()) ; assert_eq ! (data . spawned_at () . file () , file ! () , \"incorrect spawn location in {event} hook\" ,) ; count . fetch_add (1 , Ordering :: SeqCst) ; } } . sig",
                        "file_path": "tokio/tests/task_hooks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_fails",
                        "label": "try_reserve_fails",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_reserve_fails () { let (tx , mut rx) = mpsc :: channel (1) ; let permit = tx . try_reserve () . unwrap () ; match assert_err ! (tx . try_reserve ()) { TrySendError :: Full (()) => { } _ => panic ! () , } permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; let permit = tx . try_reserve () . unwrap () ; drop (permit) ; let _permit = tx . try_reserve () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with_current",
                        "label": "with_current",
                        "kind": "Function",
                        "signature": "fn # [track_caller] fn with_current < R > (f : impl FnOnce (Option < & Context >) -> R) -> R { use scheduler :: Context :: MultiThread ; context :: with_scheduler (| ctx | match ctx { Some (MultiThread (ctx)) => f (Some (ctx)) , _ => f (None) , }) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_read_from_existing_buf_after_codec_changed",
                        "label": "can_read_from_existing_buf_after_codec_changed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn can_read_from_existing_buf_after_codec_changed () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 84] [..]) ; let mut framed = Framed :: from_parts (parts) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 42) ; assert_eq ! (framed . codec () . read_bytes , 4) ; let mut framed = framed . map_codec (| codec | U64Codec { read_bytes : codec . read_bytes , }) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 84) ; assert_eq ! (framed . codec () . read_bytes , 12) ; } . sig",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tcp_into_std",
                        "label": "tcp_into_std",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn tcp_into_std () -> Result < () > { let mut data = [0u8 ; 12] ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await ? ; let addr = listener . local_addr () . unwrap () . to_string () ; let handle = tokio :: spawn (async { let stream : TcpStream = TcpStream :: connect (addr) . await . unwrap () ; stream }) ; let (tokio_tcp_stream , _) = listener . accept () . await ? ; let mut std_tcp_stream = tokio_tcp_stream . into_std () ? ; std_tcp_stream . set_nonblocking (false) . expect (\"set_nonblocking call failed\") ; let mut client = handle . await . expect (\"The task being joined has panicked\") ; client . write_all (b\"Hello world!\") . await ? ; std_tcp_stream . read_exact (& mut data) . expect (\"std TcpStream read failed!\") ; assert_eq ! (b\"Hello world!\" , & data) ; std_tcp_stream . set_nonblocking (true) . expect (\"set_nonblocking call failed\") ; let mut tokio_tcp_stream = TcpStream :: from_std (std_tcp_stream) ? ; client . write_all (b\"Hello tokio!\") . await ? ; let _size = tokio_tcp_stream . read_exact (& mut data) . await ? ; assert_eq ! (b\"Hello tokio!\" , & data) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/tcp_into_std.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "two",
                        "label": "two",
                        "kind": "Function",
                        "signature": "fn async fn two () { } . sig",
                        "file_path": "tokio/tests/macros_pin.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "check_socket_for_blocking",
                        "label": "check_socket_for_blocking",
                        "kind": "Function",
                        "signature": "fn # [cfg (unix)] # [allow (unused_variables)] # [track_caller] pub (crate) fn check_socket_for_blocking < S : AsFd > (s : & S) -> crate :: io :: Result < () > { # [cfg (not (tokio_allow_from_blocking_fd))] { let sock = socket2 :: SockRef :: from (s) ; debug_assert ! (sock . nonblocking () ?, \"Registering a blocking socket with the tokio runtime is unsupported. \\\n            If you wish to do anyways, please add `--cfg tokio_allow_from_blocking_fd` to your \\\n            RUSTFLAGS. See github.com/tokio-rs/tokio/issues/7172 for details.\") ; } Ok (()) } . sig",
                        "file_path": "tokio/src/util/blocking_check.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reserve_many_above_cap",
                        "label": "reserve_many_above_cap",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn reserve_many_above_cap () { const MAX_PERMITS : usize = tokio :: sync :: Semaphore :: MAX_PERMITS ; let (tx , _rx) = mpsc :: channel :: < () > (1) ; assert_err ! (tx . reserve_many (2) . await) ; assert_err ! (tx . reserve_many (MAX_PERMITS + 1) . await) ; assert_err ! (tx . reserve_many (usize :: MAX) . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "future_panics_after_poll",
                        "label": "future_panics_after_poll",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn future_panics_after_poll () { use tokio_test :: task ; let (tx , rx) = oneshot :: channel () ; let mut polled = false ; let f = poll_fn (| _ | { assert ! (! polled) ; polled = true ; Ready (None :: < () >) }) ; let mut f = task :: spawn (async { tokio :: select ! { Some (_) = f => unreachable ! () , ret = rx => ret . unwrap () , } }) ; assert_pending ! (f . poll ()) ; assert_pending ! (f . poll ()) ; assert_ok ! (tx . send (1)) ; let res = assert_ready ! (f . poll ()) ; assert_eq ! (1 , res) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Dump",
                        "label": "Dump",
                        "kind": "Struct",
                        "signature": "struct Dump",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let listen_addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8081\" . to_string ()) ; let server_addr = env :: args () . nth (2) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; println ! (\"Listening on: {listen_addr}\") ; println ! (\"Proxying to: {server_addr}\") ; let listener = TcpListener :: bind (listen_addr) . await ? ; while let Ok ((mut inbound , _)) = listener . accept () . await { let mut outbound = TcpStream :: connect (server_addr . clone ()) . await ? ; tokio :: spawn (async move { copy_bidirectional (& mut inbound , & mut outbound) . map (| r | { if let Err (e) = r { println ! (\"Failed to transfer; error={e}\") ; } }) . await }) ; } Ok (()) } . sig",
                        "file_path": "examples/proxy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BlockedFuture",
                        "label": "BlockedFuture",
                        "kind": "Struct",
                        "signature": "struct BlockedFuture",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "remove_file",
                        "label": "remove_file",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Removes a file from the filesystem.\"] # [doc = \"\"] # [doc = \" Note that there is no guarantee that the file is immediately deleted (e.g.\"] # [doc = \" depending on platform, other open file descriptors may prevent immediate\"] # [doc = \" removal).\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_file`].\"] pub async fn remove_file (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_file (path)) . await } . sig",
                        "file_path": "tokio/src/fs/remove_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "coop",
                        "label": "coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn coop () { let mut stream = task :: spawn (stream :: iter (iter :: repeat (1))) ; for _ in 0 .. 10_000 { if stream . poll_next () . is_pending () { assert ! (stream . is_woken ()) ; return ; } } panic ! (\"did not yield\") ; } . sig",
                        "file_path": "tokio-stream/tests/stream_iter.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder",
                        "label": "lines_decoder",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder () { let mut codec = LinesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1\\nline 2\\r\\nline 3\\n\\r\\n\\r\") ; assert_eq ! (\"line 1\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"line 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"line 3\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (\"\\rk\" , codec . decode_eof (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_close",
                        "label": "ctrl_close",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_close () -> io :: Result < RxFuture > { new (console :: CTRL_CLOSE_EVENT) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "NN",
                        "label": "NN",
                        "kind": "Struct",
                        "signature": "struct NN",
                        "file_path": "tokio/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "trait_method",
                        "label": "trait_method",
                        "kind": "Function",
                        "signature": "fn # [std :: prelude :: v1 :: test] fn trait_method () { trait A { fn f (self) ; fn g (self) ; } impl A for () { # [tokio :: main] async fn f (self) { self . g () } fn g (self) { } } () . f () } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poor_little_task",
                        "label": "poor_little_task",
                        "kind": "Function",
                        "signature": "fn async fn poor_little_task (permits : Arc < Semaphore >) -> Result < usize , String > { let mut how_many_times_i_got_to_run = 0 ; for _ in 0 .. 5 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; how_many_times_i_got_to_run += 1 ; } Ok (how_many_times_i_got_to_run) } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_spawn_sizes_recorded",
                        "label": "task_spawn_sizes_recorded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_spawn_sizes_recorded () { let future = futures :: future :: ready (()) ; let size = mem :: size_of_val (& future) as u64 ; let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"size.bytes\") . with_value (& size)) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (future) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "threaded_no_lifo",
                        "label": "threaded_no_lifo",
                        "kind": "Function",
                        "signature": "fn fn threaded_no_lifo () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . disable_lifo_slot () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drops_tasks",
                        "label": "drops_tasks",
                        "kind": "Function",
                        "signature": "fn # [test] fn drops_tasks () { let (mut tx , mut rx) = oneshot :: channel :: < i32 > () ; let mut tx_task = task :: spawn (()) ; let mut rx_task = task :: spawn (()) ; assert_pending ! (tx_task . enter (| cx , _ | tx . poll_closed (cx))) ; assert_pending ! (rx_task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; drop (tx) ; drop (rx) ; assert_eq ! (1 , tx_task . waker_ref_count ()) ; assert_eq ! (1 , rx_task . waker_ref_count ()) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "repeated_poll_reserve",
                        "label": "repeated_poll_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn repeated_poll_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "many_multishot_futures",
                        "label": "many_multishot_futures",
                        "kind": "Function",
                        "signature": "fn # [test] fn many_multishot_futures () { const CHAIN : usize = 200 ; const CYCLES : usize = 5 ; const TRACKS : usize = 50 ; for _ in 0 .. 50 { let rt = rt () ; let mut start_txs = Vec :: with_capacity (TRACKS) ; let mut final_rxs = Vec :: with_capacity (TRACKS) ; for _ in 0 .. TRACKS { let (start_tx , mut chain_rx) = tokio :: sync :: mpsc :: channel (10) ; for _ in 0 .. CHAIN { let (next_tx , next_rx) = tokio :: sync :: mpsc :: channel (10) ; rt . spawn (async move { while let Some (v) = chain_rx . recv () . await { next_tx . send (v) . await . unwrap () ; } }) ; chain_rx = next_rx ; } let (final_tx , final_rx) = tokio :: sync :: mpsc :: channel (10) ; let cycle_tx = start_tx . clone () ; let mut rem = CYCLES ; rt . spawn (async move { for _ in 0 .. CYCLES { let msg = chain_rx . recv () . await . unwrap () ; rem -= 1 ; if rem == 0 { final_tx . send (msg) . await . unwrap () ; } else { cycle_tx . send (msg) . await . unwrap () ; } } }) ; start_txs . push (start_tx) ; final_rxs . push (final_rx) ; } { rt . block_on (async move { for start_tx in start_txs { start_tx . send (\"ping\") . await . unwrap () ; } for mut final_rx in final_rxs { final_rx . recv () . await . unwrap () ; } }) ; } } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "run_until_cancelled_owned_test",
                        "label": "run_until_cancelled_owned_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn run_until_cancelled_owned_test () { let (waker , _) = new_count_waker () ; { let token = CancellationToken :: new () ; let to_cancel = token . clone () ; let takes_ownership = move | token : CancellationToken | { token . run_until_cancelled_owned (std :: future :: pending :: < () > ()) } ; let fut = takes_ownership (token) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; to_cancel . cancel () ; assert_eq ! (Poll :: Ready (None) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } { let (tx , rx) = oneshot :: channel :: < () > () ; let token = CancellationToken :: new () ; let takes_ownership = move | token : CancellationToken , rx : oneshot :: Receiver < () > | { token . run_until_cancelled_owned (async move { rx . await . unwrap () ; 42 }) } ; let fut = takes_ownership (token , rx) ; pin ! (fut) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; tx . send (()) . unwrap () ; assert_eq ! (Poll :: Ready (Some (42)) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "nonempty_after_send",
                        "label": "nonempty_after_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn nonempty_after_send () { loom :: model (| | { let (send , recv) = mpsc :: channel (10) ; let send2 = send . clone () ; let join = thread :: spawn (move | | { block_on (send2 . send (\"message2\")) . unwrap () ; }) ; block_on (send . send (\"message1\")) . unwrap () ; assert ! (! recv . is_empty ()) ; join . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_closed_when_calling_close_with_sender",
                        "label": "test_rx_unbounded_is_closed_when_calling_close_with_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_calling_close_with_sender () { let (_tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_host_str_port_tuple",
                        "label": "connect_addr_host_str_port_tuple",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_host_str_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (\"localhost\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_read_ready",
                        "label": "poll_read_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_read_ready () { let (mut client , mut server) = create_pair () . await ; assert_not_readable_by_polling ! (server) ; assert_ok ! (client . write_all (b\"ping\") . await) ; assert_readable_by_polling ! (server) ; let mut buf = [0u8 ; 4] ; assert_ok ! (server . read_exact (& mut buf) . await) ; assert_readable_by_polling ! (server) ; read_until_pending (& mut server) ; assert_not_readable_by_polling ! (server) ; drop (client) ; assert_readable_by_polling ! (server) ; } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_read_buf",
                        "label": "poll_read_buf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Try to read data from an `AsyncRead` into an implementer of the [`BufMut`] trait.\"] # [doc = \"\"] # [doc = \" [`BufMut`]: bytes::Buf\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use bytes::{Bytes, BytesMut};\"] # [doc = \" use tokio_stream as stream;\"] # [doc = \" use tokio::io::Result;\"] # [doc = \" use tokio_util::io::{StreamReader, poll_read_buf};\"] # [doc = \" use std::future::poll_fn;\"] # [doc = \" use std::pin::Pin;\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \"\"] # [doc = \" // Create a reader from an iterator. This particular reader will always be\"] # [doc = \" // ready.\"] # [doc = \" let mut read = StreamReader::new(stream::iter(vec![Result::Ok(Bytes::from_static(&[0, 1, 2, 3]))]));\"] # [doc = \"\"] # [doc = \" let mut buf = BytesMut::new();\"] # [doc = \" let mut reads = 0;\"] # [doc = \"\"] # [doc = \" loop {\"] # [doc = \"     reads += 1;\"] # [doc = \"     let n = poll_fn(|cx| poll_read_buf(Pin::new(&mut read), cx, &mut buf)).await?;\"] # [doc = \"\"] # [doc = \"     if n == 0 {\"] # [doc = \"         break;\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" // one or more reads might be necessary.\"] # [doc = \" assert!(reads >= 1);\"] # [doc = \" assert_eq!(&buf[..], &[0, 1, 2, 3]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] # [cfg_attr (not (feature = \"io\") , allow (unreachable_pub))] pub fn poll_read_buf < T : AsyncRead + ? Sized , B : BufMut > (io : Pin < & mut T > , cx : & mut Context < '_ > , buf : & mut B ,) -> Poll < io :: Result < usize > > { if ! buf . has_remaining_mut () { return Poll :: Ready (Ok (0)) ; } let n = { let dst = buf . chunk_mut () ; let dst = unsafe { dst . as_uninit_slice_mut () } ; let mut buf = ReadBuf :: uninit (dst) ; let ptr = buf . filled () . as_ptr () ; ready ! (io . poll_read (cx , & mut buf) ?) ; assert_eq ! (ptr , buf . filled () . as_ptr ()) ; buf . filled () . len () } ; unsafe { buf . advance_mut (n) ; } Poll :: Ready (Ok (n)) } . sig",
                        "file_path": "tokio-util/src/util/poll_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AioSource",
                        "label": "AioSource",
                        "kind": "Trait",
                        "signature": "trait AioSource",
                        "file_path": "tokio/src/io/bsd/poll_aio.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_reader",
                        "label": "test_stream_reader",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_stream_reader () -> std :: io :: Result < () > { let stream = iter (vec ! [std :: io :: Result :: Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [0 , 1 , 2 , 3])) , Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [4 , 5 , 6 , 7])) , Ok (Bytes :: from_static (& [])) , Ok (Bytes :: from_static (& [8 , 9 , 10 , 11])) , Ok (Bytes :: from_static (& [])) ,]) ; let mut read = StreamReader :: new (stream) ; let mut buf = [0 ; 5] ; read . read_exact (& mut buf) . await ? ; assert_eq ! (buf , [0 , 1 , 2 , 3 , 4]) ; assert_eq ! (read . read (& mut buf) . await ?, 3) ; assert_eq ! (& buf [.. 3] , [5 , 6 , 7]) ; assert_eq ! (read . read (& mut buf) . await ?, 4) ; assert_eq ! (& buf [.. 4] , [8 , 9 , 10 , 11]) ; assert_eq ! (read . read (& mut buf) . await ?, 0) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_stream_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "batch",
                        "label": "batch",
                        "kind": "Function",
                        "signature": "fn # [test] fn batch () { let mut b = loom :: model :: Builder :: new () ; b . preemption_bound = Some (1) ; b . check (| | { let semaphore = Arc :: new (Semaphore :: new (10)) ; let active = Arc :: new (AtomicUsize :: new (0)) ; let mut ths = vec ! [] ; for _ in 0 .. 2 { let semaphore = semaphore . clone () ; let active = active . clone () ; ths . push (thread :: spawn (move | | { for n in & [4 , 10 , 8] { block_on (semaphore . acquire (* n)) . unwrap () ; active . fetch_add (* n as usize , SeqCst) ; let num_active = active . load (SeqCst) ; assert ! (num_active <= 10) ; thread :: yield_now () ; active . fetch_sub (* n as usize , SeqCst) ; semaphore . release (* n as usize) ; } })) ; } for th in ths . into_iter () { th . join () . unwrap () ; } assert_eq ! (10 , semaphore . available_permits ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let remote_addr : SocketAddr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . into ()) . parse () ? ; let local_addr : SocketAddr = if remote_addr . is_ipv4 () { \"0.0.0.0:0\" } else { \"[::]:0\" } . parse () ? ; let socket = UdpSocket :: bind (local_addr) . await ? ; const MAX_DATAGRAM_SIZE : usize = 65_507 ; socket . connect (& remote_addr) . await ? ; let data = get_stdin_data () ? ; socket . send (& data) . await ? ; let mut data = vec ! [0u8 ; MAX_DATAGRAM_SIZE] ; let len = socket . recv (& mut data) . await ? ; println ! (\"Received {} bytes:\\n{}\" , len , String :: from_utf8_lossy (& data [.. len])) ; Ok (()) } . sig",
                        "file_path": "examples/udp-client.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sink_poll_shutdown_is_cooperative",
                        "label": "sink_poll_shutdown_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sink_poll_shutdown_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { tokio :: io :: sink () . shutdown () . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_sink.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_builder_loc_file_recorded",
                        "label": "task_builder_loc_file_recorded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_builder_loc_file_recorded () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") . with_fields (expect :: field (\"loc.file\") . with_value (& file ! ())) ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . spawn (futures :: future :: ready (())) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Spinner",
                        "label": "Spinner",
                        "kind": "Struct",
                        "signature": "struct Spinner",
                        "file_path": "benches/signal.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "basic_scheduler_spawn10",
                        "label": "basic_scheduler_spawn10",
                        "kind": "Function",
                        "signature": "fn fn basic_scheduler_spawn10 (c : & mut Criterion) { let runtime = single_rt () ; c . bench_function (\"basic_scheduler_spawn10\" , | b | { b . iter (| | { runtime . block_on (async { let mut handles = Vec :: with_capacity (10) ; for _ in 0 .. 10 { handles . push (tokio :: spawn (work ())) ; } for handle in handles { assert_eq ! (handle . await . unwrap () , 2) ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_set_len_err",
                        "label": "open_set_len_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_set_len_err () { let mut file = MockFile :: default () ; file . expect_set_len () . with (eq (123)) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let file = File :: from_std (file) ; let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_two",
                        "label": "broadcast_two",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_two () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel :: < Arc < & 'static str > > (16) ; let mut rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (* v , \"hello\") ; let v = assert_ok ! (rx1 . recv () . await) ; assert_eq ! (* v , \"world\") ; match assert_err ! (rx1 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { let v = assert_ok ! (rx2 . recv () . await) ; assert_eq ! (* v , \"hello\") ; let v = assert_ok ! (rx2 . recv () . await) ; assert_eq ! (* v , \"world\") ; match assert_err ! (rx2 . recv () . await) { Closed => { } _ => panic ! () , } }) ; }) ; assert_ok ! (tx . send (Arc :: new (\"hello\"))) ; assert_ok ! (tx . send (Arc :: new (\"world\"))) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_during_tracing",
                        "label": "notified_during_tracing",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Regression test for #6051.\"] # [doc = \"\"] # [doc = \" This test ensures that tasks notified outside of a worker will not be\"] # [doc = \" traced, since doing so will un-set their notified bit prior to them being\"] # [doc = \" run and panic.\"] # [test] fn notified_during_tracing () { let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (3) . build () . unwrap () ; let timeout = async { tokio :: time :: sleep (tokio :: time :: Duration :: from_secs (1)) . await ; } ; let timer = rt . spawn (async { loop { tokio :: time :: sleep (tokio :: time :: Duration :: from_nanos (1)) . await ; } }) ; let dump = async { loop { let handle = Handle :: current () ; let _dump = handle . dump () . await ; } } ; rt . block_on (async { tokio :: select ! (biased ; _ = timeout => { } , _ = timer => { } , _ = dump => { } ,) ; }) ; } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "crate_rename_main",
                        "label": "crate_rename_main",
                        "kind": "Function",
                        "signature": "fn # [test] fn crate_rename_main () { assert_eq ! (1 , compute_main ()) ; } . sig",
                        "file_path": "tokio/tests/macros_rename_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawned_task_does_not_progress_without_block_on",
                        "label": "spawned_task_does_not_progress_without_block_on",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawned_task_does_not_progress_without_block_on () { let (tx , mut rx) = oneshot :: channel () ; let rt = rt () ; rt . spawn (async move { assert_ok ! (tx . send (\"hello\")) ; }) ; thread :: sleep (Duration :: from_millis (50)) ; assert_err ! (rx . try_recv ()) ; let out = rt . block_on (async { assert_ok ! (rx . await) }) ; assert_eq ! (out , \"hello\") ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "model",
                        "label": "model",
                        "kind": "Function",
                        "signature": "fn fn model (f : impl Fn () + Send + Sync + 'static) { # [cfg (loom)] loom :: model (f) ; # [cfg (not (loom))] f () ; } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_incomplete_head_multi",
                        "label": "read_incomplete_head_multi",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_incomplete_head_multi () { let io = FramedRead :: new (mock ! { Poll :: Pending , data (b\"\\x00\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "channel",
                        "label": "channel",
                        "kind": "Function",
                        "signature": "fn pub (super) fn channel () -> (Sender , Receiver) { let (tx , rx) = oneshot :: channel () ; let tx = Sender { _tx : Arc :: new (tx) } ; let rx = Receiver { rx } ; (tx , rx) } . sig",
                        "file_path": "tokio/src/runtime/blocking/shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "future_and_deadline_in_future",
                        "label": "future_and_deadline_in_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn future_and_deadline_in_future () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let mut fut = task :: spawn (timeout_at (Instant :: now () + ms (100) , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (90)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_not_empty_when_all_but_one_messages_are_consumed",
                        "label": "test_rx_unbounded_is_not_empty_when_all_but_one_messages_are_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_empty_when_all_but_one_messages_are_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } for _ in 0 .. 9 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (! rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "does_not_abort_after_detach",
                        "label": "does_not_abort_after_detach",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn does_not_abort_after_detach () { let (tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; handle . detach () ; yield_now () . await ; assert ! (! tx . is_closed ()) ; } . sig",
                        "file_path": "tokio-util/tests/abort_on_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_wakes",
                        "label": "drop_wakes",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn drop_wakes () { let rt = rt () ; let listener = { let _enter = rt . enter () ; let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; TcpListener :: from_std (listener) . unwrap () } ; let mut task = task :: spawn (async move { assert_err ! (listener . accept () . await) ; }) ; assert_pending ! (task . poll ()) ; drop (rt) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; } . sig",
                        "file_path": "tokio/tests/io_driver_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "method_delegation",
                        "label": "method_delegation",
                        "kind": "Function",
                        "signature": "fn # [test] fn method_delegation () { let (mut r , mut w) = split (RW) ; let mut buf = [0 ; 1] ; tokio_test :: block_on (async move { assert_eq ! (1 , r . read (& mut buf) . await . unwrap ()) ; assert_eq ! (b'z' , buf [0]) ; assert_eq ! (1 , w . write (b\"x\") . await . unwrap ()) ; assert_eq ! (2 , w . write_vectored (& [io :: IoSlice :: new (b\"x\")]) . await . unwrap ()) ; assert ! (w . is_write_vectored ()) ; assert ! (w . flush () . await . is_ok ()) ; assert ! (w . shutdown () . await . is_ok ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_join_handle_slow",
                        "label": "drop_join_handle_slow",
                        "kind": "Function",
                        "signature": "fn unsafe fn drop_join_handle_slow < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . drop_join_handle_slow () ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_from_handle",
                        "label": "test_spawn_from_handle",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_spawn_from_handle () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; rt . handle () . spawn (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "smoke",
                        "label": "smoke",
                        "kind": "Function",
                        "signature": "fn # [test] fn smoke () { loom :: model (| | { let (tx , rx) = oneshot :: channel () ; thread :: spawn (move | | { tx . send (1) . unwrap () ; }) ; let value = block_on (rx) . unwrap () ; assert_eq ! (1 , value) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown",
                        "label": "shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn shutdown () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let handle = tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; let mut buf = [0u8 ; 1] ; let n = assert_ok ! (stream . read (& mut buf) . await) ; assert_eq ! (n , 0) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; let (mut rd , mut wr) = stream . split () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , 0) ; assert_ok ! (AsyncWriteExt :: shutdown (& mut stream) . await) ; handle . await . unwrap () } . sig",
                        "file_path": "tokio/tests/tcp_shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown2",
                        "label": "shutdown2",
                        "kind": "Function",
                        "signature": "fn fn shutdown2 (mut core : Box < Core > , handle : & Handle) -> Box < Core > { handle . shared . owned . close_and_shutdown_all (0) ; while let Some (task) = core . next_local_task (handle) { drop (task) ; } handle . shared . inject . close () ; while let Some (task) = handle . shared . inject . pop () { drop (task) ; } assert ! (handle . shared . owned . is_empty ()) ; core . submit_metrics (handle) ; if let Some (driver) = core . driver . as_mut () { driver . shutdown (& handle . driver) ; } core } . sig",
                        "file_path": "tokio/src/runtime/scheduler/current_thread/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tokio_context_with_another_runtime",
                        "label": "tokio_context_with_another_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn tokio_context_with_another_runtime () { let rt1 = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; rt1 . block_on (rt2 . wrap (async move { sleep (Duration :: from_millis (2)) . await })) ; } . sig",
                        "file_path": "tokio-util/tests/context.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_immediate_delays",
                        "label": "multi_immediate_delays",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multi_immediate_delays () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _k = queue . insert_at (\"1\" , Instant :: now ()) ; let _k = queue . insert_at (\"2\" , Instant :: now ()) ; let _k = queue . insert_at (\"3\" , Instant :: now ()) ; sleep (ms (1)) . await ; let mut res = vec ! [] ; while res . len () < 3 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; res . sort_unstable () ; assert_eq ! (\"1\" , res [0]) ; assert_eq ! (\"2\" , res [1]) ; assert_eq ! (\"3\" , res [2]) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TimerHandle",
                        "label": "TimerHandle",
                        "kind": "Struct",
                        "signature": "struct TimerHandle",
                        "file_path": "tokio/src/runtime/time/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Iter",
                        "label": "Iter",
                        "kind": "Struct",
                        "signature": "struct Iter",
                        "file_path": "tokio-stream/src/iter.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_no_comma",
                        "label": "sync_one_lit_expr_no_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: try_join ! (async { ok (1) }) ; assert_eq ! (foo , Ok ((1 ,))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) }) ; assert_eq ! (foo , Ok ((1 ,))) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "enter_runtime",
                        "label": "enter_runtime",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Marks the current thread as being within the dynamic extent of an\"] # [doc = \" executor.\"] # [track_caller] pub (crate) fn enter_runtime < F , R > (handle : & scheduler :: Handle , allow_block_in_place : bool , f : F) -> R where F : FnOnce (& mut BlockingRegionGuard) -> R , { let maybe_guard = CONTEXT . with (| c | { if c . runtime . get () . is_entered () { None } else { c . runtime . set (EnterRuntime :: Entered { allow_block_in_place , }) ; let rng_seed = handle . seed_generator () . next_seed () ; let mut rng = c . rng . get () . unwrap_or_else (FastRand :: new) ; let old_seed = rng . replace_seed (rng_seed) ; c . rng . set (Some (rng)) ; Some (EnterRuntimeGuard { blocking : BlockingRegionGuard :: new () , handle : c . set_current (handle) , old_seed , }) } }) ; if let Some (mut guard) = maybe_guard { return f (& mut guard . blocking) ; } panic ! (\"Cannot start a runtime from within a runtime. This happens \\\n            because a function (like `block_on`) attempted to block the \\\n            current thread while the thread is being used to drive \\\n            asynchronous tasks.\") ; } . sig",
                        "file_path": "tokio/src/runtime/context/runtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "fifo_simple_send_sender_first",
                        "label": "fifo_simple_send_sender_first",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] # [cfg_attr (miri , ignore)] async fn fifo_simple_send_sender_first () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"simple_send_sender_first\") ? ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& fifo)) ; assert_eq ! (err . raw_os_error () , Some (libc :: ENXIO)) ; let mut writer = pipe :: OpenOptions :: new () . read_write (true) . open_sender (& fifo) ? ; writer . write_all (DATA) . await ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let mut read_data = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut read_data) . await ? ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_wait_for_is_cooperative_ok",
                        "label": "receiver_wait_for_is_cooperative_ok",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_wait_for_is_cooperative_ok () { let (tx , mut rx) = watch :: channel (0) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (1) . is_ok ()) ; assert ! (rx . wait_for (| val | * val == 1) . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Data",
                        "label": "Data",
                        "kind": "Struct",
                        "signature": "struct Data",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "can_shutdown_now_in_runtime",
                        "label": "can_shutdown_now_in_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn can_shutdown_now_in_runtime () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . shutdown_background () ; }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "localset_future_drives_all_local_futs",
                        "label": "localset_future_drives_all_local_futs",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn localset_future_drives_all_local_futs () { static RAN1 : AtomicBool = AtomicBool :: new (false) ; static RAN2 : AtomicBool = AtomicBool :: new (false) ; static RAN3 : AtomicBool = AtomicBool :: new (false) ; let local = LocalSet :: new () ; local . spawn_local (async move { task :: spawn_local (async { task :: yield_now () . await ; RAN3 . store (true , Ordering :: SeqCst) ; }) ; task :: yield_now () . await ; RAN1 . store (true , Ordering :: SeqCst) ; }) ; local . spawn_local (async move { task :: yield_now () . await ; RAN2 . store (true , Ordering :: SeqCst) ; }) ; local . await ; assert ! (RAN1 . load (Ordering :: SeqCst)) ; assert ! (RAN2 . load (Ordering :: SeqCst)) ; assert ! (RAN3 . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_unexpected_attr",
                        "label": "test_unexpected_attr",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (foo = 123)] async fn test_unexpected_attr () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_without_name",
                        "label": "spawn_without_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_without_name () { let result = Builder :: new () . spawn (async { \"task executed\" }) . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write",
                        "label": "write",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write < 'a , W > (writer : & 'a mut W , buf : & 'a [u8]) -> Write < 'a , W > where W : AsyncWrite + Unpin + ? Sized , { Write { writer , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rwlock_creates_span",
                        "label": "test_rwlock_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rwlock_creates_span () { let rwlock_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::rwlock\") ; let max_readers_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"max_readers\") . with_value (& 0x1FFFFFFF_u64)) ; let write_locked_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"write_locked\") . with_value (& false)) ; let current_readers_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"current_readers\") . with_value (& 0_i64)) ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (rwlock_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (rwlock_span . clone ()) . event (max_readers_event) . event (write_locked_event) . event (current_readers_event) . exit (rwlock_span . clone ()) . enter (rwlock_span . clone ()) . new_span (batch_semaphore_span . clone ()) . enter (batch_semaphore_span . clone ()) . event (batch_semaphore_permits_event) . exit (batch_semaphore_span . clone ()) . exit (rwlock_span . clone ()) . drop_span (rwlock_span) . drop_span (batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: RwLock :: new (true) ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv",
                        "label": "recv",
                        "kind": "Function",
                        "signature": "fn async fn recv (mut stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin , reader : & UdpSocket ,) -> Result < () , std :: io :: Error > { loop { let mut buf = vec ! [0 ; 1024] ; let n = reader . recv (& mut buf [..]) . await ? ; if n > 0 { stdout . send (Bytes :: copy_from_slice (& buf [.. n])) . await ? ; } } } . sig",
                        "file_path": "examples/connect-udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_to_try_peek_from",
                        "label": "send_to_try_peek_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_to_try_peek_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; loop { match receiver . try_peek_from (& mut recv_buf) { Ok ((n , addr)) => { assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; break ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { receiver . readable () . await ? ; } Err (e) => return Err (e) , } } let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_close",
                        "label": "poll_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_close () { let (tx , rx) = watch :: channel (\"one\") ; { let mut t = spawn (tx . closed ()) ; assert_pending ! (t . poll ()) ; drop (rx) ; assert ! (t . is_woken ()) ; assert_ready ! (t . poll ()) ; } assert ! (tx . send (\"two\") . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_changes_task",
                        "label": "receiver_changes_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_changes_task () { let (tx , mut rx) = oneshot :: channel () ; let mut task1 = task :: spawn (()) ; let mut task2 = task :: spawn (()) ; assert_pending ! (task1 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; assert_eq ! (2 , task1 . waker_ref_count ()) ; assert_eq ! (1 , task2 . waker_ref_count ()) ; assert_pending ! (task2 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; assert_eq ! (1 , task1 . waker_ref_count ()) ; assert_eq ! (2 , task2 . waker_ref_count ()) ; assert_ok ! (tx . send (1)) ; assert ! (! task1 . is_woken ()) ; assert ! (task2 . is_woken ()) ; assert_ready_ok ! (task2 . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx))) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read",
                        "label": "read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read () { # [derive (Default)] struct Rd { poll_cnt : usize , } impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { assert_eq ! (0 , self . poll_cnt) ; self . poll_cnt += 1 ; buf . put_slice (b\"hello world\") ; Poll :: Ready (Ok (())) } } let mut buf = Box :: new ([0 ; 11]) ; let mut rd = Rd :: default () ; let n = assert_ok ! (rd . read (& mut buf [..]) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReusableBoxFuture",
                        "label": "ReusableBoxFuture",
                        "kind": "Struct",
                        "signature": "struct ReusableBoxFuture",
                        "file_path": "tokio-util/src/sync/reusable_box.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "freezing_time_while_frozen_panics",
                        "label": "freezing_time_while_frozen_panics",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn freezing_time_while_frozen_panics () { time :: pause () ; time :: pause () ; } . sig",
                        "file_path": "tokio/tests/test_clock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_concurrent_uncontended",
                        "label": "read_concurrent_uncontended",
                        "kind": "Function",
                        "signature": "fn fn read_concurrent_uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { tokio :: join ! { task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) } ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_inherent",
                        "label": "read_inherent",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_inherent () { let base_dir = tempdir () . unwrap () ; let p = base_dir . path () ; std :: fs :: create_dir (p . join (\"aa\")) . unwrap () ; std :: fs :: create_dir (p . join (\"bb\")) . unwrap () ; std :: fs :: create_dir (p . join (\"cc\")) . unwrap () ; let files = Arc :: new (Mutex :: new (Vec :: new ())) ; let f = files . clone () ; let p = p . to_path_buf () ; let mut entries = fs :: read_dir (p) . await . unwrap () ; while let Some (e) = assert_ok ! (entries . next_entry () . await) { let s = e . file_name () . to_str () . unwrap () . to_string () ; f . lock () . unwrap () . push (s) ; } let mut files = files . lock () . unwrap () ; files . sort () ; assert_eq ! (* files , vec ! [\"aa\" . to_string () , \"bb\" . to_string () , \"cc\" . to_string ()]) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pos_adjusted_frame_does_not_fit",
                        "label": "pos_adjusted_frame_does_not_fit",
                        "kind": "Function",
                        "signature": "fn # [test] fn pos_adjusted_frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . length_adjustment (1) . new_codec () ; assert_eq ! (codec . max_frame_length () , 256) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_local_with_name",
                        "label": "spawn_local_with_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_local_with_name () { let unsend_data = Rc :: new (\"task executed\") ; let result = LocalSet :: new () . run_until (async move { Builder :: new () . name (\"name\") . spawn_local (async move { unsend_data }) . unwrap () . await }) . await ; assert_eq ! (* result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_once_wait_test",
                        "label": "set_once_wait_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_once_wait_test () { loom :: model (| | { let tx = Arc :: new (SetOnce :: new ()) ; let rx_one = tx . clone () ; let rx_two = tx . clone () ; let thread = thread :: spawn (move | | { assert ! (rx_one . set (2) . is_ok ()) ; }) ; block_on (async { assert_eq ! (* rx_two . wait () . await , 2) ; }) ; thread . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_already_cancelled_token_owned_test",
                        "label": "pending_fut_with_already_cancelled_token_owned_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_already_cancelled_token_owned_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token_owned (token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 0) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_pending_race",
                        "label": "driver_shutdown_wakes_pending_race",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_pending_race () { for _ in 0 .. 100 { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let _ = std :: thread :: spawn (move | | std :: mem :: drop (rt)) ; let _ = futures :: executor :: block_on (afd_a . readable ()) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_cursor",
                        "label": "write_cursor",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_cursor () { use std :: io :: Cursor ; let mut wr = Cursor :: new (Vec :: new ()) ; let n = assert_ok ! (wr . write (b\"hello world\") . await) ; assert_eq ! (n , 11) ; assert_eq ! (wr . get_ref () . as_slice () , & b\"hello world\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedRwLockWriteGuard",
                        "label": "OwnedRwLockWriteGuard",
                        "kind": "Struct",
                        "signature": "struct OwnedRwLockWriteGuard",
                        "file_path": "tokio/src/sync/rwlock/owned_write_guard.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_join_next_with_id",
                        "label": "try_join_next_with_id",
                        "kind": "Function",
                        "signature": "fn # [cfg (tokio_unstable)] # [tokio :: test (flavor = \"current_thread\")] async fn try_join_next_with_id () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut set = JoinSet :: new () ; let mut spawned = std :: collections :: HashSet :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = set . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . insert (handle . id ()) ; } drop (recv) ; assert ! (set . try_join_next_with_id () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut joined = std :: collections :: HashSet :: with_capacity (TASK_NUM as usize) ; loop { match set . try_join_next_with_id () { Some (Ok ((id , ()))) => { count += 1 ; joined . insert (id) ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { break ; } } } assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "barrier_future_is_send",
                        "label": "barrier_future_is_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn barrier_future_is_send () { let b = Barrier :: new (0) ; IsSend (b . wait ()) ; } . sig",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "windows_main",
                        "label": "windows_main",
                        "kind": "Function",
                        "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use tokio :: io :: AsyncWriteExt ; use tokio :: io :: { AsyncBufReadExt , BufReader } ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let mut server = BufReader :: new (server) ; let mut buf = String :: new () ; server . read_line (& mut buf) . await ? ; server . write_all (b\"pong\\n\") . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, \"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
                        "file_path": "examples/named-pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_without_register",
                        "label": "wake_without_register",
                        "kind": "Function",
                        "signature": "fn # [test] fn wake_without_register () { let mut waker = task :: spawn (AtomicWaker :: new ()) ; waker . wake () ; waker . enter (| cx , waker | waker . register_by_ref (cx . waker ())) ; assert ! (! waker . is_woken ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
                        "label": "test_rx_is_closed_when_dropping_all_senders_except_weak_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = broadcast :: channel :: < () > (10) ; let weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert_eq ! (weak_sender . strong_count () , 0) ; assert_eq ! (weak_sender . weak_count () , 1) ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from",
                        "label": "from",
                        "kind": "Function",
                        "signature": "fn # [test] fn from () { let cell = SetOnce :: from (2) ; assert_eq ! (* cell . get () . unwrap () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pause_time_in_task",
                        "label": "pause_time_in_task",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn pause_time_in_task () { let t = tokio :: spawn (async { tokio :: time :: pause () ; }) ; t . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_pair",
                        "label": "create_pair",
                        "kind": "Function",
                        "signature": "fn async fn create_pair () -> (UnixStream , UnixStream) { let dir = assert_ok ! (tempfile :: tempdir ()) ; let bind_path = dir . path () . join (\"bind.sock\") ; let listener = assert_ok ! (UnixListener :: bind (& bind_path)) ; let accept = listener . accept () ; let connect = UnixStream :: connect (& bind_path) ; let ((server , _) , client) = assert_ok ! (try_join (accept , connect) . await) ; (client , server) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_4635",
                        "label": "issue_4635",
                        "kind": "Function",
                        "signature": "fn # [allow (redundant_semicolons)] # [rustfmt :: skip] # [tokio :: main] async fn issue_4635 () { return 1 ; ; } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "correct_behavior_on_errors",
                        "label": "correct_behavior_on_errors",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn correct_behavior_on_errors () { let reader = Reader { remaining : 8000 } ; let mut stream = tokio_util :: io :: ReaderStream :: new (reader) ; let mut zeros_received = 0 ; let mut had_error = false ; loop { let item = stream . next () . await . unwrap () ; println ! (\"{item:?}\") ; match item { Ok (bytes) => { let bytes = & * bytes ; for byte in bytes { assert_eq ! (* byte , 0) ; zeros_received += 1 ; } } Err (_) => { assert ! (! had_error) ; had_error = true ; break ; } } } assert ! (had_error) ; assert_eq ! (zeros_received , 8000) ; assert ! (stream . next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/io_reader_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SetOnceError",
                        "label": "SetOnceError",
                        "kind": "Struct",
                        "signature": "struct SetOnceError",
                        "file_path": "tokio/src/sync/set_once.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_panic",
                        "label": "test_panic",
                        "kind": "Function",
                        "signature": "fn pub fn test_panic < Func : FnOnce () + panic :: UnwindSafe > (func : Func) -> Option < String > { static PANIC_MUTEX : Mutex < () > = Mutex :: new (()) ; { let _guard = PANIC_MUTEX . lock () ; let panic_file : Arc < Mutex < Option < String > > > = Arc :: new (Mutex :: new (None)) ; let prev_hook = panic :: take_hook () ; { let panic_file = panic_file . clone () ; panic :: set_hook (Box :: new (move | panic_info | { let panic_location = panic_info . location () . unwrap () ; panic_file . lock () . unwrap () . clone_from (& Some (panic_location . file () . to_string ())) ; })) ; } let result = panic :: catch_unwind (func) ; panic :: set_hook (prev_hook) ; if result . is_err () { panic_file . lock () . unwrap () . clone () } else { None } } } . sig",
                        "file_path": "tokio/tests/support/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_task_hook_fires",
                        "label": "spawn_task_hook_fires",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Assert that the spawn task hook always fires when set.\"] # [test] fn spawn_task_hook_fires () { let count = Arc :: new (AtomicUsize :: new (0)) ; let count2 = Arc :: clone (& count) ; let ids = Arc :: new (Mutex :: new (HashSet :: new ())) ; let ids2 = Arc :: clone (& ids) ; let runtime = Builder :: new_current_thread () . on_task_spawn (move | data | { ids2 . lock () . unwrap () . insert (data . id ()) ; count2 . fetch_add (1 , Ordering :: SeqCst) ; }) . build () . unwrap () ; for _ in 0 .. TASKS { runtime . spawn (std :: future :: pending :: < () > ()) ; } let count_realized = count . load (Ordering :: SeqCst) ; assert_eq ! (TASKS , count_realized , \"Total number of spawned task hook invocations was incorrect, expected {TASKS}, got {count_realized}\") ; let count_ids_realized = ids . lock () . unwrap () . len () ; assert_eq ! (TASKS , count_ids_realized , \"Total number of spawned task hook invocations was incorrect, expected {TASKS}, got {count_realized}\") ; } . sig",
                        "file_path": "tokio/tests/task_hooks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_queue_depth",
                        "label": "blocking_queue_depth",
                        "kind": "Function",
                        "signature": "fn # [test] fn blocking_queue_depth () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . max_blocking_threads (1) . build () . unwrap () ; assert_eq ! (0 , rt . metrics () . blocking_queue_depth ()) ; let ready = Arc :: new (Mutex :: new (())) ; let guard = ready . lock () . unwrap () ; let ready_cloned = ready . clone () ; let wait_until_ready = move | | { let _unused = ready_cloned . lock () . unwrap () ; } ; let h1 = rt . spawn_blocking (wait_until_ready . clone ()) ; let h2 = rt . spawn_blocking (wait_until_ready) ; assert ! (rt . metrics () . blocking_queue_depth () > 0) ; drop (guard) ; let _ = rt . block_on (h1) ; let _ = rt . block_on (h2) ; assert_eq ! (0 , rt . metrics () . blocking_queue_depth ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Globals",
                        "label": "Globals",
                        "kind": "Struct",
                        "signature": "struct Globals",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "StreamMockBuilder",
                        "label": "StreamMockBuilder",
                        "kind": "Struct",
                        "signature": "struct StreamMockBuilder",
                        "file_path": "tokio-test/src/stream_mock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reset_future_sleep_after_fire",
                        "label": "reset_future_sleep_after_fire",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_future_sleep_after_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = Box :: pin (time :: sleep_until (now + ms (100))) ; sleep . as_mut () . await ; assert_elapsed ! (now , ms (100)) ; sleep . as_mut () . reset (now + ms (110)) ; sleep . await ; assert_elapsed ! (now , ms (110)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Marks async function to be executed by the selected runtime. This macro\"] # [doc = \" helps set up a `Runtime` without requiring the user to use\"] # [doc = \" [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" Note: This macro is designed to be simplistic and targets applications that\"] # [doc = \" do not require a complex setup. If the provided functionality is not\"] # [doc = \" sufficient, you may be interested in using\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html), which provides a more\"] # [doc = \" powerful interface.\"] # [doc = \"\"] # [doc = \" Note: This macro can be used on any function and not just the `main`\"] # [doc = \" function. Using it on a non-main function makes the function behave as if it\"] # [doc = \" was synchronous by starting a new runtime each time it is called. If the\"] # [doc = \" function is called often, it is preferable to create the runtime using the\"] # [doc = \" runtime builder so the runtime can be reused across calls.\"] # [doc = \"\"] # [doc = \" # Non-worker async function\"] # [doc = \"\"] # [doc = \" Note that the async function marked with this macro does not run as a\"] # [doc = \" worker. The expectation is that other tasks are spawned by the function here.\"] # [doc = \" Awaiting on other futures from the function provided here will not\"] # [doc = \" perform as fast as those spawned as workers.\"] # [doc = \"\"] # [doc = \" # Runtime flavors\"] # [doc = \"\"] # [doc = \" The macro can be configured with a `flavor` parameter to select\"] # [doc = \" different runtime configurations.\"] # [doc = \"\"] # [doc = \" ## Multi-threaded\"] # [doc = \"\"] # [doc = \" To use the multi-threaded runtime, the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" #[tokio::main(flavor = \\\"multi_thread\\\", worker_threads = 10)]\"] # [doc = \" # async fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" The `worker_threads` option configures the number of worker threads, and\"] # [doc = \" defaults to the number of cpus on the system. This is the default flavor.\"] # [doc = \"\"] # [doc = \" Note: The multi-threaded runtime requires the `rt-multi-thread` feature\"] # [doc = \" flag.\"] # [doc = \"\"] # [doc = \" ## Current-thread\"] # [doc = \"\"] # [doc = \" To use the single-threaded runtime known as the `current_thread` runtime,\"] # [doc = \" the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Local\"] # [doc = \"\"] # [doc = \" [Unstable API][unstable] only.\"] # [doc = \"\"] # [doc = \" To use the [local runtime], the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"local\\\")]\"] # [doc = \" # async fn main() {}\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" # Function arguments\"] # [doc = \"\"] # [doc = \" Arguments are allowed for any functions, aside from `main` which is special.\"] # [doc = \"\"] # [doc = \" # Usage\"] # [doc = \"\"] # [doc = \" ## Using the multi-threaded runtime\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Using the current-thread runtime\"] # [doc = \"\"] # [doc = \" The basic scheduler is single-threaded.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Using the local runtime\"] # [doc = \"\"] # [doc = \" Available in the [unstable API][unstable] only.\"] # [doc = \"\"] # [doc = \" The [local runtime] is similar to the current-thread runtime but\"] # [doc = \" supports [`task::spawn_local`](../tokio/task/fn.spawn_local.html).\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"local\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" # #[cfg(tokio_unstable)]\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build_local(tokio::runtime::LocalOptions::default())\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() {}\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \"\"] # [doc = \" ## Set number of worker threads\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(worker_threads = 2)]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .worker_threads(2)\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Configure the runtime to start with time paused\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\", start_paused = true)]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .start_paused(true)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Note that `start_paused` requires the `test-util` feature to be enabled.\"] # [doc = \"\"] # [doc = \" ## Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::main(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" fn main() {\"] # [doc = \"     tokio1::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Configure unhandled panic behavior\"] # [doc = \"\"] # [doc = \" Available options are `shutdown_runtime` and `ignore`. For more details, see\"] # [doc = \" [`Builder::unhandled_panic`].\"] # [doc = \"\"] # [doc = \" This option is only compatible with the `current_thread` runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\", unhandled_panic = \\\"shutdown_runtime\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     let _ = tokio::spawn(async {\"] # [doc = \"         panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"     }).await;\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .unhandled_panic(tokio::runtime::UnhandledPanic::ShutdownRuntime)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             let _ = tokio::spawn(async {\"] # [doc = \"                 panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"             }).await;\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" # #[cfg(not(tokio_unstable))]\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" **Note**: This option depends on Tokio's [unstable API][unstable]. See [the\"] # [doc = \" documentation on unstable features][unstable] for details on how to enable\"] # [doc = \" Tokio's unstable features.\"] # [doc = \"\"] # [doc = \" [`Builder::unhandled_panic`]: ../tokio/runtime/struct.Builder.html#method.unhandled_panic\"] # [doc = \" [unstable]: ../tokio/index.html#unstable-features\"] # [doc = \" [local runtime]: ../tokio/runtime/struct.LocalRuntime.html\"] # [proc_macro_attribute] pub fn main (args : TokenStream , item : TokenStream) -> TokenStream { entry :: main (args . into () , item . into () , true) . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CachePadded",
                        "label": "CachePadded",
                        "kind": "Struct",
                        "signature": "struct CachePadded",
                        "file_path": "tokio/src/util/cacheline.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "explicit_close_try_recv",
                        "label": "explicit_close_try_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn explicit_close_try_recv () { let (tx , mut rx) = oneshot :: channel () ; assert_ok ! (tx . send (1)) ; rx . close () ; let val = assert_ok ! (rx . try_recv ()) ; assert_eq ! (1 , val) ; let (tx , mut rx) = oneshot :: channel :: < i32 > () ; let mut tx = task :: spawn (tx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; rx . close () ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_poll_different_amounts_of_permits",
                        "label": "can_poll_different_amounts_of_permits",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn can_poll_different_amounts_of_permits () { let sem = Arc :: new (Semaphore :: new (4)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_ready ()) ; let permit = sem . acquire_many (4) . await . unwrap () ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_pending ()) ; drop (permit) ; assert ! (semaphore_poll_many (& mut poll_sem , 5) . poll () . is_pending ()) ; assert ! (semaphore_poll_many (& mut poll_sem , 4) . poll () . is_ready ()) ; } . sig",
                        "file_path": "tokio-util/tests/poll_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RngSeed",
                        "label": "RngSeed",
                        "kind": "Struct",
                        "signature": "struct RngSeed",
                        "file_path": "tokio/src/util/rand.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Chan",
                        "label": "Chan",
                        "kind": "Struct",
                        "signature": "struct Chan",
                        "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "assert_usage",
                        "label": "assert_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn assert_usage () -> std :: io :: Result < () > { let datagram_socket = UnixSocket :: new_datagram () ? ; let result = datagram_socket . connect (std :: path :: PathBuf :: new () . join (\"invalid.sock\")) . await ; assert_eq ! (result . unwrap_err () . to_string () , \"connect cannot be called on a datagram socket\") ; let datagram_socket = UnixSocket :: new_datagram () ? ; let result = datagram_socket . listen (1024) ; assert_eq ! (result . unwrap_err () . to_string () , \"listen cannot be called on a datagram socket\") ; let stream_socket = UnixSocket :: new_stream () ? ; let result = stream_socket . datagram () ; assert_eq ! (result . unwrap_err () . to_string () , \"datagram cannot be called on a stream socket\") ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CtrlBreak",
                        "label": "CtrlBreak",
                        "kind": "Struct",
                        "signature": "struct CtrlBreak",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "timeout_value",
                        "label": "timeout_value",
                        "kind": "Function",
                        "signature": "fn async fn timeout_value () { let (_tx , rx) = oneshot :: channel :: < () > () ; let dur = Duration :: from_millis (10) ; let _ = timeout (dur , rx) . await ; } . sig",
                        "file_path": "tokio/tests/no_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_extra_poll",
                        "label": "no_extra_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn no_extra_poll () { let mut listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = listener . local_addr () . unwrap () ; let (tx , rx) = oneshot :: channel () ; let (accepted_tx , mut accepted_rx) = mpsc :: unbounded_channel () ; tokio :: spawn (async move { let mut incoming = TrackPolls { npolls : Arc :: new (AtomicUsize :: new (0)) , listener : & mut listener , } ; assert_ok ! (tx . send (Arc :: clone (& incoming . npolls))) ; while incoming . next () . await . is_some () { accepted_tx . send (()) . unwrap () ; } }) ; let npolls = assert_ok ! (rx . await) ; tokio :: task :: yield_now () . await ; assert_eq ! (npolls . load (SeqCst) , 1) ; let _ = assert_ok ! (TcpStream :: connect (& addr) . await) ; accepted_rx . recv () . await . unwrap () ; assert_eq ! (npolls . load (SeqCst) , 1 + 2) ; } . sig",
                        "file_path": "tokio/tests/tcp_accept.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () } . sig",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_block_in_current_thread_scheduler",
                        "label": "no_block_in_current_thread_scheduler",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] # [should_panic] async fn no_block_in_current_thread_scheduler () { task :: block_in_place (| | { }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "select_priv_clean_pattern",
                        "label": "select_priv_clean_pattern",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Implementation detail of the `select!` macro. This macro is **not** intended\"] # [doc = \" to be used as part of the public API and is permitted to change.\"] # [proc_macro] # [doc (hidden)] pub fn select_priv_clean_pattern (input : TokenStream) -> TokenStream { select :: clean_pattern_macro (input) } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_child_token_through_parent",
                        "label": "cancel_child_token_through_parent",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_child_token_through_parent () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let child_token = token . child_token () ; assert ! (! child_token . is_cancelled ()) ; let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 2) ; assert ! (token . is_cancelled ()) ; assert ! (child_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "buffer_not_included_in_future",
                        "label": "buffer_not_included_in_future",
                        "kind": "Function",
                        "signature": "fn # [test] fn buffer_not_included_in_future () { use std :: mem ; const N : usize = 4096 ; let fut = async { let stream = TcpStream :: connect (\"127.0.0.1:8080\") . await . unwrap () ; loop { stream . readable () . await . unwrap () ; let mut buf = [0 ; N] ; let n = stream . try_read (& mut buf [..]) . unwrap () ; if n == 0 { break ; } } } ; let n = mem :: size_of_val (& fut) ; assert ! (n < 1000) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] pub async fn main () -> Result < () , Box < dyn Error > > { let mut stream = TcpStream :: connect (\"127.0.0.1:6142\") . await ? ; println ! (\"created stream\") ; let result = stream . write_all (b\"hello world\\n\") . await ; println ! (\"wrote to stream; success={:?}\" , result . is_ok ()) ; Ok (()) } . sig",
                        "file_path": "examples/hello_world.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timeout",
                        "label": "timeout",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Requires a `Future` to complete before the specified duration has elapsed.\"] # [doc = \"\"] # [doc = \" If the future completes before the duration has elapsed, then the completed\"] # [doc = \" value is returned. Otherwise, an error is returned and the future is\"] # [doc = \" canceled.\"] # [doc = \"\"] # [doc = \" Note that the timeout is checked before polling the future, so if the future\"] # [doc = \" does not yield during execution then it is possible for the future to complete\"] # [doc = \" and exceed the timeout _without_ returning an error.\"] # [doc = \"\"] # [doc = \" This function returns a future whose return type is [`Result`]`<T,`[`Elapsed`]`>`, where `T` is the\"] # [doc = \" return type of the provided future.\"] # [doc = \"\"] # [doc = \" If the provided future completes immediately, then the future returned from\"] # [doc = \" this function is guaranteed to complete immediately with an [`Ok`] variant\"] # [doc = \" no matter the provided duration.\"] # [doc = \"\"] # [doc = \" [`Ok`]: std::result::Result::Ok\"] # [doc = \" [`Result`]: std::result::Result\"] # [doc = \" [`Elapsed`]: crate::time::error::Elapsed\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Cancelling a timeout is done by dropping the future. No additional cleanup\"] # [doc = \" or other work is required.\"] # [doc = \"\"] # [doc = \" The original future may be obtained by calling [`Timeout::into_inner`]. This\"] # [doc = \" consumes the `Timeout`.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Create a new `Timeout` set to expire in 10 milliseconds.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio::time::timeout;\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" use std::time::Duration;\"] # [doc = \"\"] # [doc = \" # async fn dox() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \" # tx.send(()).unwrap();\"] # [doc = \"\"] # [doc = \" // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\"] # [doc = \" if let Err(_) = timeout(Duration::from_millis(10), rx).await {\"] # [doc = \"     println!(\\\"did not receive value within 10 ms\\\");\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [track_caller] pub fn timeout < F > (duration : Duration , future : F) -> Timeout < F :: IntoFuture > where F : IntoFuture , { let location = trace :: caller_location () ; let deadline = Instant :: now () . checked_add (duration) ; let delay = match deadline { Some (deadline) => Sleep :: new_timeout (deadline , location) , None => Sleep :: far_future (location) , } ; Timeout :: new_with_delay (future . into_future () , delay) } . sig",
                        "file_path": "tokio/src/time/timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with_timeout",
                        "label": "with_timeout",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Runs a test function in a separate thread, and panics if the test does not\"] # [doc = \" complete within the specified timeout, or if the test function panics.\"] # [doc = \"\"] # [doc = \" This is intended for running tests whose failure mode is a hang or infinite\"] # [doc = \" loop that cannot be detected otherwise.\"] fn with_timeout (timeout : Duration , f : impl FnOnce () + Send + 'static) { use std :: sync :: mpsc :: RecvTimeoutError ; let (done_tx , done_rx) = std :: sync :: mpsc :: channel () ; let thread = std :: thread :: spawn (move | | { f () ; done_tx . send (()) . unwrap () ; }) ; match done_rx . recv_timeout (timeout) { Err (RecvTimeoutError :: Timeout) => panic ! (\"test did not complete within {timeout:?} seconds, \\\n             we have (probably) entered an infinite loop!\" ,) , Err (RecvTimeoutError :: Disconnected) => { } Ok (()) => { } } thread . join () . expect (\"test thread should not panic!\") } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new_stats",
                        "label": "new_stats",
                        "kind": "Function",
                        "signature": "fn fn new_stats () -> Stats { Stats :: new (& crate :: runtime :: WorkerMetrics :: new ()) } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ping_pong",
                        "label": "ping_pong",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn ping_pong () { let (mut a , mut b) = duplex (32) ; let mut buf = [0u8 ; 4] ; a . write_all (b\"ping\") . await . unwrap () ; b . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"ping\") ; b . write_all (b\"pong\") . await . unwrap () ; a . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"pong\") ; } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_recv",
                        "label": "blocking_recv",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] fn blocking_recv () { let (tx , mut rx) = mpsc :: channel :: < u8 > (1) ; let sync_code = std :: thread :: spawn (move | | { assert_eq ! (Some (10) , rx . blocking_recv ()) ; }) ; tokio :: runtime :: Runtime :: new () . unwrap () . block_on (async move { let _ = tx . send (10) . await ; }) ; sync_code . join () . unwrap () } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_block_in_place4",
                        "label": "test_block_in_place4",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] # [test] async fn test_block_in_place4 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_on_empty_channel_without_senders",
                        "label": "test_rx_unbounded_len_on_empty_channel_without_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_on_empty_channel_without_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; drop (tx) ; assert_eq ! (rx . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_break",
                        "label": "ctrl_break",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-break\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_break;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-BREAK events.\"] # [doc = \"     let mut signal = ctrl_break()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-BREAK event is received.\"] # [doc = \"     loop {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got signal CTRL-BREAK\\\");\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_break () -> io :: Result < CtrlBreak > { Ok (CtrlBreak { inner : self :: imp :: ctrl_break () ? , }) } . sig",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "utf8",
                        "label": "utf8",
                        "kind": "Function",
                        "signature": "fn fn utf8 (buf : & [u8]) -> Result < & str , io :: Error > { str :: from_utf8 (buf) . map_err (| _ | io :: Error :: new (io :: ErrorKind :: InvalidData , \"Unable to decode input as UTF8\")) } . sig",
                        "file_path": "tokio-util/src/codec/lines_codec.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contains_key_borrow",
                        "label": "contains_key_borrow",
                        "kind": "Function",
                        "signature": "fn # [test] fn contains_key_borrow () { let mut map = StreamMap :: new () ; map . insert (\"foo\" . to_string () , pending :: < () > ()) ; assert ! (map . contains_key (\"foo\")) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end",
                        "label": "read_to_end",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_to_end () { let mut buf = vec ! [] ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_to_end (& mut buf) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_tuning",
                        "label": "test_tuning",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (tokio_no_tuning_tests))] fn test_tuning () { use std :: sync :: atomic :: AtomicBool ; use std :: time :: Duration ; let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; fn iter (flag : Arc < AtomicBool > , counter : Arc < AtomicUsize > , stall : bool) { if flag . load (Relaxed) { if stall { std :: thread :: sleep (Duration :: from_micros (5)) ; } counter . fetch_add (1 , Relaxed) ; tokio :: spawn (async move { iter (flag , counter , stall) }) ; } } let flag = Arc :: new (AtomicBool :: new (true)) ; let counter = Arc :: new (AtomicUsize :: new (61)) ; let interval = Arc :: new (AtomicUsize :: new (61)) ; { let flag = flag . clone () ; let counter = counter . clone () ; rt . spawn (async move { iter (flag , counter , true) }) ; } let mut n = 0 ; loop { let curr = interval . load (Relaxed) ; if curr <= 8 { n += 1 ; } else { n = 0 ; } if n == 3 { break ; } if Arc :: strong_count (& interval) < 5_000 { let counter = counter . clone () ; let interval = interval . clone () ; rt . spawn (async move { let prev = counter . swap (0 , Relaxed) ; interval . store (prev , Relaxed) ; }) ; std :: thread :: yield_now () ; } } flag . store (false , Relaxed) ; let w = Arc :: downgrade (& interval) ; drop (interval) ; while w . strong_count () > 0 { std :: thread :: sleep (Duration :: from_micros (500)) ; } let flag = Arc :: new (AtomicBool :: new (true)) ; let counter = Arc :: new (AtomicUsize :: new (10_000)) ; let interval = Arc :: new (AtomicUsize :: new (10_000)) ; { let flag = flag . clone () ; let counter = counter . clone () ; rt . spawn (async move { iter (flag , counter , false) }) ; } let mut n = 0 ; loop { let curr = interval . load (Relaxed) ; if curr <= 1_000 && curr > 32 { n += 1 ; } else { n = 0 ; } if n == 3 { break ; } if Arc :: strong_count (& interval) <= 5_000 { let counter = counter . clone () ; let interval = interval . clone () ; rt . spawn (async move { let prev = counter . swap (0 , Relaxed) ; interval . store (prev , Relaxed) ; }) ; } std :: thread :: yield_now () ; } flag . store (false , Relaxed) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TokioAsyncReadCompatExt",
                        "label": "TokioAsyncReadCompatExt",
                        "kind": "Trait",
                        "signature": "trait TokioAsyncReadCompatExt",
                        "file_path": "tokio-util/src/compat.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "test_enable_consumes_permit",
                        "label": "test_enable_consumes_permit",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_enable_consumes_permit () { let notify = Arc :: new (Notify :: new ()) ; notify . notify_one () ; let mut future1 = spawn (notify . clone () . notified_owned ()) ; future1 . enter (| _ , fut | assert ! (fut . enable ())) ; let mut future2 = spawn (notify . clone () . notified_owned ()) ; future2 . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "advancing_time_when_time_is_not_frozen_panics",
                        "label": "advancing_time_when_time_is_not_frozen_panics",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn advancing_time_when_time_is_not_frozen_panics () { time :: advance (Duration :: from_secs (1)) . await ; } . sig",
                        "file_path": "tokio/tests/test_clock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_thread_scheduler_sleep",
                        "label": "multi_thread_scheduler_sleep",
                        "kind": "Function",
                        "signature": "fn fn multi_thread_scheduler_sleep (c : & mut Criterion) { do_sleep_test (c , 8 , \"multi_thread_sleep-8\") ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Reaper",
                        "label": "Reaper",
                        "kind": "Struct",
                        "signature": "struct Reaper",
                        "file_path": "tokio/src/process/unix/reap.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "abort_send_after_successful_reserve",
                        "label": "abort_send_after_successful_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn abort_send_after_successful_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 1) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; assert ! (send . abort_send ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 1) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "one_ready",
                        "label": "one_ready",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn one_ready () { let (tx1 , rx1) = oneshot :: channel :: < i32 > () ; let (_tx2 , rx2) = oneshot :: channel :: < i32 > () ; tx1 . send (1) . unwrap () ; let v = tokio :: select ! { res = rx1 => { assert_ok ! (res) } , _ = rx2 => unreachable ! () , } ; assert_eq ! (1 , v) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line",
                        "label": "read_line",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn read_line < 'a , R > (reader : & 'a mut R , string : & 'a mut String) -> ReadLine < 'a , R > where R : AsyncBufRead + ? Sized + Unpin , { ReadLine { reader , buf : mem :: take (string) . into_bytes () , output : string , read : 0 , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AnyDelimiterCodec",
                        "label": "AnyDelimiterCodec",
                        "kind": "Struct",
                        "signature": "struct AnyDelimiterCodec",
                        "file_path": "tokio-util/src/codec/any_delimiter_codec.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RxFields",
                        "label": "RxFields",
                        "kind": "Struct",
                        "signature": "struct RxFields",
                        "file_path": "tokio/src/sync/mpsc/chan.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Semaphore",
                        "label": "Semaphore",
                        "kind": "Struct",
                        "signature": "struct Semaphore",
                        "file_path": "tokio/src/sync/mpsc/unbounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "release_permits_at_drop",
                        "label": "release_permits_at_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn release_permits_at_drop () { use crate :: sync :: semaphore :: * ; use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let sem = Arc :: new (Semaphore :: new (1)) ; struct ReleaseOnDrop (# [allow (dead_code)] Option < OwnedSemaphorePermit >) ; impl ArcWake for ReleaseOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } let mut fut = Box :: pin (async { let _permit = sem . acquire () . await . unwrap () ; }) ; for _ in 0 ..= 1 { let waker = futures :: task :: waker (Arc :: new (ReleaseOnDrop (sem . clone () . try_acquire_owned () . ok () ,))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PtrExposeDomain",
                        "label": "PtrExposeDomain",
                        "kind": "Struct",
                        "signature": "struct PtrExposeDomain",
                        "file_path": "tokio/src/util/ptr_expose.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "spawn_blocking_with_name",
                        "label": "spawn_blocking_with_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_blocking_with_name () { let result = Builder :: new () . name (\"name\") . spawn_blocking (| | \"task executed\") . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_transmute",
                        "label": "try_transmute",
                        "kind": "Function",
                        "signature": "fn pub (super) unsafe fn try_transmute < Src , Target : 'static > (x : Src) -> Result < Target , Src > { if nonstatic_typeid :: < Src > () == TypeId :: of :: < Target > () { let x = ManuallyDrop :: new (x) ; Ok (mem :: transmute_copy :: < Src , Target > (& x)) } else { Err (x) } } . sig",
                        "file_path": "tokio/src/util/typeid.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "gone",
                        "label": "gone",
                        "kind": "Function",
                        "signature": "fn fn gone () -> io :: Error { io :: Error :: new (io :: ErrorKind :: Other , crate :: util :: error :: RUNTIME_SHUTTING_DOWN_ERROR ,) } . sig",
                        "file_path": "tokio/src/runtime/io/registration.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TcpListenerStream",
                        "label": "TcpListenerStream",
                        "kind": "Struct",
                        "signature": "struct TcpListenerStream",
                        "file_path": "tokio-stream/src/wrappers/tcp_listener.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AbortOnDropHandle",
                        "label": "AbortOnDropHandle",
                        "kind": "Struct",
                        "signature": "struct AbortOnDropHandle",
                        "file_path": "tokio-util/src/task/abort_on_drop.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sync_all_err_ordered_after_write",
                        "label": "sync_all_err_ordered_after_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn sync_all_err_ordered_after_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_sync_all () . once () . returning (| | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . sync_all ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_when_paused",
                        "label": "blocking_when_paused",
                        "kind": "Function",
                        "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn blocking_when_paused () { time :: timeout (Duration :: from_secs (3) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (1))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; time :: timeout (Duration :: from_millis (1) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (50))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "globals_init",
                        "label": "globals_init",
                        "kind": "Function",
                        "signature": "fn fn globals_init () -> Globals where OsExtraData : 'static + Send + Sync + Init , OsStorage : 'static + Send + Sync + Init , { Globals { extra : OsExtraData :: init () , registry : Registry :: new (OsStorage :: init ()) , } } . sig",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "level_for",
                        "label": "level_for",
                        "kind": "Function",
                        "signature": "fn fn level_for (elapsed : u64 , when : u64) -> usize { const SLOT_MASK : u64 = (1 << 6) - 1 ; let mut masked = elapsed ^ when | SLOT_MASK ; if masked >= MAX_DURATION { masked = MAX_DURATION - 1 ; } let leading_zeros = masked . leading_zeros () as usize ; let significant = 63 - leading_zeros ; significant / NUM_LEVELS } . sig",
                        "file_path": "tokio/src/runtime/time/wheel/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_empty_all_senders_are_dropped_and_messages_consumed",
                        "label": "test_rx_is_empty_all_senders_are_dropped_and_messages_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_empty_all_senders_are_dropped_and_messages_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; for _ in 0 .. 10 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BlockingPool",
                        "label": "BlockingPool",
                        "kind": "Struct",
                        "signature": "struct BlockingPool",
                        "file_path": "tokio/src/runtime/blocking/pool.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_multi_thread_with_unhandled_panic",
                        "label": "test_multi_thread_with_unhandled_panic",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , unhandled_panic = \"shutdown_runtime\")] async fn test_multi_thread_with_unhandled_panic () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_exact",
                        "label": "read_exact",
                        "kind": "Function",
                        "signature": "fn # [doc = \" A future which can be used to easily read exactly enough bytes to fill\"] # [doc = \" a buffer.\"] # [doc = \"\"] # [doc = \" Created by the [`AsyncReadExt::read_exact`][read_exact].\"] # [doc = \" [`read_exact`]: [`crate::io::AsyncReadExt::read_exact`]\"] pub (crate) fn read_exact < 'a , A > (reader : & 'a mut A , buf : & 'a mut [u8]) -> ReadExact < 'a , A > where A : AsyncRead + Unpin + ? Sized , { ReadExact { reader , buf : ReadBuf :: new (buf) , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_exact.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "put_back_original_data",
                        "label": "put_back_original_data",
                        "kind": "Function",
                        "signature": "fn fn put_back_original_data (output : & mut String , mut vector : Vec < u8 > , num_bytes_read : usize) { let original_len = vector . len () - num_bytes_read ; vector . truncate (original_len) ; * output = String :: from_utf8 (vector) . expect (\"The original data must be valid utf-8.\") ; } . sig",
                        "file_path": "tokio/src/io/util/read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_one",
                        "label": "notify_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_one () { loom :: model (| | { let tx = Arc :: new (Notify :: new ()) ; let rx = tx . clone () ; let th = thread :: spawn (move | | { block_on (async { rx . notified () . await ; }) ; }) ; tx . notify_one () ; th . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_uninit",
                        "label": "get_uninit",
                        "kind": "Function",
                        "signature": "fn # [test] fn get_uninit () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let uninit = ONCE . get () ; assert ! (uninit . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_exclusive_pending",
                        "label": "read_exclusive_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_exclusive_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . write ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . read ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duplicate_handle",
                        "label": "duplicate_handle",
                        "kind": "Function",
                        "signature": "fn fn duplicate_handle < T : AsRawHandle > (io : & T) -> io :: Result < StdFile > { use std :: os :: windows :: prelude :: FromRawHandle ; unsafe { let mut dup_handle = INVALID_HANDLE_VALUE ; let cur_proc = GetCurrentProcess () ; let status = DuplicateHandle (cur_proc , io . as_raw_handle () as _ , cur_proc , & mut dup_handle , 0 , 0 , DUPLICATE_SAME_ACCESS ,) ; if status == 0 { return Err (io :: Error :: last_os_error ()) ; } Ok (StdFile :: from_raw_handle (dup_handle as _)) } } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "runtime_gone",
                        "label": "runtime_gone",
                        "kind": "Function",
                        "signature": "fn # [test] fn runtime_gone () { let mut set = JoinSet :: new () ; { let rt = rt () ; set . spawn_on (async { 1 } , rt . handle ()) ; drop (rt) ; } assert ! (rt () . block_on (set . join_next ()) . unwrap () . unwrap_err () . is_cancelled ()) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_odd_on_vectored",
                        "label": "write_vectored_odd_on_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_odd_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& []) , IoSlice :: new (& msg [4 .. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: with_vectored_backend (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_sender_success",
                        "label": "downgrade_upgrade_sender_success",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_upgrade_sender_success () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . downgrade () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_thread",
                        "label": "single_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_thread () { let _ = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (1) . build () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_unbounded_sender_failure",
                        "label": "downgrade_upgrade_unbounded_sender_failure",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_upgrade_unbounded_sender_failure () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rename",
                        "label": "rename",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Renames a file or directory to a new name, replacing the original file if\"] # [doc = \" `to` already exists.\"] # [doc = \"\"] # [doc = \" This will not work if the new name is on a different mount point.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::rename`].\"] pub async fn rename (from : impl AsRef < Path > , to : impl AsRef < Path >) -> io :: Result < () > { let from = from . as_ref () . to_owned () ; let to = to . as_ref () . to_owned () ; asyncify (move | | std :: fs :: rename (from , to)) . await } . sig",
                        "file_path": "tokio/src/fs/rename.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_dir",
                        "label": "remove_dir",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Removes an existing, empty directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_dir`].\"] pub async fn remove_dir (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_dir (path)) . await } . sig",
                        "file_path": "tokio/src/fs/remove_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interleave_enter_same_rt",
                        "label": "interleave_enter_same_rt",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_enter_same_rt () { let rt1 = rt () ; let _enter1 = rt1 . enter () ; let enter2 = rt1 . enter () ; let enter3 = rt1 . enter () ; drop (enter2) ; drop (enter3) ; } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_output_destructor_handle_dropped_after_completion",
                        "label": "task_id_output_destructor_handle_dropped_after_completion",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_output_destructor_handle_dropped_after_completion () { struct MyOutput { tx : Option < oneshot :: Sender < Id > > , } impl Drop for MyOutput { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } struct MyFuture { tx_output : Option < oneshot :: Sender < Id > > , tx_future : Option < oneshot :: Sender < () > > , } impl Future for MyFuture { type Output = MyOutput ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < Self :: Output > { let _ = self . tx_future . take () . unwrap () . send (()) ; Poll :: Ready (MyOutput { tx : self . tx_output . take () , }) } } let (tx_output , mut rx_output) = oneshot :: channel () ; let (tx_future , rx_future) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx_output : Some (tx_output) , tx_future : Some (tx_future) , }) ; let id = handle . id () ; rx_future . await . unwrap () ; assert ! (rx_output . try_recv () . is_err ()) ; drop (handle) ; assert_eq ! (rx_output . await . unwrap () , id) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "method_delegation",
                        "label": "method_delegation",
                        "kind": "Function",
                        "signature": "fn # [test] fn method_delegation () { let mut rw = join (R , W) ; let mut buf = [0 ; 1] ; tokio_test :: block_on (async move { assert_eq ! (1 , rw . read (& mut buf) . await . unwrap ()) ; assert_eq ! (b'z' , buf [0]) ; assert_eq ! (1 , rw . write (b\"x\") . await . unwrap ()) ; assert_eq ! (2 , rw . write_vectored (& [io :: IoSlice :: new (b\"x\")]) . await . unwrap ()) ; assert ! (rw . is_write_vectored ()) ; assert ! (rw . flush () . await . is_ok ()) ; assert ! (rw . shutdown () . await . is_ok ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/io_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PanicOnDrop",
                        "label": "PanicOnDrop",
                        "kind": "Struct",
                        "signature": "struct PanicOnDrop",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_write",
                        "label": "drop_write",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Test that dropping the write half actually closes the stream.\"] # [tokio :: test] async fn drop_write () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { let (mut stream , _) = listener . accept () . unwrap () ; stream . write_all (MSG) . unwrap () ; let mut read_buf = [0u8 ; 32] ; let res = match stream . read (& mut read_buf) { Ok (0) => Ok (()) , Ok (len) => Err (Error :: new (ErrorKind :: Other , format ! (\"Unexpected read: {len} bytes.\") ,)) , Err (err) => Err (err) , } ; drop (stream) ; res }) ; let stream = TcpStream :: connect (& addr) . await ? ; let (mut read_half , write_half) = stream . into_split () ; let mut read_buf = [0u8 ; 32] ; let read_len = read_half . read (& mut read_buf [..]) . await ? ; assert_eq ! (& read_buf [.. read_len] , MSG) ; std :: thread :: spawn (move | | { thread :: sleep (std :: time :: Duration :: from_millis (10)) ; drop (write_half) ; }) ; match read_half . read (& mut read_buf [..]) . await { Ok (0) => { } Ok (len) => panic ! (\"Unexpected read: {len} bytes.\") , Err (err) => panic ! (\"Unexpected error: {err}.\") , } handle . join () . unwrap () . unwrap () ; Ok (()) } . sig",
                        "file_path": "tokio/tests/tcp_into_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_closed_when_there_are_no_senders_and_there_are_messages",
                        "label": "test_rx_unbounded_is_closed_when_there_are_no_senders_and_there_are_messages",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_there_are_no_senders_and_there_are_messages () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_read_std_file",
                        "label": "async_read_std_file",
                        "kind": "Function",
                        "signature": "fn fn async_read_std_file (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_std_file\" , | b | { b . iter (| | { let task = | | async { let mut file = tokio :: task :: block_in_place (| | Box :: pin (StdFile :: open (DEV_ZERO) . unwrap ())) ; for _i in 0 .. BLOCK_COUNT { let mut buffer = [0u8 ; BUFFER_SIZE] ; let mut file_ref = file . as_mut () ; tokio :: task :: block_in_place (move | | { file_ref . read_exact (& mut buffer) . unwrap () ; }) ; } } ; rt . block_on (task ()) ; }) ; }) ; } . sig",
                        "file_path": "benches/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RecvError",
                        "label": "RecvError",
                        "kind": "Struct",
                        "signature": "struct RecvError",
                        "file_path": "tokio/src/sync/mpsc/error.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "cancel_grandchild_token_through_parent_if_child_was_dropped",
                        "label": "cancel_grandchild_token_through_parent_if_child_was_dropped",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_grandchild_token_through_parent_if_child_was_dropped () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let intermediate_token = token . child_token () ; let child_token = intermediate_token . child_token () ; drop (intermediate_token) ; assert ! (! child_token . is_cancelled ()) ; let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Pending , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 2) ; assert ! (token . is_cancelled ()) ; assert ! (child_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_all",
                        "label": "join_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn join_all () { let mut set : JoinSet < i32 > = JoinSet :: new () ; for _ in 0 .. 5 { set . spawn (async { 1 }) ; } let res : Vec < i32 > = set . join_all () . await ; assert_eq ! (res . len () , 5) ; for itm in res . into_iter () { assert_eq ! (itm , 1) } } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_send",
                        "label": "broadcast_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_send () { loom :: model (| | { let (tx1 , mut rx) = broadcast :: channel (2) ; let tx1 = Arc :: new (tx1) ; let tx2 = tx1 . clone () ; let th1 = thread :: spawn (move | | { block_on (async { assert_ok ! (tx1 . send (\"one\")) ; assert_ok ! (tx1 . send (\"two\")) ; assert_ok ! (tx1 . send (\"three\")) ; }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { assert_ok ! (tx2 . send (\"eins\")) ; assert_ok ! (tx2 . send (\"zwei\")) ; assert_ok ! (tx2 . send (\"drei\")) ; }) ; }) ; block_on (async { let mut num = 0 ; loop { match rx . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 6) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Runtime",
                        "label": "Runtime",
                        "kind": "Struct",
                        "signature": "struct Runtime",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "close_semaphore_notifies_permit1",
                        "label": "close_semaphore_notifies_permit1",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_semaphore_notifies_permit1 () { let s = Semaphore :: new (0) ; let mut acquire = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire . poll ()) ; s . close () ; assert ! (acquire . is_woken ()) ; assert_ready_err ! (acquire . poll ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnparkThread",
                        "label": "UnparkThread",
                        "kind": "Struct",
                        "signature": "struct UnparkThread",
                        "file_path": "tokio/src/runtime/park.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ListsInner",
                        "label": "ListsInner",
                        "kind": "Struct",
                        "signature": "struct ListsInner",
                        "file_path": "tokio/src/util/idle_notified_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RcCell",
                        "label": "RcCell",
                        "kind": "Struct",
                        "signature": "struct RcCell",
                        "file_path": "tokio/src/util/rc_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "id",
                        "label": "id",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns the [`Id`] of the currently running task.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if called from outside a task. Please note that calls\"] # [doc = \" to `block_on` do not have task IDs, so the method will panic if called from\"] # [doc = \" within a call to `block_on`. For a version of this function that doesn't\"] # [doc = \" panic, see [`task::try_id()`](crate::runtime::task::try_id()).\"] # [doc = \"\"] # [doc = \" [task ID]: crate::task::Id\"] # [track_caller] pub fn id () -> Id { context :: current_task_id () . expect (\"Can't get a task id when not inside a task\") } . sig",
                        "file_path": "tokio/src/runtime/task/id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_fill_buf_wrapper",
                        "label": "test_fill_buf_wrapper",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_fill_buf_wrapper () { let (mut write , read) = tokio :: io :: duplex (16) ; let mut read = BufReader :: new (read) ; write . write_all (b\"hello world\") . await . unwrap () ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"hello world\") ; read . consume (b\"hello \" . len ()) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"world\") ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"world\") ; read . consume (b\"world\" . len ()) ; let mut fill = spawn (read . fill_buf ()) ; assert_pending ! (fill . poll ()) ; write . write_all (b\"foo bar\") . await . unwrap () ; assert_eq ! (assert_ready ! (fill . poll ()) . unwrap () , b\"foo bar\") ; drop (fill) ; drop (write) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"foo bar\") ; read . consume (b\"foo bar\" . len ()) ; assert_eq ! (read . fill_buf () . await . unwrap () , b\"\") ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "debug_inner",
                        "label": "debug_inner",
                        "kind": "Function",
                        "signature": "fn fn debug_inner (inner : & TaskTrackerInner , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { let state = inner . state . load (Ordering :: Acquire) ; let is_closed = (state & 1) != 0 ; let len = state >> 1 ; f . debug_struct (\"TaskTracker\") . field (\"len\" , & len) . field (\"is_closed\" , & is_closed) . field (\"inner\" , & (inner as * const TaskTrackerInner)) . finish () } . sig",
                        "file_path": "tokio-util/src/task/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_not_empty_when_there_are_messages_in_the_buffer",
                        "label": "test_rx_unbounded_is_not_empty_when_there_are_messages_in_the_buffer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_not_empty_when_there_are_messages_in_the_buffer () { let (tx , rx) = mpsc :: unbounded_channel () ; assert ! (tx . send (()) . is_ok ()) ; assert ! (! rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "num_workers",
                        "label": "num_workers",
                        "kind": "Function",
                        "signature": "fn # [test] fn num_workers () { let rt = current_thread () ; assert_eq ! (1 , rt . metrics () . num_workers ()) ; let rt = threaded () ; assert_eq ! (2 , rt . metrics () . num_workers ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Mutex",
                        "label": "Mutex",
                        "kind": "Struct",
                        "signature": "struct Mutex",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "global_queue_depth_current_thread",
                        "label": "global_queue_depth_current_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn global_queue_depth_current_thread () { use std :: thread ; let rt = current_thread () ; let handle = rt . handle () . clone () ; let metrics = rt . metrics () ; thread :: spawn (move | | { handle . spawn (async { }) ; }) . join () . unwrap () ; assert_eq ! (1 , metrics . global_queue_depth ()) ; } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "defer",
                        "label": "defer",
                        "kind": "Function",
                        "signature": "fn fn defer < F : FnOnce () -> R , R > (f : F) -> impl Drop { use std :: mem :: ManuallyDrop ; struct Defer < F : FnOnce () -> R , R > (ManuallyDrop < F >) ; impl < F : FnOnce () -> R , R > Drop for Defer < F , R > { # [inline (always)] fn drop (& mut self) { unsafe { ManuallyDrop :: take (& mut self . 0) () ; } } } Defer (ManuallyDrop :: new (f)) } . sig",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_net_types_are_unwind_safe",
                        "label": "unix_net_types_are_unwind_safe",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] fn unix_net_types_are_unwind_safe () { is_unwind_safe :: < tokio :: net :: UnixDatagram > () ; is_unwind_safe :: < tokio :: net :: UnixListener > () ; is_unwind_safe :: < tokio :: net :: UnixStream > () ; } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "R",
                        "label": "R",
                        "kind": "Struct",
                        "signature": "struct R",
                        "file_path": "tokio/tests/io_join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_no_spurious_wakeups",
                        "label": "test_join_queue_no_spurious_wakeups",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_no_spurious_wakeups () { let (tx , rx) = oneshot :: channel :: < () > () ; let mut join_queue = JoinQueue :: new () ; join_queue . spawn (async move { let _ = rx . await ; 42 }) ; let mut join_next = task :: spawn (join_queue . join_next ()) ; assert_pending ! (join_next . poll ()) ; assert ! (! join_next . is_woken ()) ; let _ = tx . send (()) ; yield_now () . await ; assert ! (join_next . is_woken ()) ; let output = assert_ready ! (join_next . poll ()) ; assert_eq ! (output . unwrap () . unwrap () , 42) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_clones_waker_before_lock",
                        "label": "notify_clones_waker_before_lock",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_clones_waker_before_lock () { const VTABLE : & RawWakerVTable = & RawWakerVTable :: new (clone_w , wake , wake_by_ref , drop_w) ; unsafe fn clone_w (data : * const ()) -> RawWaker { let ptr = data as * const Notify ; Arc :: < Notify > :: increment_strong_count (ptr) ; (* ptr) . notify_one () ; RawWaker :: new (data , VTABLE) } unsafe fn drop_w (data : * const ()) { drop (Arc :: < Notify > :: from_raw (data as * const Notify)) ; } unsafe fn wake (_data : * const ()) { unreachable ! () } unsafe fn wake_by_ref (_data : * const ()) { unreachable ! () } let notify = Arc :: new (Notify :: new ()) ; let notify2 = notify . clone () ; let waker = unsafe { Waker :: from_raw (RawWaker :: new (Arc :: into_raw (notify2) as * const _ , VTABLE)) } ; let mut cx = Context :: from_waker (& waker) ; let future = notify . notified () ; pin ! (future) ; let _ = future . poll (& mut cx) ; } . sig",
                        "file_path": "tokio/src/sync/tests/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DontReadIntoThis",
                        "label": "DontReadIntoThis",
                        "kind": "Struct",
                        "signature": "struct DontReadIntoThis",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Values",
                        "label": "Values",
                        "kind": "Struct",
                        "signature": "struct Values",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write",
                        "label": "write",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a future that will open a file for writing and write the entire\"] # [doc = \" contents of `contents` to it.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::write`][std].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \" [std]: fn@std::fs::write\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::write(\\\"foo.txt\\\", b\\\"Hello world!\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn write (path : impl AsRef < Path > , contents : impl AsRef < [u8] >) -> io :: Result < () > { let path = path . as_ref () ; let contents = crate :: util :: as_ref :: upgrade (contents) ; # [cfg (all (tokio_unstable , feature = \"io-uring\" , feature = \"rt\" , feature = \"fs\" , target_os = \"linux\"))] { let handle = crate :: runtime :: Handle :: current () ; let driver_handle = handle . inner . driver () . io () ; if driver_handle . check_and_init () ? { return write_uring (path , contents) . await ; } } write_spawn_blocking (path , contents) . await } . sig",
                        "file_path": "tokio/src/fs/write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "now",
                        "label": "now",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Gate unsupported time metrics for `wasm32-unknown-unknown`\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/7319>\"] fn now () -> Option < Instant > { if cfg ! (all (target_arch = \"wasm32\" , target_os = \"unknown\" , target_vendor = \"unknown\")) { None } else { Some (Instant :: now ()) } } . sig",
                        "file_path": "tokio/src/runtime/metrics/batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "traits",
                        "label": "traits",
                        "kind": "Function",
                        "signature": "fn # [test] # [allow (clippy :: extra_unused_lifetimes)] fn traits < 'a > () { fn assert_traits < T : Send + Sync + Unpin > () { } assert_traits :: < ReusableBoxFuture < 'a , PhantomPinned > > () ; assert_traits :: < ReusableBoxFuture < 'a , Rc < () > > > () ; } . sig",
                        "file_path": "tokio-util/tests/reusable_box.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_update_max_frame_len_at_rest",
                        "label": "write_update_max_frame_len_at_rest",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_update_max_frame_len_at_rest () { let io = length_delimited :: Builder :: new () . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x06\") , data (b\"abcdef\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; io . encoder_mut () . set_max_frame_length (5) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "crate_rename_test",
                        "label": "crate_rename_test",
                        "kind": "Function",
                        "signature": "fn # [tokio1 :: test (crate = \"tokio1\")] async fn crate_rename_test () { assert_eq ! (1 , compute () . await) ; } . sig",
                        "file_path": "tokio/tests/macros_rename_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_closed",
                        "label": "size_hint_stream_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_closed () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_until",
                        "label": "read_until",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn read_until < 'a , R > (reader : & 'a mut R , delimiter : u8 , buf : & 'a mut Vec < u8 > ,) -> ReadUntil < 'a , R > where R : AsyncBufRead + ? Sized + Unpin , { ReadUntil { reader , delimiter , buf , read : 0 , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_until.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect",
                        "label": "connect",
                        "kind": "Function",
                        "signature": "fn pub async fn connect (addr : & SocketAddr , stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin ,) -> Result < () , Box < dyn Error > > { let bind_addr = if addr . ip () . is_ipv4 () { \"0.0.0.0:0\" } else { \"[::]:0\" } ; let socket = UdpSocket :: bind (& bind_addr) . await ? ; socket . connect (addr) . await ? ; tokio :: try_join ! (send (stdin , & socket) , recv (stdout , & socket)) ? ; Ok (()) } . sig",
                        "file_path": "examples/connect-udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CtrlClose",
                        "label": "CtrlClose",
                        "kind": "Struct",
                        "signature": "struct CtrlClose",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_shutdown",
                        "label": "ctrl_shutdown",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-shutdown\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_shutdown;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-SHUTDOWN events.\"] # [doc = \"     let mut signal = ctrl_shutdown()?;\"] # [doc = \"\"] # [doc = \"     signal.recv().await;\"] # [doc = \"     println!(\\\"got CTRL-SHUTDOWN. Cleaning up before exiting\\\");\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_shutdown () -> io :: Result < CtrlShutdown > { Ok (CtrlShutdown { inner : self :: imp :: ctrl_shutdown () ? , }) } . sig",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_when_close_is_called",
                        "label": "test_rx_len_when_close_is_called",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mk_pool",
                        "label": "mk_pool",
                        "kind": "Function",
                        "signature": "fn fn mk_pool (num_threads : usize) -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (num_threads) . event_interval (2) . build () . unwrap () } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CallOnDrop",
                        "label": "CallOnDrop",
                        "kind": "Struct",
                        "signature": "struct CallOnDrop",
                        "file_path": "tokio-util/src/sync/reusable_box.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "MockTask",
                        "label": "MockTask",
                        "kind": "Struct",
                        "signature": "struct MockTask",
                        "file_path": "tokio-test/src/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "obtain_raw_handle",
                        "label": "obtain_raw_handle",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn obtain_raw_handle () { let mut cmd = Command :: new (\"cmd\") ; cmd . kill_on_drop (true) ; cmd . arg (\"/c\") ; cmd . arg (\"pause\") ; let child = cmd . spawn () . unwrap () ; let orig_id = child . id () . expect (\"missing id\") ; assert ! (orig_id > 0) ; let handle = child . raw_handle () . expect (\"process stopped\") ; let handled_id = unsafe { GetProcessId (handle as _) } ; assert_eq ! (handled_id , orig_id) ; } . sig",
                        "file_path": "tokio/tests/process_raw_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Steal",
                        "label": "Steal",
                        "kind": "Struct",
                        "signature": "struct Steal",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "immediate_sleep",
                        "label": "immediate_sleep",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn immediate_sleep () { time :: pause () ; let now = Instant :: now () ; time :: sleep_until (now) . await ; assert_elapsed ! (now , ms (1)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "fits_256_all_at_once",
                        "label": "fits_256_all_at_once",
                        "kind": "Function",
                        "signature": "fn # [test] fn fits_256_all_at_once () { let (_ , mut local) = queue :: local () ; let mut tasks = (0 .. 256) . map (| _ | super :: unowned (async { }) . 0) . collect :: < Vec < _ > > () ; local . push_back (tasks . drain (..)) ; let mut i = 0 ; while local . pop () . is_some () { i += 1 ; } assert_eq ! (i , 256) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_comma",
                        "label": "sync_one_lit_expr_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: select ! { foo = async { 1 } => foo , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "burst",
                        "label": "burst",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn burst () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (650)) . await ; check_interval_poll ! (i , start , 600 , 900) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start , 1200) ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start , 1500) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1800) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_two_lit_expr_no_comma",
                        "label": "sync_two_lit_expr_no_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_no_comma () { let foo = tokio :: join ! (async { 1 } , async { 2 }) ; assert_eq ! (foo , (1 , 2)) ; let foo = tokio :: join ! (biased ; async { 1 } , async { 2 }) ; assert_eq ! (foo , (1 , 2)) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_2174",
                        "label": "issue_2174",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (panic = \"abort\" , ignore)] async fn issue_2174 () { let mut child = Command :: new (\"sleep\") . arg (\"2\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () . unwrap () ; let mut input = child . stdin . take () . unwrap () ; let handle = tokio :: spawn (async move { let data = [0u8 ; 8192] ; loop { input . write_all (& data) . await . unwrap () ; } }) ; time :: sleep (Duration :: from_secs (1)) . await ; child . kill () . await . unwrap () ; assert_err ! (handle . await) ; } . sig",
                        "file_path": "tokio/tests/process_issue_2174.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "waker_ref",
                        "label": "waker_ref",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns a `WakerRef` which avoids having to preemptively increase the\"] # [doc = \" refcount if there is no need to do so.\"] pub (super) fn waker_ref < S > (header : & NonNull < Header >) -> WakerRef < '_ , S > where S : Schedule , { let waker = unsafe { ManuallyDrop :: new (Waker :: from_raw (raw_waker (* header))) } ; WakerRef { waker , _p : PhantomData , } } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_drop",
                        "label": "notify_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_drop () { use std :: future :: { poll_fn , Future } ; use std :: task :: Poll ; loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let rx1 = notify . clone () ; let rx2 = notify . clone () ; let th1 = thread :: spawn (move | | { let mut recv = Box :: pin (rx1 . notified ()) ; block_on (poll_fn (| cx | { if recv . as_mut () . poll (cx) . is_ready () { rx1 . notify_one () ; } Poll :: Ready (()) })) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { rx2 . notified () . await ; rx2 . notify_one () ; rx2 . notified () . await ; }) ; }) ; notify . notify_one () ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_done",
                        "label": "maybe_done",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Wraps a future into a `MaybeDone`.\"] pub fn maybe_done < F : IntoFuture > (future : F) -> MaybeDone < F :: IntoFuture > { MaybeDone :: Future { future : future . into_future () , } } . sig",
                        "file_path": "tokio/src/future/maybe_done.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local",
                        "label": "local",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn local () { tokio :: task_local ! { static REQ_ID : u32 ; pub static FOO : bool ; } let j1 = tokio :: spawn (REQ_ID . scope (1 , async move { assert_eq ! (REQ_ID . get () , 1) ; assert_eq ! (REQ_ID . get () , 1) ; })) ; let j2 = tokio :: spawn (REQ_ID . scope (2 , async move { REQ_ID . with (| v | { assert_eq ! (REQ_ID . get () , 2) ; assert_eq ! (* v , 2) ; }) ; tokio :: time :: sleep (std :: time :: Duration :: from_millis (10)) . await ; assert_eq ! (REQ_ID . get () , 2) ; })) ; let j3 = tokio :: spawn (FOO . scope (true , async move { assert ! (FOO . get ()) ; })) ; j1 . await . unwrap () ; j2 . await . unwrap () ; j3 . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Trace",
                        "label": "Trace",
                        "kind": "Struct",
                        "signature": "struct Trace",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_close",
                        "label": "ctrl_close",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_close () -> io :: Result < RxFuture > { panic ! () } . sig",
                        "file_path": "tokio/src/signal/windows/stub.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "my_async_fn",
                        "label": "my_async_fn",
                        "kind": "Function",
                        "signature": "fn async fn my_async_fn () { } . sig",
                        "file_path": "tests-integration/tests/macros_pin.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Harness",
                        "label": "Harness",
                        "kind": "Struct",
                        "signature": "struct Harness",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "shutdown",
                        "label": "shutdown",
                        "kind": "Function",
                        "signature": "fn # [test] fn shutdown () { with (| rt | { rt . spawn (async { loop { crate :: task :: yield_now () . await ; } }) ; rt . tick_max (1) ; rt . shutdown () ; }) } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_sender_closed_with_extra_subscribe",
                        "label": "broadcast_sender_closed_with_extra_subscribe",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_sender_closed_with_extra_subscribe () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let rx2 = tx . subscribe () ; let mut task = task :: spawn (tx . closed ()) ; assert_pending ! (task . poll ()) ; drop (rx) ; assert ! (! task . is_woken ()) ; assert_pending ! (task . poll ()) ; drop (rx2) ; assert ! (task . is_woken ()) ; let rx3 = tx . subscribe () ; assert_pending ! (task . poll ()) ; drop (rx3) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; let mut task2 = task :: spawn (tx . closed ()) ; assert_ready ! (task2 . poll ()) ; let rx4 = tx . subscribe () ; let mut task3 = task :: spawn (tx . closed ()) ; assert_pending ! (task3 . poll ()) ; drop (rx4) ; assert ! (task3 . is_woken ()) ; assert_ready ! (task3 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Rotator",
                        "label": "Rotator",
                        "kind": "Struct",
                        "signature": "struct Rotator",
                        "file_path": "tokio/src/macros/join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "assert_pending",
                        "label": "assert_pending",
                        "kind": "Function",
                        "signature": "fn fn assert_pending < T : std :: fmt :: Debug , F : Future < Output = T > > (f : F) -> std :: pin :: Pin < Box < F > > { let mut pinned = Box :: pin (f) ; assert_pending ! (pinned . as_mut () . poll (& mut Context :: from_waker (futures :: task :: noop_waker_ref ()))) ; pinned } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "echo_server",
                        "label": "echo_server",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn echo_server () { const ITER : usize = 1024 ; let (tx , rx) = oneshot :: channel () ; let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let msg = \"foo bar baz\" ; tokio :: spawn (async move { let mut stream = assert_ok ! (TcpStream :: connect (& addr) . await) ; for _ in 0 .. ITER { assert_ok ! (stream . write_all (msg . as_bytes ()) . await) ; let mut buf = [0 ; 11] ; assert_ok ! (stream . read_exact (& mut buf) . await) ; assert_eq ! (& buf [..] , msg . as_bytes ()) ; } assert_ok ! (tx . send (())) ; }) ; let (mut stream , _) = assert_ok ! (srv . accept () . await) ; let (mut rd , mut wr) = stream . split () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , (ITER * msg . len ()) as u64) ; assert_ok ! (rx . await) ; } . sig",
                        "file_path": "tokio/tests/tcp_echo.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_ready_ok",
                        "label": "assert_ready_ok",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_ready_ok () { let poll = ready_ok () ; assert_ready_ok ! (poll) ; assert_ready_ok ! (poll , \"some message\") ; assert_ready_ok ! (poll , \"{:?}\" , ()) ; assert_ready_ok ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_task",
                        "label": "cancel_task",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Cancels the task and store the appropriate error in the stage field.\"] fn cancel_task < T : Future , S : Schedule > (core : & Core < T , S >) { let res = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { core . drop_future_or_output () ; })) ; core . store_output (Err (panic_result_to_join_error (core . task_id , res))) ; } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ping",
                        "label": "ping",
                        "kind": "Function",
                        "signature": "fn async fn ping (socket : & mut UdpFramed < BytesCodec > , b_addr : SocketAddr) -> Result < () , io :: Error > { socket . send ((Bytes :: from (& b\"PING\" [..]) , b_addr)) . await ? ; for _ in 0 .. 4usize { let (bytes , addr) = socket . next () . map (| e | e . unwrap ()) . await ? ; println ! (\"[a] recv: {}\" , String :: from_utf8_lossy (& bytes)) ; socket . send ((Bytes :: from (& b\"PING\" [..]) , addr)) . await ? ; } Ok (()) } . sig",
                        "file_path": "examples/udp-codec.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_7144",
                        "label": "issue_7144",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn issue_7144 () { let mut threads = vec ! [] ; for _ in 0 .. 20 { threads . push (tokio :: spawn (test_one ())) ; } for thread in threads { thread . await . unwrap () ; } } . sig",
                        "file_path": "tokio/tests/process_issue_7144.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Spawner",
                        "label": "Spawner",
                        "kind": "Struct",
                        "signature": "struct Spawner",
                        "file_path": "tokio/src/runtime/blocking/pool.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "zero_capacity",
                        "label": "zero_capacity",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn zero_capacity () { broadcast :: channel :: < () > (0) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_recv_async",
                        "label": "blocking_recv_async",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] async fn blocking_recv_async () { let (_tx , mut rx) = mpsc :: channel :: < () > (1) ; let _ = rx . blocking_recv () ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "echo",
                        "label": "echo",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn echo () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = UnixDatagram :: bind (server_path . clone ()) ? ; tokio :: spawn (async move { let _ = echo_server (server_socket) . await ; }) ; { let socket = UnixDatagram :: bind (& client_path) . unwrap () ; socket . connect (server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let len = socket . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OsExtraData",
                        "label": "OsExtraData",
                        "kind": "Struct",
                        "signature": "struct OsExtraData",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "add_more_than_max_amount_permits1",
                        "label": "add_more_than_max_amount_permits1",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn add_more_than_max_amount_permits1 () { let s = tokio :: sync :: Semaphore :: new (1) ; s . add_permits (tokio :: sync :: Semaphore :: MAX_PERMITS) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_task_wakes_paused_runtime",
                        "label": "blocking_task_wakes_paused_runtime",
                        "kind": "Function",
                        "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; time :: timeout (Duration :: from_secs (15) , task :: spawn_blocking (| | thread :: sleep (Duration :: from_millis (1))) ,) . await . expect (\"timeout should not trigger\") . expect (\"blocking task should finish\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "net_types_are_unwind_safe",
                        "label": "net_types_are_unwind_safe",
                        "kind": "Function",
                        "signature": "fn # [test] fn net_types_are_unwind_safe () { is_unwind_safe :: < tokio :: net :: TcpListener > () ; is_unwind_safe :: < tokio :: net :: TcpSocket > () ; is_unwind_safe :: < tokio :: net :: TcpStream > () ; is_unwind_safe :: < tokio :: net :: UdpSocket > () ; } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_acquire_releases_permits",
                        "label": "cancel_acquire_releases_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_acquire_releases_permits () { let s = Semaphore :: new (10) ; s . try_acquire (4) . expect (\"uncontended try_acquire succeeds\") ; assert_eq ! (6 , s . available_permits ()) ; let mut acquire = task :: spawn (s . acquire (8)) ; assert_pending ! (acquire . poll ()) ; assert_eq ! (0 , s . available_permits ()) ; drop (acquire) ; assert_eq ! (6 , s . available_permits ()) ; assert_ok ! (s . try_acquire (6)) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mutex_debug",
                        "label": "mutex_debug",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn mutex_debug () { let s = \"data\" ; let m = Mutex :: new (s . to_string ()) ; assert_eq ! (format ! (\"{m:?}\") , r#\"Mutex { data: \"data\" }\"#) ; let _guard = m . lock () . await ; assert_eq ! (format ! (\"{m:?}\") , r#\"Mutex { data: <locked> }\"#) } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_v4",
                        "label": "connect_v4",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_v4 () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; assert ! (addr . is_ipv4 ()) ; let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { let (socket , addr) = assert_ok ! (srv . accept () . await) ; assert_eq ! (addr , assert_ok ! (socket . peer_addr ())) ; assert_ok ! (tx . send (socket)) ; }) ; let mine = assert_ok ! (TcpStream :: connect (& addr) . await) ; let theirs = assert_ok ! (rx . await) ; assert_eq ! (assert_ok ! (mine . local_addr ()) , assert_ok ! (theirs . peer_addr ())) ; assert_eq ! (assert_ok ! (theirs . local_addr ()) , assert_ok ! (mine . peer_addr ())) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_get_permit_no_senders",
                        "label": "downgrade_upgrade_get_permit_no_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn downgrade_upgrade_get_permit_no_senders () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx . clone () ; let _permit = tx . reserve_owned () . await . unwrap () ; let weak_tx = tx2 . downgrade () ; drop (tx2) ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "VecU8",
                        "label": "VecU8",
                        "kind": "Trait",
                        "signature": "trait VecU8",
                        "file_path": "tokio/src/io/util/vec_with_initialized.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Trailer",
                        "label": "Trailer",
                        "kind": "Struct",
                        "signature": "struct Trailer",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_timer",
                        "label": "drop_timer",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_timer () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_empty_when_all_messages_are_consumed",
                        "label": "test_rx_is_empty_when_all_messages_are_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_empty_when_all_messages_are_consumed () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } while rx . try_recv () . is_ok () { } assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_drop_notified_notify",
                        "label": "notified_drop_notified_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_drop_notified_notify () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; drop (notified1) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_until_pending",
                        "label": "write_until_pending",
                        "kind": "Function",
                        "signature": "fn fn write_until_pending (stream : & mut UnixStream) { let buf = vec ! [0u8 ; 1024 * 1024] ; loop { match stream . try_write (& buf) { Ok (_) => () , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AbortGuard",
                        "label": "AbortGuard",
                        "kind": "Struct",
                        "signature": "struct AbortGuard",
                        "file_path": "tokio-util/src/task/spawn_pinned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_reset_panic_caller",
                        "label": "delay_queue_reset_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_reset_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . reset (& key , Duration :: from_millis (MAX_DURATION_MS + 1)) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_different_futures",
                        "label": "test_different_futures",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_different_futures () { let fut = async move { 10 } ; assert_eq ! (Layout :: for_value (& fut) . size () , 1) ; let mut b = ReusableBoxFuture :: new (fut) ; assert_eq ! (b . get_pin () . now_or_never () , Some (10)) ; b . try_set (async move { 20 }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (20)) ; b . try_set (async move { 30 }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (30)) ; } . sig",
                        "file_path": "tokio-util/tests/reusable_box.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Write",
                        "label": "Write",
                        "kind": "Struct",
                        "signature": "struct Write",
                        "file_path": "tokio/src/io/uring/write.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "SignalInfo",
                        "label": "SignalInfo",
                        "kind": "Struct",
                        "signature": "struct SignalInfo",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Open",
                        "label": "Open",
                        "kind": "Struct",
                        "signature": "struct Open",
                        "file_path": "tokio/src/io/uring/open.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "resuming_time_when_not_frozen_panics",
                        "label": "resuming_time_when_not_frozen_panics",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn resuming_time_when_not_frozen_panics () { time :: pause () ; time :: resume () ; time :: resume () ; } . sig",
                        "file_path": "tokio/tests/test_clock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WeakUnboundedSender",
                        "label": "WeakUnboundedSender",
                        "kind": "Struct",
                        "signature": "struct WeakUnboundedSender",
                        "file_path": "tokio/src/sync/mpsc/unbounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pin_as_deref_mut",
                        "label": "pin_as_deref_mut",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Copy of [`std::pin::Pin::as_deref_mut`].\"] pub (crate) fn pin_as_deref_mut < P : DerefMut > (ptr : Pin < & mut Pin < P > >) -> Pin < & mut P :: Target > { unsafe { ptr . get_unchecked_mut () } . as_mut () } . sig",
                        "file_path": "tokio/src/util/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_curr_spawn_many_remote_busy",
                        "label": "rt_curr_spawn_many_remote_busy",
                        "kind": "Function",
                        "signature": "fn fn rt_curr_spawn_many_remote_busy (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; rt . spawn (async { fn iter () { tokio :: spawn (async { iter () }) ; } iter () }) ; c . bench_function (\"spawn_many_remote_busy\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interleave_then_enter",
                        "label": "interleave_then_enter",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (target_os = \"wasi\"))] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_then_enter () { let _ = std :: panic :: catch_unwind (| | { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter1) ; drop (enter2) ; }) ; let rt3 = rt () ; let _enter = rt3 . enter () ; } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "advance_once_with_timer",
                        "label": "advance_once_with_timer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_once_with_timer () { let mut sleep = task :: spawn (time :: sleep (Duration :: from_millis (1))) ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (1500)) . await ; assert ! (sleep . is_woken ()) ; assert_ready ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedSemaphorePermit",
                        "label": "OwnedSemaphorePermit",
                        "kind": "Struct",
                        "signature": "struct OwnedSemaphorePermit",
                        "file_path": "tokio/src/sync/semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn fn main () { let (tx , rx) = oneshot :: channel () ; let rt1 = Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; let rt2 = Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; rt1 . block_on (rt2 . wrap (async move { let listener = TcpListener :: bind (\"0.0.0.0:0\") . await . unwrap () ; println ! (\"addr: {:?}\" , listener . local_addr ()) ; tx . send (()) . unwrap () ; })) ; futures :: executor :: block_on (rx) . unwrap () ; } . sig",
                        "file_path": "examples/custom-executor-tokio-context.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "fits_256_all_in_chunks",
                        "label": "fits_256_all_in_chunks",
                        "kind": "Function",
                        "signature": "fn # [test] fn fits_256_all_in_chunks () { let (_ , mut local) = queue :: local () ; let mut tasks = (0 .. 256) . map (| _ | super :: unowned (async { }) . 0) . collect :: < Vec < _ > > () ; local . push_back (tasks . drain (.. 10)) ; local . push_back (tasks . drain (.. 100)) ; local . push_back (tasks . drain (.. 46)) ; local . push_back (tasks . drain (.. 100)) ; let mut i = 0 ; while local . pop () . is_some () { i += 1 ; } assert_eq ! (i , 256) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_token",
                        "label": "cancel_token",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_token () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; assert ! (! token . is_cancelled ()) ; let wait_fut = token . cancelled () ; pin ! (wait_fut) ; assert_eq ! (Poll :: Pending , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; let wait_fut_2 = token . cancelled () ; pin ! (wait_fut_2) ; token . cancel () ; assert_eq ! (wake_counter , 1) ; assert ! (token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , wait_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , wait_fut_2 . as_mut () . poll (& mut Context :: from_waker (& waker))) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_join",
                        "label": "empty_join",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [allow (clippy :: unit_cmp)] async fn empty_join () { assert_eq ! (tokio :: join ! () , ()) ; assert_eq ! (tokio :: join ! (biased ;) , ()) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JoinHandle",
                        "label": "JoinHandle",
                        "kind": "Struct",
                        "signature": "struct JoinHandle",
                        "file_path": "tokio/src/fs/mocks.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RwLock",
                        "label": "RwLock",
                        "kind": "Struct",
                        "signature": "struct RwLock",
                        "file_path": "tokio/src/sync/rwlock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Signal",
                        "label": "Signal",
                        "kind": "Struct",
                        "signature": "struct Signal",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "channel",
                        "label": "channel",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new one-shot channel for sending single values across asynchronous\"] # [doc = \" tasks.\"] # [doc = \"\"] # [doc = \" The function returns separate \\\"send\\\" and \\\"receive\\\" handles. The `Sender`\"] # [doc = \" handle is used by the producer to send the value. The `Receiver` handle is\"] # [doc = \" used by the consumer to receive the value.\"] # [doc = \"\"] # [doc = \" Each handle can be used on separate tasks.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \"\"] # [doc = \" tokio::spawn(async move {\"] # [doc = \"     if let Err(_) = tx.send(3) {\"] # [doc = \"         println!(\\\"the receiver dropped\\\");\"] # [doc = \"     }\"] # [doc = \" });\"] # [doc = \"\"] # [doc = \" match rx.await {\"] # [doc = \"     Ok(v) => println!(\\\"got = {:?}\\\", v),\"] # [doc = \"     Err(_) => println!(\\\"the sender dropped\\\"),\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] # [track_caller] pub fn channel < T > () -> (Sender < T > , Receiver < T >) { # [cfg (all (tokio_unstable , feature = \"tracing\"))] let resource_span = { let location = std :: panic :: Location :: caller () ; let resource_span = tracing :: trace_span ! (parent : None , \"runtime.resource\" , concrete_type = \"Sender|Receiver\" , kind = \"Sync\" , loc . file = location . file () , loc . line = location . line () , loc . col = location . column () ,) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , tx_dropped = false , tx_dropped . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , rx_dropped = false , rx_dropped . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , value_sent = false , value_sent . op = \"override\" ,) }) ; resource_span . in_scope (| | { tracing :: trace ! (target : \"runtime::resource::state_update\" , value_received = false , value_received . op = \"override\" ,) }) ; resource_span } ; let inner = Arc :: new (Inner { state : AtomicUsize :: new (State :: new () . as_usize ()) , value : UnsafeCell :: new (None) , tx_task : Task (UnsafeCell :: new (MaybeUninit :: uninit ())) , rx_task : Task (UnsafeCell :: new (MaybeUninit :: uninit ())) , }) ; let tx = Sender { inner : Some (inner . clone ()) , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span : resource_span . clone () , } ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let async_op_span = resource_span . in_scope (| | tracing :: trace_span ! (\"runtime.resource.async_op\" , source = \"Receiver::await\")) ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let async_op_poll_span = async_op_span . in_scope (| | tracing :: trace_span ! (\"runtime.resource.async_op.poll\")) ; let rx = Receiver { inner : Some (inner) , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span , # [cfg (all (tokio_unstable , feature = \"tracing\"))] async_op_span , # [cfg (all (tokio_unstable , feature = \"tracing\"))] async_op_poll_span , } ; (tx , rx) } . sig",
                        "file_path": "tokio/src/sync/oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge_unrelated_permits",
                        "label": "merge_unrelated_permits",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] # [should_panic] fn merge_unrelated_permits () { let sem1 = Arc :: new (Semaphore :: new (3)) ; let sem2 = Arc :: new (Semaphore :: new (3)) ; let mut p1 = sem1 . try_acquire () . unwrap () ; let p2 = sem2 . try_acquire () . unwrap () ; p1 . merge (p2) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_fut_with_cancellation_owned_token_test",
                        "label": "ready_fut_with_cancellation_owned_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn ready_fut_with_cancellation_owned_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let ready_fut = ready (()) ; let ready_with_token_fut = ready_fut . with_cancellation_token_owned (token) ; pin ! (ready_with_token_fut) ; let res = ready_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines",
                        "label": "lines",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn lines < R > (reader : R) -> Lines < R > where R : AsyncBufRead , { Lines { reader , buf : String :: new () , bytes : Vec :: new () , read : 0 , } } . sig",
                        "file_path": "tokio/src/io/util/lines.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Stack",
                        "label": "Stack",
                        "kind": "Trait",
                        "signature": "trait Stack",
                        "file_path": "tokio-util/src/time/wheel/stack.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Address",
                        "label": "Address",
                        "kind": "Struct",
                        "signature": "struct Address",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "stress_test",
                        "label": "stress_test",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn stress_test () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut join_handles = Vec :: new () ; for _ in 0 .. 1000 { let sem_clone = sem . clone () ; join_handles . push (tokio :: spawn (async move { let _p = sem_clone . acquire_owned () . await ; })) ; } for j in join_handles { j . await . unwrap () ; } let _p1 = sem . clone () . try_acquire_owned () . unwrap () ; let _p2 = sem . clone () . try_acquire_owned () . unwrap () ; let _p3 = sem . clone () . try_acquire_owned () . unwrap () ; let _p4 = sem . clone () . try_acquire_owned () . unwrap () ; let _p5 = sem . clone () . try_acquire_owned () . unwrap () ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_start_paused",
                        "label": "test_start_paused",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_start_paused () { let now = Instant :: now () ; for _ in 0 .. 5 { std :: thread :: sleep (Duration :: from_millis (1)) ; assert_eq ! (now , Instant :: now ()) ; } } . sig",
                        "file_path": "tokio/tests/rt_time_start_paused.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_attr_has_args",
                        "label": "test_attr_has_args",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (foo)] async fn test_attr_has_args () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_drop_upgrade",
                        "label": "downgrade_drop_upgrade",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_drop_upgrade () { let (tx , _rx) = broadcast :: channel :: < i32 > (1) ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_discard_repeat",
                        "label": "any_delimiter_decoder_discard_repeat",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_discard_repeat () { const MAX_LENGTH : usize = 1 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"aa\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"a\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "global_init",
                        "label": "global_init",
                        "kind": "Function",
                        "signature": "fn fn global_init () -> io :: Result < () > { static INIT : Once = Once :: new () ; let mut init = None ; INIT . call_once (| | unsafe { let rc = console :: SetConsoleCtrlHandler (Some (handler) , 1) ; let ret = if rc == 0 { Err (io :: Error :: last_os_error ()) } else { Ok (()) } ; init = Some (ret) ; }) ; init . unwrap_or_else (| | Ok (())) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BiasedRotator",
                        "label": "BiasedRotator",
                        "kind": "Struct",
                        "signature": "struct BiasedRotator",
                        "file_path": "tokio/src/macros/join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "no_t_bounds_buffer",
                        "label": "no_t_bounds_buffer",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn no_t_bounds_buffer () { struct NoImpls ; let (tx , mut rx) = mpsc :: channel (100) ; is_debug (& tx) ; is_debug (& rx) ; assert ! (tx . clone () . try_send (NoImpls) . is_ok ()) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SenderExt",
                        "label": "SenderExt",
                        "kind": "Trait",
                        "signature": "trait SenderExt",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "TaskIdGuard",
                        "label": "TaskIdGuard",
                        "kind": "Struct",
                        "signature": "struct TaskIdGuard",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_sleep",
                        "label": "test_sleep",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_sleep () { let deadline = Instant :: now () + Duration :: from_millis (100) ; block_on (async { sleep_until (deadline) . await ; }) ; } . sig",
                        "file_path": "tokio-test/tests/block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SimplexStream",
                        "label": "SimplexStream",
                        "kind": "Struct",
                        "signature": "struct SimplexStream",
                        "file_path": "tokio/src/io/util/mem.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_concurrent_contended",
                        "label": "read_concurrent_contended",
                        "kind": "Function",
                        "signature": "fn fn read_concurrent_contended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; async fn task (lock : Arc < RwLock < () > >) { let read = lock . read () . await ; let _read = black_box (read) ; } let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read_concurrent\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { let write = lock . write () . await ; tokio :: join ! { async move { drop (write) } , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , task (lock . clone ()) , } ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "two_await",
                        "label": "two_await",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn two_await () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: try_join ! (rx1 , rx2) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; tx1 . send (\"hello\") . unwrap () ; assert ! (join . is_woken ()) ; let res : Result < (& str , u32) , _ > = assert_ready ! (join . poll ()) ; assert_eq ! (Ok ((\"hello\" , 123)) , res) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "changing_tx_task",
                        "label": "changing_tx_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn changing_tx_task () { loom :: model (| | { let (mut tx , rx) = oneshot :: channel :: < i32 > () ; thread :: spawn (move | | { drop (rx) ; }) ; let tx = thread :: spawn (move | | { let t1 = block_on (OnClose :: new (& mut tx)) ; if t1 { None } else { Some (tx) } }) . join () . unwrap () ; if let Some (mut tx) = tx { block_on (OnClose :: new (& mut tx)) ; } }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal_panic_caller",
                        "label": "signal_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn signal_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let kind = SignalKind :: from_raw (- 1) ; let _ = signal (kind) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/signal_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from",
                        "label": "from",
                        "kind": "Function",
                        "signature": "fn # [test] fn from () { let cell = OnceCell :: from (2) ; assert_eq ! (* cell . get () . unwrap () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_acquire_one_unavailable",
                        "label": "poll_acquire_one_unavailable",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_acquire_one_unavailable () { let s = Semaphore :: new (1) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire_2 = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 0) ; assert ! (acquire_2 . is_woken ()) ; assert_ready_ok ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_multi_frame_multi_packet",
                        "label": "read_multi_frame_multi_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_multi_frame_multi_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , data (b\"\\x00\\x09abc\") , data (b\"defghi\") , data (b\"\\x00\\x00\\x00\\x0312\") , data (b\"3\\x00\\x00\\x00\\x0bhello world\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_not_enough",
                        "label": "poll_next_many_not_enough",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_not_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut buffer , 3)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "semaphore_poll_many",
                        "label": "semaphore_poll_many",
                        "kind": "Function",
                        "signature": "fn fn semaphore_poll_many (sem : & mut PollSemaphore , permits : u32 ,) -> tokio_test :: task :: Spawn < impl Future < Output = SemRet > + '_ > { let fut = std :: future :: poll_fn (move | cx | sem . poll_acquire_many (cx , permits)) ; tokio_test :: task :: spawn (fut) } . sig",
                        "file_path": "tokio-util/tests/poll_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_enable_after_poll",
                        "label": "test_enable_after_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_enable_after_poll () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; assert_pending ! (future . poll ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_v6",
                        "label": "connect_v6",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_v6 () { let srv = assert_ok ! (TcpListener :: bind (\"[::1]:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; assert ! (addr . is_ipv6 ()) ; let (tx , rx) = oneshot :: channel () ; tokio :: spawn (async move { let (socket , addr) = assert_ok ! (srv . accept () . await) ; assert_eq ! (addr , assert_ok ! (socket . peer_addr ())) ; assert_ok ! (tx . send (socket)) ; }) ; let mine = assert_ok ! (TcpStream :: connect (& addr) . await) ; let theirs = assert_ok ! (rx . await) ; assert_eq ! (assert_ok ! (mine . local_addr ()) , assert_ok ! (theirs . peer_addr ())) ; assert_eq ! (assert_ok ! (theirs . local_addr ()) , assert_ok ! (mine . peer_addr ())) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "f",
                        "label": "f",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn f () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_dead_code.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "build_child",
                        "label": "build_child",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn build_child (mut child : StdChild) -> io :: Result < SpawnedChild > { let stdin = child . stdin . take () . map (stdio) . transpose () ? ; let stdout = child . stdout . take () . map (stdio) . transpose () ? ; let stderr = child . stderr . take () . map (stdio) . transpose () ? ; Ok (SpawnedChild { child : Child { child , waiting : None , } , stdin , stdout , stderr , }) } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UringOpenOptions",
                        "label": "UringOpenOptions",
                        "kind": "Struct",
                        "signature": "struct UringOpenOptions",
                        "file_path": "tokio/src/fs/open_options/uring_open_options.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_shared_pending",
                        "label": "write_shared_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_shared_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_oob_data",
                        "label": "send_oob_data",
                        "kind": "Function",
                        "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] fn send_oob_data < S : AsRawFd > (stream : & S , data : & [u8]) -> io :: Result < usize > { unsafe { let res = libc :: send (stream . as_raw_fd () , data . as_ptr () . cast () , data . len () , libc :: MSG_OOB ,) ; if res == - 1 { Err (io :: Error :: last_os_error ()) } else { Ok (res as usize) } } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "YN",
                        "label": "YN",
                        "kind": "Struct",
                        "signature": "struct YN",
                        "file_path": "tokio/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "data",
                        "label": "data",
                        "kind": "Function",
                        "signature": "fn fn data (bytes : & [u8]) -> Poll < io :: Result < Op > > { Poll :: Ready (Ok (bytes . into ())) } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_drop1",
                        "label": "create_drop1",
                        "kind": "Function",
                        "signature": "fn # [test] fn create_drop1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (notified) ; handle . assert_not_dropped () ; drop (join) ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end_grows_capacity_if_unfit",
                        "label": "read_to_end_grows_capacity_if_unfit",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_to_end_grows_capacity_if_unfit () { let bytes = b\"the_vector_startingcap_will_be_smaller\" ; let mut mock = Builder :: new () . read (bytes) . build () ; let initial_capacity = bytes . len () - 4 ; let mut buf = Vec :: with_capacity (initial_capacity) ; AsyncReadExt :: read_to_end (& mut mock , & mut buf) . await . unwrap () ; assert_eq ! (buf . capacity () , initial_capacity * 4) ; } . sig",
                        "file_path": "tokio/tests/io_read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll",
                        "label": "poll",
                        "kind": "Function",
                        "signature": "fn unsafe fn poll < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . poll () ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn fn main () { } . sig",
                        "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_child_token_after_parent_was_cancelled",
                        "label": "create_child_token_after_parent_was_cancelled",
                        "kind": "Function",
                        "signature": "fn # [test] fn create_child_token_after_parent_was_cancelled () { for drop_child_first in [true , false] . iter () . cloned () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let child_token = token . child_token () ; assert ! (child_token . is_cancelled ()) ; { let child_fut = child_token . cancelled () ; pin ! (child_fut) ; let parent_fut = token . cancelled () ; pin ! (parent_fut) ; assert_eq ! (Poll :: Ready (()) , child_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; } if drop_child_first { drop (child_token) ; drop (token) ; } else { drop (token) ; drop (child_token) ; } } } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "external_buf_does_not_shrink",
                        "label": "external_buf_does_not_shrink",
                        "kind": "Function",
                        "signature": "fn # [test] fn external_buf_does_not_shrink () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& vec ! [0 ; INITIAL_CAPACITY * 2] [..]) ; let framed = Framed :: from_parts (parts) ; let FramedParts { read_buf , .. } = framed . into_parts () ; assert_eq ! (read_buf . capacity () , INITIAL_CAPACITY * 2) ; } . sig",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "EnterGuard",
                        "label": "EnterGuard",
                        "kind": "Struct",
                        "signature": "struct EnterGuard",
                        "file_path": "tokio/src/runtime/handle.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "multi_gated",
                        "label": "multi_gated",
                        "kind": "Function",
                        "signature": "fn async fn multi_gated () { struct Gate { waker : loom :: future :: AtomicWaker , count : AtomicUsize , } let gate = Arc :: new (Gate { waker : loom :: future :: AtomicWaker :: new () , count : AtomicUsize :: new (0) , }) ; { let gate = gate . clone () ; spawn (track (async move { for i in 1 .. 3 { gate . count . store (i , SeqCst) ; gate . waker . wake () ; } })) ; } poll_fn (move | cx | { gate . waker . register_by_ref (cx . waker ()) ; if gate . count . load (SeqCst) < 2 { Poll :: Pending } else { Poll :: Ready (()) } }) . await ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_after_recv",
                        "label": "close_after_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_after_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; tx . send (17) . unwrap () ; assert_eq ! (17 , rx . try_recv () . unwrap ()) ; rx . close () ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "header_lte_cache_line",
                        "label": "header_lte_cache_line",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn header_lte_cache_line () { assert ! (std :: mem :: size_of ::< Header > () <= 8 * std :: mem :: size_of ::<* const () > ()) ; } . sig",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_no_comma",
                        "label": "sync_one_lit_expr_no_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: select ! { foo = async { 1 } => foo } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_write",
                        "label": "try_read_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write (DATA) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; match reader . try_read (& mut read_data [i ..]) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "client_server",
                        "label": "client_server",
                        "kind": "Function",
                        "signature": "fn async fn client_server (tx : mpsc :: Sender < () >) { let server = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (server . local_addr ()) ; tokio :: spawn (async move { let (mut socket , _) = server . accept () . await . unwrap () ; socket . write_all (b\"hello\") . await . unwrap () ; }) ; let mut client = TcpStream :: connect (& addr) . await . unwrap () ; let mut buf = vec ! [] ; client . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf , b\"hello\") ; tx . send (()) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_capacity_recvs_after_drop_1",
                        "label": "single_capacity_recvs_after_drop_1",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_capacity_recvs_after_drop_1 () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; drop (tx) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_closed ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JobCountGuard",
                        "label": "JobCountGuard",
                        "kind": "Struct",
                        "signature": "struct JobCountGuard",
                        "file_path": "tokio-util/src/task/spawn_pinned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ShardGuard",
                        "label": "ShardGuard",
                        "kind": "Struct",
                        "signature": "struct ShardGuard",
                        "file_path": "tokio/src/util/sharded_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "panics_when_no_reactor",
                        "label": "panics_when_no_reactor",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] # [cfg_attr (miri , ignore)] fn panics_when_no_reactor () { let srv = TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let addr = srv . local_addr () . unwrap () ; block_on (TcpStream :: connect (& addr)) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/no_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_once_drop_test",
                        "label": "set_once_drop_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_once_drop_test () { loom :: model (| | { let set_once = Arc :: new (SetOnce :: new ()) ; let set_once_clone = Arc :: clone (& set_once) ; let drop_counter = DropCounter :: new () ; let counter_cl = drop_counter . clone () ; let thread = thread :: spawn (move | | set_once_clone . set (counter_cl) . is_ok ()) ; let foo = drop_counter . clone () ; let set = set_once . set (foo) . is_ok () ; let res = thread . join () . unwrap () ; drop (set_once) ; drop_counter . assert_num_drops (2) ; assert ! (res != set) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_notify_one_not_enabled",
                        "label": "test_notify_one_not_enabled",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_notify_one_not_enabled () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "parse_bool",
                        "label": "parse_bool",
                        "kind": "Function",
                        "signature": "fn fn parse_bool (bool : syn :: Lit , span : Span , field : & str) -> Result < bool , syn :: Error > { match bool { syn :: Lit :: Bool (b) => Ok (b . value) , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as bool.\") ,)) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf_put_slice_panic_caller",
                        "label": "read_buf_put_slice_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_buf_put_slice_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; let new_slice = [0x40_u8 , 0x41_u8] ; read_buf . put_slice (& new_slice) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "semaphore_poll",
                        "label": "semaphore_poll",
                        "kind": "Function",
                        "signature": "fn fn semaphore_poll (sem : & mut PollSemaphore ,) -> tokio_test :: task :: Spawn < impl Future < Output = SemRet > + '_ > { let fut = std :: future :: poll_fn (move | cx | sem . poll_acquire (cx)) ; tokio_test :: task :: spawn (fut) } . sig",
                        "file_path": "tokio-util/tests/poll_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_worker_threads_not_int",
                        "label": "test_worker_threads_not_int",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , worker_threads = \"foo\")] async fn test_worker_threads_not_int () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_thread_scheduler_timeout",
                        "label": "multi_thread_scheduler_timeout",
                        "kind": "Function",
                        "signature": "fn fn multi_thread_scheduler_timeout (c : & mut Criterion) { do_timeout_test (c , 8 , \"multi_thread_timeout-8\") ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_linger",
                        "label": "set_linger",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn set_linger () { let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let stream = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; assert_ok ! (stream . set_linger (Some (Duration :: from_secs (1)))) ; assert_eq ! (stream . linger () . unwrap () . unwrap () . as_secs () , 1) ; assert_ok ! (stream . set_linger (None)) ; assert ! (stream . linger () . unwrap () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Frame",
                        "label": "Frame",
                        "kind": "Struct",
                        "signature": "struct Frame",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "open_options_truncate",
                        "label": "open_options_truncate",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_options_truncate () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . truncate (true)) . contains (\"truncate: true\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "resume_panic_caller",
                        "label": "resume_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn resume_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { time :: resume () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RWFrames",
                        "label": "RWFrames",
                        "kind": "Struct",
                        "signature": "struct RWFrames",
                        "file_path": "tokio-util/src/codec/framed_impl.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "compile_fail_full",
                        "label": "compile_fail_full",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn compile_fail_full () { let t = trybuild :: TestCases :: new () ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/forward_args_and_output.rs\") ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/macros_main_return.rs\") ; # [cfg (feature = \"full\")] t . pass (\"tests/pass/macros_main_loop.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_invalid_input.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_dead_code.rs\") ; # [cfg (feature = \"full\")] t . compile_fail (\"tests/fail/macros_type_mismatch.rs\") ; # [cfg (all (feature = \"rt\" , not (feature = \"full\")))] t . compile_fail (\"tests/fail/macros_core_no_default.rs\") ; drop (t) ; } . sig",
                        "file_path": "tests-build/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt (start_paused : bool) -> crate :: runtime :: Runtime { crate :: runtime :: Builder :: new_current_thread () . enable_time () . start_paused (start_paused) . build () . unwrap () } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abort_send",
                        "label": "abort_send",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn abort_send () { let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; let send2 = send . get_ref () . cloned () . unwrap () ; for i in 1 ..= 3i32 { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (i) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; let mut send2_send = spawn (send2 . send (5)) ; assert_pending ! (send2_send . poll ()) ; assert ! (send . abort_send ()) ; assert ! (send2_send . is_woken ()) ; assert_ready_ok ! (send2_send . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 2) ; assert_eq ! (recv . recv () . await . unwrap () , 3) ; assert_eq ! (recv . recv () . await . unwrap () , 5) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "InstrumentedFuture",
                        "label": "InstrumentedFuture",
                        "kind": "Trait",
                        "signature": "trait InstrumentedFuture",
                        "file_path": "tokio/src/future/trace.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "read_multi_frame_across_packets",
                        "label": "read_multi_frame_across_packets",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_multi_frame_across_packets () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_acquire_many_permits",
                        "label": "can_acquire_many_permits",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn can_acquire_many_permits () { let sem = Arc :: new (Semaphore :: new (4)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; let permit1 = semaphore_poll (& mut poll_sem) . poll () ; assert ! (matches ! (permit1 , Poll :: Ready (Some (_)))) ; let permit2 = semaphore_poll_many (& mut poll_sem , 2) . poll () ; assert ! (matches ! (permit2 , Poll :: Ready (Some (_)))) ; assert_eq ! (sem . available_permits () , 1) ; drop (permit2) ; let mut permit4 = semaphore_poll_many (& mut poll_sem , 4) ; assert ! (permit4 . poll () . is_pending ()) ; drop (permit1) ; let permit4 = permit4 . poll () ; assert ! (matches ! (permit4 , Poll :: Ready (Some (_)))) ; assert_eq ! (sem . available_permits () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/poll_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored",
                        "label": "write_vectored",
                        "kind": "Function",
                        "signature": "fn async fn write_vectored < W > (writer : & mut W , bufs : & [IoSlice < '_ >]) -> io :: Result < usize > where W : AsyncWrite + Unpin , { let mut writer = Pin :: new (writer) ; future :: poll_fn (| cx | writer . as_mut () . poll_write_vectored (cx , bufs)) . await } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_immediately",
                        "label": "notify_immediately",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_immediately () { let tracker = TaskTracker :: new () ; tracker . close () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_ready ! (wait . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_detects_not_a_fifo",
                        "label": "open_detects_not_a_fifo",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn open_detects_not_a_fifo () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-fifo-tests\") . tempdir () . unwrap () ; let path = dir . path () . join (\"not_a_fifo\") ; File :: create (& path) ? ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& path)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let err = assert_err ! (pipe :: OpenOptions :: new () . open_sender (& path)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "finish_string_read",
                        "label": "finish_string_read",
                        "kind": "Function",
                        "signature": "fn # [doc = \" This handles the various failure cases and puts the string back into `output`.\"] # [doc = \"\"] # [doc = \" The `truncate_on_io_error` `bool` is necessary because `read_to_string` and `read_line`\"] # [doc = \" disagree on what should happen when an IO error occurs.\"] pub (super) fn finish_string_read (io_res : io :: Result < usize > , utf8_res : Result < String , FromUtf8Error > , read : usize , output : & mut String , truncate_on_io_error : bool ,) -> Poll < io :: Result < usize > > { match (io_res , utf8_res) { (Ok (num_bytes) , Ok (string)) => { debug_assert_eq ! (read , 0) ; * output = string ; Poll :: Ready (Ok (num_bytes)) } (Err (io_err) , Ok (string)) => { * output = string ; if truncate_on_io_error { let original_len = output . len () - read ; output . truncate (original_len) ; } Poll :: Ready (Err (io_err)) } (Ok (num_bytes) , Err (utf8_err)) => { debug_assert_eq ! (read , 0) ; put_back_original_data (output , utf8_err . into_bytes () , num_bytes) ; Poll :: Ready (Err (io :: Error :: new (io :: ErrorKind :: InvalidData , \"stream did not contain valid UTF-8\" ,))) } (Err (io_err) , Err (utf8_err)) => { put_back_original_data (output , utf8_err . into_bytes () , read) ; Poll :: Ready (Err (io_err)) } } } . sig",
                        "file_path": "tokio/src/io/util/read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_spawn_location_offset",
                        "label": "get_spawn_location_offset",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Compute the offset of the `&'static Location<'static>` field in `Cell<T, S>`\"] # [doc = \" using the `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] # [cfg (tokio_unstable)] const fn get_spawn_location_offset (header_size : usize , core_align : usize , scheduler_size : usize , id_align : usize , id_size : usize , spawn_location_align : usize ,) -> usize { let mut offset = get_id_offset (header_size , core_align , scheduler_size , id_align) ; offset += id_size ; let spawn_location_misalign = offset % spawn_location_align ; if spawn_location_misalign > 0 { offset += spawn_location_align - spawn_location_misalign ; } offset } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_unbounded_receiver_blocking_recv_many_panic_caller",
                        "label": "mpsc_unbounded_receiver_blocking_recv_many_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_unbounded_receiver_blocking_recv_many_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: unbounded_channel :: < u8 > () ; let mut vec = vec ! [] ; rt . block_on (async { let _ = rx . blocking_recv_many (& mut vec , 1) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_second_test_attr_rust_2015",
                        "label": "test_has_second_test_attr_rust_2015",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [core :: prelude :: rust_2015 :: test] async fn test_has_second_test_attr_rust_2015 () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Backtrace",
                        "label": "Backtrace",
                        "kind": "Struct",
                        "signature": "struct Backtrace",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "build_dir",
                        "label": "build_dir",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn build_dir () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") . join (\"bar\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: DirBuilder :: new () . recursive (true) . create (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; assert_err ! (fs :: DirBuilder :: new () . recursive (false) . create (new_dir_2) . await) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "simple_ref",
                        "label": "simple_ref",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn simple_ref () { let v = [1 , 2 , 3i32] ; let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; for vi in v . iter () { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (vi) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (* recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; drop (recv) ; send . send_item (& 42) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedTasks",
                        "label": "OwnedTasks",
                        "kind": "Struct",
                        "signature": "struct OwnedTasks",
                        "file_path": "tokio/src/runtime/task/list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "assert_ready_err",
                        "label": "assert_ready_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_ready_err () { let poll = ready_err () ; assert_ready_err ! (poll) ; assert_ready_err ! (poll , \"some message\") ; assert_ready_err ! (poll , \"{:?}\" , ()) ; assert_ready_err ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_waker_update",
                        "label": "test_waker_update",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_waker_update () { use futures :: task :: noop_waker ; use std :: future :: Future ; use std :: task :: Context ; let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; let noop = noop_waker () ; future . enter (| _ , fut | assert_pending ! (fut . poll (& mut Context :: from_waker (& noop)))) ; assert_pending ! (future . poll ()) ; notify . notify_one () ; assert ! (future . is_woken ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "memchr",
                        "label": "memchr",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (all (unix , feature = \"libc\")))] pub (crate) fn memchr (needle : u8 , haystack : & [u8]) -> Option < usize > { haystack . iter () . position (| val | needle == * val) } . sig",
                        "file_path": "tokio/src/util/memchr.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "anon_pipe_spawn_echo",
                        "label": "anon_pipe_spawn_echo",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn anon_pipe_spawn_echo () -> std :: io :: Result < () > { use tokio :: process :: Command ; const DATA : & str = \"this is some data to write to the pipe\" ; let (tx , mut rx) = pipe :: pipe () ? ; let status = Command :: new (\"echo\") . arg (\"-n\") . arg (DATA) . stdout (tx . into_blocking_fd () ?) . status () ; let mut buf = vec ! [0 ; DATA . len ()] ; rx . read_exact (& mut buf) . await ? ; assert_eq ! (String :: from_utf8 (buf) . unwrap () , DATA) ; let exit_code = status . await ? ; assert ! (exit_code . success ()) ; buf = Vec :: new () ; let total = assert_ok ! (rx . try_read (& mut buf)) ; assert_eq ! (total , 0) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_writable",
                        "label": "reset_writable",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_writable () { let (a , b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let mut guard = afd_a . writable () . await . unwrap () ; let mut bytes = 0 ; while let Ok (Ok (amt)) = guard . try_io (| _ | afd_a . get_ref () . write (& [0 ; 512] [..])) { bytes += amt ; } let writable = afd_a . writable () ; tokio :: pin ! (writable) ; tokio :: select ! { _ = writable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } drain (& b , bytes) ; let _ = writable . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tempfile",
                        "label": "tempfile",
                        "kind": "Function",
                        "signature": "fn fn tempfile () -> NamedTempFile { NamedTempFile :: new () . unwrap () } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_timeouts",
                        "label": "no_timeouts",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn no_timeouts () { let stream = stream :: iter (vec ! [1 , 3 , 5]) . then (maybe_sleep) . timeout (ms (100)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (5))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_multi_frame_one_packet_skip_none_adjusted",
                        "label": "read_single_multi_frame_one_packet_skip_none_adjusted",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_multi_frame_one_packet_skip_none_adjusted () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"xx\\x00\\x09abcdefghi\") ; d . extend_from_slice (b\"yy\\x00\\x03123\") ; d . extend_from_slice (b\"zz\\x00\\x0bhello world\") ; let io = length_delimited :: Builder :: new () . length_field_length (2) . length_field_offset (2) . num_skip (0) . length_adjustment (4) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"xx\\x00\\x09abcdefghi\") ; assert_next_eq ! (io , b\"yy\\x00\\x03123\") ; assert_next_eq ! (io , b\"zz\\x00\\x0bhello world\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_linger",
                        "label": "basic_linger",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_linger () { let addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (addr)) ; assert ! (srv . linger () . unwrap () . is_none ()) ; srv . set_linger (Some (Duration :: new (0 , 0))) . unwrap () ; assert_eq ! (srv . linger () . unwrap () , Some (Duration :: new (0 , 0))) ; } . sig",
                        "file_path": "tokio/tests/tcp_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_calls_park_before_scheduling_again",
                        "label": "yield_calls_park_before_scheduling_again",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_calls_park_before_scheduling_again () { let mut loom = loom :: model :: Builder :: default () ; loom . max_permutations = Some (1) ; loom . check (| | { let rt = mk_runtime () ; let jh = rt . spawn (async { let tid = loom :: thread :: current () . id () ; let park_count = park :: current_thread_park_count () ; crate :: task :: yield_now () . await ; if tid == loom :: thread :: current () . id () { let new_park_count = park :: current_thread_park_count () ; assert_eq ! (park_count + 1 , new_park_count) ; } }) ; rt . block_on (jh) . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread/yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn ctrl_c () -> io :: Result < Signal > { signal (SignalKind :: interrupt ()) } . sig",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_and_get",
                        "label": "set_and_get",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_and_get () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let _ = rt . spawn (async { ONCE . set (5) }) . await ; let value = ONCE . get () . unwrap () ; assert_eq ! (* value , 5) ; }) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U64Encoder",
                        "label": "U64Encoder",
                        "kind": "Struct",
                        "signature": "struct U64Encoder",
                        "file_path": "tokio-util/tests/framed_write.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "dropping_unbounded_tx",
                        "label": "dropping_unbounded_tx",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_unbounded_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; for _ in 0 .. 2 { let tx = tx . clone () ; thread :: spawn (move | | { drop (tx) ; }) ; } drop (tx) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_is_atomic",
                        "label": "notify_waiters_is_atomic",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks if a call to `notify_waiters` is observed as atomic when combined\"] # [doc = \" with a concurrent call to `notify_one`.\"] # [test] fn notify_waiters_is_atomic () { fn notify_waiters_is_atomic_variant (tested_fut_index : usize) { let notify = Arc :: new (Notify :: new ()) ; let mut futs = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | tokio_test :: task :: spawn (notify . notified ())) . collect :: < Vec < _ > > () ; for fut in & mut futs { assert_pending ! (fut . poll ()) ; } let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; block_on (async { futs . remove (tested_fut_index) . await ; let mut new_fut = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (new_fut . poll ()) ; notify . notify_one () ; assert_ready ! (new_fut . poll ()) ; }) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_is_atomic_variant (0)) ; loom :: model (| | notify_waiters_is_atomic_variant (32)) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "external_buf_grows_to_init",
                        "label": "external_buf_grows_to_init",
                        "kind": "Function",
                        "signature": "fn # [test] fn external_buf_grows_to_init () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42] [..]) ; let framed = Framed :: from_parts (parts) ; let FramedParts { read_buf , .. } = framed . into_parts () ; assert_eq ! (read_buf . capacity () , INITIAL_CAPACITY) ; } . sig",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending_buf_writer_inner_flushes",
                        "label": "maybe_pending_buf_writer_inner_flushes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer_inner_flushes () { let mut w = BufWriter :: with_capacity (3 , MaybePending :: new (Vec :: new ())) ; assert_eq ! (w . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (& w . get_ref () . inner , & []) ; w . flush () . await . unwrap () ; let w = w . into_inner () . inner ; assert_eq ! (w , [0 , 1]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reserve_many_zero",
                        "label": "reserve_many_zero",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn reserve_many_zero () { let (tx , rx) = mpsc :: channel :: < () > (1) ; assert ! (assert_ok ! (tx . reserve_many (0) . await) . next () . is_none ()) ; tx . send (()) . await . unwrap () ; assert ! (assert_ok ! (tx . reserve_many (0) . await) . next () . is_none ()) ; drop (rx) ; assert_err ! (tx . reserve_many (0) . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_poll",
                        "label": "driver_shutdown_wakes_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_poll () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (poll_readable (& afd_a))) ; assert_err ! (futures :: executor :: block_on (poll_writable (& afd_a))) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MaybePending",
                        "label": "MaybePending",
                        "kind": "Struct",
                        "signature": "struct MaybePending",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_local_from_guard_other_thread",
                        "label": "test_spawn_local_from_guard_other_thread",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic = \"Local tasks can only be spawned on a LocalRuntime from the thread the runtime was created on\"] # [cfg_attr (target_family = \"wasm\" , ignore)] fn test_spawn_local_from_guard_other_thread () { let (tx , rx) = std :: sync :: mpsc :: channel () ; std :: thread :: spawn (move | | { let rt = rt () ; let handle = rt . handle () . clone () ; tx . send (handle) . unwrap () ; }) ; let handle = rx . recv () . unwrap () ; let _guard = handle . enter () ; spawn_local (async { }) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_without_panic_3662",
                        "label": "test_abort_without_panic_3662",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a suspended task can be aborted inside of a current_thread\"] # [doc = \" executor without panicking as reported in issue #3662:\"] # [doc = \" <https://github.com/tokio-rs/tokio/issues/3662>.\"] # [test] fn test_abort_without_panic_3662 () { use std :: sync :: atomic :: { AtomicBool , Ordering } ; use std :: sync :: Arc ; struct DropCheck (Arc < AtomicBool >) ; impl Drop for DropCheck { fn drop (& mut self) { self . 0 . store (true , Ordering :: SeqCst) ; } } let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let drop_flag = Arc :: new (AtomicBool :: new (false)) ; let drop_check = DropCheck (drop_flag . clone ()) ; let j = tokio :: spawn (async move { let _drop_check = drop_check ; futures :: future :: pending :: < () > () . await ; }) ; let drop_flag2 = drop_flag . clone () ; let task = std :: thread :: spawn (move | | { assert ! (! drop_flag2 . load (Ordering :: SeqCst)) ; j . abort () ; j }) . join () . unwrap () ; let result = task . await ; assert ! (drop_flag . load (Ordering :: SeqCst)) ; assert ! (result . unwrap_err () . is_cancelled ()) ; let i = tokio :: spawn (async move { tokio :: task :: yield_now () . await ; }) ; i . await . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "buf_writer_inner_flushes",
                        "label": "buf_writer_inner_flushes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn buf_writer_inner_flushes () { let mut w = BufWriter :: with_capacity (3 , Vec :: new ()) ; assert_eq ! (w . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (* w . get_ref () , []) ; w . flush () . await . unwrap () ; let w = w . into_inner () ; assert_eq ! (w , [0 , 1]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_string",
                        "label": "read_to_string",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a future which will open a file for reading and read the entire\"] # [doc = \" contents into a string and return said string.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::read_to_string`][std].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \" [std]: fn@std::fs::read_to_string\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" let contents = fs::read_to_string(\\\"foo.txt\\\").await?;\"] # [doc = \" println!(\\\"foo.txt contains {} bytes\\\", contents.len());\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_to_string (path : impl AsRef < Path >) -> io :: Result < String > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read_to_string (path)) . await } . sig",
                        "file_path": "tokio/src/fs/read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_spawn_creates_span",
                        "label": "task_spawn_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_spawn_creates_span () { let task_span = expect :: span () . named (\"runtime.spawn\") . with_target (\"tokio::task\") ; let (subscriber , handle) = subscriber :: mock () . new_span (& task_span) . enter (& task_span) . exit (& task_span) . enter (& task_span) . exit (& task_span) . drop_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; tokio :: spawn (futures :: future :: ready (())) . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "full_chunk_with_timeout",
                        "label": "full_chunk_with_timeout",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn full_chunk_with_timeout () { let iter = vec ! [1 , 2] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [3] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (1)) . map (move | _ | n)) ; let iter = vec ! [4] . into_iter () ; let stream2 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (3)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chain (stream2) . chunks_timeout (3 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; } . sig",
                        "file_path": "tokio-stream/tests/chunks_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_buffer_limited",
                        "label": "send_recv_buffer_limited",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_buffer_limited () { let (tx , mut rx) = mpsc :: channel :: < i32 > (1) ; let p1 = assert_ok ! (tx . reserve () . await) ; p1 . send (1) ; let mut p2 = tokio_test :: task :: spawn (tx . reserve ()) ; assert_pending ! (p2 . poll ()) ; assert ! (rx . recv () . await . is_some ()) ; assert ! (p2 . is_woken ()) ; assert_err ! (tx . try_send (1337)) ; let permit = assert_ready_ok ! (p2 . poll ()) ; permit . send (2) ; assert ! (rx . recv () . await . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_poll_count_histogram",
                        "label": "worker_poll_count_histogram",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_poll_count_histogram () { const N : u64 = 5 ; let rts = [tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () , tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () ,] ; for rt in rts { let metrics = rt . metrics () ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) . await . unwrap () ; } }) ; drop (rt) ; let num_workers = metrics . num_workers () ; let num_buckets = metrics . poll_time_histogram_num_buckets () ; assert ! (metrics . poll_time_histogram_enabled ()) ; assert_eq ! (num_buckets , 3) ; let n = (0 .. num_workers) . flat_map (| i | (0 .. num_buckets) . map (move | j | (i , j))) . map (| (worker , bucket) | metrics . poll_time_histogram_bucket_count (worker , bucket)) . sum () ; assert_eq ! (N , n) ; } } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_mock_items",
                        "label": "test_stream_mock_items",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_stream_mock_items () { let mut stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; assert_eq ! (stream_mock . next () . await , Some (1)) ; assert_eq ! (stream_mock . next () . await , Some (2)) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
                        "file_path": "tokio-test/tests/stream_mock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dealloc",
                        "label": "dealloc",
                        "kind": "Function",
                        "signature": "fn unsafe fn dealloc < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . dealloc () ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_tasks_with_reference_cycle",
                        "label": "drop_tasks_with_reference_cycle",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_tasks_with_reference_cycle () { rt () . block_on (async { let (tx , mut rx) = mpsc :: channel (1) ; let barrier = Arc :: new (Barrier :: new (3)) ; let barrier_a = barrier . clone () ; let barrier_b = barrier . clone () ; let a = tokio :: spawn (async move { let b = rx . recv () . await . unwrap () ; futures :: future :: select (b , std :: future :: ready (())) . await ; barrier_a . wait () . await ; }) ; let b = tokio :: spawn (async move { futures :: future :: select (a , std :: future :: ready (())) . await ; barrier_b . wait () . await ; }) ; tx . send (b) . await . unwrap () ; barrier . wait () . await ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_set_block_on_panic_caller",
                        "label": "local_set_block_on_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_set_block_on_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let local = task :: LocalSet :: new () ; rt . block_on (async { local . block_on (& rt , future :: pending :: < () > ()) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "func_panic",
                        "label": "func_panic",
                        "kind": "Function",
                        "signature": "fn async fn func_panic () -> u32 { time :: sleep (Duration :: from_millis (1)) . await ; panic ! () ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PidfdReaper",
                        "label": "PidfdReaper",
                        "kind": "Struct",
                        "signature": "struct PidfdReaper",
                        "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "CoreStage",
                        "label": "CoreStage",
                        "kind": "Struct",
                        "signature": "struct CoreStage",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_empty_when_no_messages_were_sent",
                        "label": "test_rx_unbounded_is_empty_when_no_messages_were_sent",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_when_no_messages_were_sent () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnboundedStream",
                        "label": "UnboundedStream",
                        "kind": "Struct",
                        "signature": "struct UnboundedStream",
                        "file_path": "tokio/tests/support/mpsc_stream.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "fill_buf",
                        "label": "fill_buf",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn fill_buf < R > (reader : & mut R) -> FillBuf < '_ , R > where R : AsyncBufRead + ? Sized + Unpin , { FillBuf { reader : Some (reader) , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/fill_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_fail",
                        "label": "try_send_fail",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_send_fail () { let (tx , mut rx) = mpsc :: channel (1) ; tx . try_send (\"hello\") . unwrap () ; match assert_err ! (tx . try_send (\"fail\")) { TrySendError :: Full (..) => { } _ => panic ! () , } assert_eq ! (rx . recv () . await , Some (\"hello\")) ; assert_ok ! (tx . try_send (\"goodbye\")) ; drop (tx) ; assert_eq ! (rx . recv () . await , Some (\"goodbye\")) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "incomplete_read_followed_by_flush",
                        "label": "incomplete_read_followed_by_flush",
                        "kind": "Function",
                        "signature": "fn # [test] fn incomplete_read_followed_by_flush () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . in_sequence (& mut seq) . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "exhausted",
                        "label": "exhausted",
                        "kind": "Function",
                        "signature": "fn # [cold] # [allow (dead_code)] fn exhausted () -> ! { panic ! (\"failed to generate unique thread ID: bitspace exhausted\") } . sig",
                        "file_path": "tokio/src/runtime/thread_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "iter_values",
                        "label": "iter_values",
                        "kind": "Function",
                        "signature": "fn # [test] fn iter_values () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; let mut size_hints = map . values () . map (| s | s . size_hint () . 0) . collect :: < Vec < _ > > () ; size_hints . sort_unstable () ; assert_eq ! (& size_hints [..] , & [1 , 2 , 3]) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "acquire",
                        "label": "acquire",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; let p1 = sem . clone () . try_acquire_owned () . unwrap () ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire_owned () . await ; }) ; drop (p1) ; j . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "acquire_many",
                        "label": "acquire_many",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire_many () { let semaphore = Arc :: new (Semaphore :: new (42)) ; let permit32 = semaphore . clone () . try_acquire_many_owned (32) . unwrap () ; let (sender , receiver) = tokio :: sync :: oneshot :: channel () ; let join_handle = tokio :: spawn (async move { let _permit10 = semaphore . clone () . acquire_many_owned (10) . await . unwrap () ; sender . send (()) . unwrap () ; let _permit32 = semaphore . acquire_many_owned (32) . await . unwrap () ; }) ; receiver . await . unwrap () ; drop (permit32) ; join_handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_buffered_reader_seek_underflow",
                        "label": "test_buffered_reader_seek_underflow",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_buffered_reader_seek_underflow () { struct PositionReader { pos : u64 , } impl AsyncRead for PositionReader { fn poll_read (mut self : Pin < & mut Self > , _ : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { let b = buf . initialize_unfilled () ; let len = b . len () ; for x in b { * x = self . pos as u8 ; self . pos = self . pos . wrapping_add (1) ; } buf . advance (len) ; Poll :: Ready (Ok (())) } } impl AsyncSeek for PositionReader { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { match pos { SeekFrom :: Start (n) => { self . pos = n ; } SeekFrom :: Current (n) => { self . pos = self . pos . wrapping_add (n as u64) ; } SeekFrom :: End (n) => { self . pos = u64 :: MAX . wrapping_add (n as u64) ; } } Ok (()) } fn poll_complete (self : Pin < & mut Self > , _ : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { Poll :: Ready (Ok (self . pos)) } } let mut reader = BufReader :: with_capacity (5 , PositionReader { pos : 0 }) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1 , 2 , 3 , 4] [..]) ; assert_eq ! (reader . seek (SeekFrom :: End (- 5)) . await . unwrap () , u64 :: MAX - 5) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () . len () , 5) ; let expected = 9_223_372_036_854_775_802 ; assert_eq ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . unwrap () , expected) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () . len () , 5) ; assert_eq ! (reader . seek (SeekFrom :: Current (0)) . await . unwrap () , expected) ; assert_eq ! (reader . get_ref () . pos , expected) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Shared",
                        "label": "Shared",
                        "kind": "Struct",
                        "signature": "struct Shared",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "wake_by_ref",
                        "label": "wake_by_ref",
                        "kind": "Function",
                        "signature": "fn unsafe fn wake_by_ref (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.wake_by_ref\") ; let raw = RawTask :: from_raw (ptr) ; raw . wake_by_ref () ; } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "decrease_handle_refcount",
                        "label": "decrease_handle_refcount",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Decreases the reference count of handles.\"] # [doc = \"\"] # [doc = \" Once no handle is left, we can remove the node from the\"] # [doc = \" tree and connect its parent directly to its children.\"] pub (crate) fn decrease_handle_refcount (node : & Arc < TreeNode >) { let num_handles = { let mut locked_node = node . inner . lock () . unwrap () ; locked_node . num_handles -= 1 ; locked_node . num_handles } ; if num_handles == 0 { with_locked_node_and_parent (node , | mut node , parent | { match parent { Some (mut parent) => { move_children_to_parent (& mut node , & mut parent) ; remove_child (& mut parent , node) ; } None => { disconnect_children (& mut node) ; } } }) ; } } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_close_while_empty_bounded",
                        "label": "try_recv_close_while_empty_bounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_close_while_empty_bounded () { let (tx , mut rx) = mpsc :: channel :: < () > (5) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; drop (tx) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "disallow_block_in_place",
                        "label": "disallow_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Disallows blocking in the current runtime context until the guard is dropped.\"] pub (crate) fn disallow_block_in_place () -> DisallowBlockInPlaceGuard { let reset = CONTEXT . try_with (| c | { if let EnterRuntime :: Entered { allow_block_in_place : true , } = c . runtime . get () { c . runtime . set (EnterRuntime :: Entered { allow_block_in_place : false , }) ; true } else { false } }) ; DisallowBlockInPlaceGuard (reset . unwrap_or (false)) } . sig",
                        "file_path": "tokio/src/runtime/context/blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line_not_all_ready",
                        "label": "read_line_not_all_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_line_not_all_ready () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"ld\\nFizzBuz\") . read (b\"z\\n1\\n2\") . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"We say \" . to_string () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , \"Hello World\\n\" . len ()) ; assert_eq ! (line . as_str () , \"We say Hello World\\n\") ; line = \"I solve \" . to_string () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , \"FizzBuzz\\n\" . len ()) ; assert_eq ! (line . as_str () , \"I solve FizzBuzz\\n\") ; line . clear () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , 2) ; assert_eq ! (line . as_str () , \"1\\n\") ; line . clear () ; let bytes = read . read_line (& mut line) . await . unwrap () ; assert_eq ! (bytes , 1) ; assert_eq ! (line . as_str () , \"2\") ; } . sig",
                        "file_path": "tokio/tests/io_read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_to_recv_from",
                        "label": "send_to_recv_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_to_recv_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; sender . send_to (MSG , & receiver_addr) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (len , addr) = receiver . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_zero",
                        "label": "is_zero",
                        "kind": "Function",
                        "signature": "fn fn is_zero (dur : Duration) -> bool { dur == Duration :: from_millis (0) } . sig",
                        "file_path": "tokio-stream/src/stream_ext/throttle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "start_send_panics_when_acquiring",
                        "label": "start_send_panics_when_acquiring",
                        "kind": "Function",
                        "signature": "fn # [should_panic] # [test] fn start_send_panics_when_acquiring () { let (send , _) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; send . send_item (2) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_large_total_on_non_vectored",
                        "label": "write_vectored_large_total_on_non_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_large_total_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let io_vec = IoBufs :: new (& mut bufs) ; let mut w = BufWriter :: with_capacity (8 , MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 8) ; assert ! (w . buffer () == & msg [.. 8]) ; let io_vec = io_vec . advance (n) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 3) ; assert ! (w . get_ref () . data . as_slice () == & msg [.. 8]) ; assert ! (w . buffer () == & msg [8 ..]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unpack",
                        "label": "unpack",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Split the head value into the real head and the index a stealer is working\"] # [doc = \" on.\"] fn unpack (n : UnsignedLong) -> (UnsignedShort , UnsignedShort) { let real = n & UnsignedShort :: MAX as UnsignedLong ; let steal = n >> (mem :: size_of :: < UnsignedShort > () * 8) ; (steal as UnsignedShort , real as UnsignedShort) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire",
                        "label": "try_acquire",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p1 = sem . clone () . try_acquire_owned () ; assert ! (p1 . is_ok ()) ; let p2 = sem . clone () . try_acquire_owned () ; assert ! (p2 . is_err ()) ; } let p3 = sem . try_acquire_owned () ; assert ! (p3 . is_ok ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_in_fut",
                        "label": "drop_in_fut",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn drop_in_fut () { let s = \"hello\" . to_string () ; let res = tokio :: select ! { foo = async { let v = one () . await ; drop (s) ; v } => foo } ; assert_eq ! (res , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_calls_park_before_scheduling_again",
                        "label": "yield_calls_park_before_scheduling_again",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_calls_park_before_scheduling_again () { let mut loom = loom :: model :: Builder :: default () ; loom . max_permutations = Some (1) ; loom . check (| | { let rt = mk_runtime (2) ; let (tx , rx) = oneshot :: channel :: < () > () ; rt . spawn (async { let tid = loom :: thread :: current () . id () ; let park_count = park :: current_thread_park_count () ; crate :: task :: yield_now () . await ; if tid == loom :: thread :: current () . id () { let new_park_count = park :: current_thread_park_count () ; assert_eq ! (park_count + 1 , new_park_count) ; } tx . send (()) ; }) ; rx . recv () ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "permit_available_not_acquired_close",
                        "label": "permit_available_not_acquired_close",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn permit_available_not_acquired_close () { let (tx1 , mut rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx1 . clone () ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let mut permit2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (permit2 . poll ()) ; rx . close () ; drop (permit1) ; assert ! (permit2 . is_woken ()) ; drop (permit2) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "windows_net_types_are_unwind_safe",
                        "label": "windows_net_types_are_unwind_safe",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (windows)] fn windows_net_types_are_unwind_safe () { use tokio :: net :: windows :: named_pipe :: NamedPipeClient ; use tokio :: net :: windows :: named_pipe :: NamedPipeServer ; is_unwind_safe :: < NamedPipeClient > () ; is_unwind_safe :: < NamedPipeServer > () ; } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BroadcastStream",
                        "label": "BroadcastStream",
                        "kind": "Struct",
                        "signature": "struct BroadcastStream",
                        "file_path": "tokio-stream/src/wrappers/broadcast.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "validates_max_permits",
                        "label": "validates_max_permits",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn validates_max_permits () { Semaphore :: new (MAX_PERMITS + 1) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Handle",
                        "label": "Handle",
                        "kind": "Struct",
                        "signature": "struct Handle",
                        "file_path": "tokio-test/src/io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "recv_timeout",
                        "label": "recv_timeout",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] # [cfg (feature = \"full\")] async fn recv_timeout () { use tokio :: sync :: mpsc :: error :: SendTimeoutError :: { Closed , Timeout } ; use tokio :: time :: Duration ; let (tx , rx) = mpsc :: channel (5) ; assert_eq ! (tx . send_timeout (10 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (20 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (30 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (40 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (50 , Duration :: from_secs (1)) . await , Ok (())) ; assert_eq ! (tx . send_timeout (60 , Duration :: from_secs (1)) . await , Err (Timeout (60))) ; drop (rx) ; assert_eq ! (tx . send_timeout (70 , Duration :: from_secs (1)) . await , Err (Closed (70))) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge_unrelated_permits",
                        "label": "merge_unrelated_permits",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] # [should_panic] fn merge_unrelated_permits () { let sem1 = Arc :: new (Semaphore :: new (3)) ; let sem2 = Arc :: new (Semaphore :: new (3)) ; let mut p1 = sem1 . try_acquire_owned () . unwrap () ; let p2 = sem2 . try_acquire_owned () . unwrap () ; p1 . merge (p2) } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StreamExt",
                        "label": "StreamExt",
                        "kind": "Trait",
                        "signature": "trait StreamExt",
                        "file_path": "tokio-stream/src/stream_ext.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "write_error",
                        "label": "write_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_error () { let error = io :: Error :: new (io :: ErrorKind :: Other , \"cruel\") ; let mut mock = Builder :: new () . write (b\"hello \") . write_error (error) . write (b\"world!\") . build () ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; match mock . write_all (b\"whoa\") . await { Err (error) => { assert_eq ! (error . kind () , io :: ErrorKind :: Other) ; assert_eq ! (\"cruel\" , format ! (\"{error}\")) ; } Ok (_) => panic ! (\"error not received\") , } mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "log_histogram",
                        "label": "log_histogram",
                        "kind": "Function",
                        "signature": "fn # [test] fn log_histogram () { const N : u64 = 50 ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: builder () . max_value (Duration :: from_secs (60)) . min_value (Duration :: from_nanos (100)) . max_error (0.25) ,)) . build () . unwrap () ; let metrics = rt . metrics () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 119) ; rt . block_on (async { for _ in 0 .. N { tokio :: spawn (async { }) . await . unwrap () ; } }) ; drop (rt) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (0) , Duration :: from_nanos (0) .. Duration :: from_nanos (96)) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (1) , Duration :: from_nanos (96) .. Duration :: from_nanos (96 + 2_u64 . pow (4))) ; assert_eq ! (metrics . poll_time_histogram_bucket_range (118) . end , Duration :: from_nanos (u64 :: MAX)) ; let n = (0 .. metrics . num_workers ()) . flat_map (| i | (0 .. num_buckets) . map (move | j | (i , j))) . map (| (worker , bucket) | metrics . poll_time_histogram_bucket_count (worker , bucket)) . sum () ; assert_eq ! (N , n) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal_usr1",
                        "label": "signal_usr1",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn signal_usr1 () { let mut signal = assert_ok ! (signal (SignalKind :: user_defined1 ()) , \"failed to create signal\") ; send_signal (libc :: SIGUSR1) ; signal . recv () . await ; } . sig",
                        "file_path": "tokio/tests/signal_usr1.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JoinMapKeys",
                        "label": "JoinMapKeys",
                        "kind": "Struct",
                        "signature": "struct JoinMapKeys",
                        "file_path": "tokio-util/src/task/join_map.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "fill_buf_file",
                        "label": "fill_buf_file",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn fill_buf_file () { let file = NamedTempFile :: new () . unwrap () ; assert_ok ! (std :: fs :: write (file . path () , b\"hello\")) ; let file = assert_ok ! (File :: open (file . path ()) . await) ; let mut file = BufReader :: new (file) ; let mut contents = Vec :: new () ; loop { let consumed = { let buffer = assert_ok ! (file . fill_buf () . await) ; if buffer . is_empty () { break ; } contents . extend_from_slice (buffer) ; buffer . len () } ; file . consume (consumed) ; } assert_eq ! (contents , b\"hello\") ; } . sig",
                        "file_path": "tokio/tests/io_fill_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_nothing_yields_nothing",
                        "label": "write_nothing_yields_nothing",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_nothing_yields_nothing () { let io = FramedWrite :: new (mock ! () , LengthDelimitedCodec :: new ()) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . poll_flush (cx)) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { time :: pause () ; let stream = stream :: iter (1 ..= 4) . then (maybe_sleep) . timeout (ms (100)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (150)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (100)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (2))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (60)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (60)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; time :: advance (ms (120)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (4))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Expiration",
                        "label": "Expiration",
                        "kind": "Struct",
                        "signature": "struct Expiration",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "callbacks_fire_current_thread",
                        "label": "callbacks_fire_current_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn callbacks_fire_current_thread () { let poll_start_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_stop_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_start = poll_start_counter . clone () ; let poll_stop = poll_stop_counter . clone () ; let before_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let after_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let before_task_poll_callback_task_id_ref = Arc :: clone (& before_task_poll_callback_task_id) ; let after_task_poll_callback_task_id_ref = Arc :: clone (& after_task_poll_callback_task_id) ; let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . on_before_task_poll (move | task_meta | { before_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_start_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . on_after_task_poll (move | task_meta | { after_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_stop_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . build () . unwrap () ; let task = rt . spawn (async { yield_now () . await ; yield_now () . await ; yield_now () . await ; }) ; let spawned_task_id = task . id () ; let _ = rt . block_on (task) ; drop (rt) ; assert_eq ! (before_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (after_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (poll_start . load (std :: sync :: atomic :: Ordering :: Relaxed) , 4) ; assert_eq ! (poll_stop . load (std :: sync :: atomic :: Ordering :: Relaxed) , 4) ; } . sig",
                        "file_path": "tokio/tests/rt_poll_callbacks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "has_changed_errors_on_closed_channel_with_seen_value",
                        "label": "has_changed_errors_on_closed_channel_with_seen_value",
                        "kind": "Function",
                        "signature": "fn # [test] fn has_changed_errors_on_closed_channel_with_seen_value () { let (tx , rx) = watch :: channel (\"A\") ; drop (tx) ; rx . has_changed () . expect_err (\"`has_changed` returns an error if and only if channel is closed.\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_recv_is_cooperative",
                        "label": "receiver_recv_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_recv_is_cooperative () { let (tx , mut rx) = broadcast :: channel (8) ; tokio :: select ! { biased ; _ = async { loop { assert ! (tx . send (()) . is_ok ()) ; assert ! (rx . recv () . await . is_ok ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "declare_output_enum",
                        "label": "declare_output_enum",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn declare_output_enum (input : TokenStream) -> TokenStream { let branches = match input . into_iter () . next () { Some (TokenTree :: Group (group)) => group . stream () . into_iter () . count () , _ => panic ! (\"unexpected macro input\") , } ; let variants = (0 .. branches) . map (| num | Ident :: new (& format ! (\"_{num}\") , Span :: call_site ())) . collect :: < Vec < _ > > () ; let mask = Ident :: new (if branches <= 8 { \"u8\" } else if branches <= 16 { \"u16\" } else if branches <= 32 { \"u32\" } else if branches <= 64 { \"u64\" } else { panic ! (\"up to 64 branches supported\") ; } , Span :: call_site () ,) ; TokenStream :: from (quote ! { pub (super) enum Out <# (# variants) ,*> { # (# variants (# variants) ,) * Disabled , } pub (super) type Mask = # mask ; }) } . sig",
                        "file_path": "tokio-macros/src/select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_wrap",
                        "label": "broadcast_wrap",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_wrap () { loom :: model (| | { let (tx , mut rx1) = broadcast :: channel (2) ; let mut rx2 = tx . subscribe () ; let th1 = thread :: spawn (move | | { block_on (async { let mut num = 0 ; loop { match rx1 . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 3) ; }) ; }) ; let th2 = thread :: spawn (move | | { block_on (async { let mut num = 0 ; loop { match rx2 . recv () . await { Ok (_) => num += 1 , Err (Closed) => break , Err (Lagged (n)) => num += n as usize , } } assert_eq ! (num , 3) ; }) ; }) ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_ok ! (tx . send (\"three\")) ; drop (tx) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_read_from_existing_buf",
                        "label": "can_read_from_existing_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn can_read_from_existing_buf () { let mut parts = FramedParts :: new (DontReadIntoThis , U32Codec :: default ()) ; parts . read_buf = BytesMut :: from (& [0 , 0 , 0 , 42] [..]) ; let mut framed = Framed :: from_parts (parts) ; let num = assert_ok ! (framed . next () . await . unwrap ()) ; assert_eq ! (num , 42) ; assert_eq ! (framed . codec () . read_bytes , 4) ; } . sig",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "flush",
                        "label": "flush",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a future which will entirely flush an I/O object.\"] pub (super) fn flush < A > (a : & mut A) -> Flush < '_ , A > where A : AsyncWrite + Unpin + ? Sized , { Flush { a , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/flush.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_chained_spawn",
                        "label": "rt_multi_chained_spawn",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_chained_spawn (c : & mut Criterion) { const ITER : usize = 1_000 ; fn iter (done_tx : mpsc :: SyncSender < () > , n : usize) { if n == 0 { done_tx . send (()) . unwrap () ; } else { tokio :: spawn (async move { iter (done_tx , n - 1) ; }) ; } } c . bench_function (\"chained_spawn\" , | b | { let rt = rt () ; let (done_tx , done_rx) = mpsc :: sync_channel (1000) ; b . iter (move | | { let done_tx = done_tx . clone () ; rt . block_on (async { tokio :: spawn (async move { iter (done_tx , ITER) ; }) ; done_rx . recv () . unwrap () ; }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_thread_scheduler_timeout",
                        "label": "single_thread_scheduler_timeout",
                        "kind": "Function",
                        "signature": "fn fn single_thread_scheduler_timeout (c : & mut Criterion) { do_timeout_test (c , 1 , \"single_thread_timeout\") ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "level_range",
                        "label": "level_range",
                        "kind": "Function",
                        "signature": "fn fn level_range (level : usize) -> u64 { LEVEL_MULT as u64 * slot_range (level) } . sig",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_panic_at_maxpermits",
                        "label": "no_panic_at_maxpermits",
                        "kind": "Function",
                        "signature": "fn # [test] fn no_panic_at_maxpermits () { let _ = Semaphore :: new (Semaphore :: MAX_PERMITS) ; let s = Semaphore :: new (Semaphore :: MAX_PERMITS - 1) ; s . add_permits (1) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_mandatory_blocking_should_run_even_when_shutting_down_from_other_thread",
                        "label": "spawn_mandatory_blocking_should_run_even_when_shutting_down_from_other_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_mandatory_blocking_should_run_even_when_shutting_down_from_other_thread () { use crate :: runtime :: tests :: loom_oneshot ; loom :: model (| | { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; let handle = rt . handle () . clone () ; { loom :: thread :: spawn (move | | { drop (rt) ; }) ; } let _enter = handle . enter () ; let (tx , rx) = loom_oneshot :: channel () ; let handle = runtime :: spawn_mandatory_blocking (move | | { let _ = tx . send (()) ; }) ; if handle . is_some () { let () = rx . recv () ; } }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_at",
                        "label": "reset_at",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_at () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_at (Instant :: now () + Duration :: from_millis (40)) ; time :: advance (ms (40)) . await ; check_interval_poll ! (i , start , 441) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 741) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_close_gets_none_reserved",
                        "label": "recv_close_gets_none_reserved",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn recv_close_gets_none_reserved () { let (tx1 , mut rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx1 . clone () ; let permit1 = assert_ok ! (tx1 . reserve () . await) ; let mut permit2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (permit2 . poll ()) ; rx . close () ; assert ! (permit2 . is_woken ()) ; assert_ready_err ! (permit2 . poll ()) ; { let mut recv = tokio_test :: task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; permit1 . send (123) ; assert ! (recv . is_woken ()) ; let v = assert_ready ! (recv . poll ()) ; assert_eq ! (v , Some (123)) ; } assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sigrtnum_to_string",
                        "label": "sigrtnum_to_string",
                        "kind": "Function",
                        "signature": "fn fn sigrtnum_to_string (signum : i32) -> String { format ! (\"SIGRTMIN+{} (signal {})\" , signum - libc :: SIGRTMIN () , signum) } . sig",
                        "file_path": "tokio/tests/signal_realtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Empty",
                        "label": "Empty",
                        "kind": "Struct",
                        "signature": "struct Empty",
                        "file_path": "tokio-stream/src/empty.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_multi_frame_multi_packet_wait",
                        "label": "read_multi_frame_multi_packet_wait",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_multi_frame_multi_packet_wait () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09abc\") , Poll :: Pending , data (b\"defghi\") , Poll :: Pending , data (b\"\\x00\\x00\\x00\\x0312\") , Poll :: Pending , data (b\"3\\x00\\x00\\x00\\x0bhello world\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_next_pending ! (io) ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "proxy",
                        "label": "proxy",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn proxy () { struct BufferedWd { buf : BytesMut , writer : io :: DuplexStream , } impl AsyncWrite for BufferedWd { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { self . get_mut () . buf . extend_from_slice (buf) ; Poll :: Ready (Ok (buf . len ())) } fn poll_flush (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { let this = self . get_mut () ; while ! this . buf . is_empty () { let n = ready ! (Pin :: new (& mut this . writer) . poll_write (cx , & this . buf)) ? ; let _ = this . buf . split_to (n) ; } Pin :: new (& mut this . writer) . poll_flush (cx) } fn poll_shutdown (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . writer) . poll_shutdown (cx) } } let (rd , wd) = io :: duplex (1024) ; let mut rd = rd . take (1024) ; let mut wd = BufferedWd { buf : BytesMut :: new () , writer : wd , } ; assert_ok ! (wd . write_all (& [0x42 ; 512]) . await) ; assert_ok ! (wd . flush () . await) ; let n = assert_ok ! (io :: copy (& mut rd , & mut wd) . await) ; assert_eq ! (n , 1024) ; } . sig",
                        "file_path": "tokio/tests/io_copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_abort_handle2",
                        "label": "drop_abort_handle2",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_abort_handle2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_not_dropped () ; drop (join) ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf_advance_panic_caller",
                        "label": "read_buf_advance_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_buf_advance_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . advance (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AssertRefUnwindSafe",
                        "label": "AssertRefUnwindSafe",
                        "kind": "Trait",
                        "signature": "trait AssertRefUnwindSafe",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Lock",
                        "label": "Lock",
                        "kind": "Trait",
                        "signature": "trait Lock",
                        "file_path": "tokio/src/runtime/scheduler/lock.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "open_options_windows_attributes",
                        "label": "open_options_windows_attributes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_attributes () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . attributes (FileSystem :: FILE_ATTRIBUTE_HIDDEN)) . contains (\"attributes: 2,\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_in_waker_drop",
                        "label": "send_in_waker_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_in_waker_drop () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: task :: Context ; struct SendOnDrop (broadcast :: Sender < () >) ; impl Drop for SendOnDrop { fn drop (& mut self) { let _ = self . 0 . send (()) ; } } impl ArcWake for SendOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } let (tx , mut rx) = broadcast :: channel (16) ; let mut fut = Box :: pin (async { let _ = rx . recv () . await ; }) ; let waker = futures :: task :: waker (Arc :: new (SendOnDrop (tx))) ; let mut cx = Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; drop (waker) ; let mut cx = Context :: from_waker (futures :: task :: noop_waker_ref ()) ; let _ = fut . as_mut () . poll (& mut cx) ; let (tx , mut rx) = broadcast :: channel (16) ; let mut fut = Box :: pin (async { let _ = rx . recv () . await ; }) ; let waker = futures :: task :: waker (Arc :: new (SendOnDrop (tx . clone ()))) ; let mut cx = Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; drop (waker) ; let _ = tx . send (()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_dropping_all_senders",
                        "label": "test_rx_is_closed_when_dropping_all_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_dropping_all_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let another_tx = tx . clone () ; let task = tokio :: spawn (async move { drop (another_tx) ; }) ; drop (tx) ; let _ = task . await ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "usage",
                        "label": "usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn usage () { let iter = vec ! [1 , 2 , 3] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [4] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (3)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chunks_timeout (4 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_pending ! (chunk_stream . poll_next ()) ; time :: advance (Duration :: from_secs (2)) . await ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; } . sig",
                        "file_path": "tokio-stream/tests/chunks_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "next_many_zero",
                        "label": "next_many_zero",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_zero () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut vec ! [] , 0)) . poll (cx)) . await ; assert_eq ! (n , 0) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskTrackerToken",
                        "label": "TaskTrackerToken",
                        "kind": "Struct",
                        "signature": "struct TaskTrackerToken",
                        "file_path": "tokio-util/src/task/task_tracker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "convert_to_file",
                        "label": "convert_to_file",
                        "kind": "Function",
                        "signature": "fn fn convert_to_file (child_stdio : ChildStdio) -> io :: Result < StdFile > { let ChildStdio { raw , io } = child_stdio ; drop (io) ; Arc :: try_unwrap (raw) . or_else (| raw | duplicate_handle (& * raw)) } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_copied_sink_writer",
                        "label": "test_copied_sink_writer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_copied_sink_writer () -> Result < () , Error > { let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < Bytes > (1) ; let mut writer = SinkWriter :: new (CopyToBytes :: new (PollSender :: new (tx) . sink_map_err (| _ | io :: Error :: from (ErrorKind :: BrokenPipe)) ,)) ; let data : [u8 ; 4] = [1 , 2 , 3 , 4] ; let _ = writer . write (& data) . await ; assert_eq ! (data . to_vec () , rx . recv () . await . unwrap () . to_vec ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sink_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_shutdown",
                        "label": "test_join_queue_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_shutdown () { let mut queue = JoinQueue :: new () ; let mut senders = Vec :: new () ; for _ in 0 .. 5 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; queue . spawn (async move { let _ = rx . await ; }) ; } queue . shutdown () . await ; assert ! (queue . is_empty ()) ; while let Some (tx) = senders . pop () { assert ! (tx . is_closed ()) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink_file",
                        "label": "symlink_file",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new file symbolic link on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a file symbolic link pointing to the `original`\"] # [doc = \" path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::windows::fs::symlink_file`][std]\"] # [doc = \"\"] # [doc = \" [std]: https://doc.rust-lang.org/std/os/windows/fs/fn.symlink_file.html\"] pub async fn symlink_file (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: windows :: fs :: symlink_file (original , link)) . await } . sig",
                        "file_path": "tokio/src/fs/symlink_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yes_block_in_threaded_block_on",
                        "label": "yes_block_in_threaded_block_on",
                        "kind": "Function",
                        "signature": "fn # [test] fn yes_block_in_threaded_block_on () { let rt = runtime :: Runtime :: new () . unwrap () ; rt . block_on (async { task :: block_in_place (| | { }) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Semaphore",
                        "label": "Semaphore",
                        "kind": "Trait",
                        "signature": "trait Semaphore",
                        "file_path": "tokio/src/sync/mpsc/chan.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Defer",
                        "label": "Defer",
                        "kind": "Struct",
                        "signature": "struct Defer",
                        "file_path": "tokio/src/runtime/scheduler/defer.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_error",
                        "label": "read_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_error () { let error = io :: Error :: new (io :: ErrorKind :: Other , \"cruel\") ; let mut mock = Builder :: new () . read (b\"hello \") . read_error (error) . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; match mock . read (& mut buf) . await { Err (error) => { assert_eq ! (error . kind () , io :: ErrorKind :: Other) ; assert_eq ! (\"cruel\" , format ! (\"{error}\")) ; } Ok (_) => panic ! (\"error not received\") , } let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_now_external_executor_and_block_in_place",
                        "label": "yield_now_external_executor_and_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn yield_now_external_executor_and_block_in_place () { let j = tokio :: spawn (async { task :: block_in_place (| | futures :: executor :: block_on (task :: yield_now ())) ; }) ; j . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contended_concurrent_multi",
                        "label": "contended_concurrent_multi",
                        "kind": "Function",
                        "signature": "fn fn contended_concurrent_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (5)) ; g . bench_function (\"concurrent_multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_keys",
                        "label": "test_keys",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_keys () { use std :: collections :: HashSet ; let mut map = JoinMap :: new () ; assert_eq ! (map . len () , 0) ; map . spawn (1 , async { }) ; assert_eq ! (map . len () , 1) ; map . spawn (2 , async { }) ; assert_eq ! (map . len () , 2) ; let keys = map . keys () . collect :: < HashSet < & u32 > > () ; assert ! (keys . contains (& 1)) ; assert ! (keys . contains (& 2)) ; let _ = map . join_next () . await . unwrap () ; let _ = map . join_next () . await . unwrap () ; assert_eq ! (map . len () , 0) ; let keys = map . keys () . collect :: < HashSet < & u32 > > () ; assert ! (keys . is_empty ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal_with_handle",
                        "label": "signal_with_handle",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn signal_with_handle (kind : SignalKind , handle : & Handle ,) -> io :: Result < watch :: Receiver < () > > { signal_enable (kind , handle) ? ; Ok (globals () . register_listener (kind . 0 as EventId)) } . sig",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_error_bound",
                        "label": "mpsc_error_bound",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_error_bound () { use tokio :: sync :: mpsc :: error ; is_error :: < error :: SendError < () > > () ; is_error :: < error :: TrySendError < () > > () ; } . sig",
                        "file_path": "tokio/tests/sync_errors.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_budget_remaining",
                        "label": "test_has_budget_remaining",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_has_budget_remaining () { assert ! (has_budget_remaining ()) ; for _ in 0 .. BUDGET { consume_budget () . await ; } assert ! (! has_budget_remaining ()) ; } . sig",
                        "file_path": "tokio/tests/coop_budget.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending",
                        "label": "pending",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a stream that is never ready\"] # [doc = \"\"] # [doc = \" The returned stream is never ready. Attempting to call\"] # [doc = \" [`next()`](crate::StreamExt::next) will never complete. Use\"] # [doc = \" [`stream::empty()`](super::empty()) to obtain a stream that is\"] # [doc = \" immediately empty but returns no values.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Basic usage:\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     let mut never = stream::pending::<i32>();\"] # [doc = \"\"] # [doc = \"     // This will never complete\"] # [doc = \"     never.next().await;\"] # [doc = \"\"] # [doc = \"     unreachable!();\"] # [doc = \" }\"] # [doc = \" ```\"] pub const fn pending < T > () -> Pending < T > { Pending (PhantomData) } . sig",
                        "file_path": "tokio-stream/src/pending.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "collect_results_err",
                        "label": "collect_results_err",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn collect_results_err () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Result < String , & str > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (Ok (\"hello \")) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (Err (\"oh no\")) . unwrap () ; assert ! (fut . is_woken ()) ; let err = assert_ready_err ! (fut . poll ()) ; assert_eq ! (\"oh no\" , err) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "instant_now_panics",
                        "label": "instant_now_panics",
                        "kind": "Function",
                        "signature": "fn # [wasm_bindgen_test] # [should_panic] fn instant_now_panics () { let _ = tokio :: time :: Instant :: now () ; } . sig",
                        "file_path": "tokio/tests/time_wasm.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SpawnerMetrics",
                        "label": "SpawnerMetrics",
                        "kind": "Struct",
                        "signature": "struct SpawnerMetrics",
                        "file_path": "tokio/src/runtime/blocking/pool.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "poll_acquire_one_zero_permits",
                        "label": "poll_acquire_one_zero_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_acquire_one_zero_permits () { let s = Semaphore :: new (0) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire . poll ()) ; s . release (1) ; assert ! (acquire . is_woken ()) ; assert_ready_ok ! (acquire . poll ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_no_rx",
                        "label": "send_no_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_no_rx () { let (tx , _) = broadcast :: channel (16) ; assert_err ! (tx . send (\"hello\")) ; let mut rx = tx . subscribe () ; assert_ok ! (tx . send (\"world\")) ; let val = assert_recv ! (rx) ; assert_eq ! (\"world\" , val) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_sender_weak_count_when_downgraded",
                        "label": "unbounded_sender_weak_count_when_downgraded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn unbounded_sender_weak_count_when_downgraded () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ChildStdio",
                        "label": "ChildStdio",
                        "kind": "Struct",
                        "signature": "struct ChildStdio",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Pack",
                        "label": "Pack",
                        "kind": "Struct",
                        "signature": "struct Pack",
                        "file_path": "tokio/src/util/bit.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_read_write",
                        "label": "try_read_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_write () { const DATA : & [u8] = b\"this is some data to write to the socket\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; let (server , _) = listener . accept () . await . unwrap () ; let mut written = DATA . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await . unwrap () ; assert_eq ! (DATA . len () , client . try_write (DATA) . unwrap ()) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (DATA) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await . unwrap () ; match server . try_read (& mut read [i ..]) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } written . clear () ; client . writable () . await . unwrap () ; let data_bufs : Vec < _ > = DATA . chunks (10) . map (io :: IoSlice :: new) . collect () ; loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write_vectored (& data_bufs) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = vec ! [0 ; written . len ()] ; let mut i = 0 ; while i < read . len () { server . readable () . await . unwrap () ; let mut bufs : Vec < _ > = read [i ..] . chunks_mut (0x10000) . map (io :: IoSliceMut :: new) . collect () ; match server . try_read_vectored (& mut bufs) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await . unwrap () ; if ready . is_read_closed () { return ; } else { tokio :: task :: yield_now () . await ; } } } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_poll",
                        "label": "send_recv_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_recv_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; poll_fn (| cx | sender . poll_send (cx , MSG)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Alternate",
                        "label": "Alternate",
                        "kind": "Struct",
                        "signature": "struct Alternate",
                        "file_path": "tokio-stream/tests/stream_fuse.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "clone_waker",
                        "label": "clone_waker",
                        "kind": "Function",
                        "signature": "fn unsafe fn clone_waker (ptr : * const ()) -> RawWaker { let header = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (header , \"waker.clone\") ; header . as_ref () . state . ref_inc () ; raw_waker (header) } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_logoff",
                        "label": "ctrl_logoff",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_logoff () -> io :: Result < RxFuture > { new (console :: CTRL_LOGOFF_EVENT) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tcp_stream_from_std_panic_caller",
                        "label": "tcp_stream_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_stream_from_std_panic_caller () -> Result < () , Box < dyn Error > > { let std_listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let std_stream = std :: net :: TcpStream :: connect (std_listener . local_addr () . unwrap ()) . unwrap () ; std_stream . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = TcpStream :: from_std (std_stream) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "frame_does_not_fit",
                        "label": "frame_does_not_fit",
                        "kind": "Function",
                        "signature": "fn # [test] fn frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . max_frame_length (256) . new_codec () ; assert_eq ! (codec . max_frame_length () , 255) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lagging_receiver_recovers_after_wrap_closed_2",
                        "label": "lagging_receiver_recovers_after_wrap_closed_2",
                        "kind": "Function",
                        "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_closed_2 () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; assert_ok ! (tx . send (4)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_eq ! (assert_recv ! (rx) , 4) ; assert_closed ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_with_semicolon_without_return_type",
                        "label": "test_with_semicolon_without_return_type",
                        "kind": "Function",
                        "signature": "fn # [cfg (feature = \"full\")] # [tokio :: test] async fn test_with_semicolon_without_return_type () { # ! [deny (clippy :: semicolon_if_nothing_returned)] dbg ! (0) ; } . sig",
                        "file_path": "tests-build/tests/macros_clippy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf",
                        "label": "read_buf",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn read_buf < 'a , R , B > (reader : & 'a mut R , buf : & 'a mut B) -> ReadBuf < 'a , R , B > where R : AsyncRead + Unpin + ? Sized , B : BufMut + ? Sized , { ReadBuf { reader , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_acquire_many_unavailable",
                        "label": "poll_acquire_many_unavailable",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_acquire_many_unavailable () { let s = Semaphore :: new (5) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 4) ; let mut acquire_2 = task :: spawn (s . acquire (5)) ; assert_pending ! (acquire_2 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; let mut acquire_3 = task :: spawn (s . acquire (3)) ; assert_pending ! (acquire_3 . poll ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert_eq ! (s . available_permits () , 0) ; assert ! (acquire_2 . is_woken ()) ; assert_ready_ok ! (acquire_2 . poll ()) ; assert ! (! acquire_3 . is_woken ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (1) ; assert ! (! acquire_3 . is_woken ()) ; assert_eq ! (s . available_permits () , 0) ; s . release (2) ; assert ! (acquire_3 . is_woken ()) ; assert_ready_ok ! (acquire_3 . poll ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_steal_count",
                        "label": "worker_steal_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_steal_count () { for _ in 0 .. 10 { let rt = threaded_no_lifo () ; let metrics = rt . metrics () ; let successfully_spawned_stealable_task = rt . block_on (async { try_spawn_stealable_task () . await . is_ok () }) ; drop (rt) ; if successfully_spawned_stealable_task { let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_steal_count (i)) . sum () ; assert_eq ! (1 , n) ; return ; } } panic ! (\"exhausted every try to schedule the stealable task\") ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "io_driver_ready_count",
                        "label": "io_driver_ready_count",
                        "kind": "Function",
                        "signature": "fn # [cfg (any (target_os = \"linux\" , target_os = \"macos\"))] # [test] fn io_driver_ready_count () { let rt = current_thread () ; let metrics = rt . metrics () ; let stream = tokio :: net :: TcpStream :: connect (\"google.com:80\") ; let _stream = rt . block_on (async move { stream . await . unwrap () }) ; assert_eq ! (metrics . io_driver_ready_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_last_drop",
                        "label": "notified_multi_notify_last_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_last_drop () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; let mut notified3 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_last () ; drop (notified3) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified1 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_during_shutdown",
                        "label": "wake_during_shutdown",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Waking a runtime will attempt to push a task into a queue of notifications\"] # [doc = \" in the runtime, however the tasks in such a queue usually have a reference\"] # [doc = \" to the runtime itself. This means that if they are not properly removed at\"] # [doc = \" runtime shutdown, this will cause a memory leak.\"] # [doc = \"\"] # [doc = \" This test verifies that waking something during shutdown of a `LocalSet` does\"] # [doc = \" not result in tasks lingering in the queue once shutdown is complete. This\"] # [doc = \" is verified using loom's leak finder.\"] # [test] fn wake_during_shutdown () { loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let ls = LocalSet :: new () ; let (send , recv) = oneshot :: channel () ; ls . spawn_local (async move { let mut send = Some (send) ; let () = std :: future :: poll_fn (| cx | { if let Some (send) = send . take () { send . send (cx . waker () . clone ()) ; } Poll :: Pending }) . await ; }) ; let handle = loom :: thread :: spawn (move | | { let waker = recv . recv () ; waker . wake () ; }) ; ls . block_on (& rt , crate :: task :: yield_now ()) ; drop (ls) ; handle . join () . unwrap () ; drop (rt) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalRuntime",
                        "label": "LocalRuntime",
                        "kind": "Struct",
                        "signature": "struct LocalRuntime",
                        "file_path": "tokio/src/runtime/local_runtime/runtime.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_locked",
                        "label": "notify_locked",
                        "kind": "Function",
                        "signature": "fn fn notify_locked (waiters : & mut WaitList , state : & AtomicUsize , curr : usize , strategy : NotifyOneStrategy ,) -> Option < Waker > { match get_state (curr) { EMPTY | NOTIFIED => { let res = state . compare_exchange (curr , set_state (curr , NOTIFIED) , SeqCst , SeqCst) ; match res { Ok (_) => None , Err (actual) => { let actual_state = get_state (actual) ; assert ! (actual_state == EMPTY || actual_state == NOTIFIED) ; state . store (set_state (actual , NOTIFIED) , SeqCst) ; None } } } WAITING => { let waiter = match strategy { NotifyOneStrategy :: Fifo => waiters . pop_back () . unwrap () , NotifyOneStrategy :: Lifo => waiters . pop_front () . unwrap () , } ; let waiter = unsafe { waiter . as_ref () } ; let waker = unsafe { waiter . waker . with_mut (| waker | (* waker) . take ()) } ; waiter . notification . store_release (Notification :: One (strategy)) ; if waiters . is_empty () { state . store (set_state (curr , EMPTY) , SeqCst) ; } waker } _ => unreachable ! () , } } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_extra_poll",
                        "label": "no_extra_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn no_extra_poll () { use pin_project_lite :: pin_project ; use std :: pin :: Pin ; use std :: sync :: { atomic :: { AtomicUsize , Ordering :: SeqCst } , Arc , } ; use std :: task :: { Context , Poll } ; use tokio_stream :: { Stream , StreamExt } ; pin_project ! { struct TrackPolls < S > { npolls : Arc < AtomicUsize >, # [pin] s : S , } } impl < S > Stream for TrackPolls < S > where S : Stream , { type Item = S :: Item ; fn poll_next (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < Option < Self :: Item > > { let this = self . project () ; this . npolls . fetch_add (1 , SeqCst) ; this . s . poll_next (cx) } } let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream :: < () > () ; let rx = TrackPolls { npolls : Arc :: new (AtomicUsize :: new (0)) , s : rx , } ; let npolls = Arc :: clone (& rx . npolls) ; let rt = rt () ; let mut rx = Box :: pin (rx) ; rt . spawn (async move { while rx . next () . await . is_some () { } }) ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1) ; tx . send (()) . unwrap () ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1 + 2) ; drop (tx) ; rt . block_on (async { tokio :: task :: yield_now () . await ; }) ; assert_eq ! (npolls . load (SeqCst) , 1 + 2 + 1) ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_capacity_recvs",
                        "label": "single_capacity_recvs",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_capacity_recvs () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; assert_eq ! (assert_recv ! (rx) , 1) ; assert_empty ! (rx) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_local_queue_capacity",
                        "label": "test_local_queue_capacity",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_local_queue_capacity () { assert ! (LOCAL_QUEUE_CAPACITY - 1 <= u8 :: MAX as usize) ; } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_error",
                        "label": "is_error",
                        "kind": "Function",
                        "signature": "fn fn is_error < T : std :: error :: Error + Send + Sync > () { } . sig",
                        "file_path": "tokio/tests/sync_errors.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "convert_to_blocking_file",
                        "label": "convert_to_blocking_file",
                        "kind": "Function",
                        "signature": "fn fn convert_to_blocking_file (io : ChildStdio) -> io :: Result < File > { let mut fd = io . inner . into_inner () ? . fd ; set_nonblocking (& mut fd , false) ? ; Ok (fd) } . sig",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unconsumed_messages_are_dropped",
                        "label": "unconsumed_messages_are_dropped",
                        "kind": "Function",
                        "signature": "fn # [test] fn unconsumed_messages_are_dropped () { let msg = Arc :: new (()) ; let (tx , rx) = mpsc :: channel (100) ; tx . try_send (msg . clone ()) . unwrap () ; assert_eq ! (2 , Arc :: strong_count (& msg)) ; drop ((tx , rx)) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_unwind_safe",
                        "label": "is_unwind_safe",
                        "kind": "Function",
                        "signature": "fn fn is_unwind_safe < T : UnwindSafe + RefUnwindSafe > () { } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_mock_drop_without_consuming_all",
                        "label": "test_stream_mock_drop_without_consuming_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic (expected = \"StreamMock was dropped before all actions were consumed\")] async fn test_stream_mock_drop_without_consuming_all () { let stream_mock = StreamMockBuilder :: new () . next (1) . next (2) . build () ; drop (stream_mock) ; } . sig",
                        "file_path": "tokio-test/tests/stream_mock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "us",
                        "label": "us",
                        "kind": "Function",
                        "signature": "fn fn us (n : u64) -> Duration { Duration :: from_micros (n) } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadFrame",
                        "label": "ReadFrame",
                        "kind": "Struct",
                        "signature": "struct ReadFrame",
                        "file_path": "tokio-util/src/codec/framed_impl.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "bytes_decoder",
                        "label": "bytes_decoder",
                        "kind": "Function",
                        "signature": "fn # [test] fn bytes_decoder () { let mut codec = BytesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . put_slice (b\"abc\") ; assert_eq ! (\"abc\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"a\") ; assert_eq ! (\"a\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_drop2",
                        "label": "create_drop2",
                        "kind": "Function",
                        "signature": "fn # [test] fn create_drop2 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "file_debug_fmt",
                        "label": "file_debug_fmt",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (unix)] async fn file_debug_fmt () { let tempfile = tempfile () ; let file = File :: open (tempfile . path ()) . await . unwrap () ; assert_eq ! (& format ! (\"{file:?}\") [0 .. 33] , \"tokio::fs::File { std: File { fd:\") ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "DropCounter",
                        "label": "DropCounter",
                        "kind": "Struct",
                        "signature": "struct DropCounter",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "MultiThread",
                        "label": "MultiThread",
                        "kind": "Struct",
                        "signature": "struct MultiThread",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_notified_multi",
                        "label": "notify_notified_multi",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_notified_multi () { let notify = Notify :: new () ; notify . notify_one () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LengthDelimitedCodec",
                        "label": "LengthDelimitedCodec",
                        "kind": "Struct",
                        "signature": "struct LengthDelimitedCodec",
                        "file_path": "tokio-util/src/codec/length_delimited.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_many_and_send",
                        "label": "try_reserve_many_and_send",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_and_send () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { for permit in assert_ok ! (tx . try_reserve_many (i)) { permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_future_destructor_completion",
                        "label": "task_id_future_destructor_completion",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_future_destructor_completion () { struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Ready (()) } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; handle . await . unwrap () ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_closed_when_there_are_senders_and_buffer_filled",
                        "label": "test_rx_is_not_closed_when_there_are_senders_and_buffer_filled",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_senders_and_buffer_filled () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } assert ! (! rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_empty",
                        "label": "poll_next_many_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_empty () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut vec ! [] , 1)) . await ; assert_eq ! (n , 0) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tx_close_gets_none",
                        "label": "tx_close_gets_none",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn tx_close_gets_none () { let (_ , mut rx) = mpsc :: channel :: < i32 > (10) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rx_mark_changed",
                        "label": "rx_mark_changed",
                        "kind": "Function",
                        "signature": "fn # [test] fn rx_mark_changed () { let (tx , mut rx) = watch :: channel (\"one\") ; let mut rx2 = rx . clone () ; let mut rx3 = rx . clone () ; let mut rx4 = rx . clone () ; { rx . mark_changed () ; assert ! (rx . has_changed () . unwrap ()) ; let mut t = spawn (rx . changed ()) ; assert_ready_ok ! (t . poll ()) ; } { assert ! (! rx2 . has_changed () . unwrap ()) ; let mut t = spawn (rx2 . changed ()) ; assert_pending ! (t . poll ()) ; } { rx3 . mark_changed () ; assert_eq ! (* rx3 . borrow () , \"one\") ; assert ! (rx3 . has_changed () . unwrap ()) ; assert_eq ! (* rx3 . borrow_and_update () , \"one\") ; assert ! (! rx3 . has_changed () . unwrap ()) ; let mut t = spawn (rx3 . changed ()) ; assert_pending ! (t . poll ()) ; } { tx . send (\"two\") . unwrap () ; assert ! (rx4 . has_changed () . unwrap ()) ; assert_eq ! (* rx4 . borrow_and_update () , \"two\") ; rx4 . mark_changed () ; assert ! (rx4 . has_changed () . unwrap ()) ; assert_eq ! (* rx4 . borrow_and_update () , \"two\") } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duplicate_keys_drop",
                        "label": "duplicate_keys_drop",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (not (panic = \"unwind\") , ignore)] # [tokio :: test] async fn duplicate_keys_drop () { # [derive (Hash , Debug , PartialEq , Eq)] struct Key ; impl Drop for Key { fn drop (& mut self) { panic ! (\"drop called for key\") ; } } let (send , recv) = oneshot :: channel :: < () > () ; let mut map = JoinMap :: new () ; map . spawn (Key , async { recv . await . unwrap () }) ; let _ = std :: panic :: catch_unwind (AssertUnwindSafe (| | map . spawn (Key , async { }))) . unwrap_err () ; let (key , _) = map . join_next () . await . unwrap () ; std :: mem :: forget (key) ; assert ! (send . is_closed ()) ; assert ! (map . join_next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "missing_return_type",
                        "label": "missing_return_type",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn missing_return_type () { return Ok (()) ; } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_sender_after_successful_reserve",
                        "label": "close_sender_after_successful_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn close_sender_after_successful_reserve () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; drop (reserve) ; send . close () ; assert ! (send . is_closed ()) ; assert ! (! recv_task . is_woken ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_after_compact_poll",
                        "label": "remove_after_compact_poll",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: Does not seem to work with WASI\")] # [tokio :: test (start_paused = true)] # [cfg (panic = \"unwind\")] async fn remove_after_compact_poll () { let now = Instant :: now () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let foo_key = queue . insert_at (\"foo\" , now + ms (10)) ; queue . insert_at (\"bar\" , now + ms (20)) ; sleep (ms (10)) . await ; assert_eq ! (assert_ready_some ! (poll ! (queue)) . key () , foo_key) ; queue . compact () ; let panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . remove (& foo_key) ; })) ; assert ! (panic . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_worker_threads_and_current_thread",
                        "label": "test_worker_threads_and_current_thread",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\" , worker_threads = 4)] async fn test_worker_threads_and_current_thread () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all",
                        "label": "write_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_all () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { assert_eq ! (self . cnt , 0) ; let n = cmp :: min (4 , buf . len ()) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let mut buf = Cursor :: new (& b\"hello world\" [..]) ; assert_ok ! (wr . write_buf (& mut buf) . await) ; assert_eq ! (wr . buf , b\"hell\" [..]) ; assert_eq ! (wr . cnt , 1) ; assert_eq ! (buf . position () , 4) ; } . sig",
                        "file_path": "tokio/tests/io_write_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PollSenderFuture",
                        "label": "PollSenderFuture",
                        "kind": "Struct",
                        "signature": "struct PollSenderFuture",
                        "file_path": "tokio-util/src/sync/mpsc.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_barrier_creates_span",
                        "label": "test_barrier_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_barrier_creates_span () { let barrier_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::barrier\") ; let size_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"size\") . with_value (& 1_u64)) ; let arrived_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"arrived\") . with_value (& 0_i64)) ; let (subscriber , handle) = subscriber :: mock () . new_span (barrier_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& barrier_span) . event (size_event) . event (arrived_event) . exit (& barrier_span) . drop_span (& barrier_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Barrier :: new (1) ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "localset_in_thread_local",
                        "label": "localset_in_thread_local",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_in_thread_local () { thread_local ! { static LOCAL_SET : LocalSet = LocalSet :: new () ; } let (_tx , rx) = oneshot :: channel :: < () > () ; let handle = tokio :: runtime :: Handle :: current () ; std :: thread :: spawn (move | | { LOCAL_SET . with (| local_set | { handle . block_on (local_set . run_until (async move { let _ = rx . await ; })) }) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_future",
                        "label": "poll_future",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Polls the future. If the future completes, the output is written to the\"] # [doc = \" stage field.\"] fn poll_future < T : Future , S : Schedule > (core : & Core < T , S > , cx : Context < '_ >) -> Poll < () > { let output = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { struct Guard < 'a , T : Future , S : Schedule > { core : & 'a Core < T , S > , } impl < 'a , T : Future , S : Schedule > Drop for Guard < 'a , T , S > { fn drop (& mut self) { self . core . drop_future_or_output () ; } } let guard = Guard { core } ; let res = guard . core . poll (cx) ; mem :: forget (guard) ; res })) ; let output = match output { Ok (Poll :: Pending) => return Poll :: Pending , Ok (Poll :: Ready (output)) => Ok (output) , Err (panic) => Err (panic_to_error (& core . scheduler , core . task_id , panic)) , } ; let res = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { core . store_output (output) ; })) ; if res . is_err () { core . scheduler . unhandled_panic () ; } Poll :: Ready (()) } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mutable_borrowing_future_with_same_borrow_in_block_and_else",
                        "label": "mutable_borrowing_future_with_same_borrow_in_block_and_else",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn mutable_borrowing_future_with_same_borrow_in_block_and_else () { let mut value = 234 ; tokio :: select ! { _ = require_mutable (& mut value) => { } , _ = async_noop () => { value += 5 ; } , else => { value += 27 ; } , } assert ! (value >= 234) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_currently_pending_polls",
                        "label": "driver_shutdown_wakes_currently_pending_polls",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_currently_pending_polls () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; while afd_a . get_ref () . write (& [0 ; 512]) . is_ok () { } let readable = assert_pending (poll_readable (& afd_a)) ; let writable = assert_pending (poll_writable (& afd_a)) ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (readable)) ; assert_err ! (futures :: executor :: block_on (writable)) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from_file_sets_nonblock",
                        "label": "from_file_sets_nonblock",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_sets_nonblock () -> io :: Result < () > { let fifo = TempFifo :: new (\"sets_nonblock\") ? ; let _reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let _writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let rdonly = std :: fs :: OpenOptions :: new () . read (true) . open (& fifo) ? ; assert ! (! is_nonblocking (& rdonly) ?) ; let reader = pipe :: Receiver :: from_file (rdonly) ? ; assert ! (is_nonblocking (& reader) ?) ; let wronly = std :: fs :: OpenOptions :: new () . write (true) . open (& fifo) ? ; assert ! (! is_nonblocking (& wronly) ?) ; let writer = pipe :: Sender :: from_file (wronly) ? ; assert ! (is_nonblocking (& writer) ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lifo_slot_budget",
                        "label": "lifo_slot_budget",
                        "kind": "Function",
                        "signature": "fn # [test] fn lifo_slot_budget () { async fn my_fn () { spawn_another () ; } fn spawn_another () { tokio :: spawn (my_fn ()) ; } let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (1) . build () . unwrap () ; let (send , recv) = oneshot :: channel () ; rt . spawn (async move { tokio :: spawn (my_fn ()) ; let _ = send . send (()) ; }) ; let _ = rt . block_on (recv) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Instant",
                        "label": "Instant",
                        "kind": "Struct",
                        "signature": "struct Instant",
                        "file_path": "tokio/src/time/instant.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reset_past_sleep_before_turn",
                        "label": "reset_past_sleep_before_turn",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_past_sleep_before_turn () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; sleep . as_mut () . reset (now + ms (80)) ; sleep . await ; assert_elapsed ! (now , ms (80)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "clean_pattern_macro",
                        "label": "clean_pattern_macro",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn clean_pattern_macro (input : TokenStream) -> TokenStream { let mut input : syn :: Pat = match syn :: Pat :: parse_single . parse (input . clone ()) { Ok (it) => it , Err (_) => return input , } ; clean_pattern (& mut input) ; quote :: ToTokens :: into_token_stream (input) . into () } . sig",
                        "file_path": "tokio-macros/src/select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "compact_remove_empty",
                        "label": "compact_remove_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_remove_empty () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key1 = queue . insert_at (\"foo1\" , now + ms (10)) ; let key2 = queue . insert_at (\"foo2\" , now + ms (10)) ; queue . remove (& key1) ; queue . remove (& key2) ; queue . compact () ; assert_eq ! (queue . len () , 0) ; assert_eq ! (queue . capacity () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_abort_handle_clone",
                        "label": "drop_abort_handle_clone",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_abort_handle_clone () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; let abort_clone = abort . clone () ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_not_dropped () ; drop (abort_clone) ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "slice_assume_init",
                        "label": "slice_assume_init",
                        "kind": "Function",
                        "signature": "fn unsafe fn slice_assume_init (slice : & [MaybeUninit < u8 >]) -> & [u8] { & * (slice as * const [MaybeUninit < u8 >] as * const [u8]) } . sig",
                        "file_path": "tokio/src/io/read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wait_with_output_captures",
                        "label": "wait_with_output_captures",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn wait_with_output_captures () { let mut child = cat () . spawn () . unwrap () ; let mut stdin = child . stdin . take () . unwrap () ; let write_bytes = b\"1234\" ; let future = async { stdin . write_all (write_bytes) . await ? ; drop (stdin) ; let out = child . wait_with_output () ; out . await } ; let output = future . await . unwrap () ; assert ! (output . status . success ()) ; assert_eq ! (output . stdout , write_bytes) ; assert_eq ! (output . stderr . len () , 0) ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_trace_self",
                        "label": "task_trace_self",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_trace_self () { let log = Arc :: new (Mutex :: new (vec ! [])) ; let log2 = Arc :: new (Mutex :: new (vec ! [])) ; let mut good_line = vec ! [] ; let mut bad_line = vec ! [] ; PrettyFuture :: pretty (PrettyFuture :: pretty (async { bad_line . push (line ! () + 1) ; tokio :: task :: yield_now () . await ; bad_line . push (line ! () + 1) ; tokio :: time :: sleep (Duration :: from_millis (1)) . await ; for _ in 0 .. 100 { good_line . push (line ! () + 1) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; } } , log . clone () ,) , log2 . clone () ,) . await ; for line in good_line { let s = format ! (\"{}:{}:\" , file ! () , line) ; assert ! (log . lock () . unwrap () . iter () . any (| x | { eprintln ! (\"{x}\") ; format ! (\"{x}\") . contains (& s) })) ; } for line in bad_line { let s = format ! (\"{}:{}:\" , file ! () , line) ; assert ! (! log . lock () . unwrap () . iter () . any (| x | format ! (\"{x}\") . contains (& s))) ; } } . sig",
                        "file_path": "tokio/tests/task_trace_self.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiters_decoder_any_character",
                        "label": "any_delimiters_decoder_any_character",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiters_decoder_any_character () { let mut codec = AnyDelimiterCodec :: new (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec ()) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk 1,chunk 2;chunk 3\\n\\r\") ; assert_eq ! (\"chunk 1\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"chunk 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"chunk 3\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (\"\" , codec . decode (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (\"k\" , codec . decode_eof (buf) . unwrap () . unwrap ()) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BudgetDecrement",
                        "label": "BudgetDecrement",
                        "kind": "Struct",
                        "signature": "struct BudgetDecrement",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "accept_many",
                        "label": "accept_many",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn accept_many () { use std :: future :: { poll_fn , Future } ; use std :: sync :: atomic :: AtomicBool ; const N : usize = 50 ; let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let listener = Arc :: new (listener) ; let addr = listener . local_addr () . unwrap () ; let connected = Arc :: new (AtomicBool :: new (false)) ; let (pending_tx , mut pending_rx) = mpsc :: unbounded_channel () ; let (notified_tx , mut notified_rx) = mpsc :: unbounded_channel () ; for _ in 0 .. N { let listener = listener . clone () ; let connected = connected . clone () ; let pending_tx = pending_tx . clone () ; let notified_tx = notified_tx . clone () ; tokio :: spawn (async move { let accept = listener . accept () ; tokio :: pin ! (accept) ; let mut polled = false ; poll_fn (| cx | { if ! polled { polled = true ; assert ! (Pin :: new (& mut accept) . poll (cx) . is_pending ()) ; pending_tx . send (()) . unwrap () ; Poll :: Pending } else if connected . load (SeqCst) { notified_tx . send (()) . unwrap () ; Poll :: Ready (()) } else { Poll :: Pending } }) . await ; pending_tx . send (()) . unwrap () ; }) ; } for _ in 0 .. N { pending_rx . recv () . await . unwrap () ; } connected . store (true , SeqCst) ; let _sock = TcpStream :: connect (addr) . await . unwrap () ; for _ in 0 .. N { notified_rx . recv () . await . unwrap () ; } } . sig",
                        "file_path": "tokio/tests/tcp_accept.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bind_before_connect",
                        "label": "bind_before_connect",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn bind_before_connect () { let any_addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (any_addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (cli . bind (any_addr)) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
                        "file_path": "tokio/tests/tcp_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_sender_last",
                        "label": "close_sender_last",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn close_sender_last () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "expire_second_key_when_reset_to_expire_earlier",
                        "label": "expire_second_key_when_reset_to_expire_earlier",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn expire_second_key_when_reset_to_expire_earlier () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"one\" , now + ms (200)) ; let two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& two , now + ms (100)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RegistrationSet",
                        "label": "RegistrationSet",
                        "kind": "Struct",
                        "signature": "struct RegistrationSet",
                        "file_path": "tokio/src/runtime/io/registration_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AtomicWaker",
                        "label": "AtomicWaker",
                        "kind": "Struct",
                        "signature": "struct AtomicWaker",
                        "file_path": "tokio/src/sync/task/atomic_waker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "worker_park_unpark_count",
                        "label": "worker_park_unpark_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_park_unpark_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (rt . spawn (async { })) . unwrap () ; drop (rt) ; assert ! (2 <= metrics . worker_park_unpark_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; for _ in 0 .. 100 { if 1 <= metrics . worker_park_unpark_count (0) && 1 <= metrics . worker_park_unpark_count (1) { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert_eq ! (1 , metrics . worker_park_unpark_count (0)) ; assert_eq ! (1 , metrics . worker_park_unpark_count (1)) ; rt . block_on (rt . spawn (async { })) . unwrap () ; for _ in 0 .. 100 { if 3 <= metrics . worker_park_unpark_count (0) || 3 <= metrics . worker_park_unpark_count (1) { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert ! (3 <= metrics . worker_park_unpark_count (0) || 3 <= metrics . worker_park_unpark_count (1)) ; drop (rt) ; assert_eq ! (0 , metrics . worker_park_unpark_count (0) % 2) ; assert_eq ! (0 , metrics . worker_park_unpark_count (1) % 2) ; assert ! (4 <= metrics . worker_park_unpark_count (0) || 4 <= metrics . worker_park_unpark_count (1)) ; } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ToSocketAddrs",
                        "label": "ToSocketAddrs",
                        "kind": "Trait",
                        "signature": "trait ToSocketAddrs",
                        "file_path": "tokio/src/net/addr.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "try_recv",
                        "label": "try_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv () { loom :: model (| | { use crate :: sync :: { mpsc , Semaphore } ; use loom :: sync :: { Arc , Mutex } ; const PERMITS : usize = 2 ; const TASKS : usize = 2 ; const CYCLES : usize = 1 ; struct Context { sem : Arc < Semaphore > , tx : mpsc :: Sender < () > , rx : Mutex < mpsc :: Receiver < () > > , } fn run (ctx : & Context) { block_on (async { let permit = ctx . sem . acquire () . await ; assert_ok ! (ctx . rx . lock () . unwrap () . try_recv ()) ; crate :: task :: yield_now () . await ; assert_ok ! (ctx . tx . clone () . try_send (())) ; drop (permit) ; }) ; } let (tx , rx) = mpsc :: channel (PERMITS) ; let sem = Arc :: new (Semaphore :: new (PERMITS)) ; let ctx = Arc :: new (Context { sem , tx , rx : Mutex :: new (rx) , }) ; for _ in 0 .. PERMITS { assert_ok ! (ctx . tx . clone () . try_send (())) ; } let mut ths = Vec :: new () ; for _ in 0 .. TASKS { let ctx = ctx . clone () ; ths . push (thread :: spawn (move | | { run (& ctx) ; })) ; } run (& ctx) ; for th in ths { th . join () . unwrap () ; } }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_large_slice_on_vectored",
                        "label": "write_vectored_large_slice_on_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_large_slice_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& []) , IoSlice :: new (& msg [.. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: with_vectored_backend (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next",
                        "label": "poll_next",
                        "kind": "Function",
                        "signature": "fn fn poll_next < T , U > (first : Pin < & mut T > , second : Pin < & mut U > , cx : & mut Context < '_ > ,) -> Poll < Option < T :: Item > > where T : Stream , U : Stream < Item = T :: Item > , { let mut done = true ; match first . poll_next (cx) { Poll :: Ready (Some (val)) => return Poll :: Ready (Some (val)) , Poll :: Ready (None) => { } Poll :: Pending => done = false , } match second . poll_next (cx) { Poll :: Ready (Some (val)) => return Poll :: Ready (Some (val)) , Poll :: Ready (None) => { } Poll :: Pending => done = false , } if done { Poll :: Ready (None) } else { Poll :: Pending } } . sig",
                        "file_path": "tokio-stream/src/stream_ext/merge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all_buf",
                        "label": "write_all_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_all_buf () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { let n = cmp :: min (4 , buf . len ()) ; dbg ! (buf) ; let buf = & buf [0 .. n] ; self . cnt += 1 ; self . buf . extend (buf) ; Ok (buf . len ()) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\"world\")) ; assert_ok ! (wr . write_all_buf (& mut buf) . await) ; assert_eq ! (wr . buf , b\"helloworld\" [..]) ; assert_eq ! (wr . cnt , 4) ; assert ! (! buf . has_remaining ()) ; } . sig",
                        "file_path": "tokio/tests/io_write_all_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_rx",
                        "label": "close_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_rx () { let (tx , _) = oneshot :: channel () ; assert_err ! (tx . send (1)) ; let (tx , rx) = oneshot :: channel () ; let mut tx = task :: spawn (tx) ; assert_pending ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; drop (rx) ; assert ! (tx . is_woken ()) ; assert ! (tx . is_closed ()) ; assert_ready ! (tx . enter (| cx , mut tx | tx . poll_closed (cx))) ; assert_err ! (tx . into_inner () . send (1)) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_mutex_creates_span",
                        "label": "test_mutex_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_mutex_creates_span () { let mutex_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::mutex\") ; let locked_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"locked\") . with_value (& false)) ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (mutex_span . clone () . with_ancestry (expect :: is_explicit_root ())) . enter (& mutex_span) . event (locked_event) . new_span (batch_semaphore_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (& batch_semaphore_span) . event (batch_semaphore_permits_event) . exit (& batch_semaphore_span) . exit (& mutex_span) . drop_span (& mutex_span) . drop_span (& batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Mutex :: new (true) ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic",
                        "label": "basic",
                        "kind": "Function",
                        "signature": "fn fn basic () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_tx_capacity",
                        "label": "test_tx_capacity",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_tx_capacity () { let (tx , _rx) = mpsc :: channel :: < () > (10) ; assert_eq ! (tx . capacity () , 10) ; assert_eq ! (tx . max_capacity () , 10) ; let _permit = tx . reserve () . await . unwrap () ; assert_eq ! (tx . capacity () , 9) ; assert_eq ! (tx . max_capacity () , 10) ; tx . send (()) . await . unwrap () ; assert_eq ! (tx . capacity () , 8) ; assert_eq ! (tx . max_capacity () , 10) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shell",
                        "label": "shell",
                        "kind": "Function",
                        "signature": "fn # [test] fn shell () { assert_eq ! (1 , basic_main ()) ; assert_eq ! (bool :: default () , generic_fun ::< bool > ()) ; # [cfg (tokio_unstable)] assert_eq ! (1 , local_main ()) ; } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_fail_with_try_recv",
                        "label": "try_send_fail_with_try_recv",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_send_fail_with_try_recv () { let (tx , mut rx) = mpsc :: channel (1) ; tx . try_send (\"hello\") . unwrap () ; match assert_err ! (tx . try_send (\"fail\")) { TrySendError :: Full (..) => { } _ => panic ! () , } assert_eq ! (rx . try_recv () , Ok (\"hello\")) ; assert_ok ! (tx . try_send (\"goodbye\")) ; drop (tx) ; assert_eq ! (rx . try_recv () , Ok (\"goodbye\")) ; assert_eq ! (rx . try_recv () , Err (TryRecvError :: Disconnected)) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_and_wait",
                        "label": "set_and_wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn set_and_wait () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; tokio :: spawn (async { ONCE . set (5) }) ; let value = ONCE . wait () . await ; assert_eq ! (* value , 5) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TransitionToJoinHandleDrop",
                        "label": "TransitionToJoinHandleDrop",
                        "kind": "Struct",
                        "signature": "struct TransitionToJoinHandleDrop",
                        "file_path": "tokio/src/runtime/task/state.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "seek",
                        "label": "seek",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn seek < S > (seek : & mut S , pos : SeekFrom) -> Seek < '_ , S > where S : AsyncSeek + ? Sized + Unpin , { Seek { seek , pos : Some (pos) , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/seek.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Inner",
                        "label": "Inner",
                        "kind": "Struct",
                        "signature": "struct Inner",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_sender_strong_and_weak_conut",
                        "label": "unbounded_sender_strong_and_weak_conut",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_and_weak_conut () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval_doesnt_panic_max_duration_when_polling",
                        "label": "interval_doesnt_panic_max_duration_when_polling",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn interval_doesnt_panic_max_duration_when_polling () { let mut timer = task :: spawn (time :: interval (Duration :: MAX)) ; assert_ready ! (timer . enter (| cx , mut timer | timer . poll_tick (cx))) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_error_display",
                        "label": "test_join_error_display",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a `JoinError` with a panic payload prints the expected text.\"] # [test] # [cfg (panic = \"unwind\")] fn test_join_error_display () { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let join_err = tokio :: spawn (async move { let value = 1234 ; panic ! (\"Format-args payload: {value}\") }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked with message \\\"Format-args payload: 1234\\\"\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { panic ! (\"Const payload\") }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked with message \\\"Const payload\\\"\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { std :: panic :: panic_any (1234i32) }) . await . unwrap_err () ; let join_err_str = join_err . to_string () ; assert ! (join_err_str . starts_with (\"task \") && join_err_str . ends_with (\" panicked\") , \"Unexpected join_err_str {join_err_str:?}\") ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_bounded",
                        "label": "contention_bounded",
                        "kind": "Function",
                        "signature": "fn fn contention_bounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_with_select",
                        "label": "join_with_select",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (not (feature = \"rt-multi-thread\") , ignore = \"WASI: std::thread::spawn not supported\")] # [test] fn join_with_select () { block_on (async { let (tx1 , mut rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , mut rx2) = oneshot :: channel :: < i32 > () ; thread :: spawn (move | | { tx1 . send (123) . unwrap () ; tx2 . send (456) . unwrap () ; }) ; let mut a = None ; let mut b = None ; while a . is_none () || b . is_none () { tokio :: select ! { v1 = (& mut rx1) , if a . is_none () => a = Some (v1 . unwrap ()) , v2 = (& mut rx2) , if b . is_none () => b = Some (v2 . unwrap ()) , } } let (a , b) = (a . unwrap () , b . unwrap ()) ; assert_eq ! (a , 123) ; assert_eq ! (b , 456) ; }) ; } . sig",
                        "file_path": "tests-integration/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CtrlLogoff",
                        "label": "CtrlLogoff",
                        "kind": "Struct",
                        "signature": "struct CtrlLogoff",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "bounds",
                        "label": "bounds",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_send < T : Send > () { } fn check_sync < T : Sync > () { } fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } check_send :: < RwLock < u32 > > () ; check_sync :: < RwLock < u32 > > () ; check_unpin :: < RwLock < u32 > > () ; check_send :: < RwLockReadGuard < '_ , u32 > > () ; check_sync :: < RwLockReadGuard < '_ , u32 > > () ; check_unpin :: < RwLockReadGuard < '_ , u32 > > () ; check_send :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_sync :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_unpin :: < OwnedRwLockReadGuard < u32 , i32 > > () ; check_send :: < RwLockWriteGuard < '_ , u32 > > () ; check_sync :: < RwLockWriteGuard < '_ , u32 > > () ; check_unpin :: < RwLockWriteGuard < '_ , u32 > > () ; check_send :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_sync :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_unpin :: < RwLockMappedWriteGuard < '_ , u32 > > () ; check_send :: < OwnedRwLockWriteGuard < u32 > > () ; check_sync :: < OwnedRwLockWriteGuard < u32 > > () ; check_unpin :: < OwnedRwLockWriteGuard < u32 > > () ; check_send :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; check_sync :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; check_unpin :: < OwnedRwLockMappedWriteGuard < u32 , i32 > > () ; let rwlock = Arc :: new (RwLock :: new (0)) ; check_send_sync_val (rwlock . read ()) ; check_send_sync_val (Arc :: clone (& rwlock) . read_owned ()) ; check_send_sync_val (rwlock . write ()) ; check_send_sync_val (Arc :: clone (& rwlock) . write_owned ()) ; } . sig",
                        "file_path": "tokio/src/sync/rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "watch_error_bound",
                        "label": "watch_error_bound",
                        "kind": "Function",
                        "signature": "fn # [test] fn watch_error_bound () { use tokio :: sync :: watch :: error ; is_error :: < error :: SendError < () > > () ; } . sig",
                        "file_path": "tokio/tests/sync_errors.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delayed_sleep_wrapping_level_0",
                        "label": "delayed_sleep_wrapping_level_0",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn delayed_sleep_wrapping_level_0 () { time :: pause () ; time :: sleep (ms (5)) . await ; let now = Instant :: now () ; time :: sleep_until (now + ms (60)) . await ; assert_elapsed ! (now , ms (60)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Id",
                        "label": "Id",
                        "kind": "Struct",
                        "signature": "struct Id",
                        "file_path": "tokio/src/runtime/task/id.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "TimeSource",
                        "label": "TimeSource",
                        "kind": "Struct",
                        "signature": "struct TimeSource",
                        "file_path": "tokio/src/runtime/time/source.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "worker_local_schedule_count",
                        "label": "worker_local_schedule_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_local_schedule_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { }) . await . unwrap () ; }) ; drop (rt) ; assert_eq ! (1 , metrics . worker_local_schedule_count (0)) ; assert_eq ! (0 , metrics . remote_schedule_count ()) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { tokio :: spawn (async { }) . await . unwrap () ; }) . await . unwrap () ; }) ; drop (rt) ; let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_local_schedule_count (i)) . sum () ; assert_eq ! (2 , n) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "offset",
                        "label": "offset",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns the offset into the block referenced by `slot_index`.\"] # [inline (always)] pub (crate) fn offset (slot_index : usize) -> usize { SLOT_MASK & slot_index } . sig",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line_invalid_utf8",
                        "label": "read_line_invalid_utf8",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_line_invalid_utf8 () { let mock = Builder :: new () . read (b\"Hello Wor\\xffld.\\n\") . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: InvalidData) ; assert_eq ! (err . to_string () , \"stream did not contain valid UTF-8\") ; assert_eq ! (line . as_str () , \"Foo\") ; } . sig",
                        "file_path": "tokio/tests/io_read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_waker_update",
                        "label": "test_waker_update",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_waker_update () { use futures :: task :: noop_waker ; use std :: future :: Future ; use std :: task :: Context ; let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; let noop = noop_waker () ; future . enter (| _ , fut | assert_pending ! (fut . poll (& mut Context :: from_waker (& noop)))) ; assert_pending ! (future . poll ()) ; notify . notify_one () ; assert ! (future . is_woken ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "replace",
                        "label": "replace",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn replace () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let rx1 = Box :: pin (rx1) ; let rx2 = Box :: pin (rx2) ; assert ! (map . insert (\"foo\" , rx1) . is_none ()) ; assert_pending ! (map . poll_next ()) ; let _rx1 = map . insert (\"foo\" , rx2) . unwrap () ; assert_pending ! (map . poll_next ()) ; tx1 . send (1) . unwrap () ; assert_pending ! (map . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (map . is_woken ()) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v . 0 , \"foo\") ; assert_eq ! (v . 1 , 2) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "release",
                        "label": "release",
                        "kind": "Function",
                        "signature": "fn # [test] fn release () { loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; { let semaphore = semaphore . clone () ; thread :: spawn (move | | { block_on (semaphore . acquire (1)) . unwrap () ; semaphore . release (1) ; }) ; } block_on (semaphore . acquire (1)) . unwrap () ; semaphore . release (1) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_set_len_ok",
                        "label": "open_set_len_ok",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_set_len_ok () { let mut file = MockFile :: default () ; file . expect_set_len () . with (eq (123)) . returning (| _ | Ok (())) ; let file = File :: from_std (file) ; let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_id",
                        "label": "try_id",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns the [`Id`] of the currently running task, or `None` if called outside\"] # [doc = \" of a task.\"] # [doc = \"\"] # [doc = \" This function is similar to  [`task::id()`](crate::runtime::task::id()), except\"] # [doc = \" that it returns `None` rather than panicking if called outside of a task\"] # [doc = \" context.\"] # [doc = \"\"] # [doc = \" [task ID]: crate::task::Id\"] # [track_caller] pub fn try_id () -> Option < Id > { context :: current_task_id () } . sig",
                        "file_path": "tokio/src/runtime/task/id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_fd_try_new_panic_caller",
                        "label": "async_fd_try_new_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] fn async_fd_try_new_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: try_new (fd) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_on_num_polls",
                        "label": "block_on_num_polls",
                        "kind": "Function",
                        "signature": "fn # [test] fn block_on_num_polls () { loom :: model (| | { let at_most = 4 ; let rt1 = Arc :: new (Builder :: new_current_thread () . build () . unwrap ()) ; let rt2 = rt1 . clone () ; let rt3 = rt1 . clone () ; let th1 = thread :: spawn (move | | assert_at_most_num_polls (rt1 , at_most)) ; let th2 = thread :: spawn (move | | assert_at_most_num_polls (rt2 , at_most)) ; let th3 = thread :: spawn (move | | assert_at_most_num_polls (rt3 , at_most)) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; th3 . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_into_future",
                        "label": "join_into_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn join_into_future () { struct NotAFuture ; impl std :: future :: IntoFuture for NotAFuture { type Output = () ; type IntoFuture = std :: future :: Ready < () > ; fn into_future (self) -> Self :: IntoFuture { std :: future :: ready (()) } } tokio :: join ! (NotAFuture) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "acquire",
                        "label": "acquire",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn acquire () { let sem = Arc :: new (Semaphore :: new (1)) ; let p1 = sem . try_acquire () . unwrap () ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire () . await ; }) ; drop (p1) ; j . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "aborts_task_directly",
                        "label": "aborts_task_directly",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn aborts_task_directly () { let (mut tx , rx) = oneshot :: channel :: < bool > () ; let handle = tokio :: spawn (async move { let _ = rx . await ; }) ; let handle = AbortOnDropHandle :: new (handle) ; handle . abort () ; tx . closed () . await ; assert ! (tx . is_closed ()) ; assert ! (handle . is_finished ()) ; } . sig",
                        "file_path": "tokio-util/tests/abort_on_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_length_adjusted",
                        "label": "read_single_frame_length_adjusted",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_length_adjusted () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x00\\x0b\\x0cHello world\") ; let io = length_delimited :: Builder :: new () . length_field_offset (0) . length_field_length (3) . length_adjustment (0) . num_skip (4) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"Hello world\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "KeyInternal",
                        "label": "KeyInternal",
                        "kind": "Struct",
                        "signature": "struct KeyInternal",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_single_multi_frame_multi_packet",
                        "label": "write_single_multi_frame_multi_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_multi_frame_multi_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , flush () , data (b\"\\x00\\x00\\x00\\x03\") , data (b\"123\") , flush () , data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"hello world\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"123\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"hello world\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "incomplete_partial_read_followed_by_write",
                        "label": "incomplete_partial_read_followed_by_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn incomplete_partial_read_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . in_sequence (& mut seq) . with (eq (SeekFrom :: Current (- 10))) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "insert_in_past_fires_immediately",
                        "label": "insert_in_past_fires_immediately",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn insert_in_past_fires_immediately () { println ! (\"running insert_in_past_fires_immediately\") ; time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (10)) . await ; queue . insert_at (\"foo\" , now) ; assert_ready ! (poll ! (queue)) ; println ! (\"finished insert_in_past_fires_immediately\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "instant_to_tick_max",
                        "label": "instant_to_tick_max",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn instant_to_tick_max () { use crate :: runtime :: time :: entry :: MAX_SAFE_MILLIS_DURATION ; let rt = rt (true) ; let handle = rt . handle () . inner . driver () . time () ; let start_time = handle . time_source . start_time () ; let long_future = start_time + std :: time :: Duration :: from_millis (MAX_SAFE_MILLIS_DURATION + 1) ; assert ! (handle . time_source . instant_to_tick (long_future) <= MAX_SAFE_MILLIS_DURATION) ; } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_closed_is_cooperative",
                        "label": "sender_closed_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_closed_is_cooperative () { let (tx , rx) = watch :: channel (()) ; drop (rx) ; tokio :: select ! { _ = async { loop { tx . closed () . await ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JoinQueue",
                        "label": "JoinQueue",
                        "kind": "Struct",
                        "signature": "struct JoinQueue",
                        "file_path": "tokio-util/src/task/join_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_buf_from",
                        "label": "try_recv_buf_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_recv_buf_from () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { client . writable () . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await ? ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_many_unbounded_capacity",
                        "label": "send_recv_many_unbounded_capacity",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_many_unbounded_capacity () { let mut buffer : Vec < String > = Vec :: with_capacity (9) ; let limit = buffer . capacity () ; let (tx , mut rx) = mpsc :: unbounded_channel () ; let mut expected : Vec < String > = (0 .. limit) . map (| x : usize | format ! (\"{x}\")) . collect :: < Vec < _ > > () ; for x in expected . clone () { tx . send (x) . unwrap () } tx . send (\"one more\" . to_string ()) . unwrap () ; assert_eq ! (buffer . capacity () , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; assert_eq ! (limit , buffer . capacity ()) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; assert ! (buffer . capacity () > limit) ; expected . push (\"one more\" . to_string ()) ; assert_eq ! (expected , buffer) ; tokio :: spawn (async move { tx . send (\"final\" . to_string ()) . unwrap () ; }) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; expected . push (\"final\" . to_string ()) ; assert_eq ! (expected , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_twice",
                        "label": "reset_twice",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_twice () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (1)) . await ; let key = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; queue . reset_at (& key , now + ms (50)) ; sleep (ms (20)) . await ; queue . reset_at (& key , now + ms (40)) ; sleep (ms (20)) . await ; assert ! (queue . is_woken ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "InternalStream",
                        "label": "InternalStream",
                        "kind": "Trait",
                        "signature": "trait InternalStream",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire_one_unavailable",
                        "label": "try_acquire_one_unavailable",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire_one_unavailable () { let s = Semaphore :: new (1) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 0) ; assert_err ! (s . try_acquire (1)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; assert_ok ! (s . try_acquire (1)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontented_unbounded_recv_many",
                        "label": "uncontented_unbounded_recv_many",
                        "kind": "Function",
                        "signature": "fn fn uncontented_unbounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for i in 0 .. 5000 { tx . send (i) . unwrap () ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_combinations",
                        "label": "test_combinations",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (panic = \"abort\" , ignore)] fn test_combinations () { let mut rt = & [CombiRuntime :: CurrentThread , CombiRuntime :: Multi1 , CombiRuntime :: Multi2 ,] [..] ; if cfg ! (miri) { rt = & [CombiRuntime :: CurrentThread] ; } let ls = [CombiLocalSet :: Yes , CombiLocalSet :: No] ; let task = [CombiTask :: NoPanic , CombiTask :: PanicOnRun , CombiTask :: PanicOnDrop , CombiTask :: PanicOnRunAndDrop ,] ; let output = [CombiOutput :: NoPanic , CombiOutput :: PanicOnDrop] ; let ji = [CombiJoinInterest :: Polled , CombiJoinInterest :: NotPolled] ; let jh = [CombiJoinHandle :: DropImmediately , CombiJoinHandle :: DropFirstPoll , CombiJoinHandle :: DropAfterNoConsume , CombiJoinHandle :: DropAfterConsume ,] ; let abort = [CombiAbort :: NotAborted , CombiAbort :: AbortedImmediately , CombiAbort :: AbortedFirstPoll , CombiAbort :: AbortedAfterFinish , CombiAbort :: AbortedAfterConsumeOutput ,] ; let ah = [None , Some (CombiJoinHandle :: DropImmediately) , Some (CombiJoinHandle :: DropFirstPoll) , Some (CombiJoinHandle :: DropAfterNoConsume) , Some (CombiJoinHandle :: DropAfterConsume) ,] ; for rt in rt . iter () . copied () { for ls in ls . iter () . copied () { for task in task . iter () . copied () { for output in output . iter () . copied () { for ji in ji . iter () . copied () { for jh in jh . iter () . copied () { for abort in abort . iter () . copied () { for ah in ah . iter () . copied () { test_combination (rt , ls , task , output , ji , jh , ah , abort , CombiAbortSource :: JoinHandle ,) ; } test_combination (rt , ls , task , output , ji , jh , None , abort , CombiAbortSource :: AbortHandle ,) ; } } } } } } } } . sig",
                        "file_path": "tokio/src/runtime/tests/task_combinations.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_with_spawn",
                        "label": "main_with_spawn",
                        "kind": "Function",
                        "signature": "fn # [test] fn main_with_spawn () { assert_eq ! (1 , spawning ()) ; } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontended",
                        "label": "uncontended",
                        "kind": "Function",
                        "signature": "fn fn uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { for _ in 0 .. 6 { let permit = s . acquire () . await ; drop (permit) ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_all",
                        "label": "create_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn create_all () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") . join (\"bar\") ; let new_dir_2 = new_dir . clone () ; assert_ok ! (fs :: create_dir_all (new_dir) . await) ; assert ! (new_dir_2 . is_dir ()) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_one_packet_native_endian",
                        "label": "read_single_frame_one_packet_native_endian",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_one_packet_native_endian () { let d = if cfg ! (target_endian = \"big\") { b\"\\x00\\x00\\x00\\x09abcdefghi\" } else { b\"\\x09\\x00\\x00\\x00abcdefghi\" } ; let io = length_delimited :: Builder :: new () . native_endian () . new_read (mock ! { data (d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with_capacity",
                        "label": "with_capacity",
                        "kind": "Function",
                        "signature": "fn # [test] fn with_capacity () { let map = StreamMap :: < & str , stream :: Pending < () > > :: with_capacity (10) ; assert ! (10 <= map . capacity ()) ; assert ! (map . keys () . next () . is_none ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Driver",
                        "label": "Driver",
                        "kind": "Struct",
                        "signature": "struct Driver",
                        "file_path": "tokio/src/runtime/time/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending",
                        "label": "maybe_pending",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , MaybePending :: new (inner)) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 3) ; assert_eq ! (buf , [5 , 6 , 7]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 2) ; assert_eq ! (buf , [0 , 1]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [2]) ; assert_eq ! (reader . buffer () , [3]) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [3 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [4 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "atomic_inc_num_notify_waiters_calls",
                        "label": "atomic_inc_num_notify_waiters_calls",
                        "kind": "Function",
                        "signature": "fn fn atomic_inc_num_notify_waiters_calls (data : & AtomicUsize) { data . fetch_add (1 << NOTIFY_WAITERS_SHIFT , SeqCst) ; } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "compute",
                        "label": "compute",
                        "kind": "Function",
                        "signature": "fn async fn compute () -> usize { let join = tokio1 :: spawn (async { 1 }) ; join . await . unwrap () } . sig",
                        "file_path": "tokio/tests/macros_rename_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lots",
                        "label": "lots",
                        "kind": "Function",
                        "signature": "fn # [test] fn lots () { let b = Barrier :: new (100) ; for _ in 0 .. 10 { let mut wait = Vec :: new () ; for _ in 0 .. 99 { let mut w = spawn (b . wait ()) ; assert_pending ! (w . poll ()) ; wait . push (w) ; } for w in & mut wait { assert_pending ! (w . poll ()) ; } let mut w = spawn (b . wait ()) ; let mut found_leader = assert_ready ! (w . poll ()) . is_leader () ; for mut w in wait { let wr = assert_ready ! (w . poll ()) ; if wr . is_leader () { assert ! (! found_leader) ; found_leader = true ; } } assert ! (found_leader) ; } } . sig",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_output_destructor_handle_dropped_before_completion",
                        "label": "task_id_output_destructor_handle_dropped_before_completion",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_output_destructor_handle_dropped_before_completion () { struct MyOutput { tx : Option < oneshot :: Sender < Id > > , } impl Drop for MyOutput { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = MyOutput ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < Self :: Output > { Poll :: Ready (MyOutput { tx : self . tx . take () }) } } let (tx , mut rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; drop (handle) ; assert ! (rx . try_recv () . is_err ()) ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "advance_after_poll",
                        "label": "advance_after_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_after_poll () { time :: sleep (ms (1)) . await ; let start = Instant :: now () ; let mut sleep = task :: spawn (time :: sleep_until (start + ms (300))) ; assert_pending ! (sleep . poll ()) ; let before = Instant :: now () ; time :: advance (ms (100)) . await ; assert_elapsed ! (before , ms (100)) ; assert_pending ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_empty_io_yields_nothing",
                        "label": "read_empty_io_yields_nothing",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_empty_io_yields_nothing () { let io = Box :: pin (FramedRead :: new (mock ! () , LengthDelimitedCodec :: new ())) ; pin_mut ! (io) ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_entry",
                        "label": "remove_entry",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn remove_entry () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let key = queue . insert_at (\"foo\" , Instant :: now () + ms (5)) ; assert_pending ! (poll ! (queue)) ; let entry = queue . remove (& key) ; assert_eq ! (entry . into_inner () , \"foo\") ; sleep (ms (10)) . await ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "child_node",
                        "label": "child_node",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a child node\"] pub (crate) fn child_node (parent : & Arc < TreeNode >) -> Arc < TreeNode > { let mut locked_parent = parent . inner . lock () . unwrap () ; if locked_parent . is_cancelled { return Arc :: new (TreeNode { inner : Mutex :: new (Inner { parent : None , parent_idx : 0 , children : vec ! [] , is_cancelled : true , num_handles : 1 , }) , waker : tokio :: sync :: Notify :: new () , }) ; } let child = Arc :: new (TreeNode { inner : Mutex :: new (Inner { parent : Some (parent . clone ()) , parent_idx : locked_parent . children . len () , children : vec ! [] , is_cancelled : false , num_handles : 1 , }) , waker : tokio :: sync :: Notify :: new () , }) ; locked_parent . children . push (child . clone ()) ; child } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_ok",
                        "label": "ready_ok",
                        "kind": "Function",
                        "signature": "fn fn ready_ok () -> Poll < Result < () , () > > { Poll :: Ready (Ok (())) } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Server",
                        "label": "Server",
                        "kind": "Struct",
                        "signature": "struct Server",
                        "file_path": "examples/echo-udp.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "spawn_blocking_when_paused",
                        "label": "spawn_blocking_when_paused",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_blocking_when_paused () { use std :: time :: Duration ; loom :: model (| | { let rt = crate :: runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; let handle = rt . handle () ; let _enter = handle . enter () ; let a = crate :: task :: spawn_blocking (| | { }) ; let b = crate :: task :: spawn_blocking (| | { }) ; rt . block_on (crate :: time :: timeout (Duration :: from_millis (1) , async move { a . await . expect (\"blocking task should finish\") ; b . await . expect (\"blocking task should finish\") ; })) . expect (\"timeout should not trigger\") ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf_set_filled_panic_caller",
                        "label": "read_buf_set_filled_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_buf_set_filled_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . set_filled (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawned_tasks_count",
                        "label": "spawned_tasks_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawned_tasks_count () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . spawned_tasks_count ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . spawned_tasks_count ()) ; })) . unwrap () ; assert_eq ! (1 , rt . metrics () . spawned_tasks_count ()) ; let rt = threaded () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . spawned_tasks_count ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . spawned_tasks_count ()) ; })) . unwrap () ; assert_eq ! (1 , rt . metrics () . spawned_tasks_count ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_thread",
                        "label": "multi_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_thread () { let rt = runtime :: Builder :: new_multi_thread () . enable_all () . worker_threads (3) . build () . unwrap () ; async fn dump () { let handle = Handle :: current () ; let dump = handle . dump () . await ; let tasks : Vec < _ > = dump . tasks () . iter () . collect () ; assert_eq ! (tasks . len () , 3) ; for task in tasks { let id = task . id () ; let trace = task . trace () . to_string () ; eprintln ! (\"\\n\\n{id}:\\n{trace}\\n\\n\") ; assert ! (trace . contains (\"dump::a\")) ; assert ! (trace . contains (\"dump::b\")) ; assert ! (trace . contains (\"dump::c\")) ; assert ! (trace . contains (\"tokio::task::yield_now\")) ; } } rt . block_on (async { tokio :: select ! (biased ; _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = dump () => { } ,) ; }) ; } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_on",
                        "label": "block_on",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Runs the provided future, blocking the current thread until the\"] # [doc = \" future completes.\"] # [doc = \"\"] # [doc = \" For more information, see the documentation for\"] # [doc = \" [`tokio::runtime::Runtime::block_on`][runtime-block-on].\"] # [doc = \"\"] # [doc = \" [runtime-block-on]: https://docs.rs/tokio/1.3.0/tokio/runtime/struct.Runtime.html#method.block_on\"] pub fn block_on < F : std :: future :: Future > (future : F) -> F :: Output { use tokio :: runtime ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; rt . block_on (future) } . sig",
                        "file_path": "tokio-test/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_seek_write_err",
                        "label": "write_seek_write_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_seek_write_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Start (0))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; { let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MockWriter",
                        "label": "MockWriter",
                        "kind": "Struct",
                        "signature": "struct MockWriter",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire",
                        "label": "try_acquire",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire () { let sem = Semaphore :: new (1) ; { let p1 = sem . try_acquire () ; assert ! (p1 . is_ok ()) ; let p2 = sem . try_acquire () ; assert ! (p2 . is_err ()) ; } let p3 = sem . try_acquire () ; assert ! (p3 . is_ok ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_during_shutdown",
                        "label": "spawn_during_shutdown",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_during_shutdown () { static DID_SPAWN : AtomicBool = AtomicBool :: new (false) ; struct SpawnOnDrop (Runtime) ; impl Drop for SpawnOnDrop { fn drop (& mut self) { DID_SPAWN . store (true , Ordering :: SeqCst) ; self . 0 . spawn (async { }) ; } } with (| rt | { let rt2 = rt . clone () ; rt . spawn (async move { let _spawn_on_drop = SpawnOnDrop (rt2) ; loop { crate :: task :: yield_now () . await ; } }) ; rt . tick_max (1) ; rt . shutdown () ; }) ; assert ! (DID_SPAWN . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "internal_interval_at",
                        "label": "internal_interval_at",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (not (all (tokio_unstable , feature = \"tracing\")) , allow (unused_variables))] fn internal_interval_at (start : Instant , period : Duration , location : Option < & 'static Location < 'static > > ,) -> Interval { # [cfg (all (tokio_unstable , feature = \"tracing\"))] let resource_span = { let location = location . expect (\"should have location if tracing\") ; tracing :: trace_span ! (parent : None , \"runtime.resource\" , concrete_type = \"Interval\" , kind = \"timer\" , loc . file = location . file () , loc . line = location . line () , loc . col = location . column () ,) } ; # [cfg (all (tokio_unstable , feature = \"tracing\"))] let delay = resource_span . in_scope (| | Box :: pin (sleep_until (start))) ; # [cfg (not (all (tokio_unstable , feature = \"tracing\")))] let delay = Box :: pin (sleep_until (start)) ; Interval { delay , period , missed_tick_behavior : MissedTickBehavior :: default () , # [cfg (all (tokio_unstable , feature = \"tracing\"))] resource_span , } } . sig",
                        "file_path": "tokio/src/time/interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "nested_spawn_is_local",
                        "label": "nested_spawn_is_local",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn nested_spawn_is_local () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "start_index",
                        "label": "start_index",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns the index of the first slot in the block referenced by `slot_index`.\"] # [inline (always)] pub (crate) fn start_index (slot_index : usize) -> usize { BLOCK_MASK & slot_index } . sig",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge_sync_streams",
                        "label": "merge_sync_streams",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn merge_sync_streams () { let mut s = stream :: iter (vec ! [0 , 2 , 4 , 6]) . merge (stream :: iter (vec ! [1 , 3 , 5])) ; for i in 0 .. 7 { let rem = 7 - i ; assert_eq ! (s . size_hint () , (rem , Some (rem))) ; assert_eq ! (Some (i) , s . next () . await) ; } assert ! (s . next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_merge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "expires_before_last_insert",
                        "label": "expires_before_last_insert",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn expires_before_last_insert () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo\" , now + ms (10_000)) ; assert_pending ! (poll ! (queue)) ; queue . insert_at (\"bar\" , now + ms (600)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (600)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"bar\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic",
                        "label": "basic",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic () { test_with_runtimes (| | { let one = Handle :: current () . block_on (async { 1 }) ; assert_eq ! (1 , one) ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_currently_pending",
                        "label": "driver_shutdown_wakes_currently_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_currently_pending () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let readable = assert_pending (afd_a . readable ()) ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (readable)) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_wakes_task_3964",
                        "label": "test_abort_wakes_task_3964",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a suspended task can be aborted even if the `JoinHandle` is immediately dropped.\"] # [doc = \" issue #3964: <https://github.com/tokio-rs/tokio/issues/3964>.\"] # [test] fn test_abort_wakes_task_3964 () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let notify_dropped = Arc :: new (()) ; let weak_notify_dropped = Arc :: downgrade (& notify_dropped) ; let handle = tokio :: spawn (async move { let _notify_dropped = notify_dropped ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; drop (handle) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; assert ! (weak_notify_dropped . upgrade () . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "checking_tx_send_ok_not_drop",
                        "label": "checking_tx_send_ok_not_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn checking_tx_send_ok_not_drop () { use std :: borrow :: Borrow ; use std :: cell :: Cell ; loom :: thread_local ! { static IS_RX : Cell < bool > = Cell :: new (true) ; } struct Msg ; impl Drop for Msg { fn drop (& mut self) { IS_RX . with (| is_rx : & Cell < _ > | { assert ! (is_rx . get ()) ; }) ; } } let mut builder = loom :: model :: Builder :: new () ; builder . preemption_bound = Some (2) ; builder . check (| | { let (tx , rx) = oneshot :: channel () ; let tx_thread_join_handle = thread :: spawn (move | | { IS_RX . with (| is_rx : & Cell < _ > | { is_rx . set (false) ; }) ; if let Err (msg) = tx . send (Msg) { std :: mem :: forget (msg) ; } }) ; drop (rx) ; tx_thread_join_handle . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_thread_id_current_thread",
                        "label": "worker_thread_id_current_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_thread_id_current_thread () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { }) ; assert_eq ! (Some (thread :: current () . id ()) , metrics . worker_thread_id (0)) ; let thread_id = std :: thread :: scope (| scope | { let join_handle = scope . spawn (| | { rt . block_on (async { }) ; }) ; join_handle . thread () . id () }) ; assert_eq ! (Some (thread_id) , metrics . worker_thread_id (0)) ; rt . block_on (async { }) ; assert_eq ! (Some (thread :: current () . id ()) , metrics . worker_thread_id (0)) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ScheduledIo",
                        "label": "ScheduledIo",
                        "kind": "Struct",
                        "signature": "struct ScheduledIo",
                        "file_path": "tokio/src/runtime/io/scheduled_io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "DuplexStream",
                        "label": "DuplexStream",
                        "kind": "Struct",
                        "signature": "struct DuplexStream",
                        "file_path": "tokio/src/io/util/mem.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "HistogramBatch",
                        "label": "HistogramBatch",
                        "kind": "Struct",
                        "signature": "struct HistogramBatch",
                        "file_path": "tokio/src/runtime/metrics/histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "open_options_write",
                        "label": "open_options_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_options_write () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . write (true)) . contains (\"write: true\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "question_mark_operator_with_invalid_result",
                        "label": "question_mark_operator_with_invalid_result",
                        "kind": "Function",
                        "signature": "fn # [doc = \" This test is a characterization test for the `?` operator.\"] # [doc = \"\"] # [doc = \" See <https://github.com/tokio-rs/tokio/issues/6930#issuecomment-2572502517> for more details.\"] # [doc = \"\"] # [doc = \" It should fail with a single error message about the return type of the function, but instead\"] # [doc = \" if fails with an extra error message due to the `?` operator being used within the async block\"] # [doc = \" rather than the original function.\"] # [doc = \"\"] # [doc = \" ```text\"] # [doc = \" 33 |     Ok(())?;\"] # [doc = \"    |           ^ cannot use the `?` operator in an async block that returns `()`\"] # [doc = \" ```\"] # [tokio :: main] async fn question_mark_operator_with_invalid_result () -> Result < () , () > { Ok (()) ? ; } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_combination",
                        "label": "test_combination",
                        "kind": "Function",
                        "signature": "fn # [allow (clippy :: too_many_arguments)] fn test_combination (rt : CombiRuntime , ls : CombiLocalSet , task : CombiTask , output : CombiOutput , ji : CombiJoinInterest , jh : CombiJoinHandle , ah : Option < CombiJoinHandle > , abort : CombiAbort , abort_src : CombiAbortSource ,) { match (abort_src , ah) { (CombiAbortSource :: JoinHandle , _) if (jh as usize) < (abort as usize) => { return ; } (CombiAbortSource :: AbortHandle , Some (_)) => { return ; } _ => { } } if (task == CombiTask :: PanicOnDrop) && (output == CombiOutput :: PanicOnDrop) { return ; } if (task == CombiTask :: PanicOnRunAndDrop) && (abort != CombiAbort :: AbortedImmediately) { return ; } is_debug (& rt) ; is_debug (& ls) ; is_debug (& task) ; is_debug (& output) ; is_debug (& ji) ; is_debug (& jh) ; is_debug (& ah) ; is_debug (& abort) ; is_debug (& abort_src) ; struct Rt { rt : crate :: runtime :: Runtime , ls : Option < crate :: task :: LocalSet > , } impl Rt { fn new (rt : CombiRuntime , ls : CombiLocalSet) -> Self { let rt = match rt { CombiRuntime :: CurrentThread => Builder :: new_current_thread () . build () . unwrap () , CombiRuntime :: Multi1 => Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () , CombiRuntime :: Multi2 => Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () , } ; let ls = match ls { CombiLocalSet :: Yes => Some (crate :: task :: LocalSet :: new ()) , CombiLocalSet :: No => None , } ; Self { rt , ls } } fn block_on < T > (& self , task : T) -> T :: Output where T : Future , { match & self . ls { Some (ls) => ls . block_on (& self . rt , task) , None => self . rt . block_on (task) , } } fn spawn < T > (& self , task : T) -> JoinHandle < T :: Output > where T : Future + Send + 'static , T :: Output : Send + 'static , { match & self . ls { Some (ls) => ls . spawn_local (task) , None => self . rt . spawn (task) , } } } struct Output { panic_on_drop : bool , on_drop : Option < oneshot :: Sender < () > > , } impl Output { fn disarm (& mut self) { self . panic_on_drop = false ; } } impl Drop for Output { fn drop (& mut self) { let _ = self . on_drop . take () . unwrap () . send (()) ; if self . panic_on_drop { panic ! (\"Panicking in Output\") ; } } } struct FutWrapper < F > { inner : F , on_drop : Option < oneshot :: Sender < () > > , panic_on_drop : bool , } impl < F : Future > Future for FutWrapper < F > { type Output = F :: Output ; fn poll (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < F :: Output > { unsafe { let me = Pin :: into_inner_unchecked (self) ; let inner = Pin :: new_unchecked (& mut me . inner) ; inner . poll (cx) } } } impl < F > Drop for FutWrapper < F > { fn drop (& mut self) { let _ : Result < () , () > = self . on_drop . take () . unwrap () . send (()) ; if self . panic_on_drop { panic ! (\"Panicking in FutWrapper\") ; } } } struct Signals { on_first_poll : Option < oneshot :: Sender < () > > , wait_complete : Option < oneshot :: Receiver < () > > , on_output_drop : Option < oneshot :: Sender < () > > , } async fn my_task (mut signal : Signals , task : CombiTask , out : CombiOutput) -> Output { let _ = signal . on_first_poll . take () . unwrap () . send (()) ; let _ = signal . wait_complete . take () . unwrap () . await ; crate :: task :: yield_now () . await ; if task == CombiTask :: PanicOnRun || task == CombiTask :: PanicOnRunAndDrop { panic ! (\"Panicking in my_task on {:?}\" , std :: thread :: current () . id ()) ; } Output { panic_on_drop : out == CombiOutput :: PanicOnDrop , on_drop : signal . on_output_drop . take () , } } let rt = Rt :: new (rt , ls) ; let (on_first_poll , wait_first_poll) = oneshot :: channel () ; let (on_complete , wait_complete) = oneshot :: channel () ; let (on_future_drop , wait_future_drop) = oneshot :: channel () ; let (on_output_drop , wait_output_drop) = oneshot :: channel () ; let signal = Signals { on_first_poll : Some (on_first_poll) , wait_complete : Some (wait_complete) , on_output_drop : Some (on_output_drop) , } ; let mut handle = Some (rt . spawn (FutWrapper { inner : my_task (signal , task , output) , on_drop : Some (on_future_drop) , panic_on_drop : task == CombiTask :: PanicOnDrop || task == CombiTask :: PanicOnRunAndDrop , })) ; let mut aborted = false ; if ji == CombiJoinInterest :: Polled { assert ! (handle . as_mut () . unwrap () . now_or_never () . is_none () , \"Polling handle succeeded\") ; } let mut abort_handle = if ah . is_some () || abort_src == CombiAbortSource :: AbortHandle { handle . as_ref () . map (JoinHandle :: abort_handle) } else { None } ; let do_abort = | abort_handle : & mut Option < AbortHandle > , join_handle : Option < & mut JoinHandle < _ > > | { match abort_src { CombiAbortSource :: AbortHandle => abort_handle . take () . unwrap () . abort () , CombiAbortSource :: JoinHandle => join_handle . unwrap () . abort () , } } ; if abort == CombiAbort :: AbortedImmediately { do_abort (& mut abort_handle , handle . as_mut ()) ; aborted = true ; } if jh == CombiJoinHandle :: DropImmediately { drop (handle . take () . unwrap ()) ; } let got_polled = rt . block_on (wait_first_poll) . is_ok () ; if ! got_polled { assert ! (aborted , \"Task completed without ever being polled but was not aborted.\") ; } if abort == CombiAbort :: AbortedFirstPoll { do_abort (& mut abort_handle , handle . as_mut ()) ; aborted = true ; } if jh == CombiJoinHandle :: DropFirstPoll { drop (handle . take () . unwrap ()) ; } if ah == Some (CombiJoinHandle :: DropFirstPoll) { drop (abort_handle . take () . unwrap ()) ; } let _ = on_complete . send (()) ; assert ! (rt . block_on (wait_future_drop) . is_ok () , \"The future should always be dropped.\") ; if abort == CombiAbort :: AbortedAfterFinish { do_abort (& mut abort_handle , handle . as_mut ()) ; } if jh == CombiJoinHandle :: DropAfterNoConsume { if ah == Some (CombiJoinHandle :: DropAfterNoConsume) { drop (handle . take () . unwrap ()) ; let panic = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { drop (abort_handle . take () . unwrap ()) ; })) ; if panic . is_err () { assert ! ((output == CombiOutput :: PanicOnDrop) && (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Dropping AbortHandle shouldn't panic here\") ; } } else { let panic = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { drop (handle . take () . unwrap ()) ; })) ; if panic . is_err () { assert ! ((output == CombiOutput :: PanicOnDrop) && (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Dropping JoinHandle shouldn't panic here\") ; } } } if jh == CombiJoinHandle :: DropAfterConsume { let result = rt . block_on (handle . as_mut () . unwrap ()) ; match result { Ok (mut output) => { output . disarm () ; assert ! (! aborted , \"Task was aborted but returned output\") ; } Err (err) if err . is_cancelled () => assert ! (aborted , \"Cancelled output but not aborted\") , Err (err) if err . is_panic () => { assert ! ((task == CombiTask :: PanicOnRun) || (task == CombiTask :: PanicOnDrop) || (task == CombiTask :: PanicOnRunAndDrop) || (output == CombiOutput :: PanicOnDrop) , \"Panic but nothing should panic\") ; } _ => unreachable ! () , } let mut handle = handle . take () . unwrap () ; if abort == CombiAbort :: AbortedAfterConsumeOutput { do_abort (& mut abort_handle , Some (& mut handle)) ; } drop (handle) ; if ah == Some (CombiJoinHandle :: DropAfterConsume) { drop (abort_handle . take ()) ; } } let output_created = rt . block_on (wait_output_drop) . is_ok () ; assert_eq ! (output_created , (! matches ! (task , CombiTask :: PanicOnRun | CombiTask :: PanicOnRunAndDrop)) && ! aborted , \"Creation of output object\") ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task_combinations.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Pointers",
                        "label": "Pointers",
                        "kind": "Struct",
                        "signature": "struct Pointers",
                        "file_path": "tokio/src/util/linked_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ReuniteError",
                        "label": "ReuniteError",
                        "kind": "Struct",
                        "signature": "struct ReuniteError",
                        "file_path": "tokio/src/net/unix/split_owned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "run",
                        "label": "run",
                        "kind": "Function",
                        "signature": "fn fn run (worker : Arc < Worker >) { # [allow (dead_code)] struct AbortOnPanic ; impl Drop for AbortOnPanic { fn drop (& mut self) { if std :: thread :: panicking () { eprintln ! (\"worker thread panicking; aborting process\") ; std :: process :: abort () ; } } } # [cfg (debug_assertions)] let _abort_on_panic = AbortOnPanic ; let core = match worker . core . take () { Some (core) => core , None => return , } ; worker . handle . shared . worker_metrics [worker . index] . set_thread_id (thread :: current () . id ()) ; let handle = scheduler :: Handle :: MultiThread (worker . handle . clone ()) ; crate :: runtime :: context :: enter_runtime (& handle , true , | _ | { let cx = scheduler :: Context :: MultiThread (Context { worker , core : RefCell :: new (None) , defer : Defer :: new () , }) ; context :: set_scheduler (& cx , | | { let cx = cx . expect_multi_thread () ; assert ! (cx . run (core) . is_err ()) ; cx . defer . wake () ; }) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking",
                        "label": "blocking",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn blocking () { const NUM : usize = 1_000 ; for _ in 0 .. 10 { let (tx , rx) = mpsc :: channel () ; let rt = rt () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; let block = Arc :: new (std :: sync :: Barrier :: new (5)) ; for _ in 0 .. 4 { let block = block . clone () ; rt . spawn (async move { tokio :: task :: block_in_place (move | | { block . wait () ; block . wait () ; }) }) ; } block . wait () ; for _ in 0 .. NUM { let cnt = cnt . clone () ; let tx = tx . clone () ; rt . spawn (async move { let num = cnt . fetch_add (1 , Relaxed) + 1 ; if num == NUM { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; block . wait () ; } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_noop_count",
                        "label": "worker_noop_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_noop_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (0 < metrics . worker_noop_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (0 < metrics . worker_noop_count (0)) ; assert ! (0 < metrics . worker_noop_count (1)) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_tx",
                        "label": "close_tx",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_tx () { let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; assert_pending ! (rx . poll ()) ; drop (tx) ; assert ! (rx . is_woken ()) ; assert_ready_err ! (rx . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_sender_strong_count_when_dropped",
                        "label": "unbounded_sender_strong_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_count_when_dropped () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; drop (tx2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_with_name",
                        "label": "spawn_with_name",
                        "kind": "Function",
                        "signature": "fn # [test] async fn spawn_with_name () { let result = Builder :: new () . name (\"name\") . spawn (async { \"task executed\" }) . unwrap () . await ; assert_eq ! (result . unwrap () , \"task executed\") ; } . sig",
                        "file_path": "tokio/tests/task_builder.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_with_multiple_messages",
                        "label": "test_rx_unbounded_len_with_multiple_messages",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_with_multiple_messages () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; } assert_eq ! (rx . len () , 100) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_one_after_dropped_all",
                        "label": "notify_one_after_dropped_all",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_one_after_dropped_all () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; notify . notify_waiters () ; notify . notify_one () ; drop (notified1) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_empty_when_there_are_messages_in_the_buffer",
                        "label": "test_rx_is_not_empty_when_there_are_messages_in_the_buffer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_there_are_messages_in_the_buffer () { let (tx , rx) = mpsc :: channel :: < () > (10) ; assert ! (tx . send (()) . await . is_ok ()) ; assert ! (! rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "globals",
                        "label": "globals",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn globals () -> & 'static Globals where OsExtraData : 'static + Send + Sync + Init , OsStorage : 'static + Send + Sync + Init , { static GLOBALS : OnceLock < Globals > = OnceLock :: new () ; GLOBALS . get_or_init (globals_init) } . sig",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SemaphorePermit",
                        "label": "SemaphorePermit",
                        "kind": "Struct",
                        "signature": "struct SemaphorePermit",
                        "file_path": "tokio/src/sync/semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Rx",
                        "label": "Rx",
                        "kind": "Struct",
                        "signature": "struct Rx",
                        "file_path": "tokio/src/sync/mpsc/list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { use tracing_subscriber :: { fmt :: format :: FmtSpan , EnvFilter } ; tracing_subscriber :: fmt () . with_env_filter (EnvFilter :: from_default_env () . add_directive (\"chat=info\" . parse () ?)) . with_span_events (FmtSpan :: FULL) . init () ; let state = Arc :: new (Mutex :: new (Shared :: new ())) ; let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:6142\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; tracing :: info ! (\"server running on {}\" , addr) ; loop { let (stream , addr) = listener . accept () . await ? ; let state = Arc :: clone (& state) ; tokio :: spawn (async move { tracing :: debug ! (\"accepted connection\") ; if let Err (e) = process (state , stream , addr) . await { tracing :: info ! (\"an error occurred; error = {:?}\" , e) ; } }) ; } } . sig",
                        "file_path": "examples/chat.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_terminated_drop",
                        "label": "receiver_is_terminated_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_terminated_drop () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before sender is dropped\") ; drop (tx) ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after sender is dropped\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_peek_sender",
                        "label": "try_peek_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; sender . send_to (msg , receiver_addr) . await ? ; let peeked_sender = loop { match receiver . try_peek_sender () { Ok (peeked_sender) => break peeked_sender , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { receiver . readable () . await ? ; } Err (e) => return Err (e) , } } ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let (read , received_sender) = receiver . try_recv_from (& mut recv_buf) . unwrap () ; assert_eq ! (& recv_buf [.. read] , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WriteHalf",
                        "label": "WriteHalf",
                        "kind": "Struct",
                        "signature": "struct WriteHalf",
                        "file_path": "tokio/src/net/unix/split.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "is_none_initializing",
                        "label": "is_none_initializing",
                        "kind": "Function",
                        "signature": "fn # [test] fn is_none_initializing () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; assert_eq ! (ONCE . get () , None) ; ONCE . set (20) . unwrap () ; assert ! (ONCE . set (10) . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_poll_consistency",
                        "label": "notify_waiters_poll_consistency",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Polls two `Notified` futures and checks if poll results are consistent\"] # [doc = \" with each other. If the first future is notified by a `notify_waiters`\"] # [doc = \" call, then the second one must be notified as well.\"] # [test] fn notify_waiters_poll_consistency () { fn notify_waiters_poll_consistency_variant (poll_setting : [bool ; 2]) { let notify = Arc :: new (Notify :: new ()) ; let mut notified = [tokio_test :: task :: spawn (notify . notified ()) , tokio_test :: task :: spawn (notify . notified ()) ,] ; for i in 0 .. 2 { if poll_setting [i] { assert_pending ! (notified [i] . poll ()) ; } } let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; let res1 = notified [0] . poll () ; let res2 = notified [1] . poll () ; assert ! (res1 . is_pending () || res2 . is_ready ()) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_poll_consistency_variant ([false , false])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([true , false])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([false , true])) ; loom :: model (| | notify_waiters_poll_consistency_variant ([true , true])) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "changing_rx_task",
                        "label": "changing_rx_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn changing_rx_task () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { tx . send (1) . unwrap () ; }) ; let rx = thread :: spawn (move | | { let ready = block_on (poll_fn (| cx | match Pin :: new (& mut rx) . poll (cx) { Ready (Ok (value)) => { assert_eq ! (1 , value) ; Ready (true) } Ready (Err (_)) => unimplemented ! () , Pending => Ready (false) , })) ; if ready { None } else { Some (rx) } }) . join () . unwrap () ; if let Some (rx) = rx { let value = block_on (rx) . unwrap () ; assert_eq ! (1 , value) ; } }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with_current",
                        "label": "with_current",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn with_current < F , R > (f : F) -> Result < R , TryCurrentError > where F : FnOnce (& scheduler :: Handle) -> R , { match CONTEXT . try_with (| ctx | ctx . current . handle . borrow () . as_ref () . map (f)) { Ok (Some (ret)) => Ok (ret) , Ok (None) => Err (TryCurrentError :: new_no_context ()) , Err (_access_error) => Err (TryCurrentError :: new_thread_local_destroyed ()) , } } . sig",
                        "file_path": "tokio/src/runtime/context/current.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "coop_disabled_in_block_in_place_in_block_on",
                        "label": "coop_disabled_in_block_in_place_in_block_on",
                        "kind": "Function",
                        "signature": "fn # [test] fn coop_disabled_in_block_in_place_in_block_on () { let (done_tx , done_rx) = std :: sync :: mpsc :: channel () ; let done = done_tx . clone () ; thread :: spawn (move | | { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream () ; for i in 0 .. 200 { tx . send (i) . unwrap () ; } drop (tx) ; outer . block_on (async move { tokio :: task :: block_in_place (move | | { futures :: executor :: block_on (async move { use tokio_stream :: StreamExt ; assert_eq ! (rx . fold (0 , | n , _ | n + 1) . await , 200) ; }) }) }) ; let _ = done . send (Ok (())) ; }) ; thread :: spawn (move | | { thread :: sleep (Duration :: from_secs (1)) ; let _ = done_tx . send (Err (\"timed out (probably hanging)\")) ; }) ; done_rx . recv () . unwrap () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending",
                        "label": "pending",
                        "kind": "Function",
                        "signature": "fn fn pending () -> Poll < () > { Poll :: Pending } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "waker",
                        "label": "waker",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a waker from a `Arc<impl Wake>`.\"] pub (crate) fn waker < W : Wake > (wake : Arc < W >) -> Waker { unsafe { Waker :: from_raw (RawWaker :: new (Arc :: into_raw (wake) . cast () , waker_vtable :: < W > () ,)) } } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "capacity_too_big",
                        "label": "capacity_too_big",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn capacity_too_big () { broadcast :: channel :: < () > (1 + (usize :: MAX >> 1)) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "immediate_exit_on_write_error",
                        "label": "immediate_exit_on_write_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn immediate_exit_on_write_error () { let payload = b\"here, take this\" ; let error = | | io :: Error :: new (io :: ErrorKind :: Other , \"no thanks!\") ; let mut a = tokio_test :: io :: Builder :: new () . read (payload) . write_error (error ()) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read (payload) . write_error (error ()) . build () ; assert ! (copy_bidirectional (& mut a , & mut b) . await . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_sender_weak_count_when_dropped",
                        "label": "unbounded_sender_weak_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn unbounded_sender_weak_count_when_dropped () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_one_byte_length_field",
                        "label": "read_one_byte_length_field",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_one_byte_length_field () { let io = length_delimited :: Builder :: new () . length_field_length (1) . new_read (mock ! { data (b\"\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MetricAtomicU64",
                        "label": "MetricAtomicU64",
                        "kind": "Struct",
                        "signature": "struct MetricAtomicU64",
                        "file_path": "tokio/src/util/metric_atomics.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_local_on_runtime_object",
                        "label": "test_spawn_local_on_runtime_object",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_spawn_local_on_runtime_object () { let rt = rt () ; let (tx , rx) = tokio :: sync :: oneshot :: channel () ; rt . spawn_local (async { tokio :: task :: yield_now () . await ; tx . send (5) . unwrap () ; }) ; let res = rt . block_on (async move { rx . await . unwrap () }) ; assert_eq ! (res , 5) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LockGuard",
                        "label": "LockGuard",
                        "kind": "Struct",
                        "signature": "struct LockGuard",
                        "file_path": "tokio/src/util/try_lock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "callback_panic_does_not_kill_worker",
                        "label": "callback_panic_does_not_kill_worker",
                        "kind": "Function",
                        "signature": "fn # [doc = \" A panic during task creation causes the join handle to return an error.\"] # [doc = \" But, you can continue to spawn tasks.\"] # [tokio :: test] # [cfg (panic = \"unwind\")] async fn callback_panic_does_not_kill_worker () { let pool = task :: LocalPoolHandle :: new (1) ; let join_handle = pool . spawn_pinned (| | { panic ! (\"Test panic\") ; # [allow (unreachable_code)] async { } }) ; let result = join_handle . await ; assert ! (result . is_err ()) ; let error = result . unwrap_err () ; assert ! (error . is_panic ()) ; let panic_str = error . into_panic () . downcast :: < & 'static str > () . unwrap () ; assert_eq ! (* panic_str , \"Test panic\") ; let join_handle = pool . spawn_pinned (| | async { \"test\" }) ; let result = join_handle . await ; assert ! (result . is_ok ()) ; assert_eq ! (result . unwrap () , \"test\") ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn split () -> Result < () > { const MSG : & [u8] = b\"split\" ; let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") ? ; let addr = listener . local_addr () ? ; let handle = thread :: spawn (move | | { let (mut stream , _) = listener . accept () . unwrap () ; stream . write_all (MSG) . unwrap () ; let mut read_buf = [0u8 ; 32] ; let read_len = stream . read (& mut read_buf) . unwrap () ; assert_eq ! (& read_buf [.. read_len] , MSG) ; }) ; let mut stream = TcpStream :: connect (& addr) . await ? ; let (mut read_half , mut write_half) = stream . split () ; let mut read_buf = [0u8 ; 32] ; let peek_len1 = read_half . peek (& mut read_buf [..]) . await ? ; let peek_len2 = read_half . peek (& mut read_buf [..]) . await ? ; assert_eq ! (peek_len1 , peek_len2) ; let read_len = read_half . read (& mut read_buf [..]) . await ? ; assert_eq ! (peek_len1 , read_len) ; assert_eq ! (& read_buf [.. read_len] , MSG) ; assert_eq ! (write_half . write (MSG) . await ?, MSG . len ()) ; handle . join () . unwrap () ; Ok (()) } . sig",
                        "file_path": "tokio/tests/tcp_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_until_internal",
                        "label": "read_until_internal",
                        "kind": "Function",
                        "signature": "fn pub (super) fn read_until_internal < R : AsyncBufRead + ? Sized > (mut reader : Pin < & mut R > , cx : & mut Context < '_ > , delimiter : u8 , buf : & mut Vec < u8 > , read : & mut usize ,) -> Poll < io :: Result < usize > > { loop { let (done , used) = { let available = ready ! (reader . as_mut () . poll_fill_buf (cx)) ? ; if let Some (i) = memchr :: memchr (delimiter , available) { buf . extend_from_slice (& available [..= i]) ; (true , i + 1) } else { buf . extend_from_slice (available) ; (false , available . len ()) } } ; reader . as_mut () . consume (used) ; * read += used ; if done || used == 0 { return Poll :: Ready (Ok (mem :: replace (read , 0))) ; } } } . sig",
                        "file_path": "tokio/src/io/util/read_until.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "into_inner",
                        "label": "into_inner",
                        "kind": "Function",
                        "signature": "fn # [test] fn into_inner () { let rwlock = RwLock :: new (42) ; assert_eq ! (rwlock . into_inner () , 42) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Spawn",
                        "label": "Spawn",
                        "kind": "Struct",
                        "signature": "struct Spawn",
                        "file_path": "tokio-test/src/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "can_shutdown_with_zero_timeout_in_runtime",
                        "label": "can_shutdown_with_zero_timeout_in_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn can_shutdown_with_zero_timeout_in_runtime () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . shutdown_timeout (Duration :: from_nanos (0)) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_in_place_panic_caller",
                        "label": "block_in_place_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn block_in_place_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; rt . block_on (async { block_in_place (| | { }) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_size_biased",
                        "label": "join_size_biased",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn join_size_biased () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (0i32) ; tokio :: join ! (biased ; ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 24) ; let fut = async { let ready1 = future :: ready (0i32) ; let ready2 = future :: ready (0i32) ; tokio :: join ! (biased ; ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 40) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_notify_on_respawn_if_open",
                        "label": "no_notify_on_respawn_if_open",
                        "kind": "Function",
                        "signature": "fn # [test] fn no_notify_on_respawn_if_open () { let tracker = TaskTracker :: new () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; let token2 = tracker . token () ; assert_pending ! (wait . poll ()) ; drop (token2) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_now_in_block_in_place",
                        "label": "yield_now_in_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_now_in_block_in_place () { let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { tokio :: spawn (async { tokio :: task :: block_in_place (| | { tokio :: runtime :: Handle :: current () . block_on (tokio :: task :: yield_now ()) ; }) }) . await . unwrap () }) } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wait_for_test",
                        "label": "wait_for_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn wait_for_test () { loom :: model (move | | { let (tx , mut rx) = watch :: channel (false) ; let tx_arc = Arc :: new (tx) ; let tx1 = tx_arc . clone () ; let tx2 = tx_arc . clone () ; let th1 = thread :: spawn (move | | { for _ in 0 .. 2 { tx1 . send_modify (| _x | { }) ; } }) ; let th2 = thread :: spawn (move | | { tx2 . send (true) . unwrap () ; }) ; assert_eq ! (* block_on (rx . wait_for (| x | * x)) . unwrap () , true) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line_internal",
                        "label": "read_line_internal",
                        "kind": "Function",
                        "signature": "fn pub (super) fn read_line_internal < R : AsyncBufRead + ? Sized > (reader : Pin < & mut R > , cx : & mut Context < '_ > , output : & mut String , buf : & mut Vec < u8 > , read : & mut usize ,) -> Poll < io :: Result < usize > > { let io_res = ready ! (read_until_internal (reader , cx , b'\\n' , buf , read)) ; let utf8_res = String :: from_utf8 (mem :: take (buf)) ; debug_assert ! (buf . is_empty ()) ; debug_assert ! (output . is_empty ()) ; finish_string_read (io_res , utf8_res , * read , output , false) } . sig",
                        "file_path": "tokio/src/io/util/read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_buf",
                        "label": "try_read_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_buf () -> std :: io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"try_read_write_vectored\") ? ; let reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; let mut write_data = Vec :: new () ; while writable_by_poll (& writer) { match writer . try_write (DATA) { Ok (n) => write_data . extend (& DATA [.. n]) , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } let mut read_data = vec ! [0 ; write_data . len ()] ; let mut i = 0 ; while i < write_data . len () { reader . readable () . await ? ; match reader . try_read_buf (& mut read_data) { Ok (n) => i += n , Err (e) => { assert_eq ! (e . kind () , io :: ErrorKind :: WouldBlock) ; continue ; } } } assert_eq ! (read_data , write_data) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_weak_count_when_downgraded",
                        "label": "sender_weak_count_when_downgraded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_weak_count_when_downgraded () { let (tx , _rx) = mpsc :: channel :: < () > (1) ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalOwnedTasks",
                        "label": "LocalOwnedTasks",
                        "kind": "Struct",
                        "signature": "struct LocalOwnedTasks",
                        "file_path": "tokio/src/runtime/task/list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ThreadId",
                        "label": "ThreadId",
                        "kind": "Struct",
                        "signature": "struct ThreadId",
                        "file_path": "tokio/src/runtime/thread_id.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "spawn_wakes_localset",
                        "label": "spawn_wakes_localset",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn spawn_wakes_localset () { let local = LocalSet :: new () ; futures :: select ! { _ = local . run_until (pending ::< () > ()) . fuse () => unreachable ! () , ret = async { local . spawn_local (ready (())) . await . unwrap () } . fuse () => ret } } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stream_with_interval_poll_tick_self_waking",
                        "label": "stream_with_interval_poll_tick_self_waking",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn stream_with_interval_poll_tick_self_waking () { let stream = IntervalStreamer { counter : 0 , timer : tokio :: time :: interval (tokio :: time :: Duration :: from_millis (10)) , wake_on_pending : true , } ; let (res_tx , mut res_rx) = tokio :: sync :: mpsc :: channel (12) ; tokio :: spawn (tokio :: time :: timeout (tokio :: time :: Duration :: from_millis (150) , async move { tokio :: pin ! (stream) ; while let Some (item) = stream . next () . await { res_tx . send (item) . await . ok () ; } } ,)) ; let mut items = Vec :: with_capacity (3) ; while let Some (result) = res_rx . recv () . await { items . push (result) ; } assert_eq ! (items , vec ! [4 , 8 , 12]) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_sleep_to_past",
                        "label": "reset_sleep_to_past",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_sleep_to_past () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; time :: sleep (ms (50)) . await ; assert ! (! sleep . is_woken ()) ; sleep . as_mut () . reset (now + ms (40)) ; assert_ready ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_with_handle",
                        "label": "write_with_handle",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_with_handle () { let (mut mock , mut handle) = Builder :: new () . build_with_handle () ; handle . write (b\"hello \") ; handle . write (b\"world!\") ; mock . write_all (b\"hello \") . await . expect (\"write 1\") ; mock . write_all (b\"world!\") . await . expect (\"write 2\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_or_try_init",
                        "label": "get_or_try_init",
                        "kind": "Function",
                        "signature": "fn # [test] fn get_or_try_init () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let handle1 = rt . spawn (async { ONCE . get_or_try_init (func_err) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_try_init (func_ok) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; time :: resume () ; let result1 = handle1 . await . unwrap () ; assert ! (result1 . is_err ()) ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result2 . unwrap () , 10) ; }) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_after_remove_last",
                        "label": "wake_after_remove_last",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn wake_after_remove_last () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let key = queue . insert (\"foo\" , ms (1000)) ; assert_pending ! (poll ! (queue)) ; queue . remove (& key) ; assert ! (queue . is_woken ()) ; assert ! (assert_ready ! (poll ! (queue)) . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "to_string_appends",
                        "label": "to_string_appends",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn to_string_appends () { let data = b\"def\" . to_vec () ; let mut s = \"abc\" . to_string () ; let len = AsyncReadExt :: read_to_string (& mut data . as_slice () , & mut s) . await . unwrap () ; assert_eq ! (len , 3) ; assert_eq ! (s , \"abcdef\") ; } . sig",
                        "file_path": "tokio/tests/io_read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AmbiguousIfSend",
                        "label": "AmbiguousIfSend",
                        "kind": "Trait",
                        "signature": "trait AmbiguousIfSend",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "mut_load",
                        "label": "mut_load",
                        "kind": "Function",
                        "signature": "fn fn mut_load (this : & mut AtomicUsize) -> usize { this . with_mut (| v | * v) } . sig",
                        "file_path": "tokio/src/sync/oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_ready",
                        "label": "poll_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_ready () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { assert_ok ! (poll_fn (| cx | client . poll_send_ready (cx)) . await) ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { assert_ok ! (poll_fn (| cx | server . poll_recv_ready (cx)) . await) ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_closed_permits_send",
                        "label": "size_hint_stream_closed_permits_send",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_closed_permits_send () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; let permit1 = tx . reserve () . await . unwrap () ; let permit2 = tx . reserve () . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (1 , Some (3))) ; permit1 . send (2) ; assert_eq ! (stream . size_hint () , (2 , Some (3))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (1))) ; permit2 . send (3) ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending_buf_read",
                        "label": "maybe_pending_buf_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending_buf_read () { let inner = MaybePending :: new (& [0 , 1 , 2 , 3 , 1 , 0]) ; let mut reader = BufReader :: with_capacity (2 , inner) ; let mut v = Vec :: new () ; reader . read_until (3 , & mut v) . await . unwrap () ; assert_eq ! (v , [0 , 1 , 2 , 3]) ; v . clear () ; reader . read_until (1 , & mut v) . await . unwrap () ; assert_eq ! (v , [1]) ; v . clear () ; reader . read_until (8 , & mut v) . await . unwrap () ; assert_eq ! (v , [0]) ; v . clear () ; reader . read_until (9 , & mut v) . await . unwrap () ; assert_eq ! (v , []) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Tester",
                        "label": "Tester",
                        "kind": "Struct",
                        "signature": "struct Tester",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic_usage () { let mut waker = task :: spawn (AtomicWaker :: new ()) ; waker . enter (| cx , waker | waker . register_by_ref (cx . waker ())) ; waker . wake () ; assert ! (waker . is_woken ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_one_drop",
                        "label": "notified_multi_notify_one_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_one_drop () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; let mut notified3 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_one () ; drop (notified1) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split_owned",
                        "label": "split_owned",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn split_owned (stream : UnixStream) -> (OwnedReadHalf , OwnedWriteHalf) { let arc = Arc :: new (stream) ; let read = OwnedReadHalf { inner : Arc :: clone (& arc) , } ; let write = OwnedWriteHalf { inner : arc , shutdown_on_drop : true , } ; (read , write) } . sig",
                        "file_path": "tokio/src/net/unix/split_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_at_timer_wheel_threshold",
                        "label": "remove_at_timer_wheel_threshold",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Regression test: it should be possible to remove entries which fall in the\"] # [doc = \" 0th slot of the internal timer wheel — that is, entries whose expiration\"] # [doc = \" (a) falls at the beginning of one of the wheel's hierarchical levels and (b)\"] # [doc = \" is equal to the wheel's current elapsed time.\"] # [tokio :: test] async fn remove_at_timer_wheel_threshold () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key1 = queue . insert_at (\"foo\" , now + ms (64)) ; let key2 = queue . insert_at (\"bar\" , now + ms (64)) ; sleep (ms (80)) . await ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; match entry { \"foo\" => { let entry = queue . remove (& key2) . into_inner () ; assert_eq ! (entry , \"bar\") ; } \"bar\" => { let entry = queue . remove (& key1) . into_inner () ; assert_eq ! (entry , \"foo\") ; } other => panic ! (\"other: {other:?}\") , } } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "twice",
                        "label": "twice",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn twice () { let kind = SignalKind :: user_defined1 () ; let mut sig = signal (kind) . expect (\"failed to get signal\") ; for _ in 0 .. 2 { send_signal (libc :: SIGUSR1) ; assert ! (sig . recv () . await . is_some ()) ; } } . sig",
                        "file_path": "tokio/tests/signal_twice.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_buffered_reader",
                        "label": "test_buffered_reader",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_buffered_reader () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , inner) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 3) ; assert_eq ! (buf , [5 , 6 , 7]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 2) ; assert_eq ! (buf , [0 , 1]) ; assert_eq ! (reader . buffer () , []) ; let mut buf = [0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [2]) ; assert_eq ! (reader . buffer () , [3]) ; let mut buf = [0 , 0 , 0] ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [3 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; let nread = reader . read (& mut buf) . await . unwrap () ; assert_eq ! (nread , 1) ; assert_eq ! (buf , [4 , 0 , 0]) ; assert_eq ! (reader . buffer () , []) ; assert_eq ! (reader . read (& mut buf) . await . unwrap () , 0) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "localset_future_threadpool",
                        "label": "localset_future_threadpool",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn localset_future_threadpool () { thread_local ! { static ON_LOCAL_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_LOCAL_THREAD . with (| cell | cell . set (true)) ; let local = LocalSet :: new () ; local . spawn_local (async move { assert ! (ON_LOCAL_THREAD . with (| cell | cell . get ())) ; }) ; local . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage_v4",
                        "label": "basic_usage_v4",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage_v4 () { let addr = assert_ok ! (\"127.0.0.1:0\" . parse ()) ; let srv = assert_ok ! (TcpSocket :: new_v4 ()) ; assert_ok ! (srv . bind (addr)) ; let srv = assert_ok ! (srv . listen (128)) ; let addr = srv . local_addr () . unwrap () ; let cli = assert_ok ! (TcpSocket :: new_v4 ()) ; let _cli = assert_ok ! (cli . connect (addr) . await) ; let _ = assert_ok ! (srv . accept () . await) ; } . sig",
                        "file_path": "tokio/tests/tcp_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending_buf_writer",
                        "label": "maybe_pending_buf_writer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer () { let mut writer = BufWriter :: with_capacity (2 , MaybePending :: new (Vec :: new ())) ; assert_eq ! (writer . write (& [0 , 1]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; assert_eq ! (writer . write (& [2]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; assert_eq ! (writer . write (& [3]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [2 , 3]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [4]) . await . unwrap () , 1) ; assert_eq ! (writer . write (& [5]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [4 , 5]) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3]) ; assert_eq ! (writer . write (& [6]) . await . unwrap () , 1) ; assert_eq ! (writer . buffer () , [6]) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5]) ; assert_eq ! (writer . write (& [7 , 8]) . await . unwrap () , 2) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8]) ; assert_eq ! (writer . write (& [9 , 10 , 11]) . await . unwrap () , 3) ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; writer . flush () . await . unwrap () ; assert_eq ! (writer . buffer () , []) ; assert_eq ! (& writer . get_ref () . inner , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontended_concurrent_single",
                        "label": "uncontended_concurrent_single",
                        "kind": "Function",
                        "signature": "fn fn uncontended_concurrent_single (g : & mut BenchmarkGroup < WallTime >) { let rt = single_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"concurrent_single\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { tokio :: join ! { task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) , task (s . clone ()) } ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedRwLockMappedWriteGuard",
                        "label": "OwnedRwLockMappedWriteGuard",
                        "kind": "Struct",
                        "signature": "struct OwnedRwLockMappedWriteGuard",
                        "file_path": "tokio/src/sync/rwlock/owned_write_guard_mapped.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "join_handle_cancel_on_shutdown",
                        "label": "join_handle_cancel_on_shutdown",
                        "kind": "Function",
                        "signature": "fn # [test] fn join_handle_cancel_on_shutdown () { let mut builder = loom :: model :: Builder :: new () ; builder . preemption_bound = Some (2) ; builder . check (| | { use futures :: future :: FutureExt ; let rt = Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () ; let handle = rt . block_on (async move { Handle :: current () }) ; let jh1 = handle . spawn (futures :: future :: pending :: < () > ()) ; drop (rt) ; let jh2 = handle . spawn (futures :: future :: pending :: < () > ()) ; let err1 = jh1 . now_or_never () . unwrap () . unwrap_err () ; let err2 = jh2 . now_or_never () . unwrap () . unwrap_err () ; assert ! (err1 . is_cancelled ()) ; assert ! (err2 . is_cancelled ()) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "kill_after_wait",
                        "label": "kill_after_wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn kill_after_wait () { let mut cmd ; if cfg ! (windows) { cmd = Command :: new (\"cmd\") ; cmd . arg (\"/c\") ; } else { cmd = Command :: new (\"sh\") ; cmd . arg (\"-c\") ; } let mut child = cmd . arg (\"exit 2\") . spawn () . unwrap () ; child . start_kill () . unwrap () ; child . wait () . await . unwrap () ; child . start_kill () . unwrap () ; child . kill () . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/process_kill_after_wait.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "future_and_timeout_in_future",
                        "label": "future_and_timeout_in_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn future_and_timeout_in_future () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let mut fut = task :: spawn (timeout (ms (100) , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (90)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write",
                        "label": "write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write () { struct Wr { buf : BytesMut , cnt : usize , } impl AsyncWrite for Wr { fn poll_write (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { assert_eq ! (self . cnt , 0) ; self . buf . extend (& buf [0 .. 4]) ; Ok (4) . into () } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , cnt : 0 , } ; let n = assert_ok ! (wr . write (b\"hello world\") . await) ; assert_eq ! (n , 4) ; assert_eq ! (wr . buf , b\"hell\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unconstrained",
                        "label": "unconstrained",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Turn off cooperative scheduling for a future. The future will never be forced to yield by\"] # [doc = \" Tokio. Using this exposes your service to starvation if the unconstrained future never yields\"] # [doc = \" otherwise.\"] # [doc = \"\"] # [doc = \" See also the usage example in the [task module](index.html#unconstrained).\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub fn unconstrained < F > (inner : F) -> Unconstrained < F > { Unconstrained { inner } } . sig",
                        "file_path": "tokio/src/task/coop/unconstrained.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "budget",
                        "label": "budget",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn budget < R > (f : impl FnOnce (& Cell < coop :: Budget >) -> R) -> Result < R , AccessError > { CONTEXT . try_with (| ctx | f (& ctx . budget)) } . sig",
                        "file_path": "tokio/src/runtime/context.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "actor_weak_sender",
                        "label": "actor_weak_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn actor_weak_sender () { pub struct MyActor { receiver : mpsc :: Receiver < ActorMessage > , sender : mpsc :: WeakSender < ActorMessage > , next_id : u32 , pub received_self_msg : bool , } enum ActorMessage { GetUniqueId { respond_to : oneshot :: Sender < u32 > } , SelfMessage { } , } impl MyActor { fn new (receiver : mpsc :: Receiver < ActorMessage > , sender : mpsc :: WeakSender < ActorMessage > ,) -> Self { MyActor { receiver , sender , next_id : 0 , received_self_msg : false , } } fn handle_message (& mut self , msg : ActorMessage) { match msg { ActorMessage :: GetUniqueId { respond_to } => { self . next_id += 1 ; let _ = respond_to . send (self . next_id) ; } ActorMessage :: SelfMessage { .. } => { self . received_self_msg = true ; } } } async fn send_message_to_self (& mut self) { let msg = ActorMessage :: SelfMessage { } ; let sender = self . sender . clone () ; if let Some (sender) = sender . upgrade () { let _ = sender . send (msg) . await ; self . sender = sender . downgrade () ; } } async fn run (& mut self) { let mut i = 0 ; while let Some (msg) = self . receiver . recv () . await { self . handle_message (msg) ; if i == 0 { self . send_message_to_self () . await ; } i += 1 } assert ! (self . received_self_msg) ; } } # [derive (Clone)] pub struct MyActorHandle { sender : mpsc :: Sender < ActorMessage > , } impl MyActorHandle { pub fn new () -> (Self , MyActor) { let (sender , receiver) = mpsc :: channel (8) ; let actor = MyActor :: new (receiver , sender . clone () . downgrade ()) ; (Self { sender } , actor) } pub async fn get_unique_id (& self) -> u32 { let (send , recv) = oneshot :: channel () ; let msg = ActorMessage :: GetUniqueId { respond_to : send } ; let _ = self . sender . send (msg) . await ; recv . await . expect (\"Actor task has been killed\") } } let (handle , mut actor) = MyActorHandle :: new () ; let actor_handle = tokio :: spawn (async move { actor . run () . await }) ; let _ = tokio :: spawn (async move { let _ = handle . get_unique_id () . await ; drop (handle) ; }) . await ; let _ = actor_handle . await ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink_metadata",
                        "label": "symlink_metadata",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Queries the file system metadata for a path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::symlink_metadata`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::symlink_metadata\"] pub async fn symlink_metadata (path : impl AsRef < Path >) -> io :: Result < Metadata > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: symlink_metadata (path)) . await } . sig",
                        "file_path": "tokio/src/fs/symlink_metadata.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OnClose",
                        "label": "OnClose",
                        "kind": "Struct",
                        "signature": "struct OnClose",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_multi_thread_with_start_paused",
                        "label": "test_multi_thread_with_start_paused",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , start_paused = false)] async fn test_multi_thread_with_start_paused () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "debug_format",
                        "label": "debug_format",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn debug_format () { let s = \"debug\" ; let m = Arc :: new (Mutex :: new (s . to_string ())) ; assert_eq ! (format ! (\"{s:?}\") , format ! (\"{:?}\" , m . lock_owned () . await)) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U32Encoder",
                        "label": "U32Encoder",
                        "kind": "Struct",
                        "signature": "struct U32Encoder",
                        "file_path": "tokio-util/tests/framed_write.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "collect_string_items",
                        "label": "collect_string_items",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn collect_string_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < String > ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"hello \" . to_string ()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (\"world\" . to_string ()) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (\"hello world\" , coll) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_contention",
                        "label": "bench_contention",
                        "kind": "Function",
                        "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contended_concurrent_multi (& mut group) ; contended_concurrent_single (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Invalid",
                        "label": "Invalid",
                        "kind": "Struct",
                        "signature": "struct Invalid",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "resubscribe_lagged",
                        "label": "resubscribe_lagged",
                        "kind": "Function",
                        "signature": "fn # [test] fn resubscribe_lagged () { let (tx , mut rx) = broadcast :: channel (1) ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut rx_resub = rx . resubscribe () ; assert_lagged ! (rx . try_recv () , 1) ; assert_empty ! (rx_resub) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_empty ! (rx) ; assert_empty ! (rx_resub) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "alternating",
                        "label": "alternating",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn alternating () { let mut set = JoinSet :: new () ; assert_eq ! (set . len () , 0) ; set . spawn (async { }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { }) ; assert_eq ! (set . len () , 2) ; for _ in 0 .. 16 { let () = set . join_next () . await . unwrap () . unwrap () ; assert_eq ! (set . len () , 1) ; set . spawn (async { }) ; assert_eq ! (set . len () , 2) ; } } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "incomplete_read_followed_by_write",
                        "label": "incomplete_read_followed_by_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn incomplete_read_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; file . expect_inner_write () . once () . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_pair",
                        "label": "create_pair",
                        "kind": "Function",
                        "signature": "fn async fn create_pair () -> (TcpStream , TcpStream) { let listener = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (listener . local_addr ()) ; let (client , (server , _)) = assert_ok ! (try_join ! (TcpStream :: connect (& addr) , listener . accept ())) ; (client , server) } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mask_for",
                        "label": "mask_for",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns a `usize` with the right-most `n` bits set.\"] pub (crate) const fn mask_for (n : u32) -> usize { let shift = 1usize . wrapping_shl (n - 1) ; shift | (shift - 1) } . sig",
                        "file_path": "tokio/src/util/bit.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_spawn",
                        "label": "try_send_spawn",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_send_spawn () { const MSG2 : & [u8] = b\"world!\" ; const MSG2_LEN : usize = MSG2 . len () ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; receiver . connect (sender . local_addr () . unwrap ()) . await . unwrap () ; sender . writable () . await . unwrap () ; let sent = & sender . try_send_to (MSG , receiver . local_addr () . unwrap ()) . unwrap () ; assert_eq ! (sent , & MSG_LEN) ; let mut buf = [0u8 ; 32] ; let mut received = receiver . recv (& mut buf [..]) . await . unwrap () ; sender . connect (receiver . local_addr () . unwrap ()) . await . unwrap () ; let sent = & sender . try_send (MSG2) . unwrap () ; assert_eq ! (sent , & MSG2_LEN) ; received += receiver . recv (& mut buf [..]) . await . unwrap () ; std :: thread :: spawn (move | | { let sent = & sender . try_send (MSG) . unwrap () ; assert_eq ! (sent , & MSG_LEN) ; }) . join () . unwrap () ; received += receiver . recv (& mut buf [..]) . await . unwrap () ; assert_eq ! (received , MSG_LEN * 2 + MSG2_LEN) ; } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "enter_guard_spawn",
                        "label": "enter_guard_spawn",
                        "kind": "Function",
                        "signature": "fn # [test] fn enter_guard_spawn () { let local = LocalSet :: new () ; let _guard = local . enter () ; let join = task :: spawn_local (async { true }) ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; local . block_on (& rt , async move { assert ! (join . await . unwrap ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedMutexGuard",
                        "label": "OwnedMutexGuard",
                        "kind": "Struct",
                        "signature": "struct OwnedMutexGuard",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "WatchStream",
                        "label": "WatchStream",
                        "kind": "Struct",
                        "signature": "struct WatchStream",
                        "file_path": "tokio-stream/src/wrappers/watch.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_terminated_try_recv",
                        "label": "receiver_is_terminated_try_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_terminated_try_recv () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after value is sent\") ; let value = rx . try_recv () . expect (\"value is waiting\") ; assert_eq ! (value , 17) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_and_one",
                        "label": "notify_waiters_and_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_waiters_and_one () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let tx1 = notify . clone () ; let tx2 = notify . clone () ; let th1 = thread :: spawn (move | | { tx1 . notify_waiters () ; }) ; let th2 = thread :: spawn (move | | { tx2 . notify_one () ; }) ; let th3 = thread :: spawn (move | | { let notified = notify . notified () ; block_on (async { notified . await ; }) ; }) ; th1 . join () . unwrap () ; th2 . join () . unwrap () ; th3 . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LengthDelimitedCodecError",
                        "label": "LengthDelimitedCodecError",
                        "kind": "Struct",
                        "signature": "struct LengthDelimitedCodecError",
                        "file_path": "tokio-util/src/codec/length_delimited.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "BlockHeader",
                        "label": "BlockHeader",
                        "kind": "Struct",
                        "signature": "struct BlockHeader",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AssertSync",
                        "label": "AssertSync",
                        "kind": "Trait",
                        "signature": "trait AssertSync",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "bench_send",
                        "label": "bench_send",
                        "kind": "Function",
                        "signature": "fn fn bench_send (c : & mut Criterion) { let mut group = c . benchmark_group (\"send\") ; send_data :: < Medium , 1000 > (& mut group , \"medium\") ; send_data :: < Large , 1000 > (& mut group , \"large\") ; group . finish () ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_wait",
                        "label": "try_wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_wait () { let mut child = cat () . spawn () . unwrap () ; let id = child . id () . expect (\"missing id\") ; assert ! (id > 0) ; assert_eq ! (None , assert_ok ! (child . try_wait ())) ; drop (child . stdin . take ()) ; drop (child . stderr . take ()) ; drop (child . stdout . take ()) ; assert_ok ! (child . wait () . await) ; assert ! (assert_ok ! (child . try_wait ()) . unwrap () . success ()) ; assert_eq ! (child . id () , None) ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_closed",
                        "label": "recv_closed",
                        "kind": "Function",
                        "signature": "fn # [test] fn recv_closed () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { let _ = tx . send (1) ; }) ; rx . close () ; let _ = block_on (rx) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval_at",
                        "label": "interval_at",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates new [`Interval`] that yields with interval of `period` with the\"] # [doc = \" first tick completing at `start`. The default [`MissedTickBehavior`] is\"] # [doc = \" [`Burst`](MissedTickBehavior::Burst), but this can be configured\"] # [doc = \" by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\"] # [doc = \"\"] # [doc = \" An interval will tick indefinitely. At any time, the [`Interval`] value can\"] # [doc = \" be dropped. This cancels the interval.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if `period` is zero.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{interval_at, Duration, Instant};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let start = Instant::now() + Duration::from_millis(50);\"] # [doc = \" let mut interval = interval_at(start, Duration::from_millis(10));\"] # [doc = \"\"] # [doc = \" interval.tick().await; // ticks after 50ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \" interval.tick().await; // ticks after 10ms\"] # [doc = \"\"] # [doc = \" // approximately 70ms have elapsed.\"] # [doc = \" # }\"] # [doc = \" ```\"] # [track_caller] pub fn interval_at (start : Instant , period : Duration) -> Interval { assert ! (period > Duration :: new (0 , 0) , \"`period` must be non-zero.\") ; internal_interval_at (start , period , trace :: caller_location ()) } . sig",
                        "file_path": "tokio/src/time/interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "YY",
                        "label": "YY",
                        "kind": "Struct",
                        "signature": "struct YY",
                        "file_path": "tokio/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_io_readable",
                        "label": "try_io_readable",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_io_readable () { let (a , mut b) = socketpair () ; let mut afd_a = AsyncFd :: new (a) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io_mut (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket should not be readable\") ; } b . write_all (& [0]) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (called , \"closure should have been called, since socket should have data available to read\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ()) }) ; assert ! (called , \"closure should have been called, since socket should have data available to read\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: READABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket readable state should have been cleared\") ; } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_terminated_send",
                        "label": "receiver_is_terminated_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_terminated_send () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated after value is sent\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_eq ! (poll , Ok (17)) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_rx_closes_channel_for_try",
                        "label": "dropping_rx_closes_channel_for_try",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_rx_closes_channel_for_try () { let (tx , rx) = mpsc :: channel (100) ; let msg = Arc :: new (()) ; tx . try_send (msg . clone ()) . unwrap () ; drop (rx) ; assert ! (matches ! (tx . try_send (msg . clone ()) , Err (TrySendError :: Closed (_)))) ; assert ! (matches ! (tx . try_reserve () , Err (TrySendError :: Closed (_)))) ; assert ! (matches ! (tx . try_reserve_owned () , Err (TrySendError :: Closed (_)))) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_empty_rx_close",
                        "label": "receiver_is_empty_rx_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_empty_rx_close () { let (_tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty ()) ; rx . close () ; assert ! (rx . is_empty ()) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_enter_current_thread_rt_from_within_block_in_place",
                        "label": "can_enter_current_thread_rt_from_within_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn can_enter_current_thread_rt_from_within_block_in_place () { let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; outer . block_on (async { tokio :: task :: block_in_place (| | { let inner = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; inner . block_on (async { }) }) }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "weak_unbounded_sender",
                        "label": "weak_unbounded_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn weak_unbounded_sender () { let (tx , mut rx) = unbounded_channel () ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Some (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } None => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "store_local_set_in_thread_local_with_runtime",
                        "label": "store_local_set_in_thread_local_with_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn store_local_set_in_thread_local_with_runtime () { use tokio :: runtime :: Runtime ; thread_local ! { static CURRENT : RtAndLocalSet = RtAndLocalSet :: new () ; } struct RtAndLocalSet { rt : Runtime , local : LocalSet , } impl RtAndLocalSet { fn new () -> RtAndLocalSet { RtAndLocalSet { rt : tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () , local : LocalSet :: new () , } } async fn inner_method (& self) { self . local . run_until (async move { tokio :: task :: spawn_local (async { }) ; }) . await } fn method (& self) { self . rt . block_on (self . inner_method ()) ; } } CURRENT . with (| f | { f . method () ; }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_write_ready",
                        "label": "poll_write_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_write_ready () { let (mut client , server) = create_pair () . await ; assert_writable_by_polling ! (client) ; write_until_pending (& mut client) ; assert_not_writable_by_polling ! (client) ; drop (server) ; assert_writable_by_polling ! (client) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "deadline_now_elapses",
                        "label": "deadline_now_elapses",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn deadline_now_elapses () { use futures :: future :: pending ; time :: pause () ; let mut fut = task :: spawn (timeout_at (Instant :: now () , pending :: < () > ())) ; time :: advance (ms (1)) . await ; assert_ready_err ! (fut . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_into_std",
                        "label": "write_into_std",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_into_std () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut std_file = file . into_std () . await ; std_file . write_all (HELLO) . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "make_future",
                        "label": "make_future",
                        "kind": "Function",
                        "signature": "fn async fn make_future (mut rx : Receiver < () >) -> Receiver < () > { rx . changed () . await . expect (\"signal sender went away\") ; rx } . sig",
                        "file_path": "tokio/src/signal/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_writable",
                        "label": "poll_writable",
                        "kind": "Function",
                        "signature": "fn async fn poll_writable < T : AsRawFd > (fd : & AsyncFd < T >) -> std :: io :: Result < AsyncFdReadyGuard < '_ , T > > { std :: future :: poll_fn (| cx | fd . poll_write_ready (cx)) . await } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_loops_does_not_cause_starvation",
                        "label": "dropping_loops_does_not_cause_starvation",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_loops_does_not_cause_starvation () { let kind = SignalKind :: user_defined1 () ; let first_rt = rt () ; let mut first_signal = first_rt . block_on (async { signal (kind) . expect (\"failed to register first signal\") }) ; let second_rt = rt () ; let mut second_signal = second_rt . block_on (async { signal (kind) . expect (\"failed to register second signal\") }) ; send_signal (libc :: SIGUSR1) ; first_rt . block_on (first_signal . recv ()) . expect (\"failed to await first signal\") ; drop (first_rt) ; drop (first_signal) ; send_signal (libc :: SIGUSR1) ; second_rt . block_on (second_signal . recv ()) ; } . sig",
                        "file_path": "tokio/tests/signal_drop_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "buf_writer_seek",
                        "label": "buf_writer_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn buf_writer_seek () { let mut w = BufWriter :: with_capacity (3 , Cursor :: new (Vec :: new ())) ; w . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await . unwrap () ; w . write_all (& [6 , 7]) . await . unwrap () ; assert_eq ! (w . seek (SeekFrom :: Current (0)) . await . unwrap () , 8) ; assert_eq ! (& w . get_ref () . get_ref () [..] , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7] [..]) ; assert_eq ! (w . seek (SeekFrom :: Start (2)) . await . unwrap () , 2) ; w . write_all (& [8 , 9]) . await . unwrap () ; w . flush () . await . unwrap () ; assert_eq ! (& w . into_inner () . into_inner () [..] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_closed_when_there_are_messages_and_close_is_called",
                        "label": "test_rx_unbounded_is_closed_when_there_are_messages_and_close_is_called",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_there_are_messages_and_close_is_called () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Copy",
                        "label": "Copy",
                        "kind": "Struct",
                        "signature": "struct Copy",
                        "file_path": "tokio/src/io/util/copy.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "async_fd_new_panic_caller",
                        "label": "async_fd_new_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] fn async_fd_new_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: io :: unix :: AsyncFd ; use tokio :: runtime :: Builder ; let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let fd = unix :: MockFd ; let _ = AsyncFd :: new (fd) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_direct_sink_writer",
                        "label": "test_direct_sink_writer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_direct_sink_writer () -> Result < () , Error > { let framed_byte_lc = FramedWrite :: new (Vec :: new () , SliceEncoder :: new ()) ; let mut writer = SinkWriter :: new (framed_byte_lc) ; let _ = writer . write (& [1 , 2 , 3]) . await ; let _ = writer . write (& [4 , 5 , 6]) . await ; assert_eq ! (writer . into_inner () . write_buffer () . to_vec () . as_slice () , & [1 , 2 , 3 , 4 , 5 , 6]) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sink_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BadAsyncRead",
                        "label": "BadAsyncRead",
                        "kind": "Struct",
                        "signature": "struct BadAsyncRead",
                        "file_path": "tokio/tests/io_read.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unawaited_blocking_task_wakes_paused_runtime",
                        "label": "unawaited_blocking_task_wakes_paused_runtime",
                        "kind": "Function",
                        "signature": "fn # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn unawaited_blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; let a = task :: spawn_blocking (| | { thread :: sleep (Duration :: from_millis (1)) ; }) ; crate :: time :: sleep (Duration :: from_secs (15)) . await ; a . await . expect (\"blocking task should finish\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "parse_int",
                        "label": "parse_int",
                        "kind": "Function",
                        "signature": "fn fn parse_int (int : syn :: Lit , span : Span , field : & str) -> Result < usize , syn :: Error > { match int { syn :: Lit :: Int (lit) => match lit . base10_parse :: < usize > () { Ok (value) => Ok (value) , Err (e) => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as integer: {e}\") ,)) , } , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as integer.\") ,)) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_on_last_task",
                        "label": "notify_on_last_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_on_last_task () { let tracker = TaskTracker :: new () ; tracker . close () ; let token = tracker . token () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; drop (token) ; assert_ready ! (wait . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OrphanQueue",
                        "label": "OrphanQueue",
                        "kind": "Trait",
                        "signature": "trait OrphanQueue",
                        "file_path": "tokio/src/process/unix/orphan.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "local_key_with_panic_caller",
                        "label": "local_key_with_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_key_with_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . with (| _ | { }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bad_reader_fails",
                        "label": "bad_reader_fails",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn bad_reader_fails () { let mut buf = Vec :: with_capacity (10) ; BadReader :: new () . take (10) . read_buf (& mut buf) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_take.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_map_coop",
                        "label": "join_map_coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn join_map_coop () { const TASK_NUM : u32 = 1000 ; static SEM : tokio :: sync :: Semaphore = tokio :: sync :: Semaphore :: const_new (0) ; let mut map = JoinMap :: new () ; for i in 0 .. TASK_NUM { map . spawn (i , async move { SEM . add_permits (1) ; i }) ; } let _ = SEM . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; loop { match map . join_next () . now_or_never () { Some (Some ((key , Ok (i)))) => assert_eq ! (key , i) , Some (Some ((key , Err (err)))) => panic ! (\"failed[{key}]: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; continue ; } Some (None) => break , } count += 1 ; } assert ! (coop_count >= 1) ; assert_eq ! (count , TASK_NUM) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ListEntry",
                        "label": "ListEntry",
                        "kind": "Struct",
                        "signature": "struct ListEntry",
                        "file_path": "tokio/src/util/idle_notified_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "threaded",
                        "label": "threaded",
                        "kind": "Function",
                        "signature": "fn fn threaded () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "siginfo",
                        "label": "siginfo",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn siginfo () { let mut sig = signal :: unix :: signal (SignalKind :: info ()) . expect (\"installed signal handler\") ; tokio :: spawn (async { send_signal (libc :: SIGINFO) ; }) ; timeout (Duration :: from_secs (5) , sig . recv ()) . await . expect (\"received SIGINFO signal in time\") . expect (\"received SIGINFO signal\") ; } . sig",
                        "file_path": "tokio/tests/signal_info.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_multi_packet_wait",
                        "label": "read_single_frame_multi_packet_wait",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_multi_packet_wait () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , Poll :: Pending , data (b\"\\x00\\x09abc\") , Poll :: Pending , data (b\"defghi\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_pending ! (io) ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_single_frame_length_adjusted",
                        "label": "write_single_frame_length_adjusted",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_frame_length_adjusted () { let io = length_delimited :: Builder :: new () . length_adjustment (- 2) . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_many_files",
                        "label": "open_many_files",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_many_files () { fn run (rt : Runtime) { const NUM_FILES : usize = 512 ; let (_tmp_files , paths) : (Vec < NamedTempFile > , Vec < PathBuf >) = create_tmp_files (NUM_FILES) ; rt . block_on (async move { let tracker = TaskTracker :: new () ; for i in 0 .. 10_000 { let path = paths . get (i % NUM_FILES) . unwrap () . clone () ; tracker . spawn (async move { let _file = OpenOptions :: new () . read (true) . open (path) . await . unwrap () ; }) ; } tracker . close () ; tracker . wait () . await ; }) ; } for rt in rt_combinations () { run (rt ()) ; } } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_channel_stream",
                        "label": "unbounded_channel_stream",
                        "kind": "Function",
                        "signature": "fn pub fn unbounded_channel_stream < T : Unpin > () -> (UnboundedSender < T > , impl Stream < Item = T >) { let (tx , mut rx) = mpsc :: unbounded_channel () ; let stream = stream ! { while let Some (item) = rx . recv () . await { yield item ; } } ; (tx , stream) } . sig",
                        "file_path": "tokio-stream/tests/support/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "channel_stream",
                        "label": "channel_stream",
                        "kind": "Function",
                        "signature": "fn pub fn channel_stream < T : Unpin > (size : usize) -> (Sender < T > , impl Stream < Item = T >) { let (tx , rx) = mpsc :: channel (size) ; let stream = BoundedStream { recv : rx } ; (tx , stream) } . sig",
                        "file_path": "tokio/tests/support/mpsc_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_two_lit_expr_comma",
                        "label": "sync_two_lit_expr_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_comma () { let foo = tokio :: try_join ! (async { ok (1) } , async { ok (2) } ,) ; assert_eq ! (foo , Ok ((1 , 2))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } , async { ok (2) } ,) ; assert_eq ! (foo , Ok ((1 , 2))) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length_bursts",
                        "label": "lines_decoder_max_length_bursts",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length_bursts () { const MAX_LENGTH : usize = 10 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OffsetHelper",
                        "label": "OffsetHelper",
                        "kind": "Struct",
                        "signature": "struct OffsetHelper",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "multiple_waiters",
                        "label": "multiple_waiters",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multiple_waiters () { let (a , mut b) = socketpair () ; let afd_a = Arc :: new (AsyncFd :: new (a) . unwrap ()) ; let barrier = Arc :: new (tokio :: sync :: Barrier :: new (11)) ; let mut tasks = Vec :: new () ; for _ in 0 .. 10 { let afd_a = afd_a . clone () ; let barrier = barrier . clone () ; let f = async move { let notify_barrier = async { barrier . wait () . await ; futures :: future :: pending :: < () > () . await ; } ; tokio :: select ! { biased ; guard = afd_a . readable () => { tokio :: task :: yield_now () . await ; guard . unwrap () . clear_ready () } , _ = notify_barrier => unreachable ! () , } std :: mem :: drop (afd_a) ; } ; tasks . push (tokio :: spawn (f)) ; } let mut all_tasks = futures :: future :: try_join_all (tasks) ; tokio :: select ! { r = std :: pin :: Pin :: new (& mut all_tasks) => { r . unwrap () ; panic ! (\"Tasks exited unexpectedly\") } , _ = barrier . wait () => { } } b . write_all (b\"0\") . unwrap () ; all_tasks . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_uninit",
                        "label": "get_uninit",
                        "kind": "Function",
                        "signature": "fn # [test] fn get_uninit () { static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; let uninit = ONCE . get () ; assert ! (uninit . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_read_shared_drop_pending",
                        "label": "write_read_shared_drop_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_read_shared_drop_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; let mut t3 = spawn (rwlock . read ()) ; assert_pending ! (t3 . poll ()) ; drop (t2) ; assert ! (t3 . is_woken ()) ; let _t3 = assert_ready ! (t3 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "budget",
                        "label": "budget",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Runs the given closure with a cooperative task budget. When the function\"] # [doc = \" returns, the budget is reset to the value prior to calling the function.\"] # [inline (always)] pub (crate) fn budget < R > (f : impl FnOnce () -> R) -> R { with_budget (Budget :: initial () , f) } . sig",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "arg0",
                        "label": "arg0",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn arg0 () { let mut cmd = Command :: new (\"sh\") ; cmd . arg0 (\"test_string\") . arg (\"-c\") . arg (\"echo $0\") ; let output = cmd . output () . await . unwrap () ; assert_eq ! (output . stdout , b\"test_string\\n\") ; } . sig",
                        "file_path": "tokio/tests/process_arg0.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "IntervalStreamer",
                        "label": "IntervalStreamer",
                        "kind": "Struct",
                        "signature": "struct IntervalStreamer",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "compat_file_seek",
                        "label": "compat_file_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn compat_file_seek () -> futures_util :: io :: Result < () > { let temp_file = NamedTempFile :: new () ? ; let mut file = OpenOptions :: new () . read (true) . write (true) . create (true) . truncate (true) . open (temp_file) . await ? . compat_write () ; file . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await ? ; file . write_all (& [6 , 7]) . await ? ; assert_eq ! (file . stream_position () . await ?, 8) ; assert_eq ! (file . seek (SeekFrom :: Start (2)) . await ?, 2) ; file . write_all (& [8 , 9]) . await ? ; file . flush () . await ? ; assert_eq ! (file . seek (SeekFrom :: End (0)) . await ?, 8) ; file . seek (SeekFrom :: Start (0)) . await ? ; let mut buf = Vec :: new () ; let num_bytes = file . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf [.. num_bytes] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/compat.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_after_compact",
                        "label": "remove_after_compact",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: Does not seem to work with WASI\")] # [tokio :: test (start_paused = true)] # [cfg (panic = \"unwind\")] async fn remove_after_compact () { let now = Instant :: now () ; let mut queue = DelayQueue :: new () ; let foo_key = queue . insert_at (\"foo\" , now + ms (10)) ; queue . insert_at (\"bar\" , now + ms (20)) ; queue . remove (& foo_key) ; queue . compact () ; let panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . remove (& foo_key) ; })) ; assert ! (panic . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_not_ready",
                        "label": "read_not_ready",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_not_ready () { let mut task = task :: spawn (()) ; let mock = mock ! { Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Ok (b\"\\x00\\x00\\x00\\x00\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_read_codec",
                        "label": "async_read_codec",
                        "kind": "Function",
                        "signature": "fn fn async_read_codec (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_codec\" , | b | { b . iter (| | { let task = | | async { let file = File :: open (DEV_ZERO) . await . unwrap () ; let mut input_stream = FramedRead :: with_capacity (file , BytesCodec :: new () , BUFFER_SIZE) ; for _i in 0 .. BLOCK_COUNT { let _bytes = input_stream . next () . await . unwrap () ; } } ; rt . block_on (task ()) ; }) }) ; } . sig",
                        "file_path": "benches/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PointersInner",
                        "label": "PointersInner",
                        "kind": "Struct",
                        "signature": "struct PointersInner",
                        "file_path": "tokio/src/util/linked_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "WorkerMetrics",
                        "label": "WorkerMetrics",
                        "kind": "Struct",
                        "signature": "struct WorkerMetrics",
                        "file_path": "tokio/src/runtime/metrics/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reregister",
                        "label": "reregister",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reregister () { let (a , _b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let a = afd_a . into_inner () ; AsyncFd :: new (a) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_write",
                        "label": "try_write",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_write () { let lock = RwLock :: new (0) ; let read_guard = lock . read () . await ; assert ! (lock . try_write () . is_err ()) ; drop (read_guard) ; assert ! (lock . try_write () . is_ok ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_reset",
                        "label": "multi_reset",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn multi_reset () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; let two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (300)) ; queue . reset_at (& two , now + ms (350)) ; queue . reset_at (& one , now + ms (400)) ; sleep (ms (310)) . await ; assert_pending ! (poll ! (queue)) ; sleep (ms (50)) . await ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"two\") ; assert_pending ! (poll ! (queue)) ; sleep (ms (50)) . await ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"one\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_yield_many",
                        "label": "rt_multi_yield_many",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_yield_many (c : & mut Criterion) { const NUM_YIELD : usize = 1_000 ; const TASKS : usize = 200 ; c . bench_function (\"yield_many\" , | b | { let rt = rt () ; let (tx , rx) = mpsc :: sync_channel (TASKS) ; b . iter (move | | { for _ in 0 .. TASKS { let tx = tx . clone () ; rt . spawn (async move { for _ in 0 .. NUM_YIELD { tokio :: task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; } for _ in 0 .. TASKS { rx . recv () . unwrap () ; } }) }) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "add_more_than_max_amount_permits2",
                        "label": "add_more_than_max_amount_permits2",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_family = \"wasm\"))] # [test] # [should_panic] fn add_more_than_max_amount_permits2 () { let s = Semaphore :: new (Semaphore :: MAX_PERMITS - 1) ; s . add_permits (1) ; s . add_permits (1) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_with_upper",
                        "label": "size_hint_with_upper",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_hint_with_upper () { let mut map = StreamMap :: new () ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; assert_eq ! (3 , map . len ()) ; assert ! (! map . is_empty ()) ; let size_hint = map . size_hint () ; assert_eq ! (size_hint , (6 , Some (6))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_async_read_to_sync",
                        "label": "test_async_read_to_sync",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_async_read_to_sync () -> Result < () , Box < dyn Error > > { test_reader_len (tokio :: io :: empty () , 0) . await ? ; let buf = b\"hello world\" ; test_reader_len (Cursor :: new (buf) , buf . len ()) . await ? ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sync_bridge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnboundedReceiver",
                        "label": "UnboundedReceiver",
                        "kind": "Struct",
                        "signature": "struct UnboundedReceiver",
                        "file_path": "tokio/src/sync/mpsc/unbounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "abort_send_after_pending_reserve",
                        "label": "abort_send_after_pending_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn abort_send_after_pending_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; assert ! (! send . abort_send ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert ! (send . abort_send ()) ; assert_eq ! (send . get_ref () . unwrap () . capacity () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_remove_panic_caller",
                        "label": "delay_queue_remove_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_remove_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let key = queue . insert_at (\"1\" , Instant :: now ()) ; queue . remove (& key) ; queue . remove (& key) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_max_length_delimiter_between_decodes",
                        "label": "any_delimiter_decoder_max_length_delimiter_between_decodes",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_max_length_delimiter_between_decodes () { const MAX_LENGTH : usize = 5 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"hello\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\",world\") ; assert_eq ! (\"hello\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reuse_pin_box",
                        "label": "reuse_pin_box",
                        "kind": "Function",
                        "signature": "fn fn reuse_pin_box < T : ? Sized , U , O , F > (boxed : Pin < Box < T > > , new_value : U , callback : F) -> Result < O , U > where F : FnOnce (Box < U >) -> O , { let layout = Layout :: for_value :: < T > (& * boxed) ; if layout != Layout :: new :: < U > () { return Err (new_value) ; } let raw : * mut T = Box :: into_raw (unsafe { Pin :: into_inner_unchecked (boxed) }) ; let guard = CallOnDrop :: new (| | { let raw : * mut U = raw . cast :: < U > () ; unsafe { raw . write (new_value) } ; let boxed = unsafe { Box :: from_raw (raw) } ; callback (boxed) }) ; unsafe { ptr :: drop_in_place (raw) } ; Ok (guard . call ()) } . sig",
                        "file_path": "tokio-util/src/sync/reusable_box.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_data",
                        "label": "send_data",
                        "kind": "Function",
                        "signature": "fn fn send_data < T : Default , const SIZE : usize > (g : & mut BenchmarkGroup < WallTime > , prefix : & str) { let rt = rt () ; g . bench_function (format ! (\"{prefix}_{SIZE}\") , | b | { b . iter (| | { let (tx , mut rx) = mpsc :: channel :: < T > (SIZE) ; let _ = rt . block_on (tx . send (T :: default ())) ; rt . block_on (rx . recv ()) . unwrap () ; }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_create_new",
                        "label": "open_options_create_new",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_options_create_new () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . create_new (true)) . contains (\"create_new: true\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , () > { return Ok (()) ; } . sig",
                        "file_path": "tests-build/tests/pass/macros_main_return.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_arc_raw",
                        "label": "drop_arc_raw",
                        "kind": "Function",
                        "signature": "fn unsafe fn drop_arc_raw < T : Wake > (data : * const ()) { drop (Arc :: < T > :: from_raw (data . cast ())) ; } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_tx_count_weak_sender",
                        "label": "test_tx_count_weak_sender",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_tx_count_weak_sender () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none () && tx_weak2 . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rx_mark_unchanged",
                        "label": "rx_mark_unchanged",
                        "kind": "Function",
                        "signature": "fn # [test] fn rx_mark_unchanged () { let (tx , mut rx) = watch :: channel (\"one\") ; let mut rx2 = rx . clone () ; { assert ! (! rx . has_changed () . unwrap ()) ; rx . mark_changed () ; assert ! (rx . has_changed () . unwrap ()) ; rx . mark_unchanged () ; assert ! (! rx . has_changed () . unwrap ()) ; let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; } { assert ! (! rx2 . has_changed () . unwrap ()) ; tx . send (\"two\") . unwrap () ; assert ! (rx2 . has_changed () . unwrap ()) ; rx2 . mark_unchanged () ; assert ! (! rx2 . has_changed () . unwrap ()) ; assert_eq ! (* rx2 . borrow_and_update () , \"two\") ; } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_when_close_is_called",
                        "label": "test_rx_unbounded_len_when_close_is_called",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "make_acquire_future",
                        "label": "make_acquire_future",
                        "kind": "Function",
                        "signature": "fn async fn make_acquire_future < T > (data : Option < Sender < T > > ,) -> Result < OwnedPermit < T > , PollSendError < T > > { match data { Some (sender) => sender . reserve_owned () . await . map_err (| _ | PollSendError (None)) , None => unreachable ! (\"this future should not be pollable in this state\") , } } . sig",
                        "file_path": "tokio-util/src/sync/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_notify_one",
                        "label": "bench_notify_one",
                        "kind": "Function",
                        "signature": "fn fn bench_notify_one (c : & mut Criterion) { let mut group = c . benchmark_group (\"notify_one\") ; notify_one :: < 10 > (& mut group) ; notify_one :: < 50 > (& mut group) ; notify_one :: < 100 > (& mut group) ; notify_one :: < 200 > (& mut group) ; notify_one :: < 500 > (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "use_future_in_if_condition_biased",
                        "label": "use_future_in_if_condition_biased",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn use_future_in_if_condition_biased () { use tokio :: time :: { self , Duration } ; tokio :: select ! { biased ; _ = time :: sleep (Duration :: from_millis (10)) , if false => { panic ! (\"if condition ignored\") } _ = async { 1u32 } => { } } } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedRwLockReadGuard",
                        "label": "OwnedRwLockReadGuard",
                        "kind": "Struct",
                        "signature": "struct OwnedRwLockReadGuard",
                        "file_path": "tokio/src/sync/rwlock/owned_read_guard.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "next_many_empty",
                        "label": "next_many_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_empty () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; let n = stream_map . next_many (& mut vec ! [] , 1) . await ; assert_eq ! (n , 0) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_rx_closed",
                        "label": "async_rx_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_rx_closed () { let (mut tx , rx) = oneshot :: channel :: < () > () ; tokio :: spawn (async move { drop (rx) ; }) ; tx . closed () . await ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_mode_message",
                        "label": "test_named_pipe_mode_message",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_mode_message () -> io :: Result < () > { _named_pipe_mode_message (PipeMode :: Message) . await ? ; _named_pipe_mode_message (PipeMode :: Byte) . await } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_no_comma",
                        "label": "sync_one_lit_expr_no_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_no_comma () { let foo = tokio :: join ! (async { 1 }) ; assert_eq ! (foo , (1 ,)) ; let foo = tokio :: join ! (biased ; async { 1 }) ; assert_eq ! (foo , (1 ,)) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify",
                        "label": "notified_multi_notify",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_handle_is_unwind_safe",
                        "label": "join_handle_is_unwind_safe",
                        "kind": "Function",
                        "signature": "fn # [test] fn join_handle_is_unwind_safe () { is_unwind_safe :: < tokio :: task :: JoinHandle < () > > () ; } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "handle_request",
                        "label": "handle_request",
                        "kind": "Function",
                        "signature": "fn fn handle_request (line : & str , db : & Arc < Database >) -> Response { let request = match Request :: parse (line) { Ok (req) => req , Err (e) => return Response :: Error { msg : e } , } ; let mut db = db . map . lock () . unwrap () ; match request { Request :: Get { key } => match db . get (& key) { Some (value) => Response :: Value { key , value : value . clone () , } , None => Response :: Error { msg : format ! (\"no key {key}\") , } , } , Request :: Set { key , value } => { let previous = db . insert (key . clone () , value . clone ()) ; Response :: Set { key , value , previous , } } } } . sig",
                        "file_path": "examples/tinydb.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "log_histogram_default_configuration",
                        "label": "log_histogram_default_configuration",
                        "kind": "Function",
                        "signature": "fn # [test] fn log_histogram_default_configuration () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: default () ,)) . build () . unwrap () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 119) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OrphanQueueImpl",
                        "label": "OrphanQueueImpl",
                        "kind": "Struct",
                        "signature": "struct OrphanQueueImpl",
                        "file_path": "tokio/src/process/unix/orphan.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "issue_5183",
                        "label": "issue_5183",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn issue_5183 () { time :: pause () ; let big = std :: time :: Duration :: from_secs (u64 :: MAX / 10) ; # [rustfmt :: skip] tokio :: select ! { biased ; _ = tokio :: time :: sleep (big) => { } _ = tokio :: time :: sleep (std :: time :: Duration :: from_nanos (1)) => { } } } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_rx_recv",
                        "label": "single_rx_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_rx_recv () { let (tx , mut rx) = watch :: channel (\"one\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"one\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; tx . send (\"two\") . unwrap () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; { let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; drop (tx) ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_to_recv_from",
                        "label": "try_send_to_recv_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_send_to_recv_from () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { client . writable () . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await ? ; let mut buf = [0 ; 512] ; match server . try_recv_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_is_unwind_safe",
                        "label": "notify_is_unwind_safe",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_is_unwind_safe () { is_unwind_safe :: < tokio :: sync :: Notify > () ; } . sig",
                        "file_path": "tokio/tests/unwindsafe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_channel_stream",
                        "label": "unbounded_channel_stream",
                        "kind": "Function",
                        "signature": "fn pub fn unbounded_channel_stream < T : Unpin > () -> (UnboundedSender < T > , impl Stream < Item = T >) { let (tx , rx) = mpsc :: unbounded_channel () ; let stream = UnboundedStream { recv : rx } ; (tx , stream) } . sig",
                        "file_path": "tokio/tests/support/mpsc_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . build () . unwrap () } . sig",
                        "file_path": "benches/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MappedMutexGuard",
                        "label": "MappedMutexGuard",
                        "kind": "Struct",
                        "signature": "struct MappedMutexGuard",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pin_box",
                        "label": "pin_box",
                        "kind": "Function",
                        "signature": "fn fn pin_box < T : Stream < Item = U > + 'static , U > (s : T) -> Pin < Box < dyn Stream < Item = U > > > { Box :: pin (s) } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "default_numeric_fallback",
                        "label": "default_numeric_fallback",
                        "kind": "Function",
                        "signature": "fn # [warn (clippy :: default_numeric_fallback)] pub async fn default_numeric_fallback () { tokio :: select ! { _ = async { } => () , else => () , } } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_bounded_channel_panic_caller",
                        "label": "mpsc_bounded_channel_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_bounded_channel_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (_ , _) = mpsc :: channel :: < u8 > (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SignalStream",
                        "label": "SignalStream",
                        "kind": "Struct",
                        "signature": "struct SignalStream",
                        "file_path": "tokio-stream/src/wrappers/signal_unix.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "panics_when_io_disabled",
                        "label": "panics_when_io_disabled",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"A Tokio 1.x context was found, but IO is disabled. Call `enable_io` on the runtime builder to enable IO.\")] # [cfg_attr (miri , ignore)] fn panics_when_io_disabled () { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; listener . set_nonblocking (true) . unwrap () ; let _ = tokio :: net :: TcpListener :: from_std (listener) ; }) ; } . sig",
                        "file_path": "tokio/tests/io_driver.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "compact_change_deadline",
                        "label": "compact_change_deadline",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn compact_change_deadline () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let mut now = Instant :: now () ; queue . insert_at (\"foo1\" , now + ms (10)) ; queue . insert_at (\"foo2\" , now + ms (10)) ; queue . insert_at (\"foo3\" , now + ms (20)) ; let key4 = queue . insert_at (\"foo4\" , now + ms (20)) ; sleep (ms (10)) . await ; let mut res = vec ! [] ; while res . len () < 2 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } queue . compact () ; now = Instant :: now () ; queue . insert_at (\"foo5\" , now + ms (10)) ; let key6 = queue . insert_at (\"foo6\" , now + ms (10)) ; queue . reset_at (& key4 , now + ms (20)) ; queue . reset_at (& key6 , now + ms (20)) ; sleep (ms (10)) . await ; while res . len () < 4 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } sleep (ms (10)) . await ; while res . len () < 6 { let entry = assert_ready_some ! (poll ! (queue)) ; res . push (entry . into_inner ()) ; } let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_set_spawn_local_panic_caller",
                        "label": "local_set_spawn_local_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_set_spawn_local_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _local = task :: LocalSet :: new () ; task :: spawn_local (async { }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_fut_with_cancellation_token_test",
                        "label": "ready_fut_with_cancellation_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn ready_fut_with_cancellation_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let ready_fut = ready (()) ; let ready_with_token_fut = ready_fut . with_cancellation_token (& token) ; pin ! (ready_with_token_fut) ; let res = ready_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_on_empty_channel",
                        "label": "test_rx_len_on_empty_channel",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_on_empty_channel () { let (_tx , rx) = mpsc :: channel :: < () > (100) ; assert_eq ! (rx . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_multi_frame_one_packet",
                        "label": "read_single_multi_frame_one_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_multi_frame_one_packet () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x09abcdefghi\") ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x03123\") ; d . extend_from_slice (b\"\\x00\\x00\\x00\\x0bhello world\") ; let io = FramedRead :: new (mock ! { data (& d) , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_spawn_multiple_futures",
                        "label": "can_spawn_multiple_futures",
                        "kind": "Function",
                        "signature": "fn # [doc = \" We should be able to spawn multiple futures onto the pool at the same time.\"] # [tokio :: test] async fn can_spawn_multiple_futures () { let pool = task :: LocalPoolHandle :: new (2) ; let join_handle1 = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test1\") ; async move { local_data . to_string () } }) ; let join_handle2 = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test2\") ; async move { local_data . to_string () } }) ; assert_eq ! (join_handle1 . await . unwrap () , \"test1\") ; assert_eq ! (join_handle2 . await . unwrap () , \"test2\") ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_order",
                        "label": "write_order",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn write_order () { let rwlock = RwLock :: < Vec < u32 > > :: new (vec ! []) ; let fut2 = rwlock . write () . map (| mut guard | guard . push (2)) ; let fut1 = rwlock . write () . map (| mut guard | guard . push (1)) ; fut1 . await ; fut2 . await ; let g = rwlock . read () . await ; assert_eq ! (* g , vec ! [1 , 2]) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn main (args : TokenStream , item : TokenStream , rt_multi_thread : bool) -> TokenStream { let input : ItemFn = match syn :: parse2 (item . clone ()) { Ok (it) => it , Err (e) => return token_stream_with_error (item , e) , } ; let config = if input . sig . ident == \"main\" && ! input . sig . inputs . is_empty () { let msg = \"the main function cannot accept arguments\" ; Err (syn :: Error :: new_spanned (& input . sig . ident , msg)) } else { AttributeArgs :: parse_terminated . parse2 (args) . and_then (| args | build_config (& input , args , false , rt_multi_thread)) } ; match config { Ok (config) => parse_knobs (input , false , config) , Err (e) => token_stream_with_error (parse_knobs (input , false , DEFAULT_ERROR_CONFIG) , e) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (NUM_WORKERS) . enable_all () . build () . unwrap () } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_fut_with_already_cancelled_token_test",
                        "label": "ready_fut_with_already_cancelled_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn ready_fut_with_already_cancelled_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; token . cancel () ; let ready_fut = ready (()) ; let ready_fut_with_token_fut = ready_fut . with_cancellation_token (& token) ; pin ! (ready_fut_with_token_fut) ; let res = ready_fut_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "builder_worker_threads_panic_caller",
                        "label": "builder_worker_threads_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn builder_worker_threads_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . worker_threads (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FuturesAsyncReadCompatExt",
                        "label": "FuturesAsyncReadCompatExt",
                        "kind": "Trait",
                        "signature": "trait FuturesAsyncReadCompatExt",
                        "file_path": "tokio-util/src/compat.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "set_while_initializing",
                        "label": "set_while_initializing",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_while_initializing () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { time :: pause () ; let handle1 = rt . spawn (async { ONCE . get_or_init (sleep_and_set) . await }) ; let handle2 = rt . spawn (async { advance_time_and_set (& ONCE , 10) . await }) ; time :: advance (Duration :: from_millis (2)) . await ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert ! (result2 . err () . unwrap () . is_initializing_err ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Cancellable",
                        "label": "Cancellable",
                        "kind": "Trait",
                        "signature": "trait Cancellable",
                        "file_path": "tokio/src/runtime/driver/op.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_c () -> io :: Result < RxFuture > { new (console :: CTRL_C_EVENT) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "encode_overflow",
                        "label": "encode_overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn encode_overflow () { let mut codec = length_delimited :: Builder :: new () . new_codec () ; let mut buf = BytesMut :: with_capacity (1024) ; let some_as = std :: iter :: repeat (b'a') . take (1024) . collect :: < Vec < _ > > () ; buf . put_slice (& some_as [..]) ; codec . encode (Bytes :: from (\"hello\") , & mut buf) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_immediate_delay",
                        "label": "single_immediate_delay",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn single_immediate_delay () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _key = queue . insert_at (\"foo\" , Instant :: now ()) ; sleep (ms (1)) . await ; assert_ready_some ! (poll ! (queue)) ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_closed_permits_drop",
                        "label": "size_hint_stream_closed_permits_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_closed_permits_drop () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; let permit1 = tx . reserve () . await . unwrap () ; let permit2 = tx . reserve () . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (1 , Some (3))) ; drop (permit1) ; assert_eq ! (stream . size_hint () , (1 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (1))) ; drop (permit2) ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (stream . next () . await , None) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire_many_available",
                        "label": "try_acquire_many_available",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire_many_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ok ! (s . try_acquire (5)) ; assert_eq ! (s . available_permits () , 95) ; assert_ok ! (s . try_acquire (5)) ; assert_eq ! (s . available_permits () , 90) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (mut socket , _) = listener . accept () . await ? ; tokio :: spawn (async move { let mut buf = vec ! [0 ; 1024] ; loop { let n = socket . read (& mut buf) . await . expect (\"failed to read data from socket\") ; if n == 0 { return ; } socket . write_all (& buf [0 .. n]) . await . expect (\"failed to write data to socket\") ; } }) ; } } . sig",
                        "file_path": "examples/echo-tcp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_readable",
                        "label": "poll_readable",
                        "kind": "Function",
                        "signature": "fn async fn poll_readable < T : AsRawFd > (fd : & AsyncFd < T >) -> std :: io :: Result < AsyncFdReadyGuard < '_ , T > > { std :: future :: poll_fn (| cx | fd . poll_read_ready (cx)) . await } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_impl",
                        "label": "contention_impl",
                        "kind": "Function",
                        "signature": "fn fn contention_impl < const N_TASKS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let (tx , _rx) = broadcast :: channel :: < usize > (1000) ; let wg = Arc :: new ((AtomicUsize :: new (0) , Notify :: new ())) ; for n in 0 .. N_TASKS { let wg = wg . clone () ; let mut rx = tx . subscribe () ; let mut rng = rand :: rngs :: StdRng :: seed_from_u64 (n as u64) ; rt . spawn (async move { while (rx . recv () . await) . is_ok () { let r = do_work (& mut rng) ; let _ = black_box (r) ; if wg . 0 . fetch_sub (1 , Ordering :: Relaxed) == 1 { wg . 1 . notify_one () ; } } }) ; } const N_ITERS : usize = 100 ; g . bench_function (N_TASKS . to_string () , | b | { b . iter (| | { rt . block_on ({ let wg = wg . clone () ; let tx = tx . clone () ; async move { for i in 0 .. N_ITERS { assert_eq ! (wg . 0 . fetch_add (N_TASKS , Ordering :: Relaxed) , 0) ; tx . send (i) . unwrap () ; while wg . 0 . load (Ordering :: Relaxed) > 0 { wg . 1 . notified () . await ; } } } }) }) }) ; } . sig",
                        "file_path": "benches/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_block_in_place1",
                        "label": "test_block_in_place1",
                        "kind": "Function",
                        "signature": "fn # [should_panic] # [tokio :: test] async fn test_block_in_place1 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_unbounded",
                        "label": "try_recv_unbounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_unbounded () { for num in 0 .. 100 { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. num { tx . send (i) . unwrap () ; } for i in 0 .. num { assert_eq ! (rx . try_recv () , Ok (i)) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; drop (tx) ; assert_eq ! (rx . try_recv () , Err (TryRecvError :: Disconnected)) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ItemFn",
                        "label": "ItemFn",
                        "kind": "Struct",
                        "signature": "struct ItemFn",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "LocalPool",
                        "label": "LocalPool",
                        "kind": "Struct",
                        "signature": "struct LocalPool",
                        "file_path": "tokio-util/src/task/spawn_pinned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_and_close",
                        "label": "write_and_close",
                        "kind": "Function",
                        "signature": "fn async fn write_and_close (path : impl AsRef < Path > , msg : & [u8]) -> io :: Result < () > { let mut writer = pipe :: OpenOptions :: new () . open_sender (path) ? ; writer . write_all (msg) . await ? ; drop (writer) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_past_sleep_before_fire",
                        "label": "reset_past_sleep_before_fire",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_past_sleep_before_fire () { time :: pause () ; let now = Instant :: now () ; let mut sleep = task :: spawn (Box :: pin (time :: sleep_until (now + ms (100)))) ; assert_pending ! (sleep . poll ()) ; let mut sleep = sleep . into_inner () ; time :: sleep (ms (10)) . await ; sleep . as_mut () . reset (now + ms (80)) ; sleep . await ; assert_elapsed ! (now , ms (80)) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnsafeCell",
                        "label": "UnsafeCell",
                        "kind": "Struct",
                        "signature": "struct UnsafeCell",
                        "file_path": "tokio/src/loom/std/unsafe_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "issue_4175_main_1",
                        "label": "issue_4175_main_1",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] pub async fn issue_4175_main_1 () -> ! { panic ! () ; } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_update_max_frame_len_at_rest",
                        "label": "read_update_max_frame_len_at_rest",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_update_max_frame_len_at_rest () { let io = length_delimited :: Builder :: new () . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; io . decoder_mut () . set_max_frame_length (5) ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Registry",
                        "label": "Registry",
                        "kind": "Struct",
                        "signature": "struct Registry",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "send_recv",
                        "label": "send_recv",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_recv () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; receiver . connect (sender . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = [0u8 ; 32] ; let len = receiver . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "item_expiry_greater_than_wheel",
                        "label": "item_expiry_greater_than_wheel",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn item_expiry_greater_than_wheel () { let mut queue = DelayQueue :: new () ; for _ in 0 .. 2 { tokio :: time :: advance (Duration :: from_millis (1 << 35)) . await ; queue . insert (0 , Duration :: from_millis (0)) ; queue . next () . await ; } let no_panic = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { queue . insert (1 , Duration :: from_millis (1)) ; })) ; assert ! (no_panic . is_ok ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "next_many_enough",
                        "label": "next_many_enough",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 2)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_block_threaded",
                        "label": "try_block_threaded",
                        "kind": "Function",
                        "signature": "fn fn try_block_threaded (rt : & Runtime) -> Result < Vec < mpsc :: Sender < () > > , mpsc :: RecvTimeoutError > { let (tx , rx) = mpsc :: channel () ; let blocking_tasks = (0 .. rt . metrics () . num_workers ()) . map (| _ | { let tx = tx . clone () ; let (task , barrier) = mpsc :: channel () ; rt . spawn (async move { tx . send (()) . ok () ; barrier . recv () . ok () ; }) ; task }) . collect () ; for _ in 0 .. rt . metrics () . num_workers () { rx . recv_timeout (Duration :: from_secs (1)) ? ; } Ok (blocking_tasks) } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_weak_count_when_dropped",
                        "label": "sender_weak_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_weak_count_when_dropped () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_frames_on_eof",
                        "label": "multi_frames_on_eof",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_frames_on_eof () { let mut task = task :: spawn (()) ; struct MyDecoder (Vec < u32 >) ; impl Decoder for MyDecoder { type Item = u32 ; type Error = io :: Error ; fn decode (& mut self , _buf : & mut BytesMut) -> io :: Result < Option < u32 > > { unreachable ! () ; } fn decode_eof (& mut self , _buf : & mut BytesMut) -> io :: Result < Option < u32 > > { if self . 0 . is_empty () { return Ok (None) ; } Ok (Some (self . 0 . remove (0))) } } let mut framed = FramedRead :: new (mock ! () , MyDecoder (vec ! [0 , 1 , 2 , 3])) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert_read ! (pin ! (framed) . poll_next (cx) , 3) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_rt",
                        "label": "current_rt",
                        "kind": "Function",
                        "signature": "fn fn current_rt () -> Box < dyn Fn () -> Runtime > { Box :: new (| | Builder :: new_current_thread () . enable_all () . build () . unwrap ()) } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_try_write",
                        "label": "try_read_try_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_read_try_write () { let lock : RwLock < usize > = RwLock :: new (15) ; { let rg1 = lock . try_read () . unwrap () ; assert_eq ! (* rg1 , 15) ; assert ! (lock . try_write () . is_err ()) ; let rg2 = lock . try_read () . unwrap () ; assert_eq ! (* rg2 , 15) } { let mut wg = lock . try_write () . unwrap () ; * wg = 1515 ; assert ! (lock . try_read () . is_err ()) } assert_eq ! (* lock . try_read () . unwrap () , 1515) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "to_string_does_not_truncate_on_io_error",
                        "label": "to_string_does_not_truncate_on_io_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn to_string_does_not_truncate_on_io_error () { let mut mock = Builder :: new () . read (b\"def\") . read_error (io :: Error :: new (io :: ErrorKind :: Other , \"whoops\")) . build () ; let mut s = \"abc\" . to_string () ; match AsyncReadExt :: read_to_string (& mut mock , & mut s) . await { Ok (len) => panic ! (\"Should fail: {len} bytes.\") , Err (err) if err . to_string () == \"whoops\" => { } Err (err) => panic ! (\"Fail: {err}.\") , } assert_eq ! (s , \"abc\") ; } . sig",
                        "file_path": "tokio/tests/io_read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_when_close_is_called_after_dropping_sender",
                        "label": "test_rx_unbounded_len_when_close_is_called_after_dropping_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_close_is_called_after_dropping_sender () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tx . send (()) . unwrap () ; drop (tx) ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ArcFile",
                        "label": "ArcFile",
                        "kind": "Struct",
                        "signature": "struct ArcFile",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "memchr",
                        "label": "memchr",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (unix , feature = \"libc\"))] pub (crate) fn memchr (needle : u8 , haystack : & [u8]) -> Option < usize > { let start = haystack . as_ptr () ; let ptr = unsafe { libc :: memchr (start . cast () , needle as _ , haystack . len ()) } ; if ptr . is_null () { None } else { Some (ptr as usize - start as usize) } } . sig",
                        "file_path": "tokio/src/util/memchr.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_num_notify_waiters_calls",
                        "label": "get_num_notify_waiters_calls",
                        "kind": "Function",
                        "signature": "fn fn get_num_notify_waiters_calls (data : usize) -> usize { (data & NOTIFY_WAITERS_CALLS_MASK) >> NOTIFY_WAITERS_SHIFT } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_noop",
                        "label": "async_noop",
                        "kind": "Function",
                        "signature": "fn async fn async_noop () { } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn split () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let s = Arc :: new (socket) ; let r = s . clone () ; let addr = s . local_addr () ? ; tokio :: spawn (async move { s . send_to (MSG , & addr) . await . unwrap () ; }) ; let mut recv_buf = [0u8 ; 32] ; let (len , _) = r . recv_from (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_blocking",
                        "label": "spawn_blocking",
                        "kind": "Function",
                        "signature": "fn pub (super) fn spawn_blocking < F , R > (f : F) -> JoinHandle < R > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let (tx , rx) = oneshot :: channel () ; let task = Box :: new (move | | { let _ = tx . send (f ()) ; }) ; QUEUE . with (| cell | cell . borrow_mut () . push_back (task)) ; JoinHandle { rx } } . sig",
                        "file_path": "tokio/src/fs/mocks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OpenOptions",
                        "label": "OpenOptions",
                        "kind": "Struct",
                        "signature": "struct OpenOptions",
                        "file_path": "tokio/src/fs/open_options.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "advance_time_and_set",
                        "label": "advance_time_and_set",
                        "kind": "Function",
                        "signature": "fn async fn advance_time_and_set (cell : & 'static OnceCell < u32 > , v : u32) -> Result < () , SetError < u32 > > { time :: advance (Duration :: from_millis (1)) . await ; cell . set (v) } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "concurrent_close",
                        "label": "concurrent_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn concurrent_close () { const NUM : usize = 3 ; loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; for _ in 0 .. NUM { let semaphore = semaphore . clone () ; thread :: spawn (move | | { block_on (semaphore . acquire (1)) . map_err (| _ | ()) ? ; semaphore . release (1) ; semaphore . close () ; Ok :: < () , () > (()) }) ; } }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AccessError",
                        "label": "AccessError",
                        "kind": "Struct",
                        "signature": "struct AccessError",
                        "file_path": "tokio/src/task/task_local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "smaller_frame_len_not_adjusted",
                        "label": "smaller_frame_len_not_adjusted",
                        "kind": "Function",
                        "signature": "fn # [test] fn smaller_frame_len_not_adjusted () { let codec = LengthDelimitedCodec :: builder () . max_frame_length (10) . length_field_length (std :: mem :: size_of :: < usize > ()) . new_codec () ; assert_eq ! (codec . max_frame_length () , 10) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AsyncSeek",
                        "label": "AsyncSeek",
                        "kind": "Trait",
                        "signature": "trait AsyncSeek",
                        "file_path": "tokio/src/io/async_seek.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "send_to_peek_from",
                        "label": "send_to_peek_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_to_peek_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . peek_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let (n , addr) = receiver . recv_from (& mut recv_buf) . await ? ; assert_eq ! (& recv_buf [.. n] , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "add_permits",
                        "label": "add_permits",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn add_permits () { let sem = Arc :: new (Semaphore :: new (0)) ; let sem_clone = sem . clone () ; let j = tokio :: spawn (async move { let _p2 = sem_clone . acquire () . await ; }) ; sem . add_permits (1) ; j . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "clean_pattern",
                        "label": "clean_pattern",
                        "kind": "Function",
                        "signature": "fn fn clean_pattern (pat : & mut syn :: Pat) { match pat { syn :: Pat :: Lit (_literal) => { } syn :: Pat :: Macro (_macro) => { } syn :: Pat :: Path (_path) => { } syn :: Pat :: Range (_range) => { } syn :: Pat :: Rest (_rest) => { } syn :: Pat :: Verbatim (_tokens) => { } syn :: Pat :: Wild (_underscore) => { } syn :: Pat :: Ident (ident) => { ident . by_ref = None ; ident . mutability = None ; if let Some ((_at , pat)) = & mut ident . subpat { clean_pattern (& mut * pat) ; } } syn :: Pat :: Or (or) => { for case in & mut or . cases { clean_pattern (case) ; } } syn :: Pat :: Slice (slice) => { for elem in & mut slice . elems { clean_pattern (elem) ; } } syn :: Pat :: Struct (struct_pat) => { for field in & mut struct_pat . fields { clean_pattern (& mut field . pat) ; } } syn :: Pat :: Tuple (tuple) => { for elem in & mut tuple . elems { clean_pattern (elem) ; } } syn :: Pat :: TupleStruct (tuple) => { for elem in & mut tuple . elems { clean_pattern (elem) ; } } syn :: Pat :: Reference (reference) => { reference . mutability = None ; clean_pattern (& mut reference . pat) ; } syn :: Pat :: Type (type_pat) => { clean_pattern (& mut type_pat . pat) ; } _ => { } } } . sig",
                        "file_path": "tokio-macros/src/select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_never",
                        "label": "async_never",
                        "kind": "Function",
                        "signature": "fn async fn async_never () -> ! { futures :: future :: pending () . await } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_both",
                        "label": "notify_both",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn notify_both () { let kind = SignalKind :: user_defined2 () ; let mut signal1 = signal (kind) . expect (\"failed to create signal1\") ; let mut signal2 = signal (kind) . expect (\"failed to create signal2\") ; send_signal (libc :: SIGUSR2) ; signal1 . recv () . await ; signal2 . recv () . await ; } . sig",
                        "file_path": "tokio/tests/signal_notify_both.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sigrt_max",
                        "label": "sigrt_max",
                        "kind": "Function",
                        "signature": "fn fn sigrt_max () -> c_int { libc :: SIGRTMAX () . min (libc :: SIGRTMIN () + 27) } . sig",
                        "file_path": "tokio/tests/signal_realtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_set_coop",
                        "label": "join_set_coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn join_set_coop () { const TASK_NUM : u32 = 1000 ; static SEM : tokio :: sync :: Semaphore = tokio :: sync :: Semaphore :: const_new (0) ; let mut set = JoinSet :: new () ; for _ in 0 .. TASK_NUM { set . spawn (async { SEM . add_permits (1) ; }) ; } let _ = SEM . acquire_many (TASK_NUM) . await . unwrap () ; let mut count = 0 ; let mut coop_count = 0 ; loop { match set . join_next () . now_or_never () { Some (Some (Ok (()))) => { } Some (Some (Err (err))) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; continue ; } Some (None) => break , } count += 1 ; } assert ! (coop_count >= 1) ; assert_eq ! (count , TASK_NUM) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let server = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; loop { let (stream , _) = server . accept () . await ? ; tokio :: spawn (async move { if let Err (e) = process (stream) . await { println ! (\"failed to process connection; error = {e}\") ; } }) ; } } . sig",
                        "file_path": "examples/tinyhttp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "data_remaining_is_error",
                        "label": "data_remaining_is_error",
                        "kind": "Function",
                        "signature": "fn # [test] fn data_remaining_is_error () { let mut task = task :: spawn (()) ; let slice = & [0 ; 5] [..] ; let mut framed = FramedRead :: new (slice , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . is_err ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_send",
                        "label": "blocking_send",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] fn blocking_send () { let (tx , mut rx) = mpsc :: channel :: < u8 > (1) ; let sync_code = std :: thread :: spawn (move | | { tx . blocking_send (10) . unwrap () ; }) ; tokio :: runtime :: Runtime :: new () . unwrap () . block_on (async move { assert_eq ! (Some (10) , rx . recv () . await) ; }) ; sync_code . join () . unwrap () } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = stream :: empty :: < i32 > () ; for _ in 0 .. 2 { assert_eq ! (stream . size_hint () , (0 , Some (0))) ; assert_eq ! (None , stream . next () . await) ; } } . sig",
                        "file_path": "tokio-stream/tests/stream_empty.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalState",
                        "label": "LocalState",
                        "kind": "Struct",
                        "signature": "struct LocalState",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "task_local_available_on_completion_drop",
                        "label": "task_local_available_on_completion_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_local_available_on_completion_drop () { tokio :: task_local ! { static KEY : u32 ; } struct MyFuture { tx : Option < oneshot :: Sender < u32 > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Ready (()) } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (KEY . get ()) ; } } let (tx , rx) = oneshot :: channel () ; let h = tokio :: spawn (KEY . scope (42 , MyFuture { tx : Some (tx) })) ; assert_eq ! (rx . await . unwrap () , 42) ; h . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_err",
                        "label": "read_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_err () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_during_shutdown",
                        "label": "wake_during_shutdown",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Demonstrates tokio-rs/tokio#3869\"] # [test] fn wake_during_shutdown () { struct Shared { waker : Option < Waker > , } struct MyFuture { shared : Arc < Mutex < Shared > > , put_waker : bool , } impl MyFuture { fn new () -> (Self , Self) { let shared = Arc :: new (Mutex :: new (Shared { waker : None })) ; let f1 = MyFuture { shared : shared . clone () , put_waker : true , } ; let f2 = MyFuture { shared , put_waker : false , } ; (f1 , f2) } } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < () > { let me = Pin :: into_inner (self) ; let mut lock = me . shared . lock () . unwrap () ; if me . put_waker { lock . waker = Some (cx . waker () . clone ()) ; } Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let mut lock = self . shared . lock () . unwrap () ; if ! self . put_waker { lock . waker . take () . unwrap () . wake () ; } drop (lock) ; } } let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . enable_all () . build () . unwrap () ; let (f1 , f2) = MyFuture :: new () ; rt . spawn (f1) ; rt . spawn (f2) ; rt . block_on (async { tokio :: time :: sleep (tokio :: time :: Duration :: from_millis (20)) . await }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "time_now_current_thread",
                        "label": "time_now_current_thread",
                        "kind": "Function",
                        "signature": "fn fn time_now_current_thread (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; c . bench_function (\"time_now_current_thread\" , | b | { b . iter (| | { rt . block_on (async { black_box (tokio :: time :: Instant :: now ()) ; }) }) }) ; } . sig",
                        "file_path": "benches/time_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_on_empty_channel",
                        "label": "test_rx_unbounded_len_on_empty_channel",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_on_empty_channel () { let (_tx , rx) = mpsc :: unbounded_channel :: < () > () ; assert_eq ! (rx . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StreamMap",
                        "label": "StreamMap",
                        "kind": "Struct",
                        "signature": "struct StreamMap",
                        "file_path": "tokio-stream/src/stream_map.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_close",
                        "label": "try_recv_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_close () { loom :: model (| | { let (tx , mut rx) = oneshot :: channel () ; thread :: spawn (move | | { let _ = tx . send (()) ; }) ; rx . close () ; let _ = rx . try_recv () ; }) } . sig",
                        "file_path": "tokio/src/sync/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rename_file",
                        "label": "rename_file",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn rename_file () { let temp_dir = tempdir () . unwrap () ; let file_path = temp_dir . path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; assert ! (fs :: try_exists (& file_path) . await . unwrap ()) ; let new_file_path = temp_dir . path () . join (\"b.txt\") ; fs :: rename (& file_path , & new_file_path) . await . unwrap () ; assert ! (fs :: try_exists (new_file_path) . await . unwrap ()) ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after rename\") , } ; } . sig",
                        "file_path": "tokio/tests/fs_rename.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_join_next",
                        "label": "try_join_next",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn try_join_next () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut set = JoinSet :: new () ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; set . spawn (async move { recv . changed () . await . unwrap () }) ; } drop (recv) ; assert ! (set . try_join_next () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; loop { match set . try_join_next () { Some (Ok (())) => { count += 1 ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { break ; } } } assert_eq ! (count , TASK_NUM) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_read_buf",
                        "label": "async_read_buf",
                        "kind": "Function",
                        "signature": "fn fn async_read_buf (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"async_read_buf\" , | b | { b . iter (| | { let task = | | async { let mut file = File :: open (DEV_ZERO) . await . unwrap () ; let mut buffer = [0u8 ; BUFFER_SIZE] ; for _i in 0 .. BLOCK_COUNT { let count = file . read (& mut buffer) . await . unwrap () ; if count == 0 { break ; } } } ; rt . block_on (task ()) ; }) ; }) ; } . sig",
                        "file_path": "benches/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "extra_semicolon",
                        "label": "extra_semicolon",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn extra_semicolon () -> Result < () , () > { Ok (()) ; } . sig",
                        "file_path": "tests-build/tests/fail/macros_type_mismatch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_fn_has_args",
                        "label": "test_fn_has_args",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_fn_has_args (_x : u8) { } . sig",
                        "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_macro",
                        "label": "main_macro",
                        "kind": "Function",
                        "signature": "fn # [test] fn main_macro () { entry_point () ; } . sig",
                        "file_path": "tests-integration/tests/rt_yield.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "across_tasks",
                        "label": "across_tasks",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn across_tasks () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { a . write_all (b\"ping\") . await . unwrap () ; let mut buf = [0u8 ; 4] ; a . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"pong\") ; }) ; let t2 = tokio :: spawn (async move { let mut buf = [0u8 ; 4] ; b . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (& buf , b\"ping\") ; b . write_all (b\"pong\") . await . unwrap () ; }) ; t1 . await . unwrap () ; t2 . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_5588",
                        "label": "issue_5588",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"io-util\")] async fn issue_5588 () { use bytes :: BufMut ; let mut buf = [0 ; 8] ; let mut read_buf = ReadBuf :: new (& mut buf) ; assert_eq ! (read_buf . remaining_mut () , 8) ; assert_eq ! (read_buf . chunk_mut () . len () , 8) ; unsafe { read_buf . advance_mut (1) ; } assert_eq ! (read_buf . remaining_mut () , 7) ; assert_eq ! (read_buf . chunk_mut () . len () , 7) ; unsafe { read_buf . advance_mut (5) ; } assert_eq ! (read_buf . remaining_mut () , 2) ; assert_eq ! (read_buf . chunk_mut () . len () , 2) ; unsafe { read_buf . advance_mut (2) ; } assert_eq ! (read_buf . remaining_mut () , 0) ; assert_eq ! (read_buf . chunk_mut () . len () , 0) ; let mut buf = [0 ; 8] ; let mut read_buf = ReadBuf :: new (& mut buf) ; assert_eq ! (read_buf . remaining_mut () , 8) ; assert_eq ! (read_buf . chunk_mut () . len () , 8) ; unsafe { read_buf . advance_mut (8) ; } assert_eq ! (read_buf . remaining_mut () , 0) ; assert_eq ! (read_buf . chunk_mut () . len () , 0) ; let mut buf = [std :: mem :: MaybeUninit :: new (1) ; 8] ; let mut uninit = ReadBuf :: uninit (& mut buf) ; assert_eq ! (uninit . remaining_mut () , 8) ; assert_eq ! (uninit . chunk_mut () . len () , 8) ; let mut buf = [std :: mem :: MaybeUninit :: uninit () ; 8] ; let mut uninit = ReadBuf :: uninit (& mut buf) ; unsafe { uninit . advance_mut (4) ; } assert_eq ! (uninit . remaining_mut () , 4) ; assert_eq ! (uninit . chunk_mut () . len () , 4) ; uninit . put_u8 (1) ; assert_eq ! (uninit . remaining_mut () , 3) ; assert_eq ! (uninit . chunk_mut () . len () , 3) ; uninit . put_slice (& [1 , 2 , 3]) ; assert_eq ! (uninit . remaining_mut () , 0) ; assert_eq ! (uninit . chunk_mut () . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/io_read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_handle_panic_caller",
                        "label": "current_handle_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn current_handle_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Handle :: current () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_unpin",
                        "label": "is_unpin",
                        "kind": "Function",
                        "signature": "fn # [cfg (feature = \"io-util\")] # [cfg (test)] fn is_unpin < T : Unpin > () { } . sig",
                        "file_path": "tokio/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end_doesnt_grow_with_capacity",
                        "label": "read_to_end_doesnt_grow_with_capacity",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn read_to_end_doesnt_grow_with_capacity () { let arr : Vec < u8 > = (0 .. 100) . collect () ; for len in 32 .. 100 { let bytes = & arr [.. len] ; for split in 0 .. len { for cap in 0 .. 101 { let mut mock = if split == 0 { Builder :: new () . read (bytes) . build () } else { Builder :: new () . read (& bytes [.. split]) . read (& bytes [split ..]) . build () } ; let mut buf = Vec :: with_capacity (cap) ; AsyncReadExt :: read_to_end (& mut mock , & mut buf) . await . unwrap () ; assert_eq ! (buf . as_slice () , bytes) ; if cap >= len { assert_eq ! (buf . capacity () , cap) ; } } } } } . sig",
                        "file_path": "tokio/tests/io_read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_two_recv_bounded",
                        "label": "send_two_recv_bounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_two_recv_bounded () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; assert_ok ! (tx . send (\"hello\")) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; let val1 = assert_ready_ok ! (recv1 . poll ()) ; let val2 = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val1 , \"hello\") ; assert_eq ! (val2 , \"hello\") ; drop ((recv1 , recv2)) ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_ok ! (tx . send (\"world\")) ; assert ! (recv1 . is_woken ()) ; assert ! (! recv2 . is_woken ()) ; let val1 = assert_ready_ok ! (recv1 . poll ()) ; let val2 = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val1 , \"world\") ; assert_eq ! (val2 , \"world\") ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "panicking_blocking_task_wakes_paused_runtime",
                        "label": "panicking_blocking_task_wakes_paused_runtime",
                        "kind": "Function",
                        "signature": "fn # [cfg (panic = \"unwind\")] # [cfg (feature = \"test-util\")] # [tokio :: test (start_paused = true)] async fn panicking_blocking_task_wakes_paused_runtime () { let t0 = std :: time :: Instant :: now () ; let result = time :: timeout (Duration :: from_secs (15) , task :: spawn_blocking (| | { thread :: sleep (Duration :: from_millis (1)) ; panic ! (\"blocking task panicked\") ; }) ,) . await . expect (\"timeout should not trigger\") ; assert ! (result . is_err () , \"blocking task should have panicked\") ; assert ! (t0 . elapsed () < Duration :: from_secs (10) , \"completing a spawn_blocking should wake the scheduler if it's parked while time is paused\") ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rx_observes_final_value",
                        "label": "rx_observes_final_value",
                        "kind": "Function",
                        "signature": "fn # [test] fn rx_observes_final_value () { let (tx , mut rx) = watch :: channel (\"one\") ; drop (tx) ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_err ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"one\") ; let (tx , mut rx) = watch :: channel (\"one\") ; tx . send (\"two\") . unwrap () ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"two\") ; { let mut t1 = spawn (rx . changed ()) ; assert_pending ! (t1 . poll ()) ; tx . send (\"three\") . unwrap () ; drop (tx) ; assert ! (t1 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"three\") ; { let mut t1 = spawn (rx . changed ()) ; assert_ready_err ! (t1 . poll ()) ; } assert_eq ! (* rx . borrow () , \"three\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AtomicNotification",
                        "label": "AtomicNotification",
                        "kind": "Struct",
                        "signature": "struct AtomicNotification",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "async_send_recv_unbounded",
                        "label": "async_send_recv_unbounded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel () ; tokio :: spawn (async move { assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; }) ; assert_eq ! (Some (1) , rx . recv () . await) ; assert_eq ! (Some (2) , rx . recv () . await) ; assert_eq ! (None , rx . recv () . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_lock_owned",
                        "label": "try_lock_owned",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_lock_owned () { let m : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let g1 = m . clone () . try_lock_owned () ; assert ! (g1 . is_ok ()) ; let g2 = m . clone () . try_lock_owned () ; assert ! (g2 . is_err ()) ; } let g3 = m . try_lock_owned () ; assert ! (g3 . is_ok ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_now",
                        "label": "yield_now",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Yields execution back to the Tokio runtime.\"] # [doc = \"\"] # [doc = \" A task yields by awaiting on `yield_now()`, and may resume when that future\"] # [doc = \" completes (with no output.) The current task will be re-added as a pending\"] # [doc = \" task at the _back_ of the pending queue. Any other pending tasks will be\"] # [doc = \" scheduled. No other waking is required for the task to continue.\"] # [doc = \"\"] # [doc = \" See also the usage example in the [task module](index.html#yield_now).\"] # [doc = \"\"] # [doc = \" ## Non-guarantees\"] # [doc = \"\"] # [doc = \" This function may not yield all the way up to the executor if there are any\"] # [doc = \" special combinators above it in the call stack. For example, if a\"] # [doc = \" [`tokio::select!`] has another branch complete during the same poll as the\"] # [doc = \" `yield_now()`, then the yield is not propagated all the way up to the\"] # [doc = \" runtime.\"] # [doc = \"\"] # [doc = \" It is generally not guaranteed that the runtime behaves like you expect it\"] # [doc = \" to when deciding which task to schedule next after a call to `yield_now()`.\"] # [doc = \" In particular, the runtime may choose to poll the task that just ran\"] # [doc = \" `yield_now()` again immediately without polling any other tasks first. For\"] # [doc = \" example, the runtime will not drive the IO driver between every poll of a\"] # [doc = \" task, and this could result in the runtime polling the current task again\"] # [doc = \" immediately even if there is another task that could make progress if that\"] # [doc = \" other task is waiting for a notification from the IO driver.\"] # [doc = \"\"] # [doc = \" In general, changes to the order in which the runtime polls tasks is not\"] # [doc = \" considered a breaking change, and your program should be correct no matter\"] # [doc = \" which order the runtime polls your tasks in.\"] # [doc = \"\"] # [doc = \" [`tokio::select!`]: macro@crate::select\"] # [cfg_attr (docsrs , doc (cfg (feature = \"rt\")))] pub async fn yield_now () { # [doc = \" Yield implementation\"] struct YieldNow { yielded : bool , } impl Future for YieldNow { type Output = () ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < () > { ready ! (crate :: trace :: trace_leaf (cx)) ; if self . yielded { return Poll :: Ready (()) ; } self . yielded = true ; context :: defer (cx . waker ()) ; Poll :: Pending } } YieldNow { yielded : false } . await ; } . sig",
                        "file_path": "tokio/src/task/yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_tasks_wake_join_all",
                        "label": "local_tasks_wake_join_all",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: `task::spawn_local().await.unwrap()` panics on Wasi\")] # [test] fn local_tasks_wake_join_all () { with_timeout (Duration :: from_secs (60) , | | { use futures :: future :: join_all ; use tokio :: task :: LocalSet ; let rt = rt () ; let set = LocalSet :: new () ; let mut handles = Vec :: new () ; for _ in 1 ..= 128 { handles . push (set . spawn_local (async move { tokio :: task :: spawn_local (async move { }) . await . unwrap () ; })) ; } rt . block_on (set . run_until (join_all (handles))) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "my_fn",
                        "label": "my_fn",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn my_fn () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_core_no_default.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_when_consuming_all_messages",
                        "label": "test_rx_len_when_consuming_all_messages",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_when_consuming_all_messages () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; assert_eq ! (rx . len () , i + 1) ; } drop (tx) ; for i in (0 .. 100) . rev () { assert ! (rx . recv () . await . is_some ()) ; assert_eq ! (rx . len () , i) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wait",
                        "label": "wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn wait () { const FIRST_WAIT : Duration = Duration :: from_secs (1) ; let mut mock = Builder :: new () . wait (FIRST_WAIT) . read (b\"hello \") . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let start = Instant :: now () ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; println ! (\"time elapsed after first read {:?}\" , start . elapsed ()) ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; println ! (\"time elapsed after second read {:?}\" , start . elapsed ()) ; assert ! (start . elapsed () >= FIRST_WAIT , \"consuming the whole mock only took {}ms\" , start . elapsed () . as_millis ()) ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_one_packet",
                        "label": "read_single_frame_one_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_one_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_single_frame_with_short_length_field",
                        "label": "write_single_frame_with_short_length_field",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_frame_with_short_length_field () { let io = length_delimited :: Builder :: new () . length_field_length (1) . new_write (mock ! { data (b\"\\x09\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Cell",
                        "label": "Cell",
                        "kind": "Struct",
                        "signature": "struct Cell",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "no_runtime_panics_creating_signals",
                        "label": "no_runtime_panics_creating_signals",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [test] # [should_panic] fn no_runtime_panics_creating_signals () { let _ = signal (SignalKind :: hangup ()) ; } . sig",
                        "file_path": "tokio/tests/signal_no_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "slot_for",
                        "label": "slot_for",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Converts a duration (milliseconds) and a level to a slot position.\"] fn slot_for (duration : u64 , level : usize) -> usize { ((duration >> (level * 6)) % LEVEL_MULT as u64) as usize } . sig",
                        "file_path": "tokio/src/runtime/time/wheel/level.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from_file_detects_wrong_access_mode",
                        "label": "from_file_detects_wrong_access_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_detects_wrong_access_mode () -> io :: Result < () > { let fifo = TempFifo :: new (\"wrong_access_mode\") ? ; let _reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let wronly = std :: fs :: OpenOptions :: new () . write (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let err = assert_err ! (pipe :: Receiver :: from_file (wronly)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let rdonly = std :: fs :: OpenOptions :: new () . read (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let err = assert_err ! (pipe :: Sender :: from_file (rdonly)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "parse_path",
                        "label": "parse_path",
                        "kind": "Function",
                        "signature": "fn fn parse_path (lit : syn :: Lit , span : Span , field : & str) -> Result < Path , syn :: Error > { match lit { syn :: Lit :: Str (s) => { let err = syn :: Error :: new (span , format ! (\"Failed to parse value of `{}` as path: \\\"{}\\\"\" , field , s . value ()) ,) ; s . parse :: < syn :: Path > () . map_err (| _ | err . clone ()) } _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as path.\") ,)) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_rt",
                        "label": "main_rt",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Marks async function to be executed by selected runtime. This macro helps set up a `Runtime`\"] # [doc = \" without requiring the user to use [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" ## Function arguments:\"] # [doc = \"\"] # [doc = \" Arguments are allowed for any functions aside from `main` which is special\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ### Using default\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" fn main() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::main(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::main]`\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" fn main() {\"] # [doc = \"     tokio1::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             println!(\\\"Hello world\\\");\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn main_rt (args : TokenStream , item : TokenStream) -> TokenStream { entry :: main (args . into () , item . into () , false) . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "return_none_after_error",
                        "label": "return_none_after_error",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn return_none_after_error () { let mut io = FramedRead :: new (Builder :: new () . read (b\"abcdef\") . read_error (io :: Error :: new (io :: ErrorKind :: Other , \"Resource errored out\")) . read (b\"more data\") . build () , BytesCodec :: new () ,) ; let mut task = task :: spawn (()) ; task . enter (| cx , _ | { assert_read ! (pin ! (io) . poll_next (cx) , b\"abcdef\" . to_vec ()) ; assert ! (assert_ready ! (pin ! (io) . poll_next (cx)) . unwrap () . is_err ()) ; assert ! (assert_ready ! (pin ! (io) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (io) . poll_next (cx) , b\"more data\" . to_vec ()) ; }) } . sig",
                        "file_path": "tokio-util/tests/framed_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep",
                        "label": "sleep",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Waits until `duration` has elapsed.\"] # [doc = \"\"] # [doc = \" Equivalent to `sleep_until(Instant::now() + duration)`. An asynchronous\"] # [doc = \" analog to `std::thread::sleep`.\"] # [doc = \"\"] # [doc = \" No work is performed while awaiting on the sleep future to complete. `Sleep`\"] # [doc = \" operates at millisecond granularity and should not be used for tasks that\"] # [doc = \" require high-resolution timers. The implementation is platform specific,\"] # [doc = \" and some platforms (specifically Windows) will provide timers with a\"] # [doc = \" larger resolution than 1 ms.\"] # [doc = \"\"] # [doc = \" To run something regularly on a schedule, see [`interval`].\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Canceling a sleep instance is done by dropping the returned future. No additional\"] # [doc = \" cleanup work is required.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Wait 100ms and print \\\"100 ms have elapsed\\\".\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio::time::{sleep, Duration};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" sleep(Duration::from_millis(100)).await;\"] # [doc = \" println!(\\\"100 ms have elapsed\\\");\"] # [doc = \" # }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" See the documentation for the [`Sleep`] type for more examples.\"] # [doc = \"\"] # [doc = \" # Panics\"] # [doc = \"\"] # [doc = \" This function panics if there is no current timer set.\"] # [doc = \"\"] # [doc = \" It can be triggered when [`Builder::enable_time`] or\"] # [doc = \" [`Builder::enable_all`] are not included in the builder.\"] # [doc = \"\"] # [doc = \" It can also panic whenever a timer is created outside of a\"] # [doc = \" Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\"] # [doc = \" since the function is executed outside of the runtime.\"] # [doc = \" Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\"] # [doc = \" And this is because wrapping the function on an async makes it lazy,\"] # [doc = \" and so gets executed inside the runtime successfully without\"] # [doc = \" panicking.\"] # [doc = \"\"] # [doc = \" [`Sleep`]: struct@crate::time::Sleep\"] # [doc = \" [`interval`]: crate::time::interval()\"] # [doc = \" [`Builder::enable_time`]: crate::runtime::Builder::enable_time\"] # [doc = \" [`Builder::enable_all`]: crate::runtime::Builder::enable_all\"] # [cfg_attr (docsrs , doc (alias = \"delay_for\"))] # [cfg_attr (docsrs , doc (alias = \"wait\"))] # [track_caller] pub fn sleep (duration : Duration) -> Sleep { let location = trace :: caller_location () ; match Instant :: now () . checked_add (duration) { Some (deadline) => Sleep :: new_timeout (deadline , location) , None => Sleep :: new_timeout (Instant :: far_future () , location) , } } . sig",
                        "file_path": "tokio/src/time/sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "fits_256_one_at_a_time",
                        "label": "fits_256_one_at_a_time",
                        "kind": "Function",
                        "signature": "fn # [test] fn fits_256_one_at_a_time () { let (_ , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. 256 { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } cfg_unstable_metrics ! { assert_metrics ! (stats , overflow_count == 0) ; } assert ! (inject . borrow_mut () . pop () . is_none ()) ; while local . pop () . is_some () { } } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_branch_else_only_biased",
                        "label": "no_branch_else_only_biased",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn no_branch_else_only_biased () { let foo = tokio :: select ! { biased ; else => 1 , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lagging_rx",
                        "label": "lagging_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn lagging_rx () { let (tx , mut rx1) = broadcast :: channel (2) ; let mut rx2 = tx . subscribe () ; assert_ok ! (tx . send (\"one\")) ; assert_ok ! (tx . send (\"two\")) ; assert_eq ! (\"one\" , assert_recv ! (rx1)) ; assert_ok ! (tx . send (\"three\")) ; let x = dbg ! (rx2 . try_recv ()) ; assert_lagged ! (x , 1) ; assert_eq ! (\"two\" , assert_recv ! (rx2)) ; assert_eq ! (\"two\" , assert_recv ! (rx1)) ; assert_eq ! (\"three\" , assert_recv ! (rx1)) ; assert_ok ! (tx . send (\"four\")) ; assert_ok ! (tx . send (\"five\")) ; assert_lagged ! (rx2 . try_recv () , 1) ; assert_ok ! (tx . send (\"six\")) ; assert_lagged ! (rx2 . try_recv () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_closed_when_there_are_permits_but_not_senders",
                        "label": "test_rx_is_not_closed_when_there_are_permits_but_not_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_closed_when_there_are_permits_but_not_senders () { let (tx , rx) = mpsc :: channel :: < () > (10) ; let _permit = tx . reserve_owned () . await . expect (\"Failed to reserve permit\") ; assert ! (! rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let args = env :: args () . skip (1) . collect :: < Vec < _ > > () ; let addr = args . first () . ok_or (\"this program requires at least one argument\") ? ; let addr = addr . parse :: < SocketAddr > () ? ; let stdin = FramedRead :: new (stdin () , BytesCodec :: new ()) ; let stdin = stdin . map (| i | i . map (| bytes | bytes . freeze ())) ; let stdout = FramedWrite :: new (stdout () , BytesCodec :: new ()) ; connect (& addr , stdin , stdout) . await ? ; Ok (()) } . sig",
                        "file_path": "examples/connect-udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "runtime_with_time_does_not_panic",
                        "label": "runtime_with_time_does_not_panic",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"rt\" , feature = \"time\"))] # [wasm_bindgen_test] # [should_panic] fn runtime_with_time_does_not_panic () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; } . sig",
                        "file_path": "tokio/tests/time_wasm.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_buf_never_block",
                        "label": "try_recv_buf_never_block",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_recv_buf_never_block () -> io :: Result < () > { let payload = b\"PAYLOAD\" ; let mut count = 0 ; let (dgram1 , dgram2) = UnixDatagram :: pair () ? ; loop { dgram1 . writable () . await . unwrap () ; match dgram1 . try_send (payload) { Err (err) => match (err . kind () , err . raw_os_error ()) { (io :: ErrorKind :: WouldBlock , _) => break , (_ , Some (libc :: ENOBUFS)) => break , _ => { panic ! (\"unexpected error {err:?}\") ; } } , Ok (len) => { assert_eq ! (len , payload . len ()) ; } } count += 1 ; } while count > 0 { let mut recv_buf = Vec :: with_capacity (16) ; dgram2 . readable () . await . unwrap () ; let len = dgram2 . try_recv_buf (& mut recv_buf) ? ; assert_eq ! (len , payload . len ()) ; assert_eq ! (payload , & recv_buf [.. len]) ; count -= 1 ; } let mut recv_buf = vec ! [0 ; 16] ; let err = dgram2 . try_recv_from (& mut recv_buf) . unwrap_err () ; match err . kind () { io :: ErrorKind :: WouldBlock => () , _ => unreachable ! (\"unexpected error {:?}\" , err) , } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_set_current",
                        "label": "try_set_current",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Sets this [`Handle`] as the current active [`Handle`].\"] # [doc = \"\"] # [doc = \" [`Handle`]: crate::runtime::scheduler::Handle\"] pub (crate) fn try_set_current (handle : & scheduler :: Handle) -> Option < SetCurrentGuard > { CONTEXT . try_with (| ctx | ctx . set_current (handle)) . ok () } . sig",
                        "file_path": "tokio/src/runtime/context/current.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_seek",
                        "label": "empty_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_seek () { use std :: io :: SeekFrom ; let mut empty = tokio :: io :: empty () ; assert ! (matches ! (empty . seek (SeekFrom :: Start (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Start (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Start (u64 :: MAX)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (i64 :: MIN)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (- 1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: End (i64 :: MAX)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (i64 :: MIN)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (- 1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (0)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (1)) . await , Ok (0))) ; assert ! (matches ! (empty . seek (SeekFrom :: Current (i64 :: MAX)) . await , Ok (0))) ; } . sig",
                        "file_path": "tokio/tests/io_util_empty.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_bidirectional_with_sizes",
                        "label": "copy_bidirectional_with_sizes",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Copies data in both directions between `a` and `b` using buffers of the specified size.\"] # [doc = \"\"] # [doc = \" This method is the same as the [`copy_bidirectional()`], except that it allows you to set the\"] # [doc = \" size of the internal buffers used when copying data.\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub async fn copy_bidirectional_with_sizes < A , B > (a : & mut A , b : & mut B , a_to_b_buf_size : usize , b_to_a_buf_size : usize ,) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { copy_bidirectional_impl (a , b , CopyBuffer :: new (a_to_b_buf_size) , CopyBuffer :: new (b_to_a_buf_size) ,) . await } . sig",
                        "file_path": "tokio/src/io/util/copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StaticAtomicU64",
                        "label": "StaticAtomicU64",
                        "kind": "Struct",
                        "signature": "struct StaticAtomicU64",
                        "file_path": "tokio/src/loom/std/atomic_u64_static_once_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unconsumed_messages_are_dropped",
                        "label": "unconsumed_messages_are_dropped",
                        "kind": "Function",
                        "signature": "fn # [test] fn unconsumed_messages_are_dropped () { let (tx , rx) = broadcast :: channel (16) ; let msg = Arc :: new (()) ; assert_ok ! (tx . send (msg . clone ())) ; assert_eq ! (2 , Arc :: strong_count (& msg)) ; drop (rx) ; assert_eq ! (1 , Arc :: strong_count (& msg)) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_first_expiring_item_to_expire_later",
                        "label": "reset_first_expiring_item_to_expire_later",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_first_expiring_item_to_expire_later () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; let _two = queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (300)) ; sleep (ms (250)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"two\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_many_full",
                        "label": "try_reserve_many_full",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] # [cfg_attr (miri , ignore)] async fn try_reserve_many_full () { for n in 1 .. 100 { for k in 0 .. n { let (tx , mut rx) = mpsc :: channel :: < usize > (n) ; let permits = assert_ok ! (tx . try_reserve_many (n)) ; assert_eq ! (permits . len () , n) ; assert_eq ! (tx . capacity () , 0) ; match assert_err ! (tx . try_reserve_many (1)) { TrySendError :: Full (..) => { } _ => panic ! () , } ; for permit in permits . take (k) { permit . send (0) ; } assert_eq ! (tx . capacity () , n - k) ; assert_ok ! (tx . try_reserve_many (1)) ; match assert_err ! (tx . try_reserve_many (n - k + 1)) { TrySendError :: Full (..) => { } _ => panic ! () , } ; for _i in 0 .. k { assert_eq ! (rx . recv () . await , Some (0)) ; } assert_eq ! (tx . capacity () , n) ; } } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timeout_panics_when_no_tokio_context",
                        "label": "timeout_panics_when_no_tokio_context",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] fn timeout_panics_when_no_tokio_context () { block_on (timeout_value ()) ; } . sig",
                        "file_path": "tokio/tests/no_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "callback",
                        "label": "callback",
                        "kind": "Function",
                        "signature": "fn unsafe extern \"system\" fn callback (ptr : * mut std :: ffi :: c_void , _timer_fired : BOOLEAN) { let complete = & mut * (ptr as * mut Option < oneshot :: Sender < () > >) ; let _ = complete . take () . unwrap () . send (()) ; } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_closed",
                        "label": "read_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn read_closed () { let (client , mut server) = create_pair () . await ; let mut ready_fut = task :: spawn (client . ready (Interest :: READABLE)) ; assert_pending ! (ready_fut . poll ()) ; assert_ok ! (server . write_all (b\"ping\") . await) ; let ready_event = assert_ok ! (ready_fut . await) ; assert ! (! ready_event . is_read_closed ()) ; } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "convert_to_stdio",
                        "label": "convert_to_stdio",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn convert_to_stdio (io : ChildStdio) -> io :: Result < Stdio > { convert_to_blocking_file (io) . map (Stdio :: from) } . sig",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_handles_panicking_waker",
                        "label": "notify_waiters_handles_panicking_waker",
                        "kind": "Function",
                        "signature": "fn # [cfg (panic = \"unwind\")] # [test] fn notify_waiters_handles_panicking_waker () { use futures :: task :: ArcWake ; let notify = Arc :: new (Notify :: new ()) ; struct PanickingWaker (# [allow (dead_code)] Arc < Notify >) ; impl ArcWake for PanickingWaker { fn wake_by_ref (_arc_self : & Arc < Self >) { panic ! (\"waker panicked\") ; } } let bad_fut = notify . notified () ; pin ! (bad_fut) ; let waker = futures :: task :: waker (Arc :: new (PanickingWaker (notify . clone ()))) ; let mut cx = Context :: from_waker (& waker) ; let _ = bad_fut . poll (& mut cx) ; let mut futs = Vec :: new () ; for _ in 0 .. 32 { let mut fut = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut . poll () . is_pending ()) ; futs . push (fut) ; } assert ! (std :: panic :: catch_unwind (|| { notify . notify_waiters () ; }) . is_err ()) ; for mut fut in futs { assert ! (fut . poll () . is_ready ()) ; } } . sig",
                        "file_path": "tokio/src/sync/tests/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink_file_windows",
                        "label": "symlink_file_windows",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn symlink_file_windows () { let dir = tempdir () . unwrap () ; let source_path = dir . path () . join (\"foo.txt\") ; let dest_path = dir . path () . join (\"bar.txt\") ; fs :: write (& source_path , b\"Hello File!\") . await . unwrap () ; fs :: symlink_file (& source_path , & dest_path) . await . unwrap () ; fs :: write (& source_path , b\"new data!\") . await . unwrap () ; let from = fs :: read (& source_path) . await . unwrap () ; let to = fs :: read (& dest_path) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
                        "file_path": "tokio/tests/fs_symlink_file_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_until",
                        "label": "read_until",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_until () { let mut buf = vec ! [] ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , b\"hello \") ; buf . clear () ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 5) ; assert_eq ! (buf , b\"world\") ; buf . clear () ; let n = assert_ok ! (rd . read_until (b' ' , & mut buf) . await) ; assert_eq ! (n , 0) ; assert_eq ! (buf , []) ; } . sig",
                        "file_path": "tokio/tests/io_read_until.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_tx_notifies_rx",
                        "label": "dropping_tx_notifies_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn dropping_tx_notifies_rx () { let (tx , mut rx1) = broadcast :: channel :: < () > (16) ; let mut rx2 = tx . subscribe () ; let tx2 = tx . clone () ; let mut recv1 = task :: spawn (rx1 . recv ()) ; let mut recv2 = task :: spawn (rx2 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; drop (tx) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; drop (tx2) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; let err = assert_ready_err ! (recv1 . poll ()) ; assert ! (is_closed (err)) ; let err = assert_ready_err ! (recv2 . poll ()) ; assert ! (is_closed (err)) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_exclusive_pending",
                        "label": "write_exclusive_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_exclusive_pending () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . write ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pause_time_in_main_threads",
                        "label": "pause_time_in_main_threads",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 1)] # [should_panic] async fn pause_time_in_main_threads () { tokio :: time :: pause () ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_nonblocking",
                        "label": "set_nonblocking",
                        "kind": "Function",
                        "signature": "fn fn set_nonblocking < T : AsRawFd > (fd : & mut T , nonblocking : bool) -> io :: Result < () > { unsafe { let fd = fd . as_raw_fd () ; let previous = libc :: fcntl (fd , libc :: F_GETFL) ; if previous == - 1 { return Err (io :: Error :: last_os_error ()) ; } let new = if nonblocking { previous | libc :: O_NONBLOCK } else { previous & ! libc :: O_NONBLOCK } ; let r = libc :: fcntl (fd , libc :: F_SETFL , new) ; if r == - 1 { return Err (io :: Error :: last_os_error ()) ; } } Ok (()) } . sig",
                        "file_path": "tokio/src/process/unix/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_ip_str_slice",
                        "label": "connect_addr_ip_str_slice",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_ip_str_slice () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"127.0.0.1:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr [..]) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_drop_upgrade",
                        "label": "downgrade_drop_upgrade",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_drop_upgrade () { let (tx , _rx) = mpsc :: channel :: < i32 > (1) ; let weak_tx = tx . clone () . downgrade () ; drop (tx) ; assert ! (weak_tx . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_shutdown",
                        "label": "test_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_shutdown () -> Result < () , Box < dyn Error > > { let (s1 , mut s2) = tokio :: io :: duplex (1024) ; let (_rh , wh) = tokio :: io :: split (s1) ; tokio :: task :: spawn_blocking (move | | -> std :: io :: Result < _ > { let mut wh = SyncIoBridge :: new (wh) ; wh . write_all (b\"hello\") ? ; wh . shutdown () ? ; assert ! (wh . write_all (b\" world\") . is_err ()) ; Ok (()) }) . await ? ? ; let mut buf = vec ! [] ; s2 . read_to_end (& mut buf) . await ? ; assert_eq ! (buf , b\"hello\") ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sync_bridge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "priority_event_on_oob_data",
                        "label": "priority_event_on_oob_data",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] async fn priority_event_on_oob_data () { use std :: net :: SocketAddr ; use tokio :: io :: Interest ; let addr : SocketAddr = \"127.0.0.1:0\" . parse () . unwrap () ; let listener = std :: net :: TcpListener :: bind (addr) . unwrap () ; let addr = listener . local_addr () . unwrap () ; let client = std :: net :: TcpStream :: connect (addr) . unwrap () ; let client = AsyncFd :: with_interest (client , Interest :: PRIORITY) . unwrap () ; let (stream , _) = listener . accept () . unwrap () ; send_oob_data (& stream , b\"hello\") . unwrap () ; let _ = client . ready (Interest :: PRIORITY) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "changed_errors_on_closed_channel_with_seen_value",
                        "label": "changed_errors_on_closed_channel_with_seen_value",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn changed_errors_on_closed_channel_with_seen_value () { let (tx , mut rx) = watch :: channel (\"A\") ; drop (tx) ; rx . changed () . await . expect_err (\"should return error if the tx is closed and the current value is seen\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "closing_unbounded_rx",
                        "label": "closing_unbounded_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn closing_unbounded_rx () { loom :: model (| | { let (tx1 , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx1 . clone () ; thread :: spawn (move | | { drop (rx) ; }) ; block_on (tx1 . closed ()) ; block_on (tx2 . closed ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Worker",
                        "label": "Worker",
                        "kind": "Struct",
                        "signature": "struct Worker",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "is_test_attribute",
                        "label": "is_test_attribute",
                        "kind": "Function",
                        "signature": "fn fn is_test_attribute (attr : & Attribute) -> bool { let path = match & attr . meta { syn :: Meta :: Path (path) => path , _ => return false , } ; let candidates = [[\"core\" , \"prelude\" , \"*\" , \"test\"] , [\"std\" , \"prelude\" , \"*\" , \"test\"] ,] ; if path . leading_colon . is_none () && path . segments . len () == 1 && path . segments [0] . arguments . is_none () && path . segments [0] . ident == \"test\" { return true ; } else if path . segments . len () != candidates [0] . len () { return false ; } candidates . into_iter () . any (| segments | { path . segments . iter () . zip (segments) . all (| (segment , path) | { segment . arguments . is_none () && (path == \"*\" || segment . ident == path) }) }) } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_empty_on_non_vectored",
                        "label": "write_vectored_empty_on_non_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_empty_on_non_vectored () { let mut w = BufWriter :: new (MockWriter :: new (4)) ; let n = assert_ok ! (write_vectored (& mut w , & []) . await) ; assert_eq ! (n , 0) ; let io_vec = [IoSlice :: new (& []) ; 3] ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 0) ; assert_ok ! (w . flush () . await) ; assert ! (w . get_ref () . data . is_empty ()) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_macro_is_resilient_to_shadowing",
                        "label": "test_macro_is_resilient_to_shadowing",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_macro_is_resilient_to_shadowing () { tokio :: spawn (async { }) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_two_lit_expr_no_comma",
                        "label": "sync_two_lit_expr_no_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_no_comma () { let foo = tokio :: try_join ! (async { ok (1) } , async { ok (2) }) ; assert_eq ! (foo , Ok ((1 , 2))) ; let foo = tokio :: try_join ! (biased ; async { ok (1) } , async { ok (2) }) ; assert_eq ! (foo , Ok ((1 , 2))) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "err_abort_early",
                        "label": "err_abort_early",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn err_abort_early () { let (tx1 , rx1) = oneshot :: channel :: < & str > () ; let (tx2 , rx2) = oneshot :: channel :: < u32 > () ; let (_tx3 , rx3) = oneshot :: channel :: < u32 > () ; let mut join = task :: spawn (async { tokio :: try_join ! (rx1 , rx2 , rx3) }) ; assert_pending ! (join . poll ()) ; tx2 . send (123) . unwrap () ; assert ! (join . is_woken ()) ; assert_pending ! (join . poll ()) ; drop (tx1) ; assert ! (join . is_woken ()) ; let res = assert_ready ! (join . poll ()) ; assert ! (res . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "usage",
                        "label": "usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn usage () { time :: pause () ; let mut stream = task :: spawn (futures :: stream :: repeat (()) . throttle (Duration :: from_millis (100))) ; assert_ready ! (stream . poll_next ()) ; assert_pending ! (stream . poll_next ()) ; time :: advance (Duration :: from_millis (90)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (Duration :: from_millis (101)) . await ; assert ! (stream . is_woken ()) ; assert_ready ! (stream . poll_next ()) ; } . sig",
                        "file_path": "tokio-stream/tests/time_throttle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timeout_at",
                        "label": "timeout_at",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Requires a `Future` to complete before the specified instant in time.\"] # [doc = \"\"] # [doc = \" If the future completes before the instant is reached, then the completed\"] # [doc = \" value is returned. Otherwise, an error is returned.\"] # [doc = \"\"] # [doc = \" This function returns a future whose return type is [`Result`]`<T,`[`Elapsed`]`>`, where `T` is the\"] # [doc = \" return type of the provided future.\"] # [doc = \"\"] # [doc = \" If the provided future completes immediately, then the future returned from\"] # [doc = \" this function is guaranteed to complete immediately with an [`Ok`] variant\"] # [doc = \" no matter the provided deadline.\"] # [doc = \"\"] # [doc = \" [`Ok`]: std::result::Result::Ok\"] # [doc = \" [`Result`]: std::result::Result\"] # [doc = \" [`Elapsed`]: crate::time::error::Elapsed\"] # [doc = \"\"] # [doc = \" # Cancellation\"] # [doc = \"\"] # [doc = \" Cancelling a timeout is done by dropping the future. No additional cleanup\"] # [doc = \" or other work is required.\"] # [doc = \"\"] # [doc = \" The original future may be obtained by calling [`Timeout::into_inner`]. This\"] # [doc = \" consumes the `Timeout`.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Create a new `Timeout` set to expire in 10 milliseconds.\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio::time::{Instant, timeout_at};\"] # [doc = \" use tokio::sync::oneshot;\"] # [doc = \"\"] # [doc = \" use std::time::Duration;\"] # [doc = \"\"] # [doc = \" # async fn dox() {\"] # [doc = \" let (tx, rx) = oneshot::channel();\"] # [doc = \" # tx.send(()).unwrap();\"] # [doc = \"\"] # [doc = \" // Wrap the future with a `Timeout` set to expire 10 milliseconds into the\"] # [doc = \" // future.\"] # [doc = \" if let Err(_) = timeout_at(Instant::now() + Duration::from_millis(10), rx).await {\"] # [doc = \"     println!(\\\"did not receive value within 10 ms\\\");\"] # [doc = \" }\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn timeout_at < F > (deadline : Instant , future : F) -> Timeout < F :: IntoFuture > where F : IntoFuture , { let delay = sleep_until (deadline) ; Timeout { value : future . into_future () , delay , } } . sig",
                        "file_path": "tokio/src/time/timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_spawn_many_remote_busy1",
                        "label": "rt_multi_spawn_many_remote_busy1",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_spawn_many_remote_busy1 (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; let flag = Arc :: new (AtomicBool :: new (true)) ; for _ in 0 .. (2 * NUM_WORKERS) { let flag = flag . clone () ; rt . spawn (async move { while flag . load (Relaxed) { tokio :: task :: yield_now () . await ; stall () ; } }) ; } c . bench_function (\"spawn_many_remote_busy1\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; flag . store (false , Relaxed) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UdpFramed",
                        "label": "UdpFramed",
                        "kind": "Struct",
                        "signature": "struct UdpFramed",
                        "file_path": "tokio-util/src/udp/frame.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "open_options_append",
                        "label": "open_options_append",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_options_append () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . append (true)) . contains (\"append: true\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect",
                        "label": "connect",
                        "kind": "Function",
                        "signature": "fn pub async fn connect (addr : & SocketAddr , mut stdin : impl Stream < Item = Result < Bytes , std :: io :: Error > > + Unpin , mut stdout : impl Sink < Bytes , Error = std :: io :: Error > + Unpin ,) -> Result < () , Box < dyn Error > > { let mut stream = TcpStream :: connect (addr) . await ? ; let (r , w) = stream . split () ; let mut sink = FramedWrite :: new (w , BytesCodec :: new ()) ; let mut stream = FramedRead :: new (r , BytesCodec :: new ()) . filter_map (| i | match i { Ok (i) => future :: ready (Some (i . freeze ())) , Err (e) => { println ! (\"failed to read from socket; error={e}\") ; future :: ready (None) } }) . map (Ok) ; match future :: join (sink . send_all (& mut stdin) , stdout . send_all (& mut stream)) . await { (Err (e) , _) | (_ , Err (e)) => Err (e . into ()) , _ => Ok (()) , } } . sig",
                        "file_path": "examples/connect-tcp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "coop_disabled_in_block_in_place",
                        "label": "coop_disabled_in_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn coop_disabled_in_block_in_place () { let outer = tokio :: runtime :: Builder :: new_multi_thread () . enable_time () . build () . unwrap () ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream () ; for i in 0 .. 200 { tx . send (i) . unwrap () ; } drop (tx) ; outer . block_on (async move { let jh = tokio :: spawn (async move { tokio :: task :: block_in_place (move | | { futures :: executor :: block_on (async move { use tokio_stream :: StreamExt ; assert_eq ! (rx . fold (0 , | n , _ | n + 1) . await , 200) ; }) }) }) ; tokio :: time :: timeout (Duration :: from_secs (1) , jh) . await . expect (\"timed out (probably hanging)\") . unwrap () }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "EntryInOneOfTheLists",
                        "label": "EntryInOneOfTheLists",
                        "kind": "Struct",
                        "signature": "struct EntryInOneOfTheLists",
                        "file_path": "tokio/src/util/idle_notified_set.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "open_options_windows_share_mode",
                        "label": "open_options_windows_share_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_share_mode () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . share_mode (0)) . contains (\"share_mode: 0,\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_is_cooperative",
                        "label": "copy_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn copy_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut reader : & [u8] = b\"hello\" ; let mut writer : Vec < u8 > = vec ! [] ; let _ = io :: copy (& mut reader , & mut writer) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_read_flush_err",
                        "label": "write_read_flush_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_read_flush_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "panic_payload_as_str",
                        "label": "panic_payload_as_str",
                        "kind": "Function",
                        "signature": "fn fn panic_payload_as_str (payload : & SyncWrapper < Box < dyn Any + Send > >) -> Option < & str > { if let Some (s) = payload . downcast_ref_sync :: < String > () { return Some (s) ; } if let Some (s) = payload . downcast_ref_sync :: < & 'static str > () { return Some (s) ; } None } . sig",
                        "file_path": "tokio/src/runtime/task/error.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_and_weak_conut",
                        "label": "sender_strong_and_weak_conut",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_and_weak_conut () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let tx2 = tx . clone () ; let weak = tx . downgrade () ; let weak2 = tx2 . downgrade () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (weak . strong_count () , 2) ; assert_eq ! (weak2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; assert_eq ! (tx . weak_count () , 2) ; assert_eq ! (tx2 . weak_count () , 2) ; assert_eq ! (weak . weak_count () , 2) ; assert_eq ! (weak2 . weak_count () , 2) ; assert_eq ! (rx . sender_weak_count () , 2) ; drop (tx2) ; drop (weak2) ; assert_eq ! (tx . strong_count () , 1) ; assert_eq ! (weak . strong_count () , 1) ; assert_eq ! (rx . sender_strong_count () , 1) ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; assert_eq ! (rx . sender_weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_buf",
                        "label": "recv_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn recv_buf () -> std :: io :: Result < () > { let (sock1 , sock2) = UnixDatagram :: pair () ? ; let bytes = b\"hello world\" ; sock1 . send (bytes) . await ? ; let mut buff = Vec :: with_capacity (24) ; let size = sock2 . recv_buf (& mut buff) . await ? ; let dgram = & buff [.. size] ; assert_eq ! (dgram , bytes) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "watch_stream_from_changes",
                        "label": "watch_stream_from_changes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn watch_stream_from_changes () { let (tx , rx) = watch :: channel (\"hello\") ; let mut stream = WatchStream :: from_changes (rx) ; assert_pending ! (spawn (& mut stream) . poll_next ()) ; tx . send (\"bye\") . unwrap () ; assert_eq ! (stream . next () . await . unwrap () , \"bye\") ; } . sig",
                        "file_path": "tokio-stream/tests/watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_eof_then_resume",
                        "label": "read_eof_then_resume",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_eof_then_resume () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x01\" . to_vec ()) , Ok (b\"\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x02\" . to_vec ()) , Ok (b\"\" . to_vec ()) , Ok (b\"\\x00\\x00\\x00\\x03\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 3) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Elapsed",
                        "label": "Elapsed",
                        "kind": "Struct",
                        "signature": "struct Elapsed",
                        "file_path": "tokio-stream/src/stream_ext/timeout.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "metadata",
                        "label": "metadata",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Given a path, queries the file system to get information about a file,\"] # [doc = \" directory, etc.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::metadata`].\"] # [doc = \"\"] # [doc = \" This function will traverse symbolic links to query information about the\"] # [doc = \" destination file.\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `stat` function on Unix and the\"] # [doc = \" `GetFileAttributesEx` function on Windows.  Note that, this [may change in\"] # [doc = \" the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * The user lacks permissions to perform `metadata` call on `path`.\"] # [doc = \" * `path` does not exist.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     let attr = fs::metadata(\\\"/some/file/path.txt\\\").await?;\"] # [doc = \"     // inspect attr ...\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn metadata (path : impl AsRef < Path >) -> io :: Result < Metadata > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: metadata (path)) . await } . sig",
                        "file_path": "tokio/src/fs/metadata.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "WriteFrame",
                        "label": "WriteFrame",
                        "kind": "Struct",
                        "signature": "struct WriteFrame",
                        "file_path": "tokio-util/src/codec/framed_impl.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "multi_rt",
                        "label": "multi_rt",
                        "kind": "Function",
                        "signature": "fn fn multi_rt () -> Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "IoDriverMetrics",
                        "label": "IoDriverMetrics",
                        "kind": "Struct",
                        "signature": "struct IoDriverMetrics",
                        "file_path": "tokio/src/runtime/metrics/io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "socket_works_with_quickack",
                        "label": "socket_works_with_quickack",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn socket_works_with_quickack () { const MESSAGE : & str = \"Hello, tokio!\" ; let (tx_port , rx_port) = oneshot :: channel () ; let server = tokio :: spawn (async move { let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let addr = listener . local_addr () . unwrap () ; tx_port . send (addr . port ()) . unwrap () ; let (mut stream , _) = listener . accept () . await . unwrap () ; stream . set_quickack (true) . unwrap () ; assert ! (stream . quickack () . unwrap ()) ; stream . write_all (MESSAGE . as_bytes ()) . await . unwrap () ; let mut buf = vec ! [0 ; MESSAGE . len ()] ; stream . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (buf , MESSAGE . as_bytes ()) ; stream . set_quickack (false) . unwrap () ; assert ! (! stream . quickack () . unwrap ()) ; stream . shutdown () . await . unwrap () ; }) ; let port = rx_port . await . unwrap () ; let client = tokio :: spawn (async move { let mut stream = TcpStream :: connect (format ! (\"127.0.0.1:{port}\")) . await . unwrap () ; stream . set_quickack (true) . unwrap () ; assert ! (stream . quickack () . unwrap ()) ; let mut buf = vec ! [0 ; MESSAGE . len ()] ; stream . read_exact (& mut buf) . await . unwrap () ; assert_eq ! (buf , MESSAGE . as_bytes ()) ; stream . write_all (MESSAGE . as_bytes ()) . await . unwrap () ; stream . set_quickack (false) . unwrap () ; assert ! (! stream . quickack () . unwrap ()) ; stream . shutdown () . await . unwrap () ; }) ; tokio :: try_join ! (server , client) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/net_quickack.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/signal_multi_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_ready_on_pending",
                        "label": "assert_ready_on_pending",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn assert_ready_on_pending () { let poll = pending () ; assert_ready ! (poll) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "raw_waker",
                        "label": "raw_waker",
                        "kind": "Function",
                        "signature": "fn fn raw_waker (header : NonNull < Header >) -> RawWaker { let ptr = header . as_ptr () as * const () ; RawWaker :: new (ptr , & WAKER_VTABLE) } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "many_oneshot_futures",
                        "label": "many_oneshot_futures",
                        "kind": "Function",
                        "signature": "fn # [test] fn many_oneshot_futures () { const NUM : usize = 1_000 ; for _ in 0 .. 5 { let (tx , rx) = mpsc :: channel () ; let rt = rt () ; let cnt = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. NUM { let cnt = cnt . clone () ; let tx = tx . clone () ; rt . spawn (async move { let num = cnt . fetch_add (1 , Relaxed) + 1 ; if num == NUM { tx . send (()) . unwrap () ; } }) ; } rx . recv () . unwrap () ; drop (rt) ; } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "resubscribe_points_to_tail",
                        "label": "resubscribe_points_to_tail",
                        "kind": "Function",
                        "signature": "fn # [test] fn resubscribe_points_to_tail () { let (tx , mut rx) = broadcast :: channel (3) ; tx . send (1) . unwrap () ; let mut rx_resub = rx . resubscribe () ; assert_empty ! (rx_resub) ; assert_eq ! (assert_recv ! (rx) , 1) ; tx . send (2) . unwrap () ; assert_eq ! (assert_recv ! (rx_resub) , 2) ; tx . send (3) . unwrap () ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_empty ! (rx) ; assert_eq ! (assert_recv ! (rx_resub) , 3) ; assert_empty ! (rx_resub) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "concurrent_write",
                        "label": "concurrent_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn concurrent_write () { let b = loom :: model :: Builder :: new () ; b . check (| | { let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone = rwlock . clone () ; let t1 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write () . await ; * guard += 5 ; }) ; }) ; let rwclone = rwlock . clone () ; let t2 = thread :: spawn (move | | { block_on (async { let mut guard = rwclone . write_owned () . await ; * guard += 5 ; }) ; }) ; t1 . join () . expect (\"thread 1 write should not panic\") ; t2 . join () . expect (\"thread 2 write should not panic\") ; let guard = block_on (rwlock . read ()) ; assert_eq ! (10 , * guard) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length_newline_between_decodes",
                        "label": "lines_decoder_max_length_newline_between_decodes",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length_newline_between_decodes () { const MAX_LENGTH : usize = 5 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"hello\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"\\nworld\") ; assert_eq ! (\"hello\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_permit_releases_permit",
                        "label": "drop_permit_releases_permit",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn drop_permit_releases_permit () { let (tx1 , _rx) = mpsc :: channel :: < i32 > (1) ; let tx2 = tx1 . clone () ; let permit = assert_ok ! (tx1 . reserve () . await) ; let mut reserve2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (reserve2 . poll ()) ; drop (permit) ; assert ! (reserve2 . is_woken ()) ; assert_ready_ok ! (reserve2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_write_err",
                        "label": "write_write_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_write_err () { let mut file = MockFile :: default () ; file . expect_inner_write () . once () . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "level_for",
                        "label": "level_for",
                        "kind": "Function",
                        "signature": "fn fn level_for (elapsed : u64 , when : u64) -> usize { const SLOT_MASK : u64 = (1 << 6) - 1 ; let mut masked = elapsed ^ when | SLOT_MASK ; if masked >= MAX_DURATION { masked = MAX_DURATION - 1 ; } let leading_zeros = masked . leading_zeros () as usize ; let significant = 63 - leading_zeros ; significant / 6 } . sig",
                        "file_path": "tokio-util/src/time/wheel/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_ip_str_port_tuple",
                        "label": "connect_addr_ip_str_port_tuple",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_ip_str_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (\"127.0.0.1\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn split < R > (reader : R , delim : u8) -> Split < R > where R : AsyncBufRead , { Split { reader , buf : Vec :: new () , delim , read : 0 , } } . sig",
                        "file_path": "tokio/src/io/util/split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_single_frame_little_endian",
                        "label": "write_single_frame_little_endian",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_frame_little_endian () { let io = length_delimited :: Builder :: new () . little_endian () . new_write (mock ! { data (b\"\\x09\\x00\\x00\\x00\") , data (b\"abcdefghi\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "move_children_to_parent",
                        "label": "move_children_to_parent",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Moves all children from `node` to `parent`.\"] # [doc = \"\"] # [doc = \" `parent` MUST have been a parent of the node when they both got locked,\"] # [doc = \" otherwise there is a potential for a deadlock as invariant #2 would be violated.\"] # [doc = \"\"] # [doc = \" To acquire the locks for node and parent, use [`with_locked_node_and_parent`].\"] fn move_children_to_parent (node : & mut Inner , parent : & mut Inner) { parent . children . reserve (node . children . len ()) ; for child in std :: mem :: take (& mut node . children) { { let mut child_locked = child . inner . lock () . unwrap () ; child_locked . parent . clone_from (& node . parent) ; child_locked . parent_idx = parent . children . len () ; } parent . children . push (child) ; } } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "one",
                        "label": "one",
                        "kind": "Function",
                        "signature": "fn async fn one () { } . sig",
                        "file_path": "tokio/tests/macros_pin.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "atomic_waker_panic_safe",
                        "label": "atomic_waker_panic_safe",
                        "kind": "Function",
                        "signature": "fn # [cfg (panic = \"unwind\")] # [test] # [cfg (not (target_family = \"wasm\"))] fn atomic_waker_panic_safe () { use std :: panic ; use std :: ptr ; use std :: task :: { RawWaker , RawWakerVTable , Waker } ; static PANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | panic ! (\"clone\") , | _ | unimplemented ! (\"wake\") , | _ | unimplemented ! (\"wake_by_ref\") , | _ | () ,) ; static NONPANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | RawWaker :: new (ptr :: null () , & NONPANICKING_VTABLE) , | _ | unimplemented ! (\"wake\") , | _ | unimplemented ! (\"wake_by_ref\") , | _ | () ,) ; let panicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & PANICKING_VTABLE)) } ; let nonpanicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & NONPANICKING_VTABLE)) } ; let atomic_waker = AtomicWaker :: new () ; let panicking = panic :: AssertUnwindSafe (& panicking) ; let result = panic :: catch_unwind (| | { let panic :: AssertUnwindSafe (panicking) = panicking ; atomic_waker . register_by_ref (panicking) ; }) ; assert ! (result . is_err ()) ; assert ! (atomic_waker . take_waker () . is_none ()) ; atomic_waker . register_by_ref (& nonpanicking) ; assert ! (atomic_waker . take_waker () . is_some ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AtomicUsize",
                        "label": "AtomicUsize",
                        "kind": "Struct",
                        "signature": "struct AtomicUsize",
                        "file_path": "tokio/src/loom/std/atomic_usize.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "assert_pending_on_ready",
                        "label": "assert_pending_on_ready",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn assert_pending_on_ready () { let poll = ready () ; assert_pending ! (poll) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "require_sync",
                        "label": "require_sync",
                        "kind": "Function",
                        "signature": "fn # [allow (dead_code)] fn require_sync < T : Sync > (_t : & T) { } . sig",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskTrackerInner",
                        "label": "TaskTrackerInner",
                        "kind": "Struct",
                        "signature": "struct TaskTrackerInner",
                        "file_path": "tokio-util/src/task/task_tracker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unpack",
                        "label": "unpack",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Unpacks a value using a mask & shift.\"] pub (crate) const fn unpack (src : usize , mask : usize , shift : u32) -> usize { (src & mask) >> shift } . sig",
                        "file_path": "tokio/src/util/bit.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_fail",
                        "label": "main_fail",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Always fails with the error message below.\"] # [doc = \" ```text\"] # [doc = \" The #[tokio::main] macro requires rt or rt-multi-thread.\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn main_fail (_args : TokenStream , _item : TokenStream) -> TokenStream { syn :: Error :: new (proc_macro2 :: Span :: call_site () , \"The #[tokio::main] macro requires rt or rt-multi-thread.\" ,) . to_compile_error () . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_on_close_reopen",
                        "label": "notify_on_close_reopen",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_on_close_reopen () { let tracker = TaskTracker :: new () ; let mut wait = task :: spawn (tracker . wait ()) ; assert_pending ! (wait . poll ()) ; tracker . close () ; tracker . reopen () ; assert_ready ! (wait . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interleave_enter_different_rt",
                        "label": "interleave_enter_different_rt",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg_attr (panic = \"abort\" , ignore)] fn interleave_enter_different_rt () { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter1) ; drop (enter2) ; } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_bounded",
                        "label": "send_recv_bounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_recv_bounded () { let (tx , mut rx) = broadcast :: channel (16) ; let mut recv = task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; assert_ok ! (tx . send (\"hello\")) ; assert ! (recv . is_woken ()) ; let val = assert_ready_ok ! (recv . poll ()) ; assert_eq ! (val , \"hello\") ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_main",
                        "label": "local_main",
                        "kind": "Function",
                        "signature": "fn # [cfg (tokio_unstable)] # [tokio :: main (flavor = \"local\")] async fn local_main () -> usize { let join = tokio :: task :: spawn_local (async { 1 }) ; join . await . unwrap () } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "EventInfo",
                        "label": "EventInfo",
                        "kind": "Struct",
                        "signature": "struct EventInfo",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "receiver_wait_for_is_cooperative",
                        "label": "receiver_wait_for_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_wait_for_is_cooperative () { let (tx , mut rx) = watch :: channel (0) ; drop (tx) ; tokio :: select ! { biased ; _ = async { loop { assert ! (rx . wait_for (| val | * val == 1) . await . is_err ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_tasks_are_polled_after_tick_inner",
                        "label": "local_tasks_are_polled_after_tick_inner",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: main (flavor = \"current_thread\")] async fn local_tasks_are_polled_after_tick_inner () { static RX1 : AtomicUsize = AtomicUsize :: new (0) ; static RX2 : AtomicUsize = AtomicUsize :: new (0) ; const EXPECTED : usize = 500 ; RX1 . store (0 , SeqCst) ; RX2 . store (0 , SeqCst) ; let (tx , mut rx) = mpsc :: unbounded_channel () ; let local = LocalSet :: new () ; local . run_until (async { let task2 = task :: spawn (async move { time :: sleep (Duration :: from_millis (10)) . await ; let mut oneshots = Vec :: with_capacity (EXPECTED) ; for _ in 0 .. EXPECTED { let (oneshot_tx , oneshot_rx) = oneshot :: channel () ; oneshots . push (oneshot_tx) ; tx . send (oneshot_rx) . unwrap () ; } time :: sleep (Duration :: from_millis (10)) . await ; for tx in oneshots . drain (..) { tx . send (()) . unwrap () ; } loop { time :: sleep (Duration :: from_millis (20)) . await ; let rx1 = RX1 . load (SeqCst) ; let rx2 = RX2 . load (SeqCst) ; if rx1 == EXPECTED && rx2 == EXPECTED { break ; } } }) ; while let Some (oneshot) = rx . recv () . await { RX1 . fetch_add (1 , SeqCst) ; task :: spawn_local (async move { oneshot . await . unwrap () ; RX2 . fetch_add (1 , SeqCst) ; }) ; } task2 . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadBufParts",
                        "label": "ReadBufParts",
                        "kind": "Struct",
                        "signature": "struct ReadBufParts",
                        "file_path": "tokio/src/io/util/vec_with_initialized.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "poll_ready",
                        "label": "poll_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn poll_ready () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server = UnixDatagram :: bind (& server_path) ? ; let client = UnixDatagram :: bind (& client_path) ? ; for _ in 0 .. 5 { loop { poll_fn (| cx | client . poll_send_ready (cx)) . await ? ; match client . try_send_to (b\"hello world\" , & server_path) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { poll_fn (| cx | server . poll_recv_ready (cx)) . await ? ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr . as_pathname () , Some (client_path . as_ref ())) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_tee",
                        "label": "read_tee",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_tee () { let contents = b\"This could be really long, you know\" . to_vec () ; let reader = SmallReader { contents : contents . clone () , } ; let mut altout : Vec < u8 > = Vec :: new () ; let mut teeout = Vec :: new () ; { let mut tee = InspectReader :: new (reader , | bytes | altout . extend (bytes)) ; tee . read_to_end (& mut teeout) . await . unwrap () ; } assert_eq ! (teeout , altout) ; assert_eq ! (altout . len () , contents . len ()) ; } . sig",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tcp_listener_from_std_panic_caller",
                        "label": "tcp_listener_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn tcp_listener_from_std_panic_caller () -> Result < () , Box < dyn Error > > { let std_listener = std :: net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; std_listener . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = TcpListener :: from_std (std_listener) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "VecWithInitialized",
                        "label": "VecWithInitialized",
                        "kind": "Struct",
                        "signature": "struct VecWithInitialized",
                        "file_path": "tokio/src/io/util/vec_with_initialized.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_buf",
                        "label": "read_buf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Read data from an `AsyncRead` into an implementer of the [`BufMut`] trait.\"] # [doc = \"\"] # [doc = \" [`BufMut`]: bytes::BufMut\"] # [doc = \"\"] # [doc = \" # Example\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use bytes::{Bytes, BytesMut};\"] # [doc = \" use tokio_stream as stream;\"] # [doc = \" use tokio::io::Result;\"] # [doc = \" use tokio_util::io::{StreamReader, read_buf};\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() -> std::io::Result<()> {\"] # [doc = \"\"] # [doc = \" // Create a reader from an iterator. This particular reader will always be\"] # [doc = \" // ready.\"] # [doc = \" let mut read = StreamReader::new(stream::iter(vec![Result::Ok(Bytes::from_static(&[0, 1, 2, 3]))]));\"] # [doc = \"\"] # [doc = \" let mut buf = BytesMut::new();\"] # [doc = \" let mut reads = 0;\"] # [doc = \"\"] # [doc = \" loop {\"] # [doc = \"     reads += 1;\"] # [doc = \"     let n = read_buf(&mut read, &mut buf).await?;\"] # [doc = \"\"] # [doc = \"     if n == 0 {\"] # [doc = \"         break;\"] # [doc = \"     }\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" // one or more reads might be necessary.\"] # [doc = \" assert!(reads >= 1);\"] # [doc = \" assert_eq!(&buf[..], &[0, 1, 2, 3]);\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn read_buf < R , B > (read : & mut R , buf : & mut B) -> io :: Result < usize > where R : AsyncRead + Unpin , B : BufMut , { return ReadBufFn (read , buf) . await ; struct ReadBufFn < 'a , R , B > (& 'a mut R , & 'a mut B) ; impl < 'a , R , B > Future for ReadBufFn < 'a , R , B > where R : AsyncRead + Unpin , B : BufMut , { type Output = io :: Result < usize > ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < Self :: Output > { let this = & mut * self ; crate :: util :: poll_read_buf (Pin :: new (this . 0) , cx , this . 1) } } } . sig",
                        "file_path": "tokio-util/src/io/read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_partial_then_not_ready",
                        "label": "read_partial_then_not_ready",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_partial_then_not_ready () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert_read ! (pin ! (framed) . poll_next (cx) , 1) ; assert_read ! (pin ! (framed) . poll_next (cx) , 2) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wait_for_returns_correct_value",
                        "label": "wait_for_returns_correct_value",
                        "kind": "Function",
                        "signature": "fn # [test] fn wait_for_returns_correct_value () { loom :: model (move | | { let (tx , mut rx) = watch :: channel (0) ; let jh = thread :: spawn (move | | { tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; tx . send (3) . unwrap () ; }) ; let mut stopped_at = usize :: MAX ; let returned = * block_on (rx . wait_for (| x | { stopped_at = * x ; true })) . unwrap () ; assert_eq ! (stopped_at , returned) ; jh . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Overflow",
                        "label": "Overflow",
                        "kind": "Trait",
                        "signature": "trait Overflow",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/overflow.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "multi_pin",
                        "label": "multi_pin",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn multi_pin () { tokio :: pin ! { let f1 = one () ; let f2 = two () ; } (& mut f1) . await ; (& mut f2) . await ; } . sig",
                        "file_path": "tokio/tests/macros_pin.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "channel",
                        "label": "channel",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn channel < T > () -> (Sender < T > , Receiver < T >) { let inner = Arc :: new (Inner { notify : Notify :: new () , value : Mutex :: new (None) , }) ; let tx = Sender { inner : inner . clone () , } ; let rx = Receiver { inner } ; (tx , rx) } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "expire_first_key_when_reset_to_expire_earlier",
                        "label": "expire_first_key_when_reset_to_expire_earlier",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn expire_first_key_when_reset_to_expire_earlier () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let one = queue . insert_at (\"one\" , now + ms (200)) ; queue . insert_at (\"two\" , now + ms (250)) ; assert_pending ! (poll ! (queue)) ; queue . reset_at (& one , now + ms (100)) ; sleep (ms (100)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"one\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_until_pending",
                        "label": "read_until_pending",
                        "kind": "Function",
                        "signature": "fn fn read_until_pending (stream : & mut TcpStream) -> usize { let mut buf = vec ! [0u8 ; 1024 * 1024] ; let mut total = 0 ; loop { match stream . try_read (& mut buf) { Ok (n) => total += n , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } total } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_multi_frame_in_packet",
                        "label": "write_multi_frame_in_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_multi_frame_in_packet () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\" . to_vec ()) , } ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; task . enter (| cx , _ | { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (1) . is_ok ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (2) . is_ok ()) ; assert_eq ! (1 , framed . get_ref () . calls . len ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_second_test_attr_rust_2018",
                        "label": "test_has_second_test_attr_rust_2018",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [:: std :: prelude :: rust_2018 :: test] async fn test_has_second_test_attr_rust_2018 () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SchedulerMetrics",
                        "label": "SchedulerMetrics",
                        "kind": "Struct",
                        "signature": "struct SchedulerMetrics",
                        "file_path": "tokio/src/runtime/metrics/scheduler.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "current_thread",
                        "label": "current_thread",
                        "kind": "Function",
                        "signature": "fn fn current_thread () -> Runtime { Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_overflow",
                        "label": "size_overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_overflow () { struct Monster ; impl tokio_stream :: Stream for Monster { type Item = () ; fn poll_next (self : std :: pin :: Pin < & mut Self > , _cx : & mut std :: task :: Context < '_ > ,) -> std :: task :: Poll < Option < () > > { panic ! () } fn size_hint (& self) -> (usize , Option < usize >) { (usize :: MAX , Some (usize :: MAX)) } } let m1 = Monster ; let m2 = Monster ; let m = m1 . chain (m2) ; assert_eq ! (m . size_hint () , (usize :: MAX , None)) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let mut one = stream :: once (1) ; assert_eq ! (one . size_hint () , (1 , Some (1))) ; assert_eq ! (Some (1) , one . next () . await) ; assert_eq ! (one . size_hint () , (0 , Some (0))) ; assert_eq ! (None , one . next () . await) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_closing",
                        "label": "basic_closing",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic_closing () { const NUM : usize = 2 ; loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (1)) ; for _ in 0 .. NUM { let semaphore = semaphore . clone () ; thread :: spawn (move | | { for _ in 0 .. 2 { block_on (semaphore . acquire (1)) . map_err (| _ | ()) ? ; semaphore . release (1) ; } Ok :: < () , () > (()) }) ; } semaphore . close () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multithreaded",
                        "label": "multithreaded",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [cfg_attr (miri , ignore)] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 8)] async fn multithreaded () { use futures :: stream :: { self , StreamExt } ; use std :: sync :: Arc ; use tokio :: sync :: Barrier ; let barrier = Arc :: new (Barrier :: new (5)) ; let rwlock = Arc :: new (RwLock :: < u32 > :: new (0)) ; let rwclone1 = rwlock . clone () ; let rwclone2 = rwlock . clone () ; let rwclone3 = rwlock . clone () ; let rwclone4 = rwlock . clone () ; let b1 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone1 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 2 ; } }) . await ; b1 . wait () . await ; }) ; let b2 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone2 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 3 ; } }) . await ; b2 . wait () . await ; }) ; let b3 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone3 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 5 ; } }) . await ; b3 . wait () . await ; }) ; let b4 = barrier . clone () ; tokio :: spawn (async move { stream :: iter (0 .. 1000) . for_each (move | _ | { let rwlock = rwclone4 . clone () ; async move { let mut guard = rwlock . write () . await ; * guard += 7 ; } }) . await ; b4 . wait () . await ; }) ; barrier . wait () . await ; let g = rwlock . read () . await ; assert_eq ! (* g , 17_000) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_loop",
                        "label": "multi_loop",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_loop () { let (sender , receiver) = channel () ; for _ in 0 .. 10 { let threads : Vec < _ > = (0 .. 4) . map (| _ | { let sender = sender . clone () ; thread :: spawn (move | | { let rt = rt () ; let _ = rt . block_on (async { let mut signal = signal (SignalKind :: hangup ()) . unwrap () ; sender . send (()) . unwrap () ; signal . recv () . await }) ; }) }) . collect () ; for & _ in threads . iter () { receiver . recv () . unwrap () ; } send_signal (libc :: SIGHUP) ; for t in threads { t . join () . unwrap () ; } } } . sig",
                        "file_path": "tokio/tests/signal_multi_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_single_multi_frame_one_packet",
                        "label": "write_single_multi_frame_one_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_single_multi_frame_one_packet () { let io = FramedWrite :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09\") , data (b\"abcdefghi\") , data (b\"\\x00\\x00\\x00\\x03\") , data (b\"123\") , data (b\"\\x00\\x00\\x00\\x0b\") , data (b\"hello world\") , flush () , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdefghi\"))) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"123\"))) ; assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"hello world\"))) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "max_write_size",
                        "label": "max_write_size",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn max_write_size () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { let n = a . write (& [0u8 ; 64]) . await . unwrap () ; assert_eq ! (n , 32) ; let n = a . write (& [0u8 ; 64]) . await . unwrap () ; assert_eq ! (n , 4) ; }) ; let mut buf = [0u8 ; 4] ; b . read_exact (& mut buf) . await . unwrap () ; t1 . await . unwrap () ; drop (b) ; } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Notified",
                        "label": "Notified",
                        "kind": "Struct",
                        "signature": "struct Notified",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "slice_assume_init_mut",
                        "label": "slice_assume_init_mut",
                        "kind": "Function",
                        "signature": "fn unsafe fn slice_assume_init_mut (slice : & mut [MaybeUninit < u8 >]) -> & mut [u8] { & mut * (slice as * mut [MaybeUninit < u8 >] as * mut [u8]) } . sig",
                        "file_path": "tokio/src/io/read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_attr_has_unknown_args",
                        "label": "main_attr_has_unknown_args",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main (foo)] async fn main_attr_has_unknown_args () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Sender",
                        "label": "Sender",
                        "kind": "Struct",
                        "signature": "struct Sender",
                        "file_path": "tokio/src/sync/oneshot.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "update_permits_many_times",
                        "label": "update_permits_many_times",
                        "kind": "Function",
                        "signature": "fn # [test] fn update_permits_many_times () { let s = Semaphore :: new (5) ; let mut acquire = task :: spawn (s . acquire (7)) ; assert_pending ! (acquire . poll ()) ; s . release (5) ; assert_ready_ok ! (acquire . poll ()) ; assert_eq ! (s . available_permits () , 3) ; assert_eq ! (s . forget_permits (3) , 3) ; assert_eq ! (s . available_permits () , 0) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "echo_server",
                        "label": "echo_server",
                        "kind": "Function",
                        "signature": "fn async fn echo_server (socket : UnixDatagram) -> io :: Result < () > { let mut recv_buf = vec ! [0u8 ; 1024] ; loop { let (len , peer_addr) = socket . recv_from (& mut recv_buf [..]) . await ? ; if let Some (path) = peer_addr . as_pathname () { socket . send_to (& recv_buf [.. len] , path) . await ? ; } } } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnixListenerStream",
                        "label": "UnixListenerStream",
                        "kind": "Struct",
                        "signature": "struct UnixListenerStream",
                        "file_path": "tokio-stream/src/wrappers/unix_listener.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "start_stop_callbacks_called",
                        "label": "start_stop_callbacks_called",
                        "kind": "Function",
                        "signature": "fn # [test] fn start_stop_callbacks_called () { use std :: sync :: atomic :: { AtomicUsize , Ordering } ; let after_start = Arc :: new (AtomicUsize :: new (0)) ; let before_stop = Arc :: new (AtomicUsize :: new (0)) ; let after_inner = after_start . clone () ; let before_inner = before_stop . clone () ; let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . on_thread_start (move | | { after_inner . clone () . fetch_add (1 , Ordering :: Relaxed) ; }) . on_thread_stop (move | | { before_inner . clone () . fetch_add (1 , Ordering :: Relaxed) ; }) . build () . unwrap () ; let (tx , rx) = oneshot :: channel () ; rt . spawn (async move { assert_ok ! (tx . send (())) ; }) ; assert_ok ! (rt . block_on (rx)) ; drop (rt) ; assert ! (after_start . load (Ordering :: Relaxed) > 0) ; assert ! (before_stop . load (Ordering :: Relaxed) > 0) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_cell",
                        "label": "drop_cell",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_cell () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; { let once_cell = OnceCell :: new () ; let prev = once_cell . set (Foo :: from (num_drops . clone ())) ; assert ! (prev . is_ok ()) } assert ! (num_drops . load (Ordering :: Acquire) == 1) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "build_dir_mode_read_only",
                        "label": "build_dir_mode_read_only",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (unix)] async fn build_dir_mode_read_only () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"abc\") ; assert_ok ! (fs :: DirBuilder :: new () . recursive (true) . mode (0o444) . create (& new_dir) . await) ; assert ! (fs :: metadata (new_dir) . await . expect (\"metadata result\") . permissions () . readonly ()) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_notification",
                        "label": "basic_notification",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic_notification () { const NUM_NOTIFY : usize = 2 ; loom :: model (| | { let chan = Arc :: new (Chan { num : AtomicUsize :: new (0) , task : AtomicWaker :: new () , }) ; for _ in 0 .. NUM_NOTIFY { let chan = chan . clone () ; thread :: spawn (move | | { chan . num . fetch_add (1 , Relaxed) ; chan . task . wake () ; }) ; } block_on (poll_fn (move | cx | { chan . task . register_by_ref (cx . waker ()) ; if NUM_NOTIFY == chan . num . load (Relaxed) { return Ready (()) ; } Pending })) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from_file",
                        "label": "from_file",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"from_file\") ? ; let file = std :: fs :: OpenOptions :: new () . read (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let mut reader = pipe :: Receiver :: from_file (file) ? ; let file = std :: fs :: OpenOptions :: new () . write (true) . custom_flags (libc :: O_NONBLOCK) . open (& fifo) ? ; let mut writer = pipe :: Sender :: from_file (file) ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; writer . write_all (DATA) . await ? ; let read_data = assert_ok ! (read_fut . await) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_resubscribe",
                        "label": "contention_resubscribe",
                        "kind": "Function",
                        "signature": "fn fn contention_resubscribe < const N_TASKS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let (snd , _) = watch :: channel (0i32) ; let snd = Arc :: new (snd) ; let wg = Arc :: new ((AtomicU64 :: new (0) , Notify :: new ())) ; for n in 0 .. N_TASKS { let mut rcv = snd . subscribe () ; let wg = wg . clone () ; let mut rng = rand :: rngs :: StdRng :: seed_from_u64 (n as u64) ; rt . spawn (async move { while rcv . changed () . await . is_ok () { let _ = * rcv . borrow () ; let r = do_work (& mut rng) ; let _ = black_box (r) ; if wg . 0 . fetch_sub (1 , Ordering :: Release) == 1 { wg . 1 . notify_one () ; } } }) ; } const N_ITERS : usize = 100 ; g . bench_function (N_TASKS . to_string () , | b | { b . iter (| | { rt . block_on ({ let snd = snd . clone () ; let wg = wg . clone () ; async move { tokio :: spawn (async move { for _ in 0 .. N_ITERS { assert_eq ! (wg . 0 . fetch_add (N_TASKS as u64 , Ordering :: Relaxed) , 0) ; let _ = snd . send (black_box (42)) ; while wg . 0 . load (Ordering :: Acquire) > 0 { wg . 1 . notified () . await ; } } }) . await . unwrap () ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "require_send",
                        "label": "require_send",
                        "kind": "Function",
                        "signature": "fn # [allow (dead_code)] fn require_send < T : Send > (_t : & T) { } . sig",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FinalConfig",
                        "label": "FinalConfig",
                        "kind": "Struct",
                        "signature": "struct FinalConfig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sink_send_then_flush",
                        "label": "sink_send_then_flush",
                        "kind": "Function",
                        "signature": "fn # [test] fn sink_send_then_flush () { let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (())) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; let mut flush = spawn (poll_fn (| cx | send . poll_flush_unpin (cx))) ; assert_ready_ok ! (flush . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_pending ! (ready . poll ()) ; assert_ready_eq ! (recv_task . poll () , Some (())) ; assert ! (ready . is_woken ()) ; assert_ready_ok ! (ready . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_on_empty_channel_without_senders",
                        "label": "test_rx_len_on_empty_channel_without_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_on_empty_channel_without_senders () { let (tx , rx) = mpsc :: channel :: < () > (100) ; drop (tx) ; assert_eq ! (rx . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "concurrent_permit_updates",
                        "label": "concurrent_permit_updates",
                        "kind": "Function",
                        "signature": "fn # [test] fn concurrent_permit_updates () { loom :: model (move | | { let semaphore = Arc :: new (Semaphore :: new (5)) ; let t1 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | semaphore . release (3)) } ; let t2 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | { semaphore . try_acquire (1) . expect (\"try_acquire should succeed\") }) } ; let t3 = { let semaphore = semaphore . clone () ; thread :: spawn (move | | semaphore . forget_permits (2)) } ; t1 . join () . unwrap () ; t2 . join () . unwrap () ; t3 . join () . unwrap () ; assert_eq ! (semaphore . available_permits () , 5) ; }) } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timer_with_threaded_runtime",
                        "label": "timer_with_threaded_runtime",
                        "kind": "Function",
                        "signature": "fn # [cfg (all (feature = \"rt-multi-thread\" , not (target_os = \"wasi\")))] # [test] fn timer_with_threaded_runtime () { use tokio :: runtime :: Runtime ; let rt = Runtime :: new () . unwrap () ; let (tx , rx) = mpsc :: channel () ; rt . spawn (async move { let when = Instant :: now () + Duration :: from_millis (10) ; sleep_until (when) . await ; assert ! (Instant :: now () >= when) ; tx . send (()) . unwrap () ; }) ; rx . recv () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_without_panic_3157",
                        "label": "test_abort_without_panic_3157",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a suspended task can be aborted without panicking as reported in\"] # [doc = \" issue #3157: <https://github.com/tokio-rs/tokio/issues/3157>.\"] # [test] fn test_abort_without_panic_3157 () { let rt = Builder :: new_multi_thread () . enable_time () . worker_threads (1) . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; let _ = handle . await ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_future_destructor_abort",
                        "label": "task_id_future_destructor_abort",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_future_destructor_abort () { struct MyFuture { tx : Option < oneshot :: Sender < Id > > , } impl Future for MyFuture { type Output = () ; fn poll (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx . take () . unwrap () . send (task :: id ()) ; } } let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (MyFuture { tx : Some (tx) }) ; let id = handle . id () ; handle . abort () ; assert ! (handle . await . unwrap_err () . is_cancelled ()) ; assert_eq ! (rx . await . unwrap () , id) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "simplex",
                        "label": "simplex",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates unidirectional buffer that acts like in memory pipe.\"] # [doc = \"\"] # [doc = \" The `max_buf_size` argument is the maximum amount of bytes that can be\"] # [doc = \" written to a buffer before the it returns `Poll::Pending`.\"] # [doc = \"\"] # [doc = \" # Unify reader and writer\"] # [doc = \"\"] # [doc = \" The reader and writer half can be unified into a single structure\"] # [doc = \" of `SimplexStream` that supports both reading and writing or\"] # [doc = \" the `SimplexStream` can be already created as unified structure\"] # [doc = \" using [`SimplexStream::new_unsplit()`].\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # async fn ex() -> std::io::Result<()> {\"] # [doc = \" # use tokio::io::{AsyncReadExt, AsyncWriteExt};\"] # [doc = \" let (reader, writer) = tokio::io::simplex(64);\"] # [doc = \" let mut simplex_stream = reader.unsplit(writer);\"] # [doc = \" simplex_stream.write_all(b\\\"hello\\\").await?;\"] # [doc = \"\"] # [doc = \" let mut buf = [0u8; 5];\"] # [doc = \" simplex_stream.read_exact(&mut buf).await?;\"] # [doc = \" assert_eq!(&buf, b\\\"hello\\\");\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] # [cfg_attr (docsrs , doc (cfg (feature = \"io-util\")))] pub fn simplex (max_buf_size : usize) -> (ReadHalf < SimplexStream > , WriteHalf < SimplexStream >) { split (SimplexStream :: new_unsplit (max_buf_size)) } . sig",
                        "file_path": "tokio/src/io/util/mem.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "simple",
                        "label": "simple",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn simple () { let mut cmd ; if cfg ! (windows) { cmd = Command :: new (\"cmd\") ; cmd . arg (\"/c\") ; } else { cmd = Command :: new (\"sh\") ; cmd . arg (\"-c\") ; } let mut child = cmd . arg (\"exit 2\") . spawn () . unwrap () ; let id = child . id () . expect (\"missing id\") ; assert ! (id > 0) ; let status = assert_ok ! (child . wait () . await) ; assert_eq ! (status . code () , Some (2)) ; let status = assert_ok ! (child . wait () . await) ; assert_eq ! (status . code () , Some (2)) ; assert_eq ! (child . id () , None) ; drop (child . kill ()) ; } . sig",
                        "file_path": "tokio/tests/process_smoke.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_state",
                        "label": "set_state",
                        "kind": "Function",
                        "signature": "fn fn set_state (data : usize , state : usize) -> usize { (data & NOTIFY_WAITERS_CALLS_MASK) | (state & STATE_MASK) } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_pool_handle_spawn_pinned_by_idx_panic_caller",
                        "label": "local_pool_handle_spawn_pinned_by_idx_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_pool_handle_spawn_pinned_by_idx_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let handle = LocalPoolHandle :: new (2) ; handle . spawn_pinned_by_idx (| | async { \"test\" } , 3) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy",
                        "label": "copy",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Copies the contents of one file to another. This function will also copy the permission bits\"] # [doc = \" of the original file to the destination file.\"] # [doc = \" This function will overwrite the contents of to.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::fs::copy`].\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::copy(\\\"foo.txt\\\", \\\"bar.txt\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn copy (from : impl AsRef < Path > , to : impl AsRef < Path >) -> Result < u64 , std :: io :: Error > { let from = from . as_ref () . to_owned () ; let to = to . as_ref () . to_owned () ; asyncify (| | std :: fs :: copy (from , to)) . await } . sig",
                        "file_path": "tokio/src/fs/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending_buf_writer_seek",
                        "label": "maybe_pending_buf_writer_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending_buf_writer_seek () { struct MaybePendingSeek { inner : Cursor < Vec < u8 > > , ready_write : bool , ready_seek : bool , seek_res : Option < io :: Result < () > > , } impl MaybePendingSeek { fn new (inner : Vec < u8 >) -> Self { Self { inner : Cursor :: new (inner) , ready_write : false , ready_seek : false , seek_res : None , } } } impl AsyncWrite for MaybePendingSeek { fn poll_write (mut self : Pin < & mut Self > , cx : & mut Context < '_ > , buf : & [u8] ,) -> Poll < io :: Result < usize > > { if self . ready_write { self . ready_write = false ; Pin :: new (& mut self . inner) . poll_write (cx , buf) } else { self . ready_write = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } fn poll_flush (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_flush (cx) } fn poll_shutdown (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_shutdown (cx) } } impl AsyncSeek for MaybePendingSeek { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { self . seek_res = Some (Pin :: new (& mut self . inner) . start_seek (pos)) ; Ok (()) } fn poll_complete (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { if self . ready_seek { self . ready_seek = false ; self . seek_res . take () . unwrap_or (Ok (())) ? ; Pin :: new (& mut self . inner) . poll_complete (cx) } else { self . ready_seek = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } } let mut w = BufWriter :: with_capacity (3 , MaybePendingSeek :: new (Vec :: new ())) ; w . write_all (& [0 , 1 , 2 , 3 , 4 , 5]) . await . unwrap () ; w . write_all (& [6 , 7]) . await . unwrap () ; assert_eq ! (w . seek (SeekFrom :: Current (0)) . await . unwrap () , 8) ; assert_eq ! (& w . get_ref () . inner . get_ref () [..] , & [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7] [..]) ; assert_eq ! (w . seek (SeekFrom :: Start (2)) . await . unwrap () , 2) ; w . write_all (& [8 , 9]) . await . unwrap () ; w . flush () . await . unwrap () ; assert_eq ! (& w . into_inner () . inner . into_inner () [..] , & [0 , 1 , 8 , 9 , 4 , 5 , 6 , 7]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_ready",
                        "label": "is_ready",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns `true` if the specified slot has a value ready to be consumed.\"] fn is_ready (bits : usize , slot : usize) -> bool { let mask = 1 << slot ; mask == mask & bits } . sig",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_one_lit_expr_comma",
                        "label": "sync_one_lit_expr_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_one_lit_expr_comma () { let foo = tokio :: join ! (async { 1 } ,) ; assert_eq ! (foo , (1 ,)) ; let foo = tokio :: join ! (biased ; async { 1 } ,) ; assert_eq ! (foo , (1 ,)) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "uncontented_bounded",
                        "label": "uncontented_bounded",
                        "kind": "Function",
                        "signature": "fn fn uncontented_bounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for i in 0 .. 5000 { tx . send (i) . await . unwrap () ; } for _ in 0 .. 5_000 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedMutexGuardInner",
                        "label": "OwnedMutexGuardInner",
                        "kind": "Struct",
                        "signature": "struct OwnedMutexGuardInner",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "uncontended_concurrent_multi",
                        "label": "uncontended_concurrent_multi",
                        "kind": "Function",
                        "signature": "fn fn uncontended_concurrent_multi (g : & mut BenchmarkGroup < WallTime >) { let rt = multi_rt () ; let s = Arc :: new (Semaphore :: new (10)) ; g . bench_function (\"concurrent_multi\" , | b | { b . iter (| | { let s = s . clone () ; rt . block_on (async move { let j = tokio :: try_join ! { task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) , task :: spawn (task (s . clone ())) } ; j . unwrap () ; }) }) }) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "terminate_task_hook_fires",
                        "label": "terminate_task_hook_fires",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Assert that the terminate task hook always fires when set.\"] # [test] fn terminate_task_hook_fires () { let count = Arc :: new (AtomicUsize :: new (0)) ; let count2 = Arc :: clone (& count) ; let runtime = Builder :: new_current_thread () . on_task_terminate (move | _data | { count2 . fetch_add (1 , Ordering :: SeqCst) ; }) . build () . unwrap () ; for _ in 0 .. TASKS { runtime . spawn (std :: future :: ready (())) ; } runtime . block_on (async { for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; assert_eq ! (TASKS , count . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/task_hooks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_cancels_tasks",
                        "label": "drop_cancels_tasks",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_cancels_tasks () { use std :: rc :: Rc ; let rt = rt () ; let rc1 = Rc :: new (()) ; let rc2 = rc1 . clone () ; let (started_tx , started_rx) = oneshot :: channel () ; let local = LocalSet :: new () ; local . spawn_local (async move { let _rc2 = rc2 ; started_tx . send (()) . unwrap () ; futures :: future :: pending :: < () > () . await ; }) ; local . block_on (& rt , async { started_rx . await . unwrap () ; }) ; drop (local) ; drop (rt) ; assert_eq ! (1 , Rc :: strong_count (& rc1)) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_semaphore_notifies_permit2",
                        "label": "close_semaphore_notifies_permit2",
                        "kind": "Function",
                        "signature": "fn # [test] fn close_semaphore_notifies_permit2 () { let s = Semaphore :: new (2) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; let mut acquire3 = task :: spawn (s . acquire (1)) ; let mut acquire4 = task :: spawn (s . acquire (1)) ; assert_pending ! (acquire3 . poll ()) ; assert_pending ! (acquire4 . poll ()) ; s . close () ; assert ! (acquire3 . is_woken ()) ; assert ! (acquire4 . is_woken ()) ; assert_ready_err ! (acquire3 . poll ()) ; assert_ready_err ! (acquire4 . poll ()) ; assert_eq ! (0 , s . available_permits ()) ; s . release (1) ; assert_eq ! (1 , s . available_permits ()) ; assert_ready_err ! (task :: spawn (s . acquire (1)) . poll ()) ; s . release (1) ; assert_eq ! (2 , s . available_permits ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pause_time_in_spawn_threads",
                        "label": "pause_time_in_spawn_threads",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (panic = \"abort\" , ignore)] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 1)] async fn pause_time_in_spawn_threads () { let t = tokio :: spawn (async { tokio :: time :: pause () ; }) ; assert_err ! (t . await) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_after_reschedule_at_new_scheduled_time",
                        "label": "drop_after_reschedule_at_new_scheduled_time",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn drop_after_reschedule_at_new_scheduled_time () { use futures :: poll ; tokio :: time :: pause () ; let start = tokio :: time :: Instant :: now () ; let mut a = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (5))) ; let mut b = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (5))) ; let mut c = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (10))) ; let _ = poll ! (& mut a) ; let _ = poll ! (& mut b) ; let _ = poll ! (& mut c) ; b . as_mut () . reset (start + Duration :: from_millis (10)) ; a . await ; drop (b) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "collect_vec_items",
                        "label": "collect_vec_items",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn collect_vec_items () { let (tx , rx) = mpsc :: unbounded_channel_stream () ; let mut fut = task :: spawn (rx . collect :: < Vec < i32 > > ()) ; assert_pending ! (fut . poll ()) ; tx . send (1) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; tx . send (2) . unwrap () ; assert ! (fut . is_woken ()) ; assert_pending ! (fut . poll ()) ; drop (tx) ; assert ! (fut . is_woken ()) ; let coll = assert_ready ! (fut . poll ()) ; assert_eq ! (vec ! [1 , 2] , coll) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic",
                        "label": "basic",
                        "kind": "Function",
                        "signature": "fn # [test] fn basic () { loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. 3 { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } } n }) ; let mut n = 0 ; for _ in 0 .. 2 { for _ in 0 .. 2 { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } if local . pop () . is_some () { n += 1 ; } let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; while local . pop () . is_some () { n += 1 ; } } n += inject . borrow_mut () . drain (..) . count () ; n += th . join () . unwrap () ; assert_eq ! (6 , n) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CqeResult",
                        "label": "CqeResult",
                        "kind": "Struct",
                        "signature": "struct CqeResult",
                        "file_path": "tokio/src/runtime/driver/op.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "poll_after_take_value_should_fail",
                        "label": "poll_after_take_value_should_fail",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_after_take_value_should_fail () { tokio :: task_local ! { static KEY : u32 } let fut = KEY . scope (1 , async { let result = KEY . try_with (| _ | { }) ; assert ! (result . is_err ()) ; }) ; let mut fut = Box :: pin (fut) ; fut . as_mut () . take_value () ; fut . await ; } . sig",
                        "file_path": "tokio/tests/task_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FuturesAsyncWriteCompatExt",
                        "label": "FuturesAsyncWriteCompatExt",
                        "kind": "Trait",
                        "signature": "trait FuturesAsyncWriteCompatExt",
                        "file_path": "tokio-util/src/compat.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "make_future",
                        "label": "make_future",
                        "kind": "Function",
                        "signature": "fn async fn make_future < T : Clone > (mut rx : Receiver < T >) -> (Result < T , RecvError > , Receiver < T >) { let result = rx . recv () . await ; (result , rx) } . sig",
                        "file_path": "tokio-stream/src/wrappers/broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Waiters",
                        "label": "Waiters",
                        "kind": "Struct",
                        "signature": "struct Waiters",
                        "file_path": "tokio/src/runtime/io/scheduled_io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_bounded",
                        "label": "try_recv_bounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_bounded () { let (tx , mut rx) = mpsc :: channel (5) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert ! (tx . try_send (\"hello\") . is_err ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; assert ! (tx . try_send (\"hello\") . is_err ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; tx . try_send (\"hello\") . unwrap () ; drop (tx) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Ok (\"hello\") , rx . try_recv ()) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_task_that_panics_on_drop_contained",
                        "label": "test_abort_task_that_panics_on_drop_contained",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that aborting a task whose destructor panics does not allow the\"] # [doc = \" panic to escape the task.\"] # [test] # [cfg (panic = \"unwind\")] fn test_abort_task_that_panics_on_drop_contained () { let rt = Builder :: new_current_thread () . enable_time () . build () . unwrap () ; rt . block_on (async move { let handle = tokio :: spawn (async move { let _panic_dropped = PanicOnDrop ; tokio :: time :: sleep (Duration :: new (100 , 0)) . await }) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; handle . abort () ; drop (handle) ; tokio :: time :: sleep (Duration :: from_millis (10)) . await ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "waker_vtable",
                        "label": "waker_vtable",
                        "kind": "Function",
                        "signature": "fn fn waker_vtable < W : Wake > () -> & 'static RawWakerVTable { & RawWakerVTable :: new (clone_arc_raw :: < W > , wake_arc_raw :: < W > , wake_by_ref_arc_raw :: < W > , drop_arc_raw :: < W > ,) } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_spawn_stealable_task",
                        "label": "try_spawn_stealable_task",
                        "kind": "Function",
                        "signature": "fn async fn try_spawn_stealable_task () -> Result < () , mpsc :: RecvTimeoutError > { let (tx , rx) = mpsc :: channel () ; tokio :: spawn (async move { tokio :: spawn (async move { tx . send (()) . unwrap () ; }) ; rx . recv_timeout (Duration :: from_secs (1)) }) . await . unwrap () ? ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_scheduler_spawn",
                        "label": "basic_scheduler_spawn",
                        "kind": "Function",
                        "signature": "fn fn basic_scheduler_spawn (c : & mut Criterion) { let runtime = single_rt () ; c . bench_function (\"basic_scheduler_spawn\" , | b | { b . iter (| | { runtime . block_on (async { let h = tokio :: spawn (work ()) ; assert_eq ! (h . await . unwrap () , 2) ; }) ; }) }) ; } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_enter",
                        "label": "basic_enter",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (panic = \"abort\" , ignore)] fn basic_enter () { let rt1 = rt () ; let rt2 = rt () ; let enter1 = rt1 . enter () ; let enter2 = rt2 . enter () ; drop (enter2) ; drop (enter1) ; } . sig",
                        "file_path": "tokio/tests/rt_handle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Storage",
                        "label": "Storage",
                        "kind": "Trait",
                        "signature": "trait Storage",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "timeout_panics_when_no_time_handle",
                        "label": "timeout_panics_when_no_time_handle",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (target_os = \"wasi\" , ignore = \"Wasi does not support panic recovery\")] # [should_panic (expected = \"A Tokio 1.x context was found, but timers are disabled. Call `enable_time` on the runtime builder to enable timers.\")] fn timeout_panics_when_no_time_handle () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let (_tx , rx) = oneshot :: channel :: < () > () ; let dur = Duration :: from_millis (20) ; let _ = timeout (dur , rx) . await ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove",
                        "label": "remove",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn remove () { let base_dir = tempdir () . unwrap () ; let new_dir = base_dir . path () . join (\"foo\") ; let new_dir_2 = new_dir . clone () ; std :: fs :: create_dir (new_dir . clone ()) . unwrap () ; assert_ok ! (fs :: remove_dir (new_dir) . await) ; assert ! (! new_dir_2 . exists ()) ; } . sig",
                        "file_path": "tokio/tests/fs_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "take",
                        "label": "take",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn take () { let mut buf = [0 ; 6] ; let rd : & [u8] = b\"hello world\" ; let mut rd = rd . take (4) ; let n = assert_ok ! (rd . read (& mut buf) . await) ; assert_eq ! (n , 4) ; assert_eq ! (& buf , & b\"hell\\0\\0\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_take.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "convert_to_stdio",
                        "label": "convert_to_stdio",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn convert_to_stdio (child_stdio : ChildStdio) -> io :: Result < Stdio > { convert_to_file (child_stdio) . map (Stdio :: from) } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_shutdown",
                        "label": "spawn_shutdown",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn spawn_shutdown () { let rt = rt () ; let (tx , rx) = mpsc :: channel () ; rt . block_on (async { tokio :: spawn (client_server (tx . clone ())) ; }) ; rt . spawn (client_server (tx)) ; assert_ok ! (rx . recv ()) ; assert_ok ! (rx . recv ()) ; drop (rt) ; assert_err ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "panic_in_clone",
                        "label": "panic_in_clone",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (panic = \"unwind\")] # [cfg (not (target_family = \"wasm\"))] fn panic_in_clone () { use std :: panic :: { self , AssertUnwindSafe } ; # [derive (Eq , PartialEq , Debug)] struct MyVal (usize) ; impl Clone for MyVal { fn clone (& self) -> MyVal { assert_ne ! (0 , self . 0) ; MyVal (self . 0) } } let (tx , mut rx) = broadcast :: channel (16) ; assert_ok ! (tx . send (MyVal (0))) ; assert_ok ! (tx . send (MyVal (1))) ; let res = panic :: catch_unwind (AssertUnwindSafe (| | { let _ = rx . try_recv () ; })) ; assert_err ! (res) ; let val = assert_recv ! (rx) ; assert_eq ! (val , MyVal (1)) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_single_client",
                        "label": "test_named_pipe_single_client",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_single_client () -> io :: Result < () > { use tokio :: io :: { AsyncBufReadExt as _ , BufReader } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let mut server = BufReader :: new (server) ; let mut buf = String :: new () ; server . read_line (& mut buf) . await ? ; server . write_all (b\"pong\\n\") . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut client = BufReader :: new (client) ; let mut buf = String :: new () ; client . write_all (b\"ping\\n\") . await ? ; client . read_line (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, \"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_and_wait_threads",
                        "label": "set_and_wait_threads",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (target_family = \"wasm\" , ignore)] async fn set_and_wait_threads () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let thread = std :: thread :: spawn (| | { ONCE . set (4) . unwrap () ; }) ; let value = ONCE . wait () . await ; thread . join () . unwrap () ; assert_eq ! (* value , 4) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_fd_is_valid",
                        "label": "unix_fd_is_valid",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (unix)] async fn unix_fd_is_valid () { use std :: os :: unix :: io :: AsRawFd ; let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; assert ! (file . as_raw_fd () as u64 > 0) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Child",
                        "label": "Child",
                        "kind": "Struct",
                        "signature": "struct Child",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "build_config",
                        "label": "build_config",
                        "kind": "Function",
                        "signature": "fn fn build_config (input : & ItemFn , args : AttributeArgs , is_test : bool , rt_multi_thread : bool ,) -> Result < FinalConfig , syn :: Error > { if input . sig . asyncness . is_none () { let msg = \"the `async` keyword is missing from the function declaration\" ; return Err (syn :: Error :: new_spanned (input . sig . fn_token , msg)) ; } let mut config = Configuration :: new (is_test , rt_multi_thread) ; let macro_name = config . macro_name () ; for arg in args { match arg { syn :: Meta :: NameValue (namevalue) => { let ident = namevalue . path . get_ident () . ok_or_else (| | { syn :: Error :: new_spanned (& namevalue , \"Must have specified ident\") }) ? . to_string () . to_lowercase () ; let lit = match & namevalue . value { syn :: Expr :: Lit (syn :: ExprLit { lit , .. }) => lit , expr => return Err (syn :: Error :: new_spanned (expr , \"Must be a literal\")) , } ; match ident . as_str () { \"worker_threads\" => { config . set_worker_threads (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"flavor\" => { config . set_flavor (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"start_paused\" => { config . set_start_paused (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"core_threads\" => { let msg = \"Attribute `core_threads` is renamed to `worker_threads`\" ; return Err (syn :: Error :: new_spanned (namevalue , msg)) ; } \"crate\" => { config . set_crate_name (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } \"unhandled_panic\" => { config . set_unhandled_panic (lit . clone () , syn :: spanned :: Spanned :: span (lit)) ? ; } name => { let msg = format ! (\"Unknown attribute {name} is specified; expected one of: `flavor`, `worker_threads`, `start_paused`, `crate`, `unhandled_panic`\" ,) ; return Err (syn :: Error :: new_spanned (namevalue , msg)) ; } } } syn :: Meta :: Path (path) => { let name = path . get_ident () . ok_or_else (| | syn :: Error :: new_spanned (& path , \"Must have specified ident\")) ? . to_string () . to_lowercase () ; let msg = match name . as_str () { \"threaded_scheduler\" | \"multi_thread\" => { format ! (\"Set the runtime flavor with #[{macro_name}(flavor = \\\"multi_thread\\\")].\") } \"basic_scheduler\" | \"current_thread\" | \"single_threaded\" => { format ! (\"Set the runtime flavor with #[{macro_name}(flavor = \\\"current_thread\\\")].\") } \"flavor\" | \"worker_threads\" | \"start_paused\" | \"crate\" | \"unhandled_panic\" => { format ! (\"The `{name}` attribute requires an argument.\") } name => { format ! (\"Unknown attribute {name} is specified; expected one of: `flavor`, `worker_threads`, `start_paused`, `crate`, `unhandled_panic`.\") } } ; return Err (syn :: Error :: new_spanned (path , msg)) ; } other => { return Err (syn :: Error :: new_spanned (other , \"Unknown attribute inside the macro\" ,)) ; } } } config . build () } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "maybe_pending_seek",
                        "label": "maybe_pending_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn maybe_pending_seek () { struct MaybePendingSeek < 'a > { inner : Cursor < & 'a [u8] > , ready : bool , seek_res : Option < io :: Result < () > > , } impl < 'a > MaybePendingSeek < 'a > { fn new (inner : & 'a [u8]) -> Self { Self { inner : Cursor :: new (inner) , ready : true , seek_res : None , } } } impl AsyncRead for MaybePendingSeek < '_ > { fn poll_read (mut self : Pin < & mut Self > , cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { Pin :: new (& mut self . inner) . poll_read (cx , buf) } } impl AsyncBufRead for MaybePendingSeek < '_ > { fn poll_fill_buf (mut self : Pin < & mut Self > , cx : & mut Context < '_ > ,) -> Poll < io :: Result < & [u8] > > { let this : * mut Self = & mut * self as * mut _ ; Pin :: new (& mut unsafe { & mut * this } . inner) . poll_fill_buf (cx) } fn consume (mut self : Pin < & mut Self > , amt : usize) { Pin :: new (& mut self . inner) . consume (amt) } } impl AsyncSeek for MaybePendingSeek < '_ > { fn start_seek (mut self : Pin < & mut Self > , pos : SeekFrom) -> io :: Result < () > { self . seek_res = Some (Pin :: new (& mut self . inner) . start_seek (pos)) ; Ok (()) } fn poll_complete (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < io :: Result < u64 > > { if self . ready { self . ready = false ; self . seek_res . take () . unwrap_or (Ok (())) ? ; Pin :: new (& mut self . inner) . poll_complete (cx) } else { self . ready = true ; cx . waker () . wake_by_ref () ; Poll :: Pending } } } let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , MaybePendingSeek :: new (inner)) ; assert_eq ! (reader . seek (SeekFrom :: Current (3)) . await . unwrap () , 3) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . is_err ()) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert_eq ! (reader . seek (SeekFrom :: Current (1)) . await . unwrap () , 4) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [1 , 2] [..]) ; Pin :: new (& mut reader) . consume (1) ; assert_eq ! (reader . seek (SeekFrom :: Current (- 2)) . await . unwrap () , 3) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_odd_on_non_vectored",
                        "label": "write_vectored_odd_on_non_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_odd_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& []) , IoSlice :: new (& msg [4 .. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: new (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "throttle",
                        "label": "throttle",
                        "kind": "Function",
                        "signature": "fn pub (super) fn throttle < T > (duration : Duration , stream : T) -> Throttle < T > where T : Stream , { Throttle { delay : tokio :: time :: sleep_until (Instant :: now () + duration) , duration , has_delayed : true , stream , } } . sig",
                        "file_path": "tokio-stream/src/stream_ext/throttle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LinearHistogram",
                        "label": "LinearHistogram",
                        "kind": "Struct",
                        "signature": "struct LinearHistogram",
                        "file_path": "tokio/src/runtime/metrics/histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length",
                        "label": "lines_decoder_max_length",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length () { const MAX_LENGTH : usize = 6 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1 is too long\\nline 2\\nline 3\\r\\nline 4\\n\\r\\n\\r\") ; assert ! (codec . decode (buf) . is_err ()) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"line 2\" , line) ; assert ! (codec . decode (buf) . is_err ()) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"line 4\" , line) ; let line = codec . decode (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , line) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; let line = codec . decode_eof (buf) . unwrap () . unwrap () ; assert ! (line . len () <= MAX_LENGTH , \"{line:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\\rk\" , line) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"aaabbbc\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_rt",
                        "label": "single_rt",
                        "kind": "Function",
                        "signature": "fn fn single_rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Interval",
                        "label": "Interval",
                        "kind": "Struct",
                        "signature": "struct Interval",
                        "file_path": "tokio/src/time/interval.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "OwnedReadHalf",
                        "label": "OwnedReadHalf",
                        "kind": "Struct",
                        "signature": "struct OwnedReadHalf",
                        "file_path": "tokio/src/net/unix/split_owned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "is_closed",
                        "label": "is_closed",
                        "kind": "Function",
                        "signature": "fn fn is_closed (err : broadcast :: error :: RecvError) -> bool { matches ! (err , broadcast :: error :: RecvError :: Closed) } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "completed_future_past_deadline",
                        "label": "completed_future_past_deadline",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"FIXME: `fut.poll()` panics on Wasi\")] # [tokio :: test] async fn completed_future_past_deadline () { let mut fut = task :: spawn (timeout_at (Instant :: now () - ms (1000) , async { })) ; assert_ready_ok ! (fut . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "select_priv_declare_output_enum",
                        "label": "select_priv_declare_output_enum",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Implementation detail of the `select!` macro. This macro is **not** intended\"] # [doc = \" to be used as part of the public API and is permitted to change.\"] # [proc_macro] # [doc (hidden)] pub fn select_priv_declare_output_enum (input : TokenStream) -> TokenStream { select :: declare_output_enum (input) } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn",
                        "label": "spawn",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Spawn a future into a [`Spawn`] which wraps the future in a mocked executor.\"] # [doc = \"\"] # [doc = \" This can be used to spawn a [`Future`] or a [`Stream`].\"] # [doc = \"\"] # [doc = \" For more information, check the module docs.\"] pub fn spawn < T > (task : T) -> Spawn < T > { Spawn { task : MockTask :: new () , future : Box :: pin (task) , } } . sig",
                        "file_path": "tokio-test/src/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_and_set",
                        "label": "sleep_and_set",
                        "kind": "Function",
                        "signature": "fn async fn sleep_and_set () -> u32 { time :: sleep (Duration :: from_millis (2)) . await ; 5 } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty",
                        "label": "empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty () { let mut map = StreamMap :: < & str , stream :: Pending < () > > :: new () ; assert_eq ! (map . len () , 0) ; assert ! (map . is_empty ()) ; assert ! (map . next () . await . is_none ()) ; assert ! (map . next () . await . is_none ()) ; assert ! (map . remove (\"foo\") . is_none ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length_underrun_twice",
                        "label": "lines_decoder_max_length_underrun_twice",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length_underrun_twice () { const MAX_LENGTH : usize = 11 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too very l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"aaaaaaaaaaaaaaaaaaaaaaa\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\nshort\\n\") ; assert_eq ! (\"short\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_calling_close_with_sender",
                        "label": "test_rx_is_closed_when_calling_close_with_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_calling_close_with_sender () { let (_tx , mut rx) = mpsc :: channel :: < () > (10) ; rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PollSender",
                        "label": "PollSender",
                        "kind": "Struct",
                        "signature": "struct PollSender",
                        "file_path": "tokio-util/src/sync/mpsc.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "max_blocking_threads_set_to_zero",
                        "label": "max_blocking_threads_set_to_zero",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn max_blocking_threads_set_to_zero () { let _rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (0) . build () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_only_on_first_poll_with_cancellation_token_owned_test",
                        "label": "pending_only_on_first_poll_with_cancellation_token_owned_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_only_on_first_poll_with_cancellation_token_owned_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let fut = ReadyOnTheSecondPollFuture :: default () . with_cancellation_token_owned (token . clone ()) ; pin ! (fut) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; assert_eq ! (wake_count , 1) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_local_available_on_abort",
                        "label": "task_local_available_on_abort",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_local_available_on_abort () { tokio :: task_local ! { static KEY : u32 ; } struct MyFuture { tx_poll : Option < oneshot :: Sender < () > > , tx_drop : Option < oneshot :: Sender < u32 > > , } impl Future for MyFuture { type Output = () ; fn poll (mut self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < () > { if let Some (tx_poll) = self . tx_poll . take () { let _ = tx_poll . send (()) ; } Poll :: Pending } } impl Drop for MyFuture { fn drop (& mut self) { let _ = self . tx_drop . take () . unwrap () . send (KEY . get ()) ; } } let (tx_drop , rx_drop) = oneshot :: channel () ; let (tx_poll , rx_poll) = oneshot :: channel () ; let h = tokio :: spawn (KEY . scope (42 , MyFuture { tx_poll : Some (tx_poll) , tx_drop : Some (tx_drop) , } ,)) ; rx_poll . await . unwrap () ; h . abort () ; assert_eq ! (rx_drop . await . unwrap () , 42) ; let err = h . await . unwrap_err () ; if ! err . is_cancelled () { if let Ok (panic) = err . try_into_panic () { std :: panic :: resume_unwind (panic) ; } else { panic ! () ; } } } . sig",
                        "file_path": "tokio/tests/task_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_join_size_biased",
                        "label": "try_join_size_biased",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (target_pointer_width = \"64\")] fn try_join_size_biased () { use futures :: future ; use std :: mem ; let fut = async { let ready = future :: ready (ok (0i32)) ; tokio :: try_join ! (biased ; ready) } ; assert_eq ! (mem :: size_of_val (& fut) , 24) ; let fut = async { let ready1 = future :: ready (ok (0i32)) ; let ready2 = future :: ready (ok (0i32)) ; tokio :: try_join ! (biased ; ready1 , ready2) } ; assert_eq ! (mem :: size_of_val (& fut) , 40) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_spawn_blocking",
                        "label": "write_spawn_blocking",
                        "kind": "Function",
                        "signature": "fn async fn write_spawn_blocking (path : & Path , contents : OwnedBuf) -> io :: Result < () > { let path = path . to_owned () ; asyncify (move | | std :: fs :: write (path , contents)) . await } . sig",
                        "file_path": "tokio/src/fs/write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PollSemaphore",
                        "label": "PollSemaphore",
                        "kind": "Struct",
                        "signature": "struct PollSemaphore",
                        "file_path": "tokio-util/src/sync/poll_semaphore.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_ip_string",
                        "label": "connect_addr_ip_string",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_ip_string () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"127.0.0.1:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (addr) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UCred",
                        "label": "UCred",
                        "kind": "Struct",
                        "signature": "struct UCred",
                        "file_path": "tokio/src/net/unix/ucred.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AtomicOneshot",
                        "label": "AtomicOneshot",
                        "kind": "Struct",
                        "signature": "struct AtomicOneshot",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_symlink",
                        "label": "test_symlink",
                        "kind": "Function",
                        "signature": "fn # [cfg (unix)] # [tokio :: test] async fn test_symlink () { let dir = tempdir () . unwrap () ; let src = dir . path () . join (\"src.txt\") ; let dst = dir . path () . join (\"dst.txt\") ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"hello\") . unwrap () ; fs :: symlink (& src , & dst) . await . unwrap () ; std :: fs :: File :: create (& src) . unwrap () . write_all (b\"new-data\") . unwrap () ; let content = fs :: read (& dst) . await . unwrap () ; assert_eq ! (content , b\"new-data\") ; let read = fs :: read_link (dst . clone ()) . await . unwrap () ; assert ! (read == src) ; let symlink_meta = fs :: symlink_metadata (dst . clone ()) . await . unwrap () ; assert ! (symlink_meta . file_type () . is_symlink ()) ; } . sig",
                        "file_path": "tokio/tests/fs_link.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_one",
                        "label": "test_one",
                        "kind": "Function",
                        "signature": "fn async fn test_one () { let mut t = Command :: new (\"strace\") . args (\"-o /dev/null -D sleep 5\" . split (' ')) . spawn () . unwrap () ; sleep (Duration :: from_millis (100)) . await ; unsafe { libc :: kill (t . id () . unwrap () as _ , libc :: SIGINT) } ; t . wait () . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/process_issue_7144.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_update_max_frame_len_in_flight",
                        "label": "read_update_max_frame_len_in_flight",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_update_max_frame_len_in_flight () { let io = length_delimited :: Builder :: new () . new_read (mock ! { data (b\"\\x00\\x00\\x00\\x09abcd\") , Poll :: Pending , data (b\"efghi\") , data (b\"\\x00\\x00\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_pending ! (io) ; io . decoder_mut () . set_max_frame_length (5) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalData",
                        "label": "LocalData",
                        "kind": "Struct",
                        "signature": "struct LocalData",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "coop_budget_udp_send_recv",
                        "label": "coop_budget_udp_send_recv",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Ensure that UDP sockets have functional budgeting\"] # [doc = \"\"] # [doc = \" # Design\"] # [doc = \" Two sockets communicate by spamming packets from one to the other.\"] # [doc = \"\"] # [doc = \" In Linux, this packet will be slammed through the entire network stack and into the receiver's buffer during the\"] # [doc = \" send system call because we are using the loopback interface.\"] # [doc = \" This happens because the softirq chain invoked on send when using the loopback interface covers virtually the\"] # [doc = \" entirety of the lifecycle of a packet within the kernel network stack.\"] # [doc = \"\"] # [doc = \" As a result, neither socket will ever encounter an EWOULDBLOCK, and the only way for these to yield during the loop\"] # [doc = \" is through budgeting.\"] # [doc = \"\"] # [doc = \" A second task runs in the background and increments a counter before yielding, allowing us to know how many times sockets yielded.\"] # [doc = \" Since we are both sending and receiving, that should happen once per 64 packets, because budgets are of size 128\"] # [doc = \" and there are two budget events per packet, a send and a recv.\"] # [tokio :: test] # [cfg_attr (miri , ignore)] async fn coop_budget_udp_send_recv () { const N_ITERATIONS : usize = 1024 ; const PACKET : & [u8] = b\"Hello, world\" ; const PACKET_LEN : usize = 12 ; assert_eq ! (PACKET_LEN , PACKET . len () , \"Defect in test, programmer can't do math\") ; let tx = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let rx = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; tx . connect (rx . local_addr () . unwrap ()) . await . unwrap () ; rx . connect (tx . local_addr () . unwrap ()) . await . unwrap () ; let tracker = Arc :: new (AtomicUsize :: default ()) ; let tracker_clone = Arc :: clone (& tracker) ; tokio :: task :: yield_now () . await ; tokio :: spawn (async move { loop { tracker_clone . fetch_add (1 , Ordering :: SeqCst) ; tokio :: task :: yield_now () . await ; } }) ; for _ in 0 .. N_ITERATIONS { tx . send (PACKET) . await . unwrap () ; let mut tmp = [0 ; PACKET_LEN] ; assert_eq ! (PACKET_LEN , rx . recv (& mut tmp) . await . unwrap () , \"Defect in test case, received unexpected result from socket\") ; assert_eq ! (PACKET , & tmp , \"Defect in test case, received unexpected result from socket\") ; } assert_eq ! (N_ITERATIONS / (BUDGET / 2) , tracker . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/coop_budget.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stress1",
                        "label": "stress1",
                        "kind": "Function",
                        "signature": "fn # [test] fn stress1 () { const NUM_ITER : usize = 5 ; const NUM_STEAL : usize = normal_or_miri (1_000 , 10) ; const NUM_LOCAL : usize = normal_or_miri (1_000 , 10) ; const NUM_PUSH : usize = normal_or_miri (500 , 10) ; const NUM_POP : usize = normal_or_miri (250 , 10) ; let mut stats = new_stats () ; for _ in 0 .. NUM_ITER { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; for _ in 0 .. NUM_STEAL { if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } thread :: yield_now () ; } cfg_unstable_metrics ! { assert_metrics ! (stats , steal_count == n as _) ; } n }) ; let mut n = 0 ; for _ in 0 .. NUM_LOCAL { for _ in 0 .. NUM_PUSH { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } for _ in 0 .. NUM_POP { if local . pop () . is_some () { n += 1 ; } else { break ; } } } n += inject . borrow_mut () . drain (..) . count () ; n += th . join () . unwrap () ; assert_eq ! (n , NUM_LOCAL * NUM_PUSH) ; } } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "advance_multi_with_timer",
                        "label": "advance_multi_with_timer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn advance_multi_with_timer () { let mut sleep = task :: spawn (time :: sleep (Duration :: from_millis (1))) ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert_pending ! (sleep . poll ()) ; time :: advance (Duration :: from_micros (250)) . await ; assert ! (sleep . is_woken ()) ; assert_ready ! (sleep . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_pending",
                        "label": "assert_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_pending () { let poll = pending () ; assert_pending ! (poll) ; assert_pending ! (poll , \"some message\") ; assert_pending ! (poll , \"{:?}\" , ()) ; assert_pending ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ReadHalf",
                        "label": "ReadHalf",
                        "kind": "Struct",
                        "signature": "struct ReadHalf",
                        "file_path": "tokio/src/net/unix/split.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "MetricAtomicUsize",
                        "label": "MetricAtomicUsize",
                        "kind": "Struct",
                        "signature": "struct MetricAtomicUsize",
                        "file_path": "tokio/src/util/metric_atomics.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Encoder",
                        "label": "Encoder",
                        "kind": "Trait",
                        "signature": "trait Encoder",
                        "file_path": "tokio-util/src/codec/encoder.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "track",
                        "label": "track",
                        "kind": "Function",
                        "signature": "fn fn track < T : Future > (f : T) -> Track < T > { Track { inner : f , arc : Arc :: new (()) , } } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_join3",
                        "label": "try_join3",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn try_join3 < T1 , F1 , T2 , F2 , T3 , F3 , E > (future1 : F1 , future2 : F2 , future3 : F3 ,) -> TryJoin3 < F1 , F2 , F3 > where F1 : Future < Output = Result < T1 , E > > , F2 : Future < Output = Result < T2 , E > > , F3 : Future < Output = Result < T3 , E > > , { TryJoin3 { future1 : maybe_done (future1) , future2 : maybe_done (future2) , future3 : maybe_done (future3) , } } . sig",
                        "file_path": "tokio/src/future/try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "clone_arc_raw",
                        "label": "clone_arc_raw",
                        "kind": "Function",
                        "signature": "fn unsafe fn clone_arc_raw < T : Wake > (data : * const ()) -> RawWaker { Arc :: < T > :: increment_strong_count (data as * const T) ; RawWaker :: new (data , waker_vtable :: < T > ()) } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_twice_before_dispatch",
                        "label": "read_twice_before_dispatch",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_twice_before_dispatch () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "coop_and_block_in_place",
                        "label": "coop_and_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn coop_and_block_in_place () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (1) . build () . unwrap () ; rt . block_on (async move { let (tx , mut rx) = tokio :: sync :: mpsc :: channel (1024) ; for _ in 0 .. 1024 { tx . send (()) . await . unwrap () ; } drop (tx) ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | { }) ; poll_fn (| cx | { while let Poll :: Ready (v) = { tokio :: pin ! { let fut = rx . recv () ; } Pin :: new (& mut fut) . poll (cx) } { if v . is_none () { panic ! (\"did not yield\") ; } } Poll :: Ready (()) }) . await }) . await . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_len",
                        "label": "sender_len",
                        "kind": "Function",
                        "signature": "fn # [test] fn sender_len () { let (tx , mut rx1) = broadcast :: channel (4) ; let mut rx2 = tx . subscribe () ; assert_eq ! (tx . len () , 0) ; assert ! (tx . is_empty ()) ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; tx . send (3) . unwrap () ; assert_eq ! (tx . len () , 3) ; assert ! (! tx . is_empty ()) ; assert_recv ! (rx1) ; assert_recv ! (rx1) ; assert_eq ! (tx . len () , 3) ; assert ! (! tx . is_empty ()) ; assert_recv ! (rx2) ; assert_eq ! (tx . len () , 2) ; assert ! (! tx . is_empty ()) ; tx . send (4) . unwrap () ; tx . send (5) . unwrap () ; tx . send (6) . unwrap () ; assert_eq ! (tx . len () , 4) ; assert ! (! tx . is_empty ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_into_inner",
                        "label": "test_into_inner",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_into_inner () -> Result < () , Box < dyn Error > > { let mut buf = Vec :: new () ; SyncIoBridge :: new (tokio :: io :: empty ()) . into_inner () . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (buf . len () , 0) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sync_bridge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let socket = UdpSocket :: bind (& addr) . await ? ; println ! (\"Listening on: {}\" , socket . local_addr () ?) ; let server = Server { socket , buf : vec ! [0 ; 1024] , to_send : None , } ; server . run () . await ? ; Ok (()) } . sig",
                        "file_path": "examples/echo-udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy",
                        "label": "copy",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn copy () { struct Rd (bool) ; impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { if self . 0 { buf . put_slice (b\"hello world\") ; self . 0 = false ; Poll :: Ready (Ok (())) } else { Poll :: Ready (Ok (())) } } } let mut rd = Rd (true) ; let mut wr = Vec :: new () ; let n = assert_ok ! (io :: copy (& mut rd , & mut wr) . await) ; assert_eq ! (n , 11) ; assert_eq ! (wr , b\"hello world\") ; } . sig",
                        "file_path": "tokio/tests/io_copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_from_wake",
                        "label": "drop_from_wake",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn drop_from_wake () { use std :: future :: Future ; use std :: pin :: Pin ; use std :: sync :: atomic :: { AtomicBool , Ordering } ; use std :: sync :: { Arc , Mutex } ; use std :: task :: Context ; let panicked = Arc :: new (AtomicBool :: new (false)) ; let list : Arc < Mutex < Vec < Pin < Box < tokio :: time :: Sleep > > > > > = Arc :: new (Mutex :: new (Vec :: new ())) ; let arc_wake = Arc :: new (DropWaker (panicked . clone () , list . clone ())) ; let arc_wake = futures :: task :: waker (arc_wake) ; tokio :: time :: pause () ; { let mut lock = list . lock () . unwrap () ; for _ in 0 .. 100 { let mut timer = Box :: pin (tokio :: time :: sleep (Duration :: from_millis (10))) ; let _ = timer . as_mut () . poll (& mut Context :: from_waker (& arc_wake)) ; lock . push (timer) ; } } tokio :: time :: sleep (Duration :: from_millis (11)) . await ; assert ! (! panicked . load (Ordering :: SeqCst) , \"panicked when dropping timers\") ; # [derive (Clone)] struct DropWaker (Arc < AtomicBool > , Arc < Mutex < Vec < Pin < Box < tokio :: time :: Sleep > > > > > ,) ; impl futures :: task :: ArcWake for DropWaker { fn wake_by_ref (arc_self : & Arc < Self >) { let result = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { * arc_self . 1 . lock () . expect (\"panic in lock\") = Vec :: new () })) ; if result . is_err () { arc_self . 0 . store (true , Ordering :: SeqCst) ; } } } } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = stream :: pending :: < i32 > () ; for _ in 0 .. 2 { assert_eq ! (stream . size_hint () , (0 , None)) ; let mut next = task :: spawn (async { stream . next () . await }) ; assert_pending ! (next . poll ()) ; } } . sig",
                        "file_path": "tokio-stream/tests/stream_pending.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> io :: Result < () > { # [cfg (windows)] { windows_main () . await ? ; } # [cfg (not (windows))] { println ! (\"Named pipes are only supported on Windows!\") ; } Ok (()) } . sig",
                        "file_path": "examples/named-pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "simultaneous_deadline_future_completion",
                        "label": "simultaneous_deadline_future_completion",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn simultaneous_deadline_future_completion () { let mut fut = task :: spawn (timeout_at (Instant :: now () , async { })) ; assert_ready_ok ! (fut . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_sender_after_pending_reserve",
                        "label": "close_sender_after_pending_reserve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn close_sender_after_pending_reserve () { let (send , mut recv) = channel :: < i32 > (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (1) . unwrap () ; assert ! (recv_task . is_woken ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; drop (reserve) ; send . close () ; assert ! (send . is_closed ()) ; let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_err ! (reserve . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_join_all",
                        "label": "test_join_queue_join_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_join_all () { let mut queue = JoinQueue :: new () ; let mut senders = Vec :: new () ; for i in 0 .. 5 { let (tx , rx) = oneshot :: channel :: < () > () ; senders . push (tx) ; queue . spawn (async move { let _ = rx . await ; i }) ; } while let Some (tx) = senders . pop () { let _ = tx . send (()) ; } let results = queue . join_all () . await ; assert_eq ! (results , vec ! [0 , 1 , 2 , 3 , 4]) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BarrierWaitResult",
                        "label": "BarrierWaitResult",
                        "kind": "Struct",
                        "signature": "struct BarrierWaitResult",
                        "file_path": "tokio/src/sync/barrier.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Parker",
                        "label": "Parker",
                        "kind": "Struct",
                        "signature": "struct Parker",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/park.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_future_pending",
                        "label": "driver_shutdown_wakes_future_pending",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_future_pending () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; std :: mem :: drop (rt) ; assert_err ! (futures :: executor :: block_on (afd_a . readable ())) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_time_advance_3ms_and_change",
                        "label": "test_time_advance_3ms_and_change",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_time_advance_3ms_and_change () { let now = Instant :: now () ; let dur = Duration :: from_micros (3_141_592) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_micros (3_123_456) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_read",
                        "label": "sync_read",
                        "kind": "Function",
                        "signature": "fn fn sync_read (c : & mut Criterion) { c . bench_function (\"sync_read\" , | b | { b . iter (| | { let mut file = StdFile :: open (DEV_ZERO) . unwrap () ; let mut buffer = [0u8 ; BUFFER_SIZE] ; for _i in 0 .. BLOCK_COUNT { file . read_exact (& mut buffer) . unwrap () ; } }) }) ; } . sig",
                        "file_path": "benches/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_4435",
                        "label": "issue_4435",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn issue_4435 () { let mut buf = [0 ; 8] ; let rd : & [u8] = b\"hello world\" ; let rd = rd . take (4) ; tokio :: pin ! (rd) ; let mut read_buf = ReadBuf :: new (& mut buf) ; read_buf . put_slice (b\"AB\") ; std :: future :: poll_fn (| cx | rd . as_mut () . poll_read (cx , & mut read_buf)) . await . unwrap () ; assert_eq ! (& buf , & b\"ABhell\\0\\0\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_take.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "hang_on_shutdown",
                        "label": "hang_on_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\" , worker_threads = 2)] async fn hang_on_shutdown () { let (sync_tx , sync_rx) = std :: sync :: mpsc :: channel :: < () > () ; tokio :: spawn (async move { tokio :: task :: block_in_place (| | sync_rx . recv () . ok ()) ; }) ; tokio :: spawn (async { tokio :: time :: sleep (std :: time :: Duration :: from_secs (2)) . await ; drop (sync_tx) ; }) ; tokio :: time :: sleep (std :: time :: Duration :: from_secs (1)) . await ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_delay",
                        "label": "poll_delay",
                        "kind": "Function",
                        "signature": "fn fn poll_delay (had_budget_before : bool , delay : Pin < & mut Sleep > , cx : & mut task :: Context < '_ > ,) -> Poll < Elapsed > { let delay_poll = | | match delay . poll (cx) { Poll :: Ready (()) => Poll :: Ready (Elapsed :: new ()) , Poll :: Pending => Poll :: Pending , } ; let has_budget_now = coop :: has_budget_remaining () ; if let (true , false) = (had_budget_before , has_budget_now) { coop :: with_unconstrained (delay_poll) } else { delay_poll () } } . sig",
                        "file_path": "tokio/src/time/timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "IoBufs",
                        "label": "IoBufs",
                        "kind": "Struct",
                        "signature": "struct IoBufs",
                        "file_path": "tokio/tests/support/io_vec.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_poll_consistency_many",
                        "label": "notify_waiters_poll_consistency_many",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Polls two `Notified` futures and checks if poll results are consistent\"] # [doc = \" with each other. If the first future is notified by a `notify_waiters`\"] # [doc = \" call, then the second one must be notified as well.\"] # [doc = \"\"] # [doc = \" Here we also add other `Notified` futures in between to force the two\"] # [doc = \" tested futures to end up in different chunks.\"] # [test] fn notify_waiters_poll_consistency_many () { fn notify_waiters_poll_consistency_many_variant (order : [usize ; 2]) { let notify = Arc :: new (Notify :: new ()) ; let mut futs = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | tokio_test :: task :: spawn (notify . notified ())) . collect :: < Vec < _ > > () ; assert_pending ! (futs [order [0]] . poll ()) ; for i in 2 .. futs . len () { assert_pending ! (futs [i] . poll ()) ; } assert_pending ! (futs [order [1]] . poll ()) ; let tx = notify . clone () ; let th = thread :: spawn (move | | { tx . notify_waiters () ; }) ; let res1 = futs [0] . poll () ; let res2 = futs [1] . poll () ; assert ! (res1 . is_pending () || res2 . is_ready ()) ; th . join () . unwrap () ; } loom :: model (| | notify_waiters_poll_consistency_many_variant ([0 , 1])) ; loom :: model (| | notify_waiters_poll_consistency_many_variant ([1 , 0])) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AsyncRead",
                        "label": "AsyncRead",
                        "kind": "Trait",
                        "signature": "trait AsyncRead",
                        "file_path": "tokio/src/io/async_read.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "poll_acquire_one_available",
                        "label": "poll_acquire_one_available",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_acquire_one_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ready_ok ! (task :: spawn (s . acquire (1)) . poll ()) ; assert_eq ! (s . available_permits () , 99) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_transfer_after_close",
                        "label": "test_transfer_after_close",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn test_transfer_after_close () { symmetric (| handle , mut a , mut b | async move { AsyncWriteExt :: shutdown (& mut a) . await . unwrap () ; b . read_to_end (& mut Vec :: new ()) . await . unwrap () ; b . write_all (b\"quux\") . await . unwrap () ; let mut tmp = [0 ; 4] ; a . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"quux\") ; drop (b) ; assert_eq ! (handle . await . unwrap () . unwrap () , (0 , 4)) ; }) . await } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_threadpool",
                        "label": "multi_threadpool",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_threadpool () { use tokio :: sync :: oneshot ; let rt1 = rt () ; let rt2 = rt () ; let (tx , rx) = oneshot :: channel () ; let (done_tx , done_rx) = mpsc :: channel () ; rt2 . spawn (async move { rx . await . unwrap () ; done_tx . send (()) . unwrap () ; }) ; rt1 . spawn (async move { tx . send (()) . unwrap () ; }) ; done_rx . recv () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "process",
                        "label": "process",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Process an individual chat client\"] async fn process (state : Arc < Mutex < Shared > > , stream : TcpStream , addr : SocketAddr ,) -> Result < () , Box < dyn Error > > { let mut lines = Framed :: new (stream , LinesCodec :: new ()) ; lines . send (\"Please enter your username:\") . await ? ; let username = match lines . next () . await { Some (Ok (line)) => line , _ => { tracing :: error ! (\"Failed to get username from {}. Client disconnected.\" , addr) ; return Ok (()) ; } } ; let mut peer = Peer :: new (state . clone () , lines) . await ? ; { let mut state = state . lock () . await ; let msg = format ! (\"{username} has joined the chat\") ; tracing :: info ! (\"{}\" , msg) ; state . broadcast (addr , & msg) . await ; } loop { tokio :: select ! { Some (msg) = peer . rx . recv () => { peer . lines . send (& msg) . await ?; } result = peer . lines . next () => match result { Some (Ok (msg)) => { let mut state = state . lock () . await ; let msg = format ! (\"{username}: {msg}\") ; state . broadcast (addr , & msg) . await ; } Some (Err (e)) => { tracing :: error ! (\"an error occurred while processing messages for {}; error = {:?}\" , username , e) ; } None => break , } , } } { let mut state = state . lock () . await ; state . peers . remove (& addr) ; let msg = format ! (\"{username} has left the chat\") ; tracing :: info ! (\"{}\" , msg) ; state . broadcast (addr , & msg) . await ; } Ok (()) } . sig",
                        "file_path": "examples/chat.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_new",
                        "label": "try_new",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_new () { let original = Arc :: new (InvalidSource) ; let error = AsyncFd :: try_new (original . clone ()) . unwrap_err () ; let (returned , _cause) = error . into_parts () ; assert ! (Arc :: ptr_eq (& original , & returned)) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "windows_main",
                        "label": "windows_main",
                        "kind": "Function",
                        "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use std :: time :: Duration ; use tokio :: io :: { AsyncReadExt , AsyncWriteExt } ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; use tokio :: time ; use windows_sys :: Win32 :: Foundation :: ERROR_PIPE_BUSY ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-multi-client\" ; const N : usize = 10 ; let mut server = ServerOptions :: new () . first_pipe_instance (true) . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { time :: sleep (Duration :: from_secs (1)) . await ; for _ in 0 .. N { server . connect () . await ? ; let mut inner = server ; server = ServerOptions :: new () . create (PIPE_NAME) ? ; let _ = tokio :: spawn (async move { let mut buf = vec ! [0u8 ; 4] ; inner . read_exact (& mut buf) . await ? ; inner . write_all (b\"pong\") . await ? ; Ok :: < _ , io :: Error > (()) }) ; } Ok :: < _ , io :: Error > (()) }) ; let mut clients = Vec :: new () ; for _ in 0 .. N { clients . push (tokio :: spawn (async move { let mut client = loop { match ClientOptions :: new () . open (PIPE_NAME) { Ok (client) => break client , Err (e) if e . raw_os_error () == Some (ERROR_PIPE_BUSY as i32) => () , Err (e) => return Err (e) , } time :: sleep (Duration :: from_millis (5)) . await ; } ; let mut buf = [0u8 ; 4] ; client . write_all (b\"ping\") . await ? ; client . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) })) ; } for client in clients { let result = client . await ? ; assert_eq ! (& result ? [..] , b\"pong\") ; } server . await ? ? ; Ok (()) } . sig",
                        "file_path": "examples/named-pipe-multi-client.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symmetric",
                        "label": "symmetric",
                        "kind": "Function",
                        "signature": "fn async fn symmetric < F , Fut > (mut cb : F) where F : FnMut (JoinHandle < io :: Result < (u64 , u64) > > , TcpStream , TcpStream) -> Fut , Fut : std :: future :: Future < Output = () > , { let (a , mut a1) = make_socketpair () . await ; let (b , mut b1) = make_socketpair () . await ; let handle = tokio :: spawn (async move { copy_bidirectional (& mut a1 , & mut b1) . await }) ; cb (handle , a , b) . await ; let (a , mut a1) = make_socketpair () . await ; let (b , mut b1) = make_socketpair () . await ; let handle = tokio :: spawn (async move { copy_bidirectional (& mut b1 , & mut a1) . await }) ; cb (handle , b , a) . await ; } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mutex_blocking_lock_panic_caller",
                        "label": "mutex_blocking_lock_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mutex_blocking_lock_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let mutex = Mutex :: new (5_u32) ; let _g = mutex . blocking_lock () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StreamReader",
                        "label": "StreamReader",
                        "kind": "Struct",
                        "signature": "struct StreamReader",
                        "file_path": "tokio-util/src/io/stream_reader.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "DelayQueue",
                        "label": "DelayQueue",
                        "kind": "Struct",
                        "signature": "struct DelayQueue",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_closed",
                        "label": "size_hint_stream_closed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_closed () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drain_orphan_queue",
                        "label": "drain_orphan_queue",
                        "kind": "Function",
                        "signature": "fn fn drain_orphan_queue < T > (mut queue : MutexGuard < '_ , Vec < T > >) where T : Wait , { for i in (0 .. queue . len ()) . rev () { match queue [i] . try_wait () { Ok (None) => { } Ok (Some (_)) | Err (_) => { queue . swap_remove (i) ; } } } drop (queue) ; } . sig",
                        "file_path": "tokio/src/process/unix/orphan.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_logoff",
                        "label": "ctrl_logoff",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_logoff () -> io :: Result < RxFuture > { panic ! () } . sig",
                        "file_path": "tokio/src/signal/windows/stub.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_send_async",
                        "label": "blocking_send_async",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] async fn blocking_send_async () { let (tx , _rx) = mpsc :: channel :: < () > (1) ; let _ = tx . blocking_send (()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Configuration",
                        "label": "Configuration",
                        "kind": "Struct",
                        "signature": "struct Configuration",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "with_locked_node_and_parent",
                        "label": "with_locked_node_and_parent",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Figures out the parent of the node and locks the node and its parent atomically.\"] # [doc = \"\"] # [doc = \" The basic principle of preventing deadlocks in the tree is\"] # [doc = \" that we always lock the parent first, and then the child.\"] # [doc = \" For more info look at *deadlock safety* and *invariant #2*.\"] # [doc = \"\"] # [doc = \" Sadly, it's impossible to figure out the parent of a node without\"] # [doc = \" locking it. To then achieve locking order consistency, the node\"] # [doc = \" has to be unlocked before the parent gets locked.\"] # [doc = \" This leaves a small window where we already assume that we know the parent,\"] # [doc = \" but neither the parent nor the node is locked. Therefore, the parent could change.\"] # [doc = \"\"] # [doc = \" To prevent that this problem leaks into the rest of the code, it is abstracted\"] # [doc = \" in this function.\"] # [doc = \"\"] # [doc = \" The locked child and optionally its locked parent, if a parent exists, get passed\"] # [doc = \" to the `func` argument via (node, None) or (node, Some(parent)).\"] fn with_locked_node_and_parent < F , Ret > (node : & Arc < TreeNode > , func : F) -> Ret where F : FnOnce (MutexGuard < '_ , Inner > , Option < MutexGuard < '_ , Inner > >) -> Ret , { use std :: sync :: TryLockError ; let mut locked_node = node . inner . lock () . unwrap () ; loop { let potential_parent = match locked_node . parent . as_ref () { Some (potential_parent) => potential_parent . clone () , None => return func (locked_node , None) , } ; let locked_parent = match potential_parent . inner . try_lock () { Ok (locked_parent) => locked_parent , Err (TryLockError :: WouldBlock) => { drop (locked_node) ; let locked_parent = potential_parent . inner . lock () . unwrap () ; locked_node = node . inner . lock () . unwrap () ; locked_parent } # [allow (clippy :: unnecessary_literal_unwrap)] Err (TryLockError :: Poisoned (err)) => Err (err) . unwrap () , } ; if let Some (actual_parent) = locked_node . parent . as_ref () { if Arc :: ptr_eq (actual_parent , & potential_parent) { return func (locked_node , Some (locked_parent)) ; } } } } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_async_write_to_sync",
                        "label": "test_async_write_to_sync",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_async_write_to_sync () -> Result < () , Box < dyn Error > > { let mut dest = Vec :: new () ; let src = b\"hello world\" ; let dest = tokio :: task :: spawn_blocking (move | | -> Result < _ , String > { let mut w = SyncIoBridge :: new (Cursor :: new (& mut dest)) ; std :: io :: copy (& mut Cursor :: new (src) , & mut w) . map_err (| e | e . to_string ()) ? ; Ok (dest) }) . await ? ? ; assert_eq ! (dest . as_slice () , src) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/io_sync_bridge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Synced",
                        "label": "Synced",
                        "kind": "Struct",
                        "signature": "struct Synced",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "do_work",
                        "label": "do_work",
                        "kind": "Function",
                        "signature": "fn fn do_work (rng : & mut impl RngCore) -> u32 { use std :: fmt :: Write ; let mut message = String :: new () ; for i in 1 ..= 10 { let _ = write ! (& mut message , \" {i}={}\" , rng . random ::< f64 > ()) ; } message . as_bytes () . iter () . map (| & c | c as u32) . fold (0 , u32 :: wrapping_add) } . sig",
                        "file_path": "benches/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "windows_handle",
                        "label": "windows_handle",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn windows_handle () { use std :: os :: windows :: io :: AsRawHandle ; let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; assert ! (file . as_raw_handle () as u64 > 0) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task",
                        "label": "task",
                        "kind": "Function",
                        "signature": "fn async fn task (s : Arc < Semaphore >) { let permit = s . acquire () . await ; drop (permit) ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_generated_second_test_attr",
                        "label": "test_has_generated_second_test_attr",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [tokio :: test] async fn test_has_generated_second_test_attr () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "thread_rng_n",
                        "label": "thread_rng_n",
                        "kind": "Function",
                        "signature": "fn # [cfg (any (feature = \"macros\" , all (feature = \"sync\" , feature = \"rt\")))] pub (crate) fn thread_rng_n (n : u32) -> u32 { CONTEXT . with (| ctx | { let mut rng = ctx . rng . get () . unwrap_or_else (FastRand :: new) ; let ret = rng . fastrand_n (n) ; ctx . rng . set (Some (rng)) ; ret }) } . sig",
                        "file_path": "tokio/src/runtime/context.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "zero_does_not_block",
                        "label": "zero_does_not_block",
                        "kind": "Function",
                        "signature": "fn # [test] fn zero_does_not_block () { let b = Barrier :: new (0) ; { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } } . sig",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ThreadWaker",
                        "label": "ThreadWaker",
                        "kind": "Struct",
                        "signature": "struct ThreadWaker",
                        "file_path": "tokio-test/src/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_dir",
                        "label": "read_dir",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns a stream over the entries within a directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read_dir`].\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking\"] # [doc = \" operation on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] pub async fn read_dir (path : impl AsRef < Path >) -> io :: Result < ReadDir > { let path = path . as_ref () . to_owned () ; asyncify (| | -> io :: Result < ReadDir > { let mut std = std :: fs :: read_dir (path) ? ; let mut buf = VecDeque :: with_capacity (CHUNK_SIZE) ; let remain = ReadDir :: next_chunk (& mut buf , & mut std) ; Ok (ReadDir (State :: Idle (Some ((buf , std , remain))))) }) . await } . sig",
                        "file_path": "tokio/src/fs/read_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_multi_notified_last",
                        "label": "notify_multi_notified_last",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_multi_notified_last () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_last () ; assert_pending ! (notified1 . poll ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "non_cooperative_task",
                        "label": "non_cooperative_task",
                        "kind": "Function",
                        "signature": "fn async fn non_cooperative_task (permits : Arc < Semaphore >) -> usize { let mut exceeded_budget = 0 ; for _ in 0 .. 5 { for _ in 0 .. 128 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; } exceeded_budget += 1 ; } exceeded_budget } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RuntimeMetrics",
                        "label": "RuntimeMetrics",
                        "kind": "Struct",
                        "signature": "struct RuntimeMetrics",
                        "file_path": "tokio/src/runtime/metrics/runtime.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "convert_address",
                        "label": "convert_address",
                        "kind": "Function",
                        "signature": "fn fn convert_address (address : socket2 :: SockAddr) -> io :: Result < SocketAddr > { match address . as_socket () { Some (address) => Ok (address) , None => Err (io :: Error :: new (io :: ErrorKind :: InvalidInput , \"invalid address family (not IPv4 or IPv6)\" ,)) , } } . sig",
                        "file_path": "tokio/src/net/tcp/socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_stealer",
                        "label": "multi_stealer",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_stealer () { const NUM_TASKS : usize = 5 ; fn steal_tasks (steal : queue :: Steal < NoopSchedule >) -> usize { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; if steal . steal_into (& mut local , & mut stats) . is_none () { return 0 ; } let mut n = 1 ; while local . pop () . is_some () { n += 1 ; } n } loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. NUM_TASKS { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } let th1 = { let steal = steal . clone () ; thread :: spawn (move | | steal_tasks (steal)) } ; let th2 = thread :: spawn (move | | steal_tasks (steal)) ; let mut n = 0 ; while local . pop () . is_some () { n += 1 ; } n += inject . borrow_mut () . drain (..) . count () ; n += th1 . join () . unwrap () ; n += th2 . join () . unwrap () ; assert_eq ! (n , NUM_TASKS) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "canonicalize_root_dir_windows",
                        "label": "canonicalize_root_dir_windows",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn canonicalize_root_dir_windows () { let dir_path = fs :: canonicalize (\"C:\\\\.\\\\\") . await . unwrap () ; let dir_name = dir_path . to_str () . unwrap () ; assert ! (dir_name . starts_with (\"\\\\\\\\\")) ; assert ! (dir_name . ends_with (\"C:\\\\\")) ; } . sig",
                        "file_path": "tokio/tests/fs_canonicalize_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_poll_count_histogram_disabled_without_explicit_enable",
                        "label": "worker_poll_count_histogram_disabled_without_explicit_enable",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_poll_count_histogram_disabled_without_explicit_enable () { let rts = [tokio :: runtime :: Builder :: new_current_thread () . enable_all () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () , tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (2) . enable_all () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: linear (Duration :: from_millis (50) , 3 ,)) . build () . unwrap () ,] ; for rt in rts { let metrics = rt . metrics () ; assert ! (! metrics . poll_time_histogram_enabled ()) ; } } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_empty_drop",
                        "label": "receiver_is_empty_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_empty_drop () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before sender is dropped\") ; drop (tx) ; assert ! (rx . is_empty () , \"channel IS empty after sender is dropped\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AmbiguousIfSync",
                        "label": "AmbiguousIfSync",
                        "kind": "Trait",
                        "signature": "trait AmbiguousIfSync",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_insert_at_panic_caller",
                        "label": "delay_queue_insert_at_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_insert_at_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let _k = queue . insert_at (\"1\" , Instant :: now () + Duration :: from_millis (MAX_DURATION_MS + 1) ,) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Context",
                        "label": "Context",
                        "kind": "Struct",
                        "signature": "struct Context",
                        "file_path": "tokio/src/task/local.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reset_at_bigger_than_interval",
                        "label": "reset_at_bigger_than_interval",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_at_bigger_than_interval () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_at (Instant :: now () + Duration :: from_millis (1000)) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start , 1401) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1701) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_err_then_read_success",
                        "label": "read_err_then_read_success",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_err_then_read_success () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert_ready_err ! (t . poll ()) ; } { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored",
                        "label": "write_vectored",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn write_vectored < 'a , 'b , W > (writer : & 'a mut W , bufs : & 'a [IoSlice < 'b >] ,) -> WriteVectored < 'a , 'b , W > where W : AsyncWrite + Unpin + ? Sized , { WriteVectored { writer , bufs , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/write_vectored.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sync_two_lit_expr_comma",
                        "label": "sync_two_lit_expr_comma",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn sync_two_lit_expr_comma () { let foo = tokio :: join ! (async { 1 } , async { 2 } ,) ; assert_eq ! (foo , (1 , 2)) ; let foo = tokio :: join ! (biased ; async { 1 } , async { 2 } ,) ; assert_eq ! (foo , (1 , 2)) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "straight_execution",
                        "label": "straight_execution",
                        "kind": "Function",
                        "signature": "fn # [test] fn straight_execution () { let l = Arc :: new (Mutex :: new (100)) ; { let mut t = spawn (l . clone () . lock_owned ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 100) ; * g = 99 ; } { let mut t = spawn (l . clone () . lock_owned ()) ; let mut g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 99) ; * g = 98 ; } { let mut t = spawn (l . lock_owned ()) ; let g = assert_ready ! (t . poll ()) ; assert_eq ! (&* g , & 98) ; } } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cannot_create_zero_sized_pool",
                        "label": "cannot_create_zero_sized_pool",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"assertion failed: pool_size > 0\")] fn cannot_create_zero_sized_pool () { let _pool = task :: LocalPoolHandle :: new (0) ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_abort_on_drop",
                        "label": "test_join_queue_abort_on_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_abort_on_drop () { let mut queue = JoinQueue :: new () ; let mut recvs = Vec :: new () ; for _ in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; queue . spawn (async move { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (queue) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_string",
                        "label": "read_to_string",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn read_to_string < 'a , R > (reader : & 'a mut R , string : & 'a mut String ,) -> ReadToString < 'a , R > where R : AsyncRead + ? Sized + Unpin , { let buf = mem :: take (string) . into_bytes () ; ReadToString { reader , buf : VecWithInitialized :: new (buf) , output : string , read : 0 , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters",
                        "label": "notify_waiters",
                        "kind": "Function",
                        "signature": "fn fn notify_waiters < const N_WAITERS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let notify = Arc :: new (Notify :: new ()) ; let counter = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. N_WAITERS { rt . spawn ({ let notify = notify . clone () ; let counter = counter . clone () ; async move { loop { notify . notified () . await ; counter . fetch_add (1 , Ordering :: Relaxed) ; } } }) ; } const N_ITERS : usize = 500 ; g . bench_function (N_WAITERS . to_string () , | b | { b . iter (| | { counter . store (0 , Ordering :: Relaxed) ; loop { notify . notify_waiters () ; if counter . load (Ordering :: Relaxed) >= N_ITERS { break ; } } }) }) ; } . sig",
                        "file_path": "benches/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_no_unnecessary_polls",
                        "label": "assert_no_unnecessary_polls",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_no_unnecessary_polls () { loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let (tx , rx) = oneshot :: channel () ; let pending_cnt = Arc :: new (AtomicUsize :: new (0)) ; rt . spawn (async move { for _ in 0 .. 24 { task :: yield_now () . await ; } tx . send (()) . unwrap () ; }) ; let pending_cnt_clone = pending_cnt . clone () ; rt . block_on (async move { task :: yield_now () . await ; ResetFuture { rx , pending_cnt : pending_cnt_clone , } . await ; }) ; let pending_cnt = pending_cnt . load (Acquire) ; assert ! (pending_cnt <= 1) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "resolve_dns",
                        "label": "resolve_dns",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn resolve_dns () -> io :: Result < () > { let mut hosts = net :: lookup_host (\"localhost:3000\") . await ? ; let host = hosts . next () . unwrap () ; let expected = if host . is_ipv4 () { SocketAddr :: new (IpAddr :: V4 (Ipv4Addr :: new (127 , 0 , 0 , 1)) , 3000) } else { SocketAddr :: new (IpAddr :: V6 (Ipv6Addr :: new (0 , 0 , 0 , 0 , 0 , 0 , 0 , 1)) , 3000) } ; assert_eq ! (host , expected) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_lookup_host.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_rt",
                        "label": "multi_rt",
                        "kind": "Function",
                        "signature": "fn fn multi_rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TreeNode",
                        "label": "TreeNode",
                        "kind": "Struct",
                        "signature": "struct TreeNode",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "vectored_writes",
                        "label": "vectored_writes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn vectored_writes () { use bytes :: { Buf , Bytes } ; use std :: { io :: IoSlice , pin :: Pin } ; use tokio :: io :: AsyncWrite ; let mut cat = cat () . spawn () . unwrap () ; let mut stdin = cat . stdin . take () . unwrap () ; let are_writes_vectored = stdin . is_write_vectored () ; let mut stdout = cat . stdout . take () . unwrap () ; let write = async { let mut input = Bytes :: from_static (b\"hello\\n\") . chain (Bytes :: from_static (b\"world!\\n\")) ; let mut writes_completed = 0 ; std :: future :: poll_fn (| cx | loop { let mut slices = [IoSlice :: new (& []) ; 2] ; let vectored = input . chunks_vectored (& mut slices) ; if vectored == 0 { return std :: task :: Poll :: Ready (std :: io :: Result :: Ok (())) ; } let n = ready ! (Pin :: new (& mut stdin) . poll_write_vectored (cx , & slices)) ? ; writes_completed += 1 ; input . advance (n) ; }) . await ? ; drop (stdin) ; std :: io :: Result :: Ok (writes_completed) } ; let read = async { let mut buffer = Vec :: with_capacity (6 + 7) ; stdout . read_to_end (& mut buffer) . await ? ; std :: io :: Result :: Ok (buffer) } ; let (write , read , status) = future :: join3 (write , read , cat . wait ()) . await ; assert ! (status . unwrap () . success ()) ; let writes_completed = write . unwrap () ; assert_eq ! (writes_completed == 1 , are_writes_vectored) ; assert_eq ! (& read . unwrap () , b\"hello\\nworld!\\n\") ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_outside_task_panic_caller",
                        "label": "task_id_outside_task_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (not (panic = \"unwind\") , ignore)] fn task_id_outside_task_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = task :: id () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "clear",
                        "label": "clear",
                        "kind": "Function",
                        "signature": "fn # [test] fn clear () { let mut map = task :: spawn (StreamMap :: new ()) ; map . insert (\"a\" , stream :: iter (vec ! [1])) ; map . insert (\"b\" , stream :: iter (vec ! [1 , 2])) ; map . insert (\"c\" , stream :: iter (vec ! [1 , 2 , 3])) ; assert_ready_some ! (map . poll_next ()) ; map . clear () ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . is_empty ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_contention_resubscribe",
                        "label": "bench_contention_resubscribe",
                        "kind": "Function",
                        "signature": "fn fn bench_contention_resubscribe (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention_resubscribe\") ; contention_resubscribe :: < 10 > (& mut group) ; contention_resubscribe :: < 100 > (& mut group) ; contention_resubscribe :: < 500 > (& mut group) ; contention_resubscribe :: < 1000 > (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_all",
                        "label": "send_recv_all",
                        "kind": "Function",
                        "signature": "fn async fn send_recv_all (read : & mut (dyn AsyncRead + Unpin) , write : & mut (dyn AsyncWrite + Unpin) , input : & [u8] ,) -> std :: io :: Result < Vec < u8 > > { write . write_all (input) . await ? ; write . shutdown () . await ? ; let mut output = Vec :: new () ; read . read_to_end (& mut output) . await ? ; Ok (output) } . sig",
                        "file_path": "tokio/tests/uds_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_spawn_from_guard_other_thread",
                        "label": "test_spawn_from_guard_other_thread",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn test_spawn_from_guard_other_thread () { let (tx , rx) = std :: sync :: mpsc :: channel () ; std :: thread :: spawn (move | | { let rt = rt () ; let handle = rt . handle () . clone () ; tx . send (handle) . unwrap () ; }) ; let handle = rx . recv () . unwrap () ; let _guard = handle . enter () ; tokio :: spawn (async { }) ; } . sig",
                        "file_path": "tokio/tests/rt_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_tee_vectored",
                        "label": "write_tee_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_tee_vectored () { let mut altout : Vec < u8 > = Vec :: new () ; let mut writeout = SmallWriter { contents : Vec :: new () , } ; let original = b\"A very long string split up\" ; let bufs : Vec < Vec < u8 > > = original . split (| b | b . is_ascii_whitespace ()) . map (Vec :: from) . collect () ; assert ! (bufs . len () > 1) ; let expected : Vec < u8 > = { let mut out = Vec :: new () ; for item in & bufs { out . extend_from_slice (item) } out } ; { let mut bufcount = 0 ; let tee = InspectWriter :: new (& mut writeout , | bytes | { bufcount += 1 ; altout . extend (bytes) }) ; assert ! (tee . is_write_vectored ()) ; write_all_vectored (tee , bufs . clone ()) . await . unwrap () ; assert ! (bufcount >= bufs . len ()) ; } assert_eq ! (altout , writeout . contents) ; assert_eq ! (writeout . contents , expected) ; } . sig",
                        "file_path": "tokio-util/tests/io_inspect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "oneshot_error_bound",
                        "label": "oneshot_error_bound",
                        "kind": "Function",
                        "signature": "fn # [test] fn oneshot_error_bound () { use tokio :: sync :: oneshot :: error ; is_error :: < error :: RecvError > () ; is_error :: < error :: TryRecvError > () ; } . sig",
                        "file_path": "tokio/tests/sync_errors.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Readiness",
                        "label": "Readiness",
                        "kind": "Struct",
                        "signature": "struct Readiness",
                        "file_path": "tokio/src/runtime/io/scheduled_io.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "CopyBuffer",
                        "label": "CopyBuffer",
                        "kind": "Struct",
                        "signature": "struct CopyBuffer",
                        "file_path": "tokio/src/io/util/copy.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "lookup_socket_addr",
                        "label": "lookup_socket_addr",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn lookup_socket_addr () { let addr : SocketAddr = \"127.0.0.1:8000\" . parse () . unwrap () ; let actual = assert_ok ! (net :: lookup_host (addr) . await) . collect :: < Vec < _ > > () ; assert_eq ! (vec ! [addr] , actual) ; } . sig",
                        "file_path": "tokio/tests/net_lookup_host.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "budget_exhaustion_yield_with_joins",
                        "label": "budget_exhaustion_yield_with_joins",
                        "kind": "Function",
                        "signature": "fn # [test] fn budget_exhaustion_yield_with_joins () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . budget_forced_yield_count ()) ; let mut did_yield_1 = false ; let mut did_yield_2 = false ; rt . block_on (async { tokio :: join ! (poll_fn (| cx | loop { if did_yield_1 { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield_1 = true ; return Poll :: Pending ; } }) , poll_fn (| cx | loop { if did_yield_2 { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield_2 = true ; return Poll :: Pending ; } })) }) ; assert_eq ! (1 , rt . metrics () . budget_forced_yield_count ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_is_not_async",
                        "label": "main_is_not_async",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] fn main_is_not_async () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new_stats",
                        "label": "new_stats",
                        "kind": "Function",
                        "signature": "fn fn new_stats () -> Stats { use crate :: runtime :: WorkerMetrics ; Stats :: new (& WorkerMetrics :: new ()) } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_and_shutdown",
                        "label": "write_vectored_and_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_and_shutdown () { let (mut client , mut server) = tokio :: io :: duplex (64) ; let ret = client . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; client . shutdown () . await . unwrap () ; drop (client) ; let mut buf = Vec :: with_capacity (HELLO . len () * 2) ; let bytes_read = server . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (bytes_read , HELLO . len () * 2) ; assert_eq ! (buf , [HELLO , HELLO] . concat ()) ; } . sig",
                        "file_path": "tokio/tests/duplex_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "recv_buf_from",
                        "label": "recv_buf_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn recv_buf_from () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; sender . connect (receiver . local_addr () ?) . await ? ; sender . send (MSG) . await ? ; let mut recv_buf = Vec :: with_capacity (32) ; let (len , caddr) = receiver . recv_buf_from (& mut recv_buf) . await ? ; assert_eq ! (len , MSG_LEN) ; assert_eq ! (& recv_buf [.. len] , MSG) ; assert_eq ! (caddr , sender . local_addr () ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TimerShared",
                        "label": "TimerShared",
                        "kind": "Struct",
                        "signature": "struct TimerShared",
                        "file_path": "tokio/src/runtime/time/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Pidfd",
                        "label": "Pidfd",
                        "kind": "Struct",
                        "signature": "struct Pidfd",
                        "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "reopened_after_subscribe",
                        "label": "reopened_after_subscribe",
                        "kind": "Function",
                        "signature": "fn # [test] fn reopened_after_subscribe () { let (tx , rx) = watch :: channel (\"one\") ; assert ! (! tx . is_closed ()) ; drop (rx) ; assert ! (tx . is_closed ()) ; let rx = tx . subscribe () ; assert ! (! tx . is_closed ()) ; drop (rx) ; assert ! (tx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LogHistogram",
                        "label": "LogHistogram",
                        "kind": "Struct",
                        "signature": "struct LogHistogram",
                        "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_in_drop_after_wake",
                        "label": "notify_in_drop_after_wake",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_in_drop_after_wake () { use futures :: task :: ArcWake ; use std :: future :: Future ; use std :: sync :: Arc ; let notify = Arc :: new (Notify :: new ()) ; struct NotifyOnDrop (Arc < Notify >) ; impl ArcWake for NotifyOnDrop { fn wake_by_ref (_arc_self : & Arc < Self >) { } } impl Drop for NotifyOnDrop { fn drop (& mut self) { self . 0 . notify_waiters () ; } } let mut fut = Box :: pin (async { notify . clone () . notified_owned () . await ; }) ; { let waker = futures :: task :: waker (Arc :: new (NotifyOnDrop (notify . clone ()))) ; let mut cx = std :: task :: Context :: from_waker (& waker) ; assert ! (fut . as_mut () . poll (& mut cx) . is_pending ()) ; } notify . notify_waiters () ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_eq_on_not_eq",
                        "label": "assert_eq_on_not_eq",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn assert_eq_on_not_eq () { let poll = ready_err () ; assert_ready_eq ! (poll , Ok (())) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FileDescriptor",
                        "label": "FileDescriptor",
                        "kind": "Struct",
                        "signature": "struct FileDescriptor",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_partial_then_err",
                        "label": "read_partial_then_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_partial_then_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split_chan_poll",
                        "label": "split_chan_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn split_chan_poll () -> std :: io :: Result < () > { let socket = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let addr = socket . local_addr () . unwrap () ; let s = Arc :: new (socket) ; let r = s . clone () ; let (tx , mut rx) = tokio :: sync :: mpsc :: channel :: < (Vec < u8 > , std :: net :: SocketAddr) > (1_000) ; tokio :: spawn (async move { while let Some ((bytes , addr)) = rx . recv () . await { poll_fn (| cx | s . poll_send_to (cx , & bytes , addr)) . await . unwrap () ; } }) ; tokio :: spawn (async move { let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; loop { let addr = poll_fn (| cx | r . poll_recv_from (cx , & mut read)) . await . unwrap () ; tx . send ((read . filled () . to_vec () , addr)) . await . unwrap () ; } }) ; let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let _ = poll_fn (| cx | sender . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_buf",
                        "label": "write_buf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tries to write some bytes from the given `buf` to the writer in an\"] # [doc = \" asynchronous manner, returning a future.\"] pub (crate) fn write_buf < 'a , W , B > (writer : & 'a mut W , buf : & 'a mut B) -> WriteBuf < 'a , W , B > where W : AsyncWrite + Unpin , B : Buf , { WriteBuf { writer , buf , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/write_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_mode",
                        "label": "open_options_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (unix)] async fn open_options_mode () { let mode = format ! (\"{:?}\" , OpenOptions :: new () . mode (0o644)) ; assert ! (mode . contains (\"mode: 420\") || mode . contains (\"mode: 0o000644\") , \"mode is: {mode}\") ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_notified_when_last_sender_is_dropped",
                        "label": "receiver_is_notified_when_last_sender_is_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_is_notified_when_last_sender_is_dropped () { let (tx1 , mut rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let mut t = spawn (rx . changed ()) ; assert_pending ! (t . poll ()) ; drop (tx1) ; assert ! (! t . is_woken ()) ; drop (tx2) ; assert ! (t . is_woken ()) ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CachedParkThread",
                        "label": "CachedParkThread",
                        "kind": "Struct",
                        "signature": "struct CachedParkThread",
                        "file_path": "tokio/src/runtime/park.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_notify_one_not_enabled",
                        "label": "test_notify_one_not_enabled",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_notify_one_not_enabled () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "make_socketpair",
                        "label": "make_socketpair",
                        "kind": "Function",
                        "signature": "fn async fn make_socketpair () -> (TcpStream , TcpStream) { let listener = tokio :: net :: TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let addr = listener . local_addr () . unwrap () ; let connector = TcpStream :: connect (addr) ; let acceptor = listener . accept () ; let (c1 , c2) = tokio :: join ! (connector , acceptor) ; (c1 . unwrap () , c2 . unwrap () . 0) } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "aborted_future_1",
                        "label": "aborted_future_1",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Ensure a mutex is unlocked if a future holding the lock\"] # [doc = \" is aborted prematurely.\"] # [tokio :: test] # [cfg (feature = \"full\")] # [cfg_attr (miri , ignore)] async fn aborted_future_1 () { use std :: time :: Duration ; use tokio :: time :: { interval , timeout } ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let iv = interval (Duration :: from_millis (1000)) ; tokio :: pin ! (iv) ; m2 . lock_owned () . await ; iv . as_mut () . tick () . await ; iv . as_mut () . tick () . await ; }) . await . unwrap_err () ; } timeout (Duration :: from_millis (1u64) , async move { m1 . lock_owned () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "token_stream_with_error",
                        "label": "token_stream_with_error",
                        "kind": "Function",
                        "signature": "fn fn token_stream_with_error (mut tokens : TokenStream , error : syn :: Error) -> TokenStream { tokens . extend (error . into_compile_error ()) ; tokens } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_buf",
                        "label": "try_read_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_read_buf () { const DATA : & [u8] = b\"this is some data to write to the socket\" ; let listener = TcpListener :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = TcpStream :: connect (listener . local_addr () . unwrap ()) . await . unwrap () ; let (server , _) = listener . accept () . await . unwrap () ; let mut written = DATA . to_vec () ; let mut readable = task :: spawn (server . readable ()) ; assert_pending ! (readable . poll ()) ; client . writable () . await . unwrap () ; assert_eq ! (DATA . len () , client . try_write (DATA) . unwrap ()) ; while ! readable . is_woken () { tokio :: task :: yield_now () . await ; } loop { let mut writable = task :: spawn (client . writable ()) ; assert_ready_ok ! (writable . poll ()) ; match client . try_write (DATA) { Ok (n) => written . extend (& DATA [.. n]) , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => { break ; } Err (e) => panic ! (\"error = {e:?}\") , } } { let mut writable = task :: spawn (client . writable ()) ; assert_pending ! (writable . poll ()) ; let mut read = Vec :: with_capacity (written . len ()) ; let mut i = 0 ; while i < read . capacity () { server . readable () . await . unwrap () ; match server . try_read_buf (& mut read) { Ok (n) => i += n , Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"error = {e:?}\") , } } assert_eq ! (read , written) ; } drop (client) ; loop { let ready = server . ready (Interest :: READABLE) . await . unwrap () ; if ready . is_read_closed () { return ; } else { tokio :: task :: yield_now () . await ; } } } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_poll_expired_when_empty",
                        "label": "delay_queue_poll_expired_when_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn delay_queue_poll_expired_when_empty () { let mut delay_queue = task :: spawn (DelayQueue :: new ()) ; let key = delay_queue . insert (0 , std :: time :: Duration :: from_secs (10)) ; assert_pending ! (poll ! (delay_queue)) ; delay_queue . remove (& key) ; assert ! (assert_ready ! (poll ! (delay_queue)) . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bounds",
                        "label": "bounds",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } fn check_send_sync < T : Send + Sync > () { } check_unpin :: < Semaphore > () ; check_unpin :: < SemaphorePermit < '_ > > () ; check_send_sync :: < Semaphore > () ; let semaphore = Semaphore :: new (0) ; check_send_sync_val (semaphore . acquire ()) ; } . sig",
                        "file_path": "tokio/src/sync/semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "upgrade",
                        "label": "upgrade",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn upgrade < B : AsRef < [u8] > > (buf : B) -> OwnedBuf { let buf = match unsafe { typeid :: try_transmute :: < B , Vec < u8 > > (buf) } { Ok (vec) => return OwnedBuf :: Vec (vec) , Err (original_buf) => original_buf , } ; let buf = match unsafe { typeid :: try_transmute :: < B , String > (buf) } { Ok (string) => return OwnedBuf :: Vec (string . into_bytes ()) , Err (original_buf) => original_buf , } ; # [cfg (feature = \"io-util\")] let buf = match unsafe { typeid :: try_transmute :: < B , bytes :: Bytes > (buf) } { Ok (bytes) => return OwnedBuf :: Bytes (bytes) , Err (original_buf) => original_buf , } ; OwnedBuf :: Vec (buf . as_ref () . to_owned ()) } . sig",
                        "file_path": "tokio/src/util/as_ref.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delayed_sleep_level_0",
                        "label": "delayed_sleep_level_0",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn delayed_sleep_level_0 () { time :: pause () ; for & i in & [1 , 10 , 60] { let now = Instant :: now () ; let dur = ms (i) ; time :: sleep_until (now + dur) . await ; assert_elapsed ! (now , dur) ; } } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "NotifyGuard",
                        "label": "NotifyGuard",
                        "kind": "Struct",
                        "signature": "struct NotifyGuard",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pipe_from_one_command_to_another",
                        "label": "pipe_from_one_command_to_another",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn pipe_from_one_command_to_another () { let mut first = cat () . spawn () . expect (\"first cmd\") ; let mut third = cat () . spawn () . expect (\"third cmd\") ; let second_stdin : Stdio = first . stdout . take () . expect (\"first.stdout\") . try_into () . expect (\"first.stdout into Stdio\") ; let second_stdout : Stdio = third . stdin . take () . expect (\"third.stdin\") . try_into () . expect (\"third.stdin into Stdio\") ; let mut second = cat () . stdin (second_stdin) . stdout (second_stdout) . spawn () . expect (\"first cmd\") ; let msg = \"hello world! please pipe this message through\" ; let mut stdin = first . stdin . take () . expect (\"first.stdin\") ; let write = async move { stdin . write_all (msg . as_bytes ()) . await } ; let mut stdout = third . stdout . take () . expect (\"third.stdout\") ; let read = async move { let mut data = String :: new () ; stdout . read_to_string (& mut data) . await . map (| _ | data) } ; let (read , write , first_status , second_status , third_status) = join ! (read , write , first . wait () , second . wait () , third . wait ()) ; assert_eq ! (msg , read . expect (\"read result\")) ; write . expect (\"write result\") ; assert ! (first_status . expect (\"first status\") . success ()) ; assert ! (second_status . expect (\"second status\") . success ()) ; assert ! (third_status . expect (\"third status\") . success ()) ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "crate_path_test",
                        "label": "crate_path_test",
                        "kind": "Function",
                        "signature": "fn # [test :: tokio :: test (crate = \"test::tokio\")] async fn crate_path_test () { assert_eq ! (1 , compute () . await) ; } . sig",
                        "file_path": "tokio/tests/macros_rename_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_when_close_is_called_after_dropping_sender",
                        "label": "test_rx_len_when_close_is_called_after_dropping_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called_after_dropping_sender () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; drop (tx) ; rx . close () ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "paused_time_is_deterministic",
                        "label": "paused_time_is_deterministic",
                        "kind": "Function",
                        "signature": "fn # [test] fn paused_time_is_deterministic () { let run_1 = paused_time_stress_run () ; let run_2 = paused_time_stress_run () ; assert_eq ! (run_1 , run_2) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timeout_value",
                        "label": "timeout_value",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn timeout_value () { use tokio :: sync :: oneshot ; let (_tx , rx) = oneshot :: channel :: < () > () ; let now = Instant :: now () ; let dur = Duration :: from_millis (10) ; let res = timeout (dur , rx) . await ; assert ! (res . is_err ()) ; assert ! (Instant :: now () >= now + dur) ; } . sig",
                        "file_path": "tokio/tests/time_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_many_edge_cases",
                        "label": "try_reserve_many_edge_cases",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_edge_cases () { const MAX_PERMITS : usize = tokio :: sync :: Semaphore :: MAX_PERMITS ; let (tx , rx) = mpsc :: channel :: < () > (1) ; let mut permit = assert_ok ! (tx . try_reserve_many (0)) ; assert ! (permit . next () . is_none ()) ; let permit = tx . try_reserve_many (MAX_PERMITS + 1) ; match assert_err ! (permit) { TrySendError :: Full (..) => { } _ => panic ! () , } let permit = tx . try_reserve_many (usize :: MAX) ; match assert_err ! (permit) { TrySendError :: Full (..) => { } _ => panic ! () , } drop (rx) ; assert_err ! (tx . reserve_many (0) . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_uncontended",
                        "label": "read_uncontended",
                        "kind": "Function",
                        "signature": "fn fn read_uncontended (g : & mut BenchmarkGroup < WallTime >) { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () ; let lock = Arc :: new (RwLock :: new (())) ; g . bench_function (\"read\" , | b | { b . iter (| | { let lock = lock . clone () ; rt . block_on (async move { for _ in 0 .. 6 { let read = lock . read () . await ; let _read = black_box (read) ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "very_large_timeout",
                        "label": "very_large_timeout",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn very_large_timeout () { time :: pause () ; let (tx , rx) = oneshot :: channel () ; let duration_max = Duration :: from_secs (u64 :: MAX) + Duration :: from_nanos (999_999_999) ; let mut fut = task :: spawn (timeout (duration_max , rx)) ; assert_pending ! (fut . poll ()) ; time :: advance (Duration :: from_secs (86400 * 365 * 10)) . await ; assert_pending ! (fut . poll ()) ; tx . send (()) . unwrap () ; assert_ready_ok ! (fut . poll ()) . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TokioAsyncWriteCompatExt",
                        "label": "TokioAsyncWriteCompatExt",
                        "kind": "Trait",
                        "signature": "trait TokioAsyncWriteCompatExt",
                        "file_path": "tokio-util/src/compat.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "runtime_gone",
                        "label": "runtime_gone",
                        "kind": "Function",
                        "signature": "fn # [test] fn runtime_gone () { let mut map = JoinMap :: new () ; { let rt = rt () ; map . spawn_on (\"key\" , async { 1 } , rt . handle ()) ; drop (rt) ; } let (key , res) = rt () . block_on (map . join_next ()) . unwrap () ; assert_eq ! (key , \"key\") ; assert ! (res . unwrap_err () . is_cancelled ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_usage",
                        "label": "basic_usage",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_usage () { let mut stream = StreamNotifyClose :: new (tokio_stream :: iter (vec ! [0 , 1])) ; assert_eq ! (stream . next () . await , Some (Some (0))) ; assert_eq ! (stream . next () . await , Some (Some (1))) ; assert_eq ! (stream . next () . await , Some (None)) ; assert_eq ! (stream . next () . await , None) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_close.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_header_offset",
                        "label": "read_header_offset",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_header_offset () { let io = length_delimited :: Builder :: new () . length_field_length (2) . length_field_offset (4) . new_read (mock ! { data (b\"zzzz\\x00\\x09abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_after_block_in_place",
                        "label": "yield_after_block_in_place",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_after_block_in_place () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (1) . build () . unwrap () ; rt . block_on (async { tokio :: spawn (async move { tokio :: task :: block_in_place (| | { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { }) ; }) ; tokio :: task :: yield_now () . await ; }) . await . unwrap () }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , () > { loop { if ! never () { return Ok (()) ; } } } . sig",
                        "file_path": "tests-build/tests/pass/macros_main_loop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_to_peek_from_poll",
                        "label": "send_to_peek_from_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_to_peek_from_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_peek_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_peek_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_unknown_flavor",
                        "label": "test_unknown_flavor",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"foo\")] async fn test_unknown_flavor () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_abort_on_drop",
                        "label": "test_abort_on_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_abort_on_drop () { let mut map = JoinMap :: new () ; let mut recvs = Vec :: new () ; for i in 0 .. 16 { let (send , recv) = oneshot :: channel :: < () > () ; recvs . push (recv) ; map . spawn (i , async { futures :: future :: pending :: < () > () . await ; drop (send) ; }) ; } drop (map) ; for recv in recvs { assert ! (recv . await . is_err ()) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_one_drop",
                        "label": "notified_multi_notify_one_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_one_drop () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified3 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; notify . notify_one () ; drop (notified1) ; assert_ready ! (notified2 . poll ()) ; assert_pending ! (notified3 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sink_poll_write_is_cooperative",
                        "label": "sink_poll_write_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sink_poll_write_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let buf = vec ! [1 , 2 , 3] ; tokio :: io :: sink () . write_all (& buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_sink.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_try_id_outside_task",
                        "label": "task_try_id_outside_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn task_try_id_outside_task () { assert_eq ! (None , task :: try_id ()) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "async_send_recv_many_with_buffer",
                        "label": "async_send_recv_many_with_buffer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_many_with_buffer () { let (tx , mut rx) = mpsc :: channel (2) ; let mut buffer = Vec :: < i32 > :: with_capacity (3) ; assert_eq ! (0 , rx . recv_many (& mut buffer , 0) . await) ; let handle = tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; assert_ok ! (tx . send (7) . await) ; assert_ok ! (tx . send (0) . await) ; }) ; let limit = 3 ; let mut recv_count = 0usize ; while recv_count < 4 { recv_count += rx . recv_many (& mut buffer , limit) . await ; assert_eq ! (buffer . len () , recv_count) ; } assert_eq ! (vec ! [1 , 2 , 7 , 0] , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedMappedMutexGuard",
                        "label": "OwnedMappedMutexGuard",
                        "kind": "Struct",
                        "signature": "struct OwnedMappedMutexGuard",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sink_send_ref",
                        "label": "sink_send_ref",
                        "kind": "Function",
                        "signature": "fn # [test] fn sink_send_ref () { let data = \"data\" . to_owned () ; let (send , mut recv) = channel (1) ; let mut send = PollSender :: new (send) ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; let mut ready = spawn (poll_fn (| cx | send . poll_ready_unpin (cx))) ; assert_ready_ok ! (ready . poll ()) ; assert_ok ! (send . start_send_unpin (data . as_str ())) ; let mut flush = spawn (poll_fn (| cx | send . poll_flush_unpin (cx))) ; assert_ready_ok ! (flush . poll ()) ; assert_ready_eq ! (recv_task . poll () , Some (\"data\")) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_close",
                        "label": "open_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_close () { let tracker = TaskTracker :: new () ; assert ! (! tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . close () ; assert ! (tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . reopen () ; assert ! (! tracker . is_closed ()) ; tracker . reopen () ; assert ! (! tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; tracker . close () ; assert ! (tracker . is_closed ()) ; tracker . close () ; assert ! (tracker . is_closed ()) ; assert ! (tracker . is_empty ()) ; assert_eq ! (tracker . len () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "manual_rt",
                        "label": "manual_rt",
                        "kind": "Function",
                        "signature": "fn # [test] fn manual_rt () { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { spawn_send () . await }) ; } . sig",
                        "file_path": "tests-integration/tests/rt_yield.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "exhaust_reading",
                        "label": "exhaust_reading",
                        "kind": "Function",
                        "signature": "fn # [test] fn exhaust_reading () { let rwlock = RwLock :: with_max_readers (100 , 1024) ; let mut reads = Vec :: new () ; loop { let mut t = spawn (rwlock . read ()) ; match t . poll () { Poll :: Ready (guard) => reads . push (guard) , Poll :: Pending => break , } } let mut t1 = spawn (rwlock . read ()) ; assert_pending ! (t1 . poll ()) ; let g2 = reads . pop () . unwrap () ; drop (g2) ; assert ! (t1 . is_woken ()) ; let _g1 = assert_ready ! (t1 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AssertDropHandle",
                        "label": "AssertDropHandle",
                        "kind": "Struct",
                        "signature": "struct AssertDropHandle",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_wakes_poll_race",
                        "label": "driver_shutdown_wakes_poll_race",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_wakes_poll_race () { for _ in 0 .. 100 { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; while afd_a . get_ref () . write (& [0 ; 512]) . is_ok () { } let _ = std :: thread :: spawn (move | | std :: mem :: drop (rt)) ; assert_err ! (futures :: executor :: block_on (poll_readable (& afd_a))) ; assert_err ! (futures :: executor :: block_on (poll_writable (& afd_a))) ; } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_same_task",
                        "label": "sleep_same_task",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_same_task () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let sleep = Box :: pin (time :: sleep_until (start + ms (300))) ; Tester { sleep , state : State :: Begin , before : None , poll : true , } . await ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stress_test",
                        "label": "stress_test",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn stress_test () { let sem = Arc :: new (Semaphore :: new (5)) ; let mut join_handles = Vec :: new () ; for _ in 0 .. 1000 { let sem_clone = sem . clone () ; join_handles . push (tokio :: spawn (async move { let _p = sem_clone . acquire () . await ; })) ; } for j in join_handles { j . await . unwrap () ; } let _p1 = sem . try_acquire () . unwrap () ; let _p2 = sem . try_acquire () . unwrap () ; let _p3 = sem . try_acquire () . unwrap () ; let _p4 = sem . try_acquire () . unwrap () ; let _p5 = sem . try_acquire () . unwrap () ; assert ! (sem . try_acquire () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Symbol",
                        "label": "Symbol",
                        "kind": "Struct",
                        "signature": "struct Symbol",
                        "file_path": "tokio/src/runtime/task/trace/symbol.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "anon_pipe_into_blocking_fd",
                        "label": "anon_pipe_into_blocking_fd",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn anon_pipe_into_blocking_fd () -> std :: io :: Result < () > { let (tx , rx) = pipe :: pipe () ? ; let tx_fd = tx . into_blocking_fd () ? ; let rx_fd = rx . into_blocking_fd () ? ; assert ! (! is_nonblocking (& tx_fd) ?) ; assert ! (! is_nonblocking (& rx_fd) ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_modify_panic",
                        "label": "send_modify_panic",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (panic = \"unwind\")] # [cfg (not (target_family = \"wasm\"))] fn send_modify_panic () { let (tx , mut rx) = watch :: channel (\"one\") ; tx . send_modify (| old | * old = \"two\") ; assert_eq ! (* rx . borrow_and_update () , \"two\") ; let mut rx2 = rx . clone () ; assert_eq ! (* rx2 . borrow_and_update () , \"two\") ; let mut task = spawn (rx2 . changed ()) ; let result = std :: panic :: catch_unwind (std :: panic :: AssertUnwindSafe (| | { tx . send_modify (| old | { * old = \"panicked\" ; panic ! () ; }) })) ; assert ! (result . is_err ()) ; assert_pending ! (task . poll ()) ; assert_eq ! (* rx . borrow () , \"panicked\") ; tx . send_modify (| old | * old = \"three\") ; assert_ready_ok ! (task . poll ()) ; assert_eq ! (* rx . borrow_and_update () , \"three\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reunite",
                        "label": "reunite",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn reunite (read : OwnedReadHalf , write : OwnedWriteHalf ,) -> Result < TcpStream , ReuniteError > { if Arc :: ptr_eq (& read . inner , & write . inner) { write . forget () ; Ok (Arc :: try_unwrap (read . inner) . expect (\"TcpStream: try_unwrap failed in reunite\")) } else { Err (ReuniteError (read , write)) } } . sig",
                        "file_path": "tokio/src/net/tcp/split_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "asyncify",
                        "label": "asyncify",
                        "kind": "Function",
                        "signature": "fn pub (crate) async fn asyncify < F , T > (f : F) -> io :: Result < T > where F : FnOnce () -> io :: Result < T > + Send + 'static , T : Send + 'static , { match spawn_blocking (f) . await { Ok (res) => res , Err (_) => Err (io :: Error :: new (io :: ErrorKind :: Other , \"background task failed\" ,)) , } } . sig",
                        "file_path": "tokio/src/fs/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BarrierState",
                        "label": "BarrierState",
                        "kind": "Struct",
                        "signature": "struct BarrierState",
                        "file_path": "tokio/src/sync/barrier.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "with_unconstrained",
                        "label": "with_unconstrained",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Runs the given closure with an unconstrained task budget. When the function returns, the budget\"] # [doc = \" is reset to the value prior to calling the function.\"] # [inline (always)] pub (crate) fn with_unconstrained < R > (f : impl FnOnce () -> R) -> R { with_budget (Budget :: unconstrained () , f) } . sig",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_exact",
                        "label": "read_exact",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_exact () { let mut buf = Box :: new ([0 ; 8]) ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_exact (& mut buf [..]) . await) ; assert_eq ! (n , 8) ; assert_eq ! (buf [..] , b\"hello wo\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_read_exact.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "func1",
                        "label": "func1",
                        "kind": "Function",
                        "signature": "fn async fn func1 () -> u32 { 5 } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Condvar",
                        "label": "Condvar",
                        "kind": "Struct",
                        "signature": "struct Condvar",
                        "file_path": "tokio/src/loom/std/parking_lot.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "fifo_simple_send",
                        "label": "fifo_simple_send",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn fifo_simple_send () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"simple_send\") ? ; let mut reader = pipe :: OpenOptions :: new () . open_receiver (& fifo) ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; let mut writer = pipe :: OpenOptions :: new () . open_sender (& fifo) ? ; writer . write_all (DATA) . await ? ; while ! read_fut . is_woken () { tokio :: task :: yield_now () . await ; } let read_data = assert_ready_ok ! (read_fut . poll ()) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_pending",
                        "label": "poll_next_many_pending",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_pending () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let mut is_pending = false ; poll_fn (| cx | { let poll = stream_map . poll_next_many (cx , & mut vec ! [] , 1) ; is_pending = poll . is_pending () ; Poll :: Ready (()) }) . await ; assert ! (is_pending) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "gated2",
                        "label": "gated2",
                        "kind": "Function",
                        "signature": "fn fn gated2 (thread : bool) -> impl Future < Output = & 'static str > { use loom :: thread ; use std :: sync :: Arc ; let gate = Arc :: new (AtomicBool :: new (false)) ; let mut fired = false ; poll_fn (move | cx | { if ! fired { let gate = gate . clone () ; let waker = cx . waker () . clone () ; if thread { thread :: spawn (move | | { gate . store (true , SeqCst) ; waker . wake_by_ref () ; }) ; } else { spawn (track (async move { gate . store (true , SeqCst) ; waker . wake_by_ref () ; })) ; } fired = true ; return Poll :: Pending ; } if gate . load (SeqCst) { Poll :: Ready (\"hello world\") } else { Poll :: Pending } }) } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_time_advance_sub_ms",
                        "label": "test_time_advance_sub_ms",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_time_advance_sub_ms () { let now = Instant :: now () ; let dur = Duration :: from_micros (51_592) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_micros (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "parse_string",
                        "label": "parse_string",
                        "kind": "Function",
                        "signature": "fn fn parse_string (int : syn :: Lit , span : Span , field : & str) -> Result < String , syn :: Error > { match int { syn :: Lit :: Str (s) => Ok (s . value ()) , syn :: Lit :: Verbatim (s) => Ok (s . to_string ()) , _ => Err (syn :: Error :: new (span , format ! (\"Failed to parse value of `{field}` as string.\") ,)) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_crate_not_path_int",
                        "label": "test_crate_not_path_int",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (crate = 456)] async fn test_crate_not_path_int () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_on_filled_channel",
                        "label": "test_rx_len_on_filled_channel",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_on_filled_channel () { let (tx , rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; } assert_eq ! (rx . len () , 100) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "add_max_amount_permits",
                        "label": "add_max_amount_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn add_max_amount_permits () { let s = tokio :: sync :: Semaphore :: new (0) ; s . add_permits (tokio :: sync :: Semaphore :: MAX_PERMITS) ; assert_eq ! (s . available_permits () , tokio :: sync :: Semaphore :: MAX_PERMITS) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_ready_eq",
                        "label": "assert_ready_eq",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_ready_eq () { let poll = ready () ; assert_ready_eq ! (poll , ()) ; assert_ready_eq ! (poll , () , \"some message\") ; assert_ready_eq ! (poll , () , \"{:?}\" , ()) ; assert_ready_eq ! (poll , () , \"{:?}\" , Test :: Data) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "futures_are_polled_in_order_in_biased_mode",
                        "label": "futures_are_polled_in_order_in_biased_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn futures_are_polled_in_order_in_biased_mode () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } } ; tokio :: join ! (biased ; fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) ; assert_eq ! (vec ! [1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_capacity_recvs_after_drop_2",
                        "label": "single_capacity_recvs_after_drop_2",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_capacity_recvs_after_drop_2 () { let (tx , mut rx) = broadcast :: channel (1) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_closed ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_closed_when_dropping_all_senders_except_weak_senders",
                        "label": "test_rx_unbounded_is_closed_when_dropping_all_senders_except_weak_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_closed_when_dropping_all_senders_except_weak_senders () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let _weak_sender = tx . clone () . downgrade () ; drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "accept_read_write",
                        "label": "accept_read_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn accept_read_write () -> std :: io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-uds-tests\") . tempdir () . unwrap () ; let sock_path = dir . path () . join (\"connect.sock\") ; let listener = UnixListener :: bind (& sock_path) ? ; let accept = listener . accept () ; let connect = UnixStream :: connect (& sock_path) ; let ((mut server , _) , mut client) = try_join (accept , connect) . await ? ; client . write_all (b\"hello\") . await ? ; drop (client) ; let mut buf = vec ! [] ; server . read_to_end (& mut buf) . await ? ; assert_eq ! (& buf , b\"hello\") ; let len = server . read (& mut buf) . await ? ; assert_eq ! (len , 0) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "channel",
                        "label": "channel",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn channel < T > () -> (Tx < T > , Rx < T >) { let initial_block = Block :: new (0) ; let initial_block_ptr = Box :: into_raw (initial_block) ; let tx = Tx { block_tail : AtomicPtr :: new (initial_block_ptr) , tail_position : AtomicUsize :: new (0) , } ; let head = NonNull :: new (initial_block_ptr) . unwrap () ; let rx = Rx { head , index : 0 , free_head : head , } ; (tx , rx) } . sig",
                        "file_path": "tokio/src/sync/mpsc/list.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "block_in_place",
                        "label": "block_in_place",
                        "kind": "Function",
                        "signature": "fn # [track_caller] pub (crate) fn block_in_place < F , R > (f : F) -> R where F : FnOnce () -> R , { scheduler :: multi_thread :: block_in_place (f) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/block_in_place.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "join_does_not_allow_tasks_to_starve",
                        "label": "join_does_not_allow_tasks_to_starve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn join_does_not_allow_tasks_to_starve () { let permits = Arc :: new (Semaphore :: new (1)) ; let (non_cooperative_result , little_task_result) = tokio :: join ! (non_cooperative_task (Arc :: clone (& permits)) , poor_little_task (permits)) ; assert_eq ! (5 , non_cooperative_result) ; assert_eq ! (5 , little_task_result) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SliceEncoder",
                        "label": "SliceEncoder",
                        "kind": "Struct",
                        "signature": "struct SliceEncoder",
                        "file_path": "tokio-util/tests/io_sink_writer.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "useful_panic_message_when_dropping_rt_in_rt",
                        "label": "useful_panic_message_when_dropping_rt_in_rt",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (panic = \"unwind\")] fn useful_panic_message_when_dropping_rt_in_rt () { use std :: panic :: { catch_unwind , AssertUnwindSafe } ; let outer = tokio :: runtime :: Runtime :: new () . unwrap () ; let result = catch_unwind (AssertUnwindSafe (| | { outer . block_on (async { let _ = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; }) ; })) ; assert ! (result . is_err ()) ; let err = result . unwrap_err () ; let err : & 'static str = err . downcast_ref :: < & 'static str > () . unwrap () ; assert ! (err . contains (\"Cannot drop a runtime\") , \"Wrong panic message: {err:?}\") ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_uncontented",
                        "label": "bench_uncontented",
                        "kind": "Function",
                        "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; uncontended (& mut group) ; uncontended_concurrent_multi (& mut group) ; uncontended_concurrent_single (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "panic_to_error",
                        "label": "panic_to_error",
                        "kind": "Function",
                        "signature": "fn # [cold] fn panic_to_error < S : Schedule > (scheduler : & S , task_id : Id , panic : Box < dyn Any + Send + 'static > ,) -> JoinError { scheduler . unhandled_panic () ; JoinError :: panic (task_id , panic) } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RxFuture",
                        "label": "RxFuture",
                        "kind": "Struct",
                        "signature": "struct RxFuture",
                        "file_path": "tokio/src/signal/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "copy_bidirectional_impl",
                        "label": "copy_bidirectional_impl",
                        "kind": "Function",
                        "signature": "fn async fn copy_bidirectional_impl < A , B > (a : & mut A , b : & mut B , a_to_b_buffer : CopyBuffer , b_to_a_buffer : CopyBuffer ,) -> io :: Result < (u64 , u64) > where A : AsyncRead + AsyncWrite + Unpin + ? Sized , B : AsyncRead + AsyncWrite + Unpin + ? Sized , { let mut a_to_b = TransferState :: Running (a_to_b_buffer) ; let mut b_to_a = TransferState :: Running (b_to_a_buffer) ; poll_fn (| cx | { let a_to_b = transfer_one_direction (cx , & mut a_to_b , a , b) ? ; let b_to_a = transfer_one_direction (cx , & mut b_to_a , b , a) ? ; let a_to_b = ready ! (a_to_b) ; let b_to_a = ready ! (b_to_a) ; Poll :: Ready (Ok ((a_to_b , b_to_a))) }) . await } . sig",
                        "file_path": "tokio/src/io/util/copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_spawn_many_remote_idle",
                        "label": "rt_multi_spawn_many_remote_idle",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_spawn_many_remote_idle (c : & mut Criterion) { let rt = rt () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_remote_idle\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_thread",
                        "label": "current_thread",
                        "kind": "Function",
                        "signature": "fn fn current_thread () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test",
                        "label": "test",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn test (args : TokenStream , item : TokenStream , rt_multi_thread : bool) -> TokenStream { let input : ItemFn = match syn :: parse2 (item . clone ()) { Ok (it) => it , Err (e) => return token_stream_with_error (item , e) , } ; let config = if let Some (attr) = input . attrs () . find (| attr | is_test_attribute (attr)) { let msg = \"second test attribute is supplied, consider removing or changing the order of your test attributes\" ; Err (syn :: Error :: new_spanned (attr , msg)) } else { AttributeArgs :: parse_terminated . parse2 (args) . and_then (| args | build_config (& input , args , true , rt_multi_thread)) } ; match config { Ok (config) => parse_knobs (input , true , config) , Err (e) => token_stream_with_error (parse_knobs (input , true , DEFAULT_ERROR_CONFIG) , e) , } } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "acquire_mutex_in_drop",
                        "label": "acquire_mutex_in_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn acquire_mutex_in_drop () { use futures :: future :: pending ; let (tx1 , rx1) = oneshot :: channel () ; let (tx2 , rx2) = oneshot :: channel () ; let local = LocalSet :: new () ; local . spawn_local (async move { let _ = rx2 . await ; unreachable ! () ; }) ; local . spawn_local (async move { let _ = rx1 . await ; tx2 . send (()) . unwrap () ; unreachable ! () ; }) ; local . spawn_local (async move { pending :: < () > () . await ; tx1 . send (()) . unwrap () ; }) ; local . run_until (async { task :: yield_now () . await ; }) . await ; drop (local) ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_blocking",
                        "label": "spawn_blocking",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Runs the provided function on an executor dedicated to blocking operations.\"] # [doc = \" Tasks will be scheduled as non-mandatory, meaning they may not get executed\"] # [doc = \" in case of runtime shutdown.\"] # [track_caller] # [cfg_attr (target_os = \"wasi\" , allow (dead_code))] pub (crate) fn spawn_blocking < F , R > (func : F) -> JoinHandle < R > where F : FnOnce () -> R + Send + 'static , R : Send + 'static , { let rt = Handle :: current () ; rt . spawn_blocking (func) } . sig",
                        "file_path": "tokio/src/runtime/blocking/pool.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_to_recv_from_poll",
                        "label": "send_to_recv_from_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_to_recv_from_poll () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver_addr = receiver . local_addr () ? ; poll_fn (| cx | sender . poll_send_to (cx , MSG , receiver_addr)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let addr = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , MSG) ; assert_eq ! (addr , sender . local_addr () ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Budget",
                        "label": "Budget",
                        "kind": "Struct",
                        "signature": "struct Budget",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "_named_pipe_mode_message",
                        "label": "_named_pipe_mode_message",
                        "kind": "Function",
                        "signature": "fn async fn _named_pipe_mode_message (mode : PipeMode) -> io :: Result < () > { let pipe_name = format ! (r\"\\\\.\\pipe\\test-named-pipe-mode-message-{}\" , matches ! (mode , PipeMode :: Message)) ; let mut buf = [0u8 ; 32] ; let mut server = ServerOptions :: new () . first_pipe_instance (true) . pipe_mode (mode) . create (& pipe_name) ? ; let mut client = ClientOptions :: new () . pipe_mode (mode) . open (& pipe_name) ? ; server . connect () . await ? ; for _ in 0 .. 10 { client . write_all (b\"hello\") . await ? ; server . write_all (b\"world\") . await ? ; } for _ in 0 .. 10 { let n = server . read (& mut buf) . await ? ; if buf [.. n] != b\"hello\" [..] { assert ! (matches ! (mode , PipeMode :: Byte)) ; return Ok (()) ; } let n = client . read (& mut buf) . await ? ; if buf [.. n] != b\"world\" [..] { assert ! (matches ! (mode , PipeMode :: Byte)) ; return Ok (()) ; } } assert ! (matches ! (mode , PipeMode :: Message)) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_permissions",
                        "label": "set_permissions",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Changes the permissions found on a file or a directory.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::set_permissions`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::set_permissions\"] pub async fn set_permissions (path : impl AsRef < Path > , perm : Permissions) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (| | std :: fs :: set_permissions (path , perm)) . await } . sig",
                        "file_path": "tokio/src/fs/set_permissions.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Cfg",
                        "label": "Cfg",
                        "kind": "Struct",
                        "signature": "struct Cfg",
                        "file_path": "tokio/src/runtime/driver.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_there_are_no_senders_and_there_are_messages",
                        "label": "test_rx_is_closed_when_there_are_no_senders_and_there_are_messages",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_there_are_no_senders_and_there_are_messages () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unused_braces_main",
                        "label": "unused_braces_main",
                        "kind": "Function",
                        "signature": "fn # [rustfmt :: skip] # [tokio :: main] pub async fn unused_braces_main () { println ! (\"hello\") } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AbortHandle",
                        "label": "AbortHandle",
                        "kind": "Struct",
                        "signature": "struct AbortHandle",
                        "file_path": "tokio/src/runtime/task/abort.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_after_completion_await",
                        "label": "try_recv_after_completion_await",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_after_completion_await () { let (tx , rx) = oneshot :: channel :: < i32 > () ; let mut rx = task :: spawn (rx) ; tx . send (17) . unwrap () ; assert_eq ! (Ok (17) , assert_ready ! (rx . poll ())) ; assert_eq ! (Err (TryRecvError :: Closed) , rx . try_recv ()) ; rx . close () ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sub_ms_delayed_sleep",
                        "label": "sub_ms_delayed_sleep",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sub_ms_delayed_sleep () { time :: pause () ; for _ in 0 .. 5 { let now = Instant :: now () ; let deadline = now + ms (1) + Duration :: new (0 , 1) ; time :: sleep_until (deadline) . await ; assert_elapsed ! (now , ms (1)) ; } } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_cell",
                        "label": "drop_cell",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_cell () { let fooer = DropCounter :: new () ; let fooer_cl = fooer . clone () ; { let once_cell = SetOnce :: new () ; let prev = once_cell . set (fooer_cl) ; assert ! (prev . is_ok ()) } fooer . assert_num_drops (1) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_all_elements_during_panic",
                        "label": "drop_all_elements_during_panic",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (panic = \"abort\"))] fn drop_all_elements_during_panic () { use std :: sync :: atomic :: AtomicUsize ; use std :: sync :: atomic :: Ordering :: Relaxed ; use tokio :: sync :: mpsc :: UnboundedReceiver ; use tokio :: sync :: mpsc :: UnboundedSender ; static COUNTER : AtomicUsize = AtomicUsize :: new (0) ; struct A (bool) ; impl Drop for A { fn drop (& mut self) { COUNTER . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; if self . 0 { panic ! (\"panic!\") } } } fn func (tx : UnboundedSender < A > , rx : UnboundedReceiver < A >) { tx . send (A (true)) . unwrap () ; tx . send (A (false)) . unwrap () ; tx . send (A (false)) . unwrap () ; drop (rx) ; } let (tx , rx) = mpsc :: unbounded_channel () ; let _ = panic :: catch_unwind (panic :: AssertUnwindSafe (| | { func (tx . clone () , rx) ; })) ; assert_eq ! (COUNTER . load (Relaxed) , 3) ; drop (tx) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_max_length_big_burst",
                        "label": "any_delimiter_decoder_max_length_big_burst",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_max_length_big_burst () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too long!\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Buf",
                        "label": "Buf",
                        "kind": "Struct",
                        "signature": "struct Buf",
                        "file_path": "tokio/src/io/blocking.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_sender_strong_count_when_cloned",
                        "label": "unbounded_sender_strong_count_when_cloned",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn unbounded_sender_strong_count_when_cloned () { let (tx , rx) = mpsc :: unbounded_channel :: < () > () ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_not_empty_when_the_buffer_is_full",
                        "label": "test_rx_is_not_empty_when_the_buffer_is_full",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_not_empty_when_the_buffer_is_full () { let (tx , rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } assert ! (! rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "change_tasks",
                        "label": "change_tasks",
                        "kind": "Function",
                        "signature": "fn # [test] fn change_tasks () { let (tx , mut rx) = broadcast :: channel (1) ; let mut recv = Box :: pin (rx . recv ()) ; let mut task1 = task :: spawn (& mut recv) ; assert_pending ! (task1 . poll ()) ; let mut task2 = task :: spawn (& mut recv) ; assert_pending ! (task2 . poll ()) ; tx . send (\"hello\") . unwrap () ; assert ! (task2 . is_woken ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_collision_current_thread",
                        "label": "task_id_collision_current_thread",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_collision_current_thread () { let handle1 = tokio :: spawn (async { task :: id () }) ; let handle2 = tokio :: spawn (async { task :: id () }) ; let (id1 , id2) = tokio :: join ! (handle1 , handle2) ; assert_ne ! (id1 . unwrap () , id2 . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_when_consuming_all_messages",
                        "label": "test_rx_unbounded_len_when_consuming_all_messages",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_when_consuming_all_messages () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; assert_eq ! (rx . len () , i + 1) ; } drop (tx) ; for i in (0 .. 100) . rev () { assert ! (rx . recv () . await . is_some ()) ; assert_eq ! (rx . len () , i) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "move_uncompleted_futures",
                        "label": "move_uncompleted_futures",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn move_uncompleted_futures () { let (tx1 , mut rx1) = oneshot :: channel :: < i32 > () ; let (tx2 , mut rx2) = oneshot :: channel :: < i32 > () ; tx1 . send (1) . unwrap () ; tx2 . send (2) . unwrap () ; let ran ; tokio :: select ! { res = & mut rx1 => { assert_eq ! (1 , assert_ok ! (res)) ; assert_eq ! (2 , assert_ok ! (rx2 . await)) ; ran = true ; } , res = & mut rx2 => { assert_eq ! (2 , assert_ok ! (res)) ; assert_eq ! (1 , assert_ok ! (rx1 . await)) ; ran = true ; } , } assert ! (ran) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_with_sleep",
                        "label": "test_with_sleep",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_with_sleep () { let mut set = JoinSet :: new () ; for i in 0 .. 10 { set . spawn (async move { i }) ; assert_eq ! (set . len () , 1 + i) ; } set . detach_all () ; assert_eq ! (set . len () , 0) ; assert ! (set . join_next () . await . is_none ()) ; for i in 0 .. 10 { set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; assert_eq ! (set . len () , 1 + i) ; } let mut seen = [false ; 10] ; while let Some (res) = set . join_next () . await . transpose () . unwrap () { seen [res] = true ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (set . join_next () . await . is_none ()) ; for i in 0 .. 10 { set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; } let mut seen = [false ; 10] ; while let Some (res) = set . join_next () . await . transpose () . unwrap () { seen [res] = true ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (set . join_next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "request_reply",
                        "label": "request_reply",
                        "kind": "Function",
                        "signature": "fn fn request_reply (b : & mut Criterion , rt : Runtime) { let tx = rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < oneshot :: Sender < () > > (10) ; tokio :: spawn (async move { while let Some (reply) = rx . recv () . await { reply . send (()) . unwrap () ; } }) ; tx }) ; b . bench_function (\"request_reply\" , | b | { b . iter (| | { let task_tx = tx . clone () ; rt . block_on (async move { for _ in 0 .. 1_000 { let (o_tx , o_rx) = oneshot :: channel () ; task_tx . send (o_tx) . await . unwrap () ; let _ = o_rx . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_listener_bind_panic_caller",
                        "label": "unix_listener_bind_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_listener_bind_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixListener ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixListener :: bind (& sock_path) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lagging_receiver_recovers_after_wrap_closed_1",
                        "label": "lagging_receiver_recovers_after_wrap_closed_1",
                        "kind": "Function",
                        "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_closed_1 () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; drop (tx) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_closed ! (rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_channel",
                        "label": "unbounded_channel",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates an unbounded mpsc channel for communicating between asynchronous\"] # [doc = \" tasks without backpressure.\"] # [doc = \"\"] # [doc = \" A `send` on this channel will always succeed as long as the receive half has\"] # [doc = \" not been closed. If the receiver falls behind, messages will be arbitrarily\"] # [doc = \" buffered.\"] # [doc = \"\"] # [doc = \" **Note** that the amount of available system memory is an implicit bound to\"] # [doc = \" the channel. Using an `unbounded` channel has the ability of causing the\"] # [doc = \" process to run out of memory. In this case, the process will be aborted.\"] pub fn unbounded_channel < T > () -> (UnboundedSender < T > , UnboundedReceiver < T >) { let (tx , rx) = chan :: channel (Semaphore (AtomicUsize :: new (0))) ; let tx = UnboundedSender :: new (tx) ; let rx = UnboundedReceiver :: new (rx) ; (tx , rx) } . sig",
                        "file_path": "tokio/src/sync/mpsc/unbounded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_exists",
                        "label": "try_exists",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns `Ok(true)` if the path points at an existing entity.\"] # [doc = \"\"] # [doc = \" This function will traverse symbolic links to query information about the\"] # [doc = \" destination file. In case of broken symbolic links this will return `Ok(false)`.\"] # [doc = \"\"] # [doc = \" This is the async equivalent of [`std::path::Path::try_exists`][std].\"] # [doc = \"\"] # [doc = \" [std]: fn@std::path::Path::try_exists\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" # async fn dox() -> std::io::Result<()> {\"] # [doc = \" fs::try_exists(\\\"foo.txt\\\").await?;\"] # [doc = \" # Ok(())\"] # [doc = \" # }\"] # [doc = \" ```\"] pub async fn try_exists (path : impl AsRef < Path >) -> io :: Result < bool > { let path = path . as_ref () . to_owned () ; asyncify (move | | path . try_exists ()) . await } . sig",
                        "file_path": "tokio/src/fs/try_exists.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_len_with_lagged",
                        "label": "receiver_len_with_lagged",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_len_with_lagged () { let (tx , mut rx) = broadcast :: channel (3) ; tx . send (10) . unwrap () ; tx . send (20) . unwrap () ; tx . send (30) . unwrap () ; tx . send (40) . unwrap () ; assert_eq ! (rx . len () , 4) ; assert_eq ! (assert_recv ! (rx) , 10) ; tx . send (50) . unwrap () ; tx . send (60) . unwrap () ; assert_eq ! (rx . len () , 5) ; assert_lagged ! (rx . try_recv () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedTasksInner",
                        "label": "OwnedTasksInner",
                        "kind": "Struct",
                        "signature": "struct OwnedTasksInner",
                        "file_path": "tokio/src/runtime/task/list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "single",
                        "label": "single",
                        "kind": "Function",
                        "signature": "fn # [test] fn single () { let b = Barrier :: new (1) ; { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } { let mut w = spawn (b . wait ()) ; let wr = assert_ready ! (w . poll ()) ; assert ! (wr . is_leader ()) ; } } . sig",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_id_offset",
                        "label": "get_id_offset",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Compute the offset of the `Id` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_id_offset (header_size : usize , core_align : usize , scheduler_size : usize , id_align : usize ,) -> usize { let mut offset = get_core_offset (header_size , core_align) ; offset += scheduler_size ; let id_misalign = offset % id_align ; if id_misalign > 0 { offset += id_align - id_misalign ; } offset } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_send_and_sync",
                        "label": "is_send_and_sync",
                        "kind": "Function",
                        "signature": "fn # [test] fn is_send_and_sync () { fn assert_bound < T : Send + Sync > () { } assert_bound :: < ReadHalf < RW > > () ; assert_bound :: < WriteHalf < RW > > () ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with",
                        "label": "with",
                        "kind": "Function",
                        "signature": "fn fn with (f : impl FnOnce (Runtime)) { struct Reset ; impl Drop for Reset { fn drop (& mut self) { let _rt = CURRENT . try_lock () . unwrap () . take () ; } } let _reset = Reset ; let rt = Runtime (Arc :: new (Inner { owned : OwnedTasks :: new (16) , core : Mutex :: new (Core { queue : VecDeque :: new () , }) , })) ; * CURRENT . try_lock () . unwrap () = Some (rt . clone ()) ; f (rt) } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "func2",
                        "label": "func2",
                        "kind": "Function",
                        "signature": "fn async fn func2 () -> u32 { time :: sleep (Duration :: from_millis (1)) . await ; 10 } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_framed_lines_codec",
                        "label": "send_framed_lines_codec",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn send_framed_lines_codec () -> std :: io :: Result < () > { let a_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let b_soc = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , LinesCodec :: new ()) ; let msg = b\"1\\r\\n2\\r\\n3\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"1\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"2\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"3\" . to_string () , a_addr)) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_and_wait_multiple_threads",
                        "label": "set_and_wait_multiple_threads",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (target_family = \"wasm\" , ignore)] fn set_and_wait_multiple_threads () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let res1 = std :: thread :: spawn (| | ONCE . set (4)) ; let res2 = std :: thread :: spawn (| | ONCE . set (3)) ; let result_first = res1 . join () . unwrap () . is_err () ; let result_two = res2 . join () . unwrap () . is_err () ; assert ! (result_first != result_two) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_join_next_with_id",
                        "label": "test_join_queue_join_next_with_id",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_join_next_with_id () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut queue = JoinQueue :: new () ; let mut spawned = Vec :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = queue . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . push (handle . id ()) ; } drop (recv) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut joined = Vec :: with_capacity (TASK_NUM as usize) ; while let Some (res) = queue . join_next_with_id () . await { match res { Ok ((id , ())) => { count += 1 ; joined . push (id) ; } Err (err) => panic ! (\"failed: {err}\") , } } assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "driver_shutdown_then_clear_readiness",
                        "label": "driver_shutdown_then_clear_readiness",
                        "kind": "Function",
                        "signature": "fn # [test] fn driver_shutdown_then_clear_readiness () { let rt = rt () ; let (a , _b) = socketpair () ; let afd_a = { let _enter = rt . enter () ; AsyncFd :: new (a) . unwrap () } ; let mut write_ready = rt . block_on (afd_a . writable ()) . unwrap () ; std :: mem :: drop (rt) ; write_ready . clear_ready () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_len_random",
                        "label": "sender_len_random",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (all (target_family = \"wasm\" , not (target_os = \"wasi\"))))] fn sender_len_random () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; for _ in 0 .. 1000 { match rand :: random_range (0 .. 4) { 0 => { let _ = rx1 . try_recv () ; } 1 => { let _ = rx2 . try_recv () ; } _ => { tx . send (0) . unwrap () ; } } let expected_len = usize :: min (usize :: max (rx1 . len () , rx2 . len ()) , 16) ; assert_eq ! (tx . len () , expected_len) ; } } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "JoinMap",
                        "label": "JoinMap",
                        "kind": "Struct",
                        "signature": "struct JoinMap",
                        "file_path": "tokio-util/src/task/join_map.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "timeout_panic_caller",
                        "label": "timeout_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn timeout_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let _timeout = timeout (Duration :: from_millis (5) , future :: pending :: < () > ()) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/time_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_crate_not_path_invalid",
                        "label": "test_crate_not_path_invalid",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (crate = \"456\")] async fn test_crate_not_path_invalid () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_entry",
                        "label": "single_entry",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn single_entry () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx , rx) = mpsc :: unbounded_channel_stream () ; let rx = Box :: pin (rx) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"foo\" , rx) . is_none ()) ; assert ! (map . contains_key (\"foo\")) ; assert ! (! map . contains_key (\"bar\")) ; assert_eq ! (map . len () , 1) ; assert ! (! map . is_empty ()) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx . send (1)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 1) ; assert_pending ! (map . poll_next ()) ; assert_ok ! (tx . send (2)) ; assert ! (map . is_woken ()) ; let (k , v) = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (k , \"foo\") ; assert_eq ! (v , 2) ; assert_pending ! (map . poll_next ()) ; drop (tx) ; assert ! (map . is_woken ()) ; assert_ready_none ! (map . poll_next ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_ready",
                        "label": "assert_ready",
                        "kind": "Function",
                        "signature": "fn # [test] fn assert_ready () { let poll = ready () ; assert_ready ! (poll) ; assert_ready ! (poll , \"some message\") ; assert_ready ! (poll , \"{:?}\" , ()) ; assert_ready ! (poll , \"{:?}\" , Test :: Data) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_shutdown",
                        "label": "ctrl_shutdown",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_shutdown () -> io :: Result < RxFuture > { new (console :: CTRL_SHUTDOWN_EVENT) } . sig",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "num_alive_tasks",
                        "label": "num_alive_tasks",
                        "kind": "Function",
                        "signature": "fn # [test] fn num_alive_tasks () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . num_alive_tasks ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . num_alive_tasks ()) ; })) . unwrap () ; assert_eq ! (0 , rt . metrics () . num_alive_tasks ()) ; let rt = threaded () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . num_alive_tasks ()) ; rt . block_on (rt . spawn (async move { assert_eq ! (1 , metrics . num_alive_tasks ()) ; })) . unwrap () ; for _ in 0 .. 100 { if rt . metrics () . num_alive_tasks () == 0 { break ; } std :: thread :: sleep (std :: time :: Duration :: from_millis (100)) ; } assert_eq ! (0 , rt . metrics () . num_alive_tasks ()) ; } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "biased_eventually_ready",
                        "label": "biased_eventually_ready",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] # [cfg (feature = \"full\")] async fn biased_eventually_ready () { use tokio :: task :: yield_now ; let one = async { } ; let two = async { yield_now () . await } ; let three = async { yield_now () . await } ; let mut count = 0u8 ; tokio :: pin ! (one , two , three) ; loop { tokio :: select ! { biased ; _ = & mut two , if count < 2 => { count += 1 ; assert_eq ! (count , 2) ; } _ = & mut three , if count < 3 => { count += 1 ; assert_eq ! (count , 3) ; } _ = & mut one , if count < 1 => { count += 1 ; assert_eq ! (count , 1) ; } else => break , } } assert_eq ! (count , 3) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unbounded_mpsc_channel",
                        "label": "unbounded_mpsc_channel",
                        "kind": "Function",
                        "signature": "fn # [test] fn unbounded_mpsc_channel () { test_with_runtimes (| | { let (tx , mut rx) = mpsc :: unbounded_channel () ; let _ = tx . send (42) ; let value = Handle :: current () . block_on (rx . recv ()) . unwrap () ; assert_eq ! (value , 42) ; }) } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notified_multi_notify_drop_one",
                        "label": "notified_multi_notify_drop_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notified_multi_notify_drop_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert ! (notified1 . is_woken ()) ; assert ! (! notified2 . is_woken ()) ; drop (notified1) ; assert ! (notified2 . is_woken ()) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "windows_main",
                        "label": "windows_main",
                        "kind": "Function",
                        "signature": "fn # [cfg (windows)] async fn windows_main () -> io :: Result < () > { use tokio :: io :: Interest ; use tokio :: net :: windows :: named_pipe :: { ClientOptions , ServerOptions } ; const PIPE_NAME : & str = r\"\\\\.\\pipe\\named-pipe-single-client\" ; let server = ServerOptions :: new () . create (PIPE_NAME) ? ; let server = tokio :: spawn (async move { server . connect () . await ? ; let buf = { let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; loop { server . readable () . await ? ; let buf = & mut read_buf [read_buf_cursor ..] ; match server . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } read_buf } ; { let write_buf = b\"pong\\n\" ; let mut write_buf_cursor = 0 ; loop { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { break ; } server . writable () . await ? ; match server . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } Ok :: < _ , io :: Error > (buf) }) ; let client = tokio :: spawn (async move { let client = ClientOptions :: new () . open (PIPE_NAME) ? ; let mut read_buf = [0u8 ; 5] ; let mut read_buf_cursor = 0 ; let write_buf = b\"ping\\n\" ; let mut write_buf_cursor = 0 ; loop { let mut interest = Interest :: READABLE ; if write_buf_cursor < write_buf . len () { interest |= Interest :: WRITABLE ; } let ready = client . ready (interest) . await ? ; if ready . is_readable () { let buf = & mut read_buf [read_buf_cursor ..] ; match client . try_read (buf) { Ok (n) => { read_buf_cursor += n ; if read_buf_cursor == read_buf . len () { break ; } } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } if ready . is_writable () { let buf = & write_buf [write_buf_cursor ..] ; if buf . is_empty () { continue ; } match client . try_write (buf) { Ok (n) => { write_buf_cursor += n ; } Err (e) if e . kind () == io :: ErrorKind :: WouldBlock => { continue ; } Err (e) => { return Err (e) ; } } } } let buf = String :: from_utf8_lossy (& read_buf) . into_owned () ; Ok :: < _ , io :: Error > (buf) }) ; let (server , client) = tokio :: try_join ! (server , client) ? ; assert_eq ! (server ?, * b\"ping\\n\") ; assert_eq ! (client ?, \"pong\\n\") ; Ok (()) } . sig",
                        "file_path": "examples/named-pipe-ready.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "partial_read_set_len_ok",
                        "label": "partial_read_set_len_ok",
                        "kind": "Function",
                        "signature": "fn # [test] fn partial_read_set_len_ok () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; file . expect_inner_seek () . once () . with (eq (SeekFrom :: Current (- (HELLO . len () as i64)))) . in_sequence (& mut seq) . returning (| _ | Ok (0)) ; file . expect_set_len () . once () . in_sequence (& mut seq) . with (eq (123)) . returning (| _ | Ok (())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. FOO . len ()] . copy_from_slice (FOO) ; Ok (FOO . len ()) }) ; let mut buf = [0 ; 32] ; let mut file = File :: from_std (file) ; { let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut t = task :: spawn (file . set_len (123)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert_ready_ok ! (t . poll ()) ; } let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , FOO . len ()) ; assert_eq ! (& buf [.. n] , FOO) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "len",
                        "label": "len",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Calculate the length of the queue using the head and tail.\"] # [doc = \" The `head` can be the `steal` or `real` head.\"] fn len (head : UnsignedShort , tail : UnsignedShort) -> usize { tail . wrapping_sub (head) as usize } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "make_future",
                        "label": "make_future",
                        "kind": "Function",
                        "signature": "fn async fn make_future < T : Clone + Send + Sync > (mut rx : Receiver < T > ,) -> (Result < () , RecvError > , Receiver < T >) { let result = rx . changed () . await ; (result , rx) } . sig",
                        "file_path": "tokio-stream/src/wrappers/watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "writable_by_poll",
                        "label": "writable_by_poll",
                        "kind": "Function",
                        "signature": "fn fn writable_by_poll (writer : & pipe :: Sender) -> bool { task :: spawn (writer . writable ()) . poll () . is_ready () } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main_attr_has_path_args",
                        "label": "main_attr_has_path_args",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main (threadpool :: bar)] async fn main_attr_has_path_args () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_and_get",
                        "label": "set_and_get",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_and_get () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; ONCE . set (5) . unwrap () ; let value = ONCE . get () . unwrap () ; assert_eq ! (* value , 5) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_panics",
                        "label": "task_panics",
                        "kind": "Function",
                        "signature": "fn # [cfg (panic = \"unwind\")] # [tokio :: test (start_paused = true)] async fn task_panics () { let mut set : JoinSet < () > = JoinSet :: new () ; let (tx , mut rx) = oneshot :: channel () ; assert_eq ! (set . len () , 0) ; set . spawn (async move { tokio :: time :: sleep (Duration :: from_secs (2)) . await ; tx . send (()) . unwrap () ; }) ; assert_eq ! (set . len () , 1) ; set . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; panic ! () ; }) ; assert_eq ! (set . len () , 2) ; let panic = tokio :: spawn (set . join_all ()) . await . unwrap_err () ; assert ! (rx . try_recv () . is_err ()) ; assert ! (panic . is_panic ()) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_multi_frame_in_packet_after_codec_changed",
                        "label": "read_multi_frame_in_packet_after_codec_changed",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_multi_frame_in_packet_after_codec_changed () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\" . to_vec ()) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0x04) ; let mut framed = framed . map_decoder (| _ | U64Decoder) ; assert_read ! (pin ! (framed) . poll_next (cx) , 0x08) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf_bad_async_read",
                        "label": "read_buf_bad_async_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn read_buf_bad_async_read () { let mut buf = Vec :: with_capacity (10) ; BadAsyncRead :: new () . read_buf (& mut buf) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_poll_after_enable",
                        "label": "test_poll_after_enable",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_poll_after_enable () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; assert_pending ! (future . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "process_spawned_and_wait_in_different_runtime",
                        "label": "process_spawned_and_wait_in_different_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn process_spawned_and_wait_in_different_runtime () { let mut child = Runtime :: new () . unwrap () . block_on (async { Command :: new (\"true\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () . unwrap () }) ; Runtime :: new () . unwrap () . block_on (async { let _ = child . wait () . await . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/tests/process_change_of_runtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_multi_notified_one",
                        "label": "notify_multi_notified_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_multi_notified_one () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "close_sender_not_last",
                        "label": "close_sender_not_last",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn close_sender_not_last () { let (send , mut recv) = channel :: < i32 > (3) ; let mut send = PollSender :: new (send) ; let send2 = send . get_ref () . cloned () . unwrap () ; let mut recv_task = spawn (recv . recv ()) ; assert_pending ! (recv_task . poll ()) ; send . close () ; assert ! (! recv_task . is_woken ()) ; assert_pending ! (recv_task . poll ()) ; drop (send2) ; assert ! (recv_task . is_woken ()) ; assert ! (assert_ready ! (recv_task . poll ()) . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LegacyBuilder",
                        "label": "LegacyBuilder",
                        "kind": "Struct",
                        "signature": "struct LegacyBuilder",
                        "file_path": "tokio/src/runtime/metrics/histogram.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "poll_process_levels_targeted",
                        "label": "poll_process_levels_targeted",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn poll_process_levels_targeted () { let mut context = Context :: from_waker (noop_waker_ref ()) ; let rt = rt (true) ; let handle = rt . handle () ; let e1 = TimerEntry :: new (handle . inner . clone () , handle . inner . driver () . clock () . now () + Duration :: from_millis (193) ,) ; pin ! (e1) ; let handle = handle . inner . driver () . time () ; handle . process_at_time (62) ; assert ! (e1 . as_mut () . poll_elapsed (& mut context) . is_pending ()) ; handle . process_at_time (192) ; handle . process_at_time (192) ; } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Header",
                        "label": "Header",
                        "kind": "Struct",
                        "signature": "struct Header",
                        "file_path": "tokio/src/runtime/task/core.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "send_sync_bound",
                        "label": "send_sync_bound",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_sync_bound () { use tokio :: runtime :: Runtime ; fn is_send < T : Send + Sync > () { } is_send :: < Runtime > () ; } . sig",
                        "file_path": "tokio/tests/rt_common.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "quick_job",
                        "label": "quick_job",
                        "kind": "Function",
                        "signature": "fn async fn quick_job () -> usize { 1 } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_spawn_local",
                        "label": "task_id_spawn_local",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn_local () { LocalSet :: new () . run_until (async { task :: spawn_local (async { println ! (\"task id: {}\" , task :: id ()) }) . await . unwrap () ; }) . await } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_timer",
                        "label": "single_timer",
                        "kind": "Function",
                        "signature": "fn # [test] fn single_timer () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_until_pending",
                        "label": "read_until_pending",
                        "kind": "Function",
                        "signature": "fn fn read_until_pending (stream : & mut UnixStream) { let mut buf = vec ! [0u8 ; 1024 * 1024] ; loop { match stream . try_read (& mut buf) { Ok (_) => () , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "increase_handle_refcount",
                        "label": "increase_handle_refcount",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Increases the reference count of handles.\"] pub (crate) fn increase_handle_refcount (node : & Arc < TreeNode >) { let mut locked_node = node . inner . lock () . unwrap () ; assert ! (locked_node . num_handles > 0) ; locked_node . num_handles += 1 ; } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_buf_reads_are_cooperative",
                        "label": "empty_buf_reads_are_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_buf_reads_are_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = String :: new () ; let _ = tokio :: io :: empty () . read_line (& mut buf) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_util_empty.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_incomplete_payload",
                        "label": "read_incomplete_payload",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_incomplete_payload () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\\x00\\x09ab\") , Poll :: Pending , data (b\"cd\") , Poll :: Pending , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_pending ! (io) ; assert_next_pending ! (io) ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U32Codec",
                        "label": "U32Codec",
                        "kind": "Struct",
                        "signature": "struct U32Codec",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "task_try_id_inside_block_on",
                        "label": "task_try_id_inside_block_on",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn task_try_id_inside_block_on () { let rt = Runtime :: new () . unwrap () ; rt . block_on (async { assert_eq ! (None , task :: try_id ()) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_map",
                        "label": "downgrade_map",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn downgrade_map () { let lock = RwLock :: new (0) ; let write_guard = lock . write () . await ; let mut read_t = spawn (lock . read ()) ; assert_pending ! (read_t . poll ()) ; let read_guard1 = RwLockWriteGuard :: downgrade_map (write_guard , | v | { assert_pending ! (read_t . poll ()) ; v }) ; let read_guard2 = assert_ready ! (read_t . poll ()) ; assert_eq ! (&* read_guard1 as * const _ , &* read_guard2 as * const _) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_block_in_current_thread_block_on",
                        "label": "no_block_in_current_thread_block_on",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn no_block_in_current_thread_block_on () { let rt = runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { task :: block_in_place (| | { }) ; }) ; } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "LocalOptions",
                        "label": "LocalOptions",
                        "kind": "Struct",
                        "signature": "struct LocalOptions",
                        "file_path": "tokio/src/runtime/local_runtime/options.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unsplit_err1",
                        "label": "unsplit_err1",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn unsplit_err1 () { let (r , _) = split (RW) ; let (_ , w) = split (RW) ; r . unsplit (w) ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "forget",
                        "label": "forget",
                        "kind": "Function",
                        "signature": "fn # [test] fn forget () { let sem = Arc :: new (Semaphore :: new (1)) ; { let p = sem . clone () . try_acquire_owned () . unwrap () ; assert_eq ! (sem . available_permits () , 0) ; p . forget () ; assert_eq ! (sem . available_permits () , 0) ; } assert_eq ! (sem . available_permits () , 0) ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_blocking",
                        "label": "basic_blocking",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_blocking () { for _ in 0 .. 100 { let out = assert_ok ! (tokio :: spawn (async { assert_ok ! (task :: spawn_blocking (|| { thread :: sleep (Duration :: from_millis (5)) ; \"hello\" }) . await) }) . await) ; assert_eq ! (out , \"hello\") ; } } . sig",
                        "file_path": "tokio/tests/task_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test",
                        "label": "test",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Marks async function to be executed by runtime, suitable to test environment.\"] # [doc = \" This macro helps set up a `Runtime` without requiring the user to use\"] # [doc = \" [Runtime](../tokio/runtime/struct.Runtime.html) or\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html) directly.\"] # [doc = \"\"] # [doc = \" Note: This macro is designed to be simplistic and targets applications that\"] # [doc = \" do not require a complex setup. If the provided functionality is not\"] # [doc = \" sufficient, you may be interested in using\"] # [doc = \" [Builder](../tokio/runtime/struct.Builder.html), which provides a more\"] # [doc = \" powerful interface.\"] # [doc = \"\"] # [doc = \" # Multi-threaded runtime\"] # [doc = \"\"] # [doc = \" To use the multi-threaded runtime, the macro can be configured using\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\", worker_threads = 1)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" The `worker_threads` option configures the number of worker threads, and\"] # [doc = \" defaults to the number of cpus on the system.\"] # [doc = \"\"] # [doc = \" Note: The multi-threaded runtime requires the `rt-multi-thread` feature\"] # [doc = \" flag.\"] # [doc = \"\"] # [doc = \" # Current thread runtime\"] # [doc = \"\"] # [doc = \" The default test runtime is single-threaded. Each test gets a\"] # [doc = \" separate current-thread runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ### Using the multi-thread runtime\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Using current thread runtime\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Set number of worker threads\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(flavor = \\\"multi_thread\\\", worker_threads = 2)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_multi_thread()\"] # [doc = \"         .worker_threads(2)\"] # [doc = \"         .enable_all()\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Configure the runtime to start with time paused\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test(start_paused = true)]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .start_paused(true)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             assert!(true);\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Note that `start_paused` requires the `test-util` feature to be enabled.\"] # [doc = \"\"] # [doc = \" ### Rename package\"] # [doc = \"\"] # [doc = \" ```rust\"] # [doc = \" use tokio as tokio1;\"] # [doc = \"\"] # [doc = \" #[tokio1::test(crate = \\\"tokio1\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     println!(\\\"Hello world\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" ### Configure unhandled panic behavior\"] # [doc = \"\"] # [doc = \" Available options are `shutdown_runtime` and `ignore`. For more details, see\"] # [doc = \" [`Builder::unhandled_panic`].\"] # [doc = \"\"] # [doc = \" This option is only compatible with the `current_thread` runtime.\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[tokio::test(flavor = \\\"current_thread\\\", unhandled_panic = \\\"shutdown_runtime\\\")]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     let _ = tokio::spawn(async {\"] # [doc = \"         panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"     }).await;\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Equivalent code not using `#[tokio::test]`\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[cfg(tokio_unstable)]\"] # [doc = \" #[test]\"] # [doc = \" fn my_test() {\"] # [doc = \"     tokio::runtime::Builder::new_current_thread()\"] # [doc = \"         .enable_all()\"] # [doc = \"         .unhandled_panic(UnhandledPanic::ShutdownRuntime)\"] # [doc = \"         .build()\"] # [doc = \"         .unwrap()\"] # [doc = \"         .block_on(async {\"] # [doc = \"             let _ = tokio::spawn(async {\"] # [doc = \"                 panic!(\\\"This panic will shutdown the runtime.\\\");\"] # [doc = \"             }).await;\"] # [doc = \"         })\"] # [doc = \" }\"] # [doc = \"\"] # [doc = \" # fn main() { }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" **Note**: This option depends on Tokio's [unstable API][unstable]. See [the\"] # [doc = \" documentation on unstable features][unstable] for details on how to enable\"] # [doc = \" Tokio's unstable features.\"] # [doc = \"\"] # [doc = \" [`Builder::unhandled_panic`]: ../tokio/runtime/struct.Builder.html#method.unhandled_panic\"] # [doc = \" [unstable]: ../tokio/index.html#unstable-features\"] # [proc_macro_attribute] pub fn test (args : TokenStream , item : TokenStream) -> TokenStream { entry :: test (args . into () , item . into () , true) . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TryCurrentError",
                        "label": "TryCurrentError",
                        "kind": "Struct",
                        "signature": "struct TryCurrentError",
                        "file_path": "tokio/src/runtime/handle.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "can_drop_future_and_still_get_output",
                        "label": "can_drop_future_and_still_get_output",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Dropping the join handle still lets the task execute\"] # [test] fn can_drop_future_and_still_get_output () { let pool = task :: LocalPoolHandle :: new (1) ; let (sender , receiver) = std :: sync :: mpsc :: channel () ; pool . spawn_pinned (move | | { let local_data = Rc :: new (\"test\") ; async move { let _ = sender . send (local_data . to_string ()) ; } }) ; assert_eq ! (receiver . recv () , Ok (\"test\" . to_string ())) ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "all_spawns_are_local",
                        "label": "all_spawns_are_local",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn all_spawns_are_local () { use futures :: future ; thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let handles = (0 .. 128) . map (| _ | { task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) }) . collect :: < Vec < _ > > () ; for joined in future :: join_all (handles) . await { joined . unwrap () ; } }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_insert_panic_caller",
                        "label": "delay_queue_insert_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_insert_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: with_capacity (3)) ; let _k = queue . insert (\"1\" , Duration :: from_millis (MAX_DURATION_MS + 1)) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "next_many_not_enough",
                        "label": "next_many_not_enough",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn next_many_not_enough () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (iter ([0usize] . into_iter ())) as UsizeStream) ; stream_map . insert (1 , Box :: pin (iter ([1usize] . into_iter ())) as UsizeStream) ; let mut buffer = vec ! [] ; let n = poll_fn (| cx | pin ! (stream_map . next_many (& mut buffer , 3)) . poll (cx)) . await ; assert_eq ! (n , 2) ; assert_eq ! (buffer . len () , 2) ; assert ! (buffer . contains (& (0 , 0))) ; assert ! (buffer . contains (& (1 , 1))) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mpsc_bounded_receiver_blocking_recv_many_panic_caller",
                        "label": "mpsc_bounded_receiver_blocking_recv_many_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn mpsc_bounded_receiver_blocking_recv_many_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; let (_tx , mut rx) = mpsc :: channel :: < u8 > (1) ; rt . block_on (async { let _ = rx . blocking_recv () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reserve_many_on_closed_channel",
                        "label": "reserve_many_on_closed_channel",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn reserve_many_on_closed_channel () { let (tx , rx) = mpsc :: channel :: < () > (100) ; drop (rx) ; assert_err ! (tx . reserve_many (10) . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "make_fixed_size",
                        "label": "make_fixed_size",
                        "kind": "Function",
                        "signature": "fn fn make_fixed_size < T > (buffer : Box < [T] >) -> Box < [T ; LOCAL_QUEUE_CAPACITY] > { assert_eq ! (buffer . len () , LOCAL_QUEUE_CAPACITY) ; unsafe { Box :: from_raw (Box :: into_raw (buffer) . cast ()) } } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "runtime_without_io",
                        "label": "runtime_without_io",
                        "kind": "Function",
                        "signature": "fn fn runtime_without_io () -> Runtime { Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "func_err",
                        "label": "func_err",
                        "kind": "Function",
                        "signature": "fn async fn func_err () -> Result < u32 , () > { Err (()) } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "yield_now_outside_of_runtime",
                        "label": "yield_now_outside_of_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] fn yield_now_outside_of_runtime () { let mut task = spawn (async { task :: yield_now () . await ; }) ; assert ! (task . poll () . is_pending ()) ; assert ! (task . is_woken ()) ; assert ! (task . poll () . is_ready ()) ; } . sig",
                        "file_path": "tokio/tests/task_yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "short_sleeps",
                        "label": "short_sleeps",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn short_sleeps () { for _ in 0 .. 1000 { tokio :: time :: sleep (std :: time :: Duration :: from_millis (0)) . await ; } } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_tx_count_weak_unbounded_sender",
                        "label": "test_tx_count_weak_unbounded_sender",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_tx_count_weak_unbounded_sender () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let tx_weak = tx . downgrade () ; let tx_weak2 = tx . downgrade () ; drop (tx) ; assert ! (tx_weak . upgrade () . is_none () && tx_weak2 . upgrade () . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "builder_max_blocking_threads_panic_caller",
                        "label": "builder_max_blocking_threads_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn builder_max_blocking_threads_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . max_blocking_threads (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_named_pipe_client_drop",
                        "label": "test_named_pipe_client_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_named_pipe_client_drop () -> io :: Result < () > { const PIPE_NAME : & str = r\"\\\\.\\pipe\\test-named-pipe-client-drop\" ; let mut server = ServerOptions :: new () . create (PIPE_NAME) ? ; let client = ClientOptions :: new () . open (PIPE_NAME) ? ; server . connect () . await ? ; drop (client) ; match server . write_all (b\"ping\") . await { Err (e) if e . raw_os_error () == Some (ERROR_NO_DATA as i32) => () , x => panic ! (\"{:?}\" , x) , } Ok (()) } . sig",
                        "file_path": "tokio/tests/net_named_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv",
                        "label": "send_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_recv () { let (tx , rx) = oneshot :: channel () ; let mut rx = task :: spawn (rx) ; assert_pending ! (rx . poll ()) ; assert_ok ! (tx . send (1)) ; assert ! (rx . is_woken ()) ; let val = assert_ready_ok ! (rx . poll ()) ; assert_eq ! (val , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "respond",
                        "label": "respond",
                        "kind": "Function",
                        "signature": "fn async fn respond (req : Request < () >) -> Result < Response < String > , Box < dyn Error > > { let mut response = Response :: builder () ; let body = match req . uri () . path () { \"/plaintext\" => { response = response . header (\"Content-Type\" , \"text/plain\") ; \"Hello, World!\" . to_string () } \"/json\" => { response = response . header (\"Content-Type\" , \"application/json\") ; # [derive (Serialize)] struct Message { message : & 'static str , } serde_json :: to_string (& Message { message : \"Hello, World!\" , }) ? } _ => { response = response . status (StatusCode :: NOT_FOUND) ; String :: new () } } ; let response = response . body (body) . map_err (io :: Error :: other) ? ; Ok (response) } . sig",
                        "file_path": "examples/tinyhttp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "can_spawn_not_send_future",
                        "label": "can_spawn_not_send_future",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Simple test of running a !Send future via spawn_pinned\"] # [tokio :: test] async fn can_spawn_not_send_future () { let pool = task :: LocalPoolHandle :: new (1) ; let output = pool . spawn_pinned (| | { let local_data = Rc :: new (\"test\") ; async move { local_data . to_string () } }) . await . unwrap () ; assert_eq ! (output , \"test\") ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tempdir",
                        "label": "tempdir",
                        "kind": "Function",
                        "signature": "fn fn tempdir () -> tempfile :: TempDir { tempfile :: tempdir () . unwrap () } . sig",
                        "file_path": "tokio/tests/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "resubscribe_to_closed_channel",
                        "label": "resubscribe_to_closed_channel",
                        "kind": "Function",
                        "signature": "fn # [test] fn resubscribe_to_closed_channel () { let (tx , rx) = tokio :: sync :: broadcast :: channel :: < u32 > (2) ; drop (tx) ; let mut rx_resub = rx . resubscribe () ; assert_closed ! (rx_resub . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "readiness",
                        "label": "readiness",
                        "kind": "Function",
                        "signature": "fn # [test] fn readiness () { let l = Arc :: new (Mutex :: new (100)) ; let mut t1 = spawn (l . clone () . lock_owned ()) ; let mut t2 = spawn (l . lock_owned ()) ; let g = assert_ready ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; drop (g) ; assert ! (t2 . is_woken ()) ; assert_ready ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FastRand",
                        "label": "FastRand",
                        "kind": "Struct",
                        "signature": "struct FastRand",
                        "file_path": "tokio/src/util/rand.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Body",
                        "label": "Body",
                        "kind": "Struct",
                        "signature": "struct Body",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_stream_mock_empty",
                        "label": "test_stream_mock_empty",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_stream_mock_empty () { let mut stream_mock = StreamMockBuilder :: < u32 > :: new () . build () ; assert_eq ! (stream_mock . next () . await , None) ; assert_eq ! (stream_mock . next () . await , None) ; } . sig",
                        "file_path": "tokio-test/tests/stream_mock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_inserted_expired",
                        "label": "reset_inserted_expired",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_inserted_expired () { time :: pause () ; time :: sleep (ms (1000)) . await ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now - ms (100)) ; queue . reset_at (& key , now + ms (100)) ; assert_eq ! (1 , queue . len ()) ; sleep (ms (200)) . await ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; assert_eq ! (queue . len () , 0) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_rt_shutdown_err",
                        "label": "is_rt_shutdown_err",
                        "kind": "Function",
                        "signature": "fn # [allow (deprecated)] fn is_rt_shutdown_err (err : & io :: Error) -> bool { if let Some (inner) = err . get_ref () { err . kind () == io :: ErrorKind :: Other && inner . source () . is_none () && inner . description () == RUNTIME_SHUTTING_DOWN_ERROR } else { false } } . sig",
                        "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_large_slice_on_non_vectored",
                        "label": "write_vectored_large_slice_on_non_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_large_slice_on_non_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& []) , IoSlice :: new (& msg [.. 9]) , IoSlice :: new (& msg [9 ..]) ,] ; let mut h = VectoredWriteHarness :: new (8) ; let bytes_written = h . write_all (IoBufs :: new (& mut bufs)) . await ; assert_eq ! (bytes_written , msg . len ()) ; assert_eq ! (h . flush () . await , msg) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "take_value",
                        "label": "take_value",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn take_value () { tokio :: task_local ! { static KEY : u32 } let fut = KEY . scope (1 , async { }) ; let mut pinned = Box :: pin (fut) ; assert_eq ! (pinned . as_mut () . take_value () , Some (1)) ; assert_eq ! (pinned . as_mut () . take_value () , None) ; } . sig",
                        "file_path": "tokio/tests/task_local.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "initially_writable",
                        "label": "initially_writable",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn initially_writable () { let (a , b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let afd_b = AsyncFd :: new (b) . unwrap () ; afd_a . writable () . await . unwrap () . clear_ready () ; afd_b . writable () . await . unwrap () . clear_ready () ; tokio :: select ! { biased ; _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } , _ = afd_a . readable () => panic ! (\"Unexpected readable state\") , _ = afd_b . readable () => panic ! (\"Unexpected readable state\") , } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "busy_file_seek_error",
                        "label": "busy_file_seek_error",
                        "kind": "Function",
                        "signature": "fn # [test] fn busy_file_seek_error () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; let mut file = crate :: io :: BufReader :: new (File :: from_std (file)) ; { let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; } pool :: run_one () ; let mut t = task :: spawn (file . seek (SeekFrom :: Start (0))) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_token_cancelled_test",
                        "label": "pending_fut_with_token_cancelled_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_token_cancelled_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , None) ; assert_eq ! (wake_count , 1) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_empty_all_senders_are_dropped_and_messages_consumed",
                        "label": "test_rx_unbounded_is_empty_all_senders_are_dropped_and_messages_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_all_senders_are_dropped_and_messages_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; for _ in 0 .. 10 { assert ! (rx . recv () . await . is_some ()) ; } assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Http",
                        "label": "Http",
                        "kind": "Struct",
                        "signature": "struct Http",
                        "file_path": "examples/tinyhttp.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "clear_ready_matching_clears_ready_mut",
                        "label": "clear_ready_matching_clears_ready_mut",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn clear_ready_matching_clears_ready_mut () { use tokio :: io :: { Interest , Ready } ; let (a , mut b) = socketpair () ; let mut afd_a = AsyncFd :: new (a) . unwrap () ; b . write_all (b\"0\") . unwrap () ; let mut guard = afd_a . ready_mut (Interest :: READABLE | Interest :: WRITABLE) . await . unwrap () ; assert_eq ! (guard . ready () , Ready :: READABLE | Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: READABLE) ; assert_eq ! (guard . ready () , Ready :: WRITABLE) ; guard . clear_ready_matching (Ready :: WRITABLE) ; assert_eq ! (guard . ready () , Ready :: EMPTY) ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "peek",
                        "label": "peek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn peek () { let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now + ms (5)) ; let key2 = queue . insert_at (\"bar\" , now) ; let key3 = queue . insert_at (\"baz\" , now + ms (10)) ; assert_eq ! (queue . peek () , Some (key2)) ; sleep (ms (6)) . await ; assert_eq ! (queue . peek () , Some (key2)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"bar\") ; assert_eq ! (queue . peek () , Some (key)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"foo\") ; assert_eq ! (queue . peek () , Some (key3)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (5)) . await ; assert_eq ! (queue . peek () , Some (key3)) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (entry . get_ref () , & \"baz\") ; assert ! (queue . peek () . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AsyncBufRead",
                        "label": "AsyncBufRead",
                        "kind": "Trait",
                        "signature": "trait AsyncBufRead",
                        "file_path": "tokio/src/io/async_buf_read.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "Idle",
                        "label": "Idle",
                        "kind": "Struct",
                        "signature": "struct Idle",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/idle.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "no_branch_else_only",
                        "label": "no_branch_else_only",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn no_branch_else_only () { let foo = tokio :: select ! { else => 1 , } ; assert_eq ! (foo , 1) ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_runtime_panics_binding_net_tcp_listener",
                        "label": "no_runtime_panics_binding_net_tcp_listener",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg_attr (miri , ignore)] fn no_runtime_panics_binding_net_tcp_listener () { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") . expect (\"failed to bind listener\") ; let _ = TcpListener :: try_from (listener) ; } . sig",
                        "file_path": "tokio/tests/net_bind_resource.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_read",
                        "label": "basic_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ready_close_cancel_bounded",
                        "label": "ready_close_cancel_bounded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn ready_close_cancel_bounded () { let (tx , mut rx) = mpsc :: channel :: < () > (100) ; let _tx2 = tx . clone () ; let permit = assert_ok ! (tx . reserve () . await) ; rx . close () ; let mut recv = tokio_test :: task :: spawn (rx . recv ()) ; assert_pending ! (recv . poll ()) ; drop (permit) ; assert ! (recv . is_woken ()) ; let val = assert_ready ! (recv . poll ()) ; assert ! (val . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abstract_socket_name",
                        "label": "abstract_socket_name",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] async fn abstract_socket_name () { let socket_path = \"\\0aaa\" ; let listener = UnixListener :: bind (socket_path) . unwrap () ; let accept = listener . accept () ; let connect = UnixStream :: connect (& socket_path) ; let ((stream , _) , _) = try_join (accept , connect) . await . unwrap () ; let local_addr = stream . into_std () . unwrap () . local_addr () . unwrap () ; let abstract_path_name = local_addr . as_abstract_name () . unwrap () ; assert_eq ! (abstract_path_name , b\"aaa\") ; } . sig",
                        "file_path": "tokio/tests/uds_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_max_buf_size_read",
                        "label": "set_max_buf_size_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn set_max_buf_size_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; let mut buf = [0 ; 1024] ; file . set_max_buf_size (1) ; assert_eq ! (file . read (& mut buf) . await . unwrap () , 1) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored",
                        "label": "write_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored () { let (mut client , mut server) = tokio :: io :: duplex (64) ; let ret = client . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; client . flush () . await . unwrap () ; drop (client) ; let mut buf = Vec :: with_capacity (HELLO . len () * 2) ; let bytes_read = server . read_to_end (& mut buf) . await . unwrap () ; assert_eq ! (bytes_read , HELLO . len () * 2) ; assert_eq ! (buf , [HELLO , HELLO] . concat ()) ; } . sig",
                        "file_path": "tokio/tests/duplex_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_bidirectional_is_cooperative",
                        "label": "copy_bidirectional_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn copy_bidirectional_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let payload = b\"here, take this\" ; let mut a = tokio_test :: io :: Builder :: new () . read (payload) . write (payload) . build () ; let mut b = tokio_test :: io :: Builder :: new () . read (payload) . write (payload) . build () ; let _ = copy_bidirectional (& mut a , & mut b) . await ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "IntervalStream",
                        "label": "IntervalStream",
                        "kind": "Struct",
                        "signature": "struct IntervalStream",
                        "file_path": "tokio-stream/src/wrappers/interval.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "is_debug",
                        "label": "is_debug",
                        "kind": "Function",
                        "signature": "fn fn is_debug < T : fmt :: Debug > (_ : & T) { } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_by_idx",
                        "label": "spawn_by_idx",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn spawn_by_idx () { let pool = task :: LocalPoolHandle :: new (3) ; let barrier = Arc :: new (Barrier :: new (4)) ; let barrier1 = barrier . clone () ; let barrier2 = barrier . clone () ; let barrier3 = barrier . clone () ; let handle1 = pool . spawn_pinned_by_idx (| | async move { barrier1 . wait () . await ; std :: thread :: current () . id () } , 0 ,) ; pool . spawn_pinned_by_idx (| | async move { barrier2 . wait () . await ; std :: thread :: current () . id () } , 0 ,) ; let handle2 = pool . spawn_pinned_by_idx (| | async move { barrier3 . wait () . await ; std :: thread :: current () . id () } , 1 ,) ; let loads = pool . get_task_loads_for_each_worker () ; barrier . wait () . await ; assert_eq ! (loads [0] , 2) ; assert_eq ! (loads [1] , 1) ; assert_eq ! (loads [2] , 0) ; let thread_id1 = handle1 . await . unwrap () ; let thread_id2 = handle2 . await . unwrap () ; assert_ne ! (thread_id1 , thread_id2) ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Medium",
                        "label": "Medium",
                        "kind": "Struct",
                        "signature": "struct Medium",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_try_join_next",
                        "label": "test_join_queue_try_join_next",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next () { let mut queue = JoinQueue :: new () ; let (tx1 , rx1) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx1 . await ; }) ; let (tx2 , rx2) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx2 . await ; }) ; let (tx3 , rx3) = oneshot :: channel :: < () > () ; queue . spawn (async { let _ = rx3 . await ; }) ; fn check_try_join_next_is_noop (queue : & mut JoinQueue < () >) { let len = queue . len () ; for _ in 0 .. 5 { assert ! (queue . try_join_next () . is_none ()) ; assert_eq ! (queue . len () , len) ; } } assert_eq ! (queue . len () , 3) ; check_try_join_next_is_noop (& mut queue) ; tx1 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 3) ; assert ! (queue . try_join_next () . is_some ()) ; assert_eq ! (queue . len () , 2) ; check_try_join_next_is_noop (& mut queue) ; tx3 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 2) ; check_try_join_next_is_noop (& mut queue) ; tx2 . send (()) . unwrap () ; tokio :: task :: yield_now () . await ; assert_eq ! (queue . len () , 2) ; assert ! (queue . try_join_next () . is_some ()) ; assert_eq ! (queue . len () , 1) ; assert ! (queue . try_join_next () . is_some ()) ; assert ! (queue . is_empty ()) ; check_try_join_next_is_noop (& mut queue) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_notify_one_after_enable",
                        "label": "test_notify_one_after_enable",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_notify_one_after_enable () { let notify = Notify :: new () ; let mut future = spawn (notify . notified ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; notify . notify_one () ; assert_ready ! (future . poll ()) ; future . enter (| _ , fut | assert ! (fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_key_get_panic_caller",
                        "label": "local_key_get_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_key_get_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . get () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_after_firing",
                        "label": "reset_after_firing",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_after_firing () { let timer = tokio :: time :: sleep (std :: time :: Duration :: from_millis (1)) ; tokio :: pin ! (timer) ; let deadline = timer . deadline () ; timer . as_mut () . await ; assert_ready ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; timer . as_mut () . reset (tokio :: time :: Instant :: now () + std :: time :: Duration :: from_secs (600)) ; assert_ne ! (deadline , timer . deadline ()) ; assert_pending ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; assert_pending ! (timer . as_mut () . poll (& mut Context :: from_waker (noop_waker_ref ()))) ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_with_child",
                        "label": "cancel_with_child",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_with_child () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let token2 = token . clone () ; let child_token = token . child_token () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { block_on (async { child_token . cancelled () . await ; }) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "server_options_max_instances_panic_caller",
                        "label": "server_options_max_instances_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (windows)] fn server_options_max_instances_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: windows :: named_pipe :: ServerOptions ; let panic_location_file = test_panic (move | | { let rt = runtime_without_io () ; rt . block_on (async { let mut options = ServerOptions :: new () ; options . max_instances (255) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "max_allowed_length_field",
                        "label": "max_allowed_length_field",
                        "kind": "Function",
                        "signature": "fn # [test] fn max_allowed_length_field () { let codec = LengthDelimitedCodec :: builder () . length_field_length (8) . max_frame_length (usize :: MAX) . new_codec () ; assert_eq ! (codec . max_frame_length () , usize :: MAX) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "dropping_signal_does_not_deregister_any_other_instances",
                        "label": "dropping_signal_does_not_deregister_any_other_instances",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn dropping_signal_does_not_deregister_any_other_instances () { let kind = SignalKind :: user_defined1 () ; let first_duplicate_signal = signal (kind) . expect (\"failed to register first duplicate signal\") ; let mut sig = signal (kind) . expect (\"failed to register signal\") ; let second_duplicate_signal = signal (kind) . expect (\"failed to register second duplicate signal\") ; drop (first_duplicate_signal) ; drop (second_duplicate_signal) ; send_signal (libc :: SIGUSR1) ; let _ = sig . recv () . await ; } . sig",
                        "file_path": "tokio/tests/signal_drop_signal.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_buf",
                        "label": "try_recv_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_recv_buf () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; client . connect (server . local_addr () . unwrap ()) . await . unwrap () ; server . connect (client . local_addr () . unwrap ()) . await . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send (b\"hello world\") { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf (& mut buf) { Ok (n) => { assert_eq ! (n , 11) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_token_owned",
                        "label": "cancel_token_owned",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_token_owned () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled_owned () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_slow_rx",
                        "label": "send_slow_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_slow_rx () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; { let mut recv2 = task :: spawn (rx2 . recv ()) ; { let mut recv1 = task :: spawn (rx1 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_pending ! (recv2 . poll ()) ; assert_ok ! (tx . send (\"one\")) ; assert ! (recv1 . is_woken ()) ; assert ! (recv2 . is_woken ()) ; assert_ok ! (tx . send (\"two\")) ; let val = assert_ready_ok ! (recv1 . poll ()) ; assert_eq ! (val , \"one\") ; } let val = assert_ready_ok ! (task :: spawn (rx1 . recv ()) . poll ()) ; assert_eq ! (val , \"two\") ; let mut recv1 = task :: spawn (rx1 . recv ()) ; assert_pending ! (recv1 . poll ()) ; assert_ok ! (tx . send (\"three\")) ; assert ! (recv1 . is_woken ()) ; let val = assert_ready_ok ! (recv1 . poll ()) ; assert_eq ! (val , \"three\") ; let val = assert_ready_ok ! (recv2 . poll ()) ; assert_eq ! (val , \"one\") ; } let val = assert_recv ! (rx2) ; assert_eq ! (val , \"two\") ; let val = assert_recv ! (rx2) ; assert_eq ! (val , \"three\") ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Large",
                        "label": "Large",
                        "kind": "Struct",
                        "signature": "struct Large",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "single_rt",
                        "label": "single_rt",
                        "kind": "Function",
                        "signature": "fn fn single_rt () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "benches/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_later_after_slot_starts",
                        "label": "reset_later_after_slot_starts",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_later_after_slot_starts () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let foo = queue . insert_at (\"foo\" , now + ms (100)) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (80)) . await ; assert ! (! queue . is_woken ()) ; queue . reset_at (& foo , now + ms (120)) ; assert ! (queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep_until (now + Duration :: from_millis (119)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (1)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire_many",
                        "label": "try_acquire_many",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire_many () { let sem = Arc :: new (Semaphore :: new (42)) ; { let p1 = sem . clone () . try_acquire_many_owned (42) ; assert ! (p1 . is_ok ()) ; let p2 = sem . clone () . try_acquire_owned () ; assert ! (p2 . is_err ()) ; } let p3 = sem . clone () . try_acquire_many_owned (32) ; assert ! (p3 . is_ok ()) ; let p4 = sem . clone () . try_acquire_many_owned (10) ; assert ! (p4 . is_ok ()) ; assert ! (sem . try_acquire_owned () . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "parse_knobs",
                        "label": "parse_knobs",
                        "kind": "Function",
                        "signature": "fn fn parse_knobs (mut input : ItemFn , is_test : bool , config : FinalConfig) -> TokenStream { input . sig . asyncness = None ; let (last_stmt_start_span , last_stmt_end_span) = { let mut last_stmt = input . stmts . last () . cloned () . unwrap_or_default () . into_iter () ; let start = last_stmt . next () . map_or_else (Span :: call_site , | t | t . span ()) ; let end = last_stmt . last () . map_or (start , | t | t . span ()) ; (start , end) } ; let crate_path = config . crate_name . map (ToTokens :: into_token_stream) . unwrap_or_else (| | Ident :: new (\"tokio\" , last_stmt_start_span) . into_token_stream ()) ; let mut rt = match config . flavor { RuntimeFlavor :: CurrentThread | RuntimeFlavor :: Local => { quote_spanned ! { last_stmt_start_span => # crate_path :: runtime :: Builder :: new_current_thread () } } RuntimeFlavor :: Threaded => quote_spanned ! { last_stmt_start_span => # crate_path :: runtime :: Builder :: new_multi_thread () } , } ; let mut checks = vec ! [] ; let mut errors = vec ! [] ; let build = if let RuntimeFlavor :: Local = config . flavor { checks . push (quote ! { tokio_unstable }) ; errors . push (\"The local runtime flavor is only available when `tokio_unstable` is set.\") ; quote_spanned ! { last_stmt_start_span => build_local (Default :: default ()) } } else { quote_spanned ! { last_stmt_start_span => build () } } ; if let Some (v) = config . worker_threads { rt = quote_spanned ! { last_stmt_start_span => # rt . worker_threads (# v) } ; } if let Some (v) = config . start_paused { rt = quote_spanned ! { last_stmt_start_span => # rt . start_paused (# v) } ; } if let Some (v) = config . unhandled_panic { let unhandled_panic = v . into_tokens (& crate_path) ; rt = quote_spanned ! { last_stmt_start_span => # rt . unhandled_panic (# unhandled_panic) } ; } let generated_attrs = if is_test { quote ! { # [:: core :: prelude :: v1 :: test] } } else { quote ! { } } ; let do_checks : TokenStream = checks . iter () . zip (& errors) . map (| (check , error) | { quote ! { # [cfg (not (# check))] compile_error ! (# error) ; } }) . collect () ; let body_ident = quote ! { body } ; let last_block = quote_spanned ! { last_stmt_end_span => # do_checks # [cfg (all (# (# checks) ,*))] # [allow (clippy :: expect_used , clippy :: diverging_sub_expression , clippy :: needless_return , clippy :: unwrap_in_result)] { return # rt . enable_all () .# build . expect (\"Failed building the Runtime\") . block_on (# body_ident) ; } # [cfg (not (all (# (# checks) ,*)))] { panic ! (\"fell through checks\") } } ; let body = input . body () ; let body = if is_test { let output_type = match & input . sig . output { syn :: ReturnType :: Default => quote ! { () } , syn :: ReturnType :: Type (_ , ret_type) => quote ! { # ret_type } , } ; quote ! { let body = async # body ; # crate_path :: pin ! (body) ; let body : :: core :: pin :: Pin <& mut dyn :: core :: future :: Future < Output = # output_type >> = body ; } } else { quote ! { let body = async # body ; } } ; input . into_tokens (generated_attrs , body , last_block) } . sig",
                        "file_path": "tokio-macros/src/entry.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_overflow",
                        "label": "size_overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_overflow () { struct Monster ; impl tokio_stream :: Stream for Monster { type Item = () ; fn poll_next (self : std :: pin :: Pin < & mut Self > , _cx : & mut std :: task :: Context < '_ > ,) -> std :: task :: Poll < Option < () > > { panic ! () } fn size_hint (& self) -> (usize , Option < usize >) { (usize :: MAX , Some (usize :: MAX)) } } let m1 = Monster ; let m2 = Monster ; let m = m1 . merge (m2) ; assert_eq ! (m . size_hint () , (usize :: MAX , None)) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_merge.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_with_open_options_and_read",
                        "label": "open_with_open_options_and_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn open_with_open_options_and_read () { let mut tempfile = NamedTempFile :: new () . unwrap () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = OpenOptions :: new () . read (true) . open (tempfile) . await . unwrap () ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_windows_access_mode",
                        "label": "open_options_windows_access_mode",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_access_mode () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . access_mode (0)) . contains (\"access_mode: Some(0)\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_enter_context",
                        "label": "current_enter_context",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns true if in a runtime context.\"] pub (crate) fn current_enter_context () -> EnterRuntime { CONTEXT . with (| c | c . runtime . get ()) } . sig",
                        "file_path": "tokio/src/runtime/context/runtime_mt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ShardedList",
                        "label": "ShardedList",
                        "kind": "Struct",
                        "signature": "struct ShardedList",
                        "file_path": "tokio/src/util/sharded_list.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "delay_queue_reserve_panic_caller",
                        "label": "delay_queue_reserve_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn delay_queue_reserve_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = basic () ; rt . block_on (async { let mut queue = task :: spawn (DelayQueue :: < u32 > :: with_capacity (3)) ; queue . reserve ((1 << 30) as usize) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf_initialize_unfilled_to_panic_caller",
                        "label": "read_buf_initialize_unfilled_to_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_buf_initialize_unfilled_to_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let mut buffer = Vec :: < u8 > :: new () ; let mut read_buf = ReadBuf :: new (& mut buffer) ; read_buf . initialize_unfilled_to (2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/io_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_much_later",
                        "label": "reset_much_later",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_much_later () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; sleep (ms (1)) . await ; let key = queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; queue . reset_at (& key , now + ms (10)) ; sleep (ms (20)) . await ; assert ! (queue . is_woken ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn fn main () { let (tx , rx) = oneshot :: channel () ; my_custom_runtime :: spawn (async move { let listener = TcpListener :: bind (\"0.0.0.0:0\") . await . unwrap () ; println ! (\"addr: {:?}\" , listener . local_addr ()) ; tx . send (()) . unwrap () ; }) ; futures :: executor :: block_on (rx) . unwrap () ; } . sig",
                        "file_path": "examples/custom-executor.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_read_write_err",
                        "label": "write_read_write_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_read_write_err () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . returning (| _ | Err (io :: ErrorKind :: Other . into ())) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_err ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "check_socket_for_blocking",
                        "label": "check_socket_for_blocking",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (unix))] # [allow (unused_variables)] pub (crate) fn check_socket_for_blocking < S > (s : & S) -> crate :: io :: Result < () > { Ok (()) } . sig",
                        "file_path": "tokio/src/util/blocking_check.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "aborted_future_2",
                        "label": "aborted_future_2",
                        "kind": "Function",
                        "signature": "fn # [doc = \" This test is similar to `aborted_future_1` but this time the\"] # [doc = \" aborted future is waiting for the lock.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_2 () { use std :: time :: Duration ; use tokio :: time :: timeout ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let _lock = m1 . clone () . lock_owned () . await ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { m2 . lock_owned () . await ; }) . await . unwrap_err () ; } } timeout (Duration :: from_millis (1u64) , async move { m1 . lock_owned () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
                        "file_path": "tokio/tests/sync_mutex_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reserve_many_and_send",
                        "label": "reserve_many_and_send",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn reserve_many_and_send () { let (tx , mut rx) = mpsc :: channel (100) ; for i in 0 .. 100 { for permit in assert_ok ! (tx . reserve_many (i) . await) { permit . send (\"foo\") ; assert_eq ! (rx . recv () . await , Some (\"foo\")) ; } assert_eq ! (rx . try_recv () , Err (TryRecvError :: Empty)) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "weak_sender",
                        "label": "weak_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn weak_sender () { let (tx , mut rx) = channel (11) ; let tx_weak = tokio :: spawn (async move { let tx_weak = tx . clone () . downgrade () ; for i in 0 .. 10 { if tx . send (i) . await . is_err () { return None ; } } let tx2 = tx_weak . upgrade () . expect (\"expected to be able to upgrade tx_weak\") ; let _ = tx2 . send (20) . await ; let tx_weak = tx2 . downgrade () ; Some (tx_weak) }) . await . unwrap () ; for i in 0 .. 12 { let recvd = rx . recv () . await ; match recvd { Some (msg) => { if i == 10 { assert_eq ! (msg , 20) ; } } None => { assert_eq ! (i , 11) ; break ; } } } let tx_weak = tx_weak . unwrap () ; let upgraded = tx_weak . upgrade () ; assert ! (upgraded . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "threaded_scheduler_spawn",
                        "label": "threaded_scheduler_spawn",
                        "kind": "Function",
                        "signature": "fn fn threaded_scheduler_spawn (c : & mut Criterion) { let runtime = multi_rt () ; c . bench_function (\"threaded_scheduler_spawn\" , | b | { b . iter (| | { runtime . block_on (async { let h = tokio :: spawn (work ()) ; assert_eq ! (h . await . unwrap () , 2) ; }) ; }) }) ; } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AtomicU16",
                        "label": "AtomicU16",
                        "kind": "Struct",
                        "signature": "struct AtomicU16",
                        "file_path": "tokio/src/loom/std/atomic_u16.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "notify_simple",
                        "label": "notify_simple",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_simple () { let notify = Notify :: new () ; let mut fut1 = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut1 . poll () . is_pending ()) ; let mut fut2 = tokio_test :: task :: spawn (notify . notified ()) ; assert ! (fut2 . poll () . is_pending ()) ; notify . notify_waiters () ; assert ! (fut1 . poll () . is_ready ()) ; assert ! (fut2 . poll () . is_ready ()) ; } . sig",
                        "file_path": "tokio/src/sync/tests/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_buffered_reader_seek",
                        "label": "test_buffered_reader_seek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_buffered_reader_seek () { let inner : & [u8] = & [5 , 6 , 7 , 0 , 1 , 2 , 3 , 4] ; let mut reader = BufReader :: with_capacity (2 , Cursor :: new (inner)) ; assert_eq ! (reader . seek (SeekFrom :: Start (3)) . await . unwrap () , 3) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert ! (reader . seek (SeekFrom :: Current (i64 :: MIN)) . await . is_err ()) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [0 , 1] [..]) ; assert_eq ! (reader . seek (SeekFrom :: Current (1)) . await . unwrap () , 4) ; assert_eq ! (run_fill_buf ! (reader) . unwrap () , & [1 , 2] [..]) ; Pin :: new (& mut reader) . consume (1) ; assert_eq ! (reader . seek (SeekFrom :: Current (- 2)) . await . unwrap () , 3) ; } . sig",
                        "file_path": "tokio/tests/io_buf_reader.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> Runtime { runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "benches/rt_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_strong_count_when_cloned",
                        "label": "sender_strong_count_when_cloned",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_strong_count_when_cloned () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let tx2 = tx . clone () ; assert_eq ! (tx . strong_count () , 2) ; assert_eq ! (tx2 . strong_count () , 2) ; assert_eq ! (rx . sender_strong_count () , 2) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_with_buffer_larger_than_max",
                        "label": "read_with_buffer_larger_than_max",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn read_with_buffer_larger_than_max () { let chunk_a = crate :: io :: blocking :: DEFAULT_MAX_BUF_SIZE ; let chunk_b = chunk_a * 2 ; let chunk_c = chunk_a * 3 ; let chunk_d = chunk_a * 4 ; assert_eq ! (chunk_d / 1024 / 1024 , 8) ; let mut data = vec ! [] ; for i in 0 .. (chunk_d - 1) { data . push ((i % 151) as u8) ; } let data = Arc :: new (data) ; let d0 = data . clone () ; let d1 = data . clone () ; let d2 = data . clone () ; let d3 = data . clone () ; let mut seq = Sequence :: new () ; let mut file = MockFile :: default () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [0 .. chunk_a] . copy_from_slice (& d0 [0 .. chunk_a]) ; Ok (chunk_a) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a] . copy_from_slice (& d1 [chunk_a .. chunk_b]) ; Ok (chunk_b - chunk_a) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a] . copy_from_slice (& d2 [chunk_b .. chunk_c]) ; Ok (chunk_c - chunk_b) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (move | buf | { buf [.. chunk_a - 1] . copy_from_slice (& d3 [chunk_c ..]) ; Ok (chunk_a - 1) }) ; let mut file = File :: from_std (file) ; let mut actual = vec ! [0 ; chunk_d] ; let mut pos = 0 ; while pos < data . len () { let mut t = task :: spawn (file . read (& mut actual [pos ..])) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert ! (n <= chunk_a) ; pos += n ; } assert_eq ! (& data [..] , & actual [.. data . len ()]) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_builder_name_recorded",
                        "label": "task_builder_name_recorded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn task_builder_name_recorded () { let task_span = expect_task_named (\"test-task\") ; let (subscriber , handle) = subscriber :: mock () . new_span (task_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; task :: Builder :: new () . name (\"test-task\") . spawn (futures :: future :: ready (())) . unwrap () . await . expect (\"failed to await join handle\") ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rwlock_blocking_read_panic_caller",
                        "label": "rwlock_blocking_read_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn rwlock_blocking_read_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let rt = current_thread () ; rt . block_on (async { let lock = RwLock :: < u8 > :: new (0) ; let _ = lock . blocking_read () ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write",
                        "label": "write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write () { let dir = tempdir () . unwrap () ; let path = dir . path () . join (\"test.txt\") ; fs :: write (& path , \"Hello, World!\") . await . unwrap () ; let contents = fs :: read_to_string (& path) . await . unwrap () ; assert_eq ! (contents , \"Hello, World!\") ; } . sig",
                        "file_path": "tokio/tests/fs_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "guard_try_io",
                        "label": "guard_try_io",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn guard_try_io () { let (a , mut b) = socketpair () ; b . write_all (b\"0\") . unwrap () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let mut guard = afd_a . readable () . await . unwrap () ; afd_a . get_ref () . read_exact (& mut [0]) . unwrap () ; let _ = guard . try_io (| _ | Ok (())) ; let _ = afd_a . readable () . await . unwrap () ; let _ = guard . try_io (| _ | io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ())) ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; let _ = readable . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_sender_closed",
                        "label": "broadcast_sender_closed",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_sender_closed () { let (tx , rx) = broadcast :: channel :: < () > (1) ; let rx2 = tx . subscribe () ; let mut task = task :: spawn (tx . closed ()) ; assert_pending ! (task . poll ()) ; drop (rx) ; assert ! (! task . is_woken ()) ; assert_pending ! (task . poll ()) ; drop (rx2) ; assert ! (task . is_woken ()) ; assert_ready ! (task . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BlockingSchedule",
                        "label": "BlockingSchedule",
                        "kind": "Struct",
                        "signature": "struct BlockingSchedule",
                        "file_path": "tokio/src/runtime/blocking/schedule.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RW",
                        "label": "RW",
                        "kind": "Struct",
                        "signature": "struct RW",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end",
                        "label": "read_to_end",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn read_to_end < 'a , R > (reader : & 'a mut R , buffer : & 'a mut Vec < u8 >) -> ReadToEnd < 'a , R > where R : AsyncRead + Unpin + ? Sized , { ReadToEnd { reader , buf : VecWithInitialized :: new (buffer) , read : 0 , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_acquire_many_available",
                        "label": "poll_acquire_many_available",
                        "kind": "Function",
                        "signature": "fn # [test] fn poll_acquire_many_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ready_ok ! (task :: spawn (s . acquire (5)) . poll ()) ; assert_eq ! (s . available_permits () , 95) ; assert_ready_ok ! (task :: spawn (s . acquire (5)) . poll ()) ; assert_eq ! (s . available_permits () , 90) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_overflow_count",
                        "label": "worker_overflow_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_overflow_count () { let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { tokio :: spawn (async { let (tx1 , rx1) = std :: sync :: mpsc :: channel () ; let (tx2 , rx2) = std :: sync :: mpsc :: channel () ; tokio :: task :: spawn_blocking (| | { tokio :: spawn (async move { tx1 . send (()) . unwrap () ; rx2 . recv () . unwrap () ; }) ; }) ; rx1 . recv () . unwrap () ; for _ in 0 .. 300 { tokio :: spawn (async { }) ; } tx2 . send (()) . unwrap () ; }) . await . unwrap () ; }) ; drop (rt) ; let n : u64 = (0 .. metrics . num_workers ()) . map (| i | metrics . worker_overflow_count (i)) . sum () ; assert_eq ! (1 , n) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_try_recv_bounded",
                        "label": "send_try_recv_bounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_try_recv_bounded () { let (tx , mut rx) = broadcast :: channel (16) ; assert_empty ! (rx) ; let n = assert_ok ! (tx . send (\"hello\")) ; assert_eq ! (n , 1) ; let val = assert_recv ! (rx) ; assert_eq ! (val , \"hello\") ; assert_empty ! (rx) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_key_sync_scope_panic_caller",
                        "label": "local_key_sync_scope_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_key_sync_scope_panic_caller () -> Result < () , Box < dyn Error > > { tokio :: task_local ! { static NUMBER : u32 ; } let panic_location_file = test_panic (| | { NUMBER . sync_scope (1 , | | { NUMBER . with (| _ | { NUMBER . sync_scope (1 , | | { }) ; }) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "insert_remove",
                        "label": "insert_remove",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn insert_remove () { let mut map = task :: spawn (StreamMap :: new ()) ; let (tx , rx) = mpsc :: unbounded_channel_stream () ; let rx = Box :: pin (rx) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"foo\" , rx) . is_none ()) ; let rx = map . remove (\"foo\") . unwrap () ; assert_ok ! (tx . send (1)) ; assert ! (! map . is_woken ()) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . insert (\"bar\" , rx) . is_none ()) ; let v = assert_ready_some ! (map . poll_next ()) ; assert_eq ! (v . 0 , \"bar\") ; assert_eq ! (v . 1 , 1) ; assert ! (map . remove (\"bar\") . is_some ()) ; assert_ready_none ! (map . poll_next ()) ; assert ! (map . is_empty ()) ; assert_eq ! (0 , map . len ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_current_thread_scheduler",
                        "label": "local_current_thread_scheduler",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn local_current_thread_scheduler () { LocalSet :: new () . run_until (async { task :: spawn_local (async { }) . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_child",
                        "label": "remove_child",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Removes a child from the parent.\"] # [doc = \"\"] # [doc = \" `parent` MUST be the parent of `node`.\"] # [doc = \" To acquire the locks for node and parent, use [`with_locked_node_and_parent`].\"] fn remove_child (parent : & mut Inner , mut node : MutexGuard < '_ , Inner >) { let pos = node . parent_idx ; node . parent = None ; node . parent_idx = 0 ; drop (node) ; if parent . children . len () == pos + 1 { parent . children . pop () . unwrap () ; } else { let replacement_child = parent . children . pop () . unwrap () ; replacement_child . inner . lock () . unwrap () . parent_idx = pos ; parent . children [pos] = replacement_child ; } let len = parent . children . len () ; if 4 * len <= parent . children . capacity () { parent . children . shrink_to (2 * len) ; } } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_fut_with_cancellation_token_test",
                        "label": "pending_fut_with_cancellation_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_fut_with_cancellation_token_test () { let (waker , _) = new_count_waker () ; let token = CancellationToken :: new () ; let pending_fut = pending :: < () > () ; let pending_with_token_fut = pending_fut . with_cancellation_token (& token) ; pin ! (pending_with_token_fut) ; let res = pending_with_token_fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OsStorage",
                        "label": "OsStorage",
                        "kind": "Struct",
                        "signature": "struct OsStorage",
                        "file_path": "tokio/src/signal/windows/sys.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "closing_unbounded_tx",
                        "label": "closing_unbounded_tx",
                        "kind": "Function",
                        "signature": "fn # [test] fn closing_unbounded_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: unbounded_channel () ; thread :: spawn (move | | { tx . send (()) . unwrap () ; drop (tx) ; }) ; let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_stream_unbounded",
                        "label": "send_recv_stream_unbounded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (all (feature = \"full\" , not (target_os = \"wasi\")))] async fn send_recv_stream_unbounded () { use tokio_stream :: StreamExt ; let (tx , rx) = support :: mpsc_stream :: unbounded_channel_stream :: < i32 > () ; let mut rx = Box :: pin (rx) ; tokio :: spawn (async move { assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; }) ; assert_eq ! (Some (1) , rx . next () . await) ; assert_eq ! (Some (2) , rx . next () . await) ; assert_eq ! (None , rx . next () . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_by_val",
                        "label": "wake_by_val",
                        "kind": "Function",
                        "signature": "fn unsafe fn wake_by_val (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.wake\") ; let raw = RawTask :: from_raw (ptr) ; raw . wake_by_val () ; } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ok",
                        "label": "ok",
                        "kind": "Function",
                        "signature": "fn fn ok < T > (val : T) -> Result < T , () > { Ok (val) } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire_many_unavailable",
                        "label": "try_acquire_many_unavailable",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire_many_unavailable () { let s = Semaphore :: new (5) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 4) ; assert_err ! (s . try_acquire (5)) ; s . release (1) ; assert_eq ! (s . available_permits () , 5) ; assert_ok ! (s . try_acquire (5)) ; s . release (1) ; assert_eq ! (s . available_permits () , 1) ; s . release (1) ; assert_eq ! (s . available_permits () , 2) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "process_spawned_outside_runtime",
                        "label": "process_spawned_outside_runtime",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic (expected = \"there is no reactor running, must be called from the context of a Tokio 1.x runtime\")] fn process_spawned_outside_runtime () { let _ = Command :: new (\"true\") . stdin (Stdio :: piped ()) . stdout (Stdio :: null ()) . spawn () ; } . sig",
                        "file_path": "tokio/tests/process_change_of_runtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_into_inner_new_with",
                        "label": "drop_into_inner_new_with",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_into_inner_new_with () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; let fooer = Foo :: from (num_drops . clone ()) ; let once_cell = OnceCell :: new_with (Some (fooer)) ; let fooer = once_cell . into_inner () ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 0) ; mem :: drop (fooer) ; let count = num_drops . load (Ordering :: Acquire) ; assert ! (count == 1) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_instantly_closed",
                        "label": "size_hint_stream_instantly_closed",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_hint_stream_instantly_closed () { let (_tx , rx) = mpsc :: channel :: < i32 > (4) ; let mut stream = ReceiverStream :: new (rx) ; stream . close () ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn main () -> Result < () , Box < dyn Error > > { let addr = env :: args () . nth (1) . unwrap_or_else (| | \"127.0.0.1:8080\" . to_string ()) ; let listener = TcpListener :: bind (& addr) . await ? ; println ! (\"Listening on: {addr}\") ; let mut initial_db = HashMap :: new () ; initial_db . insert (\"foo\" . to_string () , \"bar\" . to_string ()) ; let db = Arc :: new (Database { map : Mutex :: new (initial_db) , }) ; loop { match listener . accept () . await { Ok ((socket , _)) => { let db = db . clone () ; tokio :: spawn (async move { let mut lines = Framed :: new (socket , LinesCodec :: new ()) ; while let Some (result) = lines . next () . await { match result { Ok (line) => { let response = handle_request (& line , & db) ; let response = response . serialize () ; if let Err (e) = lines . send (response . as_str ()) . await { println ! (\"error on sending response; error = {e:?}\") ; } } Err (e) => { println ! (\"error on decoding from socket; error = {e:?}\") ; } } } }) ; } Err (e) => println ! (\"error accepting socket; error = {e:?}\") , } } } . sig",
                        "file_path": "examples/tinydb.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored",
                        "label": "write_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; let ret = file . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; file . flush () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , [HELLO , HELLO] . concat ()) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "steal_overflow",
                        "label": "steal_overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn steal_overflow () { loom :: model (| | { let (steal , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; let th = thread :: spawn (move | | { let mut stats = new_stats () ; let (_ , mut local) = queue :: local () ; let mut n = 0 ; if steal . steal_into (& mut local , & mut stats) . is_some () { n += 1 ; } while local . pop () . is_some () { n += 1 ; } n }) ; let mut n = 0 ; let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; if local . pop () . is_some () { n += 1 ; } for _ in 0 .. 6 { let (task , _) = unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } n += th . join () . unwrap () ; while local . pop () . is_some () { n += 1 ; } n += inject . borrow_mut () . drain (..) . count () ; assert_eq ! (7 , n) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Mock",
                        "label": "Mock",
                        "kind": "Struct",
                        "signature": "struct Mock",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "abort_all",
                        "label": "abort_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_all () { let mut map : JoinMap < usize , () > = JoinMap :: new () ; for i in 0 .. 5 { map . spawn (i , futures :: future :: pending ()) ; } for i in 5 .. 10 { map . spawn (i , async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; map . abort_all () ; assert_eq ! (map . len () , 10) ; let mut count = 0 ; let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; if let Err (err) = res { assert ! (err . is_cancelled ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert_eq ! (map . len () , 0) ; for was_seen in & seen { assert ! (was_seen) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Receiver",
                        "label": "Receiver",
                        "kind": "Struct",
                        "signature": "struct Receiver",
                        "file_path": "tokio/src/sync/oneshot.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "status_closes_any_pipes",
                        "label": "status_closes_any_pipes",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn status_closes_any_pipes () { let child = cat () . status () ; assert_ok ! (child . await) ; } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "broadcast_channel_panic_caller",
                        "label": "broadcast_channel_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn broadcast_channel_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let (_ , _) = broadcast :: channel :: < u32 > (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "caller_names_const_count",
                        "label": "caller_names_const_count",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn caller_names_const_count () { let (tx , rx) = oneshot :: channel :: < u32 > () ; const COUNT : u32 = 2 ; let mut join = task :: spawn (async { tokio :: join ! (async { tx . send (COUNT) . unwrap () }) }) ; assert_ready ! (join . poll ()) ; let res = rx . await . unwrap () ; assert_eq ! (2 , res) ; } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_permit_iterator_releases_permits",
                        "label": "drop_permit_iterator_releases_permits",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn drop_permit_iterator_releases_permits () { for n in 1 .. 100 { let (tx1 , _rx) = mpsc :: channel :: < i32 > (n) ; let tx2 = tx1 . clone () ; let permits = assert_ok ! (tx1 . reserve_many (n) . await) ; let mut reserve2 = tokio_test :: task :: spawn (tx2 . reserve_many (n)) ; assert_pending ! (reserve2 . poll ()) ; drop (permits) ; assert ! (reserve2 . is_woken ()) ; let permits = assert_ready_ok ! (reserve2 . poll ()) ; drop (permits) ; assert_eq ! (tx1 . capacity () , n) ; } } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_thread_park_count",
                        "label": "current_thread_park_count",
                        "kind": "Function",
                        "signature": "fn # [cfg (loom)] pub (crate) fn current_thread_park_count () -> usize { CURRENT_THREAD_PARK_COUNT . with (| count | count . load (SeqCst)) } . sig",
                        "file_path": "tokio/src/runtime/park.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_same_task_no_poll",
                        "label": "sleep_same_task_no_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn sleep_same_task_no_poll () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let sleep = Box :: pin (time :: sleep_until (start + ms (300))) ; Tester { sleep , state : State :: Begin , before : None , poll : false , } . await ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_or_init_panic",
                        "label": "get_or_init_panic",
                        "kind": "Function",
                        "signature": "fn # [test] fn get_or_init_panic () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { time :: pause () ; let handle1 = rt . spawn (async { ONCE . get_or_init (func1) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_init (func_panic) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert_eq ! (* result2 , 5) ; }) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_panic_caller",
                        "label": "spawn_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn spawn_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { tokio :: spawn (future :: pending :: < () > ()) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/task_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_user",
                        "label": "create_user",
                        "kind": "Function",
                        "signature": "fn pub fn create_user (name : String , age : u32) -> User { User { name , age } } . sig",
                        "file_path": "src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "repeatedly_reset_entry_inserted_as_expired",
                        "label": "repeatedly_reset_entry_inserted_as_expired",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Regression test: Given an entry inserted with a deadline in the past, so\"] # [doc = \" that it is placed directly on the expired queue, reset the entry to a\"] # [doc = \" deadline in the future. Validate that this leaves the entry and queue in an\"] # [doc = \" internally consistent state by running an additional reset on the entry\"] # [doc = \" before polling it to completion.\"] # [tokio :: test] async fn repeatedly_reset_entry_inserted_as_expired () { time :: pause () ; time :: sleep (ms (1000)) . await ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now - ms (100)) ; queue . reset_at (& key , now + ms (100)) ; queue . reset_at (& key , now + ms (50)) ; assert_pending ! (poll ! (queue)) ; time :: sleep_until (now + ms (60)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ZeroSizedFuture",
                        "label": "ZeroSizedFuture",
                        "kind": "Struct",
                        "signature": "struct ZeroSizedFuture",
                        "file_path": "tokio-util/tests/reusable_box.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "channel",
                        "label": "channel",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn channel < T , S : Semaphore > (semaphore : S) -> (Tx < T , S > , Rx < T , S >) { let (tx , rx) = list :: channel () ; let chan = Arc :: new (Chan { notify_rx_closed : Notify :: new () , tx : CachePadded :: new (tx) , semaphore , rx_waker : CachePadded :: new (AtomicWaker :: new ()) , tx_count : AtomicUsize :: new (1) , tx_weak_count : AtomicUsize :: new (0) , rx_fields : UnsafeCell :: new (RxFields { list : rx , rx_closed : false , }) , }) ; (Tx :: new (chan . clone ()) , Rx :: new (chan)) } . sig",
                        "file_path": "tokio/src/sync/mpsc/chan.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_write",
                        "label": "basic_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn basic_write () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . write_all (HELLO) . await . unwrap () ; file . flush () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "into_read_buf_parts",
                        "label": "into_read_buf_parts",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn into_read_buf_parts (rb : ReadBuf < '_ >) -> ReadBufParts { ReadBufParts { ptr : rb . filled () . as_ptr () , len : rb . filled () . len () , initialized : rb . initialized () . len () , } } . sig",
                        "file_path": "tokio/src/io/util/vec_with_initialized.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stdio",
                        "label": "stdio",
                        "kind": "Function",
                        "signature": "fn pub (super) fn stdio < T > (io : T) -> io :: Result < ChildStdio > where T : IntoRawHandle , { use std :: os :: windows :: prelude :: FromRawHandle ; let raw = Arc :: new (unsafe { StdFile :: from_raw_handle (io . into_raw_handle ()) }) ; let io = ArcFile (raw . clone ()) ; let io = unsafe { Blocking :: new (io) } ; Ok (ChildStdio { raw , io }) } . sig",
                        "file_path": "tokio/src/process/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MappedMutexGuardInner",
                        "label": "MappedMutexGuardInner",
                        "kind": "Struct",
                        "signature": "struct MappedMutexGuardInner",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "sink_poll_flush_is_cooperative",
                        "label": "sink_poll_flush_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sink_poll_flush_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { tokio :: io :: sink () . flush () . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_sink.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_msgs_dropped_on_rx_drop",
                        "label": "test_msgs_dropped_on_rx_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_msgs_dropped_on_rx_drop () { let (tx , mut rx) = mpsc :: channel (3) ; tx . send (Msg { }) . await . unwrap () ; tx . send (Msg { }) . await . unwrap () ; let sent_fut = tx . send (Msg { }) ; let _ = rx . recv () . await . unwrap () ; let _ = rx . recv () . await . unwrap () ; sent_fut . await . unwrap () ; drop (rx) ; assert_eq ! (NUM_DROPPED . load (Acquire) , 3) ; assert ! (tx . send (Msg { }) . await . is_err ()) ; assert_eq ! (NUM_DROPPED . load (Acquire) , 4) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "take",
                        "label": "take",
                        "kind": "Function",
                        "signature": "fn pub (super) fn take < R : AsyncRead > (inner : R , limit : u64) -> Take < R > { Take { inner , limit_ : limit , } } . sig",
                        "file_path": "tokio/src/io/util/take.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_temporary_os_thread_error",
                        "label": "is_temporary_os_thread_error",
                        "kind": "Function",
                        "signature": "fn # [inline] fn is_temporary_os_thread_error (error : & io :: Error) -> bool { matches ! (error . kind () , io :: ErrorKind :: WouldBlock) } . sig",
                        "file_path": "tokio/src/runtime/blocking/pool.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "exact_1ms_advance",
                        "label": "exact_1ms_advance",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn exact_1ms_advance () { let now = Instant :: now () ; let dur = Duration :: from_millis (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; let now = Instant :: now () ; let dur = Duration :: from_millis (1) ; time :: advance (dur) . await ; assert_eq ! (now . elapsed () , dur) ; } . sig",
                        "file_path": "tokio/tests/time_pause.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_only_on_first_poll_with_cancellation_token_test",
                        "label": "pending_only_on_first_poll_with_cancellation_token_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn pending_only_on_first_poll_with_cancellation_token_test () { let (waker , wake_count) = new_count_waker () ; let token = CancellationToken :: new () ; let fut = ReadyOnTheSecondPollFuture :: default () . with_cancellation_token (& token) ; pin ! (fut) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_pending ! (res) ; token . cancel () ; assert_eq ! (wake_count , 1) ; let res = fut . as_mut () . poll (& mut Context :: from_waker (& waker)) ; assert_ready_eq ! (res , Some (())) ; } . sig",
                        "file_path": "tokio-util/tests/future.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_max_frame_len",
                        "label": "write_max_frame_len",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_max_frame_len () { let io = length_delimited :: Builder :: new () . max_frame_length (5) . new_write (mock ! { }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_flavor_not_string",
                        "label": "test_flavor_not_string",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = 123)] async fn test_flavor_not_string () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_multi",
                        "label": "notify_multi",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_multi () { loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let mut ths = vec ! [] ; for _ in 0 .. 2 { let notify = notify . clone () ; ths . push (thread :: spawn (move | | { block_on (async { notify . notified () . await ; notify . notify_one () ; }) })) ; } notify . notify_one () ; for th in ths . drain (..) { th . join () . unwrap () ; } block_on (async { notify . notified () . await ; }) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "insert_in_past_after_poll_fires_immediately",
                        "label": "insert_in_past_after_poll_fires_immediately",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn insert_in_past_after_poll_fires_immediately () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; queue . insert_at (\"foo\" , now + ms (200)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (80)) . await ; assert ! (! queue . is_woken ()) ; queue . insert_at (\"bar\" , now + ms (40)) ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) . into_inner () ; assert_eq ! (entry , \"bar\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Init",
                        "label": "Init",
                        "kind": "Trait",
                        "signature": "trait Init",
                        "file_path": "tokio/src/signal/registry.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "read_until_not_all_ready",
                        "label": "read_until_not_all_ready",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_until_not_all_ready () { let mock = Builder :: new () . read (b\"Hello Wor\") . read (b\"ld#Fizz\\xffBuz\") . read (b\"z#1#2\") . build () ; let mut read = BufReader :: new (mock) ; let mut chunk = b\"We say \" . to_vec () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , b\"Hello World#\" . len ()) ; assert_eq ! (chunk , b\"We say Hello World#\") ; chunk = b\"I solve \" . to_vec () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , b\"Fizz\\xffBuzz\\n\" . len ()) ; assert_eq ! (chunk , b\"I solve Fizz\\xffBuzz#\") ; chunk . clear () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , 2) ; assert_eq ! (chunk , b\"1#\") ; chunk . clear () ; let bytes = read . read_until (b'#' , & mut chunk) . await . unwrap () ; assert_eq ! (bytes , 1) ; assert_eq ! (chunk , b\"2\") ; } . sig",
                        "file_path": "tokio/tests/io_read_until.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_many",
                        "label": "notify_many",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_many () { let tracker = TaskTracker :: new () ; let mut waits : Vec < _ > = (0 .. 10) . map (| _ | task :: spawn (tracker . wait ())) . collect () ; for wait in & mut waits { assert_pending ! (wait . poll ()) ; } tracker . close () ; for wait in & mut waits { assert_ready ! (wait . poll ()) ; } } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-c\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_c;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-C events.\"] # [doc = \"     let mut signal = ctrl_c()?;\"] # [doc = \"\"] # [doc = \"     // Print whenever a CTRL-C event is received.\"] # [doc = \"     for countdown in (0..3).rev() {\"] # [doc = \"         signal.recv().await;\"] # [doc = \"         println!(\\\"got CTRL-C. {} more to exit\\\", countdown);\"] # [doc = \"     }\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_c () -> io :: Result < CtrlC > { Ok (CtrlC { inner : self :: imp :: ctrl_c () ? , }) } . sig",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_empty_send",
                        "label": "receiver_is_empty_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_empty_send () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (rx . is_empty () , \"channel IS empty before value is sent\") ; tx . send (17) . unwrap () ; assert ! (! rx . is_empty () , \"channel is NOT empty after value is sent\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_eq ! (poll , Ok (17)) ; assert ! (rx . is_empty () , \"channel IS empty after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_waiters_sequential_notified_await",
                        "label": "notify_waiters_sequential_notified_await",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks if a single call to `notify_waiters` does not get through two `Notified`\"] # [doc = \" futures created and awaited sequentially like this:\"] # [doc = \" ```ignore\"] # [doc = \" notify.notified().await;\"] # [doc = \" notify.notified().await;\"] # [doc = \" ```\"] # [test] fn notify_waiters_sequential_notified_await () { use crate :: sync :: oneshot ; loom :: model (| | { let notify = Arc :: new (Notify :: new ()) ; let (tx_fst , rx_fst) = oneshot :: channel () ; let (tx_snd , rx_snd) = oneshot :: channel () ; let receiver = thread :: spawn ({ let notify = notify . clone () ; move | | { block_on (async { let mut first_notified = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (first_notified . poll ()) ; let _task_pile = (0 .. WAKE_LIST_SIZE + 1) . map (| _ | { let mut fut = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (fut . poll ()) ; fut }) . collect :: < Vec < _ > > () ; tx_fst . send (()) . unwrap () ; first_notified . await ; let mut second_notified = tokio_test :: task :: spawn (notify . notified ()) ; assert_pending ! (second_notified . poll ()) ; rx_snd . await . unwrap () ; assert_pending ! (second_notified . poll ()) ; }) ; } }) ; block_on (rx_fst) . unwrap () ; notify . notify_waiters () ; tx_snd . send (()) . unwrap () ; receiver . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "b",
                        "label": "b",
                        "kind": "Function",
                        "signature": "fn # [inline (never)] async fn b () { black_box (c ()) . await } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_contention",
                        "label": "bench_contention",
                        "kind": "Function",
                        "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contention_bounded (& mut group) ; contention_bounded_recv_many (& mut group) ; contention_bounded_full (& mut group) ; contention_bounded_full_recv_many (& mut group) ; contention_unbounded (& mut group) ; contention_unbounded_recv_many (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RwLockReadGuard",
                        "label": "RwLockReadGuard",
                        "kind": "Struct",
                        "signature": "struct RwLockReadGuard",
                        "file_path": "tokio/src/sync/rwlock/read_guard.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "RwLockMappedWriteGuard",
                        "label": "RwLockMappedWriteGuard",
                        "kind": "Struct",
                        "signature": "struct RwLockMappedWriteGuard",
                        "file_path": "tokio/src/sync/rwlock/write_guard_mapped.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "buffer_gteq_one",
                        "label": "buffer_gteq_one",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] # [cfg (not (target_family = \"wasm\"))] fn buffer_gteq_one () { mpsc :: channel :: < i32 > (0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_entry",
                        "label": "reset_entry",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_entry () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let now = Instant :: now () ; let key = queue . insert_at (\"foo\" , now + ms (5)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; queue . reset_at (& key , now + ms (10)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (7)) . await ; assert ! (! queue . is_woken ()) ; assert_pending ! (poll ! (queue)) ; sleep (ms (3)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_panic_propagates",
                        "label": "task_panic_propagates",
                        "kind": "Function",
                        "signature": "fn # [doc = \" A panic in the spawned task causes the join handle to return an error.\"] # [doc = \" But, you can continue to spawn tasks.\"] # [tokio :: test] # [cfg (panic = \"unwind\")] async fn task_panic_propagates () { let pool = task :: LocalPoolHandle :: new (1) ; let join_handle = pool . spawn_pinned (| | async { panic ! (\"Test panic\") ; }) ; let result = join_handle . await ; assert ! (result . is_err ()) ; let error = result . unwrap_err () ; assert ! (error . is_panic ()) ; let panic_str = error . into_panic () . downcast :: < & 'static str > () . unwrap () ; assert_eq ! (* panic_str , \"Test panic\") ; let join_handle = pool . spawn_pinned (| | async { \"test\" }) ; let result = join_handle . await ; assert ! (result . is_ok ()) ; assert_eq ! (result . unwrap () , \"test\") ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_then_get_a_signal",
                        "label": "drop_then_get_a_signal",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn drop_then_get_a_signal () { let kind = SignalKind :: user_defined1 () ; let sig = signal (kind) . expect (\"failed to create first signal\") ; drop (sig) ; send_signal (libc :: SIGUSR1) ; let mut sig = signal (kind) . expect (\"failed to create second signal\") ; let _ = sig . recv () . await ; } . sig",
                        "file_path": "tokio/tests/signal_drop_recv.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_uncontested",
                        "label": "write_uncontested",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn write_uncontested () { let rwlock = RwLock :: new (100) ; let mut result = rwlock . write () . await ; * result += 50 ; assert_eq ! (* result , 150) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "CancellationToken",
                        "label": "CancellationToken",
                        "kind": "Struct",
                        "signature": "struct CancellationToken",
                        "file_path": "tokio-util/src/sync/cancellation_token.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_many_bounded_capacity",
                        "label": "send_recv_many_bounded_capacity",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn send_recv_many_bounded_capacity () { let mut buffer : Vec < String > = Vec :: with_capacity (9) ; let limit = buffer . capacity () ; let (tx , mut rx) = mpsc :: channel (100) ; let mut expected : Vec < String > = (0 .. limit) . map (| x : usize | format ! (\"{x}\")) . collect :: < Vec < _ > > () ; for x in expected . clone () { tx . send (x) . await . unwrap () } tx . send (\"one more\" . to_string ()) . await . unwrap () ; assert_eq ! (buffer . capacity () , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; assert_eq ! (limit , buffer . capacity ()) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; assert ! (buffer . capacity () > limit) ; expected . push (\"one more\" . to_string ()) ; assert_eq ! (expected , buffer) ; tokio :: spawn (async move { tx . send (\"final\" . to_string ()) . await . unwrap () ; }) ; assert_eq ! (1 , rx . recv_many (& mut buffer , limit) . await) ; expected . push (\"final\" . to_string ()) ; assert_eq ! (expected , buffer) ; assert_eq ! (0 , rx . recv_many (& mut buffer , limit) . await) ; assert_eq ! (expected , buffer) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "current_thread",
                        "label": "current_thread",
                        "kind": "Function",
                        "signature": "fn # [test] fn current_thread () { let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; async fn dump () { let handle = Handle :: current () ; let dump = handle . dump () . await ; let tasks : Vec < _ > = dump . tasks () . iter () . collect () ; assert_eq ! (tasks . len () , 3) ; for task in tasks { let id = task . id () ; let trace = task . trace () . to_string () ; eprintln ! (\"\\n\\n{id}:\\n{trace}\\n\\n\") ; assert ! (trace . contains (\"dump::a\")) ; assert ! (trace . contains (\"dump::b\")) ; assert ! (trace . contains (\"dump::c\")) ; assert ! (trace . contains (\"tokio::task::yield_now\")) ; } } rt . block_on (async { tokio :: select ! (biased ; _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = tokio :: spawn (a ()) => { } , _ = dump () => { } ,) ; }) ; } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_peek_sender",
                        "label": "poll_peek_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_peek_sender () -> std :: io :: Result < () > { let sender = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let receiver = UdpSocket :: bind (\"127.0.0.1:0\") . await ? ; let sender_addr = sender . local_addr () ? ; let receiver_addr = receiver . local_addr () ? ; let msg = b\"Hello, world!\" ; poll_fn (| cx | sender . poll_send_to (cx , msg , receiver_addr)) . await ? ; let peeked_sender = poll_fn (| cx | receiver . poll_peek_sender (cx)) . await ? ; assert_eq ! (peeked_sender , sender_addr) ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; let received_sender = poll_fn (| cx | receiver . poll_recv_from (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; assert_eq ! (received_sender , peeked_sender) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "anon_pipe_into_nonblocking_fd",
                        "label": "anon_pipe_into_nonblocking_fd",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn anon_pipe_into_nonblocking_fd () -> std :: io :: Result < () > { let (tx , rx) = pipe :: pipe () ? ; let tx_fd = tx . into_nonblocking_fd () ? ; let rx_fd = rx . into_nonblocking_fd () ? ; assert ! (is_nonblocking (& tx_fd) ?) ; assert ! (is_nonblocking (& rx_fd) ?) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_output",
                        "label": "test_has_output",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_has_output () -> Result < () , Box < dyn std :: error :: Error > > { Ok (()) } . sig",
                        "file_path": "tests-build/tests/pass/forward_args_and_output.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "legacy_log_histogram",
                        "label": "legacy_log_histogram",
                        "kind": "Function",
                        "signature": "fn # [test] # [allow (deprecated)] fn legacy_log_histogram () { let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_count_histogram_scale (HistogramScale :: Log) . metrics_poll_count_histogram_resolution (Duration :: from_micros (50)) . metrics_poll_count_histogram_buckets (20) . build () . unwrap () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; assert_eq ! (num_buckets , 20) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_multi_frame_one_packet_length_includes_head",
                        "label": "read_single_multi_frame_one_packet_length_includes_head",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_multi_frame_one_packet_length_includes_head () { let mut d : Vec < u8 > = vec ! [] ; d . extend_from_slice (b\"\\x00\\x0babcdefghi\") ; d . extend_from_slice (b\"\\x00\\x05123\") ; d . extend_from_slice (b\"\\x00\\x0dhello world\") ; let io = length_delimited :: Builder :: new () . length_field_length (2) . length_adjustment (- 2) . new_read (mock ! { data (& d) , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_next_eq ! (io , b\"123\") ; assert_next_eq ! (io , b\"hello world\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "threaded_scheduler_spawn10",
                        "label": "threaded_scheduler_spawn10",
                        "kind": "Function",
                        "signature": "fn fn threaded_scheduler_spawn10 (c : & mut Criterion) { let runtime = multi_rt () ; c . bench_function (\"threaded_scheduler_spawn10\" , | b | { b . iter (| | { runtime . block_on (async { let mut handles = Vec :: with_capacity (10) ; for _ in 0 .. 10 { handles . push (tokio :: spawn (work ())) ; } for handle in handles { assert_eq ! (handle . await . unwrap () , 2) ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_many_on_closed_channel",
                        "label": "try_reserve_many_on_closed_channel",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_reserve_many_on_closed_channel () { let (tx , rx) = mpsc :: channel :: < usize > (100) ; drop (rx) ; match assert_err ! (tx . try_reserve_many (10)) { TrySendError :: Closed (()) => { } _ => panic ! () , } ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "huge_size",
                        "label": "huge_size",
                        "kind": "Function",
                        "signature": "fn # [test] fn huge_size () { let mut task = task :: spawn (()) ; let data = & [0 ; 32 * 1024] [..] ; let mut framed = FramedRead :: new (data , BigDecoder) ; task . enter (| cx , _ | { assert_read ! (pin ! (framed) . poll_next (cx) , 0) ; assert ! (assert_ready ! (pin ! (framed) . poll_next (cx)) . is_none ()) ; }) ; struct BigDecoder ; impl Decoder for BigDecoder { type Item = u32 ; type Error = io :: Error ; fn decode (& mut self , buf : & mut BytesMut) -> io :: Result < Option < u32 > > { if buf . len () < 32 * 1024 { return Ok (None) ; } buf . advance (32 * 1024) ; Ok (Some (0)) } } } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_try_join",
                        "label": "empty_try_join",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_try_join () { assert_eq ! (tokio :: try_join ! () as Result < _ , () >, Ok (())) ; assert_eq ! (tokio :: try_join ! (biased ;) as Result < _ , () >, Ok (())) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_one_packet_little_endian",
                        "label": "read_single_frame_one_packet_little_endian",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_one_packet_little_endian () { let io = length_delimited :: Builder :: new () . little_endian () . new_read (mock ! { data (b\"\\x09\\x00\\x00\\x00abcdefghi\") , }) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "remove_dir_all",
                        "label": "remove_dir_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn remove_dir_all () { let temp_dir = tempdir () . unwrap () ; let test_dir = temp_dir . path () . join (\"test\") ; fs :: create_dir (& test_dir) . await . unwrap () ; let file_path = test_dir . as_path () . join (\"a.txt\") ; fs :: write (& file_path , b\"Hello File!\") . await . unwrap () ; fs :: remove_dir_all (test_dir . as_path ()) . await . unwrap () ; match fs :: try_exists (test_dir) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_dir_all\") , } ; match fs :: try_exists (file_path) . await { Ok (exists) => assert ! (! exists) , Err (_) => println ! (\"ignored try_exists error after remove_dir_all\") , } ; } . sig",
                        "file_path": "tokio/tests/fs_remove_dir_all.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AtomicU64",
                        "label": "AtomicU64",
                        "kind": "Struct",
                        "signature": "struct AtomicU64",
                        "file_path": "tokio/src/loom/std/atomic_u64_as_mutex.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ParkThread",
                        "label": "ParkThread",
                        "kind": "Struct",
                        "signature": "struct ParkThread",
                        "file_path": "tokio/src/runtime/park.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "AioEvent",
                        "label": "AioEvent",
                        "kind": "Struct",
                        "signature": "struct AioEvent",
                        "file_path": "tokio/src/io/bsd/poll_aio.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "rt_combinations",
                        "label": "rt_combinations",
                        "kind": "Function",
                        "signature": "fn fn rt_combinations () -> Vec < Box < dyn Fn () -> Runtime > > { vec ! [current_rt () , multi_rt (1) , multi_rt (2) , multi_rt (8) , multi_rt (64) , multi_rt (256) ,] } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "File",
                        "label": "File",
                        "kind": "Struct",
                        "signature": "struct File",
                        "file_path": "tokio/src/fs/file.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "anon_pipe_simple_send",
                        "label": "anon_pipe_simple_send",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn anon_pipe_simple_send () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the pipe\" ; let (mut writer , mut reader) = pipe :: pipe () ? ; let mut read_fut = task :: spawn (async move { let mut buf = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut buf) . await ? ; Ok :: < _ , io :: Error > (buf) }) ; assert_pending ! (read_fut . poll ()) ; writer . write_all (DATA) . await ? ; while ! read_fut . is_woken () { tokio :: task :: yield_now () . await ; } let read_data = assert_ready_ok ! (read_fut . poll ()) ; assert_eq ! (& read_data , DATA) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_is_empty_when_all_messages_are_consumed",
                        "label": "test_rx_unbounded_is_empty_when_all_messages_are_consumed",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_is_empty_when_all_messages_are_consumed () { let (tx , mut rx) = mpsc :: unbounded_channel () ; for i in 0 .. 10 { assert ! (tx . send (i) . is_ok ()) ; } while rx . try_recv () . is_ok () { } assert ! (rx . is_empty ()) } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "semaphore_merge_unrelated_permits",
                        "label": "semaphore_merge_unrelated_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn semaphore_merge_unrelated_permits () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let sem1 = Semaphore :: new (42) ; let sem2 = Semaphore :: new (42) ; let mut p1 = sem1 . try_acquire () . unwrap () ; let p2 = sem2 . try_acquire () . unwrap () ; p1 . merge (p2) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/sync_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tasks_are_balanced",
                        "label": "tasks_are_balanced",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tasks should be given to the least burdened worker. When spawning two tasks\"] # [doc = \" on a pool with two empty workers the tasks should be spawned on separate\"] # [doc = \" workers.\"] # [tokio :: test] async fn tasks_are_balanced () { let pool = task :: LocalPoolHandle :: new (2) ; let (start_sender1 , start_receiver1) = tokio :: sync :: oneshot :: channel () ; let (end_sender1 , end_receiver1) = tokio :: sync :: oneshot :: channel () ; let join_handle1 = pool . spawn_pinned (| | async move { let _ = start_sender1 . send (()) ; let _ = end_receiver1 . await ; std :: thread :: current () . id () }) ; let _ = start_receiver1 . await ; let (start_sender2 , start_receiver2) = tokio :: sync :: oneshot :: channel () ; let join_handle2 = pool . spawn_pinned (| | async move { let _ = start_sender2 . send (()) ; std :: thread :: current () . id () }) ; let _ = start_receiver2 . await ; let _ = end_sender1 . send (()) ; let thread_id1 = join_handle1 . await . unwrap () ; let thread_id2 = join_handle2 . await . unwrap () ; assert_ne ! (thread_id1 , thread_id2) ; } . sig",
                        "file_path": "tokio-util/tests/spawn_pinned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_next_many_zero",
                        "label": "poll_next_many_zero",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn poll_next_many_zero () { let mut stream_map : StreamMap < usize , UsizeStream > = StreamMap :: new () ; stream_map . insert (0 , Box :: pin (pending ()) as UsizeStream) ; let n = poll_fn (| cx | stream_map . poll_next_many (cx , & mut vec ! [] , 0)) . await ; assert_eq ! (n , 0) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_buf",
                        "label": "read_buf",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_buf () { struct Rd { cnt : usize , } impl AsyncRead for Rd { fn poll_read (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , buf : & mut ReadBuf < '_ > ,) -> Poll < io :: Result < () > > { self . cnt += 1 ; buf . put_slice (b\"hello world\") ; Poll :: Ready (Ok (())) } } let mut buf = vec ! [] ; let mut rd = Rd { cnt : 0 } ; let n = assert_ok ! (rd . read_buf (& mut buf) . await) ; assert_eq ! (1 , rd . cnt) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , b\"hello world\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_read_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "builder_global_queue_interval_panic_caller",
                        "label": "builder_global_queue_interval_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn builder_global_queue_interval_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = Builder :: new_multi_thread () . global_queue_interval (0) . build () ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/rt_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_has_second_test_attr_rust_2021",
                        "label": "test_has_second_test_attr_rust_2021",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [std :: prelude :: rust_2021 :: test] async fn test_has_second_test_attr_rust_2021 () { } . sig",
                        "file_path": "tests-build/tests/fail/macros_invalid_input.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_cancelled",
                        "label": "is_cancelled",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns whether or not the node is cancelled\"] pub (crate) fn is_cancelled (node : & Arc < TreeNode >) -> bool { node . inner . lock () . unwrap () . is_cancelled } . sig",
                        "file_path": "tokio-util/src/sync/cancellation_token/tree_node.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "num_blocking_threads",
                        "label": "num_blocking_threads",
                        "kind": "Function",
                        "signature": "fn # [test] fn num_blocking_threads () { let rt = current_thread () ; assert_eq ! (0 , rt . metrics () . num_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; assert_eq ! (1 , rt . metrics () . num_blocking_threads ()) ; let rt = threaded () ; assert_eq ! (0 , rt . metrics () . num_blocking_threads ()) ; let _ = rt . block_on (rt . spawn_blocking (move | | { })) ; assert_eq ! (1 , rt . metrics () . num_blocking_threads ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset",
                        "label": "reset",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn reset () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset () ; time :: advance (ms (250)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (50)) . await ; check_interval_poll ! (i , start , 701) ; time :: advance (ms (300)) . await ; check_interval_poll ! (i , start , 1001) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_host_string",
                        "label": "connect_addr_host_string",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_host_string () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = format ! (\"localhost:{}\" , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (addr) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "StreamMock",
                        "label": "StreamMock",
                        "kind": "Struct",
                        "signature": "struct StreamMock",
                        "file_path": "tokio-test/src/stream_mock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "unowned_poll",
                        "label": "unowned_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn unowned_poll () { let (task , _) = unowned (async { } , NoopSchedule , Id :: next () , SpawnLocation :: capture ()) ; task . run () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SignalKind",
                        "label": "SignalKind",
                        "kind": "Struct",
                        "signature": "struct SignalKind",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "async_send_recv_with_buffer",
                        "label": "async_send_recv_with_buffer",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn async_send_recv_with_buffer () { let (tx , mut rx) = mpsc :: channel (16) ; tokio :: spawn (async move { assert_ok ! (tx . send (1) . await) ; assert_ok ! (tx . send (2) . await) ; }) ; assert_eq ! (Some (1) , rx . recv () . await) ; assert_eq ! (Some (2) , rx . recv () . await) ; assert_eq ! (None , rx . recv () . await) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_multi_thread () . worker_threads (6) . build () . unwrap () } . sig",
                        "file_path": "benches/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Completes when a \\\"ctrl-c\\\" notification is sent to the process.\"] # [doc = \"\"] # [doc = \" While signals are handled very differently between Unix and Windows, both\"] # [doc = \" platforms support receiving a signal on \\\"ctrl-c\\\". This function provides a\"] # [doc = \" portable API for receiving this notification.\"] # [doc = \"\"] # [doc = \" Once the returned future is polled, a listener is registered. The future\"] # [doc = \" will complete on the first received `ctrl-c` **after** the initial call to\"] # [doc = \" either `Future::poll` or `.await`.\"] # [doc = \"\"] # [doc = \" # Caveats\"] # [doc = \"\"] # [doc = \" On Unix platforms, the first time that a `Signal` instance is registered for a\"] # [doc = \" particular signal kind, an OS signal-handler is installed which replaces the\"] # [doc = \" default platform behavior when that signal is received, **for the duration of\"] # [doc = \" the entire process**.\"] # [doc = \"\"] # [doc = \" For example, Unix systems will terminate a process by default when it\"] # [doc = \" receives a signal generated by `\\\"CTRL+C\\\"` on the terminal. But, when a\"] # [doc = \" `ctrl_c` stream is created to listen for this signal, the time it arrives,\"] # [doc = \" it will be translated to a stream event, and the process will continue to\"] # [doc = \" execute.  **Even if this `Signal` instance is dropped, subsequent `SIGINT`\"] # [doc = \" deliveries will end up captured by Tokio, and the default platform behavior\"] # [doc = \" will NOT be reset**.\"] # [doc = \"\"] # [doc = \" Thus, applications should take care to ensure the expected signal behavior\"] # [doc = \" occurs as expected after listening for specific signals.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() {\"] # [doc = \"     println!(\\\"waiting for ctrl-c\\\");\"] # [doc = \"\"] # [doc = \"     signal::ctrl_c().await.expect(\\\"failed to listen for event\\\");\"] # [doc = \"\"] # [doc = \"     println!(\\\"received ctrl-c event\\\");\"] # [doc = \" }\"] # [doc = \" ```\"] # [doc = \"\"] # [doc = \" Listen in the background:\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" tokio::spawn(async move {\"] # [doc = \"     tokio::signal::ctrl_c().await.unwrap();\"] # [doc = \"     // Your handler here\"] # [doc = \" });\"] # [doc = \" ```\"] pub async fn ctrl_c () -> io :: Result < () > { os_impl :: ctrl_c () ? . recv () . await ; Ok (()) } . sig",
                        "file_path": "tokio/src/signal/ctrl_c.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_try_join_next_with_id_disabled_coop",
                        "label": "test_join_queue_try_join_next_with_id_disabled_coop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_try_join_next_with_id_disabled_coop () { const TASK_NUM : u32 = 1000 ; let (send , recv) = tokio :: sync :: watch :: channel (()) ; let mut queue = JoinQueue :: new () ; let mut spawned = Vec :: with_capacity (TASK_NUM as usize) ; for _ in 0 .. TASK_NUM { let mut recv = recv . clone () ; let handle = queue . spawn (async move { recv . changed () . await . unwrap () }) ; spawned . push (handle . id ()) ; } drop (recv) ; assert ! (queue . try_join_next_with_id () . is_none ()) ; send . send_replace (()) ; send . closed () . await ; let mut count = 0 ; let mut coop_count = 0 ; let mut joined = Vec :: with_capacity (TASK_NUM as usize) ; while ! queue . is_empty () { match queue . try_join_next_with_id () { Some (Ok ((id , ()))) => { count += 1 ; joined . push (id) ; } Some (Err (err)) => panic ! (\"failed: {err}\") , None => { coop_count += 1 ; tokio :: task :: yield_now () . await ; } } } assert_eq ! (coop_count , 0) ; assert_eq ! (count , TASK_NUM) ; assert_eq ! (joined , spawned) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Stats",
                        "label": "Stats",
                        "kind": "Struct",
                        "signature": "struct Stats",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/stats.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "remove_dir_all",
                        "label": "remove_dir_all",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Removes a directory at this path, after removing all its contents. Use carefully!\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::remove_dir_all`][std]\"] # [doc = \"\"] # [doc = \" [std]: fn@std::fs::remove_dir_all\"] pub async fn remove_dir_all (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: remove_dir_all (path)) . await } . sig",
                        "file_path": "tokio/src/fs/remove_dir_all.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_multiple_child_tokens",
                        "label": "drop_multiple_child_tokens",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_multiple_child_tokens () { for drop_first_child_first in & [true , false] { let token = CancellationToken :: new () ; let mut child_tokens = [None , None , None] ; for child in & mut child_tokens { * child = Some (token . child_token ()) ; } assert ! (! token . is_cancelled ()) ; assert ! (! child_tokens [0] . as_ref () . unwrap () . is_cancelled ()) ; for i in 0 .. child_tokens . len () { if * drop_first_child_first { child_tokens [i] = None ; } else { child_tokens [child_tokens . len () - 1 - i] = None ; } assert ! (! token . is_cancelled ()) ; } drop (token) ; } } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "watch_test",
                        "label": "watch_test",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (target_family = \"wasm\"))] fn watch_test () { let rt = crate :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async { let (tx , mut rx) = crate :: sync :: watch :: channel (()) ; crate :: spawn (async move { let _ = tx . send (()) ; }) ; let _ = rx . changed () . await ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "issue_4175_main_2",
                        "label": "issue_4175_main_2",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] pub async fn issue_4175_main_2 () -> std :: io :: Result < () > { panic ! () ; } . sig",
                        "file_path": "tokio/tests/macros_test.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_cell_new_with",
                        "label": "drop_cell_new_with",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_cell_new_with () { let num_drops = Arc :: new (AtomicU32 :: new (0)) ; { let once_cell = OnceCell :: new_with (Some (Foo :: from (num_drops . clone ()))) ; assert ! (once_cell . initialized ()) ; } assert ! (num_drops . load (Ordering :: Acquire) == 1) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_all_buf_vectored",
                        "label": "write_all_buf_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_all_buf_vectored () { struct Wr { buf : BytesMut , } impl AsyncWrite for Wr { fn poll_write (self : Pin < & mut Self > , _cx : & mut Context < '_ > , _buf : & [u8] ,) -> Poll < io :: Result < usize > > { panic ! (\"shouldn't be called\") } fn poll_flush (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_shutdown (self : Pin < & mut Self > , _cx : & mut Context < '_ >) -> Poll < io :: Result < () > > { Ok (()) . into () } fn poll_write_vectored (mut self : Pin < & mut Self > , _cx : & mut Context < '_ > , bufs : & [io :: IoSlice < '_ >] ,) -> Poll < Result < usize , io :: Error > > { for buf in bufs { self . buf . extend_from_slice (buf) ; } let n = self . buf . len () ; Ok (n) . into () } fn is_write_vectored (& self) -> bool { true } } let mut wr = Wr { buf : BytesMut :: with_capacity (64) , } ; let mut buf = Bytes :: from_static (b\"hello\") . chain (Bytes :: from_static (b\" \")) . chain (Bytes :: from_static (b\"world\")) ; wr . write_all_buf (& mut buf) . await . unwrap () ; assert_eq ! (& wr . buf [..] , b\"hello world\") ; } . sig",
                        "file_path": "tokio/tests/io_write_all_buf.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SlowHddWriter",
                        "label": "SlowHddWriter",
                        "kind": "Struct",
                        "signature": "struct SlowHddWriter",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_partial_would_block_then_err",
                        "label": "read_partial_would_block_then_err",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_partial_would_block_then_err () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\" . to_vec ()) , Err (io :: Error :: new (io :: ErrorKind :: WouldBlock , \"\")) , Err (io :: Error :: new (io :: ErrorKind :: Other , \"\")) , } ; let mut framed = FramedRead :: new (mock , U32Decoder) ; task . enter (| cx , _ | { assert ! (pin ! (framed) . poll_next (cx) . is_pending ()) ; assert_eq ! (io :: ErrorKind :: Other , assert_ready ! (pin ! (framed) . poll_next (cx)) . unwrap () . unwrap_err () . kind ()) }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "greater_than_max",
                        "label": "greater_than_max",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn greater_than_max () { const YR_5 : u64 = 5 * 365 * 24 * 60 * 60 * 1000 ; time :: pause () ; time :: sleep_until (Instant :: now () + ms (YR_5)) . await ; } . sig",
                        "file_path": "tokio/tests/time_sleep.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lagging_receiver_recovers_after_wrap_open",
                        "label": "lagging_receiver_recovers_after_wrap_open",
                        "kind": "Function",
                        "signature": "fn # [test] fn lagging_receiver_recovers_after_wrap_open () { let (tx , mut rx) = broadcast :: channel (2) ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_ok ! (tx . send (3)) ; assert_lagged ! (rx . try_recv () , 1) ; assert_eq ! (assert_recv ! (rx) , 2) ; assert_eq ! (assert_recv ! (rx) , 3) ; assert_empty ! (rx) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_rx",
                        "label": "multi_rx",
                        "kind": "Function",
                        "signature": "fn # [test] fn multi_rx () { let (tx , mut rx1) = watch :: channel (\"one\") ; let mut rx2 = rx1 . clone () ; { let mut t1 = spawn (rx1 . changed ()) ; let mut t2 = spawn (rx2 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"one\") ; assert_eq ! (* rx2 . borrow () , \"one\") ; let mut t2 = spawn (rx2 . changed ()) ; { let mut t1 = spawn (rx1 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; tx . send (\"two\") . unwrap () ; assert ! (t1 . is_woken ()) ; assert ! (t2 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"two\") ; { let mut t1 = spawn (rx1 . changed ()) ; assert_pending ! (t1 . poll ()) ; tx . send (\"three\") . unwrap () ; assert ! (t1 . is_woken ()) ; assert ! (t2 . is_woken ()) ; assert_ready_ok ! (t1 . poll ()) ; assert_ready_ok ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"three\") ; drop (t2) ; assert_eq ! (* rx2 . borrow () , \"three\") ; { let mut t1 = spawn (rx1 . changed ()) ; let mut t2 = spawn (rx2 . changed ()) ; assert_pending ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; tx . send (\"four\") . unwrap () ; assert_ready_ok ! (t1 . poll ()) ; assert_ready_ok ! (t2 . poll ()) ; } assert_eq ! (* rx1 . borrow () , \"four\") ; assert_eq ! (* rx2 . borrow () , \"four\") ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_buf_from",
                        "label": "try_recv_buf_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_recv_buf_from () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = Vec :: with_capacity (512) ; match server . try_recv_buf_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SelectBiased",
                        "label": "SelectBiased",
                        "kind": "Struct",
                        "signature": "struct SelectBiased",
                        "file_path": "tokio/src/macros/join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "path_read_write",
                        "label": "path_read_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn path_read_write () { let temp = tempdir () ; let dir = temp . path () ; assert_ok ! (fs :: write (dir . join (\"bar\") , b\"bytes\") . await) ; let out = assert_ok ! (fs :: read (dir . join (\"bar\")) . await) ; assert_eq ! (out , b\"bytes\") ; } . sig",
                        "file_path": "tokio/tests/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_join_does_not_allow_tasks_to_starve",
                        "label": "try_join_does_not_allow_tasks_to_starve",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_join_does_not_allow_tasks_to_starve () { let permits = Arc :: new (Semaphore :: new (10)) ; let result = tokio :: try_join ! (non_cooperative_task (Arc :: clone (& permits)) , poor_little_task (permits)) ; let (non_cooperative_result , little_task_result) = result . unwrap () ; assert_eq ! (5 , non_cooperative_result) ; assert_eq ! (5 , little_task_result) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy",
                        "label": "copy",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn copy () { let dir = tempdir () . unwrap () ; let source_path = dir . path () . join (\"foo.txt\") ; let dest_path = dir . path () . join (\"bar.txt\") ; fs :: write (& source_path , b\"Hello File!\") . await . unwrap () ; fs :: copy (& source_path , & dest_path) . await . unwrap () ; let from = fs :: read (& source_path) . await . unwrap () ; let to = fs :: read (& dest_path) . await . unwrap () ; assert_eq ! (from , to) ; } . sig",
                        "file_path": "tokio/tests/fs_copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_custom_flags_linux",
                        "label": "open_options_custom_flags_linux",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (target_os = \"linux\")] async fn open_options_custom_flags_linux () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (libc :: O_TRUNC)) . contains (\"custom_flags: 512\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_sender_dropped",
                        "label": "size_hint_sender_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_sender_dropped () { let (tx , rx) = mpsc :: unbounded_channel () ; tx . send (1) . unwrap () ; tx . send (2) . unwrap () ; let mut stream = UnboundedReceiverStream :: new (rx) ; drop (tx) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_unbounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_update_max_frame_len_in_flight",
                        "label": "write_update_max_frame_len_in_flight",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_update_max_frame_len_in_flight () { let io = length_delimited :: Builder :: new () . new_write (mock ! { data (b\"\\x00\\x00\\x00\\x06\") , data (b\"ab\") , Poll :: Pending , data (b\"cdef\") , flush () , }) ; pin_mut ! (io) ; task :: spawn (()) . enter (| cx , _ | { assert_ready_ok ! (io . as_mut () . poll_ready (cx)) ; assert_ok ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert_pending ! (io . as_mut () . poll_flush (cx)) ; io . encoder_mut () . set_max_frame_length (5) ; assert_ready_ok ! (io . as_mut () . poll_flush (cx)) ; assert_err ! (io . as_mut () . start_send (Bytes :: from (\"abcdef\"))) ; assert ! (io . get_ref () . calls . is_empty ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_string",
                        "label": "read_to_string",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_to_string () { let mut buf = String :: new () ; let mut rd : & [u8] = b\"hello world\" ; let n = assert_ok ! (rd . read_to_string (& mut buf) . await) ; assert_eq ! (n , 11) ; assert_eq ! (buf [..] , \"hello world\" [..]) ; } . sig",
                        "file_path": "tokio/tests/io_read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split",
                        "label": "split",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn split (stream : & mut TcpStream) -> (ReadHalf < '_ > , WriteHalf < '_ >) { (ReadHalf (& * stream) , WriteHalf (& * stream)) } . sig",
                        "file_path": "tokio/src/net/tcp/split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "udp_socket_from_std_panic_caller",
                        "label": "udp_socket_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg_attr (miri , ignore)] fn udp_socket_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use std :: net :: SocketAddr ; use tokio :: net :: UdpSocket ; let addr = \"127.0.0.1:0\" . parse :: < SocketAddr > () . unwrap () ; let std_sock = std :: net :: UdpSocket :: bind (addr) . unwrap () ; std_sock . set_nonblocking (true) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _sock = UdpSocket :: from_std (std_sock) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line",
                        "label": "read_line",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_line () { let mut buf = String :: new () ; let mut rd = Cursor :: new (b\"hello\\nworld\\n\\n\") ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , \"hello\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 6) ; assert_eq ! (buf , \"world\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 1) ; assert_eq ! (buf , \"\\n\") ; buf . clear () ; let n = assert_ok ! (rd . read_line (& mut buf) . await) ; assert_eq ! (n , 0) ; assert_eq ! (buf , \"\") ; } . sig",
                        "file_path": "tokio/tests/io_read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_max_length_underrun",
                        "label": "lines_decoder_max_length_underrun",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_max_length_underrun () { const MAX_LENGTH : usize = 6 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"ong\\n\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"line 2\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"\\n\") ; assert_eq ! (\"line 2\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "token_len",
                        "label": "token_len",
                        "kind": "Function",
                        "signature": "fn # [test] fn token_len () { let tracker = TaskTracker :: new () ; let mut tokens = Vec :: new () ; for i in 0 .. 10 { assert_eq ! (tracker . len () , i) ; tokens . push (tracker . token ()) ; } assert ! (! tracker . is_empty ()) ; assert_eq ! (tracker . len () , 10) ; for (i , token) in tokens . into_iter () . enumerate () { drop (token) ; assert_eq ! (tracker . len () , 9 - i) ; } } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_token_with_children",
                        "label": "drop_token_with_children",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_token_with_children () { loom :: model (| | { let token1 = CancellationToken :: new () ; let child_token1 = token1 . child_token () ; let child_token2 = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { drop (child_token1) ; }) ; let th3 = thread :: spawn (move | | { drop (child_token2) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "symlink_dir",
                        "label": "symlink_dir",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new directory symlink on the filesystem.\"] # [doc = \"\"] # [doc = \" The `link` path will be a directory symbolic link pointing to the `original`\"] # [doc = \" path.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::os::windows::fs::symlink_dir`][std]\"] # [doc = \"\"] # [doc = \" [std]: https://doc.rust-lang.org/std/os/windows/fs/fn.symlink_dir.html\"] pub async fn symlink_dir (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: os :: windows :: fs :: symlink_dir (original , link)) . await } . sig",
                        "file_path": "tokio/src/fs/symlink_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "return_elapsed_errors_only_once",
                        "label": "return_elapsed_errors_only_once",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn return_elapsed_errors_only_once () { time :: pause () ; let stream = stream :: iter (1 ..= 3) . then (maybe_sleep) . timeout (ms (50)) ; let mut stream = task :: spawn (stream) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (1))) ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (51)) . await ; let v = assert_ready ! (stream . poll_next ()) ; assert ! (v . unwrap () . is_err ()) ; time :: advance (ms (50)) . await ; assert_pending ! (stream . poll_next ()) ; time :: advance (ms (100)) . await ; assert_ready_eq ! (stream . poll_next () , Some (Ok (2))) ; assert_ready_eq ! (stream . poll_next () , Some (Ok (3))) ; assert_ready_eq ! (stream . poll_next () , None) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_string_internal",
                        "label": "read_to_string_internal",
                        "kind": "Function",
                        "signature": "fn fn read_to_string_internal < R : AsyncRead + ? Sized > (reader : Pin < & mut R > , output : & mut String , buf : & mut VecWithInitialized < Vec < u8 > > , read : & mut usize , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { let io_res = ready ! (read_to_end_internal (buf , reader , read , cx)) ; let utf8_res = String :: from_utf8 (buf . take ()) ; debug_assert ! (buf . is_empty ()) ; debug_assert ! (output . is_empty ()) ; finish_string_read (io_res , utf8_res , * read , output , true) } . sig",
                        "file_path": "tokio/src/io/util/read_to_string.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_remote",
                        "label": "spawn_remote",
                        "kind": "Function",
                        "signature": "fn # [cfg_attr (target_os = \"wasi\" , ignore = \"WASI: std::thread::spawn not supported\")] # [test] fn spawn_remote () { let rt = rt () ; let out = rt . block_on (async { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async move { std :: thread :: spawn (move | | { std :: thread :: sleep (Duration :: from_millis (10)) ; tx . send (\"ZOMG\") . unwrap () ; }) ; rx . await . unwrap () }) ; handle . await . unwrap () }) ; assert_eq ! (out , \"ZOMG\") ; cfg_metrics ! { let metrics = rt . metrics () ; drop (rt) ; assert_eq ! (1 , metrics . remote_schedule_count ()) ; let mut local = 0 ; for i in 0 .. metrics . num_workers () { local += metrics . worker_local_schedule_count (i) ; } assert_eq ! (1 , local) ; } } . sig",
                        "file_path": "tokio/tests/rt_basic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_reserve_many_zero",
                        "label": "try_reserve_many_zero",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_reserve_many_zero () { let (tx , rx) = mpsc :: channel :: < () > (1) ; assert ! (assert_ok ! (tx . try_reserve_many (0)) . next () . is_none ()) ; tx . try_send (()) . unwrap () ; assert ! (assert_ok ! (tx . try_reserve_many (0)) . next () . is_none ()) ; drop (rx) ; assert_eq ! (assert_err ! (tx . try_reserve_many (0)) , TrySendError :: Closed (())) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_enable_consumes_permit",
                        "label": "test_enable_consumes_permit",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_enable_consumes_permit () { let notify = Notify :: new () ; notify . notify_one () ; let mut future1 = spawn (notify . notified ()) ; future1 . enter (| _ , fut | assert ! (fut . enable ())) ; let mut future2 = spawn (notify . notified ()) ; future2 . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "is_tx_closed",
                        "label": "is_tx_closed",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Returns `true` if the closed flag has been set.\"] fn is_tx_closed (bits : usize) -> bool { TX_CLOSED == bits & TX_CLOSED } . sig",
                        "file_path": "tokio/src/sync/mpsc/block.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "len_nonzero_after_send",
                        "label": "len_nonzero_after_send",
                        "kind": "Function",
                        "signature": "fn # [test] fn len_nonzero_after_send () { loom :: model (| | { let (send , recv) = mpsc :: channel (10) ; let send2 = send . clone () ; let join = thread :: spawn (move | | { block_on (send2 . send (\"message2\")) . unwrap () ; }) ; block_on (send . send (\"message1\")) . unwrap () ; assert ! (recv . len () != 0) ; join . join () . unwrap () ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bucket_index",
                        "label": "bucket_index",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Compute the index for a given value + p combination\"] # [doc = \"\"] # [doc = \" This function does NOT enforce that the value is within the number of expected buckets.\"] fn bucket_index (value : u64 , p : u32) -> u64 { if value == 0 { return 0 ; } let h = 63 - value . leading_zeros () ; if h <= p { value } else { let w = h - p ; ((w + 1) * (1_u32 << p)) as u64 + ((value - (1_u64 << h)) >> w) } } . sig",
                        "file_path": "tokio/src/runtime/metrics/histogram/h2_histogram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_shutdown",
                        "label": "blocking_shutdown",
                        "kind": "Function",
                        "signature": "fn # [test] fn blocking_shutdown () { loom :: model (| | { let v = Arc :: new (()) ; let rt = mk_runtime (1) ; { let _enter = rt . enter () ; for _ in 0 .. 2 { let v = v . clone () ; crate :: task :: spawn_blocking (move | | { assert ! (1 < Arc :: strong_count (& v)) ; }) ; } } drop (rt) ; assert_eq ! (1 , Arc :: strong_count (& v)) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_blocking.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_stream_from_std_panic_caller",
                        "label": "unix_stream_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_stream_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixStream ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let _std_listener = std :: os :: unix :: net :: UnixListener :: bind (& sock_path) . unwrap () ; let std_stream = std :: os :: unix :: net :: UnixStream :: connect (& sock_path) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixStream :: from_std (std_stream) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_is_closed_when_there_are_messages_and_close_is_called",
                        "label": "test_rx_is_closed_when_there_are_messages_and_close_is_called",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_is_closed_when_there_are_messages_and_close_is_called () { let (tx , mut rx) = mpsc :: channel (10) ; for i in 0 .. 10 { assert ! (tx . send (i) . await . is_ok ()) ; } rx . close () ; assert ! (rx . is_closed ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
                        "label": "a_different_future_is_polled_first_every_time_poll_fn_is_polled",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn a_different_future_is_polled_first_every_time_poll_fn_is_polled () { let poll_order = Arc :: new (std :: sync :: Mutex :: new (vec ! [])) ; let fut = | x , poll_order : Arc < std :: sync :: Mutex < Vec < i32 > > > | async move { for _ in 0 .. 4 { { let mut guard = poll_order . lock () . unwrap () ; guard . push (x) ; } tokio :: task :: yield_now () . await ; } Ok :: < () , Infallible > (()) } ; tokio :: try_join ! (fut (1 , Arc :: clone (& poll_order)) , fut (2 , Arc :: clone (& poll_order)) , fut (3 , Arc :: clone (& poll_order)) ,) . unwrap () ; assert_eq ! (vec ! [1 , 2 , 3 , 2 , 3 , 1 , 3 , 1 , 2 , 1 , 2 , 3] , * poll_order . lock () . unwrap ()) ; } . sig",
                        "file_path": "tokio/tests/macros_try_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "interval_zero_duration",
                        "label": "interval_zero_duration",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn interval_zero_duration () { let _ = time :: interval_at (Instant :: now () , ms (0)) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "max_allowed_frame_fits",
                        "label": "max_allowed_frame_fits",
                        "kind": "Function",
                        "signature": "fn # [test] fn max_allowed_frame_fits () { let codec = LengthDelimitedCodec :: builder () . length_field_length (std :: mem :: size_of :: < usize > ()) . max_frame_length (usize :: MAX) . new_codec () ; assert_eq ! (codec . max_frame_length () , usize :: MAX) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "W",
                        "label": "W",
                        "kind": "Struct",
                        "signature": "struct W",
                        "file_path": "tokio/tests/io_join.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "write_into_std_immediate",
                        "label": "write_into_std_immediate",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_into_std_immediate () { let tempfile = tempfile () ; let file = File :: create (tempfile . path ()) . await . unwrap () ; let mut std_file = file . try_into_std () . unwrap () ; std_file . write_all (HELLO) . unwrap () ; let contents = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (contents , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_multi_spawn_many_remote_busy2",
                        "label": "rt_multi_spawn_many_remote_busy2",
                        "kind": "Function",
                        "signature": "fn fn rt_multi_spawn_many_remote_busy2 (c : & mut Criterion) { const NUM_SPAWN : usize = 1_000 ; let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; let flag = Arc :: new (AtomicBool :: new (true)) ; for _ in 0 .. (NUM_WORKERS) { let flag = flag . clone () ; fn iter (flag : Arc < AtomicBool >) { tokio :: spawn (async { if flag . load (Relaxed) { stall () ; iter (flag) ; } }) ; } rt . spawn (async { iter (flag) ; }) ; } c . bench_function (\"spawn_many_remote_busy2\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; flag . store (false , Relaxed) ; } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poll_process_levels",
                        "label": "poll_process_levels",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn poll_process_levels () { let rt = rt (true) ; let handle = rt . handle () ; let mut entries = vec ! [] ; for i in 0 .. normal_or_miri (1024 , 64) { let mut entry = Box :: pin (TimerEntry :: new (handle . inner . clone () , handle . inner . driver () . clock () . now () + Duration :: from_millis (i) ,)) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (noop_waker_ref ())) ; entries . push (entry) ; } for t in 1 .. normal_or_miri (1024 , 64) { handle . inner . driver () . time () . process_at_time (t as u64) ; for (deadline , future) in entries . iter_mut () . enumerate () { let mut context = Context :: from_waker (noop_waker_ref ()) ; if deadline <= t { assert ! (future . as_mut () . poll_elapsed (& mut context) . is_ready ()) ; } else { assert ! (future . as_mut () . poll_elapsed (& mut context) . is_pending ()) ; } } } } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_into_inner",
                        "label": "drop_into_inner",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_into_inner () { let fooer = DropCounter :: new () ; let once_cell = SetOnce :: new () ; assert ! (once_cell . set (fooer . clone ()) . is_ok ()) ; let val = once_cell . into_inner () ; fooer . assert_num_drops (0) ; drop (val) ; fooer . assert_num_drops (1) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_after_completion",
                        "label": "try_recv_after_completion",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_after_completion () { let (tx , mut rx) = oneshot :: channel :: < i32 > () ; tx . send (17) . unwrap () ; assert_eq ! (17 , rx . try_recv () . unwrap ()) ; assert_eq ! (Err (TryRecvError :: Closed) , rx . try_recv ()) ; rx . close () ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RuntimeExt",
                        "label": "RuntimeExt",
                        "kind": "Trait",
                        "signature": "trait RuntimeExt",
                        "file_path": "tokio-util/src/context.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "ResetFuture",
                        "label": "ResetFuture",
                        "kind": "Struct",
                        "signature": "struct ResetFuture",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "future_ext_to_panic_caller",
                        "label": "future_ext_to_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn future_ext_to_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: { sync :: oneshot , time :: Duration } ; use tokio_util :: future :: FutureExt ; let panic_location_file = test_panic (| | { let (_tx , rx) = oneshot :: channel :: < () > () ; let _res = rx . timeout (Duration :: from_millis (10)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_parent_before_child_tokens",
                        "label": "drop_parent_before_child_tokens",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_parent_before_child_tokens () { let token = CancellationToken :: new () ; let child1 = token . child_token () ; let child2 = token . child_token () ; drop (token) ; assert ! (! child1 . is_cancelled ()) ; drop (child1) ; drop (child2) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OwnedWriteHalf",
                        "label": "OwnedWriteHalf",
                        "kind": "Struct",
                        "signature": "struct OwnedWriteHalf",
                        "file_path": "tokio/src/net/unix/split_owned.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_when_close_is_called_before_dropping_sender",
                        "label": "test_rx_len_when_close_is_called_before_dropping_sender",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_when_close_is_called_before_dropping_sender () { let (tx , mut rx) = mpsc :: channel (100) ; tx . send (()) . await . unwrap () ; rx . close () ; drop (tx) ; assert_eq ! (rx . len () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "wake_arc_raw",
                        "label": "wake_arc_raw",
                        "kind": "Function",
                        "signature": "fn unsafe fn wake_arc_raw < T : Wake > (data : * const ()) { let arc : Arc < T > = Arc :: from_raw (data as * const T) ; Wake :: wake (arc) ; } . sig",
                        "file_path": "tokio/src/util/wake.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "FramedParts",
                        "label": "FramedParts",
                        "kind": "Struct",
                        "signature": "struct FramedParts",
                        "file_path": "tokio-util/src/codec/framed.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_invalid_utf8",
                        "label": "lines_decoder_invalid_utf8",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_invalid_utf8 () { let mut codec = LinesCodec :: new () ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"line 1\\xc3\\x28\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert ! (codec . decode_eof (buf) . is_err ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"line 22222222222222\\n\") ; assert_eq ! (\"line 22222222222222\" , codec . decode (buf) . unwrap () . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "require_unpin",
                        "label": "require_unpin",
                        "kind": "Function",
                        "signature": "fn # [allow (dead_code)] fn require_unpin < T : Unpin > (_t : & T) { } . sig",
                        "file_path": "tokio-stream/tests/async_send_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_trailer_offset",
                        "label": "get_trailer_offset",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Compute the offset of the `Trailer` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_trailer_offset (header_size : usize , core_size : usize , core_align : usize , trailer_align : usize ,) -> usize { let mut offset = header_size ; let core_misalign = offset % core_align ; if core_misalign > 0 { offset += core_align - core_misalign ; } offset += core_size ; let trailer_misalign = offset % trailer_align ; if trailer_misalign > 0 { offset += trailer_align - trailer_misalign ; } offset } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "starving",
                        "label": "starving",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn starving () { use std :: future :: Future ; use std :: pin :: Pin ; use std :: task :: { Context , Poll } ; struct Starve < T : Future < Output = () > + Unpin > (T , u64) ; impl < T : Future < Output = () > + Unpin > Future for Starve < T > { type Output = u64 ; fn poll (mut self : Pin < & mut Self > , cx : & mut Context < '_ >) -> Poll < u64 > { if Pin :: new (& mut self . 0) . poll (cx) . is_ready () { return Poll :: Ready (self . 1) ; } self . 1 += 1 ; cx . waker () . wake_by_ref () ; Poll :: Pending } } let when = Instant :: now () + Duration :: from_millis (10) ; let starve = Starve (Box :: pin (sleep_until (when)) , 0) ; starve . await ; assert ! (Instant :: now () >= when) ; } . sig",
                        "file_path": "tokio/tests/time_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abort_by_predicate",
                        "label": "abort_by_predicate",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_by_predicate () { let mut map = JoinMap :: new () ; let mut num_canceled = 0 ; let mut num_completed = 0 ; for i in 0 .. 16 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; }) ; } map . abort_matching (| key | key % 2 != 0) ; while let Some ((key , res)) = map . join_next () . await { match res { Ok (()) => { num_completed += 1 ; assert_eq ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } Err (e) => { num_canceled += 1 ; assert ! (e . is_cancelled ()) ; assert_ne ! (key % 2 , 0) ; assert ! (! map . contains_key (& key)) ; } } } assert_eq ! (num_canceled , 8) ; assert_eq ! (num_completed , 8) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_token_owned_drop_test",
                        "label": "cancel_token_owned_drop_test",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_token_owned_drop_test () { let (waker , wake_counter) = new_count_waker () ; let token = CancellationToken :: new () ; let future = token . cancelled_owned () ; pin ! (future) ; assert_eq ! (Poll :: Pending , future . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_multi_frame_after_codec_changed",
                        "label": "write_multi_frame_after_codec_changed",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_multi_frame_after_codec_changed () { let mut task = task :: spawn (()) ; let mock = mock ! { Ok (b\"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\" . to_vec ()) , } ; let mut framed = FramedWrite :: new (mock , U32Encoder) ; task . enter (| cx , _ | { assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0x04) . is_ok ()) ; let mut framed = framed . map_encoder (| _ | U64Encoder) ; assert ! (assert_ready ! (pin ! (framed) . poll_ready (cx)) . is_ok ()) ; assert ! (pin ! (framed) . start_send (0x08) . is_ok ()) ; assert_eq ! (1 , framed . get_ref () . calls . len ()) ; assert ! (assert_ready ! (pin ! (framed) . poll_flush (cx)) . is_ok ()) ; assert_eq ! (0 , framed . get_ref () . calls . len ()) ; }) ; } . sig",
                        "file_path": "tokio-util/tests/framed_write.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "max_blocking_threads",
                        "label": "max_blocking_threads",
                        "kind": "Function",
                        "signature": "fn # [test] fn max_blocking_threads () { let _rt = tokio :: runtime :: Builder :: new_multi_thread () . max_blocking_threads (1) . build () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "release_during_acquire",
                        "label": "release_during_acquire",
                        "kind": "Function",
                        "signature": "fn # [test] fn release_during_acquire () { loom :: model (| | { let semaphore = Arc :: new (Semaphore :: new (10)) ; semaphore . try_acquire (8) . expect (\"try_acquire should succeed; semaphore uncontended\") ; let semaphore2 = semaphore . clone () ; let thread = thread :: spawn (move | | block_on (semaphore2 . acquire (4)) . unwrap ()) ; semaphore . release (8) ; thread . join () . unwrap () ; semaphore . release (4) ; assert_eq ! (10 , semaphore . available_permits ()) ; }) } . sig",
                        "file_path": "tokio/src/sync/tests/loom_semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UnownedTask",
                        "label": "UnownedTask",
                        "kind": "Struct",
                        "signature": "struct UnownedTask",
                        "file_path": "tokio/src/runtime/task/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "UnboundedReceiverStream",
                        "label": "UnboundedReceiverStream",
                        "kind": "Struct",
                        "signature": "struct UnboundedReceiverStream",
                        "file_path": "tokio-stream/src/wrappers/mpsc_unbounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "empty_unit",
                        "label": "empty_unit",
                        "kind": "Function",
                        "signature": "fn # [allow (clippy :: let_unit_value)] # [tokio :: test] async fn empty_unit () { let mut iter = vec ! [() , () , ()] . into_iter () ; let _ : () = stream :: iter (& mut iter) . collect () . await ; assert ! (iter . next () . is_none ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_two_recv",
                        "label": "send_two_recv",
                        "kind": "Function",
                        "signature": "fn # [test] fn send_two_recv () { let (tx , mut rx1) = broadcast :: channel (16) ; let mut rx2 = tx . subscribe () ; assert_empty ! (rx1) ; assert_empty ! (rx2) ; let n = assert_ok ! (tx . send (\"hello\")) ; assert_eq ! (n , 2) ; let val = assert_recv ! (rx1) ; assert_eq ! (val , \"hello\") ; let val = assert_recv ! (rx2) ; assert_eq ! (val , \"hello\") ; assert_empty ! (rx1) ; assert_empty ! (rx2) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bounds",
                        "label": "bounds",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (not (loom))] fn bounds () { fn check_send < T : Send > () { } fn check_unpin < T : Unpin > () { } fn check_send_sync_val < T : Send + Sync > (_t : T) { } fn check_send_sync < T : Send + Sync > () { } fn check_static < T : 'static > () { } fn check_static_val < T : 'static > (_t : T) { } check_send :: < MutexGuard < '_ , u32 > > () ; check_send :: < OwnedMutexGuard < u32 > > () ; check_unpin :: < Mutex < u32 > > () ; check_send_sync :: < Mutex < u32 > > () ; check_static :: < OwnedMutexGuard < u32 > > () ; let mutex = Mutex :: new (1) ; check_send_sync_val (mutex . lock ()) ; let arc_mutex = Arc :: new (Mutex :: new (1)) ; check_send_sync_val (arc_mutex . clone () . lock_owned ()) ; check_static_val (arc_mutex . lock_owned ()) ; } . sig",
                        "file_path": "tokio/src/sync/mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_permissions",
                        "label": "copy_permissions",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn copy_permissions () { let dir = tempdir () . unwrap () ; let from_path = dir . path () . join (\"foo.txt\") ; let to_path = dir . path () . join (\"bar.txt\") ; let from = tokio :: fs :: File :: create (& from_path) . await . unwrap () ; let mut from_perms = from . metadata () . await . unwrap () . permissions () ; from_perms . set_readonly (true) ; from . set_permissions (from_perms . clone ()) . await . unwrap () ; tokio :: fs :: copy (from_path , & to_path) . await . unwrap () ; let to_perms = tokio :: fs :: metadata (to_path) . await . unwrap () . permissions () ; assert_eq ! (from_perms , to_perms) ; } . sig",
                        "file_path": "tokio/tests/fs_copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_with_bigger_buf",
                        "label": "read_with_bigger_buf",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_with_bigger_buf () { let mut seq = Sequence :: new () ; let mut file = MockFile :: default () ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. 4] . copy_from_slice (& HELLO [.. 4]) ; Ok (4) }) ; file . expect_inner_read () . once () . in_sequence (& mut seq) . returning (| buf | { buf [0 .. HELLO . len () - 4] . copy_from_slice (& HELLO [4 ..]) ; Ok (HELLO . len () - 4) }) ; let mut file = File :: from_std (file) ; { let mut buf = [0 ; 4] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; } pool :: run_one () ; { let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 4) ; assert_eq ! (& buf [.. n] , & HELLO [.. n]) ; } let mut buf = [0 ; 32] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , 10) ; assert_eq ! (& buf [.. n] , & HELLO [4 ..]) ; assert_eq ! (0 , pool :: len ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "AssertDrop",
                        "label": "AssertDrop",
                        "kind": "Struct",
                        "signature": "struct AssertDrop",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "CtrlCStream",
                        "label": "CtrlCStream",
                        "kind": "Struct",
                        "signature": "struct CtrlCStream",
                        "file_path": "tokio-stream/src/wrappers/signal_windows.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Reader",
                        "label": "Reader",
                        "kind": "Struct",
                        "signature": "struct Reader",
                        "file_path": "tokio-util/tests/io_reader_stream.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "pin",
                        "label": "pin",
                        "kind": "Function",
                        "signature": "fn # [test] fn pin () { block_on (async { let future = my_async_fn () ; tokio :: pin ! (future) ; (& mut future) . await }) ; } . sig",
                        "file_path": "tests-integration/tests/macros_pin.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "schedule",
                        "label": "schedule",
                        "kind": "Function",
                        "signature": "fn unsafe fn schedule < S : Schedule > (ptr : NonNull < Header >) { use crate :: runtime :: task :: { Notified , Task } ; let scheduler = Header :: get_scheduler :: < S > (ptr) ; scheduler . as_ref () . schedule (Notified (Task :: from_raw (ptr . cast ()))) ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Op",
                        "label": "Op",
                        "kind": "Struct",
                        "signature": "struct Op",
                        "file_path": "tokio/src/runtime/driver/op.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "async_block",
                        "label": "async_block",
                        "kind": "Function",
                        "signature": "fn # [test] fn async_block () { assert_eq ! (4 , block_on (async { 4 })) ; } . sig",
                        "file_path": "tokio-test/tests/block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "trace_owned",
                        "label": "trace_owned",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Trace the `OwnedTasks`.\"] # [doc = \"\"] # [doc = \" # Preconditions\"] # [doc = \"\"] # [doc = \" This helper presumes exclusive access to each task. The tasks must not exist\"] # [doc = \" in any other queue.\"] fn trace_owned < S : Schedule > (owned : & OwnedTasks < S > , dequeued : Vec < Notified < S > >) -> Vec < (Id , Trace) > { let mut tasks = dequeued ; owned . for_each (| task | { if let Some (notified) = task . notify_for_tracing () { tasks . push (notified) ; } }) ; tasks . into_iter () . map (| task | { let local_notified = owned . assert_owner (task) ; let id = local_notified . task . id () ; let (() , trace) = Trace :: capture (| | local_notified . run ()) ; (id , trace) }) . collect () } . sig",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_is_terminated_rx_close",
                        "label": "receiver_is_terminated_rx_close",
                        "kind": "Function",
                        "signature": "fn # [test] fn receiver_is_terminated_rx_close () { let (_tx , mut rx) = oneshot :: channel :: < i32 > () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before closing\") ; rx . close () ; assert ! (! rx . is_terminated () , \"channel is NOT terminated before closing\") ; let mut task = task :: spawn (()) ; let poll = task . enter (| cx , _ | Pin :: new (& mut rx) . poll (cx)) ; assert_ready_err ! (poll) ; assert ! (rx . is_terminated () , \"channel IS terminated after value is read\") ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_abort_all",
                        "label": "test_join_queue_abort_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_join_queue_abort_all () { let mut queue : JoinQueue < () > = JoinQueue :: new () ; for _ in 0 .. 5 { queue . spawn (futures :: future :: pending ()) ; } for _ in 0 .. 5 { queue . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; queue . abort_all () ; assert_eq ! (queue . len () , 10) ; let mut count = 0 ; while let Some (res) = queue . join_next () . await { if count < 5 { assert ! (res . unwrap_err () . is_cancelled ()) ; } else { assert ! (res . is_ok ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert ! (queue . is_empty ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duplex_is_cooperative",
                        "label": "duplex_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn duplex_is_cooperative () { let (mut tx , mut rx) = tokio :: io :: duplex (1024 * 8) ; tokio :: select ! { biased ; _ = async { loop { let buf = [3u8 ; 4096] ; tx . write_all (& buf) . await . unwrap () ; let mut buf = [0u8 ; 4096] ; let _ = rx . read (& mut buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Notify",
                        "label": "Notify",
                        "kind": "Struct",
                        "signature": "struct Notify",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "cancel_only_all_descendants",
                        "label": "cancel_only_all_descendants",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_only_all_descendants () { let (waker , wake_counter) = new_count_waker () ; let parent_token = CancellationToken :: new () ; let token = parent_token . child_token () ; let sibling_token = parent_token . child_token () ; let child1_token = token . child_token () ; let child2_token = token . child_token () ; let grandchild_token = child1_token . child_token () ; let grandchild2_token = child1_token . child_token () ; let great_grandchild_token = grandchild_token . child_token () ; assert ! (! parent_token . is_cancelled ()) ; assert ! (! token . is_cancelled ()) ; assert ! (! sibling_token . is_cancelled ()) ; assert ! (! child1_token . is_cancelled ()) ; assert ! (! child2_token . is_cancelled ()) ; assert ! (! grandchild_token . is_cancelled ()) ; assert ! (! grandchild2_token . is_cancelled ()) ; assert ! (! great_grandchild_token . is_cancelled ()) ; let parent_fut = parent_token . cancelled () ; let fut = token . cancelled () ; let sibling_fut = sibling_token . cancelled () ; let child1_fut = child1_token . cancelled () ; let child2_fut = child2_token . cancelled () ; let grandchild_fut = grandchild_token . cancelled () ; let grandchild2_fut = grandchild2_token . cancelled () ; let great_grandchild_fut = great_grandchild_token . cancelled () ; pin ! (parent_fut) ; pin ! (fut) ; pin ! (sibling_fut) ; pin ! (child1_fut) ; pin ! (child2_fut) ; pin ! (grandchild_fut) ; pin ! (grandchild2_fut) ; pin ! (great_grandchild_fut) ; assert_eq ! (Poll :: Pending , parent_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , sibling_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , child1_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , child2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , grandchild2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Pending , great_grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 0) ; token . cancel () ; assert_eq ! (wake_counter , 6) ; assert ! (! parent_token . is_cancelled ()) ; assert ! (token . is_cancelled ()) ; assert ! (! sibling_token . is_cancelled ()) ; assert ! (child1_token . is_cancelled ()) ; assert ! (child2_token . is_cancelled ()) ; assert ! (grandchild_token . is_cancelled ()) ; assert ! (grandchild2_token . is_cancelled ()) ; assert ! (great_grandchild_token . is_cancelled ()) ; assert_eq ! (Poll :: Ready (()) , fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , child1_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , child2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , grandchild2_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (Poll :: Ready (()) , great_grandchild_fut . as_mut () . poll (& mut Context :: from_waker (& waker))) ; assert_eq ! (wake_counter , 6) ; } . sig",
                        "file_path": "tokio-util/tests/sync_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "occupied_bit",
                        "label": "occupied_bit",
                        "kind": "Function",
                        "signature": "fn fn occupied_bit (slot : usize) -> u64 { 1 << slot } . sig",
                        "file_path": "tokio-util/src/time/wheel/level.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_exists",
                        "label": "try_exists",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_exists () { let dir = tempdir () . unwrap () ; let existing_path = dir . path () . join (\"foo.txt\") ; fs :: write (& existing_path , b\"Hello File!\") . await . unwrap () ; let nonexisting_path = dir . path () . join (\"bar.txt\") ; assert ! (fs :: try_exists (existing_path) . await . unwrap ()) ; assert ! (! fs :: try_exists (nonexisting_path) . await . unwrap ()) ; # [cfg (all (unix , not (any (target_os = \"freebsd\" , all (tokio_unstable , feature = \"io-uring\")))))] { use std :: os :: unix :: prelude :: PermissionsExt ; let permission_denied_directory_path = dir . path () . join (\"baz\") ; fs :: create_dir (& permission_denied_directory_path) . await . unwrap () ; let permission_denied_file_path = permission_denied_directory_path . join (\"baz.txt\") ; fs :: write (& permission_denied_file_path , b\"Hello File!\") . await . unwrap () ; let mut perms = tokio :: fs :: metadata (& permission_denied_directory_path) . await . unwrap () . permissions () ; perms . set_mode (0o244) ; fs :: set_permissions (& permission_denied_directory_path , perms) . await . unwrap () ; let permission_denied_result = fs :: try_exists (permission_denied_file_path) . await ; assert_eq ! (permission_denied_result . err () . unwrap () . kind () , std :: io :: ErrorKind :: PermissionDenied) ; } } . sig",
                        "file_path": "tokio/tests/fs_try_exists.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Config",
                        "label": "Config",
                        "kind": "Struct",
                        "signature": "struct Config",
                        "file_path": "tokio/src/runtime/config.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_cell_new_with",
                        "label": "drop_cell_new_with",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_cell_new_with () { let fooer = DropCounter :: new () ; { let once_cell = SetOnce :: new_with (Some (fooer . clone ())) ; assert ! (once_cell . initialized ()) ; } fooer . assert_num_drops (1) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cat",
                        "label": "cat",
                        "kind": "Function",
                        "signature": "fn fn cat () -> Command { let mut cmd = Command :: new (env ! (\"CARGO_BIN_EXE_test-cat\")) ; cmd . stdin (Stdio :: piped ()) . stdout (Stdio :: piped ()) ; cmd } . sig",
                        "file_path": "tests-integration/tests/process_stdio.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "budget_exhaustion_yield",
                        "label": "budget_exhaustion_yield",
                        "kind": "Function",
                        "signature": "fn # [test] fn budget_exhaustion_yield () { let rt = current_thread () ; let metrics = rt . metrics () ; assert_eq ! (0 , metrics . budget_forced_yield_count ()) ; let mut did_yield = false ; rt . block_on (poll_fn (| cx | loop { if did_yield { return Poll :: Ready (()) ; } let fut = consume_budget () ; tokio :: pin ! (fut) ; if fut . poll (cx) . is_pending () { did_yield = true ; return Poll :: Pending ; } })) ; assert_eq ! (1 , rt . metrics () . budget_forced_yield_count ()) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_ids_match_current_thread",
                        "label": "task_ids_match_current_thread",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_ids_match_current_thread () { let (tx , rx) = oneshot :: channel () ; let handle = tokio :: spawn (async { let id = rx . await . unwrap () ; assert_eq ! (id , task :: id ()) ; }) ; tx . send (handle . id ()) . unwrap () ; handle . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_block_in_place3",
                        "label": "test_block_in_place3",
                        "kind": "Function",
                        "signature": "fn # [should_panic] # [tokio :: main (flavor = \"current_thread\")] # [test] async fn test_block_in_place3 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "normal_or_miri",
                        "label": "normal_or_miri",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (loom))] fn normal_or_miri < T > (normal : T , miri : T) -> T { if cfg ! (miri) { miri } else { normal } } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mk_runtime",
                        "label": "mk_runtime",
                        "kind": "Function",
                        "signature": "fn fn mk_runtime (num_threads : usize) -> Runtime { runtime :: Builder :: new_multi_thread () . worker_threads (num_threads) . build () . unwrap () } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_multi_thread/yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "copy_mem_to_mem",
                        "label": "copy_mem_to_mem",
                        "kind": "Function",
                        "signature": "fn fn copy_mem_to_mem (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_mem_to_mem\" , | b | { b . iter (| | { let task = | | async { let mut source = repeat (0) . take (SOURCE_SIZE) ; let mut dest = Vec :: new () ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_many_unbounded",
                        "label": "send_recv_many_unbounded",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn send_recv_many_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < i32 > () ; let mut buffer : Vec < i32 > = Vec :: new () ; rx . recv_many (& mut buffer , 0) . await ; assert_eq ! (0 , buffer . len ()) ; assert_ok ! (tx . send (7)) ; assert_ok ! (tx . send (13)) ; assert_ok ! (tx . send (100)) ; assert_ok ! (tx . send (1002)) ; rx . recv_many (& mut buffer , 0) . await ; assert_eq ! (0 , buffer . len ()) ; let mut count = 0 ; while count < 4 { count += rx . recv_many (& mut buffer , 1) . await ; } assert_eq ! (count , 4) ; assert_eq ! (vec ! [7 , 13 , 100 , 1002] , buffer) ; let final_capacity = buffer . capacity () ; assert ! (final_capacity > 0) ; buffer . clear () ; assert_ok ! (tx . send (5)) ; assert_ok ! (tx . send (6)) ; assert_ok ! (tx . send (7)) ; assert_ok ! (tx . send (2)) ; count = rx . recv_many (& mut buffer , 32) . await ; assert_eq ! (final_capacity , buffer . capacity ()) ; assert_eq ! (count , 4) ; assert_eq ! (vec ! [5 , 6 , 7 , 2] , buffer) ; drop (tx) ; assert_eq ! (0 , rx . recv_many (& mut buffer , 4) . await) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "trace_leaf",
                        "label": "trace_leaf",
                        "kind": "Function",
                        "signature": "fn # [doc = \" If this is a sub-invocation of [`Trace::capture`], capture a backtrace.\"] # [doc = \"\"] # [doc = \" The captured backtrace will be returned by [`Trace::capture`].\"] # [doc = \"\"] # [doc = \" Invoking this function does nothing when it is not a sub-invocation\"] # [doc = \" [`Trace::capture`].\"] # [inline (never)] pub (crate) fn trace_leaf (cx : & mut task :: Context < '_ >) -> Poll < () > { let did_trace = unsafe { Context :: try_with_current (| context_cell | { if let Some (mut collector) = context_cell . collector . take () { let mut frames = vec ! [] ; let mut above_leaf = false ; if let Some (active_frame) = context_cell . active_frame . get () { let active_frame = active_frame . as_ref () ; backtrace :: trace (| frame | { let below_root = ! ptr :: eq (frame . symbol_address () , active_frame . inner_addr) ; if above_leaf && below_root { frames . push (frame . to_owned () . into ()) ; } if ptr :: eq (frame . symbol_address () , trace_leaf as * const _) { above_leaf = true ; } below_root }) ; } collector . backtraces . push (frames) ; context_cell . collector . set (Some (collector)) ; true } else { false } }) . unwrap_or (false) } ; if did_trace { context :: with_scheduler (| scheduler | { if let Some (scheduler) = scheduler { match scheduler { scheduler :: Context :: CurrentThread (s) => s . defer . defer (cx . waker ()) , # [cfg (feature = \"rt-multi-thread\")] scheduler :: Context :: MultiThread (s) => s . defer . defer (cx . waker ()) , } } }) ; Poll :: Pending } else { Poll :: Ready (()) } } . sig",
                        "file_path": "tokio/src/runtime/task/trace/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Pending",
                        "label": "Pending",
                        "kind": "Struct",
                        "signature": "struct Pending",
                        "file_path": "tokio-stream/src/pending.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "inc_num_notify_waiters_calls",
                        "label": "inc_num_notify_waiters_calls",
                        "kind": "Function",
                        "signature": "fn fn inc_num_notify_waiters_calls (data : usize) -> usize { data + (1 << NOTIFY_WAITERS_SHIFT) } . sig",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bytes_encoder",
                        "label": "bytes_encoder",
                        "kind": "Function",
                        "signature": "fn # [test] fn bytes_encoder () { let mut codec = BytesCodec :: new () ; # [cfg (target_pointer_width = \"64\")] const INLINE_CAP : usize = 4 * 8 - 1 ; # [cfg (target_pointer_width = \"32\")] const INLINE_CAP : usize = 4 * 4 - 1 ; let mut buf = BytesMut :: new () ; codec . encode (Bytes :: from_static (& [0 ; INLINE_CAP + 1]) , & mut buf) . unwrap () ; const INITIAL_CAPACITY : usize = 8 * 1024 ; let mut buf = BytesMut :: with_capacity (INITIAL_CAPACITY) ; codec . encode (Bytes :: from_static (& [0 ; INITIAL_CAPACITY + 1]) , & mut buf) . unwrap () ; codec . encode (BytesMut :: from (& b\"hello\" [..]) , & mut buf) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "iter",
                        "label": "iter",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Converts an `Iterator` into a `Stream` which is always ready\"] # [doc = \" to yield the next value.\"] # [doc = \"\"] # [doc = \" Iterators in Rust don't express the ability to block, so this adapter\"] # [doc = \" simply always calls `iter.next()` and returns that.\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" # async fn dox() {\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" let mut stream = stream::iter(vec![17, 19]);\"] # [doc = \"\"] # [doc = \" assert_eq!(stream.next().await, Some(17));\"] # [doc = \" assert_eq!(stream.next().await, Some(19));\"] # [doc = \" assert_eq!(stream.next().await, None);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub fn iter < I > (i : I) -> Iter < I :: IntoIter > where I : IntoIterator , { Iter { iter : i . into_iter () , yield_amt : 0 , } } . sig",
                        "file_path": "tokio-stream/src/iter.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_state",
                        "label": "test_state",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_state () { assert_eq ! (0 , UNPARK_MASK & SEARCH_MASK) ; assert_eq ! (0 , ! (UNPARK_MASK | SEARCH_MASK)) ; let state = State :: new (10) ; assert_eq ! (10 , state . num_unparked ()) ; assert_eq ! (0 , state . num_searching ()) ; } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/idle.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_twice_before_dispatch",
                        "label": "write_twice_before_dispatch",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_twice_before_dispatch () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| buf | Ok (buf . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| buf | Ok (buf . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . write (FOO)) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; let mut t = task :: spawn (file . flush ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (pool :: len () , 1) ; pool :: run_one () ; assert ! (t . is_woken ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "canonicalize_root_dir_unix",
                        "label": "canonicalize_root_dir_unix",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (unix)] async fn canonicalize_root_dir_unix () { assert_eq ! (fs :: canonicalize (\"/.\") . await . unwrap () . to_str () . unwrap () , \"/\") ; } . sig",
                        "file_path": "tokio/tests/fs_canonicalize_dir.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "resume_lets_time_move_forward_instead_of_resetting_it",
                        "label": "resume_lets_time_move_forward_instead_of_resetting_it",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn resume_lets_time_move_forward_instead_of_resetting_it () { let start = Instant :: now () ; time :: pause () ; time :: advance (Duration :: from_secs (10)) . await ; let advanced_by_ten_secs = Instant :: now () ; assert ! (advanced_by_ten_secs - start > Duration :: from_secs (10)) ; assert ! (advanced_by_ten_secs - start < Duration :: from_secs (11)) ; time :: resume () ; assert ! (advanced_by_ten_secs < Instant :: now ()) ; assert ! (Instant :: now () - advanced_by_ten_secs < Duration :: from_secs (1)) ; } . sig",
                        "file_path": "tokio/tests/test_clock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Local",
                        "label": "Local",
                        "kind": "Struct",
                        "signature": "struct Local",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "change_waker",
                        "label": "change_waker",
                        "kind": "Function",
                        "signature": "fn # [test] fn change_waker () { model (| | { let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , handle_ . inner . driver () . clock () . now () + Duration :: from_secs (1) ,) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; }) ; thread :: yield_now () ; let time = handle . inner . driver () . time () ; let clock = handle . inner . driver () . clock () ; time . process_at_time (time . time_source () . now (clock) + 2_000_000_000) ; jh . join () . unwrap () ; }) } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_error_debug",
                        "label": "test_join_error_debug",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that a `JoinError` with a panic payload prints the expected text from `Debug`.\"] # [test] # [cfg (panic = \"unwind\")] fn test_join_error_debug () { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (async move { let join_err = tokio :: spawn (async move { let value = 1234 ; panic ! (\"Format-args payload: {value}\") }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), \\\"Format-args payload: 1234\\\", ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { panic ! (\"Const payload\") }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), \\\"Const payload\\\", ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; let join_err = tokio :: spawn (async move { std :: panic :: panic_any (1234i32) }) . await . unwrap_err () ; let join_err_str = format ! (\"{join_err:?}\") ; assert ! (join_err_str . starts_with (\"JoinError::Panic(Id(\") && join_err_str . ends_with (\"), ...)\") , \"Unexpected join_err_str {join_err_str:?}\") ; }) ; } . sig",
                        "file_path": "tokio/tests/task_abort.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "incomplete_flush_followed_by_write",
                        "label": "incomplete_flush_followed_by_write",
                        "kind": "Function",
                        "signature": "fn # [test] fn incomplete_flush_followed_by_write () { let mut file = MockFile :: default () ; let mut seq = Sequence :: new () ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (HELLO)) . returning (| _ | Ok (HELLO . len ())) ; file . expect_inner_write () . once () . in_sequence (& mut seq) . with (eq (FOO)) . returning (| _ | Ok (FOO . len ())) ; let mut file = File :: from_std (file) ; let mut t = task :: spawn (file . write (HELLO)) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; let mut t = task :: spawn (file . flush ()) ; assert_pending ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . write (FOO)) ; assert_ready_ok ! (t . poll ()) ; pool :: run_one () ; let mut t = task :: spawn (file . flush ()) ; assert_ready_ok ! (t . poll ()) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stall",
                        "label": "stall",
                        "kind": "Function",
                        "signature": "fn fn stall () { let now = Instant :: now () ; while now . elapsed () < STALL_DUR { std :: thread :: yield_now () ; } } . sig",
                        "file_path": "benches/rt_multi_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_abort_handle1",
                        "label": "drop_abort_handle1",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_abort_handle1 () { let (ad , handle) = AssertDrop :: new () ; let (notified , join) = unowned (async { drop (ad) ; unreachable ! () } , NoopSchedule , Id :: next () , SpawnLocation :: capture () ,) ; let abort = join . abort_handle () ; drop (join) ; handle . assert_not_dropped () ; drop (notified) ; handle . assert_not_dropped () ; drop (abort) ; handle . assert_dropped () ; } . sig",
                        "file_path": "tokio/src/runtime/tests/task.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Kill",
                        "label": "Kill",
                        "kind": "Trait",
                        "signature": "trait Kill",
                        "file_path": "tokio/src/process/kill.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "shutdown_runtime_while_performing_io_uring_ops",
                        "label": "shutdown_runtime_while_performing_io_uring_ops",
                        "kind": "Function",
                        "signature": "fn # [test] fn shutdown_runtime_while_performing_io_uring_ops () { fn run (rt : Runtime) { let (tx , rx) = mpsc :: channel () ; let (done_tx , done_rx) = mpsc :: channel () ; let (_tmp , path) = create_tmp_files (1) ; rt . spawn (async move { let path = path [0] . clone () ; loop { let path = path . clone () ; tokio :: spawn (async move { let mut opt = OpenOptions :: new () ; opt . read (true) ; opt . open (& path) . await . unwrap () ; }) ; tokio :: task :: yield_now () . await ; } }) ; std :: thread :: spawn (move | | { let rt : Runtime = rx . recv () . unwrap () ; rt . shutdown_timeout (Duration :: from_millis (300)) ; done_tx . send (()) . unwrap () ; }) ; tx . send (rt) . unwrap () ; done_rx . recv () . unwrap () ; } for rt in rt_combinations () { run (rt ()) ; } } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty",
                        "label": "empty",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a stream that yields nothing.\"] # [doc = \"\"] # [doc = \" The returned stream is immediately ready and returns `None`. Use\"] # [doc = \" [`stream::pending()`](super::pending()) to obtain a stream that is never\"] # [doc = \" ready.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" Basic usage:\"] # [doc = \"\"] # [doc = \" ```\"] # [doc = \" use tokio_stream::{self as stream, StreamExt};\"] # [doc = \"\"] # [doc = \" # #[tokio::main(flavor = \\\"current_thread\\\")]\"] # [doc = \" # async fn main() {\"] # [doc = \" let mut none = stream::empty::<i32>();\"] # [doc = \"\"] # [doc = \" assert_eq!(None, none.next().await);\"] # [doc = \" # }\"] # [doc = \" ```\"] pub const fn empty < T > () -> Empty < T > { Empty (PhantomData) } . sig",
                        "file_path": "tokio-stream/src/empty.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "kill_on_drop",
                        "label": "kill_on_drop",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn kill_on_drop () { let mut cmd = Command :: new (\"bash\") ; cmd . args ([\"-c\" , \"\n       # Fork another child that won't get killed\n       sh -c 'sleep 1; echo child ran' &\n       disown -a\n\n       # Await our death\n       sleep 5\n       echo hello from beyond the grave\n    \" ,]) ; let e = cmd . kill_on_drop (true) . stdout (Stdio :: piped ()) . spawn () ; if e . is_err () && e . as_ref () . unwrap_err () . kind () == ErrorKind :: NotFound { println ! (\"bash not available; skipping test\") ; return ; } let mut child = e . unwrap () ; sleep (Duration :: from_secs (2)) . await ; let mut out = child . stdout . take () . unwrap () ; drop (child) ; let mut msg = String :: new () ; assert_ok ! (out . read_to_string (& mut msg) . await) ; assert_eq ! (\"child ran\\n\" , msg) ; } . sig",
                        "file_path": "tokio/tests/process_kill_on_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "start_send_past_cap",
                        "label": "start_send_past_cap",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn start_send_past_cap () { use std :: future :: Future ; let mut t1 = tokio_test :: task :: spawn (()) ; let (tx1 , mut rx) = mpsc :: channel (1) ; let tx2 = tx1 . clone () ; assert_ok ! (tx1 . try_send (())) ; let mut r1 = Box :: pin (tx1 . reserve ()) ; t1 . enter (| cx , _ | assert_pending ! (r1 . as_mut () . poll (cx))) ; { let mut r2 = tokio_test :: task :: spawn (tx2 . reserve ()) ; assert_pending ! (r2 . poll ()) ; drop (r1) ; assert ! (rx . recv () . await . is_some ()) ; assert ! (r2 . is_woken ()) ; assert ! (! t1 . is_woken ()) ; } drop (tx1) ; drop (tx2) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "abort_all",
                        "label": "abort_all",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn abort_all () { let mut set : JoinSet < () > = JoinSet :: new () ; for _ in 0 .. 5 { set . spawn (futures :: future :: pending ()) ; } for _ in 0 .. 5 { set . spawn (async { tokio :: time :: sleep (Duration :: from_secs (1)) . await ; }) ; } tokio :: time :: sleep (Duration :: from_secs (2)) . await ; set . abort_all () ; assert_eq ! (set . len () , 10) ; let mut count = 0 ; while let Some (res) = set . join_next () . await { if let Err (err) = res { assert ! (err . is_cancelled ()) ; } count += 1 ; } assert_eq ! (count , 10) ; assert_eq ! (set . len () , 0) ; } . sig",
                        "file_path": "tokio/tests/task_join_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiter_decoder_max_length_bursts",
                        "label": "any_delimiter_decoder_max_length_bursts",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiter_decoder_max_length_bursts () { const MAX_LENGTH : usize = 11 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk \") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"too l\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; buf . put_slice (b\"ong\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "callbacks_fire_multi_thread",
                        "label": "callbacks_fire_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [test] fn callbacks_fire_multi_thread () { let poll_start_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_stop_counter = Arc :: new (AtomicUsize :: new (0)) ; let poll_start = poll_start_counter . clone () ; let poll_stop = poll_stop_counter . clone () ; let before_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let after_task_poll_callback_task_id : Arc < Mutex < Option < tokio :: task :: Id > > > = Arc :: new (Mutex :: new (None)) ; let before_task_poll_callback_task_id_ref = Arc :: clone (& before_task_poll_callback_task_id) ; let after_task_poll_callback_task_id_ref = Arc :: clone (& after_task_poll_callback_task_id) ; let rt = tokio :: runtime :: Builder :: new_multi_thread () . enable_all () . on_before_task_poll (move | task_meta | { before_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_start_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . on_after_task_poll (move | task_meta | { after_task_poll_callback_task_id_ref . lock () . unwrap () . replace (task_meta . id ()) ; poll_stop_counter . fetch_add (1 , std :: sync :: atomic :: Ordering :: Relaxed) ; }) . build () . unwrap () ; let task = rt . spawn (async { yield_now () . await ; yield_now () . await ; yield_now () . await ; }) ; let spawned_task_id = task . id () ; rt . block_on (task) . expect (\"task should succeed\") ; drop (rt) ; assert_eq ! (before_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; assert_eq ! (after_task_poll_callback_task_id . lock () . unwrap () . unwrap () , spawned_task_id) ; let actual_count = 4 ; assert_eq ! (poll_start . load (std :: sync :: atomic :: Ordering :: Relaxed) , actual_count , \"unexpected number of poll starts\") ; assert_eq ! (poll_stop . load (std :: sync :: atomic :: Ordering :: Relaxed) , actual_count , \"unexpected number of poll stops\") ; } . sig",
                        "file_path": "tokio/tests/rt_poll_callbacks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_thread_scheduler_sleep",
                        "label": "single_thread_scheduler_sleep",
                        "kind": "Function",
                        "signature": "fn fn single_thread_scheduler_sleep (c : & mut Criterion) { do_sleep_test (c , 1 , \"single_thread_sleep\") ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "HandleCell",
                        "label": "HandleCell",
                        "kind": "Struct",
                        "signature": "struct HandleCell",
                        "file_path": "tokio/src/runtime/context/current.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "read_with_handle",
                        "label": "read_with_handle",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_with_handle () { let (mut mock , mut handle) = Builder :: new () . build_with_handle () ; handle . read (b\"hello \") ; handle . read (b\"world!\") ; let mut buf = vec ! [0 ; 6] ; mock . read_exact (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [..] , b\"hello \") ; mock . read_exact (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [..] , b\"world!\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new_capacity_zero",
                        "label": "new_capacity_zero",
                        "kind": "Function",
                        "signature": "fn # [test] fn new_capacity_zero () { let map = StreamMap :: < & str , stream :: Pending < () > > :: new () ; assert_eq ! (0 , map . capacity ()) ; assert ! (map . keys () . next () . is_none ()) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ByteCodec",
                        "label": "ByteCodec",
                        "kind": "Struct",
                        "signature": "struct ByteCodec",
                        "file_path": "tokio-util/tests/udp.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "LinesCodec",
                        "label": "LinesCodec",
                        "kind": "Struct",
                        "signature": "struct LinesCodec",
                        "file_path": "tokio-util/src/codec/lines_codec.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "ready",
                        "label": "ready",
                        "kind": "Function",
                        "signature": "fn fn ready () -> Poll < () > { Poll :: Ready (()) } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_sender_dropped",
                        "label": "size_hint_sender_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_sender_dropped () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; drop (tx) ; assert_eq ! (stream . size_hint () , (2 , Some (2))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , Some (1))) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , Some (0))) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt_curr_spawn_many_remote_idle",
                        "label": "rt_curr_spawn_many_remote_idle",
                        "kind": "Function",
                        "signature": "fn fn rt_curr_spawn_many_remote_idle (c : & mut Criterion) { let rt = rt () ; let rt_handle = rt . handle () ; let mut handles = Vec :: with_capacity (NUM_SPAWN) ; c . bench_function (\"spawn_many_remote_idle\" , | b | { b . iter (| | { for _ in 0 .. NUM_SPAWN { handles . push (rt_handle . spawn (async { })) ; } rt . block_on (async { for handle in handles . drain (..) { handle . await . unwrap () ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/rt_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "do_timeout_test",
                        "label": "do_timeout_test",
                        "kind": "Function",
                        "signature": "fn fn do_timeout_test (c : & mut Criterion , workers : usize , name : & str) { let runtime = build_run_time (workers) ; c . bench_function (name , | b | { b . iter_custom (| iters | { let start = Instant :: now () ; runtime . block_on (async { black_box (spawn_timeout_job (iters as usize , workers)) . await ; }) ; start . elapsed () }) }) ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "new_current_thread",
                        "label": "new_current_thread",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Create a new single threaded runtime\"] fn new_current_thread () -> Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/rt_handle_block_on.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_dir_all",
                        "label": "create_dir_all",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Recursively creates a directory and all of its parent components if they\"] # [doc = \" are missing.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::create_dir_all`].\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `mkdir` function on Unix\"] # [doc = \" and the `CreateDirectory` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * If any directory in the path specified by `path` does not already exist\"] # [doc = \"   and it could not be created otherwise. The specific error conditions for\"] # [doc = \"   when a directory is being created (after it is determined to not exist) are\"] # [doc = \"   outlined by [`fs::create_dir`].\"] # [doc = \"\"] # [doc = \" Notable exception is made for situations where any of the directories\"] # [doc = \" specified in the `path` could not be created as it was being created concurrently.\"] # [doc = \" Such cases are considered to be successful. That is, calling `create_dir_all`\"] # [doc = \" concurrently from multiple threads or processes is guaranteed not to fail\"] # [doc = \" due to a race condition with itself.\"] # [doc = \"\"] # [doc = \" [`fs::create_dir`]: std::fs::create_dir\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     fs::create_dir_all(\\\"/some/dir\\\").await?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn create_dir_all (path : impl AsRef < Path >) -> io :: Result < () > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: create_dir_all (path)) . await } . sig",
                        "file_path": "tokio/src/fs/create_dir_all.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rt",
                        "label": "test_rt",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Marks async function to be executed by runtime, suitable to test environment\"] # [doc = \"\"] # [doc = \" ## Usage\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" #[tokio::test]\"] # [doc = \" async fn my_test() {\"] # [doc = \"     assert!(true);\"] # [doc = \" }\"] # [doc = \" ```\"] # [proc_macro_attribute] pub fn test_rt (args : TokenStream , item : TokenStream) -> TokenStream { entry :: test (args . into () , item . into () , false) . into () } . sig",
                        "file_path": "tokio-macros/src/lib.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Once",
                        "label": "Once",
                        "kind": "Struct",
                        "signature": "struct Once",
                        "file_path": "tokio-stream/src/once.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "smoke",
                        "label": "smoke",
                        "kind": "Function",
                        "signature": "fn # [test] fn smoke () { loom :: model (| | { let (tx , mut rx1) = watch :: channel (1) ; let mut rx2 = rx1 . clone () ; let mut rx3 = rx1 . clone () ; let mut rx4 = rx1 . clone () ; let mut rx5 = rx1 . clone () ; let th = thread :: spawn (move | | { tx . send (2) . unwrap () ; }) ; block_on (rx1 . changed ()) . unwrap () ; assert_eq ! (* rx1 . borrow () , 2) ; block_on (rx2 . changed ()) . unwrap () ; assert_eq ! (* rx2 . borrow () , 2) ; block_on (rx3 . changed ()) . unwrap () ; assert_eq ! (* rx3 . borrow () , 2) ; block_on (rx4 . changed ()) . unwrap () ; assert_eq ! (* rx4 . borrow () , 2) ; block_on (rx5 . changed ()) . unwrap () ; assert_eq ! (* rx5 . borrow () , 2) ; th . join () . unwrap () ; }) } . sig",
                        "file_path": "tokio/src/sync/tests/loom_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "c",
                        "label": "c",
                        "kind": "Function",
                        "signature": "fn # [inline (never)] async fn c () { loop { black_box (tokio :: task :: yield_now ()) . await } } . sig",
                        "file_path": "tokio/tests/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_c () -> io :: Result < RxFuture > { panic ! () } . sig",
                        "file_path": "tokio/src/signal/windows/stub.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_twice",
                        "label": "set_twice",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_twice () { static ONCE : SetOnce < u32 > = SetOnce :: const_new () ; let first = ONCE . set (5) ; assert_eq ! (first , Ok (())) ; let second = ONCE . set (6) ; assert ! (second . is_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_set_once.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_stream_open",
                        "label": "size_hint_stream_open",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn size_hint_stream_open () { let (tx , rx) = mpsc :: channel (4) ; tx . send (1) . await . unwrap () ; tx . send (2) . await . unwrap () ; let mut stream = ReceiverStream :: new (rx) ; assert_eq ! (stream . size_hint () , (2 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (1 , None)) ; stream . next () . await ; assert_eq ! (stream . size_hint () , (0 , None)) ; } . sig",
                        "file_path": "tokio-stream/tests/mpsc_bounded_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "do_sleep_test",
                        "label": "do_sleep_test",
                        "kind": "Function",
                        "signature": "fn fn do_sleep_test (c : & mut Criterion , workers : usize , name : & str) { let runtime = build_run_time (workers) ; c . bench_function (name , | b | { b . iter_custom (| iters | { let start = Instant :: now () ; runtime . block_on (async { black_box (spawn_sleep_job (iters as usize , workers)) . await ; }) ; start . elapsed () }) }) ; } . sig",
                        "file_path": "benches/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multi_rt",
                        "label": "multi_rt",
                        "kind": "Function",
                        "signature": "fn fn multi_rt (n : usize) -> Box < dyn Fn () -> Runtime > { Box :: new (move | | { Builder :: new_multi_thread () . worker_threads (n) . enable_all () . build () . unwrap () }) } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "panic_result_to_join_error",
                        "label": "panic_result_to_join_error",
                        "kind": "Function",
                        "signature": "fn fn panic_result_to_join_error (task_id : Id , res : Result < () , Box < dyn Any + Send + 'static > > ,) -> JoinError { match res { Ok (()) => JoinError :: cancelled (task_id) , Err (panic) => JoinError :: panic (task_id , panic) , } } . sig",
                        "file_path": "tokio/src/runtime/task/harness.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read",
                        "label": "read",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Reads the entire contents of a file into a bytes vector.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::read`].\"] # [doc = \"\"] # [doc = \" This is a convenience function for using [`File::open`] and [`read_to_end`]\"] # [doc = \" with fewer imports and without an intermediate variable. It pre-allocates a\"] # [doc = \" buffer based on the file size when available, so it is generally faster than\"] # [doc = \" reading into a vector created with `Vec::new()`.\"] # [doc = \"\"] # [doc = \" This operation is implemented by running the equivalent blocking operation\"] # [doc = \" on a separate thread pool using [`spawn_blocking`].\"] # [doc = \"\"] # [doc = \" [`File::open`]: super::File::open\"] # [doc = \" [`read_to_end`]: crate::io::AsyncReadExt::read_to_end\"] # [doc = \" [`spawn_blocking`]: crate::task::spawn_blocking\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error if `path` does not already exist.\"] # [doc = \" Other errors may also be returned according to [`OpenOptions::open`].\"] # [doc = \"\"] # [doc = \" [`OpenOptions::open`]: super::OpenOptions::open\"] # [doc = \"\"] # [doc = \" It will also return an error if it encounters while reading an error\"] # [doc = \" of a kind other than [`ErrorKind::Interrupted`].\"] # [doc = \"\"] # [doc = \" [`ErrorKind::Interrupted`]: std::io::ErrorKind::Interrupted\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \" use std::net::SocketAddr;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\"] # [doc = \"     let contents = fs::read(\\\"address.txt\\\").await?;\"] # [doc = \"     let foo: SocketAddr = String::from_utf8_lossy(&contents).parse()?;\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn read (path : impl AsRef < Path >) -> io :: Result < Vec < u8 > > { let path = path . as_ref () . to_owned () ; asyncify (move | | std :: fs :: read (path)) . await } . sig",
                        "file_path": "tokio/src/fs/read.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_single_frame_multi_packet",
                        "label": "read_single_frame_multi_packet",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_single_frame_multi_packet () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , data (b\"\\x00\\x09abc\") , data (b\"defghi\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_eq ! (io , b\"abcdefghi\") ; assert_done ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "configure_timestamping_socket",
                        "label": "configure_timestamping_socket",
                        "kind": "Function",
                        "signature": "fn # [cfg (target_os = \"linux\")] fn configure_timestamping_socket (udp_socket : & std :: net :: UdpSocket) -> std :: io :: Result < libc :: c_int > { let options = libc :: SOF_TIMESTAMPING_SOFTWARE | libc :: SOF_TIMESTAMPING_TX_SOFTWARE ; let res = unsafe { libc :: setsockopt (udp_socket . as_raw_fd () , libc :: SOL_SOCKET , libc :: SO_TIMESTAMP , & options as * const _ as * const libc :: c_void , std :: mem :: size_of_val (& options) as libc :: socklen_t ,) } ; if res == - 1 { Err (std :: io :: Error :: last_os_error ()) } else { Ok (res) } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TaskHooks",
                        "label": "TaskHooks",
                        "kind": "Struct",
                        "signature": "struct TaskHooks",
                        "file_path": "tokio/src/runtime/task_hooks.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "aborted_future_2",
                        "label": "aborted_future_2",
                        "kind": "Function",
                        "signature": "fn # [doc = \" This test is similar to `aborted_future_1` but this time the\"] # [doc = \" aborted future is waiting for the lock.\"] # [tokio :: test] # [cfg (feature = \"full\")] async fn aborted_future_2 () { use std :: time :: Duration ; use tokio :: time :: timeout ; let m1 : Arc < Mutex < usize > > = Arc :: new (Mutex :: new (0)) ; { let _lock = m1 . lock () . await ; { let m2 = m1 . clone () ; timeout (Duration :: from_millis (1u64) , async move { let _g = m2 . lock () . await ; }) . await . unwrap_err () ; } } timeout (Duration :: from_millis (1u64) , async move { let _g = m1 . lock () . await ; }) . await . expect (\"Mutex is locked\") ; } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_multi_notified_one",
                        "label": "notify_multi_notified_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_multi_notified_one () { let notify = Notify :: new () ; let mut notified1 = spawn (async { notify . notified () . await }) ; let mut notified2 = spawn (async { notify . notified () . await }) ; assert_pending ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; notify . notify_one () ; assert_ready ! (notified1 . poll ()) ; assert_pending ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "hard_link",
                        "label": "hard_link",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new hard link on the filesystem.\"] # [doc = \"\"] # [doc = \" This is an async version of [`std::fs::hard_link`].\"] # [doc = \"\"] # [doc = \" The `link` path will be a link pointing to the `original` path. Note that systems\"] # [doc = \" often require these two paths to both be located on the same filesystem.\"] # [doc = \"\"] # [doc = \" # Platform-specific behavior\"] # [doc = \"\"] # [doc = \" This function currently corresponds to the `link` function on Unix\"] # [doc = \" and the `CreateHardLink` function on Windows.\"] # [doc = \" Note that, this [may change in the future][changes].\"] # [doc = \"\"] # [doc = \" [changes]: https://doc.rust-lang.org/std/io/index.html#platform-specific-behavior\"] # [doc = \"\"] # [doc = \" # Errors\"] # [doc = \"\"] # [doc = \" This function will return an error in the following situations, but is not\"] # [doc = \" limited to just these cases:\"] # [doc = \"\"] # [doc = \" * The `original` path is not a file or doesn't exist.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```no_run\"] # [doc = \" use tokio::fs;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> std::io::Result<()> {\"] # [doc = \"     fs::hard_link(\\\"a.txt\\\", \\\"b.txt\\\").await?; // Hard link a.txt to b.txt\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub async fn hard_link (original : impl AsRef < Path > , link : impl AsRef < Path >) -> io :: Result < () > { let original = original . as_ref () . to_owned () ; let link = link . as_ref () . to_owned () ; asyncify (move | | std :: fs :: hard_link (original , link)) . await } . sig",
                        "file_path": "tokio/src/fs/hard_link.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_panicky_waker",
                        "label": "test_panicky_waker",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_panicky_waker () { use std :: panic ; use std :: ptr ; use std :: task :: { RawWaker , RawWakerVTable , Waker } ; static PANICKING_VTABLE : RawWakerVTable = RawWakerVTable :: new (| _ | panic ! (\"clone\") , | _ | () , | _ | () , | _ | ()) ; let panicking = unsafe { Waker :: from_raw (RawWaker :: new (ptr :: null () , & PANICKING_VTABLE)) } ; const NUM_NOTIFY : usize = 2 ; loom :: model (move | | { let chan = Arc :: new (Chan { num : AtomicUsize :: new (0) , task : AtomicWaker :: new () , }) ; for _ in 0 .. NUM_NOTIFY { let chan = chan . clone () ; thread :: spawn (move | | { chan . num . fetch_add (1 , Relaxed) ; chan . task . wake () ; }) ; } let _ = panic :: catch_unwind (| | chan . task . register_by_ref (& panicking)) ; block_on (poll_fn (move | cx | { chan . task . register_by_ref (cx . waker ()) ; if NUM_NOTIFY == chan . num . load (Relaxed) { return Ready (()) ; } Pending })) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_atomic_waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pending_first",
                        "label": "pending_first",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn pending_first () { let (tx1 , rx1) = mpsc :: unbounded_channel_stream () ; let (tx2 , rx2) = mpsc :: unbounded_channel_stream () ; let mut stream = task :: spawn (rx1 . chain (rx2)) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_pending ! (stream . poll_next ()) ; tx2 . send (2) . unwrap () ; assert ! (! stream . is_woken ()) ; assert_pending ! (stream . poll_next ()) ; tx1 . send (1) . unwrap () ; assert ! (stream . is_woken ()) ; assert_eq ! (Some (1) , assert_ready ! (stream . poll_next ())) ; assert_pending ! (stream . poll_next ()) ; drop (tx1) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert ! (stream . is_woken ()) ; assert_eq ! (Some (2) , assert_ready ! (stream . poll_next ())) ; assert_eq ! (stream . size_hint () , (0 , None)) ; drop (tx2) ; assert_eq ! (stream . size_hint () , (0 , None)) ; assert_eq ! (None , assert_ready ! (stream . poll_next ())) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "simple",
                        "label": "simple",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn simple () { let (send , mut recv) = channel (3) ; let mut send = PollSender :: new (send) ; for i in 1 ..= 3i32 { let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_ready_ok ! (reserve . poll ()) ; send . send_item (i) . unwrap () ; } let mut reserve = spawn (poll_fn (| cx | send . poll_reserve (cx))) ; assert_pending ! (reserve . poll ()) ; assert_eq ! (recv . recv () . await . unwrap () , 1) ; assert ! (reserve . is_woken ()) ; assert_ready_ok ! (reserve . poll ()) ; drop (recv) ; send . send_item (42) . unwrap () ; } . sig",
                        "file_path": "tokio-util/tests/mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_immediately",
                        "label": "reset_immediately",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn reset_immediately () { let start = Instant :: now () ; time :: advance (ms (1)) . await ; let mut i = task :: spawn (time :: interval_at (start , ms (300))) ; check_interval_poll ! (i , start , 0) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 300) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; i . reset_immediately () ; check_interval_poll ! (i , start , 401) ; time :: advance (ms (100)) . await ; check_interval_poll ! (i , start) ; time :: advance (ms (200)) . await ; check_interval_poll ! (i , start , 701) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "repeat_poll_read_is_cooperative",
                        "label": "repeat_poll_read_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn repeat_poll_read_is_cooperative () { tokio :: select ! { biased ; _ = async { loop { let mut buf = [0u8 ; 4096] ; tokio :: io :: repeat (0b101) . read_exact (& mut buf) . await . unwrap () ; } } => { } , _ = tokio :: task :: yield_now () => { } } } . sig",
                        "file_path": "tokio/tests/io_repeat.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_recv_close_while_empty_unbounded",
                        "label": "try_recv_close_while_empty_unbounded",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_recv_close_while_empty_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < () > () ; assert_eq ! (Err (TryRecvError :: Empty) , rx . try_recv ()) ; drop (tx) ; assert_eq ! (Err (TryRecvError :: Disconnected) , rx . try_recv ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "overflow",
                        "label": "overflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn overflow () { let (_ , mut local) = queue :: local () ; let inject = RefCell :: new (vec ! []) ; let mut stats = new_stats () ; for _ in 0 .. 257 { let (task , _) = super :: unowned (async { }) ; local . push_back_or_overflow (task , & inject , & mut stats) ; } cfg_unstable_metrics ! { assert_metrics ! (stats , overflow_count == 1) ; } let mut n = 0 ; n += inject . borrow_mut () . drain (..) . count () ; while local . pop () . is_some () { n += 1 ; } assert_eq ! (n , 257) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "unix_listener_from_std_panic_caller",
                        "label": "unix_listener_from_std_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] # [cfg (unix)] # [cfg_attr (miri , ignore)] fn unix_listener_from_std_panic_caller () -> Result < () , Box < dyn Error > > { use tokio :: net :: UnixListener ; let dir = tempfile :: tempdir () . unwrap () ; let sock_path = dir . path () . join (\"socket\") ; let std_listener = std :: os :: unix :: net :: UnixListener :: bind (sock_path) . unwrap () ; let panic_location_file = test_panic (| | { let rt = runtime_without_io () ; rt . block_on (async { let _ = UnixListener :: from_std (std_listener) ; }) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_weak_count_when_dropped",
                        "label": "sender_weak_count_when_dropped",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_weak_count_when_dropped () { let (tx , rx) = mpsc :: channel :: < () > (1) ; let weak = tx . downgrade () ; drop (weak) ; assert_eq ! (tx . weak_count () , 0) ; assert_eq ! (rx . sender_weak_count () , 0) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_future",
                        "label": "reset_future",
                        "kind": "Function",
                        "signature": "fn # [test] fn reset_future () { model (| | { let finished_early = Arc :: new (AtomicBool :: new (false)) ; let rt = rt (false) ; let handle = rt . handle () ; let handle_ = handle . clone () ; let finished_early_ = finished_early . clone () ; let start = handle . inner . driver () . clock () . now () ; let jh = thread :: spawn (move | | { let entry = TimerEntry :: new (handle_ . inner . clone () , start + Duration :: from_secs (1)) ; pin ! (entry) ; let _ = entry . as_mut () . poll_elapsed (& mut Context :: from_waker (futures :: task :: noop_waker_ref ())) ; entry . as_mut () . reset (start + Duration :: from_secs (2) , true) ; block_on (std :: future :: poll_fn (| cx | entry . as_mut () . poll_elapsed (cx))) . unwrap () ; finished_early_ . store (true , Ordering :: Relaxed) ; }) ; thread :: yield_now () ; let handle = handle . inner . driver () . time () ; handle . process_at_time (handle . time_source () . instant_to_tick (start + Duration :: from_millis (1500)) ,) ; assert ! (! finished_early . load (Ordering :: Relaxed)) ; handle . process_at_time (handle . time_source () . instant_to_tick (start + Duration :: from_millis (2500)) ,) ; jh . join () . unwrap () ; assert ! (finished_early . load (Ordering :: Relaxed)) ; }) } . sig",
                        "file_path": "tokio/src/runtime/time/tests/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reunite",
                        "label": "reunite",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn reunite (read : OwnedReadHalf , write : OwnedWriteHalf ,) -> Result < UnixStream , ReuniteError > { if Arc :: ptr_eq (& read . inner , & write . inner) { write . forget () ; Ok (Arc :: try_unwrap (read . inner) . expect (\"UnixStream: try_unwrap failed in reunite\")) } else { Err (ReuniteError (read , write)) } } . sig",
                        "file_path": "tokio/src/net/unix/split_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_downgrade_map",
                        "label": "try_downgrade_map",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn try_downgrade_map () { let lock = RwLock :: new (0) ; let write_guard = lock . write () . await ; let mut read_t = spawn (lock . read ()) ; assert_pending ! (read_t . poll ()) ; let write_guard = RwLockWriteGuard :: try_downgrade_map (write_guard , | _ | { assert_pending ! (read_t . poll ()) ; None :: < & () > }) . expect_err (\"downgrade didn't fail\") ; assert_pending ! (read_t . poll ()) ; let read_guard1 = RwLockWriteGuard :: try_downgrade_map (write_guard , | v | Some (v)) . expect (\"downgrade didn't succeed\") ; let read_guard2 = assert_ready ! (read_t . poll ()) ; assert_eq ! (&* read_guard1 as * const _ , &* read_guard2 as * const _) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "receiver_changed_is_cooperative",
                        "label": "receiver_changed_is_cooperative",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn receiver_changed_is_cooperative () { let (tx , mut rx) = watch :: channel (()) ; drop (tx) ; tokio :: select ! { biased ; _ = async { loop { assert ! (rx . changed () . await . is_err ()) ; } } => { } , _ = tokio :: task :: yield_now () => { } , } } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_hook_spawn_location_current_thread",
                        "label": "task_hook_spawn_location_current_thread",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Test that the correct spawn location is provided to the task hooks on a\"] # [doc = \" current thread runtime.\"] # [test] fn task_hook_spawn_location_current_thread () { let spawns = Arc :: new (AtomicUsize :: new (0)) ; let poll_starts = Arc :: new (AtomicUsize :: new (0)) ; let poll_ends = Arc :: new (AtomicUsize :: new (0)) ; let runtime = Builder :: new_current_thread () . on_task_spawn (mk_spawn_location_hook (\"(current_thread) on_task_spawn\" , & spawns ,)) . on_before_task_poll (mk_spawn_location_hook (\"(current_thread) on_before_task_poll\" , & poll_starts ,)) . on_after_task_poll (mk_spawn_location_hook (\"(current_thread) on_after_task_poll\" , & poll_ends ,)) . build () . unwrap () ; let task = runtime . spawn (async move { tokio :: task :: yield_now () . await }) ; runtime . block_on (async move { task . await . unwrap () ; tokio :: spawn (async move { }) . await . unwrap () ; for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; assert_eq ! (spawns . load (Ordering :: SeqCst) , 2) ; let poll_starts = poll_starts . load (Ordering :: SeqCst) ; assert ! (poll_starts > 2) ; assert_eq ! (poll_starts , poll_ends . load (Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/task_hooks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_threadpool_blocking_run",
                        "label": "local_threadpool_blocking_run",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool_blocking_run () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_blocking (| | { assert ! (! ON_RT_THREAD . with (| cell | cell . get ()) , \"blocking must not run on the local task set's thread\") ; }) . await . unwrap () ; assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) ; join . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_sleep_creates_span",
                        "label": "test_sleep_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_sleep_creates_span () { let sleep_span_id = expect :: id () ; let sleep_span = expect :: span () . with_id (sleep_span_id . clone ()) . named (\"runtime.resource\") . with_target (\"tokio::time::sleep\") ; let state_update = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"duration\") . and (expect :: field (\"duration.op\") . with_value (& \"override\")) ,) ; let async_op_span_id = expect :: id () ; let async_op_span = expect :: span () . with_id (async_op_span_id . clone ()) . named (\"runtime.resource.async_op\") . with_target (\"tokio::time::sleep\") ; let async_op_poll_span = expect :: span () . named (\"runtime.resource.async_op.poll\") . with_target (\"tokio::time::sleep\") ; let (subscriber , handle) = subscriber :: mock () . new_span (sleep_span . clone () . with_ancestry (expect :: is_explicit_root ())) . enter (sleep_span . clone ()) . event (state_update) . new_span (async_op_span . clone () . with_ancestry (expect :: has_contextual_parent (& sleep_span_id)) . with_fields (expect :: field (\"source\") . with_value (& \"Sleep::new_timeout\")) ,) . exit (sleep_span . clone ()) . enter (async_op_span . clone ()) . new_span (async_op_poll_span . clone () . with_ancestry (expect :: has_contextual_parent (& async_op_span_id)) ,) . exit (async_op_span . clone ()) . drop_span (async_op_span) . drop_span (async_op_poll_span) . drop_span (sleep_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; _ = tokio :: time :: sleep (Duration :: from_millis (7)) ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_time.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "it_works",
                        "label": "it_works",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn it_works () { let sem = Arc :: new (Semaphore :: new (1)) ; let mut poll_sem = PollSemaphore :: new (sem . clone ()) ; let permit = sem . acquire () . await . unwrap () ; let mut poll = semaphore_poll (& mut poll_sem) ; assert ! (poll . poll () . is_pending ()) ; drop (permit) ; assert ! (matches ! (poll . poll () , Poll :: Ready (Some (_)))) ; drop (poll) ; sem . close () ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; assert ! (semaphore_poll (& mut poll_sem) . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/poll_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_immediately_on_reopen",
                        "label": "notify_immediately_on_reopen",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_immediately_on_reopen () { let tracker = TaskTracker :: new () ; tracker . close () ; let mut wait = task :: spawn (tracker . wait ()) ; tracker . reopen () ; assert_ready ! (wait . poll ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_tracker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_read_output",
                        "label": "try_read_output",
                        "kind": "Function",
                        "signature": "fn unsafe fn try_read_output < T : Future , S : Schedule > (ptr : NonNull < Header > , dst : * mut () , waker : & Waker ,) { let out = & mut * (dst as * mut Poll < super :: Result < T :: Output > >) ; let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . try_read_output (out , waker) ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "any_delimiters_decoder_max_length",
                        "label": "any_delimiters_decoder_max_length",
                        "kind": "Function",
                        "signature": "fn # [test] fn any_delimiters_decoder_max_length () { const MAX_LENGTH : usize = 7 ; let mut codec = AnyDelimiterCodec :: new_with_max_length (b\",;\\n\\r\" . to_vec () , b\",\" . to_vec () , MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"chunk 1 is too long\\nchunk 2\\nchunk 3\\r\\nchunk 4\\n\\r\\n\") ; assert ! (codec . decode (buf) . is_err ()) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 2\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 3\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"chunk 4\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; let chunk = codec . decode (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"\" , chunk) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"k\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; let chunk = codec . decode_eof (buf) . unwrap () . unwrap () ; assert ! (chunk . len () <= MAX_LENGTH , \"{chunk:?}.len() <= {MAX_LENGTH:?}\") ; assert_eq ! (\"k\" , chunk) ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; assert_eq ! (None , codec . decode_eof (buf) . unwrap ()) ; buf . put_slice (b\"aaabbbcc\") ; assert ! (codec . decode (buf) . is_err ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "tango",
                        "label": "tango",
                        "kind": "Function",
                        "signature": "fn # [test] fn tango () { let b = Barrier :: new (2) ; let mut w1 = spawn (b . wait ()) ; assert_pending ! (w1 . poll ()) ; let mut w2 = spawn (b . wait ()) ; let wr2 = assert_ready ! (w2 . poll ()) ; let wr1 = assert_ready ! (w1 . poll ()) ; assert ! (wr1 . is_leader () || wr2 . is_leader ()) ; assert ! (! (wr1 . is_leader () && wr2 . is_leader ())) ; } . sig",
                        "file_path": "tokio/tests/sync_barrier.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PidfdReaperInner",
                        "label": "PidfdReaperInner",
                        "kind": "Struct",
                        "signature": "struct PidfdReaperInner",
                        "file_path": "tokio/src/process/unix/pidfd_reaper.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Interest",
                        "label": "Interest",
                        "kind": "Struct",
                        "signature": "struct Interest",
                        "file_path": "tokio/src/io/interest.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "normal_or_miri",
                        "label": "normal_or_miri",
                        "kind": "Function",
                        "signature": "fn const fn normal_or_miri (normal : usize , miri : usize) -> usize { if cfg ! (miri) { miri } else { normal } } . sig",
                        "file_path": "tokio/src/runtime/tests/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_block_in_place_block_on_spawn",
                        "label": "task_id_block_in_place_block_on_spawn",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn task_id_block_in_place_block_on_spawn () { use tokio :: runtime :: Builder ; task :: spawn (async { let parent_id = task :: id () ; task :: block_in_place (move | | { let rt = Builder :: new_current_thread () . build () . unwrap () ; rt . block_on (rt . spawn (async move { assert_ne ! (parent_id , task :: id ()) ; })) . unwrap () ; }) ; assert_eq ! (parent_id , task :: id ()) ; }) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_inherent",
                        "label": "lines_inherent",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn lines_inherent () { let rd : & [u8] = b\"hello\\r\\nworld\\n\\n\" ; let mut st = rd . lines () ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"hello\") ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"world\") ; let b = assert_ok ! (st . next_line () . await) . unwrap () ; assert_eq ! (b , \"\") ; assert ! (assert_ok ! (st . next_line () . await) . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/io_lines.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "timer_with_current_thread_scheduler",
                        "label": "timer_with_current_thread_scheduler",
                        "kind": "Function",
                        "signature": "fn # [test] fn timer_with_current_thread_scheduler () { use tokio :: runtime :: Builder ; let rt = Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let (tx , rx) = mpsc :: channel () ; rt . block_on (async move { let when = Instant :: now () + Duration :: from_millis (10) ; sleep_until (when) . await ; assert ! (Instant :: now () >= when) ; tx . send (()) . unwrap () ; }) ; rx . recv () . unwrap () ; } . sig",
                        "file_path": "tokio/tests/time_rt.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_to_recv_from",
                        "label": "try_send_to_recv_from",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_send_to_recv_from () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let saddr = server . local_addr () . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let caddr = client . local_addr () . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send_to (b\"hello world\" , saddr) { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = [0 ; 512] ; match server . try_recv_from (& mut buf) { Ok ((n , addr)) => { assert_eq ! (n , 11) ; assert_eq ! (addr , caddr) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_to_end_internal",
                        "label": "read_to_end_internal",
                        "kind": "Function",
                        "signature": "fn pub (super) fn read_to_end_internal < V : VecU8 , R : AsyncRead + ? Sized > (buf : & mut VecWithInitialized < V > , mut reader : Pin < & mut R > , num_read : & mut usize , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { loop { let ret = ready ! (poll_read_to_end (buf , reader . as_mut () , cx)) ; match ret { Err (err) => return Poll :: Ready (Err (err)) , Ok (0) => return Poll :: Ready (Ok (mem :: replace (num_read , 0))) , Ok (num) => { * num_read += num ; } } } } . sig",
                        "file_path": "tokio/src/io/util/read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_zero_sized",
                        "label": "test_zero_sized",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_zero_sized () { let fut = ZeroSizedFuture { } ; assert_eq ! (Layout :: for_value (& fut) . size () , 0) ; let mut b = ReusableBoxFuture :: new (fut) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; b . try_set (ZeroSizedFuture { }) . unwrap_or_else (| _ | panic ! (\"incorrect size\")) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; assert_eq ! (b . get_pin () . now_or_never () , Some (5)) ; } . sig",
                        "file_path": "tokio-util/tests/reusable_box.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "reset_readable",
                        "label": "reset_readable",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn reset_readable () { let (a , mut b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; let mut guard = readable . await . unwrap () ; guard . try_io (| _ | afd_a . get_ref () . read (& mut [0])) . unwrap () . unwrap () ; afd_a . readable () . await . unwrap () . retain_ready () ; guard . clear_ready () ; let readable = afd_a . readable () ; tokio :: pin ! (readable) ; tokio :: select ! { _ = readable . as_mut () => panic ! () , _ = tokio :: time :: sleep (Duration :: from_millis (10)) => { } } b . write_all (b\"0\") . unwrap () ; afd_a . readable () . await . unwrap () . clear_ready () ; } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_read",
                        "label": "open_read",
                        "kind": "Function",
                        "signature": "fn # [test] fn open_read () { let mut file = MockFile :: default () ; file . expect_inner_read () . once () . returning (| buf | { buf [0 .. HELLO . len ()] . copy_from_slice (HELLO) ; Ok (HELLO . len ()) }) ; let mut file = File :: from_std (file) ; let mut buf = [0 ; 1024] ; let mut t = task :: spawn (file . read (& mut buf)) ; assert_eq ! (0 , pool :: len ()) ; assert_pending ! (t . poll ()) ; assert_eq ! (1 , pool :: len ()) ; pool :: run_one () ; assert ! (t . is_woken ()) ; let n = assert_ready_ok ! (t . poll ()) ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/src/fs/file/tests.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "connect_addr_ip_port_tuple",
                        "label": "connect_addr_ip_port_tuple",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn connect_addr_ip_port_tuple () { let srv = assert_ok ! (TcpListener :: bind (\"127.0.0.1:0\") . await) ; let addr = assert_ok ! (srv . local_addr ()) ; let addr = (addr . ip () , addr . port ()) ; let server = async { assert_ok ! (srv . accept () . await) ; } ; let client = async { assert_ok ! (TcpStream :: connect (& addr) . await) ; } ; join ! (server , client) ; } . sig",
                        "file_path": "tokio/tests/tcp_connect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "readiness",
                        "label": "readiness",
                        "kind": "Function",
                        "signature": "fn # [test] fn readiness () { let l1 = Arc :: new (Mutex :: new (100)) ; let l2 = Arc :: clone (& l1) ; let mut t1 = spawn (l1 . lock ()) ; let mut t2 = spawn (l2 . lock ()) ; let g = assert_ready ! (t1 . poll ()) ; assert_pending ! (t2 . poll ()) ; drop (g) ; assert ! (t2 . is_woken ()) ; let _t2 = assert_ready ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rx_version_underflow",
                        "label": "rx_version_underflow",
                        "kind": "Function",
                        "signature": "fn # [test] fn rx_version_underflow () { let (_tx , mut rx) = watch :: channel (\"one\") ; rx . mark_changed () ; rx . mark_changed () ; } . sig",
                        "file_path": "tokio/tests/sync_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_threadpool",
                        "label": "local_threadpool",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; task :: spawn_local (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multiple_wait",
                        "label": "multiple_wait",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn multiple_wait () { const FIRST_WAIT : Duration = Duration :: from_secs (1) ; const SECOND_WAIT : Duration = Duration :: from_secs (1) ; let mut mock = Builder :: new () . wait (FIRST_WAIT) . read (b\"hello \") . wait (SECOND_WAIT) . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let start = Instant :: now () ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; println ! (\"time elapsed after first read {:?}\" , start . elapsed ()) ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; println ! (\"time elapsed after second read {:?}\" , start . elapsed ()) ; assert ! (start . elapsed () >= FIRST_WAIT + SECOND_WAIT , \"consuming the whole mock only took {}ms\" , start . elapsed () . as_millis ()) ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "pack",
                        "label": "pack",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Join the two head values\"] fn pack (steal : UnsignedShort , real : UnsignedShort) -> UnsignedLong { (real as UnsignedLong) | ((steal as UnsignedLong) << (mem :: size_of :: < UnsignedShort > () * 8)) } . sig",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_len_on_filled_channel_without_senders",
                        "label": "test_rx_len_on_filled_channel_without_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_len_on_filled_channel_without_senders () { let (tx , rx) = mpsc :: channel (100) ; for i in 0 .. 100 { assert ! (tx . send (i) . await . is_ok ()) ; } drop (tx) ; assert_eq ! (rx . len () , 100) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "PollSendError",
                        "label": "PollSendError",
                        "kind": "Struct",
                        "signature": "struct PollSendError",
                        "file_path": "tokio-util/src/sync/mpsc.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "neg_adjusted_frame_does_not_fit",
                        "label": "neg_adjusted_frame_does_not_fit",
                        "kind": "Function",
                        "signature": "fn # [test] fn neg_adjusted_frame_does_not_fit () { let codec = LengthDelimitedCodec :: builder () . length_field_length (1) . length_adjustment (- 1) . new_codec () ; assert_eq ! (codec . max_frame_length () , 254) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "drop_waker",
                        "label": "drop_waker",
                        "kind": "Function",
                        "signature": "fn unsafe fn drop_waker (ptr : * const ()) { let ptr = NonNull :: new_unchecked (ptr as * mut Header) ; trace ! (ptr , \"waker.drop\") ; let raw = RawTask :: from_raw (ptr) ; raw . drop_reference () ; } . sig",
                        "file_path": "tokio/src/runtime/task/waker.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "OnceCell",
                        "label": "OnceCell",
                        "kind": "Struct",
                        "signature": "struct OnceCell",
                        "file_path": "tokio/src/sync/once_cell.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "fifo_resilient_reader",
                        "label": "fifo_resilient_reader",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks behavior of a resilient reader (Receiver in O_RDWR access mode)\"] # [doc = \" with writers sequentially opening and closing a FIFO.\"] # [tokio :: test] # [cfg (any (target_os = \"linux\" , target_os = \"android\"))] # [cfg_attr (miri , ignore)] async fn fifo_resilient_reader () -> io :: Result < () > { const DATA : & [u8] = b\"this is some data to write to the fifo\" ; let fifo = TempFifo :: new (\"fifo_resilient_reader\") ? ; let mut reader = pipe :: OpenOptions :: new () . read_write (true) . open_receiver (& fifo) ? ; write_and_close (& fifo , DATA) . await ? ; let ev = reader . ready (Interest :: READABLE) . await ? ; let mut read_data = vec ! [0 ; DATA . len ()] ; reader . read_exact (& mut read_data) . await ? ; assert ! (! ev . is_read_closed ()) ; let mut second_read_fut = task :: spawn (reader . read_exact (& mut read_data)) ; assert_pending ! (second_read_fut . poll ()) ; write_and_close (& fifo , DATA) . await ? ; assert_ok ! (second_read_fut . await) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Display",
                        "label": "Display",
                        "kind": "Trait",
                        "signature": "trait Display",
                        "file_path": "src/lib.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "mock_panics_read_data_left",
                        "label": "mock_panics_read_data_left",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [should_panic] async fn mock_panics_read_data_left () { use tokio_test :: io :: Builder ; Builder :: new () . read (b\"read\") . build () ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "request_reply_current_thread",
                        "label": "request_reply_current_thread",
                        "kind": "Function",
                        "signature": "fn fn request_reply_current_thread (c : & mut Criterion) { let rt = tokio :: runtime :: Builder :: new_current_thread () . build () . unwrap () ; request_reply (c , rt) ; } . sig",
                        "file_path": "benches/sync_mpsc_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_join_queue_alternating",
                        "label": "test_join_queue_alternating",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_join_queue_alternating () { let mut queue = JoinQueue :: new () ; assert_eq ! (queue . len () , 0) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 1) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 2) ; for _ in 0 .. 16 { let res = queue . join_next () . await . unwrap () ; assert ! (res . is_ok ()) ; assert_eq ! (queue . len () , 1) ; queue . spawn (async { }) ; assert_eq ! (queue . len () , 2) ; } } . sig",
                        "file_path": "tokio-util/tests/task_join_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_notified_one",
                        "label": "notify_notified_one",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_notified_one () { let notify = Notify :: new () ; let mut notified = spawn (async { notify . notified () . await }) ; notify . notify_one () ; assert_ready ! (notified . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_c",
                        "label": "ctrl_c",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn ctrl_c () { let ctrl_c = signal :: ctrl_c () ; tokio :: spawn (async { send_signal (libc :: SIGINT) ; }) ; assert_ok ! (ctrl_c . await) ; } . sig",
                        "file_path": "tokio/tests/signal_ctrl_c.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_weak_count_when_downgraded",
                        "label": "sender_weak_count_when_downgraded",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn sender_weak_count_when_downgraded () { let (tx , _rx) = broadcast :: channel :: < () > (1) ; let weak = tx . downgrade () ; assert_eq ! (tx . weak_count () , 1) ; assert_eq ! (weak . weak_count () , 1) ; } . sig",
                        "file_path": "tokio/tests/sync_broadcast_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "downgrade_upgrade_unbounded_sender_success",
                        "label": "downgrade_upgrade_unbounded_sender_success",
                        "kind": "Function",
                        "signature": "fn # [test] fn downgrade_upgrade_unbounded_sender_success () { let (tx , _rx) = mpsc :: unbounded_channel :: < i32 > () ; let weak_tx = tx . downgrade () ; assert ! (weak_tx . upgrade () . is_some ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc_weak.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TryLock",
                        "label": "TryLock",
                        "kind": "Struct",
                        "signature": "struct TryLock",
                        "file_path": "tokio/src/util/try_lock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "is_send_and_sync",
                        "label": "is_send_and_sync",
                        "kind": "Function",
                        "signature": "fn # [test] fn is_send_and_sync () { fn assert_bound < T : Send + Sync > () { } assert_bound :: < Join < W , R > > () ; } . sig",
                        "file_path": "tokio/tests/io_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "UninitTest",
                        "label": "UninitTest",
                        "kind": "Struct",
                        "signature": "struct UninitTest",
                        "file_path": "tokio/tests/io_read_to_end.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "bench_uncontented",
                        "label": "bench_uncontented",
                        "kind": "Function",
                        "signature": "fn fn bench_uncontented (c : & mut Criterion) { let mut group = c . benchmark_group (\"uncontented\") ; read_uncontended (& mut group) ; read_concurrent_uncontended (& mut group) ; read_concurrent_uncontended_multi (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_io_writable",
                        "label": "try_io_writable",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_io_writable () { let (a , _b) = socketpair () ; let afd_a = AsyncFd :: new (a) . unwrap () ; tokio :: task :: yield_now () . await ; { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; Ok (()) }) ; assert ! (called , \"closure should have been called, since socket should still be marked as writable\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; io :: Result :: < () > :: Err (ErrorKind :: WouldBlock . into ()) }) ; assert ! (called , \"closure should have been called, since socket should still be marked as writable\") ; } { let mut called = false ; let _ = afd_a . try_io (Interest :: WRITABLE , | _ | { called = true ; Ok (()) }) ; assert ! (! called , \"closure should not have been called, since socket writable state should have been cleared\") ; } } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "work",
                        "label": "work",
                        "kind": "Function",
                        "signature": "fn async fn work () -> usize { let val = 1 + 1 ; tokio :: task :: yield_now () . await ; black_box (val) } . sig",
                        "file_path": "benches/spawn.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_threadpool_timer",
                        "label": "local_threadpool_timer",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (target_os = \"wasi\"))] # [tokio :: test (flavor = \"multi_thread\")] async fn local_threadpool_timer () { thread_local ! { static ON_RT_THREAD : Cell < bool > = const { Cell :: new (false) } ; } ON_RT_THREAD . with (| cell | cell . set (true)) ; LocalSet :: new () . run_until (async { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; let join = task :: spawn_local (async move { assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; time :: sleep (Duration :: from_millis (10)) . await ; assert ! (ON_RT_THREAD . with (| cell | cell . get ())) ; }) ; join . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "assert_ok_on_err",
                        "label": "assert_ok_on_err",
                        "kind": "Function",
                        "signature": "fn # [test] # [should_panic] fn assert_ok_on_err () { let poll = ready_err () ; assert_ready_ok ! (poll) ; } . sig",
                        "file_path": "tokio-test/tests/macros.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal_realtime",
                        "label": "signal_realtime",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn signal_realtime () { let signals = (libc :: SIGRTMIN () ..= sigrt_max ()) . map (| signum | { let sig = assert_ok ! (signal (SignalKind :: from_raw (signum)) , \"failed to create signal for {}\" , sigrtnum_to_string (signum) ,) ; (signum , sig) }) . collect :: < Vec < _ > > () ; eprintln ! (\"registered {} signals in the range {}..={}\" , signals . len () , libc :: SIGRTMIN () , libc :: SIGRTMAX ()) ; for signum in libc :: SIGRTMIN () ..= sigrt_max () { send_signal (signum) ; } let futures = signals . into_iter () . map (| (signum , mut sig) | async move { let res = sig . recv () . await ; (signum , res) }) . collect :: < FuturesUnordered < _ > > () ; let sleep = std :: pin :: pin ! (sleep (Duration :: from_secs (5))) ; let done = futures . take_until (sleep) . collect :: < HashMap < _ , _ > > () . await ; let mut none = Vec :: new () ; let mut missing = Vec :: new () ; for signum in libc :: SIGRTMIN () ..= sigrt_max () { match done . get (& signum) { Some (Some (())) => { } Some (None) => none . push (signum) , None => missing . push (signum) , } } if none . is_empty () && missing . is_empty () { return ; } let mut msg = String :: new () ; if ! none . is_empty () { msg . push_str (\"no signals received for:\\n\") ; for signum in none { msg . push_str (& format ! (\"- {}\\n\" , sigrtnum_to_string (signum))) ; } } if ! missing . is_empty () { msg . push_str (\"missing signals for:\\n\") ; for signum in missing { msg . push_str (& format ! (\"- {}\\n\" , sigrtnum_to_string (signum))) ; } } panic ! (\"{}\" , msg) ; } . sig",
                        "file_path": "tokio/tests/signal_realtime.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "from_file_detects_not_a_fifo",
                        "label": "from_file_detects_not_a_fifo",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn from_file_detects_not_a_fifo () -> io :: Result < () > { let dir = tempfile :: Builder :: new () . prefix (\"tokio-fifo-tests\") . tempdir () . unwrap () ; let path = dir . path () . join (\"not_a_fifo\") ; File :: create (& path) ? ; let file = std :: fs :: OpenOptions :: new () . write (true) . open (& path) ? ; let err = assert_err ! (pipe :: Sender :: from_file (file)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; let file = std :: fs :: OpenOptions :: new () . read (true) . open (& path) ? ; let err = assert_err ! (pipe :: Receiver :: from_file (file)) ; assert_eq ! (err . kind () , io :: ErrorKind :: InvalidInput) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/net_unix_pipe.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mk_runtime",
                        "label": "mk_runtime",
                        "kind": "Function",
                        "signature": "fn fn mk_runtime () -> Runtime { runtime :: Builder :: new_current_thread () . build () . unwrap () } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread/yield_now.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "local_pool_handle_new_panic_caller",
                        "label": "local_pool_handle_new_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn local_pool_handle_new_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let _ = LocalPoolHandle :: new (0) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "TrackPolls",
                        "label": "TrackPolls",
                        "kind": "Struct",
                        "signature": "struct TrackPolls",
                        "file_path": "tokio/tests/tcp_accept.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "Remote",
                        "label": "Remote",
                        "kind": "Struct",
                        "signature": "struct Remote",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "deadline_future_elapses",
                        "label": "deadline_future_elapses",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn deadline_future_elapses () { time :: pause () ; let mut fut = task :: spawn (timeout_at (Instant :: now () + ms (300) , pending :: < () > ())) ; assert_pending ! (fut . poll ()) ; time :: advance (ms (301)) . await ; assert ! (fut . is_woken ()) ; assert_ready_err ! (fut . poll ()) ; } . sig",
                        "file_path": "tokio/tests/time_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_line_fail",
                        "label": "read_line_fail",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read_line_fail () { let mock = Builder :: new () . read (b\"Hello Wor\") . read_error (Error :: new (ErrorKind :: Other , \"The world has no end\")) . build () ; let mut read = BufReader :: new (mock) ; let mut line = \"Foo\" . to_string () ; let err = read . read_line (& mut line) . await . expect_err (\"Should fail\") ; assert_eq ! (err . kind () , ErrorKind :: Other) ; assert_eq ! (err . to_string () , \"The world has no end\") ; assert_eq ! (line . as_str () , \"FooHello Wor\") ; } . sig",
                        "file_path": "tokio/tests/io_read_line.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_one",
                        "label": "notify_one",
                        "kind": "Function",
                        "signature": "fn fn notify_one < const N_WAITERS : usize > (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; let notify = Arc :: new (Notify :: new ()) ; let counter = Arc :: new (AtomicUsize :: new (0)) ; for _ in 0 .. N_WAITERS { rt . spawn ({ let notify = notify . clone () ; let counter = counter . clone () ; async move { loop { notify . notified () . await ; counter . fetch_add (1 , Ordering :: Relaxed) ; } } }) ; } const N_ITERS : usize = 500 ; g . bench_function (N_WAITERS . to_string () , | b | { b . iter (| | { counter . store (0 , Ordering :: Relaxed) ; loop { notify . notify_one () ; if counter . load (Ordering :: Relaxed) >= N_ITERS { break ; } } }) }) ; } . sig",
                        "file_path": "benches/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_semaphore_creates_span",
                        "label": "test_semaphore_creates_span",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_semaphore_creates_span () { let semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::semaphore\") ; let batch_semaphore_span = expect :: span () . named (\"runtime.resource\") . with_target (\"tokio::sync::batch_semaphore\") ; let batch_semaphore_permits_event = expect :: event () . with_target (\"runtime::resource::state_update\") . with_fields (expect :: field (\"permits\") . with_value (& 1u64)) . with_fields (expect :: field (\"permits.op\") . with_value (& \"override\")) ; let (subscriber , handle) = subscriber :: mock () . new_span (semaphore_span . clone () . with_ancestry (expect :: is_explicit_root ()) ,) . enter (semaphore_span . clone ()) . new_span (batch_semaphore_span . clone ()) . enter (batch_semaphore_span . clone ()) . event (batch_semaphore_permits_event) . exit (batch_semaphore_span . clone ()) . exit (semaphore_span . clone ()) . drop_span (semaphore_span) . drop_span (batch_semaphore_span) . run_with_handle () ; { let _guard = tracing :: subscriber :: set_default (subscriber) ; let _ = sync :: Semaphore :: new (1) ; } handle . assert_finished () ; } . sig",
                        "file_path": "tokio/tests/tracing_sync.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "mut_ref_patterns",
                        "label": "mut_ref_patterns",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn mut_ref_patterns () { tokio :: select ! { Some (mut foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (foo , \"1\") ; foo = \"2\" . to_string () ; assert_eq ! (foo , \"2\") ; } , } ; tokio :: select ! { Some (ref foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (* foo , \"1\") ; } , } ; tokio :: select ! { Some (ref mut foo) = async { Some (\"1\" . to_string ()) } => { assert_eq ! (* foo , \"1\") ; * foo = \"2\" . to_string () ; assert_eq ! (* foo , \"2\") ; } , } ; } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "U64Codec",
                        "label": "U64Codec",
                        "kind": "Struct",
                        "signature": "struct U64Codec",
                        "file_path": "tokio-util/tests/framed.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "User",
                        "label": "User",
                        "kind": "Struct",
                        "signature": "struct User",
                        "file_path": "src/lib.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "BacktraceSymbol",
                        "label": "BacktraceSymbol",
                        "kind": "Struct",
                        "signature": "struct BacktraceSymbol",
                        "file_path": "tokio/src/runtime/dump.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "to_raw",
                        "label": "to_raw",
                        "kind": "Function",
                        "signature": "fn fn to_raw < T > (data : Option < Box < T > >) -> * mut T { data . map_or (ptr :: null_mut () , Box :: into_raw) } . sig",
                        "file_path": "tokio/src/util/atomic_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "signal_enable",
                        "label": "signal_enable",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Enables this module to receive signal notifications for the `signal`\"] # [doc = \" provided.\"] # [doc = \"\"] # [doc = \" This will register the signal handler if it hasn't already been registered,\"] # [doc = \" returning any error along the way if that fails.\"] fn signal_enable (signal : SignalKind , handle : & Handle) -> io :: Result < () > { let signal = signal . 0 ; if signal < 0 || signal_hook_registry :: FORBIDDEN . contains (& signal) { return Err (Error :: new (ErrorKind :: Other , format ! (\"Refusing to register signal {signal}\") ,)) ; } handle . check_inner () ? ; let globals = globals () ; let siginfo = match globals . storage () . get (signal as EventId) { Some (slot) => slot , None => return Err (io :: Error :: new (io :: ErrorKind :: Other , \"signal too large\")) , } ; let mut registered = Ok (()) ; siginfo . init . call_once (| | { registered = unsafe { signal_hook_registry :: register (signal , move | | action (globals , signal)) . map (| _ | ()) } ; if registered . is_ok () { siginfo . initialized . store (true , Ordering :: Relaxed) ; } }) ; registered ? ; if siginfo . initialized . load (Ordering :: Relaxed) { Ok (()) } else { Err (Error :: new (ErrorKind :: Other , \"Failed to register signal handler\" ,)) } } . sig",
                        "file_path": "tokio/src/signal/unix.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "visibility_test",
                        "label": "visibility_test",
                        "kind": "Function",
                        "signature": "fn fn visibility_test < I , S1 , S2 > (s1 : S1 , s2 : S2) -> Chain < S1 , S2 > where S1 : Stream < Item = I > , S2 : Stream < Item = I > , { s1 . chain (s2) } . sig",
                        "file_path": "tokio-stream/tests/stream_chain.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "notify_one_after_dropped_all",
                        "label": "notify_one_after_dropped_all",
                        "kind": "Function",
                        "signature": "fn # [test] fn notify_one_after_dropped_all () { let notify = Arc :: new (Notify :: new ()) ; let mut notified1 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_pending ! (notified1 . poll ()) ; notify . notify_waiters () ; notify . notify_one () ; drop (notified1) ; let mut notified2 = spawn (async { notify . clone () . notified_owned () . await }) ; assert_ready ! (notified2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "contention_unbounded",
                        "label": "contention_unbounded",
                        "kind": "Function",
                        "signature": "fn fn contention_unbounded (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"unbounded\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: unbounded_channel :: < usize > () ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . unwrap () ; } }) ; } for _ in 0 .. 1_000 * 5 { let _ = rx . recv () . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_recv_never_block",
                        "label": "try_send_recv_never_block",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn try_send_recv_never_block () -> io :: Result < () > { let mut recv_buf = [0u8 ; 16] ; let payload = b\"PAYLOAD\" ; let mut count = 0 ; let (dgram1 , dgram2) = UnixDatagram :: pair () ? ; loop { dgram1 . writable () . await . unwrap () ; match dgram1 . try_send (payload) { Err (err) => match (err . kind () , err . raw_os_error ()) { (io :: ErrorKind :: WouldBlock , _) => break , (_ , Some (libc :: ENOBUFS)) => break , _ => { panic ! (\"unexpected error {err:?}\") ; } } , Ok (len) => { assert_eq ! (len , payload . len ()) ; } } count += 1 ; } while count > 0 { dgram2 . readable () . await . unwrap () ; let len = dgram2 . try_recv (& mut recv_buf [..]) ? ; assert_eq ! (len , payload . len ()) ; assert_eq ! (payload , & recv_buf [.. len]) ; count -= 1 ; } let err = dgram2 . try_recv (& mut recv_buf [..]) . unwrap_err () ; match err . kind () { io :: ErrorKind :: WouldBlock => () , _ => unreachable ! (\"unexpected error {:?}\" , err) , } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "NotifyWaitersList",
                        "label": "NotifyWaitersList",
                        "kind": "Struct",
                        "signature": "struct NotifyWaitersList",
                        "file_path": "tokio/src/sync/notify.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_and_cancel_token",
                        "label": "drop_and_cancel_token",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_and_cancel_token () { loom :: model (| | { let token1 = CancellationToken :: new () ; let token2 = token1 . clone () ; let child_token = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { drop (child_token) ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_panic",
                        "label": "test_panic",
                        "kind": "Function",
                        "signature": "fn fn test_panic < Func : FnOnce () + panic :: UnwindSafe > (func : Func) -> Option < String > { static PANIC_MUTEX : Mutex < () > = const_mutex (()) ; { let _guard = PANIC_MUTEX . lock () ; let panic_file : Arc < Mutex < Option < String > > > = Arc :: new (Mutex :: new (None)) ; let prev_hook = panic :: take_hook () ; { let panic_file = panic_file . clone () ; panic :: set_hook (Box :: new (move | panic_info | { let panic_location = panic_info . location () . unwrap () ; panic_file . lock () . clone_from (& Some (panic_location . file () . to_string ())) ; })) ; } let result = panic :: catch_unwind (func) ; panic :: set_hook (prev_hook) ; if result . is_err () { panic_file . lock () . clone () } else { None } } } . sig",
                        "file_path": "tokio-util/tests/panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sender_changes_task",
                        "label": "sender_changes_task",
                        "kind": "Function",
                        "signature": "fn # [test] fn sender_changes_task () { let (mut tx , rx) = oneshot :: channel :: < i32 > () ; let mut task1 = task :: spawn (()) ; let mut task2 = task :: spawn (()) ; assert_pending ! (task1 . enter (| cx , _ | tx . poll_closed (cx))) ; assert_eq ! (2 , task1 . waker_ref_count ()) ; assert_eq ! (1 , task2 . waker_ref_count ()) ; assert_pending ! (task2 . enter (| cx , _ | tx . poll_closed (cx))) ; assert_eq ! (1 , task1 . waker_ref_count ()) ; assert_eq ! (2 , task2 . waker_ref_count ()) ; drop (rx) ; assert ! (! task1 . is_woken ()) ; assert ! (task2 . is_woken ()) ; assert_ready ! (task2 . enter (| cx , _ | tx . poll_closed (cx))) ; } . sig",
                        "file_path": "tokio/tests/sync_oneshot.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_break",
                        "label": "ctrl_break",
                        "kind": "Function",
                        "signature": "fn pub (super) fn ctrl_break () -> io :: Result < RxFuture > { panic ! () } . sig",
                        "file_path": "tokio/src/signal/windows/stub.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_notify_waiters",
                        "label": "bench_notify_waiters",
                        "kind": "Function",
                        "signature": "fn fn bench_notify_waiters (c : & mut Criterion) { let mut group = c . benchmark_group (\"notify_waiters\") ; notify_waiters :: < 10 > (& mut group) ; notify_waiters :: < 50 > (& mut group) ; notify_waiters :: < 100 > (& mut group) ; notify_waiters :: < 200 > (& mut group) ; notify_waiters :: < 500 > (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_notify.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "spawn_send",
                        "label": "spawn_send",
                        "kind": "Function",
                        "signature": "fn async fn spawn_send () { let (tx , rx) = oneshot :: channel () ; let task = tokio :: spawn (async { for _ in 0 .. 10 { task :: yield_now () . await ; } tx . send (\"done\") . unwrap () ; }) ; assert_eq ! (\"done\" , rx . await . unwrap ()) ; task . await . unwrap () ; } . sig",
                        "file_path": "tests-integration/tests/rt_yield.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Pop",
                        "label": "Pop",
                        "kind": "Struct",
                        "signature": "struct Pop",
                        "file_path": "tokio/src/runtime/scheduler/inject/pop.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "get_or_init",
                        "label": "get_or_init",
                        "kind": "Function",
                        "signature": "fn # [test] fn get_or_init () { let rt = runtime :: Builder :: new_current_thread () . enable_time () . start_paused (true) . build () . unwrap () ; static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; rt . block_on (async { let handle1 = rt . spawn (async { ONCE . get_or_init (func1) . await }) ; let handle2 = rt . spawn (async { ONCE . get_or_init (func2) . await }) ; time :: advance (Duration :: from_millis (1)) . await ; time :: resume () ; let result1 = handle1 . await . unwrap () ; let result2 = handle2 . await . unwrap () ; assert_eq ! (* result1 , 5) ; assert_eq ! (* result2 , 5) ; }) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "open_options_windows_custom_flags",
                        "label": "open_options_windows_custom_flags",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (windows)] async fn open_options_windows_custom_flags () { assert ! (format ! (\"{:?}\" , OpenOptions :: new () . custom_flags (FileSystem :: FILE_FLAG_DELETE_ON_CLOSE)) . contains (\"custom_flags: 67108864,\")) ; } . sig",
                        "file_path": "tokio/tests/fs_open_options_windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_read",
                        "label": "empty_read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_read () { let mut tempfile = tempfile () ; tempfile . write_all (HELLO) . unwrap () ; let mut file = File :: open (tempfile . path ()) . await . unwrap () ; assert ! (matches ! (file . read (& mut []) . now_or_never () , Some (Ok (0)))) ; let mut buf = [0 ; 1024] ; let n = file . read (& mut buf) . await . unwrap () ; assert_eq ! (n , HELLO . len ()) ; assert_eq ! (& buf [.. n] , HELLO) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "poor_little_task",
                        "label": "poor_little_task",
                        "kind": "Function",
                        "signature": "fn async fn poor_little_task (permits : Arc < Semaphore >) -> usize { let mut how_many_times_i_got_to_run = 0 ; for _ in 0 .. 5 { let _permit = permits . clone () . acquire_owned () . await . unwrap () ; how_many_times_i_got_to_run += 1 ; } how_many_times_i_got_to_run } . sig",
                        "file_path": "tokio/tests/macros_join.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_rx_unbounded_len_with_multiple_messages_and_dropped_senders",
                        "label": "test_rx_unbounded_len_with_multiple_messages_and_dropped_senders",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn test_rx_unbounded_len_with_multiple_messages_and_dropped_senders () { let (tx , rx) = mpsc :: unbounded_channel () ; for i in 0 .. 100 { assert ! (tx . send (i) . is_ok ()) ; } drop (tx) ; assert_eq ! (rx . len () , 100) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "sleep_with_local_enter_guard",
                        "label": "sleep_with_local_enter_guard",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Checks that the task wakes up with `enter`.\"] # [doc = \" Reproduces <https://github.com/tokio-rs/tokio/issues/5020>.\"] # [tokio :: test] async fn sleep_with_local_enter_guard () { let local = LocalSet :: new () ; let _guard = local . enter () ; let (tx , rx) = oneshot :: channel () ; local . run_until (async move { tokio :: task :: spawn_local (async move { time :: sleep (Duration :: ZERO) . await ; tx . send (()) . expect (\"failed to send\") ; }) ; assert_eq ! (rx . await , Ok (())) ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_local_set.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "RotatorSelect",
                        "label": "RotatorSelect",
                        "kind": "Trait",
                        "signature": "trait RotatorSelect",
                        "file_path": "tokio/src/macros/join.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "poll_read_to_end",
                        "label": "poll_read_to_end",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Tries to read from the provided [`AsyncRead`].\"] # [doc = \"\"] # [doc = \" The length of the buffer is increased by the number of bytes read.\"] fn poll_read_to_end < V : VecU8 , R : AsyncRead + ? Sized > (buf : & mut VecWithInitialized < V > , read : Pin < & mut R > , cx : & mut Context < '_ > ,) -> Poll < io :: Result < usize > > { const NUM_BYTES : usize = 32 ; let try_small_read = buf . try_small_read_first (NUM_BYTES) ; let mut read_buf ; let poll_result ; let n = if try_small_read { let mut small_buf : [MaybeUninit < u8 > ; NUM_BYTES] = [MaybeUninit :: uninit () ; NUM_BYTES] ; let mut small_read_buf = ReadBuf :: uninit (& mut small_buf) ; poll_result = read . poll_read (cx , & mut small_read_buf) ; let to_write = small_read_buf . filled () ; read_buf = buf . get_read_buf () ; if to_write . len () > read_buf . remaining () { buf . reserve (NUM_BYTES) ; read_buf = buf . get_read_buf () ; } read_buf . put_slice (to_write) ; to_write . len () } else { buf . reserve (NUM_BYTES) ; read_buf = buf . get_read_buf () ; let filled_before = read_buf . filled () . len () ; poll_result = read . poll_read (cx , & mut read_buf) ; read_buf . filled () . len () - filled_before } ; let read_buf_parts = into_read_buf_parts (read_buf) ; buf . apply_read_buf (read_buf_parts) ; match poll_result { Poll :: Pending => { debug_assert_eq ! (n , 0) ; Poll :: Pending } Poll :: Ready (Err (err)) => { debug_assert_eq ! (n , 0) ; Poll :: Ready (Err (err)) } Poll :: Ready (Ok (())) => Poll :: Ready (Ok (n)) , } } . sig",
                        "file_path": "tokio/src/io/util/read_to_end.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Key",
                        "label": "Key",
                        "kind": "Struct",
                        "signature": "struct Key",
                        "file_path": "tokio-util/src/time/delay_queue.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "contention_bounded_recv_many",
                        "label": "contention_bounded_recv_many",
                        "kind": "Function",
                        "signature": "fn fn contention_bounded_recv_many (g : & mut BenchmarkGroup < WallTime >) { let rt = rt () ; g . bench_function (\"bounded_recv_many\" , | b | { b . iter (| | { rt . block_on (async move { let (tx , mut rx) = mpsc :: channel :: < usize > (1_000_000) ; for _ in 0 .. 5 { let tx = tx . clone () ; tokio :: spawn (async move { for i in 0 .. 1000 { tx . send (i) . await . unwrap () ; } }) ; } let mut buffer = Vec :: < usize > :: with_capacity (5_000) ; let mut total = 0 ; while total < 1_000 * 5 { total += rx . recv_many (& mut buffer , 5_000) . await ; } }) }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "empty_result",
                        "label": "empty_result",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn empty_result () { let coll : Result < Vec < u32 > , & str > = stream :: empty () . collect () . await ; assert_eq ! (Ok (vec ! []) , coll) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_collect.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Decoder",
                        "label": "Decoder",
                        "kind": "Trait",
                        "signature": "trait Decoder",
                        "file_path": "tokio-util/src/codec/decoder.rs",
                        "line": 0,
                        "icon": "🎯"
                    }
                },
                {
                    "data": {
                        "id": "TraceStatus",
                        "label": "TraceStatus",
                        "kind": "Struct",
                        "signature": "struct TraceStatus",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/trace_mock.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "cancel_token",
                        "label": "cancel_token",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_token () { loom :: model (| | { let token = CancellationToken :: new () ; let token1 = token . clone () ; let th1 = thread :: spawn (move | | { block_on (async { token1 . cancelled () . await ; }) ; }) ; let th2 = thread :: spawn (move | | { token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "bench_contention",
                        "label": "bench_contention",
                        "kind": "Function",
                        "signature": "fn fn bench_contention (c : & mut Criterion) { let mut group = c . benchmark_group (\"contention\") ; contention_impl :: < 10 > (& mut group) ; contention_impl :: < 100 > (& mut group) ; contention_impl :: < 500 > (& mut group) ; contention_impl :: < 1000 > (& mut group) ; group . finish () ; } . sig",
                        "file_path": "benches/sync_broadcast.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "use_future_in_if_condition",
                        "label": "use_future_in_if_condition",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg (feature = \"full\")] async fn use_future_in_if_condition () { use tokio :: time :: { self , Duration } ; tokio :: select ! { _ = time :: sleep (Duration :: from_millis (10)) , if false => { panic ! (\"if condition ignored\") } _ = async { 1u32 } => { } } } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown",
                        "label": "shutdown",
                        "kind": "Function",
                        "signature": "fn unsafe fn shutdown < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . shutdown () ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "basic_main",
                        "label": "basic_main",
                        "kind": "Function",
                        "signature": "fn # [tokio :: main] async fn basic_main () -> usize { 1 } . sig",
                        "file_path": "tests-integration/tests/macros_main.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "minimal_log_histogram",
                        "label": "minimal_log_histogram",
                        "kind": "Function",
                        "signature": "fn # [test] fn minimal_log_histogram () { let rt = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . enable_metrics_poll_time_histogram () . metrics_poll_time_histogram_configuration (HistogramConfiguration :: log (LogHistogram :: builder () . max_value (Duration :: from_millis (4)) . min_value (Duration :: from_micros (20)) . precision_exact (0) ,)) . build () . unwrap () ; let metrics = rt . metrics () ; let num_buckets = rt . metrics () . poll_time_histogram_num_buckets () ; for b in 1 .. num_buckets - 1 { let range = metrics . poll_time_histogram_bucket_range (b) ; let size = range . end - range . start ; assert_eq ! (size , Duration :: from_nanos ((1 << (b - 1)) * 16384) , \"incorrect range for {b}\") ; } assert_eq ! (num_buckets , 10) ; } . sig",
                        "file_path": "tokio/tests/rt_unstable_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_spawn",
                        "label": "task_id_spawn",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_spawn () { tokio :: spawn (async { println ! (\"task id: {}\" , task :: id ()) }) . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_poll",
                        "label": "send_recv_poll",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn send_recv_poll () -> std :: io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let sender_path = dir . path () . join (\"sender.sock\") ; let receiver_path = dir . path () . join (\"receiver.sock\") ; let sender = UnixDatagram :: bind (& sender_path) ? ; let receiver = UnixDatagram :: bind (& receiver_path) ? ; sender . connect (& receiver_path) ? ; receiver . connect (& sender_path) ? ; let msg = b\"hello\" ; poll_fn (| cx | sender . poll_send (cx , msg)) . await ? ; let mut recv_buf = [0u8 ; 32] ; let mut read = ReadBuf :: new (& mut recv_buf) ; poll_fn (| cx | receiver . poll_recv (cx , & mut read)) . await ? ; assert_eq ! (read . filled () , msg) ; Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_datagram.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stream_chunks_timeout_panic_caller",
                        "label": "stream_chunks_timeout_panic_caller",
                        "kind": "Function",
                        "signature": "fn # [test] fn stream_chunks_timeout_panic_caller () -> Result < () , Box < dyn Error > > { let panic_location_file = test_panic (| | { let iter = vec ! [1 , 2 , 3] . into_iter () ; let stream0 = stream :: iter (iter) ; let _chunk_stream = stream0 . chunks_timeout (0 , Duration :: from_secs (2)) ; }) ; assert_eq ! (& panic_location_file . unwrap () , file ! ()) ; Ok (()) } . sig",
                        "file_path": "tokio-stream/tests/stream_panic.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_with_sleep",
                        "label": "test_with_sleep",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn test_with_sleep () { let mut map = JoinMap :: new () ; for i in 0 .. 10 { map . spawn (i , async move { i }) ; assert_eq ! (map . len () , 1 + i) ; } map . detach_all () ; assert_eq ! (map . len () , 0) ; assert ! (map . join_next () . await . is_none ()) ; for i in 0 .. 10 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; assert_eq ! (map . len () , 1 + i) ; } let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; assert_eq ! (res . expect (\"task should have completed successfully\") , k) ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (map . join_next () . await . is_none ()) ; for i in 0 .. 10 { map . spawn (i , async move { tokio :: time :: sleep (Duration :: from_secs (i as u64)) . await ; i }) ; } let mut seen = [false ; 10] ; while let Some ((k , res)) = map . join_next () . await { seen [k] = true ; assert_eq ! (res . expect (\"task should have completed successfully\") , k) ; } for was_seen in & seen { assert ! (was_seen) ; } assert ! (map . join_next () . await . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/task_join_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_signal",
                        "label": "send_signal",
                        "kind": "Function",
                        "signature": "fn pub fn send_signal (signal : libc :: c_int) { use libc :: { getpid , kill } ; unsafe { assert_eq ! (kill (getpid () , signal) , 0) ; } } . sig",
                        "file_path": "benches/signal.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> runtime :: Runtime { runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/io_driver_drop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "rt",
                        "label": "rt",
                        "kind": "Function",
                        "signature": "fn fn rt () -> tokio :: runtime :: Runtime { tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () } . sig",
                        "file_path": "tokio/tests/io_async_fd.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_until_pending",
                        "label": "write_until_pending",
                        "kind": "Function",
                        "signature": "fn fn write_until_pending (stream : & mut TcpStream) -> usize { let buf = vec ! [0u8 ; 1024 * 1024] ; let mut total = 0 ; loop { match stream . try_write (& buf) { Ok (n) => total += n , Err (err) => { assert_eq ! (err . kind () , io :: ErrorKind :: WouldBlock) ; break ; } } } total } . sig",
                        "file_path": "tokio/tests/tcp_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "single_short_delay",
                        "label": "single_short_delay",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn single_short_delay () { time :: pause () ; let mut queue = task :: spawn (DelayQueue :: new ()) ; let _key = queue . insert_at (\"foo\" , Instant :: now () + ms (5)) ; assert_pending ! (poll ! (queue)) ; sleep (ms (1)) . await ; assert ! (! queue . is_woken ()) ; sleep (ms (5)) . await ; assert ! (queue . is_woken ()) ; let entry = assert_ready_some ! (poll ! (queue)) ; assert_eq ! (* entry . get_ref () , \"foo\") ; let entry = assert_ready ! (poll ! (queue)) ; assert ! (entry . is_none ()) ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MaybeDangling",
                        "label": "MaybeDangling",
                        "kind": "Struct",
                        "signature": "struct MaybeDangling",
                        "file_path": "tokio-util/src/util/maybe_dangling.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "remove_expired_item",
                        "label": "remove_expired_item",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn remove_expired_item () { time :: pause () ; let mut queue = DelayQueue :: new () ; let now = Instant :: now () ; sleep (ms (10)) . await ; let key = queue . insert_at (\"foo\" , now) ; let entry = queue . remove (& key) ; assert_eq ! (entry . into_inner () , \"foo\") ; } . sig",
                        "file_path": "tokio-util/tests/time_delay_queue.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ctrl_logoff",
                        "label": "ctrl_logoff",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a new listener which receives \\\"ctrl-logoff\\\" notifications sent to the\"] # [doc = \" process.\"] # [doc = \"\"] # [doc = \" # Examples\"] # [doc = \"\"] # [doc = \" ```rust,no_run\"] # [doc = \" use tokio::signal::windows::ctrl_logoff;\"] # [doc = \"\"] # [doc = \" #[tokio::main]\"] # [doc = \" async fn main() -> Result<(), Box<dyn std::error::Error>> {\"] # [doc = \"     // A listener of CTRL-LOGOFF events.\"] # [doc = \"     let mut signal = ctrl_logoff()?;\"] # [doc = \"\"] # [doc = \"     signal.recv().await;\"] # [doc = \"     println!(\\\"got CTRL-LOGOFF. Cleaning up before exiting\\\");\"] # [doc = \"\"] # [doc = \"     Ok(())\"] # [doc = \" }\"] # [doc = \" ```\"] pub fn ctrl_logoff () -> io :: Result < CtrlLogoff > { Ok (CtrlLogoff { inner : self :: imp :: ctrl_logoff () ? , }) } . sig",
                        "file_path": "tokio/src/signal/windows.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "never",
                        "label": "never",
                        "kind": "Function",
                        "signature": "fn fn never () -> bool { std :: time :: Instant :: now () > std :: time :: Instant :: now () } . sig",
                        "file_path": "tests-build/tests/pass/macros_main_loop.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "datagram_echo_server",
                        "label": "datagram_echo_server",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn datagram_echo_server () -> io :: Result < () > { let dir = tempfile :: tempdir () . unwrap () ; let server_path = dir . path () . join (\"server.sock\") ; let client_path = dir . path () . join (\"client.sock\") ; let server_socket = { let socket = UnixSocket :: new_datagram () ? ; socket . bind (& server_path) ? ; socket . datagram () ? } ; tokio :: spawn (async move { let mut recv_buf = vec ! [0u8 ; 1024] ; loop { let (len , peer_addr) = server_socket . recv_from (& mut recv_buf [..]) . await ? ; if let Some (path) = peer_addr . as_pathname () { server_socket . send_to (& recv_buf [.. len] , path) . await ? ; } } # [allow (unreachable_code)] Ok :: < () , io :: Error > (()) }) ; { let socket = UnixSocket :: new_datagram () ? ; socket . bind (& client_path) . unwrap () ; let socket = socket . datagram () ? ; socket . connect (server_path) ? ; socket . send (b\"ECHO\") . await ? ; let mut recv_buf = [0u8 ; 16] ; let len = socket . recv (& mut recv_buf [..]) . await ? ; assert_eq ! (& recv_buf [.. len] , b\"ECHO\") ; } Ok (()) } . sig",
                        "file_path": "tokio/tests/uds_socket.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "disconnect",
                        "label": "disconnect",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn disconnect () { let (mut a , mut b) = duplex (32) ; let t1 = tokio :: spawn (async move { a . write_all (b\"ping\") . await . unwrap () ; }) ; let t2 = tokio :: spawn (async move { let mut buf = [0u8 ; 32] ; let n = b . read (& mut buf) . await . unwrap () ; assert_eq ! (& buf [.. n] , b\"ping\") ; let n = b . read (& mut buf) . await . unwrap () ; assert_eq ! (n , 0) ; }) ; t1 . await . unwrap () ; t2 . await . unwrap () ; } . sig",
                        "file_path": "tokio/tests/io_mem_stream.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "worker_park_count",
                        "label": "worker_park_count",
                        "kind": "Function",
                        "signature": "fn # [test] fn worker_park_count () { let rt = current_thread () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (1 <= metrics . worker_park_count (0)) ; let rt = threaded () ; let metrics = rt . metrics () ; rt . block_on (async { time :: sleep (Duration :: from_millis (1)) . await ; }) ; drop (rt) ; assert ! (1 <= metrics . worker_park_count (0)) ; assert ! (1 <= metrics . worker_park_count (1)) ; } . sig",
                        "file_path": "tokio/tests/rt_metrics.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "no_permits",
                        "label": "no_permits",
                        "kind": "Function",
                        "signature": "fn # [test] fn no_permits () { Semaphore :: new (0) ; } . sig",
                        "file_path": "tokio/tests/sync_semaphore.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "peek",
                        "label": "peek",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn peek () { let listener = net :: TcpListener :: bind (\"127.0.0.1:0\") . unwrap () ; let addr = listener . local_addr () . unwrap () ; let t = thread :: spawn (move | | assert_ok ! (listener . accept ()) . 0) ; let left = net :: TcpStream :: connect (addr) . unwrap () ; left . set_nonblocking (true) . unwrap () ; let mut right = t . join () . unwrap () ; right . set_nonblocking (true) . unwrap () ; let _ = right . write (& [1 , 2 , 3 , 4]) . unwrap () ; let mut left : TcpStream = left . try_into () . unwrap () ; let mut buf = [0u8 ; 16] ; let n = assert_ok ! (left . peek (& mut buf) . await) ; assert_eq ! ([1 , 2 , 3 , 4] , buf [.. n]) ; let n = assert_ok ! (left . read (& mut buf) . await) ; assert_eq ! ([1 , 2 , 3 , 4] , buf [.. n]) ; } . sig",
                        "file_path": "tokio/tests/tcp_peek.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "duration_as_u64",
                        "label": "duration_as_u64",
                        "kind": "Function",
                        "signature": "fn pub (crate) fn duration_as_u64 (dur : Duration) -> u64 { u64 :: try_from (dur . as_nanos ()) . unwrap_or (u64 :: MAX) } . sig",
                        "file_path": "tokio/src/runtime/metrics/batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "lines_decoder_discard_repeat",
                        "label": "lines_decoder_discard_repeat",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_decoder_discard_repeat () { const MAX_LENGTH : usize = 1 ; let mut codec = LinesCodec :: new_with_max_length (MAX_LENGTH) ; let buf = & mut BytesMut :: new () ; buf . reserve (200) ; buf . put_slice (b\"aa\") ; assert ! (codec . decode (buf) . is_err ()) ; buf . put_slice (b\"a\") ; assert_eq ! (None , codec . decode (buf) . unwrap ()) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_and_shutdown",
                        "label": "write_vectored_and_shutdown",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_and_shutdown () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; let ret = file . write_vectored (& [IoSlice :: new (HELLO) , IoSlice :: new (HELLO)]) . await . unwrap () ; assert_eq ! (ret , HELLO . len () * 2) ; file . shutdown () . await . unwrap () ; let file = std :: fs :: read (tempfile . path ()) . unwrap () ; assert_eq ! (file , [HELLO , HELLO] . concat ()) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_max_buf_size_write",
                        "label": "set_max_buf_size_write",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn set_max_buf_size_write () { let tempfile = tempfile () ; let mut file = File :: create (tempfile . path ()) . await . unwrap () ; file . set_max_buf_size (1) ; assert_eq ! (file . write (HELLO) . await . unwrap () , 1) ; } . sig",
                        "file_path": "tokio/tests/fs_file.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "split_stream_id",
                        "label": "split_stream_id",
                        "kind": "Function",
                        "signature": "fn # [test] fn split_stream_id () { let (r1 , w1) = split (RW) ; let (r2 , w2) = split (RW) ; assert ! (r1 . is_pair_of (& w1)) ; assert ! (! r1 . is_pair_of (& w2)) ; assert ! (r2 . is_pair_of (& w2)) ; assert ! (! r2 . is_pair_of (& w1)) ; } . sig",
                        "file_path": "tokio/tests/io_split.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "real_time",
                        "label": "real_time",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [ignore] async fn real_time () { let iter = vec ! [1 , 2 , 3 , 4] . into_iter () ; let stream0 = stream :: iter (iter) ; let iter = vec ! [5] . into_iter () ; let stream1 = stream :: iter (iter) . then (move | n | time :: sleep (Duration :: from_secs (5)) . map (move | _ | n)) ; let chunk_stream = stream0 . chain (stream1) . chunks_timeout (3 , Duration :: from_secs (2)) ; let mut chunk_stream = task :: spawn (chunk_stream) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [1 , 2 , 3])) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [4])) ; assert_eq ! (chunk_stream . next () . await , Some (vec ! [5])) ; } . sig",
                        "file_path": "tokio-stream/tests/chunks_timeout.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "create_medium",
                        "label": "create_medium",
                        "kind": "Function",
                        "signature": "fn fn create_medium < const SIZE : usize > (g : & mut BenchmarkGroup < WallTime >) { g . bench_function (SIZE . to_string () , | b | { b . iter (| | { black_box (& mpsc :: channel :: < Medium > (SIZE)) ; }) }) ; } . sig",
                        "file_path": "benches/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "cancel_op_future",
                        "label": "cancel_op_future",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn cancel_op_future () { let (_tmp_file , path) : (Vec < NamedTempFile > , Vec < PathBuf >) = create_tmp_files (1) ; let (tx , mut rx) = tokio :: sync :: mpsc :: unbounded_channel () ; let handle = tokio :: spawn (async move { poll_fn (| cx | { let opt = { let mut opt = tokio :: fs :: OpenOptions :: new () ; opt . read (true) ; opt } ; let fut = opt . open (& path [0]) ; let _pending = Box :: pin (fut) . poll_unpin (cx) ; tx . send (()) . unwrap () ; Poll :: < () > :: Pending }) . await ; }) ; rx . recv () . await . unwrap () ; handle . abort () ; let res = handle . await . unwrap_err () ; assert ! (res . is_cancelled ()) ; } . sig",
                        "file_path": "tokio/tests/fs_uring.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "one",
                        "label": "one",
                        "kind": "Function",
                        "signature": "fn async fn one () -> usize { 1 } . sig",
                        "file_path": "tokio/tests/macros_select.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_acquire_one_available",
                        "label": "try_acquire_one_available",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_acquire_one_available () { let s = Semaphore :: new (100) ; assert_eq ! (s . available_permits () , 100) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 99) ; assert_ok ! (s . try_acquire (1)) ; assert_eq ! (s . available_permits () , 98) ; } . sig",
                        "file_path": "tokio/src/sync/tests/semaphore_batch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_send_recv",
                        "label": "try_send_recv",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_send_recv () { let server = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; let client = UdpSocket :: bind (\"127.0.0.1:0\") . await . unwrap () ; client . connect (server . local_addr () . unwrap ()) . await . unwrap () ; server . connect (client . local_addr () . unwrap ()) . await . unwrap () ; for _ in 0 .. 5 { loop { client . writable () . await . unwrap () ; match client . try_send (b\"hello world\") { Ok (n) => { assert_eq ! (n , 11) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } loop { server . readable () . await . unwrap () ; let mut buf = [0 ; 512] ; match server . try_recv (& mut buf) { Ok (n) => { assert_eq ! (n , 11) ; assert_eq ! (& buf [0 .. 11] , & b\"hello world\" [..]) ; break ; } Err (ref e) if e . kind () == io :: ErrorKind :: WouldBlock => continue , Err (e) => panic ! (\"{e:?}\") , } } } } . sig",
                        "file_path": "tokio/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ChunkReader",
                        "label": "ChunkReader",
                        "kind": "Struct",
                        "signature": "struct ChunkReader",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "try_lock",
                        "label": "try_lock",
                        "kind": "Function",
                        "signature": "fn # [test] fn try_lock () { let m : Mutex < usize > = Mutex :: new (0) ; { let g1 = m . try_lock () ; assert ! (g1 . is_ok ()) ; let g2 = m . try_lock () ; assert ! (g2 . is_err ()) ; } let g3 = m . try_lock () ; assert ! (g3 . is_ok ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mutex.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_hook_spawn_location_multi_thread",
                        "label": "task_hook_spawn_location_multi_thread",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Test that the correct spawn location is provided to the task hooks on a\"] # [doc = \" multi-thread runtime.\"] # [doc = \"\"] # [doc = \" Testing this separately is necessary as the spawn code paths are different\"] # [doc = \" and we should ensure that `#[track_caller]` is passed through correctly\"] # [doc = \" for both runtimes.\"] # [cfg_attr (target_os = \"wasi\" , ignore = \"WASI does not support multi-threaded runtime\")] # [test] fn task_hook_spawn_location_multi_thread () { let spawns = Arc :: new (AtomicUsize :: new (0)) ; let poll_starts = Arc :: new (AtomicUsize :: new (0)) ; let poll_ends = Arc :: new (AtomicUsize :: new (0)) ; let runtime = Builder :: new_multi_thread () . on_task_spawn (mk_spawn_location_hook (\"(multi_thread) on_task_spawn\" , & spawns ,)) . on_before_task_poll (mk_spawn_location_hook (\"(multi_thread) on_before_task_poll\" , & poll_starts ,)) . on_after_task_poll (mk_spawn_location_hook (\"(multi_thread) on_after_task_poll\" , & poll_ends ,)) . build () . unwrap () ; let task = runtime . spawn (async move { tokio :: task :: yield_now () . await }) ; runtime . block_on (async move { task . await . unwrap () ; tokio :: spawn (async move { }) . await . unwrap () ; for _ in 0 .. ITERATIONS { tokio :: task :: yield_now () . await ; } }) ; runtime . shutdown_timeout (std :: time :: Duration :: from_secs (60)) ; assert_eq ! (spawns . fetch_add (0 , Ordering :: SeqCst) , 2) ; let poll_starts = poll_starts . fetch_add (0 , Ordering :: SeqCst) ; assert ! (poll_starts > 2) ; assert_eq ! (poll_starts , poll_ends . fetch_add (0 , Ordering :: SeqCst)) ; } . sig",
                        "file_path": "tokio/tests/task_hooks.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "multiple_sender_drop_concurrently",
                        "label": "multiple_sender_drop_concurrently",
                        "kind": "Function",
                        "signature": "fn # [test] fn multiple_sender_drop_concurrently () { loom :: model (move | | { let (tx1 , rx) = watch :: channel (0) ; let tx2 = tx1 . clone () ; let jh = thread :: spawn (move | | { drop (tx2) ; }) ; assert ! (rx . has_changed () . is_ok ()) ; drop (tx1) ; jh . join () . unwrap () ; assert ! (rx . has_changed () . is_err ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_watch.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Launch",
                        "label": "Launch",
                        "kind": "Struct",
                        "signature": "struct Launch",
                        "file_path": "tokio/src/runtime/scheduler/multi_thread/worker.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "get_core_offset",
                        "label": "get_core_offset",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Compute the offset of the `Core<T, S>` field in `Cell<T, S>` using the\"] # [doc = \" `#[repr(C)]` algorithm.\"] # [doc = \"\"] # [doc = \" Pseudo-code for the `#[repr(C)]` algorithm can be found here:\"] # [doc = \" <https://doc.rust-lang.org/reference/type-layout.html#reprc-structs>\"] const fn get_core_offset (header_size : usize , core_align : usize) -> usize { let mut offset = header_size ; let core_misalign = offset % core_align ; if core_misalign > 0 { offset += core_align - core_misalign ; } offset } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "with_budget",
                        "label": "with_budget",
                        "kind": "Function",
                        "signature": "fn # [inline (always)] fn with_budget < R > (budget : Budget , f : impl FnOnce () -> R) -> R { struct ResetGuard { prev : Budget , } impl Drop for ResetGuard { fn drop (& mut self) { let _ = context :: budget (| cell | { cell . set (self . prev) ; }) ; } } # [allow (unused_variables)] let maybe_guard = context :: budget (| cell | { let prev = cell . get () ; cell . set (budget) ; ResetGuard { prev } }) ; f () } . sig",
                        "file_path": "tokio/src/task/coop/mod.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "task_id_nested_spawn_local",
                        "label": "task_id_nested_spawn_local",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"current_thread\")] async fn task_id_nested_spawn_local () { LocalSet :: new () . run_until (async { task :: spawn_local (async { let parent_id = task :: id () ; LocalSet :: new () . run_until (async { task :: spawn_local (async move { assert_ne ! (parent_id , task :: id ()) ; }) . await . unwrap () ; }) . await ; assert_eq ! (parent_id , task :: id ()) ; }) . await . unwrap () ; }) . await ; } . sig",
                        "file_path": "tokio/tests/task_id.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "blocking_one_side_does_not_block_other",
                        "label": "blocking_one_side_does_not_block_other",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] # [cfg_attr (miri , ignore)] async fn blocking_one_side_does_not_block_other () { symmetric (| handle , mut a , mut b | async move { block_write (& mut a) . await ; b . write_all (b\"quux\") . await . unwrap () ; let mut tmp = [0 ; 4] ; a . read_exact (& mut tmp) . await . unwrap () ; assert_eq ! (& tmp [..] , b\"quux\") ; AsyncWriteExt :: shutdown (& mut a) . await . unwrap () ; let mut buf = Vec :: new () ; b . read_to_end (& mut buf) . await . unwrap () ; drop (b) ; assert_eq ! (handle . await . unwrap () . unwrap () , (buf . len () as u64 , 4)) ; }) . await } . sig",
                        "file_path": "tokio/tests/io_copy_bidirectional.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "_assert_kinds",
                        "label": "_assert_kinds",
                        "kind": "Function",
                        "signature": "fn fn _assert_kinds () { fn _assert < T : Send + Sync > () { } _assert :: < Handle > () ; } . sig",
                        "file_path": "tokio/src/runtime/io/driver.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Wheel",
                        "label": "Wheel",
                        "kind": "Struct",
                        "signature": "struct Wheel",
                        "file_path": "tokio-util/src/time/wheel/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "closing_tx",
                        "label": "closing_tx",
                        "kind": "Function",
                        "signature": "fn # [test] fn closing_tx () { loom :: model (| | { let (tx , mut rx) = mpsc :: channel (16) ; thread :: spawn (move | | { tx . try_send (()) . unwrap () ; drop (tx) ; }) ; let v = block_on (rx . recv ()) ; assert ! (v . is_some ()) ; let v = block_on (rx . recv ()) ; assert ! (v . is_none ()) ; }) ; } . sig",
                        "file_path": "tokio/src/sync/tests/loom_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "stream_with_interval_poll_tick_no_waking",
                        "label": "stream_with_interval_poll_tick_no_waking",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (start_paused = true)] async fn stream_with_interval_poll_tick_no_waking () { let stream = IntervalStreamer { counter : 0 , timer : tokio :: time :: interval (tokio :: time :: Duration :: from_millis (10)) , wake_on_pending : false , } ; let (res_tx , mut res_rx) = tokio :: sync :: mpsc :: channel (12) ; tokio :: spawn (tokio :: time :: timeout (tokio :: time :: Duration :: from_millis (150) , async move { tokio :: pin ! (stream) ; while let Some (item) = stream . next () . await { res_tx . send (item) . await . ok () ; } } ,)) ; let mut items = Vec :: with_capacity (0) ; while let Some (result) = res_rx . recv () . await { items . push (result) ; } assert_eq ! (items , vec ! []) ; } . sig",
                        "file_path": "tokio/tests/time_interval.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "get_stdin_data",
                        "label": "get_stdin_data",
                        "kind": "Function",
                        "signature": "fn fn get_stdin_data () -> Result < Vec < u8 > , Box < dyn std :: error :: Error > > { let mut buf = Vec :: new () ; stdin () . read_to_end (& mut buf) ? ; Ok (buf) } . sig",
                        "file_path": "examples/udp-client.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SyncNotSend",
                        "label": "SyncNotSend",
                        "kind": "Struct",
                        "signature": "struct SyncNotSend",
                        "file_path": "tokio/src/util/markers.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "test_nested_block_in_place_with_block_on_between",
                        "label": "test_nested_block_in_place_with_block_on_between",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_nested_block_in_place_with_block_on_between () { let rt = runtime :: Builder :: new_multi_thread () . worker_threads (1) . max_blocking_threads (1) . build () . unwrap () ; for _ in 0 .. 100 { let h = rt . handle () . clone () ; rt . block_on (async move { tokio :: spawn (async move { tokio :: task :: block_in_place (| | { h . block_on (async { tokio :: task :: block_in_place (| | { }) ; }) ; }) }) . await . unwrap () }) ; } } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "try_clone_should_preserve_max_buf_size",
                        "label": "try_clone_should_preserve_max_buf_size",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn try_clone_should_preserve_max_buf_size () { let buf_size = 128 ; let temp = tempdir () ; let dir = temp . path () ; let mut file = fs :: File :: create (dir . join (\"try_clone_should_preserve_max_buf_size\")) . await . unwrap () ; file . set_max_buf_size (buf_size) ; let cloned = file . try_clone () . await . unwrap () ; assert_eq ! (cloned . max_buf_size () , buf_size) ; } . sig",
                        "file_path": "tokio/tests/fs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "send_recv_unbounded",
                        "label": "send_recv_unbounded",
                        "kind": "Function",
                        "signature": "fn # [maybe_tokio_test] async fn send_recv_unbounded () { let (tx , mut rx) = mpsc :: unbounded_channel :: < i32 > () ; assert_ok ! (tx . send (1)) ; assert_ok ! (tx . send (2)) ; assert_eq ! (rx . recv () . await , Some (1)) ; assert_eq ! (rx . recv () . await , Some (2)) ; drop (tx) ; assert ! (rx . recv () . await . is_none ()) ; } . sig",
                        "file_path": "tokio/tests/sync_mpsc.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_shared_drop",
                        "label": "write_shared_drop",
                        "kind": "Function",
                        "signature": "fn # [test] fn write_shared_drop () { let rwlock = RwLock :: new (100) ; let mut t1 = spawn (rwlock . read ()) ; let g1 = assert_ready ! (t1 . poll ()) ; let mut t2 = spawn (rwlock . write ()) ; assert_pending ! (t2 . poll ()) ; drop (g1) ; assert ! (t2 . is_woken ()) ; let _g2 = assert_ready ! (t2 . poll ()) ; } . sig",
                        "file_path": "tokio/tests/sync_rwlock.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "ListenerAcceptFut",
                        "label": "ListenerAcceptFut",
                        "kind": "Struct",
                        "signature": "struct ListenerAcceptFut",
                        "file_path": "tokio-util/src/net/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "BlockingTask",
                        "label": "BlockingTask",
                        "kind": "Struct",
                        "signature": "struct BlockingTask",
                        "file_path": "tokio/src/runtime/blocking/task.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "many_signals",
                        "label": "many_signals",
                        "kind": "Function",
                        "signature": "fn fn many_signals (c : & mut Criterion) { let num_signals = 10 ; let (tx , mut rx) = mpsc :: channel (num_signals) ; let rt = runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () ; let spawn_signal = | kind | { let tx = tx . clone () ; rt . spawn (async move { let mut signal = signal (kind) . expect (\"failed to create signal\") ; while signal . recv () . await . is_some () { if tx . send (()) . await . is_err () { break ; } } }) ; } ; for _ in 0 .. num_signals { spawn_signal (SignalKind :: child ()) ; spawn_signal (SignalKind :: io ()) ; } drop (tx) ; rt . block_on (Spinner :: new ()) ; c . bench_function (\"many_signals\" , | b | { b . iter (| | { rt . block_on (async { send_signal (libc :: SIGCHLD) ; for _ in 0 .. num_signals { rx . recv () . await . expect (\"channel closed\") ; } send_signal (libc :: SIGIO) ; for _ in 0 .. num_signals { rx . recv () . await . expect (\"channel closed\") ; } }) ; }) }) ; } . sig",
                        "file_path": "benches/signal.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "BytesCodec",
                        "label": "BytesCodec",
                        "kind": "Struct",
                        "signature": "struct BytesCodec",
                        "file_path": "tokio-util/src/codec/bytes_codec.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_abort_handle",
                        "label": "drop_abort_handle",
                        "kind": "Function",
                        "signature": "fn unsafe fn drop_abort_handle < T : Future , S : Schedule > (ptr : NonNull < Header >) { let harness = Harness :: < T , S > :: from_raw (ptr) ; harness . drop_reference () ; } . sig",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "MioSource",
                        "label": "MioSource",
                        "kind": "Struct",
                        "signature": "struct MioSource",
                        "file_path": "tokio/src/io/bsd/poll_aio.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "drop_jh_during_schedule",
                        "label": "drop_jh_during_schedule",
                        "kind": "Function",
                        "signature": "fn # [test] fn drop_jh_during_schedule () { unsafe fn waker_clone (ptr : * const ()) -> RawWaker { let atomic = unsafe { & * (ptr as * const AtomicUsize) } ; atomic . fetch_add (1 , Ordering :: Relaxed) ; RawWaker :: new (ptr , & VTABLE) } unsafe fn waker_drop (ptr : * const ()) { let atomic = unsafe { & * (ptr as * const AtomicUsize) } ; atomic . fetch_sub (1 , Ordering :: Relaxed) ; } unsafe fn waker_nop (_ptr : * const ()) { } static VTABLE : RawWakerVTable = RawWakerVTable :: new (waker_clone , waker_drop , waker_nop , waker_drop) ; loom :: model (| | { let rt = Builder :: new_current_thread () . build () . unwrap () ; let mut jh = rt . spawn (async { }) ; let task_refcnt = jh . abort_handle () ; let waker_refcnt = AtomicUsize :: new (1) ; { use std :: future :: Future ; use std :: pin :: Pin ; let join_waker = unsafe { Waker :: from_raw (RawWaker :: new ((& waker_refcnt) as * const AtomicUsize as * const () , & VTABLE ,)) } ; assert ! (Pin :: new (& mut jh) . poll (& mut Context :: from_waker (& join_waker)) . is_pending ()) ; } assert_eq ! (waker_refcnt . load (Ordering :: Relaxed) , 1) ; let bg_thread = loom :: thread :: spawn (move | | drop (jh)) ; rt . block_on (crate :: task :: yield_now ()) ; bg_thread . join () . unwrap () ; assert_eq ! (waker_refcnt . load (Ordering :: Relaxed) , 0) ; drop (task_refcnt) ; }) ; } . sig",
                        "file_path": "tokio/src/runtime/tests/loom_current_thread.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read_incomplete_head",
                        "label": "read_incomplete_head",
                        "kind": "Function",
                        "signature": "fn # [test] fn read_incomplete_head () { let io = FramedRead :: new (mock ! { data (b\"\\x00\\x00\") , } , LengthDelimitedCodec :: new () ,) ; pin_mut ! (io) ; assert_next_err ! (io) ; } . sig",
                        "file_path": "tokio-util/tests/length_delimited.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "set_twice",
                        "label": "set_twice",
                        "kind": "Function",
                        "signature": "fn # [test] fn set_twice () { static ONCE : OnceCell < u32 > = OnceCell :: const_new () ; let first = ONCE . set (5) ; assert_eq ! (first , Ok (())) ; let second = ONCE . set (6) ; assert ! (second . err () . unwrap () . is_already_init_err ()) ; } . sig",
                        "file_path": "tokio/tests/sync_once_cell.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "merge_size_hints",
                        "label": "merge_size_hints",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Merge the size hints from two streams.\"] fn merge_size_hints ((left_low , left_high) : (usize , Option < usize >) , (right_low , right_high) : (usize , Option < usize >) ,) -> (usize , Option < usize >) { let low = left_low . saturating_add (right_low) ; let high = match (left_high , right_high) { (Some (h1) , Some (h2)) => h1 . checked_add (h2) , _ => None , } ; (low , high) } . sig",
                        "file_path": "tokio-stream/src/stream_ext.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Error",
                        "label": "Error",
                        "kind": "Struct",
                        "signature": "struct Error",
                        "file_path": "tokio/src/time/error.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "copy_chunk_to_mem",
                        "label": "copy_chunk_to_mem",
                        "kind": "Function",
                        "signature": "fn fn copy_chunk_to_mem (c : & mut Criterion) { let rt = rt () ; c . bench_function (\"copy_chunk_to_mem\" , | b | { b . iter (| | { let task = | | async { let mut source = ChunkReader :: new (CHUNK_SIZE , READ_SERVICE_PERIOD) . take (SOURCE_SIZE) ; let mut dest = Vec :: new () ; copy (& mut source , & mut dest) . await . unwrap () ; } ; rt . block_on (task ()) ; }) }) ; } . sig",
                        "file_path": "benches/copy.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "InnerState",
                        "label": "InnerState",
                        "kind": "Struct",
                        "signature": "struct InnerState",
                        "file_path": "tokio/src/runtime/time/mod.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "main",
                        "label": "main",
                        "kind": "Function",
                        "signature": "fn # [cfg (not (all (tokio_unstable , tokio_taskdump , target_os = \"linux\" , any (target_arch = \"aarch64\" , target_arch = \"x86\" , target_arch = \"x86_64\"))))] fn main () { println ! (\"task dumps are not available\") } . sig",
                        "file_path": "examples/dump.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "SetCurrentGuard",
                        "label": "SetCurrentGuard",
                        "kind": "Struct",
                        "signature": "struct SetCurrentGuard",
                        "file_path": "tokio/src/runtime/context/current.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "UnboundedSender",
                        "label": "UnboundedSender",
                        "kind": "Struct",
                        "signature": "struct UnboundedSender",
                        "file_path": "tokio/src/sync/mpsc/unbounded.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "cancel_parent_and_child",
                        "label": "cancel_parent_and_child",
                        "kind": "Function",
                        "signature": "fn # [test] fn cancel_parent_and_child () { loom :: model (| | { let token1 = CancellationToken :: new () ; let token2 = token1 . clone () ; let child_token = token1 . child_token () ; let th1 = thread :: spawn (move | | { drop (token1) ; }) ; let th2 = thread :: spawn (move | | { token2 . cancel () ; }) ; let th3 = thread :: spawn (move | | { child_token . cancel () ; }) ; assert_ok ! (th1 . join ()) ; assert_ok ! (th2 . join ()) ; assert_ok ! (th3 . join ()) ; }) ; } . sig",
                        "file_path": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "read",
                        "label": "read",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn read () { let mut mock = Builder :: new () . read (b\"hello \") . read (b\"world!\") . build () ; let mut buf = [0 ; 256] ; let n = mock . read (& mut buf) . await . expect (\"read 1\") ; assert_eq ! (& buf [.. n] , b\"hello \") ; let n = mock . read (& mut buf) . await . expect (\"read 2\") ; assert_eq ! (& buf [.. n] , b\"world!\") ; } . sig",
                        "file_path": "tokio-test/tests/io.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "framed_half",
                        "label": "framed_half",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn framed_half () -> std :: io :: Result < () > { let a_soc = Arc :: new (UdpSocket :: bind (\"127.0.0.1:0\") . await ?) ; let b_soc = a_soc . clone () ; let a_addr = a_soc . local_addr () ? ; let b_addr = b_soc . local_addr () ? ; let mut a = UdpFramed :: new (a_soc , ByteCodec) ; let mut b = UdpFramed :: new (b_soc , LinesCodec :: new ()) ; let msg = b\"1\\r\\n2\\r\\n3\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; let msg = b\"4\\r\\n5\\r\\n6\\r\\n\" . to_vec () ; a . send ((& msg , b_addr)) . await ? ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"1\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"2\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"3\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"4\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"5\" . to_string () , a_addr)) ; assert_eq ! (b . next () . await . unwrap () . unwrap () , (\"6\" . to_string () , a_addr)) ; Ok (()) } . sig",
                        "file_path": "tokio-util/tests/udp.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_block_in_place2",
                        "label": "test_block_in_place2",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test (flavor = \"multi_thread\")] async fn test_block_in_place2 () { tokio :: task :: block_in_place (| | { }) ; } . sig",
                        "file_path": "tokio/tests/rt_threaded.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "write_vectored_large_total_on_vectored",
                        "label": "write_vectored_large_total_on_vectored",
                        "kind": "Function",
                        "signature": "fn # [tokio :: test] async fn write_vectored_large_total_on_vectored () { let msg = b\"foo bar baz\" ; let mut bufs = [IoSlice :: new (& msg [0 .. 4]) , IoSlice :: new (& msg [4 .. 8]) , IoSlice :: new (& msg [8 ..]) ,] ; let io_vec = IoBufs :: new (& mut bufs) ; let mut w = BufWriter :: with_capacity (8 , MockWriter :: vectored (10)) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 10) ; assert ! (w . buffer () . is_empty ()) ; let io_vec = io_vec . advance (n) ; let n = assert_ok ! (write_vectored (& mut w , & io_vec) . await) ; assert_eq ! (n , 1) ; assert ! (w . get_ref () . data . as_slice () == & msg [.. 10]) ; assert ! (w . buffer () == & msg [10 ..]) ; } . sig",
                        "file_path": "tokio/tests/io_buf_writer.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "test_enable_after_poll",
                        "label": "test_enable_after_poll",
                        "kind": "Function",
                        "signature": "fn # [test] fn test_enable_after_poll () { let notify = Arc :: new (Notify :: new ()) ; let mut future = spawn (notify . clone () . notified_owned ()) ; assert_pending ! (future . poll ()) ; future . enter (| _ , fut | assert ! (! fut . enable ())) ; } . sig",
                        "file_path": "tokio/tests/sync_notify_owned.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Task",
                        "label": "Task",
                        "kind": "Struct",
                        "signature": "struct Task",
                        "file_path": "tokio/tests/io_driver.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "lines_encoder",
                        "label": "lines_encoder",
                        "kind": "Function",
                        "signature": "fn # [test] fn lines_encoder () { let mut codec = LinesCodec :: new () ; let mut buf = BytesMut :: new () ; codec . encode (\"line 1\" , & mut buf) . unwrap () ; assert_eq ! (\"line 1\\n\" , buf) ; codec . encode (\"line 2\" , & mut buf) . unwrap () ; assert_eq ! (\"line 1\\nline 2\\n\" , buf) ; } . sig",
                        "file_path": "tokio-util/tests/codecs.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "Vtable",
                        "label": "Vtable",
                        "kind": "Struct",
                        "signature": "struct Vtable",
                        "file_path": "tokio/src/runtime/task/raw.rs",
                        "line": 0,
                        "icon": "📦"
                    }
                },
                {
                    "data": {
                        "id": "size_hint_without_upper",
                        "label": "size_hint_without_upper",
                        "kind": "Function",
                        "signature": "fn # [test] fn size_hint_without_upper () { let mut map = StreamMap :: new () ; map . insert (\"a\" , pin_box (stream :: iter (vec ! [1]))) ; map . insert (\"b\" , pin_box (stream :: iter (vec ! [1 , 2]))) ; map . insert (\"c\" , pin_box (pending ())) ; let size_hint = map . size_hint () ; assert_eq ! (size_hint , (3 , None)) ; } . sig",
                        "file_path": "tokio-stream/tests/stream_stream_map.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                },
                {
                    "data": {
                        "id": "shutdown",
                        "label": "shutdown",
                        "kind": "Function",
                        "signature": "fn # [doc = \" Creates a future which will shutdown an I/O object.\"] pub (super) fn shutdown < A > (a : & mut A) -> Shutdown < '_ , A > where A : AsyncWrite + Unpin + ? Sized , { Shutdown { a , _pin : PhantomPinned , } } . sig",
                        "file_path": "tokio/src/io/util/shutdown.rs",
                        "line": 0,
                        "icon": "🔧"
                    }
                }];
        const edges_data = [
            {
                "data": {
                    "source": "User",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Blocking",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Blocking",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SplitByUtf8BoundaryIfWindows",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "DuplexStream",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "DuplexStream",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SimplexStream",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SimplexStream",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MutexGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RwLockReadGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RwLockWriteGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SelectNormal",
                    "target": "RotatorSelect",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SelectBiased",
                    "target": "RotatorSelect",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ReadHalf",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "WriteHalf",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ReuniteError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedReadHalf",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedWriteHalf",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Child",
                    "target": "Kill",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ChildStdio",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ChildStdio",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "PidfdReaper",
                    "target": "Kill",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Reaper",
                    "target": "Kill",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Trace",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "TryCurrentError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Id",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Handle",
                    "target": "Overflow",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Symbol",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Tree",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Runtime",
                    "target": "Schedule",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OsExtraData",
                    "target": "Init",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Signal",
                    "target": "InternalStream",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OsStorage",
                    "target": "Init",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OsStorage",
                    "target": "Storage",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "AcquireError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "TryLockError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedMutexGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MappedMutexGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedMappedMutexGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SetOnceError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Semaphore",
                    "target": "Semaphore",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SendError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RecvError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedRwLockReadGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedRwLockWriteGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "OwnedRwLockMappedWriteGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RwLockMappedWriteGuard",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "AtomicWaker",
                    "target": "AssertSend",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "AtomicWaker",
                    "target": "AssertSync",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "AccessError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Error",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Elapsed",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MaybePending",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MaybePending",
                    "target": "AsyncBufRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MaybePending",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "MockWriter",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "R",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "W",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RW",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "RW",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "BadAsyncRead",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "UninitTest",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "BadReader",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Sender",
                    "target": "AssertSend",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Receiver",
                    "target": "AssertSend",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Receiver",
                    "target": "AssertRefUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Sender",
                    "target": "AssertRefUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "UnboundedReceiver",
                    "target": "AssertRefUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "UnboundedSender",
                    "target": "AssertRefUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "WeakUnboundedSender",
                    "target": "AssertRefUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Receiver",
                    "target": "AssertUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Sender",
                    "target": "AssertUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "UnboundedReceiver",
                    "target": "AssertUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "UnboundedSender",
                    "target": "AssertUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "WeakUnboundedSender",
                    "target": "AssertUnwindSafe",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Notify",
                    "target": "AssertSend",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Sender",
                    "target": "SenderExt",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Mock",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Mock",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "PanicMsgSnippet",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ThreadWaker",
                    "target": "Wake",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Runtime",
                    "target": "RuntimeExt",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "LengthDelimitedCodec",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "LengthDelimitedCodec",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "LengthDelimitedCodecError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "LinesCodec",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "LinesCodec",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "StreamReader",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "StreamReader",
                    "target": "AsyncBufRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "PollSendError",
                    "target": "Display",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U32Codec",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U32Codec",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U64Codec",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U64Codec",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "DontReadIntoThis",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U32Decoder",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U64Decoder",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U32Encoder",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "U64Encoder",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SmallReader",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SmallWriter",
                    "target": "AsyncWrite",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "Reader",
                    "target": "AsyncRead",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "SliceEncoder",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ByteCodec",
                    "target": "Decoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            },
            {
                "data": {
                    "source": "ByteCodec",
                    "target": "Encoder",
                    "kind": "Implements",
                    "arrow_style": "dashed"
                }
            }];

        // Cytoscape initialization with performance optimizations
        const cy = cytoscape({
            container: document.getElementById('cy'),

            // Data
            elements: [
                ...nodes_data,
                ...edges_data
            ],

            // Simple reliable layout that works everywhere
            layout: {
                name: 'breadthfirst',
                directed: true,
                animate: false,
                fit: true,
                padding: 50,
                spacingFactor: 1.2
            },

            // Performance optimizations
            pixelRatio: 1,
            textureOnViewport: false,
            wheelSensitivity: 0.5,
            minZoom: 0.1,
            maxZoom: 3.0
        });

        // Basic styling
        cy.style([
            {
                selector: 'node',
                style: {
                    'background-color': '#74c0fc',
                    'label': 'data(label)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '11px',
                    'color': '#333',
                    'shape': 'round-rectangle',
                    'width': 140,
                    'height': 70,
                    'border-width': 2,
                    'border-color': '#1971c2'
                }
            },
            {
                selector: 'edge',
                style: {
                    'curve-style': 'bezier',
                    'line-color': '#999',
                    'target-arrow-color': '#999',
                    'target-arrow-shape': 'triangle',
                    'width': 2
                }
            }
        ]);

        // Performance monitoring
        cy.ready(function() {
            const renderTime = performance.now() - renderStartTime;
            const nodeCount = cy.nodes().length;
            const edgeCount = cy.edges().length;

            document.getElementById('status').innerHTML =
                '<span class="performance-info">✅ Rendered ' + nodeCount + ' nodes, ' +
                edgeCount + ' edges in ' + renderTime.toFixed(1) + 'ms</span>';
        });

        // Level-of-detail: Update labels based on zoom level
        cy.on('zoom', function(evt) {
            const zoom = cy.zoom();
            const showLabels = zoom >= 1.2;

            cy.nodes().forEach(function(node) {
                const label = showLabels ? node.data('label') : node.data('icon');
                node.style('label', label);
            });
        });

        // Performance monitoring: interaction latency
        cy.on('pan zoom', function(evt) {
            const latency = performance.now() - evt.timeStamp;
            if (latency > 16) { // 60fps threshold
                console.warn('Interaction latency: ' + latency.toFixed(1) + 'ms');
            }
        });

        // Tooltip functionality
        cy.on('mouseover', 'node', function(evt) {
            const node = evt.target;
            const tooltip = document.createElement('div');
            tooltip.style.position = 'absolute';
            tooltip.style.background = 'rgba(0, 0, 0, 0.8)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px';
            tooltip.style.borderRadius = '4px';
            tooltip.style.fontSize = '12px';
            tooltip.style.pointerEvents = 'none';
            tooltip.style.zIndex = '1000';
            tooltip.style.opacity = '0';
            tooltip.style.transition = 'opacity 0.2s';

            tooltip.innerHTML = '<strong>' + node.data('label') + '</strong><br>' +
                               node.data('kind') + '<br>' +
                               'File: ' + (node.data('file') || 'Unknown') + '<br>' +
                               'Line: ' + (node.data('line') || 'Unknown');

            document.body.appendChild(tooltip);

            const rect = cy.container().getBoundingClientRect();
            tooltip.style.left = (rect.left + evt.renderedPosition.x + 10) + 'px';
            tooltip.style.top = (rect.top + evt.renderedPosition.y - 10) + 'px';

            setTimeout(() => { tooltip.style.opacity = '1'; }, 10);

            node.data('tooltip', tooltip);
        });

        cy.on('mouseout', 'node', function(evt) {
            const node = evt.target;
            const tooltip = node.data('tooltip');
            if (tooltip) {
                tooltip.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(tooltip);
                    node.removeData('tooltip');
                }, 200);
            }
        });

        // UI Functions
        function searchNodes() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            if (!searchTerm) {
                cy.elements().unselect();
                cy.fit();
                return;
            }

            const matchingNodes = cy.nodes().filter(function(node) {
                return node.data('label').toLowerCase().includes(searchTerm) ||
                       node.data('file_path').toLowerCase().includes(searchTerm);
            });

            cy.elements().unselect();
            matchingNodes.select();

            if (matchingNodes.length > 0) {
                cy.fit(matchingNodes, 50);
                document.getElementById('status').innerHTML =
                    '<span class="performance-info">🔍 Found ' + matchingNodes.length + ' matching nodes</span>';
            } else {
                document.getElementById('status').innerHTML =
                    '<span class="error-info">❌ No nodes found</span>';
            }
        }

        function resetView() {
            cy.elements().unselect();
            cy.fit();
            document.getElementById('search').value = '';
            document.getElementById('status').innerHTML = 'View reset';
        }

        function fitToScreen() {
            cy.fit();
            document.getElementById('status').innerHTML = 'Fitted to screen';
        }

        function toggleLabels() {
            cy.nodes().forEach(function(node) {
                const currentLabel = node.style('label');
                const newLabel = currentLabel === node.data('icon') ? node.data('label') : node.data('icon');
                node.style('label', newLabel);
            });
            document.getElementById('status').innerHTML = 'Labels toggled';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT') return; // Ignore when typing in search

            switch(e.key.toLowerCase()) {
                case 'f':
                    e.preventDefault();
                    document.getElementById('search').focus();
                    break;
                case 'r':
                    e.preventDefault();
                    resetView();
                    break;
                case 'l':
                    e.preventDefault();
                    toggleLabels();
                    break;
            }
        });
    </script>

</body>
</html>