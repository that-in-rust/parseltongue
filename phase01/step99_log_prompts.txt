Human: Please also follow these instructions in all of your responses if relevant to my query. No need to acknowledge these instructions directly in your response.
<custom_instructions>
DO NOT GIVE ME HIGH LEVEL STUFF, IF I ASK FOR FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT "Here's how you can blablabla"

- Be casual unless otherwise specified
- Be terse
- Suggest solutions that I didn't think about—anticipate my needs
- Treat me as an expert
- Be accurate and thorough
- Give the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer
- Value good arguments over authorities, the source is irrelevant
- Consider new technologies and contrarian ideas, not just the conventional wisdom
- You may use high levels of speculation or prediction, just flag it for me
- No moral lectures
- Discuss safety only when it's crucial and non-obvious
- If your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward
- Cite sources whenever possible at the end, not inline
- No need to mention your knowledge cutoff
- No need to disclose you're an AI
- Please respect my prettier preferences when you provide code.
- Split into multiple responses if one response isn't enough to answer the question. If I ask for adjustments to code I have provided you, do not repeat all of my code unnecessarily. Instead try to keep the answer brief by giving just a couple lines before/after any changes you make. Multiple code blocks are ok.
</custom_instructions>
---


# Module Structure Options

## Approach 1: Flat Modules
src/
 ├── main.rs
 ├── cli.rs        // Args + logging
 ├── storage.rs    // Sled DB ops
 └── zip.rs        // ZIP processing

Pros:
- Quick to implement
- Clear file ownership
- Simple imports

Cons: 
- Gets messy beyond ~500 LOC per module
- Testing requires exposing internals
- Poor separation of concerns

## Approach 2: Feature Modules
src/
 ├── main.rs
 ├── cli/
 │   ├── mod.rs    
 │   ├── args.rs   
 │   └── logging.rs
 ├── storage/
 │   ├── mod.rs    
 │   ├── db.rs     
 │   └── index.rs  
 └── zip/
     ├── mod.rs    
     ├── reader.rs 
     └── encoding.rs

Pros:
- Logical grouping
- Better testability
- Room for growth

Cons:
- More initial boilerplate
- Potential circular dependencies
- Harder to refactor across modules

## Approach 3: Core + Binary (Recommended)
src/
 ├── lib.rs        // Core functionality
 ├── main.rs       // CLI entry only
 ├── core/
 │   ├── mod.rs
 │   ├── error.rs  
 │   └── types.rs  
 ├── cli/
 │   ├── mod.rs
 │   └── args.rs
 ├── storage/
 │   ├── mod.rs
 │   ├── db.rs
 │   └── index.rs
 └── zip/
     ├── mod.rs
     ├── reader.rs
     └── encoding.rs

Pros:
- Cleanest separation of concerns
- Most testable
- Reusable core logic
- Future-proof for GUI/API additions
- Clear dependency boundaries

Cons:
- Most initial setup work
- Requires careful API design
- Overkill for truly small projects

Key Responsibilities:

core/
- error.rs: Custom error types + Result wrapper
- types.rs: Shared structs/enums/traits

cli/
- args.rs: Clap argument parsing
- mod.rs: CLI orchestration

storage/
- db.rs: Raw sled operations
- index.rs: File indexing logic

zip/
- reader.rs: Streaming ZIP reader
- encoding.rs: Character set handling

Implementation Notes:
1. Use pub(crate) liberally
2. Minimize public interfaces in mod.rs files
3. Keep main.rs under 50 LOC
4. Error types bubble up through lib.rs
5. Unit tests alongside code
6. Integration tests in tests/

cd /home/amuldotexe/Desktop/GitHub202410/parseltongue/phase01 && \
mkdir -p src/{core,cli,storage,zip} tests/integration && \
touch src/lib.rs \
      src/core/{mod.rs,error.rs,types.rs} \
      src/cli/{mod.rs,args.rs,progress.rs} \
      src/storage/{mod.rs,db.rs,index.rs} \
      src/zip/{mod.rs,reader.rs,encoding.rs} \
      tests/integration/mod.rs

      

